[{"base":"plugins","rel":"wordfence\/lib\/wfDiagnostic.php","ext":"php","size":68635,"mtime":1757312769,"type":"text","content":"<?php\n\nrequire_once __DIR__ . '\/wfCurlInterceptor.php';\n\nclass wfGrant\n{\n\tpublic $select = false;\n\tpublic $update = false;\n\tpublic $insert = false;\n\tpublic $delete = false;\n\tpublic $alter = false;\n\tpublic $create = false;\n\tpublic $drop = false;\n\n\tpublic static function get()\n\t{\n\t\tstatic $instance;\n\t\tif ($instance === null) {\n\t\t\t$instance = new self;\n\t\t}\n\t\treturn $instance;\n\t}\n\t\n\tprivate function __construct()\n\t{\n\t\tglobal $wpdb;\n\t\t$rows = $wpdb->get_results(\"SHOW GRANTS FOR current_user()\", ARRAY_N);\n\t\t\n\t\tforeach ($rows as $row) {\n\t\t\tpreg_match(\"\/GRANT (.+) ON (.+) TO\/\", $row[0], $matches);\n\t\t\tforeach (explode(\",\", $matches[1]) as $permission) {\n\t\t\t\t$permission = str_replace(\" \", \"_\", trim(strtolower($permission)));\n\t\t\t\tif ($permission === 'all_privileges') {\n\t\t\t\t\tforeach ($this as $key => $value) {\n\t\t\t\t\t\t$this->$key = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak 2;\n\t\t\t\t}\n\t\t\t\tif (property_exists($this, $permission))\n\t\t\t\t\t$this->$permission = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass wfDiagnostic\n{\n\tprotected $description = false; \/\/Defined in the constructor to allow for localization\n\n\tprotected $results = array();\n\n\tpublic function __construct()\n\t{\n\t\trequire(dirname(__FILE__) . '\/wfVersionSupport.php'); \/** @var $wfPHPMinimumVersion *\/\n\t\t$this->description = array(\n\t\t\t'Wordfence Status' => array(\n\t\t\t\t'description' => __('General information about the Wordfence installation.', 'wordfence'),\n\t\t\t\t'tests' => array(\n\t\t\t\t\t'wfVersion' => __('Wordfence Version', 'wordfence'),\n\t\t\t\t\t'geoIPVersion' => __('GeoIP Version', 'wordfence'),\n\t\t\t\t\t'cronStatus' => __('Cron Status', 'wordfence'),\n\t\t\t\t),\n\t\t\t),\n\t\t\t'Filesystem' => array(\n\t\t\t\t'description' => __('Ability to read\/write various files.', 'wordfence'),\n\t\t\t\t'tests' => array(\n\t\t\t\t\t'isPluginReadable' => __('Checking if web server can read from <code>~\/plugins\/wordfence<\/code>', 'wordfence'),\n\t\t\t\t\t'isPluginWritable' => __('Checking if web server can write to <code>~\/plugins\/wordfence<\/code>', 'wordfence'),\n\t\t\t\t\t'isWAFReadable' => __('Checking if web server can read from <code>~\/wp-content\/wflogs<\/code>', 'wordfence'),\n\t\t\t\t\t'isWAFWritable' => __('Checking if web server can write to <code>~\/wp-content\/wflogs<\/code>', 'wordfence'),\n\t\t\t\t),\n\t\t\t),\n\t\t\t'Wordfence Config' => array(\n\t\t\t\t'description' => __('Ability to save Wordfence settings to the database.', 'wordfence'),\n\t\t\t\t'tests' => array(\n\t\t\t\t\t'configWritableSet' => __('Checking basic config reading\/writing', 'wordfence'),\n\t\t\t\t\t'configWritableSetSer' => __('Checking serialized config reading\/writing', 'wordfence'),\n\t\t\t\t),\n\t\t\t),\n\t\t\t'Wordfence Firewall' => array(\n\t\t\t\t'description' => __('Current WAF configuration.', 'wordfence'),\n\t\t\t\t'tests' => array(\n\t\t\t\t\t'wafAutoPrepend' => __('WAF auto prepend active', 'wordfence'),\n\t\t\t\t\t'wafStorageEngine' => __('Configured WAF storage engine (WFWAF_STORAGE_ENGINE)', 'wordfence'),\n\t\t\t\t\t'wafActiveStorageEngine' => __('Active WAF storage engine', 'wordfence'),\n\t\t\t\t\t'wafLogPath' => __('WAF log path', 'wordfence'),\n\t\t\t\t\t'wafSubdirectoryInstall' => __('WAF subdirectory installation', 'wordfence'),\n\t\t\t\t\t'wafAutoPrependPathOverride' => __('WORDFENCE_WAF_PREPEND_DIRECTORY path constant', 'wordfence'),\n\t\t\t\t\t'wafAutoPrependFilePath' => __('wordfence-waf.php path', 'wordfence'),\n\t\t\t\t\t'wafFilePermissions' => __('WAF File Permissions', 'wordfence'),\n\t\t\t\t\t'wafRecentlyRemoved' => __('Recently removed wflogs files', 'wordfence'),\n\t\t\t\t\t'wafLoaded' => __('WAF Loaded Successfully', 'wordfence'),\n\t\t\t\t\t'wafAutoPrependHtaccess' => __('WAF .htaccess contents', 'wordfence'),\n\t\t\t\t\t'wafAutoPrependUserIni' => __('WAF .user.ini contents', 'wordfence'),\n\t\t\t\t\t'wafAutoPrependHtaccessOther' => __('.htaccess other auto prepend', 'wordfence'),\n\t\t\t\t\t'wafAutoPrependUserIniOther' => __('.user.ini other auto prepend', 'wordfence'),\n\t\t\t\t),\n\t\t\t),\n\t\t\t'MySQL' => array(\n\t\t\t\t'description' => __('Database version and privileges.', 'wordfence'),\n\t\t\t\t'tests' => array(\n\t\t\t\t\t'databaseVersion' => __('Database Version', 'wordfence'),\n\t\t\t\t\t'userCanDelete' => __('Checking if MySQL user has <code>DELETE<\/code> privilege', 'wordfence'),\n\t\t\t\t\t'userCanInsert' => __('Checking if MySQL user has <code>INSERT<\/code> privilege', 'wordfence'),\n\t\t\t\t\t'userCanUpdate' => __('Checking if MySQL user has <code>UPDATE<\/code> privilege', 'wordfence'),\n\t\t\t\t\t'userCanSelect' => __('Checking if MySQL user has <code>SELECT<\/code> privilege', 'wordfence'),\n\t\t\t\t\t'userCanCreate' => __('Checking if MySQL user has <code>CREATE TABLE<\/code> privilege', 'wordfence'),\n\t\t\t\t\t'userCanAlter'  => __('Checking if MySQL user has <code>ALTER TABLE<\/code> privilege', 'wordfence'),\n\t\t\t\t\t'userCanDrop'   => __('Checking if MySQL user has <code>DROP<\/code> privilege', 'wordfence'),\n\t\t\t\t\t'userCanTruncate'   => __('Checking if MySQL user has <code>TRUNCATE<\/code> privilege', 'wordfence'),\n\t\t\t\t)\n\t\t\t),\n\t\t\t'PHP Environment' => array(\n\t\t\t\t'description' => __('PHP version, important PHP extensions.', 'wordfence'),\n\t\t\t\t'tests' => array(\n\t\t\t\t\t'phpVersion' => array('raw' => true, 'value' => wp_kses(sprintf(\/* translators: 1. PHP version, 2. Support URL. *\/ __('PHP version >= PHP %s<br><em> (<a href=\"https:\/\/wordpress.org\/about\/requirements\/\" target=\"_blank\" rel=\"noopener noreferrer\">WordPress requirements<\/a>)<\/em> <a href=\"%s\" target=\"_blank\" rel=\"noopener noreferrer\" class=\"wfhelp\"><span class=\"screen-reader-text\"> (opens in new tab)<\/span><\/a>', 'wordfence'), $wfPHPMinimumVersion, wfSupportController::esc_supportURL(wfSupportController::ITEM_VERSION_PHP)), array('a'=>array('href'=>array(), 'target'=>array(), 'rel'=>array(), 'class'=>array()), 'span'=>array('class'=>array())))),\n\t\t\t\t\t'processOwner' => __('Process Owner', 'wordfence'),\n\t\t\t\t\t'hasOpenSSL' => __('Checking for OpenSSL support', 'wordfence'),\n\t\t\t\t\t'openSSLVersion' => __('Checking OpenSSL version', 'wordfence'),\n\t\t\t\t\t'hasCurl'    => __('Checking for cURL support', 'wordfence'),\n\t\t\t\t\t'curlFeatures'    => __('cURL Features Code', 'wordfence'),\n\t\t\t\t\t'curlHost'    => __('cURL Host', 'wordfence'),\n\t\t\t\t\t'curlProtocols'    => __('cURL Support Protocols', 'wordfence'),\n\t\t\t\t\t'curlSSLVersion'    => __('cURL SSL Version', 'wordfence'),\n\t\t\t\t\t'curlLibZVersion'    => __('cURL libz Version', 'wordfence'),\n\t\t\t\t\t'displayErrors' => array('raw' => true, 'value' => wp_kses(__('Checking <code>display_errors<\/code><br><em> (<a href=\"http:\/\/php.net\/manual\/en\/errorfunc.configuration.php#ini.display-errors\" target=\"_blank\" rel=\"noopener noreferrer\">Should be disabled on production servers<span class=\"screen-reader-text\"> (opens in new tab)<\/span><\/a>)<\/em>', 'wordfence'), array('a'=>array('href'=>array(), 'target'=>array(), 'rel'=>array()), 'span'=>array('class'=>array()), 'em'=>array(), 'code'=>array(), 'br'=>array()))),\n\t\t\t\t)\n\t\t\t),\n\t\t\t'Connectivity' => array(\n\t\t\t\t'description' => __('Ability to connect to the Wordfence servers and your own site.', 'wordfence'),\n\t\t\t\t'tests' => array(\n\t\t\t\t\t'connectToServer2' => __('Connecting to Wordfence servers (https)', 'wordfence'),\n\t\t\t\t\t'connectToSelf' => __('Connecting back to this site', 'wordfence'),\n\t\t\t\t\t'connectToSelfIpv6' => array('raw' => true, 'value' => wp_kses(sprintf(__('Connecting back to this site via IPv6 (Not required; this may not be an issue on some sites. <a href=\"%s\" target=\"_blank\" rel=\"noopener noreferrer\" class=\"wfhelp\"><span class=\"wfhelpextra\">Click here to learn whether this is an issue<\/span><\/a>)', 'wordfence'), wfSupportController::esc_supportURL(wfSupportController::ITEM_DIAGNOSTICS_IPV6)), array('a'=>array('href'=>array(), 'target'=>array(), 'rel'=>array(), 'class'=>array()), 'span'=>array('class'=>array())))),\n\t\t\t\t\t'serverIP' => __('IP(s) used by this server', 'wordfence'),\n\t\t\t\t)\n\t\t\t),\n\t\t\t'Time' => array(\n\t\t\t\t'description' => __('Server time accuracy and applied offsets.', 'wordfence'),\n\t\t\t\t'tests' => array(\n\t\t\t\t\t'wfTime' => __('Wordfence Network Time', 'wordfence'),\n\t\t\t\t\t'serverTime' => __('Server Time', 'wordfence'),\n\t\t\t\t\t'wfTimeOffset' => __('Wordfence Network Time Offset', 'wordfence'),\n\t\t\t\t\t'ntpTimeOffset' => __('NTP Time Offset', 'wordfence'),\n\t\t\t\t\t'ntpStatus' => __('NTP Status', 'wordfence'),\n\t\t\t\t\t'timeSourceInUse' => __('TOTP Time Source', 'wordfence'),\n\t\t\t\t\t'wpTimeZone' => __('WordPress Time Zone', 'wordfence'),\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\t\t\n\t\tforeach ($this->description as $title => $tests) {\n\t\t\t$this->results[$title] = array(\n\t\t\t\t'description' => $tests['description'],\n\t\t\t);\n\t\t\tforeach ($tests['tests'] as $name => $description) {\n\t\t\t\tif (!method_exists($this, $name)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t$result = $this->$name();\n\n\t\t\t\tif (is_bool($result)) {\n\t\t\t\t\t$result = array(\n\t\t\t\t\t\t'test'    => $result,\n\t\t\t\t\t\t'message' => $result ? 'OK' : 'FAIL',\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t$result['label'] = $description;\n\t\t\t\t$result['name'] = $name;\n\n\t\t\t\t$this->results[$title]['results'][] = $result;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic function getResults()\n\t{\n\t\treturn $this->results;\n\t}\n\t\n\tpublic function wfVersion() {\n\t\treturn array('test' => true, 'message' => WORDFENCE_VERSION . ' (' . WORDFENCE_BUILD_NUMBER . ')');\n\t}\n\t\n\tpublic function geoIPVersion() {\n\t\treturn array('test' => true, 'infoOnly' => true, 'message' => wfUtils::geoIPVersion());\n\t}\n\t\n\tpublic function cronStatus() {\n\t\t$cron = _get_cron_array();\n\t\t$overdue = 0;\n\t\tforeach ($cron as $timestamp => $values) {\n\t\t\tif (is_array($values)) {\n\t\t\t\tforeach ($values as $cron_job => $v) {\n\t\t\t\t\tif (is_numeric($timestamp)) {\n\t\t\t\t\t\tif ((time() - 1800) > $timestamp) { $overdue++; }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn array('test' => true, 'infoOnly' => true, 'message' => $overdue ? sprintf(\/* translators: Number of jobs. *\/ _n('%d Job Overdue', '%d Jobs Overdue', $overdue, 'wordfence'), $overdue) : __('Normal', 'wordfence'));\n\t}\n\t\n\tpublic function geoIPError() {\n\t\t$error = wfUtils::last_error('geoip');\n\t\treturn array('test' => true, 'infoOnly' => true, 'message' => $error ? $error : __('None', 'wordfence'));\n\t}\n\n\tpublic function isPluginReadable() {\n\t\treturn is_readable(WORDFENCE_PATH);\n\t}\n\n\tpublic function isPluginWritable() {\n\t\treturn is_writable(WORDFENCE_PATH);\n\t}\n\t\n\tpublic function isWAFReadable() {\n\t\tif (!is_readable(WFWAF_LOG_PATH)) {\n\t\t\tif (defined('WFWAF_STORAGE_ENGINE') && WFWAF_STORAGE_ENGINE == 'mysqli') {\n\t\t\t\treturn array('test' => false, 'infoOnly' => true, 'message' => __('No files readable', 'wordfence'));\n\t\t\t}\n\t\t\t\n\t\t\treturn array('test' => false, 'message' => __('No files readable', 'wordfence'));\n\t\t}\n\t\t\n\t\t$files = array(\n\t\t\tWFWAF_LOG_PATH . 'attack-data.php', \n\t\t\tWFWAF_LOG_PATH . 'ips.php', \n\t\t\tWFWAF_LOG_PATH . 'config.php',\n\t\t\tWFWAF_LOG_PATH . 'rules.php',\n\t\t);\n\t\t$unreadable = array();\n\t\tforeach ($files as $f) {\n\t\t\tif (!file_exists($f)) {\n\t\t\t\t$unreadable[] = sprintf(__('File \"%s\" does not exist', 'wordfence'), basename($f));\n\t\t\t}\n\t\t\telse if (!is_readable($f)) {\n\t\t\t\t$unreadable[] = sprintf(\/* translators: File path. *\/ __('File \"%s\" is unreadable', 'wordfence'), basename($f));\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (count($unreadable) > 0) {\n\t\t\tif (defined('WFWAF_STORAGE_ENGINE') && WFWAF_STORAGE_ENGINE == 'mysqli') {\n\t\t\t\treturn array('test' => false, 'infoOnly' => true, 'message' => implode(', ', $unreadable));\n\t\t\t}\n\t\t\t\n\t\t\treturn array('test' => false, 'message' => implode(', ', $unreadable));\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic function isWAFWritable() {\n\t\tif (!is_writable(WFWAF_LOG_PATH)) {\n\t\t\tif (defined('WFWAF_STORAGE_ENGINE') && WFWAF_STORAGE_ENGINE == 'mysqli') {\n\t\t\t\treturn array('test' => false, 'infoOnly' => true, 'message' => __('No files writable', 'wordfence'));\n\t\t\t}\n\t\t\t\n\t\t\treturn array('test' => false, 'message' => __('No files writable', 'wordfence'));\n\t\t}\n\t\t\n\t\t$files = array(\n\t\t\tWFWAF_LOG_PATH . 'attack-data.php',\n\t\t\tWFWAF_LOG_PATH . 'ips.php',\n\t\t\tWFWAF_LOG_PATH . 'config.php',\n\t\t\tWFWAF_LOG_PATH . 'rules.php',\n\t\t);\n\t\t$unwritable = array();\n\t\tforeach ($files as $f) {\n\t\t\tif (!file_exists($f)) {\n\t\t\t\t$unwritable[] = sprintf(\/* translators: File name. *\/__('File \"%s\" does not exist', 'wordfence'), basename($f));\n\t\t\t}\n\t\t\telse if (!is_writable($f)) {\n\t\t\t\t$unwritable[] = sprintf(\/* translators: File name. *\/__('File \"%s\" is unwritable', 'wordfence'), basename($f));\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (count($unwritable) > 0) {\n\t\t\tif (defined('WFWAF_STORAGE_ENGINE') && WFWAF_STORAGE_ENGINE == 'mysqli') {\n\t\t\t\treturn array('test' => false, 'infoOnly' => true, 'message' => implode(', ', $unwritable));\n\t\t\t}\n\t\t\t\n\t\t\treturn array('test' => false, 'message' => implode(', ', $unwritable));\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic function databaseVersion() {\n\t\tglobal $wpdb;\n\t\t$version = $wpdb->get_var(\"SELECT VERSION()\");\n\t\treturn array('test' => true, 'message' => $version);\n\t}\n\n\tpublic function userCanInsert() {\n\t\treturn wfGrant::get()->insert;\n\t}\n\t\n\tpublic function userCanUpdate() {\n\t\treturn wfGrant::get()->update;\n\t}\n\n\tpublic function userCanDelete() {\n\t\treturn wfGrant::get()->delete;\n\t}\n\n\tpublic function userCanSelect() {\n\t\treturn wfGrant::get()->select;\n\t}\n\n\tpublic function userCanCreate() {\n\t\treturn wfGrant::get()->create;\n\t}\n\n\tpublic function userCanDrop() {\n\t\treturn wfGrant::get()->drop;\n\t}\n\n\tpublic function userCanTruncate() {\n\t\treturn wfGrant::get()->drop && wfGrant::get()->delete;\n\t}\n\n\tpublic function userCanAlter() {\n\t\treturn wfGrant::get()->alter;\n\t}\n\n\tpublic function phpVersion()\n\t{\n\t\trequire(dirname(__FILE__) . '\/wfVersionSupport.php'); \/** @var $wfPHPMinimumVersion *\/\n\t\treturn array(\n\t\t\t'test' => version_compare(phpversion(), $wfPHPMinimumVersion, '>='),\n\t\t\t'message'  => phpversion(),\n\t\t);\n\t}\n\t\n\tpublic function configWritableSet() {\n\t\tglobal $wpdb;\n\t\t$show = $wpdb->hide_errors();\n\t\t$val = md5(time());\n\t\twfConfig::set('configWritingTest', $val, wfConfig::DONT_AUTOLOAD);\n\t\t$testVal = wfConfig::get('configWritingTest');\n\t\t$wpdb->show_errors($show);\n\t\treturn array(\n\t\t\t'test' => ($val === $testVal),\n\t\t\t'message' => __('Basic config writing', 'wordfence')\n\t\t);\n\t}\n\tpublic function configWritableSetSer() {\n\t\tglobal $wpdb;\n\t\t$show = $wpdb->hide_errors();\n\t\t$val = md5(time());\n\t\twfConfig::set_ser('configWritingTest_ser', array($val), false, wfConfig::DONT_AUTOLOAD);\n\t\t$testVal = wfUtils::array_first(wfConfig::get_ser('configWritingTest_ser', array(), false));\n\t\t$wpdb->show_errors($show);\n\t\treturn array(\n\t\t\t'test' => ($val === $testVal),\n\t\t\t'message' => __('Serialized config writing', 'wordfence')\n\t\t);\n\t}\n\n\tpublic function wafAutoPrepend() {\n\t\treturn array('test' => true, 'infoOnly' => true, 'message' => (defined('WFWAF_AUTO_PREPEND') && WFWAF_AUTO_PREPEND ? __('Yes', 'wordfence') : __('No', 'wordfence')));\n\t}\n\tpublic function wafAutoPrependHtaccess() {\n\t\t$htaccessPath = wfWAFAutoPrependHelper::getHtaccessPath();\n\t\tif (!file_exists($htaccessPath)) {\n\t\t\treturn array('test' => true, 'infoOnly' => true, 'message' => __('(.htaccess not present)', 'wordfence'));\n\t\t}\n\t\telse if (!is_readable($htaccessPath)) {\n\t\t\treturn array('test' => true, 'infoOnly' => true, 'message' => __('(.htaccess not readable)', 'wordfence'));\n\t\t}\n\t\t\n\t\t$htaccessContents = file_get_contents($htaccessPath);\n\t\t$section = wfWAFAutoPrependHelper::getHtaccessSectionContent($htaccessContents);\n\t\tif ($section === false) {\n\t\t\treturn array('test' => true, 'infoOnly' => true, 'message' => __('(not set)', 'wordfence'));\n\t\t}\n\t\t\n\t\t$snippet = wfUtils::pregExtract(\"\/auto_prepend_file\\s+['\\\"]?[^'\\\"]*['\\\"]?\/\", $section);\n\t\treturn array('test' => true, 'infoOnly' => true, 'message' => $snippet, 'detail' => array('escaped' => nl2br(esc_html($section)), 'textonly' => $section));\n\t}\n\tpublic function wafAutoPrependHtaccessOther() {\n\t\t$htaccessPath = wfWAFAutoPrependHelper::getHtaccessPath();\n\t\tif (!file_exists($htaccessPath)) {\n\t\t\treturn array('test' => true, 'infoOnly' => true, 'message' => __('(.htaccess not present)', 'wordfence'));\n\t\t}\n\t\telse if (!is_readable($htaccessPath)) {\n\t\t\treturn array('test' => true, 'infoOnly' => true, 'message' => __('(.htaccess not readable)', 'wordfence'));\n\t\t}\n\t\t\n\t\t$htaccessContents = file_get_contents($htaccessPath);\n\t\t$section = wfWAFAutoPrependHelper::getHtaccessSectionContent($htaccessContents);\n\t\tif ($section !== false) {\n\t\t\t$htaccessContents = str_replace($section, '', $htaccessContents);\n\t\t}\n\t\t\n\t\t$snippet = wfUtils::pregExtract(\"\/auto_prepend_file\\s+['\\\"]?[^'\\\"]*['\\\"]?\/\", $htaccessContents, true);\n\t\treturn array('test' => true, 'infoOnly' => true, 'message' => ($snippet === false ? __('(not present)', 'wordfence') : trim($snippet)));\n\t}\n\tpublic function wafAutoPrependUserIni() {\n\t\t$userIniPath = wfWAFAutoPrependHelper::getUserIniPath();\n\t\tif (!file_exists($userIniPath)) {\n\t\t\treturn array('test' => true, 'infoOnly' => true, 'message' => __('(.user.ini not present)', 'wordfence'));\n\t\t}\n\t\telse if (!is_readable($userIniPath)) {\n\t\t\treturn array('test' => true, 'infoOnly' => true, 'message' => __('(.user.ini not readable)', 'wordfence'));\n\t\t}\n\t\t\n\t\t$userIniContents = file_get_contents($userIniPath);\n\t\t$section = wfWAFAutoPrependHelper::getUserIniSectionContent($userIniContents);\n\t\tif ($section === false) {\n\t\t\treturn array('test' => true, 'infoOnly' => true, 'message' => __('(not set)', 'wordfence'));\n\t\t}\n\t\t\n\t\t$snippet = wfUtils::pregExtract(\"\/auto_prepend_file\\s*=\\s*['\\\"]?[^'\\\"]*['\\\"]?\/\", $section);\n\t\treturn array('test' => true, 'infoOnly' => true, 'message' => $snippet, 'detail' => $section);\n\t}\n\tpublic function wafAutoPrependUserIniOther() {\n\t\t$userIniPath = wfWAFAutoPrependHelper::getUserIniPath();\n\t\tif (!file_exists($userIniPath)) {\n\t\t\treturn array('test' => true, 'infoOnly' => true, 'message' => __('(.user.ini not present)', 'wordfence'));\n\t\t}\n\t\telse if (!is_readable($userIniPath)) {\n\t\t\treturn array('test' => true, 'infoOnly' => true, 'message' => __('(.user.ini not readable)', 'wordfence'));\n\t\t}\n\t\t\n\t\t$userIniContents = file_get_contents($userIniPath);\n\t\t$section = wfWAFAutoPrependHelper::getUserIniSectionContent($userIniContents);\n\t\tif ($section !== false) {\n\t\t\t$userIniContents = str_replace($section, '', $userIniContents);\n\t\t}\n\t\t\n\t\t$snippet = wfUtils::pregExtract(\"\/auto_prepend_file\\s*=\\s*['\\\"]?[^'\\\"]*['\\\"]?\/\", $userIniContents, true); \n\t\treturn array('test' => true, 'infoOnly' => true, 'message' => ($snippet === false ? __('(not present)', 'wordfence') : trim($snippet)));\n\t}\n\tpublic function wafStorageEngine() {\n\t\treturn array('test' => true, 'infoOnly' => true, 'message' => (defined('WFWAF_STORAGE_ENGINE') ? WFWAF_STORAGE_ENGINE : __('(default)', 'wordfence')));\n\t}\n\tprivate static function getStorageEngineDescription($storageEngine) {\n\t\tif ($storageEngine === null) {\n\t\t\treturn __('None', 'wordfence');\n\t\t}\n\t\telse if (method_exists($storageEngine, 'getDescription')) {\n\t\t\treturn $storageEngine->getDescription();\n\t\t}\n\t\telse {\n\t\t\treturn __('Unknown (mixed plugin version)', 'wordfence');\n\t\t}\n\t}\n\tpublic function wafActiveStorageEngine() {\n\t\treturn array('test' => true, 'infoOnly' => true, 'message' => self::getStorageEngineDescription(wfWAF::getSharedStorageEngine()));\n\t}\n\tpublic function wafLogPath() {\n\t\t$logPath = __('(not set)', 'wordfence');\n\t\tif (defined('WFWAF_LOG_PATH')) {\n\t\t\t$logPath = WFWAF_LOG_PATH;\n\t\t\tif (strpos($logPath, ABSPATH) === 0) {\n\t\t\t\t$logPath = '~\/' . substr($logPath, strlen(ABSPATH));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn array('test' => true, 'infoOnly' => true, 'message' => $logPath);\n\t}\n\t\n\tpublic function wafSubdirectoryInstall() {\n\t\treturn array('test' => true, 'infoOnly' => true, 'message' => (defined('WFWAF_SUBDIRECTORY_INSTALL') && WFWAF_SUBDIRECTORY_INSTALL ? __('Yes', 'wordfence') : __('No', 'wordfence')));\n\t}\n\t\n\tpublic function wafAutoPrependPathOverride() {\n\t\t$value = __('(not set)', 'wordfence');\n\t\tif (defined('WORDFENCE_WAF_PREPEND_DIRECTORY')) {\n\t\t\t$value = WORDFENCE_WAF_PREPEND_DIRECTORY;\n\t\t}\n\t\t\n\t\treturn array('test' => true, 'infoOnly' => true, 'message' => $value);\n\t}\n\t\n\tpublic function wafAutoPrependFilePath() {\n\t\t$path = wordfence::getWAFBootstrapPath();\n\t\tif (!file_exists($path)) {\n\t\t\t$path = '';\n\t\t}\n\t\treturn array('test' => true, 'infoOnly' => true, 'message' => $path);\n\t}\n\t\n\tpublic function wafFilePermissions() {\n\t\tif (defined('WFWAF_LOG_FILE_MODE')) {\n\t\t\treturn array('test' => true, 'infoOnly' => true, 'message' => sprintf(\/* translators: Unix file permissions in octal (example 0777). *\/ __('%s - using constant', 'wordfence'), str_pad(decoct(WFWAF_LOG_FILE_MODE), 4, '0', STR_PAD_LEFT)));\n\t\t}\n\t\t\n\t\tif (defined('WFWAF_LOG_PATH')) {\n\t\t\t$template = rtrim(WFWAF_LOG_PATH, '\/') . '\/template.php';\n\t\t\tif (file_exists($template)) {\n\t\t\t\t$stat = @stat($template);\n\t\t\t\tif ($stat !== false) {\n\t\t\t\t\t$mode = $stat[2];\n\t\t\t\t\t$updatedMode = 0600;\n\t\t\t\t\tif (($mode & 0020) == 0020) {\n\t\t\t\t\t\t$updatedMode = $updatedMode | 0060;\n\t\t\t\t\t}\n\t\t\t\t\treturn array('test' => true, 'infoOnly' => true, 'message' => sprintf(\/* translators: Unix file permissions in octal (example 0777). *\/ __('%s - using template', 'wordfence'), str_pad(decoct($updatedMode), 4, '0', STR_PAD_LEFT)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn array('test' => true, 'infoOnly' => true, 'message' => __('0660 - using default', 'wordfence'));\n\t}\n\t\n\tpublic function wafRecentlyRemoved() {\n\t\t$removalHistory = wfConfig::getJSON('diagnosticsWflogsRemovalHistory', array());\n\t\tif (empty($removalHistory)) {\n\t\t\treturn array('test' => true, 'infoOnly' => true, 'message' => __('None', 'wordfence'));\n\t\t}\n\t\t\n\t\t$message = array();\n\t\tforeach ($removalHistory as $r) {\n\t\t\t$m = wfUtils::formatLocalTime('M j, Y', $r[0]) . ': (' . count($r[1]) . ')';\n\t\t\t$r[1] = array_filter($r[1], array($this, '_filterOutNestedEntries'));\n\t\t\t$m .= ' ' . implode(', ', array_slice($r[1], 0, 5));\n\t\t\tif (count($r[1]) > 5) {\n\t\t\t\t$m .= ', ...';\n\t\t\t}\n\t\t\t$message[] = $m;\n\t\t}\n\t\t\n\t\treturn array('test' => true, 'infoOnly' => true, 'message' => implode(\"\\n\", $message));\n\t}\n\n\tpublic function wafLoaded() {\n\t\t$waf = wfWAF::getInstance();\n\t\treturn array(\n\t\t\t'test' => true,\n\t\t\t'infoOnly' => true,\n\t\t\t'message' => $waf !== null && ($waf instanceof wfWAFWordPress) ? __('Yes', 'wordfence') : __('No', 'wordfence')\n\t\t);\n\t}\n\t\n\tprivate function _filterOutNestedEntries($a) {\n\t\treturn !is_array($a);\n\t}\n\n\tpublic function processOwner() {\n\t\t$disabledFunctions = explode(',', ini_get('disable_functions'));\n\n\t\tif (is_callable('posix_geteuid')) {\n\t\t\tif (!is_callable('posix_getpwuid') || in_array('posix_getpwuid', $disabledFunctions)) {\n\t\t\t\treturn array(\n\t\t\t\t\t'test' => false,\n\t\t\t\t\t'message' => __('Unavailable', 'wordfence'),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t$processOwner = posix_getpwuid(posix_geteuid());\n\t\t\tif ($processOwner !== false)\n\t\t\t{\n\t\t\t\treturn array(\n\t\t\t\t\t'test' => true,\n\t\t\t\t\t'message' => $processOwner['name'],\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t$usernameOrUserEnv = getenv('USERNAME') ? getenv('USERNAME') : getenv('USER');\n\t\tif (!empty($usernameOrUserEnv)) { \/\/Check some environmental variable possibilities\n\t\t\treturn array(\n\t\t\t\t'test' => true,\n\t\t\t\t'message' => $usernameOrUserEnv,\n\t\t\t);\n\t\t}\n\n\t\tif (wfUtils::funcEnabled('get_current_user')) {\n\t\t\t$currentUser = get_current_user();\n\t\t\tif (!empty($currentUser)) { \/\/php.net comments indicate on Windows this returns the process owner rather than the file owner\n\t\t\t\treturn array(\n\t\t\t\t\t'test' => true,\n\t\t\t\t\t'message' => $currentUser,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tif (!empty($_SERVER['LOGON_USER'])) { \/\/Last resort for IIS since POSIX functions are unavailable, Source: https:\/\/msdn.microsoft.com\/en-us\/library\/ms524602(v=vs.90).aspx\n\t\t\treturn array(\n\t\t\t\t'test' => true,\n\t\t\t\t'message' => $_SERVER['LOGON_USER'],\n\t\t\t);\n\t\t}\n\n\t\treturn array(\n\t\t\t'test' => false,\n\t\t\t'message' => __('Unknown', 'wordfence'),\n\t\t);\n\t}\n\n\tpublic function hasOpenSSL() {\n\t\treturn is_callable('openssl_open');\n\t}\n\t\n\tpublic function openSSLVersion() {\n\t\tif (!function_exists('openssl_verify') || !defined('OPENSSL_VERSION_NUMBER') || !defined('OPENSSL_VERSION_TEXT')) {\n\t\t\treturn false;\n\t\t}\n\t\t$compare = wfVersionCheckController::shared()->checkOpenSSLVersion();\n\t\treturn array(\n\t\t\t'test' => $compare == wfVersionCheckController::VERSION_COMPATIBLE,\n\t\t\t'message'  => OPENSSL_VERSION_TEXT . ' (0x' . dechex(OPENSSL_VERSION_NUMBER) . ')',\n\t\t);\n\t}\n\n\tpublic function hasCurl() {\n\t\tif (!is_callable('curl_version')) {\n\t\t\treturn false;\n\t\t}\n\t\t$version = curl_version();\n\t\trequire(dirname(__FILE__) . '\/wfVersionSupport.php'); \/** @var $wfCURLMinimumVersion *\/\n\t\treturn array(\n\t\t\t'test' => version_compare($version['version'], $wfCURLMinimumVersion, '>='),\n\t\t\t'message'  => $version['version'] . ' (0x' . dechex($version['version_number']) . ')',\n\t\t);\n\t}\n\t\n\tpublic function curlFeatures() {\n\t\tif (!is_callable('curl_version')) {\n\t\t\treturn false;\n\t\t}\n\t\t$version = curl_version();\n\t\treturn array(\n\t\t\t'test' => true,\n\t\t\t'message'  => '0x' . dechex($version['features']),\n\t\t\t'infoOnly' => true,\n\t\t);\n\t}\n\t\n\tpublic function curlHost() {\n\t\tif (!is_callable('curl_version')) {\n\t\t\treturn false;\n\t\t}\n\t\t$version = curl_version();\n\t\treturn array(\n\t\t\t'test' => true,\n\t\t\t'message'  => $version['host'],\n\t\t\t'infoOnly' => true,\n\t\t);\n\t}\n\t\n\tpublic function curlProtocols() {\n\t\tif (!is_callable('curl_version')) {\n\t\t\treturn false;\n\t\t}\n\t\t$version = curl_version();\n\t\treturn array(\n\t\t\t'test' => true,\n\t\t\t'message'  => implode(', ', $version['protocols']),\n\t\t\t'infoOnly' => true,\n\t\t);\n\t}\n\t\n\tpublic function curlSSLVersion() {\n\t\tif (!is_callable('curl_version')) {\n\t\t\treturn false;\n\t\t}\n\t\t$version = curl_version();\n\t\treturn array(\n\t\t\t'test' => true,\n\t\t\t'message'  => $version['ssl_version'],\n\t\t\t'infoOnly' => true,\n\t\t);\n\t}\n\t\n\tpublic function curlLibZVersion() {\n\t\tif (!is_callable('curl_version')) {\n\t\t\treturn false;\n\t\t}\n\t\t$version = curl_version();\n\t\treturn array(\n\t\t\t'test' => true,\n\t\t\t'message'  => $version['libz_version'],\n\t\t\t'infoOnly' => true,\n\t\t);\n\t}\n\t\n\tpublic function displayErrors() {\n\t\tif (!is_callable('ini_get')) {\n\t\t\treturn false;\n\t\t}\n\t\t$value = ini_get('display_errors');\n\t\t$isOn = strtolower($value) == 'on' || $value == 1;\n\t\treturn array(\n\t\t\t'test' => !$isOn,\n\t\t\t'message'  => $isOn ? __('On', 'wordfence') : __('Off', 'wordfence'),\n\t\t\t'infoOnly' => true,\n\t\t);\n\t}\n\n\tpublic function connectToServer2() {\n\t\treturn $this->_connectToServer('https');\n\t}\n\n\tpublic function _connectToServer($protocol) {\n\t\t$cronURL = admin_url('admin-ajax.php');\n\t\t$cronURL = preg_replace('\/^(https?:\\\/\\\/)\/i', ':\/\/noc1.wordfence.com\/scanptest\/', $cronURL);\n\t\t$cronURL .= '?action=wordfence_doScan&isFork=0&cronKey=47e9d1fa6a675b5999999333';\n\t\t$cronURL = $protocol . $cronURL;\n\t\t$result = wp_remote_post($cronURL, array(\n\t\t\t'timeout' => 10, \/\/Must be less than max execution time or more than 2 HTTP children will be occupied by scan\n\t\t\t'blocking' => true, \/\/Non-blocking seems to block anyway, so we use blocking\n\t\t\t\/\/ This causes cURL to throw errors in some versions since WordPress uses its own certificate bundle ('CA certificate set, but certificate verification is disabled')\n\t\t\t\/\/ 'sslverify' => false,\n\t\t\t'headers' => array()\n\t\t\t));\n\t\tif( (! is_wp_error($result)) && $result['response']['code'] == 200 && strpos($result['body'], \"scanptestok\") !== false){\n\t\t\treturn true;\n\t\t}\n\n\t\t$detail = '';\n\t\tif (is_wp_error($result)) {\n\t\t\t$message = __('wp_remote_post() test to noc1.wordfence.com failed! Response was: ', 'wordfence') . $result->get_error_message();\n\t\t}\n\t\telse {\n\t\t\t$message = __('wp_remote_post() test to noc1.wordfence.com failed! Response was: ', 'wordfence') . $result['response']['code'] . \" \" . $result['response']['message'] . \"\\n\";\n\t\t\t$message .= __('This likely means that your hosting provider is blocking requests to noc1.wordfence.com or has set up a proxy that is not behaving itself.', 'wordfence') . \"\\n\";\n\t\t\tif (isset($result['http_response']) && is_object($result['http_response']) && method_exists($result['http_response'], 'get_response_object') && is_object($result['http_response']->get_response_object()) && property_exists($result['http_response']->get_response_object(), 'raw')) {\n\t\t\t\t$detail = str_replace(\"\\r\\n\", \"\\n\", $result['http_response']->get_response_object()->raw);\n\t\t\t}\n\t\t}\n\n\t\treturn array(\n\t\t\t'test' => false,\n\t\t\t'message' => $message,\n\t\t\t'detail' => $detail,\n\t\t);\n\t}\n\t\n\tpublic function connectToSelf($ipVersion = null) {\n\t\t$adminAJAX = admin_url('admin-ajax.php?action=wordfence_testAjax');\n\t\t$result = wp_remote_post($adminAJAX, array(\n\t\t\t'timeout' => 10, \/\/Must be less than max execution time or more than 2 HTTP children will be occupied by scan\n\t\t\t'blocking' => true, \/\/Non-blocking seems to block anyway, so we use blocking\n\t\t\t'headers' => array()\n\t\t));\n\t\t\n\t\tif ((!is_wp_error($result)) && $result['response']['code'] == 200 && strpos($result['body'], \"WFSCANTESTOK\") !== false) {\n\t\t\t$host = parse_url($adminAJAX, PHP_URL_HOST);\n\t\t\tif ($host !== null) {\n\t\t\t\t$ips = wfUtils::resolveDomainName($host, $ipVersion);\n\t\t\t\tif (!empty($ips)) {\n\t\t\t\t\t$ips = implode(', ', $ips);\n\t\t\t\t\treturn array('test' => true, 'message' => sprintf('OK - %s', $ips));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\t$detail = '';\n\t\tif (is_wp_error($result)) {\n\t\t\t$message = __('wp_remote_post() test back to this server failed! Response was: ', 'wordfence') . $result->get_error_message();\n\t\t\t$messageTextOnly = __('wp_remote_post() test back to this server failed! Response was: ', 'wordfence') . $result->get_error_message();\n\t\t}\n\t\telse {\n\t\t\t$message = __('wp_remote_post() test back to this server failed! Response was: ', 'wordfence') . '<br>' . $result['response']['code'] . ' ' . $result['response']['message'] . '<br><br>';\n\t\t\t$messageTextOnly = __('wp_remote_post() test back to this server failed! Response was: ', 'wordfence') . \"\\n\" . $result['response']['code'] . ' ' . $result['response']['message'] . \"\\n\\n\";\n\t\t\tif ($this->_detectBlockedByCloudflare($result)) {\n\t\t\t\t$message .= __('Cloudflare appears to be blocking your site from connecting to itself.', 'wordfence') . '<br>' . sprintf(' <a href=\"%s\" target=\"_blank\" rel=\"noopener noreferrer\">', wfSupportController::esc_supportURL(wfSupportController::ITEM_DIAGNOSTICS_CLOUDFLARE_BLOCK)) . __('Get help with Cloudflare compatibility', 'wordfence') . '<\/a><br><br>';\n\t\t\t\t$messageTextOnly .= __('Cloudflare appears to be blocking your site from connecting to itself.', 'wordfence') . \"\\n\" . __('Get help with Cloudflare compatibility', 'wordfence') . ': ' . wfSupportController::esc_supportURL(wfSupportController::ITEM_DIAGNOSTICS_CLOUDFLARE_BLOCK) . \"\\n\\n\";\n\t\t\t}\n\t\t\t$message .= __('This additional info may help you diagnose the issue. The response headers we received were:', 'wordfence') . '<br><br>';\n\t\t\t$messageTextOnly .= __('This additional info may help you diagnose the issue. The response headers we received were:', 'wordfence') . \"\\n\\n\";\n\t\t\tif (isset($result['http_response']) && is_object($result['http_response']) && method_exists($result['http_response'], 'get_response_object') && is_object($result['http_response']->get_response_object()) && property_exists($result['http_response']->get_response_object(), 'raw')) {\n\t\t\t\t$detail = str_replace(\"\\r\\n\", \"\\n\", $result['http_response']->get_response_object()->raw);\n\t\t\t}\n\t\t}\n\t\t\n\t\t$message = wp_kses($message, array('a' => array('href' => array(), 'target' => array(), 'rel' => array()), 'span' => array('class' => array()), 'em' => array(), 'code' => array(), 'br' => array()));\n\t\t\n\t\treturn array(\n\t\t\t'test' => false,\n\t\t\t'warn' => $ipVersion == 6,\n\t\t\t'message' => array('escaped' => $message, 'textonly' => $messageTextOnly),\n\t\t\t'detail' => $detail,\n\t\t);\n\t}\n\n\tpublic function connectToSelfIpv6() {\n\t\tif (wfUtils::isCurlSupported()) {\n\t\t\t$interceptor = new wfCurlInterceptor();\n\t\t\t$interceptor->setOption(CURLOPT_IPRESOLVE, CURL_IPRESOLVE_V6);\n\t\t\ttry {\n\t\t\t\t$instance = $this;\n\t\t\t\t$result = $interceptor->intercept(function() use ($instance) {\n\t\t\t\t\treturn $instance->connectToSelf(6);\n\t\t\t\t});\n\t\t\t\tif ($result !== true && !$result['test']) {\n\t\t\t\t\t$handle = $interceptor->getHandle();\n\t\t\t\t\t$errorNumber = curl_errno($handle);\n\t\t\t\t\tif ($errorNumber === 6 \/* COULDNT_RESOLVE_HOST *\/) {\n\t\t\t\t\t\t$detail = sprintf(\/* translators: error message from failed request *\/ __('This likely indicates that the server either does not support IPv6 or does not have an IPv6 address assigned or associated with the domain. Original error message: %s', 'wordfence'), is_array($result['message']) ? $result['message']['escaped'] : $result['message']);\n\t\t\t\t\t\t$detail = wp_kses($detail, array('a' => array('href' => array(), 'target' => array(), 'rel' => array()), 'span' => array('class' => array()), 'em' => array(), 'code' => array(), 'br' => array()));\n\t\t\t\t\t\t$detailTextOnly = sprintf(\/* translators: error message from failed request *\/ __('This likely indicates that the server either does not support IPv6 or does not have an IPv6 address assigned or associated with the domain. Original error message: %s', 'wordfence'), is_array($result['message']) ? $result['message']['textonly'] : strip_tags($result['message']));\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn array(\n\t\t\t\t\t\t\t'test' => false,\n\t\t\t\t\t\t\t'warn' => true,\n\t\t\t\t\t\t\t'infoOnly' => true,\n\t\t\t\t\t\t\t'message' => __('IPv6 DNS resolution failed', 'wordfence'),\n\t\t\t\t\t\t\t'detail' => array('escaped' => $detail, 'textonly' => $detailTextOnly),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn $result;\n\t\t\t}\n\t\t\tcatch (wfCurlInterceptionFailedException $e) {\n\t\t\t\treturn array(\n\t\t\t\t\t'test' => false,\n\t\t\t\t\t'warn' => true,\n\t\t\t\t\t'message' => __('This diagnostic is unavailable as cURL appears to be supported, but was not used by WordPress for this request', 'wordfence')\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn array(\n\t\t\t'test' => false,\n\t\t\t'warn' => true,\n\t\t\t'message' => __('This diagnostic requires cURL', 'wordfence')\n\t\t);\n\t}\n\t\n\t\/**\n\t * Looks for markers in $result that indicate it was challenged\/blocked by Cloudflare.\n\t * \n\t * @param $result\n\t * @return bool\n\t *\/\n\tprivate function _detectBlockedByCloudflare($result) {\n\t\t$headers = $result['headers'];\n\t\tif (isset($headers['cf-mitigated']) && strtolower($headers['cf-mitigated']) == 'challenge' \/* managed challenge *\/) { \/\/$headers is an instance of Requests_Utility_CaseInsensitiveDictionary\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\t$body = $result['body'];\n\t\t$search = array(\n\t\t\t'\/cdn-cgi\/styles\/challenges.css', \/\/managed challenge\n\t\t\t'\/cdn-cgi\/challenge-platform', \/\/managed challenge\n\t\t\t'\/cdn-cgi\/styles\/cf.errors.css', \/\/block\n\t\t\t'cf-error-details', \/\/block\n\t\t\t'Cloudflare Ray ID', \/\/block\n\t\t);\n\t\tforeach ($search as $s) {\n\t\t\tif (stripos($body, $s) !== false) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic function serverIP() {\n\t\t$serverIPs = wfUtils::serverIPs();\n\t\treturn array(\n\t\t\t'test' => true,\n\t\t\t'infoOnly' => true,\n\t\t\t'message' => implode(',', $serverIPs),\n\t\t);\n\t}\n\n\tpublic function howGetIPs()\n\t{\n\t\t$howGet = wfConfig::get('howGetIPs', false);\n\t\tif ($howGet) {\n\t\t\tif (empty($_SERVER[$howGet])) {\n\t\t\t\treturn array(\n\t\t\t\t\t'test' => false,\n\t\t\t\t\t'message' => sprintf(\/* translators: PHP super global key. *\/ __('We cannot read $_SERVER[%s]', 'wordfence'), $howGet),\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn array(\n\t\t\t\t'test' => true,\n\t\t\t\t'message' => $howGet,\n\t\t\t);\n\t\t}\n\t\tforeach (array('HTTP_CF_CONNECTING_IP', 'HTTP_X_REAL_IP', 'HTTP_X_FORWARDED_FOR') as $test) {\n\t\t\tif (!empty($_SERVER[$test])) {\n\t\t\t\treturn array(\n\t\t\t\t\t'test' => false,\n\t\t\t\t\t'message' => __('Should be: ', 'wordfence') . $test\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn array(\n\t\t\t'test' => true,\n\t\t\t'message' => 'REMOTE_ADDR',\n\t\t);\n\t}\n\t\n\tpublic function serverTime() {\n\t\treturn array(\n\t\t\t'test' => true,\n\t\t\t'infoOnly' => true,\n\t\t\t'message' => date('Y-m-d H:i:s', time()) . ' UTC',\n\t\t);\n\t}\n\t\n\tpublic function wfTime() {\n\t\ttry {\n\t\t\t$api = new wfAPI(wfConfig::get('apiKey'), wfUtils::getWPVersion());\n\t\t\t$response = $api->call('timestamp');\n\t\t\tif (!is_array($response) || !isset($response['timestamp'])) {\n\t\t\t\tthrow new Exception('Unexpected payload returned');\n\t\t\t}\n\t\t}\n\t\tcatch (Exception $e) {\n\t\t\treturn array(\n\t\t\t\t'test' => true,\n\t\t\t\t'infoOnly' => true,\n\t\t\t\t'message' => '-',\n\t\t\t);\n\t\t}\n\t\t\n\t\treturn array(\n\t\t\t'test' => true,\n\t\t\t'infoOnly' => true,\n\t\t\t'message' => date('Y-m-d H:i:s', $response['timestamp']) . ' UTC',\n\t\t);\n\t}\n\t\n\tpublic function wfTimeOffset() {\n\t\t$delta = wfUtils::normalizedTime() - time();\n\t\treturn array(\n\t\t\t'test' => true,\n\t\t\t'infoOnly' => true,\n\t\t\t'message' => ($delta < 0 ? '-' : '+') . ' ' . wfUtils::makeDuration(abs($delta), true),\n\t\t);\n\t}\n\t\n\tpublic function ntpTimeOffset() {\n\t\tif (class_exists('WFLSPHP52Compatability')) {\n\t\t\t$time = WFLSPHP52Compatability::ntp_time();\n\t\t\tif ($time === false) {\n\t\t\t\treturn array(\n\t\t\t\t\t'test' => true,\n\t\t\t\t\t'infoOnly' => true,\n\t\t\t\t\t'message' => __('Blocked', 'wordfence'),\n\t\t\t\t);\n\t\t\t}\n\t\t\t\n\t\t\t$delta = $time - time();\n\t\t\treturn array(\n\t\t\t\t'test' => true,\n\t\t\t\t'infoOnly' => true,\n\t\t\t\t'message' => ($delta < 0 ? '-' : '+') . ' ' . wfUtils::makeDuration(abs($delta), true),\n\t\t\t);\n\t\t}\n\t\t\n\t\treturn array(\n\t\t\t'test' => true,\n\t\t\t'infoOnly' => true,\n\t\t\t'message' => '-',\n\t\t);\n\t}\n\n\tpublic function ntpStatus() {\n\t\t$maxFailures = \\WordfenceLS\\Controller_Time::FAILURE_LIMIT;\n\t\t$cronDisabled = \\WordfenceLS\\Controller_Settings::shared()->is_ntp_cron_disabled($failureCount);\n\t\tif ($cronDisabled) {\n\t\t\t$constant = \\WordfenceLS\\Controller_Settings::shared()->is_ntp_disabled_via_constant();\n\t\t\t$status = __('Disabled ', 'wordfence');\n\t\t\tif ($constant) {\n\t\t\t\t$status .= __('(WORDFENCE_LS_DISABLE_NTP)', 'wordfence');\n\t\t\t}\n\t\t\telse if ($failureCount > 0) {\n\t\t\t\t$status .= __('(failures exceeded limit)', 'wordfence');\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$status .= __('(settings)', 'wordfence');\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t$status = __('Enabled', 'wordfence');\n\t\t\tif ($failureCount > 0) {\n\t\t\t\t$remainingAttempts = $maxFailures - $failureCount;\n\t\t\t\t$status .= sprintf(__(' (%d of %d attempts remaining)', 'wordfence'), $remainingAttempts, $maxFailures);\n\t\t\t}\n\t\t}\n\t\treturn array(\n\t\t\t'test' => true,\n\t\t\t'infoOnly' => true,\n\t\t\t'message' => $status\n\t\t);\n\t}\n\t\n\tpublic function timeSourceInUse() {\n\t\tif (class_exists('WFLSPHP52Compatability')) {\n\t\t\t$time = WFLSPHP52Compatability::ntp_time();\n\t\t\tif (WFLSPHP52Compatability::using_ntp_time()) {\n\t\t\t\treturn array(\n\t\t\t\t\t'test' => true,\n\t\t\t\t\t'infoOnly' => true,\n\t\t\t\t\t'message' => __('NTP', 'wordfence'),\n\t\t\t\t);\n\t\t\t}\n\t\t\telse if (WFLSPHP52Compatability::using_wf_time()) {\n\t\t\t\treturn array(\n\t\t\t\t\t'test' => true,\n\t\t\t\t\t'infoOnly' => true,\n\t\t\t\t\t'message' => __('Wordfence Network', 'wordfence'),\n\t\t\t\t);\n\t\t\t}\n\t\t\t\n\t\t\treturn array(\n\t\t\t\t'test' => true,\n\t\t\t\t'infoOnly' => true,\n\t\t\t\t'message' => __('Server Time', 'wordfence'),\n\t\t\t);\n\t\t}\n\t\t\n\t\treturn array(\n\t\t\t'test' => true,\n\t\t\t'infoOnly' => true,\n\t\t\t'message' => '-',\n\t\t);\n\t}\n\t\n\tpublic function wpTimeZone() {\n\t\t$tz = get_option('timezone_string');\n\t\tif (empty($tz)) {\n\t\t\t$offset = get_option('gmt_offset');\n\t\t\t$tz = 'UTC' . ($offset >= 0 ? '+' . $offset : $offset);\n\t\t}\n\t\t\n\t\treturn array(\n\t\t\t'test' => true,\n\t\t\t'infoOnly' => true,\n\t\t\t'message' => $tz,\n\t\t);\n\t}\n\n\tpublic static function getWordpressValues() {\n\t\trequire(ABSPATH . 'wp-includes\/version.php');\n\t\t$postRevisions = (defined('WP_POST_REVISIONS') ? WP_POST_REVISIONS : true);\n\t\treturn array(\n\t\t\t'WordPress Version'            => array('description' => '', 'value' => $wp_version),\n\t\t\t'Multisite'\t\t\t\t\t   => array('description' => __('Return value of is_multisite()', 'wordfence'), 'value' => is_multisite() ? __('Yes', 'wordfence') : __('No', 'wordfence')),\n\t\t\t'ABSPATH'\t\t\t\t\t   => __('WordPress base path', 'wordfence'), \n\t\t\t'WP_DEBUG'                     => array('description' => __('WordPress debug mode', 'wordfence'), 'value' => (defined('WP_DEBUG') && WP_DEBUG ? __('On', 'wordfence') : __('Off', 'wordfence'))),\n\t\t\t'WP_DEBUG_LOG'                 => array('description' => __('WordPress error logging override', 'wordfence'), 'value' => defined('WP_DEBUG_LOG') ? (WP_DEBUG_LOG ? 'Enabled' : 'Disabled') : __('(not set)', 'wordfence')),\n\t\t\t'WP_DEBUG_DISPLAY'             => array('description' => __('WordPress error display override', 'wordfence'), 'value' => defined('WP_DEBUG_DISPLAY') ? (WP_DEBUG_DISPLAY ? 'Enabled' : 'Disabled') : __('(not set)', 'wordfence')),\n\t\t\t'SCRIPT_DEBUG'                 => array('description' => __('WordPress script debug mode', 'wordfence'), 'value' => (defined('SCRIPT_DEBUG') && SCRIPT_DEBUG ? __('On', 'wordfence') : __('Off', 'wordfence'))),\n\t\t\t'SAVEQUERIES'                  => array('description' => __('WordPress query debug mode', 'wordfence'), 'value' => (defined('SAVEQUERIES') && SAVEQUERIES ? __('On', 'wordfence') : __('Off', 'wordfence'))),\n\t\t\t'DB_CHARSET'                   => __('Database character set', 'wordfence'),\n\t\t\t'DB_COLLATE'                   => __('Database collation', 'wordfence'),\n\t\t\t'WP_SITEURL'                   => __('Explicitly set site URL', 'wordfence'),\n\t\t\t'WP_HOME'                      => __('Explicitly set blog URL', 'wordfence'),\n\t\t\t'WP_CONTENT_DIR'               => array('description' => __('\"wp-content\" folder is in default location', 'wordfence'), 'value' => (realpath(WP_CONTENT_DIR) === realpath(ABSPATH . 'wp-content') ? __('Yes', 'wordfence') : sprintf(\/* translators: WordPress content directory. *\/ __('No: %s', 'wordfence'), WP_CONTENT_DIR))),\n\t\t\t'WP_CONTENT_URL'               => __('URL to the \"wp-content\" folder', 'wordfence'),\n\t\t\t'WP_PLUGIN_DIR'                => array('description' => __('\"plugins\" folder is in default location', 'wordfence'), 'value' => (realpath(WP_PLUGIN_DIR) === realpath(ABSPATH . 'wp-content\/plugins') ? __('Yes', 'wordfence') : sprintf(\/* translators: WordPress plugins directory. *\/ __('No: %s', 'wordfence'), WP_PLUGIN_DIR))),\n\t\t\t'WP_LANG_DIR'                  => array('description' => __('\"languages\" folder is in default location', 'wordfence'), 'value' => (realpath(WP_LANG_DIR) === realpath(ABSPATH . 'wp-content\/languages') ? __('Yes', 'wordfence') : sprintf(\/* translators: WordPress languages directory. *\/ __('No: %s', 'wordfence'), WP_LANG_DIR))),\n\t\t\t'WPLANG'                       => __('Language choice', 'wordfence'),\n\t\t\t'UPLOADS'                      => __('Custom upload folder location', 'wordfence'),\n\t\t\t'TEMPLATEPATH'                 => array('description' => __('Theme template folder override', 'wordfence'), 'value' => (defined('TEMPLATEPATH') && realpath(get_template_directory()) !== realpath(TEMPLATEPATH) ? sprintf(\/* translators: WordPress theme template directory. *\/ __('Overridden: %s', 'wordfence'), TEMPLATEPATH) : __('(not set)', 'wordfence'))),\n\t\t\t'STYLESHEETPATH'               => array('description' => __('Theme stylesheet folder override', 'wordfence'), 'value' => (defined('STYLESHEETPATH') && realpath(get_stylesheet_directory()) !== realpath(STYLESHEETPATH) ? sprintf(\/* translators: WordPress theme stylesheet directory. *\/ __('Overridden: %s', 'wordfence'), STYLESHEETPATH) : __('(not set)', 'wordfence'))),\n\t\t\t'AUTOSAVE_INTERVAL'            => __('Post editing automatic saving interval', 'wordfence'),\n\t\t\t'WP_POST_REVISIONS'            => array('description' => __('Post revisions saved by WordPress', 'wordfence'), 'value' => is_numeric($postRevisions) ? $postRevisions : ($postRevisions ? __('Unlimited', 'wordfence') : __('None', 'wordfence'))),\n\t\t\t'COOKIE_DOMAIN'                => __('WordPress cookie domain', 'wordfence'),\n\t\t\t'COOKIEPATH'                   => __('WordPress cookie path', 'wordfence'),\n\t\t\t'SITECOOKIEPATH'               => __('WordPress site cookie path', 'wordfence'),\n\t\t\t'ADMIN_COOKIE_PATH'            => __('WordPress admin cookie path', 'wordfence'),\n\t\t\t'PLUGINS_COOKIE_PATH'          => __('WordPress plugins cookie path', 'wordfence'),\n\t\t\t'NOBLOGREDIRECT'               => __('URL redirected to if the visitor tries to access a nonexistent blog', 'wordfence'),\n\t\t\t'CONCATENATE_SCRIPTS'          => array('description' => __('Concatenate JavaScript files', 'wordfence'), 'value' => (defined('CONCATENATE_SCRIPTS') && CONCATENATE_SCRIPTS ? __('Yes', 'wordfence') : __('No', 'wordfence'))),\n\t\t\t'WP_MEMORY_LIMIT'              => __('WordPress memory limit', 'wordfence'),\n\t\t\t'WP_MAX_MEMORY_LIMIT'          => __('Administrative memory limit', 'wordfence'),\n\t\t\t'WP_CACHE'                     => array('description' => __('Built-in caching', 'wordfence'), 'value' => (defined('WP_CACHE') && WP_CACHE ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence'))),\n\t\t\t'CUSTOM_USER_TABLE'            => array('description' => __('Custom \"users\" table', 'wordfence'), 'value' => (defined('CUSTOM_USER_TABLE') ? sprintf(\/* translators: WordPress custom user table. *\/ __('Set: %s', 'wordfence'), CUSTOM_USER_TABLE) : __('(not set)', 'wordfence'))),\n\t\t\t'CUSTOM_USER_META_TABLE'       => array('description' => __('Custom \"usermeta\" table', 'wordfence'), 'value' => (defined('CUSTOM_USER_META_TABLE') ? sprintf(\/* translators: WordPress custom user meta table. *\/ __('Set: %s', 'wordfence'), CUSTOM_USER_META_TABLE) : __('(not set)', 'wordfence'))),\n\t\t\t'FS_CHMOD_DIR'                 => array('description' => __('Overridden permissions for a new folder', 'wordfence'), 'value' => defined('FS_CHMOD_DIR') ? decoct(FS_CHMOD_DIR) : __('(not set)', 'wordfence')),\n\t\t\t'FS_CHMOD_FILE'                => array('description' => __('Overridden permissions for a new file', 'wordfence'), 'value' => defined('FS_CHMOD_FILE') ? decoct(FS_CHMOD_FILE) : __('(not set)', 'wordfence')),\n\t\t\t'ALTERNATE_WP_CRON'            => array('description' => __('Alternate WP cron', 'wordfence'), 'value' => (defined('ALTERNATE_WP_CRON') && ALTERNATE_WP_CRON ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence'))),\n\t\t\t'DISABLE_WP_CRON'              => array('description' => __('WP cron status', 'wordfence'), 'value' => (defined('DISABLE_WP_CRON') && DISABLE_WP_CRON ? __('Cron is disabled', 'wordfence') : __('Cron is enabled', 'wordfence'))),\n\t\t\t'WP_CRON_LOCK_TIMEOUT'         => __('Cron running frequency lock', 'wordfence'),\n\t\t\t'EMPTY_TRASH_DAYS'             => array('description' => __('Interval the trash is automatically emptied at in days', 'wordfence'), 'value' => (EMPTY_TRASH_DAYS > 0 ? EMPTY_TRASH_DAYS : __('Never', 'wordfence'))),\n\t\t\t'WP_ALLOW_REPAIR'              => array('description' => __('Automatic database repair', 'wordfence'), 'value' => (defined('WP_ALLOW_REPAIR') && WP_ALLOW_REPAIR ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence'))),\n\t\t\t'DO_NOT_UPGRADE_GLOBAL_TABLES' => array('description' => __('Do not upgrade global tables', 'wordfence'), 'value' => (defined('DO_NOT_UPGRADE_GLOBAL_TABLES') && DO_NOT_UPGRADE_GLOBAL_TABLES ? __('Yes', 'wordfence') : __('No', 'wordfence'))),\n\t\t\t'DISALLOW_FILE_EDIT'           => array('description' => __('Disallow plugin\/theme editing', 'wordfence'), 'value' => (defined('DISALLOW_FILE_EDIT') && DISALLOW_FILE_EDIT ? __('Yes', 'wordfence') : __('No', 'wordfence'))),\n\t\t\t'DISALLOW_FILE_MODS'           => array('description' => __('Disallow plugin\/theme update and installation', 'wordfence'), 'value' => (defined('DISALLOW_FILE_MODS') && DISALLOW_FILE_MODS ? __('Yes', 'wordfence') : __('No', 'wordfence'))),\n\t\t\t'IMAGE_EDIT_OVERWRITE'         => array('description' => __('Overwrite image edits when restoring the original', 'wordfence'), 'value' => (defined('IMAGE_EDIT_OVERWRITE') && IMAGE_EDIT_OVERWRITE ? __('Yes', 'wordfence') : __('No', 'wordfence'))),\n\t\t\t'FORCE_SSL_ADMIN'              => array('description' => __('Force SSL for administrative logins', 'wordfence'), 'value' => (defined('FORCE_SSL_ADMIN') && FORCE_SSL_ADMIN ? __('Yes', 'wordfence') : __('No', 'wordfence'))),\n\t\t\t'WP_HTTP_BLOCK_EXTERNAL'       => array('description' => __('Block external URL requests', 'wordfence'), 'value' => (defined('WP_HTTP_BLOCK_EXTERNAL') && WP_HTTP_BLOCK_EXTERNAL ? __('Yes', 'wordfence') : __('No', 'wordfence'))),\n\t\t\t'WP_ACCESSIBLE_HOSTS'          => __('Allowlisted hosts', 'wordfence'),\n\t\t\t'WP_AUTO_UPDATE_CORE'          => array('description' => __('Automatic WP Core updates', 'wordfence'), 'value' => defined('WP_AUTO_UPDATE_CORE') ? (is_bool(WP_AUTO_UPDATE_CORE) ? (WP_AUTO_UPDATE_CORE ? __('Everything', 'wordfence') : __('None', 'wordfence')) : WP_AUTO_UPDATE_CORE) : __('Default', 'wordfence')),\n\t\t\t'WP_PROXY_HOST'                => array('description' => __('Hostname for a proxy server', 'wordfence'), 'value' => defined('WP_PROXY_HOST') ? WP_PROXY_HOST : __('(not set)', 'wordfence')),\n\t\t\t'WP_PROXY_PORT'                => array('description' => __('Port for a proxy server', 'wordfence'), 'value' => defined('WP_PROXY_PORT') ? WP_PROXY_PORT : __('(not set)', 'wordfence')),\n\t\t\t'MULTISITE'               \t   => array('description' => __('Multisite enabled', 'wordfence'), 'value' => defined('MULTISITE') ? (MULTISITE ? __('Yes', 'wordfence') : __('No', 'wordfence')) : __('(not set)', 'wordfence')),\n\t\t\t'WP_ALLOW_MULTISITE'           => array('description' => __('Multisite\/network ability enabled', 'wordfence'), 'value' => (defined('WP_ALLOW_MULTISITE') && WP_ALLOW_MULTISITE ? __('Yes', 'wordfence') : __('No', 'wordfence'))),\n\t\t\t'SUNRISE'\t\t\t\t\t   => array('description' => __('Multisite enabled, WordPress will load the \/wp-content\/sunrise.php file', 'wordfence'), 'value' => defined('SUNRISE') ? __('Yes', 'wordfence') : __('(not set)', 'wordfence')),\n\t\t\t'SUBDOMAIN_INSTALL'\t\t\t   => array('description' => __('Multisite enabled, subdomain installation constant', 'wordfence'), 'value' => defined('SUBDOMAIN_INSTALL') ? (SUBDOMAIN_INSTALL ? __('Yes', 'wordfence') : __('No', 'wordfence')) : __('(not set)', 'wordfence')),\n\t\t\t'VHOST'\t\t\t\t\t\t   => array('description' => __('Multisite enabled, Older subdomain installation constant', 'wordfence'), 'value' => defined('VHOST') ? (VHOST == 'yes' ? __('Yes', 'wordfence') : __('No', 'wordfence')) : __('(not set)', 'wordfence')),\n\t\t\t'DOMAIN_CURRENT_SITE'\t\t   => __('Defines the multisite domain for the current site', 'wordfence'),\n\t\t\t'PATH_CURRENT_SITE'\t\t\t   => __('Defines the multisite path for the current site', 'wordfence'),\n\t\t\t'BLOG_ID_CURRENT_SITE'\t\t   => __('Defines the multisite database ID for the current site', 'wordfence'),\n\t\t\t'WP_DISABLE_FATAL_ERROR_HANDLER' => array('description' => __('Disable the fatal error handler', 'wordfence'), 'value' => (defined('WP_DISABLE_FATAL_ERROR_HANDLER') && WP_DISABLE_FATAL_ERROR_HANDLER ? __('Yes', 'wordfence') : __('No', 'wordfence'))),\n\t\t\t'AUTOMATIC_UPDATER_DISABLED' => array('description' => __('Disables automatic updates', 'wordfence'), 'value' => (defined('AUTOMATIC_UPDATER_DISABLED') ? (AUTOMATIC_UPDATER_DISABLED ? __('Automatic updates disabled', 'wordfence') : __('Automatic updates enabled', 'wordfence')) : __('(not set)', 'wordfence')))\n\t\t);\n\t}\n\t\n\tpublic static function getWordfenceValues() {\n\t\t\/\/Rate Limiting\n\t\t$rateOptions = array(\n\t\t\t'DISABLED' => __('Unlimited', 'wordfence'),\n\t\t\t1920 => sprintf(\/* translators: Number of HTTP requests. *\/__('%d per minute', 'wordfence'), 1920),\n\t\t\t960 => sprintf(\/* translators: Number of HTTP requests. *\/__('%d per minute', 'wordfence'), 960),\n\t\t\t480 => sprintf(\/* translators: Number of HTTP requests. *\/__('%d per minute', 'wordfence'), 480),\n\t\t\t240 => sprintf(\/* translators: Number of HTTP requests. *\/__('%d per minute', 'wordfence'), 240),\n\t\t\t120 => sprintf(\/* translators: Number of HTTP requests. *\/__('%d per minute', 'wordfence'), 120),\n\t\t\t60 => sprintf(\/* translators: Number of HTTP requests. *\/__('%d per minute', 'wordfence'), 60),\n\t\t\t30 => sprintf(\/* translators: Number of HTTP requests. *\/__('%d per minute', 'wordfence'), 30),\n\t\t\t15 => sprintf(\/* translators: Number of HTTP requests. *\/__('%d per minute', 'wordfence'), 15),\n\t\t\t10 => sprintf(\/* translators: Number of HTTP requests. *\/__('%d per minute', 'wordfence'), 10),\n\t\t\t5 => sprintf(\/* translators: Number of HTTP requests. *\/__('%d per minute', 'wordfence'), 5),\n\t\t\t4 => sprintf(\/* translators: Number of HTTP requests. *\/__('%d per minute', 'wordfence'), 4),\n\t\t\t3 => sprintf(\/* translators: Number of HTTP requests. *\/__('%d per minute', 'wordfence'), 3),\n\t\t\t2 => sprintf(\/* translators: Number of HTTP requests. *\/__('%d per minute', 'wordfence'), 2),\n\t\t\t1 => sprintf(\/* translators: Number of HTTP requests. *\/__('%d per minute', 'wordfence'), 1),\n\t\t);\n\t\t$actionOptions = array(\n\t\t\t'throttle' => __('throttle it', 'wordfence'),\n\t\t\t'block' => __('block it', 'wordfence'),\n\t\t);\n\t\t\n\t\t$avoidPHPInput = false;\n\t\ttry {\n\t\t\t$avoidPHPInput = wfWAFConfig::get('avoid_php_input');\n\t\t}\n\t\tcatch (Exception $e) {\n\t\t\t\/\/Ignore\n\t\t}\n\t\t\n\t\t\n\t\treturn array(\n\t\t\tarray('subheader' => __('Scanner', 'wordfence')),\n\t\t\tarray('description' => __('Scan Type', 'wordfence'), 'value' => wfScanner::shared()->scanTypeName()),\n\t\t\tarray('description' => __('Check if this website is on a domain blocklist', 'wordfence'), 'value' => !!wfConfig::get('scansEnabled_checkGSB') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Check if this website is being \"Spamvertised\"', 'wordfence'), 'value' => !!wfConfig::get('spamvertizeCheck') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Check if this website IP is generating spam', 'wordfence'), 'value' => !!wfConfig::get('checkSpamIP') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Scan for misconfigured How does Wordfence get IPs', 'wordfence'), 'value' => !!wfConfig::get('scansEnabled_checkHowGetIPs') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Scan for publicly accessible configuration, backup, or log files', 'wordfence'), 'value' => !!wfConfig::get('scansEnabled_checkReadableConfig') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Scan for publicly accessible quarantined files', 'wordfence'), 'value' => !!wfConfig::get('scansEnabled_suspectedFiles') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Scan core files against repository versions for changes', 'wordfence'), 'value' => !!wfConfig::get('scansEnabled_core') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Scan theme files against repository versions for changes', 'wordfence'), 'value' => !!wfConfig::get('scansEnabled_themes') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Scan plugin files against repository versions for changes', 'wordfence'), 'value' => !!wfConfig::get('scansEnabled_plugins') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Scan wp-admin and wp-includes for files not bundled with WordPress', 'wordfence'), 'value' => !!wfConfig::get('scansEnabled_coreUnknown') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Scan for signatures of known malicious files', 'wordfence'), 'value' => !!wfConfig::get('scansEnabled_malware') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Scan file contents for backdoors, trojans and suspicious code', 'wordfence'), 'value' => !!wfConfig::get('scansEnabled_fileContents') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Scan file contents for malicious URLs', 'wordfence'), 'value' => !!wfConfig::get('scansEnabled_fileContentsGSB') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Scan posts for known dangerous URLs and suspicious content', 'wordfence'), 'value' => !!wfConfig::get('scansEnabled_posts') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Scan comments for known dangerous URLs and suspicious content', 'wordfence'), 'value' => !!wfConfig::get('scansEnabled_comments') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Scan WordPress core, plugin, and theme options for known dangerous URLs and suspicious content', 'wordfence'), 'value' => !!wfConfig::get('scansEnabled_suspiciousOptions') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Scan for out of date, abandoned, and vulnerable plugins, themes, and WordPress versions', 'wordfence'), 'value' => !!wfConfig::get('scansEnabled_oldVersions') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Scan for suspicious admin users created outside of WordPress', 'wordfence'), 'value' => !!wfConfig::get('scansEnabled_suspiciousAdminUsers') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Check the strength of passwords', 'wordfence'), 'value' => !!wfConfig::get('scansEnabled_passwds') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Monitor disk space', 'wordfence'), 'value' => !!wfConfig::get('scansEnabled_diskSpace') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Monitor Web Application Firewall status', 'wordfence'), 'value' => !!wfConfig::get('scansEnabled_wafStatus') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Scan files outside your WordPress installation', 'wordfence'), 'value' => !!wfConfig::get('other_scanOutside') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Scan images, binary, and other files as if they were executable', 'wordfence'), 'value' => !!wfConfig::get('scansEnabled_scanImages') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Use low resource scanning (reduces server load by lengthening the scan duration)', 'wordfence'), 'value' => !!wfConfig::get('lowResourceScansEnabled') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Limit the number of issues sent in the scan results email', 'wordfence'), 'value' => wfConfig::get('scan_maxIssues')),\n\t\t\tarray('description' => __('Time limit that a scan can run in seconds', 'wordfence'), 'value' => wfConfig::get('scan_maxDuration')),\n\t\t\tarray('description' => __('How much memory should Wordfence request when scanning', 'wordfence'), 'value' => wfConfig::get('maxMem')),\n\t\t\tarray('description' => __('Maximum execution time for each scan stage ', 'wordfence'), 'value' => wfConfig::get('maxExecutionTime')),\n\t\t\tarray('description' => __('Exclude files from scan that match these wildcard patterns (one per line)', 'wordfence'), 'value' => wfUtils::cleanupOneEntryPerLine(wfUtils::string_empty(wfConfig::get('scan_exclude'), __('(empty)', 'wordfence')))),\n\t\t\tarray('description' => __('Additional scan signatures (one per line)', 'wordfence'), 'value' => wfUtils::string_empty(wfConfig::get('scan_include_extra'), __('(empty)', 'wordfence'))),\n\t\t\tarray('description' => __('Use only IPv4 to start scans', 'wordfence'), 'value' => !!wfConfig::get('scan_force_ipv4_start') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Maximum number of attempts to resume each scan stage', 'wordfence'), 'value' => wfConfig::get('scan_max_resume_attempts')),\n\t\t\t\n\t\t\tarray('subheader' => __('Diagnostics', 'wordfence')),\n\t\t\tarray('description' => __('Enable debugging mode (increases database load)', 'wordfence'), 'value' => !!wfConfig::get('debugOn') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Start all scans remotely (Try this if your scans aren\\'t starting and your site is publicly accessible)', 'wordfence'), 'value' => !!wfConfig::get('startScansRemotely') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Enable SSL Verification (Disable this if you are consistently unable to connect to the Wordfence servers.)', 'wordfence'), 'value' => !!wfConfig::get('ssl_verify') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Disable reading of php:\/\/input', 'wordfence'), 'value' => !!$avoidPHPInput ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Enable Wordfence translations', 'wordfence'), 'value' => !!wfConfig::get('wordfenceI18n') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\t\n\t\t\tarray('subheader' => __('Brute Force Protection', 'wordfence')),\n\t\t\tarray('description' => __('Enable brute force protection', 'wordfence'), 'value' => !!wfConfig::get('loginSecurityEnabled') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Lock out after how many login failures', 'wordfence'), 'value' => wfConfig::get('loginSec_maxFailures')),\n\t\t\tarray('description' => __('Lock out after how many forgot password attempts', 'wordfence'), 'value' => wfConfig::get('loginSec_maxForgotPasswd')),\n\t\t\tarray('description' => __('Count failures over what time period', 'wordfence'), 'value' => wfConfig::getInt('loginSec_countFailMins')),\n\t\t\tarray('description' => __('Amount of time a user is locked out', 'wordfence'), 'value' => wfConfig::getInt('loginSec_lockoutMins')),\n\t\t\tarray('description' => __('Immediately lock out invalid usernames', 'wordfence'), 'value' => !!wfConfig::get('loginSec_lockInvalidUsers') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Immediately block the IP of users who try to sign in as these usernames', 'wordfence'), 'value' => wfUtils::cleanupOneEntryPerLine(wfUtils::string_empty(wfConfig::get('loginSec_userBlacklist'), __('(empty)', 'wordfence')))),\n\t\t\tarray('description' => __('Prevent the use of passwords leaked in data breaches', 'wordfence'), 'value' => (!!wfConfig::get('loginSec_breachPasswds_enabled') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')) . \"\\n\" . wfUtils::array_choose(array('admins' => __('For admins only', 'wordfence'), 'pubs' => __('For all users with \"publish posts\" capability', 'wordfence')), wfConfig::get('loginSec_breachPasswds'), true, __('(unknown)', 'wordfence'))),\n\t\t\tarray('description' => __('Enforce strong passwords', 'wordfence'), 'value' => (!!wfConfig::get('loginSec_strongPasswds_enabled') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')) . \"\\n\" . wfUtils::array_choose(array('pubs' => __('Force admins and publishers to use strong passwords (recommended)', 'wordfence'), 'all' => __('Force all members to use strong passwords', 'wordfence')), wfConfig::get('loginSec_strongPasswds'), true, __('(unknown)', 'wordfence'))),\n\t\t\tarray('description' => __('Don\\'t let WordPress reveal valid users in login errors', 'wordfence'), 'value' => !!wfConfig::get('loginSec_maskLoginErrors') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Prevent users registering \\'admin\\' username if it doesn\\'t exist', 'wordfence'), 'value' => !!wfConfig::get('loginSec_blockAdminReg') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Prevent discovery of usernames through \\'\/?author=N\\' scans, the oEmbed API, the WordPress REST API, and WordPress XML Sitemaps', 'wordfence'), 'value' => !!wfConfig::get('loginSec_disableAuthorScan') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Disable WordPress application passwords', 'wordfence'), 'value' => !!wfConfig::get('loginSec_disableApplicationPasswords') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Block IPs who send POST requests with blank User-Agent and Referer', 'wordfence'), 'value' => !!wfConfig::get('other_blockBadPOST') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Custom text shown on block pages', 'wordfence'), 'value' => wfUtils::string_empty(wfConfig::get('blockCustomText'), __('(empty)', 'wordfence'))),\n\t\t\tarray('description' => __('Check password strength on profile update', 'wordfence'), 'value' => !!wfConfig::get('other_pwStrengthOnUpdate') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Participate in the Real-Time Wordfence Security Network', 'wordfence'), 'value' => !!wfConfig::get('other_WFNet') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\t\n\t\t\tarray('subheader' => __('Rate Limiting', 'wordfence')),\n\t\t\tarray('description' => __('Enable Rate Limiting and Advanced Blocking', 'wordfence'), 'value' => !!wfConfig::get('firewallEnabled') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('How should we treat Google\\'s crawlers', 'wordfence'),\n\t\t\t\t'value' => wfUtils::array_choose(array('neverBlockVerified' => __('Verified Google crawlers will not be rate-limited', 'wordfence'), 'neverBlockUA' => __('Anyone claiming to be Google will not be rate-limited', 'wordfence'), 'treatAsOtherCrawlers' => __('Treat Google like any other Crawler', 'wordfence')), wfConfig::get('neverBlockBG'), true, __('(unknown)', 'wordfence'))),\n\t\t\tarray('description' => __('If anyone\\'s requests exceed', 'wordfence'), 'value' => \n\t\t\t\twfUtils::array_choose($rateOptions, wfConfig::get('maxGlobalRequests'), true, __('(unknown)', 'wordfence')) . \"\\n\" .\n\t\t\t\twfUtils::array_choose($actionOptions, wfConfig::get('maxGlobalRequests_action'), true, __('(unknown)', 'wordfence'))),\n\t\t\tarray('description' => __('If a crawler\\'s page views exceed', 'wordfence'), 'value' => \n\t\t\t\twfUtils::array_choose($rateOptions, wfConfig::get('maxRequestsCrawlers'), true, __('(unknown)', 'wordfence')) . \"\\n\" .\n\t\t\t\twfUtils::array_choose($actionOptions, wfConfig::get('maxRequestsCrawlers_action'), true, __('(unknown)', 'wordfence'))),\n\t\t\tarray('description' => __('If a crawler\\'s pages not found (404s) exceed', 'wordfence'), 'value' => \n\t\t\t\twfUtils::array_choose($rateOptions, wfConfig::get('max404Crawlers'), true, __('(unknown)', 'wordfence')) . \"\\n\" .\n\t\t\t\twfUtils::array_choose($actionOptions, wfConfig::get('max404Crawlers_action'), true, __('(unknown)', 'wordfence'))),\n\t\t\tarray('description' => __('If a human\\'s page views exceed', 'wordfence'), 'value' => \n\t\t\t\twfUtils::array_choose($rateOptions, wfConfig::get('maxRequestsHumans'), true, __('(unknown)', 'wordfence')) . \"\\n\" .\n\t\t\t\twfUtils::array_choose($actionOptions, wfConfig::get('maxRequestsHumans_action'), true, __('(unknown)', 'wordfence'))),\n\t\t\tarray('description' => __('If a human\\'s pages not found (404s) exceed', 'wordfence'), 'value' => \n\t\t\t\twfUtils::array_choose($rateOptions, wfConfig::get('max404Humans'), true, __('(unknown)', 'wordfence')) . \"\\n\" .\n\t\t\t\twfUtils::array_choose($actionOptions, wfConfig::get('max404Humans_action'), true, __('(unknown)', 'wordfence'))),\n\t\t\tarray('description' => __('How long is an IP address blocked when it breaks a rule', 'wordfence'), 'value' => wfConfig::getInt('blockedTime')),\n\t\t\tarray('description' => __('Allowlisted 404 URLs', 'wordfence'), 'value' => wfUtils::cleanupOneEntryPerLine(wfConfig::get('allowed404s'))),\n\t\t\t\n\t\t\tarray('subheader' => __('Country Blocking', 'wordfence')),\n\t\t\tarray('description' => __('What to do when we block someone', 'wordfence'),\n\t\t\t\t'value' => wfUtils::array_choose(array('block' => __('Show the standard Wordfence blocked message', 'wordfence'), 'redir' => __('Redirect to the URL below', 'wordfence')), wfConfig::get('cbl_action'), true, __('(unknown)', 'wordfence'))),\n\t\t\tarray('description' => __('URL to redirect blocked users to', 'wordfence'), 'value' => wfUtils::string_empty(wfConfig::get('cbl_redirURL'), __('(empty)', 'wordfence'))),\n\t\t\tarray('description' => __('Block countries even if they are logged in', 'wordfence'), 'value' => !!wfConfig::get('cbl_loggedInBlocked') ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\tarray('description' => __('Bypass Redirect', 'wordfence'), 'value' => wfUtils::string_empty(wfConfig::get('cbl_bypassRedirURL'), __('(empty)', 'wordfence')) . ' -> ' . wfUtils::string_empty(wfConfig::get('cbl_bypassRedirDest'), __('(empty)', 'wordfence'))),\n\t\t\tarray('description' => __('Bypass Cookie', 'wordfence'), 'value' => wfUtils::string_empty(wfConfig::get('cbl_bypassViewURL'), __('(empty)', 'wordfence'))),\n\t\t);\n\t}\n\t\n\tpublic static function getWordfenceCentralValues() {\n\t\treturn array(\n\t\t\tarray('description' => __('Connected', 'wordfence'), 'value' => wfConfig::get('wordfenceCentralConnected') ? __('true', 'wordfence') : __('false', 'wordfence')),\n\t\t\tarray('description' => __('Connect Timestamp', 'wordfence'), 'value' => wfConfig::getInt('wordfenceCentralConnectTime') > 0 ? wfConfig::getInt('wordfenceCentralConnectTime') : __('(not set)', 'wordfence')),\n\t\t\tarray('description' => __('Site ID', 'wordfence'), 'value' => wfUtils::string_empty(wfConfig::get('wordfenceCentralSiteID'), __('(empty)', 'wordfence'))),\n\t\t\tarray('description' => __('Disconnected', 'wordfence'), 'value' => wfConfig::get('wordfenceCentralDisconnected') ? __('true', 'wordfence') : __('false', 'wordfence')),\n\t\t\tarray('description' => __('Disconnect Timestamp', 'wordfence'), 'value' => wfConfig::getInt('wordfenceCentralDisconnectTime') > 0 ? wfConfig::getInt('wordfenceCentralDisconnectTime') : __('(not set)', 'wordfence')),\n\t\t\tarray('description' => __('Configuration Issue', 'wordfence'), 'value' => wfConfig::get('wordfenceCentralConfigurationIssue') ? __('true', 'wordfence') : __('false', 'wordfence')),\n\t\t\tarray('description' => __('Plugin Alerting Disabled', 'wordfence'), 'value' => wfConfig::get('wordfenceCentralPluginAlertingDisabled') ? __('true', 'wordfence') : __('false', 'wordfence')),\n\t\t);\n\t}\n}"},{"base":"plugins","rel":"wordfence\/lib\/wordfenceURLHoover.php","ext":"php","size":18793,"mtime":1757312769,"type":"text","content":"<?php\nrequire_once(dirname(__FILE__) . '\/wfAPI.php');\nrequire_once(dirname(__FILE__) . '\/wfBinaryList.php');\nclass wordfenceURLHoover {\n\tprivate $debug = false;\n\tpublic $errorMsg = false;\n\tprivate $hostsToAdd = false;\n\tprivate $table = '';\n\tprivate $apiKey = false;\n\tprivate $wordpressVersion = false;\n\tprivate $useDB = true;\n\tprivate $hostKeys = array();\n\tprivate $hostList = array();\n\tpublic $currentHooverID = false;\n\tprivate $_foundSome = false;\n\tprivate $_excludedHosts = array();\n\tprivate $api = false;\n\tprivate $db = false;\n\t\n\tpublic static function standardExcludedHosts() {\n\t\tstatic $standardExcludedHosts = null;\n\t\tif ($standardExcludedHosts !== null) {\n\t\t\treturn $standardExcludedHosts;\n\t\t}\n\t\t\n\t\tglobal $wpdb;\n\t\t$excludedHosts = array();\n\t\tif (is_multisite()) {\n\t\t\t$blogIDs = $wpdb->get_col(\"SELECT blog_id FROM {$wpdb->blogs}\"); \/\/Can't use wp_get_sites or get_sites because they return empty at 10k sites\n\t\t\tforeach ($blogIDs as $id) {\n\t\t\t\t$homeURL = get_home_url($id);\n\t\t\t\t$host = parse_url($homeURL, PHP_URL_HOST);\n\t\t\t\tif ($host) {\n\t\t\t\t\t$excludedHosts[$host] = 1;\n\t\t\t\t}\n\t\t\t\t$siteURL = get_site_url($id);\n\t\t\t\t$host = parse_url($siteURL, PHP_URL_HOST);\n\t\t\t\tif ($host) {\n\t\t\t\t\t$excludedHosts[$host] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t$homeURL = wfUtils::wpHomeURL();\n\t\t\t$host = parse_url($homeURL, PHP_URL_HOST);\n\t\t\tif ($host) {\n\t\t\t\t$excludedHosts[$host] = 1;\n\t\t\t}\n\t\t\t$siteURL = wfUtils::wpSiteURL();\n\t\t\t$host = parse_url($siteURL, PHP_URL_HOST);\n\t\t\tif ($host) {\n\t\t\t\t$excludedHosts[$host] = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\t$standardExcludedHosts = array_keys($excludedHosts);\n\t\treturn $standardExcludedHosts;\n\t}\n\t\n\tpublic function __sleep() {\n\t\t$this->writeHosts();\t\n\t\treturn array('debug', 'errorMsg', 'apiKey', 'wordpressVersion');\n\t}\n\t\n\tpublic function __wakeup() {\n\t\t$this->hostsToAdd = array();\n\t\t$this->api = new wfAPI($this->apiKey, $this->wordpressVersion);\n\t\t$this->db = new wfDB();\n\t\t\n\t\tglobal $wpdb;\n\t\t$this->table = isset($wpdb) ? wfDB::networkTable('wfHoover') : 'wp_wfHoover';\n\t}\n\t\n\tpublic function __construct($apiKey, $wordpressVersion, $continuation = false) {\n\t\t$this->hostsToAdd = array();\n\t\t$this->apiKey = $apiKey;\n\t\t$this->wordpressVersion = $wordpressVersion;\n\t\t$this->api = new wfAPI($apiKey, $wordpressVersion);\n\t\t$this->db = new wfDB();\n\t\t\n\t\tglobal $wpdb;\n\t\t$this->table = isset($wpdb) ? wfDB::networkTable('wfHoover') : 'wp_wfHoover';\n\t\t\n\t\tif (!$continuation) {\n\t\t\t$this->cleanup();\n\t\t}\n\t}\n\t\n\tpublic function cleanup() {\n\t\t$this->db->truncate($this->table);\n\t}\n\t\n\tpublic function hoover($id, $data, $excludedHosts = array()) {\n\t\t$this->currentHooverID = $id;\n\t\t$this->_foundSome = 0;\n\t\t$this->_excludedHosts = $excludedHosts;\n\t\t@preg_replace_callback('_((?:(?:\/\/)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[a-z\\xa1-\\xff0-9.-]+)(?:\\.(?:(?:xn--[a-z\\xa1-\\xff0-9-]+)|[a-z\\xa1-\\xff]{2,}))))(?::\\d{2,5})?)(?:\/[a-z0-9\\-\\_\\.~\\!\\*\\(\\);\\:@&\\=\\+\\$,\\?#\\[\\]%]*)*)_iS', array($this, 'captureURL'), $data);\n\t\t$this->writeHosts();\n\t\treturn $this->_foundSome;\n\t}\n\t\n\tprivate function dbg($msg) { \n\t\tif ($this->debug) { wordfence::status(4, 'info', $msg); } \n\t}\n\t\n\tpublic function captureURL($matches) {\n\t\t$id = $this->currentHooverID;\n\t\t$url = 'http:' . $matches[0];\n\t\tif (!filter_var($url, FILTER_VALIDATE_URL)) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t$components = parse_url($url);\n\t\tif (preg_match('\/\\.(xn--(?:[a-z0-9-]*)[a-z0-9]+|[a-z\\xa1-\\xff0-9]{2,})$\/i', $components['host'], $tld)) {\n\t\t\t$tld = strtolower($tld[1]);\n\t\t\tif (strpos(wfConfig::get('tldlist', ''), '|' . $tld . '|') === false) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tforeach ($this->_excludedHosts as $h) {\n\t\t\tif (strcasecmp($h, $components['host']) === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\t$this->_foundSome++;\n\t\t\n\t\t$host = (isset($components['host']) ? $components['host'] : '');\n\t\t$hashes = $this->_generateHashes($url);\n\t\tforeach ($hashes as $h) {\n\t\t\t$this->_queueHost($id, $host, wfUtils::substr($h, 0, 4));\n\t\t}\n\t\t\n\t\tif (count($this->hostsToAdd) > 1000){ $this->writeHosts(); }\n\t}\n\t\n\t\/**\n\t * Queues the host for writing to the DB. Deduplication is performed here to minimize the row count on sites with \n\t * large numbers of found URLs, and the exclusions lists have already been processed by the time it reaches this \n\t * point.\n\t * \n\t * @param string $owner\n\t * @param string $host\n\t * @param string $key\n\t *\/\n\tprivate function _queueHost($owner, $host, $key) {\n\t\t$indexKey = md5($owner . '|' . $host, true);\n\t\tif (array_key_exists($indexKey, $this->hostsToAdd)) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t$this->hostsToAdd[$indexKey] = array('owner' => $owner, 'host' => $host, 'hostKey' => $key);\n\t}\n\t\n\tprivate function writeHosts() {\n\t\tif (count($this->hostsToAdd) < 1) { return; }\n\t\tif ($this->useDB) {\n\t\t\t$sql = \"INSERT INTO \" . $this->table . \" (owner, host, path, hostKey) VALUES \";\n\t\t\twhile ($elem = array_shift($this->hostsToAdd)) {\n\t\t\t\t\/\/This may be an issue for hyperDB or other abstraction layers, but leaving it for now.\n\t\t\t\t$sql .= sprintf(\"('%s', '%s', '', '%s'),\", \n\t\t\t\t\t\t$this->db->realEscape($elem['owner']),\n\t\t\t\t\t\t$this->db->realEscape($elem['host']),\n\t\t\t\t\t\t$this->db->realEscape($elem['hostKey'])\n\t\t\t\t\t\t\t\t);\n\t\t\t}\n\t\t\t$sql = rtrim($sql, ',');\n\t\t\t$this->db->queryWrite($sql);\n\t\t}\n\t\telse {\n\t\t\twhile ($elem = array_shift($this->hostsToAdd)) {\n\t\t\t\t$keys = str_split($elem['hostKey'], 4);\n\t\t\t\tforeach ($keys as $k) {\n\t\t\t\t\t$this->hostKeys[] = $k;\n\t\t\t\t}\n\t\t\t\t$this->hostList[] = array(\n\t\t\t\t\t'owner' => $elem['owner'],\n\t\t\t\t\t'host' => $elem['host'],\n\t\t\t\t\t'hostKey' => $elem['hostKey']\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\tpublic function getBaddies() {\n\t\twordfence::status(4, 'info', __(\"Gathering host keys.\", 'wordfence'));\n\t\t$allHostKeys = '';\n\t\tif ($this->useDB) {\n\t\t\tglobal $wpdb;\n\t\t\t$dbh = $wpdb->dbh;\n\t\t\t$useMySQLi = wfUtils::useMySQLi();\n\t\t\tif ($useMySQLi) { \/\/If direct-access MySQLi is available, we use it to minimize the memory footprint instead of letting it fetch everything into an array first\n\t\t\t\twordfence::status(4, 'info', __(\"Using MySQLi directly.\", 'wordfence'));\n\t\t\t\t$result = $dbh->query(\"SELECT DISTINCT hostKey FROM {$this->table} ORDER BY hostKey ASC LIMIT 100000\"); \/* We limit to 100,000 prefixes since more than that cannot be reliably checked within the default max_execution_time *\/\n\t\t\t\tif (!is_object($result)) {\n\t\t\t\t\t$this->errorMsg = \"Unable to query database\";\n\t\t\t\t\t$this->dbg($this->errorMsg);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\twhile ($row = $result->fetch_assoc()) {\n\t\t\t\t\t$allHostKeys .= $row['hostKey'];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$q1 = $this->db->querySelect(\"SELECT DISTINCT hostKey FROM {$this->table} ORDER BY hostKey ASC LIMIT 100000\"); \/* We limit to 100,000 prefixes since more than that cannot be reliably checked within the default max_execution_time *\/\n\t\t\t\tforeach ($q1 as $hRec) {\n\t\t\t\t\t$allHostKeys .= $hRec['hostKey'];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t$allHostKeys = implode('', array_values(array_unique($this->hostKeys)));\n\t\t}\n\t\t\n\t\t\/**\n\t\t * Check hash prefixes first. Each one is a 4-byte binary prefix of a SHA-256 hash of the URL. The response will\n\t\t * be a binary list of 4-byte indices; The full URL for each index should be sent in the secondary query to\n\t\t * find the true good\/bad status.\n\t\t *\/\n\t\t\n\t\t$allCount = wfUtils::strlen($allHostKeys) \/ 4;\n\t\tif ($allCount > 0) {\n\t\t\tif ($this->debug) {\n\t\t\t\t$this->dbg(\"Checking {$allCount} hostkeys\");\n\t\t\t\tfor ($i = 0; $i < $allCount; $i++) {\n\t\t\t\t\t$key = wfUtils::substr($allHostKeys, $i * 4, 4);\n\t\t\t\t\t$this->dbg(\"Checking hostkey: \" . bin2hex($key));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\twordfence::status(2, 'info', sprintf(\/* translators: Number of domains. *\/ __(\"Checking %d host keys against Wordfence scanning servers.\", 'wordfence'), $allCount));\n\t\t\t$resp = $this->api->binCall('check_host_keys', $allHostKeys);\n\t\t\twordfence::status(2, 'info', __(\"Done host key check.\", 'wordfence'));\n\t\t\t$this->dbg(\"Done host key check\");\n\n\t\t\t$badHostKeys = '';\n\t\t\tif ($resp['code'] >= 200 && $resp['code'] <= 299) {\n\t\t\t\t$this->dbg(\"Host key response: \" . bin2hex($resp['data']));\n\t\t\t\t$dataLen = wfUtils::strlen($resp['data']);\n\t\t\t\tif ($dataLen > 0 && $dataLen % 2 == 0) {\n\t\t\t\t\t$this->dbg(\"Checking response indexes\");\n\t\t\t\t\tfor ($i = 0; $i < $dataLen; $i += 2) {\n\t\t\t\t\t\t$idx = wfUtils::array_first(unpack('n', wfUtils::substr($resp['data'], $i, 2)));\n\t\t\t\t\t\t$this->dbg(\"Checking index {$idx}\");\n\t\t\t\t\t\tif ($idx < $allCount) {\n\t\t\t\t\t\t\t$prefix = wfUtils::substr($allHostKeys, $idx * 4, 4);\n\t\t\t\t\t\t\t$badHostKeys .= $prefix;\n\t\t\t\t\t\t\t$this->dbg(\"Got bad hostkey for record: \" . bin2hex($prefix));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t$this->dbg(\"Bad allHostKeys index: {$idx}\");\n\t\t\t\t\t\t\t$this->errorMsg = \"Bad allHostKeys index: {$idx}\";\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ($dataLen > 0) {\n\t\t\t\t\t$this->errorMsg = \"Invalid data length received from Wordfence server: \" . $dataLen;\n\t\t\t\t\t$this->dbg($this->errorMsg);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$this->errorMsg = \"Wordfence server responded with an error. HTTP code \" . $resp['code'] . \" and data: \" . $resp['data'];\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\t$badCount = wfUtils::strlen($badHostKeys) \/ 4;\n\t\t\tif ($badCount > 0) {\n\t\t\t\t$urlsToCheck = array();\n\t\t\t\t$totalURLs = 0;\n\t\t\t\t\n\t\t\t\t\/\/Reconcile flagged prefixes with their corresponding URLs\n\t\t\t\tfor ($i = 0; $i < $badCount; $i++) {\n\t\t\t\t\t$prefix = wfUtils::substr($badHostKeys, $i * 4, 4);\n\t\t\t\t\t\n\t\t\t\t\tif ($this->useDB) {\n\t\t\t\t\t\t\/**\n\t\t\t\t\t\t * Putting a 10000 limit in here for sites that have a huge number of items with the same URL \n\t\t\t\t\t\t * that repeats. This is an edge case. But if the URLs are malicious then presumably the admin \n\t\t\t\t\t\t * will fix the malicious URLs and on subsequent scans the items (owners) that are above the \n\t\t\t\t\t\t * 10000 limit will appear.\n\t\t\t\t\t\t *\/\n\t\t\t\t\t\t$q1 = $this->db->querySelect(\"SELECT DISTINCT owner, host FROM {$this->table} WHERE hostKey = %s LIMIT 10000\", $prefix);\n\t\t\t\t\t\tforeach ($q1 as $rec) {\n\t\t\t\t\t\t\t$url = 'http:\/\/' . $rec['host'];\n\t\t\t\t\t\t\tif (!isset($urlsToCheck[$rec['owner']])) {\n\t\t\t\t\t\t\t\t$urlsToCheck[$rec['owner']] = array();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!in_array($url, $urlsToCheck[$rec['owner']])) {\n\t\t\t\t\t\t\t\t$urlsToCheck[$rec['owner']][] = $url;\n\t\t\t\t\t\t\t\t$totalURLs++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tforeach ($this->hostList as $rec) {\n\t\t\t\t\t\t\t$pos = wfUtils::strpos($rec['hostKey'], $prefix);\n\t\t\t\t\t\t\tif ($pos !== false && $pos % 4 == 0) {\n\t\t\t\t\t\t\t\t$url = 'http:\/\/' . $rec['host'];\n\t\t\t\t\t\t\t\tif (!isset($urlsToCheck[$rec['owner']])) {\n\t\t\t\t\t\t\t\t\t$urlsToCheck[$rec['owner']] = array();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!in_array($url, $urlsToCheck[$rec['owner']])) {\n\t\t\t\t\t\t\t\t\t$urlsToCheck[$rec['owner']][] = $url;\n\t\t\t\t\t\t\t\t\t$totalURLs++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ($totalURLs > 10000) { break; }\n\t\t\t\t}\n\n\t\t\t\tif (count($urlsToCheck) > 0) {\n\t\t\t\t\twordfence::status(2, 'info', sprintf(\n\t\t\t\t\t\t\/* translators: 1. Number of URLs. 2. Number of files. *\/\n\t\t\t\t\t\t__('Checking %1$d URLs from %2$d sources.', 'wordfence'),\n\t\t\t\t\t\t$totalURLs,\n\t\t\t\t\t\tsizeof($urlsToCheck)\n\t\t\t\t\t));\n\t\t\t\t\t$badURLs = $this->api->call('check_bad_urls', array(), array('toCheck' => json_encode($urlsToCheck)));\n\t\t\t\t\twordfence::status(2, 'info', __(\"Done URL check.\", 'wordfence'));\n\t\t\t\t\t$this->dbg(\"Done URL check\");\n\t\t\t\t\tif (is_array($badURLs) && count($badURLs) > 0) {\n\t\t\t\t\t\t$finalResults = array();\n\t\t\t\t\t\tforeach ($badURLs as $file => $badSiteList) {\n\t\t\t\t\t\t\tif (!isset($finalResults[$file])) {\n\t\t\t\t\t\t\t\t$finalResults[$file] = array();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tforeach ($badSiteList as $badSite) {\n\t\t\t\t\t\t\t\t$finalResults[$file][] = array(\n\t\t\t\t\t\t\t\t\t'URL' => $badSite[0],\n\t\t\t\t\t\t\t\t\t'badList' => $badSite[1]\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$this->dbg(\"Confirmed \" . count($badURLs) . \" bad URLs\");\n\t\t\t\t\t\treturn $finalResults;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn array();\n\t}\n\t\n\t\/**\n\t * Computes the canonical URL for $url and generates the hash variants that we'll check the safe browsing list for.\n\t * \n\t * @param string $url\n\t * @return string[]\n\t *\/\n\tprotected function _generateHashes($url) {\n\t\t$canonicalURL = $this->_canonicalizeURL($url);\n\t\t\n\t\t\/\/Extract the scheme\n\t\t$scheme = 'http';\n\t\tif (preg_match('~^([a-z]+[a-z0-9+\\.\\-]*):\/\/(.*)$~i', $canonicalURL, $matches)) {\n\t\t\t$scheme = strtolower($matches[1]);\n\t\t\t$canonicalURL = $matches[2];\n\t\t}\n\t\t\n\t\t\/\/Separate URL and query string\n\t\t$query = '';\n\t\tif (preg_match('\/^([^?]+)(\\??.*)\/', $canonicalURL, $matches)) {\n\t\t\t$canonicalURL = $matches[1];\n\t\t\t$query = $matches[2];\n\t\t}\n\t\t\n\t\t\/\/Separate host and path\n\t\t$path = '';\n\t\tpreg_match('~^(.*?)(?:(\/.*)|$)~', $canonicalURL, $matches);\n\t\t$host = $matches[1];\n\t\tif (isset($matches[2])) {\n\t\t\t$path = $matches[2];\n\t\t}\n\t\t\n\t\t\/\/Clean host\n\t\t$host = $this->_normalizeHost($host);\n\t\t\n\t\t\/\/Generate hosts list\n\t\t$hosts = array();\n\t\tif (filter_var(trim($host, '[]'), FILTER_VALIDATE_IP)) {\n\t\t\t$hosts[] = $host;\n\t\t}\n\t\telse {\n\t\t\t$hostComponents = explode('.', $host);\n\t\t\t\n\t\t\t$numComponents = count($hostComponents) - 7;\n\t\t\tif ($numComponents < 1) {\n\t\t\t\t$numComponents = 1;\n\t\t\t}\n\t\t\t\n\t\t\t$hosts[] = $host;\n\t\t\tfor ($i = $numComponents; $i < count($hostComponents) - 1; $i++) {\n\t\t\t\t$hosts[] = implode('.', array_slice($hostComponents, $i));\n\t\t\t}\n\t\t}\n\t\t\n\t\t\/\/Generate hashes\n\t\t$hashes = array();\n\t\tforeach ($hosts as $h) {\n\t\t\tif (($hash = $this->_shouldCheckHost($h)) !== false) {\n\t\t\t\t$hashes[$h] = $hash; \/\/WFSB preferred hash -- it uses hashes without any path\n\t\t\t}\n\t\t\t\n\t\t\t\/\/Future hash needs may be added here\n\t\t}\n\t\t\n\t\treturn $hashes;\n\t}\n\t\n\tprotected function _canonicalizeURL($url) { \/\/Based on https:\/\/developers.google.com\/safe-browsing\/v4\/urls-hashing#canonicalization and Google's reference implementation https:\/\/github.com\/google\/safebrowsing\/blob\/master\/urls.go\n\t\t\/\/Strip fragment\n\t\t$url = $this->_array_first(explode('#', $url));\n\t\t\n\t\t\/\/Trim space\n\t\t$url = trim($url);\n\t\t\n\t\t\/\/Remove tabs, CR, LF\n\t\t$url = preg_replace('\/[\\t\\n\\r]\/', '', $url);\n\t\t\n\t\t\/\/Normalize escapes\n\t\t$url = $this->_normalizeEscape($url);\n\t\tif ($url === false) { return false; }\n\t\t\n\t\t\/\/Extract the scheme\n\t\t$scheme = 'http';\n\t\tif (preg_match('~^([a-z]+[a-z0-9+\\.\\-]*):\/\/(.*)$~i', $url, $matches)) {\n\t\t\t$scheme = strtolower($matches[1]);\n\t\t\t$url = $matches[2];\n\t\t}\n\t\t\n\t\t\/\/Separate URL and query string\n\t\t$query = '';\n\t\tif (preg_match('\/^([^?]+)(\\??.*)\/', $url, $matches)) {\n\t\t\t$url = $matches[1];\n\t\t\t$query = $matches[2];\n\t\t}\n\t\t$endsWithSlash = substr($url, -1) == '\/';\n\t\t\n\t\t\/\/Separate host and path\n\t\t$path = '';\n\t\tpreg_match('~^(.*?)(?:(\/.*)|$)~', $url, $matches);\n\t\t$host = $matches[1];\n\t\tif (isset($matches[2])) {\n\t\t\t$path = $matches[2];\n\t\t}\n\t\t\n\t\t\/\/Clean host\n\t\t$host = $this->_normalizeHost($host);\n\t\tif ($host === false) { return false; }\n\t\t\n\t\t\/\/Clean path\n\t\t$path = preg_replace('~\/\/+~', '\/', $path); \/\/Multiple slashes -> single slash\n\t\t$path = preg_replace('~(?:^|\/)\\.(?:$|\/)~', '\/', $path); \/\/. path components removed\n\t\twhile (preg_match('~\/(?!\\.\\.\/)[^\/]+\/\\.\\.(?:$|\/)~', $path)) { \/\/Resolve ..\n\t\t\t$path = preg_replace('~\/(?!\\.\\.\/)[^\/]+\/\\.\\.(?:$|\/)~', '\/', $path, 1);\n\t\t}\n\t\t$path = preg_replace('~(?:^|\/)\\.\\.(?:$|\/)~', '\/', $path); \/\/Eliminate .. at the beginning\n\t\t$path = trim($path, '.');\n\t\t$path = preg_replace('\/\\.\\.+\/', '.', $path);\n\t\t\n\t\tif ($path == '.' || $path == '') {\n\t\t\t$path = '\/';\n\t\t}\n\t\telse if ($endsWithSlash && substr($path, -1) != '\/') {\n\t\t\t$path .= '\/';\n\t\t}\n\t\t\n\t\treturn $scheme . ':\/\/' . $host . $path . $query;\n\t}\n\t\n\tprotected function _normalizeEscape($url) {\n\t\t$maxDepth = 1024;\n\t\t$i = 0;\n\t\twhile (preg_match('\/%([0-9a-f]{2})\/i', $url)) {\n\t\t\t$url = preg_replace_callback('\/%([0-9a-f]{2})\/i', array($this, '_hex2binCallback'), $url);\n\t\t\t$i++;\n\t\t\t\n\t\t\tif ($i > $maxDepth) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn preg_replace_callback('\/[\\x00-\\x20\\x7f-\\xff#%]\/', array($this, '_bin2hexCallback'), $url);\n\t}\n\t\n\tprotected function _hex2binCallback($matches) {\n\t\treturn wfUtils::hex2bin($matches[1]);\n\t}\n\n\tprotected function _bin2hexCallback($matches) {\n\t\treturn '%' . bin2hex($matches[0]);\t\n\t}\n\t\n\tprotected function _normalizeHost($host) {\n\t\t\/\/Strip username:password\n\t\t$host = $this->_array_last(explode('@', $host));\n\t\t\n\t\t\/\/IPv6 literal\n\t\tif (substr($host, 0, 1) == '[') {\n\t\t\tif (strpos($host, ']') === false) { \/\/No closing bracket\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\/\/Strip port\n\t\t$host = preg_replace('\/:\\d+$\/', '', $host);\n\t\t\n\t\t\/\/Unicode to IDNA\n\t\t$u = rawurldecode($host);\n\t\tif (preg_match('\/[\\x81-\\xff]\/', $u)) { \/\/0x80 is technically Unicode, but the GSB canonicalization doesn't consider it one\n\t\t\tif (function_exists('idn_to_ascii')) { \/\/Some PHP versions don't have this and we don't have a polyfill\n\t\t\t\t$host = idn_to_ascii($u);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\/\/Remove extra dots\n\t\t$host = trim($host, '.');\n\t\t$host = preg_replace('\/\\.\\.+\/', '.', $host);\n\t\t\n\t\t\/\/Canonicalize IP addresses\n\t\tif ($iphost = $this->_parseIP($host)) {\n\t\t\treturn $iphost;\n\t\t}\n\t\t\n\t\treturn strtolower($host);\n\t}\n\t\n\tprotected function _parseIP($host) {\n\t\t\/\/ The Windows resolver allows a 4-part dotted decimal IP address to have a\n\t\t\/\/ space followed by any old rubbish, so long as the total length of the\n\t\t\/\/ string doesn't get above 15 characters. So, \"10.192.95.89 xy\" is\n\t\t\/\/ resolved to 10.192.95.89. If the string length is greater than 15\n\t\t\/\/ characters, e.g. \"10.192.95.89 xy.wildcard.example.com\", it will be\n\t\t\/\/ resolved through DNS.\n\t\tif (strlen($host) <= 15) {\n\t\t\t$host = $this->_array_first(explode(' ', $host));\n\t\t}\n\t\t\n\t\tif (!preg_match('\/^((?:0x[0-9a-f]+|[0-9\\.])+)$\/i', $host)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t$parts = explode('.', $host);\n\t\tif (count($parts) > 4) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t$strings = array();\n\t\tforeach ($parts as $i => $p) {\n\t\t\tif ($i == count($parts) - 1) {\n\t\t\t\t$strings[] = $this->_canonicalNum($p, 5 - count($parts));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$strings[] = $this->_canonicalNum($p, 1);\n\t\t\t}\n\t\t\t\n\t\t\tif ($strings[$i] == '') {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn implode('.', $strings);\n\t}\n\t\n\tprotected function _canonicalNum($part, $n) {\n\t\tif ($n <= 0 || $n > 4) {\n\t\t\treturn '';\n\t\t}\n\t\t\n\t\tif (preg_match('\/^0x(\\d+)$\/i', $part, $matches)) { \/\/hex\n\t\t\t$part = hexdec($matches[1]);\n\t\t}\n\t\telse if (preg_match('\/^0(\\d+)$\/i', $part, $matches)) { \/\/octal\n\t\t\t$part = octdec($matches[1]);\n\t\t}\n\t\telse {\n\t\t\t$part = (int) $part;\n\t\t}\n\t\t\n\t\t$strings = array_fill(0, $n, '');\n\t\tfor ($i = $n - 1; $i >= 0; $i--) {\n\t\t\t$strings[$i] = (string) ($part & 0xff);\n\t\t\t$part = $part >> 8;\n\t\t}\n\t\treturn implode('.', $strings);\n\t}\n\t\n\t\/**\n\t * Checks whether the host should be included or not by querying the skip list. If yes, returns the binary sha256 \n\t * hash of it.\n\t * \n\t * @param string $host\n\t * @return false|string\n\t *\/\n\tprotected function _shouldCheckHost($host) {\n\t\tstatic $skipList = null;\n\t\tif ($skipList == null) {\n\t\t\t$skipList = new wfBinaryList(base64_decode(wfConfig::get('wfsbskip', '')));\n\t\t}\n\t\t$hash = hash('sha256', $host, true);\n\t\treturn $skipList->contains($hash) === false ? $hash : false;\n\t}\n\t\n\tprotected function _array_first($array) {\n\t\tif (empty($array)) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\treturn $array[0];\n\t}\n\t\n\tprotected function _array_last($array) {\n\t\tif (empty($array)) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\treturn $array[count($array) - 1];\n\t}\n}"},{"base":"plugins","rel":"wordfence\/lib\/menu_tools_diagnostic.php","ext":"php","size":51074,"mtime":1757312769,"type":"text","content":"<?php\nif (!defined('WORDFENCE_VERSION')) { exit; }\n\n\/** @var boolean $inEmail *\/\n\n$diagnostic = new wfDiagnostic;\n$plugins = get_plugins();\n$activePlugins = array_flip(get_option('active_plugins'));\n$activeNetworkPlugins = is_multisite() ? array_flip(wp_get_active_network_plugins()) : array();\n$muPlugins = get_mu_plugins();\n$themes = wp_get_themes();\n$currentTheme = wp_get_theme();\n$cols = 3;\n\n$w = new wfConfig();\nif (!isset($sendingDiagnosticEmail)) {\n\t$sendingDiagnosticEmail = false;\n}\n?>\n<?php if (!$sendingDiagnosticEmail): ?>\n<script type=\"application\/javascript\">\n\t(function($) {\n\t\t$(function() {\n\t\t\tdocument.title = \"<?php esc_attr_e('Diagnostics', 'wordfence'); ?>\" + \" \\u2039 \" + WFAD.basePageName;\n\t\t});\n\t})(jQuery);\n<\/script>\n<?php endif; ?>\n<div id=\"wf-diagnostics\">\n\t<?php if (!$sendingDiagnosticEmail): ?>\n\t\t<div class=\"wf-diagnostics-wrapper\">\n\t\t\t<div class=\"wf-flex-row\">\n\t\t\t\t<div class=\"wf-flex-row-1\">\n\t\t\t\t\t<?php echo wp_kses(sprintf(__('This page shows information that can be used for troubleshooting conflicts, configuration issues, or compatibility with other plugins, themes, or a host\\'s environment. Failing tests are not always a sign of something that you need to fix, but can help the Wordfence team when troubleshooting a problem. (<a href=\"%s\" target=\"_blank\" rel=\"noopener noreferrer\">Learn More <span class=\"screen-reader-text\">opens in new tab<\/span><\/a>)', 'wordfence'), wfSupportController::esc_supportURL(wfSupportController::ITEM_DIAGNOSTICS)), array('a' => array('href' => array(), 'target' => array(), 'rel' => array()), 'span' => array('class' => array()))) ?>\n\t\t\t\t<\/div>\n\t\t\t\t<div class=\"wf-flex-row-0 wf-padding-add-left\">\n\t\t\t\t\t<div id=\"sendByEmailThanks\" class=\"hidden\">\n\t\t\t\t\t\t<h3><?php esc_html_e('Thanks for sending your diagnostic page over email', 'wordfence'); ?><\/h3>\n\t\t\t\t\t<\/div>\n\t\t\t\t\t<div id=\"sendByEmailDiv\" class=\"wf-add-bottom\">\n\t\t\t\t\t\t<span class=\"wf-nowrap\">\n\t\t\t\t\t\t\t<input class=\"wf-btn wf-btn-primary wf-btn-sm\" type=\"submit\" id=\"exportDiagnostics\" value=\"Export\"\/>\n\t\t\t\t\t\t\t<input class=\"wf-btn wf-btn-primary wf-btn-sm\" type=\"submit\" id=\"sendByEmail\" value=\"Send Report by Email\"\/>\n\t\t\t\t\t\t\t<input class=\"wf-btn wf-btn-default wf-btn-sm\" type=\"button\" id=\"expandAllDiagnostics\" value=\"Expand All Diagnostics\"\/>\n\t\t\t\t\t\t<\/span>\n\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t<\/div>\n\t\t\t<div id=\"sendByEmailForm\" class=\"wf-block wf-active hidden\">\n\t\t\t\t<div class=\"wf-block-header\">\n\t\t\t\t\t<div class=\"wf-block-header-content\">\n\t\t\t\t\t\t<div class=\"wf-block-title\">\n\t\t\t\t\t\t\t<strong><?php esc_html_e('Send Report by Email', 'wordfence') ?><\/strong>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\t<div class=\"wf-block-content wf-clearfix\">\n\t\t\t\t\t<ul class=\"wf-block-list\">\n\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t<div><?php esc_html_e('Email address:', 'wordfence'); ?><\/div>\n\t\t\t\t\t\t\t<div style=\"width: 40%\">\n\t\t\t\t\t\t\t\t<p><input class=\"wf-input-text\" type=\"email\" id=\"_email\" value=\"wftest@wordfence.com\"\/>\n\t\t\t\t\t\t\t\t<\/p>\n\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t<div><?php esc_html_e('Ticket Number\/Forum Username:', 'wordfence'); ?><\/div>\n\t\t\t\t\t\t\t<div style=\"width: 40%\">\n\t\t\t\t\t\t\t\t<p><input class=\"wf-input-text\" type=\"text\" id=\"_ticketnumber\" required\/><\/p>\n\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t<p>\n\t\t\t\t\t\t\t\t<input class=\"wf-btn wf-btn-primary\" type=\"button\" id=\"doSendEmail\" value=\"Send\"\/>\n\t\t\t\t\t\t\t<\/p>\n\t\t\t\t\t\t<\/li>\n\t\t\t\t\t<\/ul>\n\t\t\t\t<\/div>\n\t\t\t<\/div>\n\t\t<\/div>\n\t<?php endif; ?>\n\t<div class=\"wf-diagnostics-wrapper\">\n\t\t<?php foreach ($diagnostic->getResults() as $title => $tests):\n\t\t\t$key = sanitize_key('wf-diagnostics-' . $title);\n\t\t\t$hasFailingTest = false;\n\t\t\tforeach ($tests['results'] as $result) {\n\t\t\t\t$infoOnly = isset($result['infoOnly']) && $result['infoOnly'];\n\t\t\t\tif (!$result['test'] && !$infoOnly) {\n\t\t\t\t\t$hasFailingTest = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ($inEmail): ?>\n\t\t\t\t<table>\n\t\t\t\t\t<thead>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<th colspan=\"2\"><?php echo esc_html($title) ?><\/th>\n\t\t\t\t\t<\/tr>\n\t\t\t\t\t<\/thead>\n\t\t\t\t\t<tbody>\n\t\t\t\t\t<?php foreach ($tests['results'] as $result): ?>\n\t\t\t\t\t\t<?php\n\t\t\t\t\t\t$infoOnly = isset($result['infoOnly']) && $result['infoOnly'];\n\t\t\t\t\t\t?>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td style=\"width: 75%; min-width: 300px\"><?php echo (is_array($result['label']) && isset($result['label']['raw']) && $result['label']['raw'] ? $result['label']['value'] : wp_kses($result['label'], array(\n\t\t\t\t\t\t\t\t\t'code'   => array(),\n\t\t\t\t\t\t\t\t\t'strong' => array(),\n\t\t\t\t\t\t\t\t\t'em'     => array(),\n\t\t\t\t\t\t\t\t\t'a'      => array('href' => true),\n\t\t\t\t\t\t\t\t\t'span'\t => array('class' => true)\n\t\t\t\t\t\t\t\t))) ?><\/td>\n\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<?php if ($infoOnly): ?>\n\t\t\t\t\t\t\t\t\t<div class=\"wf-result-info\"><?php echo (is_array($result['message']) && isset($result['message']['escaped']) ? $result['message']['escaped'] : nl2br(esc_html($result['message']))); ?><\/div>\n\t\t\t\t\t\t\t\t<?php elseif ($result['test']): ?>\n\t\t\t\t\t\t\t\t\t<div class=\"wf-result-success\"><?php echo (is_array($result['message']) && isset($result['message']['escaped']) ? $result['message']['escaped'] : nl2br(esc_html($result['message']))); ?><\/div>\n\t\t\t\t\t\t\t\t<?php elseif (isset($result['warn']) && $result['warn']): ?>\n\t\t\t\t\t\t\t\t\t<div class=\"wf-result-warn\"><?php echo (is_array($result['message']) && isset($result['message']['escaped']) ? $result['message']['escaped'] : nl2br(esc_html($result['message']))); ?><\/div>\n\t\t\t\t\t\t\t\t<?php else: ?>\n\t\t\t\t\t\t\t\t\t<div class=\"wf-result-error\"><?php echo (is_array($result['message']) && isset($result['message']['escaped']) ? $result['message']['escaped'] : nl2br(esc_html($result['message']))); ?><\/div>\n\t\t\t\t\t\t\t\t<?php endif ?>\n\t\t\t\t\t\t\t\t<?php if (isset($result['detail']) && !empty($result['detail'])): ?>\n\t\t\t\t\t\t\t\t\t<p><strong><?php esc_html_e('Additional Detail', 'wordfence'); ?><\/strong><br><?php echo (is_array($result['detail']) && isset($result['detail']['escaped']) ? $result['detail']['escaped'] : nl2br(esc_html($result['detail']))); ?><\/p>\n\t\t\t\t\t\t\t\t<?php endif; ?>\n\t\t\t\t\t\t\t<\/td>\n\t\t\t\t\t\t<\/tr>\n\t\t\t\t\t<?php endforeach ?>\n\t\t\t\t\t<\/tbody>\n\t\t\t\t<\/table>\n\t\t\t<?php else: ?>\n\t\t\t\t<div class=\"wf-block<?php echo (wfPersistenceController::shared()->isActive($key) ? ' wf-active' : '') .\n\t\t\t\t\t($hasFailingTest ? ' wf-diagnostic-fail' : '') ?>\" data-persistence-key=\"<?php echo esc_attr($key) ?>\">\n\t\t\t\t\t<div class=\"wf-block-header\">\n\t\t\t\t\t\t<div class=\"wf-block-header-content\">\n\t\t\t\t\t\t\t<div class=\"wf-block-title\">\n\t\t\t\t\t\t\t\t<strong><?php echo esc_html($title) ?><\/strong>\n\t\t\t\t\t\t\t\t<span class=\"wf-text-small\"><?php echo esc_html($tests['description']) ?><\/span>\n\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t<div class=\"wf-block-header-action\">\n\t\t\t\t\t\t\t\t<div class=\"wf-block-header-action-disclosure\" role=\"checkbox\" aria-checked=\"<?php echo (wfPersistenceController::shared()->isActive($key) ? 'true' : 'false'); ?>\" tabindex=\"0\"><\/div>\n\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t\t<\/div>\n\t\t\t\t\t<div class=\"wf-block-content wf-clearfix\">\n\t\t\t\t\t\t<ul class=\"wf-block-list\">\n\t\t\t\t\t\t\t<?php foreach ($tests['results'] as $key => $result): ?>\n\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t$infoOnly = isset($result['infoOnly']) && $result['infoOnly'];\n\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t\t<div style=\"width: 75%; min-width: 300px;\"><?php echo (is_array($result['label']) && isset($result['label']['raw']) && $result['label']['raw'] ? $result['label']['value'] : wp_kses($result['label'], array(\n\t\t\t\t\t\t\t\t\t\t\t'code'   => array(),\n\t\t\t\t\t\t\t\t\t\t\t'strong' => array(),\n\t\t\t\t\t\t\t\t\t\t\t'em'     => array(),\n\t\t\t\t\t\t\t\t\t\t\t'a'      => array('href' => true),\n\t\t\t\t\t\t\t\t\t\t))) ?><\/div>\n\t\t\t\t\t\t\t\t\t<div class=\"wf-right\">\n\t\t\t\t\t\t\t\t\t<?php if ($infoOnly): ?>\n\t\t\t\t\t\t\t\t\t\t<div class=\"wf-result-info\"><?php echo (is_array($result['message']) && isset($result['message']['escaped']) ? $result['message']['escaped'] : nl2br(esc_html($result['message']))); ?><\/div>\n\t\t\t\t\t\t\t\t\t<?php elseif ($result['test']): ?>\n\t\t\t\t\t\t\t\t\t\t<div class=\"wf-result-success\"><?php echo (is_array($result['message']) && isset($result['message']['escaped']) ? $result['message']['escaped'] : nl2br(esc_html($result['message']))); ?><\/div>\n\t\t\t\t\t\t\t\t\t<?php elseif (isset($result['warn']) && $result['warn']): ?>\n\t\t\t\t\t\t\t\t\t\t<div class=\"wf-result-warn\"><?php echo (is_array($result['message']) && isset($result['message']['escaped']) ? $result['message']['escaped'] : nl2br(esc_html($result['message']))); ?><\/div>\n\t\t\t\t\t\t\t\t\t<?php else: ?>\n\t\t\t\t\t\t\t\t\t\t<div class=\"wf-result-error\"><?php echo (is_array($result['message']) && isset($result['message']['escaped']) ? $result['message']['escaped'] : nl2br(esc_html($result['message']))); ?><\/div>\n\t\t\t\t\t\t\t\t\t<?php endif ?>\n\t\t\t\t\t\t\t\t\t<?php if (isset($result['detail']) && !empty($result['detail'])): ?>\n\t\t\t\t\t\t\t\t\t\t\t<p><a href=\"#\" onclick=\"jQuery('#wf-diagnostics-detail-<?php echo esc_attr($key); ?>').show(); jQuery(this).hide(); return false;\" role=\"button\"><?php esc_html_e('View Additional Detail', 'wordfence'); ?><\/a><\/p>\n\t\t\t\t\t\t\t\t\t\t\t<pre class=\"wf-pre wf-split-word\" id=\"wf-diagnostics-detail-<?php echo esc_attr($key); ?>\" style=\"max-width: 600px; display: none;\"><?php echo (is_array($result['detail']) && isset($result['detail']['escaped']) ? $result['detail']['escaped'] : nl2br(esc_html($result['detail']))); ?><\/pre>\n\t\t\t\t\t\t\t\t\t<?php endif; ?>\n\t\t\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t<?php endforeach ?>\n\t\t\t\t\t\t<\/ul>\n\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t<?php endif ?>\n\n\t\t<?php endforeach ?>\n\t\t<?php\n\t\t$howGet = wfConfig::get('howGetIPs', false);\n\t\tlist($currentIP, $currentServerVarForIP) = wfUtils::getIPAndServerVariable();\n\t\t$howGetHasErrors = $howGet && (! $currentServerVarForIP || $howGet !== $currentServerVarForIP);\n\t\t?>\n\t\t<div class=\"wf-block<?php echo ($howGetHasErrors ? ' wf-diagnostic-fail' : '') . (wfPersistenceController::shared()->isActive('wf-diagnostics-client-ip') ? ' wf-active' : '') ?>\" data-persistence-key=\"<?php echo esc_attr('wf-diagnostics-client-ip') ?>\">\n\t\t\t<div class=\"wf-block-header\">\n\t\t\t\t<div class=\"wf-block-header-content\">\n\t\t\t\t\t<div class=\"wf-block-title\">\n\t\t\t\t\t\t<strong><?php esc_html_e('IP Detection', 'wordfence') ?><\/strong>\n\t\t\t\t\t\t<span class=\"wf-text-small\"><?php esc_html_e('Methods of detecting a visitor\\'s IP address.', 'wordfence') ?><\/span>\n\t\t\t\t\t<\/div>\n\t\t\t\t\t<div class=\"wf-block-header-action\">\n\t\t\t\t\t\t<div class=\"wf-block-header-action-disclosure\" role=\"checkbox\" aria-checked=\"<?php echo (wfPersistenceController::shared()->isActive('wf-diagnostics-client-ip') ? 'true' : 'false'); ?>\" tabindex=\"0\"><\/div>\n\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t<\/div>\n\t\t\t<div class=\"wf-block-content wf-clearfix wf-padding-no-left wf-padding-no-right\">\n\n\t\t\t\t<table class=\"wf-striped-table\"<?php echo !empty($inEmail) ? ' border=1' : '' ?>>\n\t\t\t\t\t<tbody class=\"thead\">\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<th><?php esc_html_e('IPs', 'wordfence'); ?><\/th>\n\t\t\t\t\t\t<th><?php esc_html_e('Value', 'wordfence'); ?><\/th>\n\t\t\t\t\t\t<th><?php esc_html_e('Used', 'wordfence'); ?><\/th>\n\t\t\t\t\t<\/tr>\n\t\t\t\t\t<\/tbody>\n\t\t\t\t\t<tbody>\n\t\t\t\t\t<?php\n\t\t\t\t\t$serverVariables = array(\n\t\t\t\t\t\t'REMOTE_ADDR'           => 'REMOTE_ADDR',\n\t\t\t\t\t\t'HTTP_CF_CONNECTING_IP' => 'CF-Connecting-IP',\n\t\t\t\t\t\t'HTTP_X_REAL_IP'        => 'X-Real-IP',\n\t\t\t\t\t\t'HTTP_X_FORWARDED_FOR'  => 'X-Forwarded-For',\n\t\t\t\t\t);\n\t\t\t\t\tforeach (wfUtils::getAllServerVariableIPs() as $variable => $ip): ?>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td><?php echo isset($serverVariables[$variable]) ? $serverVariables[$variable] : $variable ?><\/td>\n\t\t\t\t\t\t\t<td><?php\n\t\t\t\t\t\t\t\tif (! $ip) {\n\t\t\t\t\t\t\t\t\t_e('(not set)', 'wordfence');\n\t\t\t\t\t\t\t\t} elseif (is_array($ip)) {\n\t\t\t\t\t\t\t\t\t$output = array_map('esc_html', $ip);\n\t\t\t\t\t\t\t\t\techo str_replace($currentIP, \"<strong>{$currentIP}<\/strong>\", implode(', ', $output));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\techo esc_html($ip);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t?><\/td>\n\t\t\t\t\t\t\t<?php if ($currentServerVarForIP && $currentServerVarForIP === $variable): ?>\n\t\t\t\t\t\t\t\t<td class=\"wf-result-success\"><?php esc_html_e('In use', 'wordfence'); ?><\/td>\n\t\t\t\t\t\t\t<?php elseif ($howGet === $variable): ?>\n\t\t\t\t\t\t\t\t<td class=\"wf-result-error\"><?php esc_html_e('Configured but not valid', 'wordfence'); ?><\/td>\n\t\t\t\t\t\t\t<?php else: ?>\n\t\t\t\t\t\t\t\t<td><\/td>\n\t\t\t\t\t\t\t<?php endif ?>\n\t\t\t\t\t\t<\/tr>\n\t\t\t\t\t<?php endforeach ?>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td><?php esc_html_e('Trusted Proxies', 'wordfence'); ?><\/td>\n\t\t\t\t\t\t<td><?php $proxies = wfConfig::get('howGetIPs_trusted_proxies', ''); echo esc_html(implode(', ', explode(\"\\n\", empty($proxies) ? __('(not set)', 'wordfence') : $proxies))); ?><\/td>\n\t\t\t\t\t\t<td><\/td>\n\t\t\t\t\t<\/tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td><?php esc_html_e('Trusted Proxy Preset', 'wordfence'); ?><\/td>\n\t\t\t\t\t\t<td><?php $preset = wfConfig::get('howGetIPs_trusted_proxy_preset'); $presets = wfConfig::getJSON('ipResolutionList', array()); echo esc_html((is_array($presets) && isset($presets[$preset])) ? $presets[$preset]['name'] : __('(not set)', 'wordfence')); ?><\/td>\n\t\t\t\t\t\t<td><\/td>\n\t\t\t\t\t<\/tr>\n\t\t\t\t\t<\/tbody>\n\t\t\t\t<\/table>\n\n\t\t\t<\/div>\n\t\t<\/div>\n\n\t\t<div class=\"wf-block<?php echo(wfPersistenceController::shared()->isActive('wf-diagnostics-wordpress-constants') ? ' wf-active' : '') ?>\" data-persistence-key=\"<?php echo esc_attr('wf-diagnostics-wordpress-constants') ?>\">\n\t\t\t<div class=\"wf-block-header\">\n\t\t\t\t<div class=\"wf-block-header-content\">\n\t\t\t\t\t<div class=\"wf-block-title\">\n\t\t\t\t\t\t<strong><?php esc_html_e('WordPress Settings', 'wordfence') ?><\/strong>\n\t\t\t\t\t\t<span class=\"wf-text-small\"><?php esc_html_e('WordPress version and internal settings\/constants.', 'wordfence') ?><\/span>\n\t\t\t\t\t<\/div>\n\t\t\t\t\t<div class=\"wf-block-header-action\">\n\t\t\t\t\t\t<div class=\"wf-block-header-action-disclosure\" role=\"checkbox\" aria-checked=\"<?php echo (wfPersistenceController::shared()->isActive('wf-diagnostics-wordpress-constants') ? 'true' : 'false'); ?>\" tabindex=\"0\"><\/div>\n\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t<\/div>\n\t\t\t<div class=\"wf-block-content wf-clearfix wf-padding-no-left wf-padding-no-right\">\n\t\t\t\t<table class=\"wf-striped-table\"<?php echo !empty($inEmail) ? ' border=1' : '' ?>>\n\t\t\t\t\t<tbody>\n\t\t\t\t\t<?php\n\t\t\t\t\tforeach (wfDiagnostic::getWordpressValues() as $settingName => $settingData):\n\t\t\t\t\t\t$escapedName = esc_html($settingName);\n\t\t\t\t\t\t$escapedDescription = '';\n\t\t\t\t\t\t$escapedValue = __('(not set)', 'wordfence');\n\t\t\t\t\t\tif (is_array($settingData)) {\n\t\t\t\t\t\t\t$escapedDescription = esc_html($settingData['description']);\n\t\t\t\t\t\t\tif (isset($settingData['value'])) {\n\t\t\t\t\t\t\t\t$escapedValue = esc_html($settingData['value']);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$escapedDescription = esc_html($settingData);\n\t\t\t\t\t\t\tif (defined($settingName)) {\n\t\t\t\t\t\t\t\t$escapedValue = esc_html(constant($settingName));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t?>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td><strong><?php echo $escapedName ?><\/strong><\/td>\n\t\t\t\t\t\t\t<td><?php echo $escapedDescription ?><\/td>\n\t\t\t\t\t\t\t<td><?php echo $escapedValue ?><\/td>\n\t\t\t\t\t\t<\/tr>\n\t\t\t\t\t<?php endforeach ?>\n\t\t\t\t\t<\/tbody>\n\t\t\t\t<\/table>\n\t\t\t<\/div>\n\t\t<\/div>\n\n\t\t<div class=\"wf-block<?php echo(wfPersistenceController::shared()->isActive('wf-diagnostics-wordpress-plugins') ? ' wf-active' : '') ?>\" data-persistence-key=\"<?php echo esc_attr('wf-diagnostics-wordpress-plugins') ?>\">\n\t\t\t<div class=\"wf-block-header\">\n\t\t\t\t<div class=\"wf-block-header-content\">\n\t\t\t\t\t<div class=\"wf-block-title\">\n\t\t\t\t\t\t<strong><?php esc_html_e('WordPress Plugins', 'wordfence') ?><\/strong>\n\t\t\t\t\t\t<span class=\"wf-text-small\"><?php esc_html_e('Status of installed plugins.', 'wordfence') ?><\/span>\n\t\t\t\t\t<\/div>\n\t\t\t\t\t<div class=\"wf-block-header-action\">\n\t\t\t\t\t\t<div class=\"wf-block-header-action-disclosure\" role=\"checkbox\" aria-checked=\"<?php echo (wfPersistenceController::shared()->isActive('wf-diagnostics-wordpress-plugins') ? 'true' : 'false'); ?>\" tabindex=\"0\"><\/div>\n\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t<\/div>\n\t\t\t<div class=\"wf-block-content wf-clearfix wf-padding-no-left wf-padding-no-right\">\n\t\t\t\t<table class=\"wf-striped-table\"<?php echo !empty($inEmail) ? ' border=1' : '' ?>>\n\t\t\t\t\t<tbody>\n\t\t\t\t\t<?php foreach ($plugins as $plugin => $pluginData): ?>\n\t\t\t\t\t\t<?php\n\t\t\t\t\t\t$slug = $plugin;\n\t\t\t\t\t\tif (preg_match('\/^([^\\\/]+)\\\/\/', $plugin, $matches)) {\n\t\t\t\t\t\t\t$slug = $matches[1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (preg_match('\/^([^\\\/.]+)\\.php$\/', $plugin, $matches)) {\n\t\t\t\t\t\t\t$slug = $matches[1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t?>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<strong><?php echo esc_html($pluginData['Name']); ?> (<?php echo esc_html($slug); ?>)<\/strong>\n\t\t\t\t\t\t\t\t<?php if (!empty($pluginData['Version'])): ?>\n\t\t\t\t\t\t\t\t\t- <?php echo esc_html(sprintf(__('Version %s', 'wordfence'), $pluginData['Version'])); ?>\n\t\t\t\t\t\t\t\t<?php endif ?>\n\t\t\t\t\t\t\t<\/td>\n\t\t\t\t\t\t\t<?php if (array_key_exists(trailingslashit(WP_PLUGIN_DIR) . $plugin, $activeNetworkPlugins)): ?>\n\t\t\t\t\t\t\t\t<td class=\"wf-result-success\"><?php esc_html_e('Network Activated', 'wordfence'); ?><\/td>\n\t\t\t\t\t\t\t<?php elseif (array_key_exists($plugin, $activePlugins)): ?>\n\t\t\t\t\t\t\t\t<td class=\"wf-result-success\"><?php esc_html_e('Active', 'wordfence'); ?><\/td>\n\t\t\t\t\t\t\t<?php else: ?>\n\t\t\t\t\t\t\t\t<td class=\"wf-result-inactive\"><?php esc_html_e('Inactive', 'wordfence'); ?><\/td>\n\t\t\t\t\t\t\t<?php endif ?>\n\t\t\t\t\t\t<\/tr>\n\t\t\t\t\t<?php endforeach ?>\n\t\t\t\t\t<\/tbody>\n\t\t\t\t<\/table>\n\t\t\t<\/div>\n\t\t<\/div>\n\t\t<div class=\"wf-block<?php echo(wfPersistenceController::shared()->isActive('wf-diagnostics-mu-wordpress-plugins') ? ' wf-active' : '') ?>\" data-persistence-key=\"<?php echo esc_attr('wf-diagnostics-mu-wordpress-plugins') ?>\">\n\t\t\t<div class=\"wf-block-header\">\n\t\t\t\t<div class=\"wf-block-header-content\">\n\t\t\t\t\t<div class=\"wf-block-title\">\n\t\t\t\t\t\t<strong><?php esc_html_e('Must-Use WordPress Plugins', 'wordfence') ?><\/strong>\n\t\t\t\t\t\t<span class=\"wf-text-small\"><?php esc_html_e('WordPress \"mu-plugins\" that are always active, including those provided by hosts.', 'wordfence') ?><\/span>\n\t\t\t\t\t<\/div>\n\t\t\t\t\t<div class=\"wf-block-header-action\">\n\t\t\t\t\t\t<div class=\"wf-block-header-action-disclosure\" role=\"checkbox\" aria-checked=\"<?php echo (wfPersistenceController::shared()->isActive('wf-diagnostics-mu-wordpress-plugins') ? 'true' : 'false'); ?>\" tabindex=\"0\"><\/div>\n\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t<\/div>\n\t\t\t<div class=\"wf-block-content wf-clearfix wf-padding-no-left wf-padding-no-right\">\n\t\t\t\t<table class=\"wf-striped-table\"<?php echo !empty($inEmail) ? ' border=1' : '' ?>>\n\t\t\t\t\t<?php if (!empty($muPlugins)): ?>\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<?php foreach ($muPlugins as $plugin => $pluginData): ?>\n\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t$slug = $plugin;\n\t\t\t\t\t\t\tif (preg_match('\/^([^\\\/]+)\\\/\/', $plugin, $matches)) {\n\t\t\t\t\t\t\t\t$slug = $matches[1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (preg_match('\/^([^\\\/.]+)\\.php$\/', $plugin, $matches)) {\n\t\t\t\t\t\t\t\t$slug = $matches[1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t\t<strong><?php echo esc_html($pluginData['Name']) ?> (<?php echo esc_html($slug); ?>)<\/strong>\n\t\t\t\t\t\t\t\t\t<?php if (!empty($pluginData['Version'])): ?>\n\t\t\t\t\t\t\t\t\t\t- <?php echo esc_html(sprintf(\/* translators: Plugin version. *\/ __('Version %s', 'wordfence'), $pluginData['Version'])); ?>\n\t\t\t\t\t\t\t\t\t<?php endif ?>\n\t\t\t\t\t\t\t\t<\/td>\n\t\t\t\t\t\t\t\t<td class=\"wf-result-success\"><?php esc_html_e('Active', 'wordfence'); ?><\/td>\n\t\t\t\t\t\t\t<\/tr>\n\t\t\t\t\t\t<?php endforeach ?>\n\t\t\t\t\t\t<\/tbody>\n\t\t\t\t\t<?php else: ?>\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td><?php esc_html_e('No MU-Plugins', 'wordfence'); ?><\/td>\n\t\t\t\t\t\t<\/tr>\n\t\t\t\t\t\t<\/tbody>\n\n\t\t\t\t\t<?php endif ?>\n\t\t\t\t<\/table>\n\t\t\t<\/div>\n\t\t<\/div>\n\t\t<div class=\"wf-block<?php echo(wfPersistenceController::shared()->isActive('wf-diagnostics-dropin-wordpress-plugins') ? ' wf-active' : '') ?>\" data-persistence-key=\"<?php echo esc_attr('wf-diagnostics-dropin-wordpress-plugins') ?>\">\n\t\t\t<div class=\"wf-block-header\">\n\t\t\t\t<div class=\"wf-block-header-content\">\n\t\t\t\t\t<div class=\"wf-block-title\">\n\t\t\t\t\t\t<strong><?php esc_html_e('Drop-In WordPress Plugins', 'wordfence') ?><\/strong>\n\t\t\t\t\t\t<span class=\"wf-text-small\"><?php esc_html_e('WordPress \"drop-in\" plugins that are active.', 'wordfence') ?><\/span>\n\t\t\t\t\t<\/div>\n\t\t\t\t\t<div class=\"wf-block-header-action\">\n\t\t\t\t\t\t<div class=\"wf-block-header-action-disclosure\" role=\"checkbox\" aria-checked=\"<?php echo (wfPersistenceController::shared()->isActive('wf-diagnostics-dropin-wordpress-plugins') ? 'true' : 'false'); ?>\" tabindex=\"0\"><\/div>\n\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t<\/div>\n\t\t\t<div class=\"wf-block-content wf-clearfix wf-padding-no-left wf-padding-no-right\">\n\t\t\t\t<table class=\"wf-striped-table\"<?php echo !empty($inEmail) ? ' border=1' : '' ?>>\n\t\t\t\t\t<tbody>\n\t\t\t\t\t<?php\n\t\t\t\t\t\/\/Taken from plugin.php and modified to always show multisite drop-ins\n\t\t\t\t\t$dropins = array(\n\t\t\t\t\t\t'advanced-cache.php'\t => array( __( 'Advanced caching plugin', 'wordfence' ), 'WP_CACHE' ), \/\/ WP_CACHE\n\t\t\t\t\t\t'db.php'            \t => array( __( 'Custom database class', 'wordfence' ), true ), \/\/ auto on load\n\t\t\t\t\t\t'db-error.php'      \t => array( __( 'Custom database error message', 'wordfence' ), true ), \/\/ auto on error\n\t\t\t\t\t\t'install.php'       \t => array( __( 'Custom installation script', 'wordfence' ), true ), \/\/ auto on installation\n\t\t\t\t\t\t'maintenance.php'   \t => array( __( 'Custom maintenance message', 'wordfence' ), true ), \/\/ auto on maintenance\n\t\t\t\t\t\t'object-cache.php'  \t => array( __( 'External object cache', 'wordfence' ), true ), \/\/ auto on load\n\t\t\t\t\t\t'php-error.php'          => array( __( 'Custom PHP error message', 'wordfence' ), true ), \/\/ auto on error\n\t\t\t\t\t\t'fatal-error-handler.php'=> array( __( 'Custom PHP fatal error handler', 'wordfence' ), true ), \/\/ auto on error\n\t\t\t\t\t);\n\t\t\t\t\t$dropins['sunrise.php'       ] = array( __( 'Executed before Multisite is loaded', 'wordfence' ), is_multisite() && 'SUNRISE' ); \/\/ SUNRISE\n\t\t\t\t\t$dropins['blog-deleted.php'  ] = array( __( 'Custom site deleted message', 'wordfence' ), is_multisite() ); \/\/ auto on deleted blog\n\t\t\t\t\t$dropins['blog-inactive.php' ] = array( __( 'Custom site inactive message', 'wordfence' ), is_multisite() ); \/\/ auto on inactive blog\n\t\t\t\t\t$dropins['blog-suspended.php'] = array( __( 'Custom site suspended message', 'wordfence' ), is_multisite() ); \/\/ auto on archived or spammed blog\n\t\t\t\t\t?>\n\t\t\t\t\t<?php foreach ($dropins as $file => $data): ?>\n\t\t\t\t\t\t<?php\n\t\t\t\t\t\t$active = file_exists(WP_CONTENT_DIR . DIRECTORY_SEPARATOR . $file) && is_readable(WP_CONTENT_DIR . DIRECTORY_SEPARATOR . $file) && $data[1];\n\t\t\t\t\t\t?>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<strong><?php echo esc_html($data[0]) ?> (<?php echo esc_html($file); ?>)<\/strong>\n\t\t\t\t\t\t\t<\/td>\n\t\t\t\t\t\t\t<?php if ($active): ?>\n\t\t\t\t\t\t\t\t<td class=\"wf-result-success\"><?php esc_html_e('Active', 'wordfence'); ?><\/td>\n\t\t\t\t\t\t\t<?php else: ?>\n\t\t\t\t\t\t\t\t<td class=\"wf-result-inactive\"><?php esc_html_e('Inactive', 'wordfence'); ?><\/td>\n\t\t\t\t\t\t\t<?php endif; ?>\n\t\t\t\t\t\t<\/tr>\n\t\t\t\t\t<?php endforeach ?>\n\t\t\t\t\t<\/tbody>\n\t\t\t\t<\/table>\n\t\t\t<\/div>\n\t\t<\/div>\n\t\t<div class=\"wf-block<?php echo(wfPersistenceController::shared()->isActive('wf-diagnostics-wordpress-themes') ? ' wf-active' : '') ?>\" data-persistence-key=\"<?php echo esc_attr('wf-diagnostics-wordpress-themes') ?>\">\n\t\t\t<div class=\"wf-block-header\">\n\t\t\t\t<div class=\"wf-block-header-content\">\n\t\t\t\t\t<div class=\"wf-block-title\">\n\t\t\t\t\t\t<strong><?php esc_html_e('Themes', 'wordfence') ?><\/strong>\n\t\t\t\t\t\t<span class=\"wf-text-small\"><?php esc_html_e('Status of installed themes.', 'wordfence') ?><\/span>\n\t\t\t\t\t<\/div>\n\t\t\t\t\t<div class=\"wf-block-header-action\">\n\t\t\t\t\t\t<div class=\"wf-block-header-action-disclosure\" role=\"checkbox\" aria-checked=\"<?php echo (wfPersistenceController::shared()->isActive('wf-diagnostics-wordpress-themes') ? 'true' : 'false'); ?>\" tabindex=\"0\"><\/div>\n\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t<\/div>\n\t\t\t<div class=\"wf-block-content wf-clearfix wf-padding-no-left wf-padding-no-right\">\n\t\t\t\t<table class=\"wf-striped-table\"<?php echo !empty($inEmail) ? ' border=1' : '' ?>>\n\t\t\t\t\t<?php if (!empty($themes)): ?>\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<?php foreach ($themes as $theme => $themeData): ?>\n\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t$slug = $theme;\n\t\t\t\t\t\t\tif (preg_match('\/^([^\\\/]+)\\\/\/', $theme, $matches)) {\n\t\t\t\t\t\t\t\t$slug = $matches[1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (preg_match('\/^([^\\\/.]+)\\.php$\/', $theme, $matches)) {\n\t\t\t\t\t\t\t\t$slug = $matches[1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t\t<strong><?php echo esc_html($themeData['Name']) ?> (<?php echo esc_html($slug); ?>)<\/strong>\n\t\t\t\t\t\t\t\t\t<?php if (!empty($themeData['Version'])): ?>\n\t\t\t\t\t\t\t\t\t\t- <?php echo esc_html(sprintf(\/* translators: Theme version. *\/ __('Version %s', 'wordfence'), $themeData['Version'])); ?>\n\t\t\t\t\t\t\t\t\t<?php endif ?>\n\t\t\t\t\t\t\t\t<?php if ($currentTheme instanceof WP_Theme && $theme === $currentTheme->get_stylesheet()): ?>\n\t\t\t\t\t\t\t\t\t<td class=\"wf-result-success\"><?php esc_html_e('Active', 'wordfence'); ?><\/td>\n\t\t\t\t\t\t\t\t<?php else: ?>\n\t\t\t\t\t\t\t\t\t<td class=\"wf-result-inactive\"><?php esc_html_e('Inactive', 'wordfence'); ?><\/td>\n\t\t\t\t\t\t\t\t<?php endif ?>\n\t\t\t\t\t\t\t<\/tr>\n\t\t\t\t\t\t<?php endforeach ?>\n\t\t\t\t\t\t<\/tbody>\n\t\t\t\t\t<?php else: ?>\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td><?php esc_html_e('No Themes', 'wordfence'); ?><\/td>\n\t\t\t\t\t\t<\/tr>\n\t\t\t\t\t\t<\/tbody>\n\n\t\t\t\t\t<?php endif ?>\n\t\t\t\t<\/table>\n\t\t\t<\/div>\n\t\t<\/div>\n\t\t<div class=\"wf-block<?php echo(wfPersistenceController::shared()->isActive('wf-diagnostics-wordpress-cron-jobs') ? ' wf-active' : '') ?>\" data-persistence-key=\"<?php echo esc_attr('wf-diagnostics-wordpress-cron-jobs') ?>\">\n\t\t\t<div class=\"wf-block-header\">\n\t\t\t\t<div class=\"wf-block-header-content\">\n\t\t\t\t\t<div class=\"wf-block-title\">\n\t\t\t\t\t\t<strong><?php esc_html_e('Cron Jobs', 'wordfence') ?><\/strong>\n\t\t\t\t\t\t<span class=\"wf-text-small\"><?php esc_html_e('List of WordPress cron jobs scheduled by WordPress, plugins, or themes.', 'wordfence') ?><\/span>\n\t\t\t\t\t<\/div>\n\t\t\t\t\t<div class=\"wf-block-header-action\">\n\t\t\t\t\t\t<div class=\"wf-block-header-action-disclosure\" role=\"checkbox\" aria-checked=\"<?php echo (wfPersistenceController::shared()->isActive('wf-diagnostics-wordpress-cron-jobs') ? 'true' : 'false'); ?>\" tabindex=\"0\"><\/div>\n\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t<\/div>\n\t\t\t<div class=\"wf-block-content wf-clearfix wf-padding-no-left wf-padding-no-right\">\n\t\t\t\t<table class=\"wf-striped-table\"<?php echo !empty($inEmail) ? ' border=1' : '' ?>>\n\t\t\t\t\t<tbody>\n\t\t\t\t\t<?php\n\t\t\t\t\t$cron = _get_cron_array();\n\n\t\t\t\t\tforeach ($cron as $timestamp => $values) {\n\t\t\t\t\t\tif (is_array($values)) {\n\t\t\t\t\t\t\tforeach ($values as $cron_job => $v) {\n\t\t\t\t\t\t\t\tif (is_numeric($timestamp)) {\n\t\t\t\t\t\t\t\t\t$overdue = ((time() - 1800) > $timestamp);\n\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t<tr<?php echo $overdue ? ' class=\"wf-overdue-cron\"' : ''; ?>>\n\t\t\t\t\t\t\t\t\t\t<td><?php echo esc_html(date('r', $timestamp)) . ($overdue ? ' <strong>(' . esc_html__('Overdue', 'wordfence') . ')<\/strong>' : '') ?><\/td>\n\t\t\t\t\t\t\t\t\t\t<td><?php echo esc_html($cron_job) ?><\/td>\n\t\t\t\t\t\t\t\t\t<\/tr>\n\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t?>\n\t\t\t\t\t<\/tbody>\n\t\t\t\t<\/table>\n\t\t\t<\/div>\n\t\t<\/div>\n\n\t\t<?php\n\t\tglobal $wpdb;\n\t\t$wfdb = new wfDB();\n\t\t\/\/This must be done this way because MySQL with InnoDB tables does a full regeneration of all metadata if we don't. That takes a long time with a large table count.\n\t\t$tables = $wfdb->querySelect('SELECT TABLE_NAME FROM information_schema.TABLES WHERE TABLE_SCHEMA=DATABASE() ORDER BY TABLE_NAME ASC LIMIT 250');\n\t\t$total = $wfdb->querySingle('SELECT COUNT(*) FROM information_schema.TABLES WHERE TABLE_SCHEMA=DATABASE()');\n\t\tforeach ($tables as &$t) {\n\t\t\t$t = \"'\" . esc_sql($t['TABLE_NAME']) . \"'\";\n\t\t}\n\t\tunset($t);\n\t\t$q = $wfdb->querySelect(\"SHOW TABLE STATUS WHERE Name IN (\" . implode(',', $tables) . ')');\n\t\tif ($q):\n\t\t\t$databaseCols = count($q[0]);\n\t\t\t?>\n\t\t\t<div class=\"wf-block<?php echo(wfPersistenceController::shared()->isActive('wf-diagnostics-database-tables') ? ' wf-active' : '') ?>\" data-persistence-key=\"<?php echo esc_attr('wf-diagnostics-database-tables') ?>\">\n\t\t\t\t<div class=\"wf-block-header\">\n\t\t\t\t\t<div class=\"wf-block-header-content\">\n\t\t\t\t\t\t<div class=\"wf-block-title\">\n\t\t\t\t\t\t\t<strong><?php esc_html_e('Database Tables', 'wordfence') ?><\/strong>\n\t\t\t\t\t\t\t<span class=\"wf-text-small\"><?php esc_html_e('Database table names, sizes, timestamps, and other metadata.', 'wordfence') ?><\/span>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<div class=\"wf-block-header-action\">\n\t\t\t\t\t\t\t<div class=\"wf-block-header-action-disclosure\" role=\"checkbox\" aria-checked=\"<?php echo (wfPersistenceController::shared()->isActive('wf-diagnostics-database-tables') ? 'true' : 'false'); ?>\" tabindex=\"0\"><\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\t<div class=\"wf-block-content wf-clearfix wf-padding-no-left wf-padding-no-right\">\n\t\t\t\t\t<ul class=\"wf-block-list wf-padding-add-left-large wf-padding-add-right-large\">\n\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t<div style=\"width: 75%; min-width: 300px;\"><?php esc_html_e('Wordfence Table Check', 'wordfence'); ?><\/div>\n\t\t\t\t\t\t\t<div class=\"wf-right\">\n\t\t\t\t\t\t\t\t<?php if ($total > 250): ?>\n\t\t\t\t\t\t\t\t\t<div class=\"wf-result-info\"><?php esc_html_e('Unable to verify - table count too high', 'wordfence'); ?><\/div>\n\t\t\t\t\t\t\t\t<?php else:\n\t\t\t\t\t\t\t\t\t$hasAll = true;\n\t\t\t\t\t\t\t\t\t$schemaTables = wfSchema::tableList();\n\t\t\t\t\t\t\t\t\t$existingTables = wfUtils::array_column($q, 'Name');\n\t\t\t\t\t\t\t\t\tif (WFWAF_IS_WINDOWS) { $existingTables = wfUtils::array_strtolower($existingTables); } \/\/Windows MySQL installations are case-insensitive\n\t\t\t\t\t\t\t\t\t$missingTables = array();\n\t\t\t\t\t\t\t\t\tforeach ($schemaTables as $t) {\n\t\t\t\t\t\t\t\t\t\t$table = wfDB::networkTable($t);\n\t\t\t\t\t\t\t\t\t\tif (WFWAF_IS_WINDOWS) { $table = strtolower($table); }\n\t\t\t\t\t\t\t\t\t\tif (!in_array($table, $existingTables)) {\n\t\t\t\t\t\t\t\t\t\t\t$hasAll = false;\n\t\t\t\t\t\t\t\t\t\t\t$missingTables[] = $t;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tforeach (\n\t\t\t\t\t\t\t\t\t\tarray(\n\t\t\t\t\t\t\t\t\t\t\t\\WordfenceLS\\Controller_DB::TABLE_2FA_SECRETS,\n\t\t\t\t\t\t\t\t\t\t\t\\WordfenceLS\\Controller_DB::TABLE_SETTINGS,\n\t\t\t\t\t\t\t\t\t\t) as $t) {\n\t\t\t\t\t\t\t\t\t\t$table = \\WordfenceLS\\Controller_DB::network_table($t);\n\t\t\t\t\t\t\t\t\t\tif (!in_array($table, $existingTables)) {\n\t\t\t\t\t\t\t\t\t\t\t$hasAll = false;\n\t\t\t\t\t\t\t\t\t\t\t$missingTables[] = $t;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif ($hasAll): ?>\n\t\t\t\t\t\t\t\t\t<div class=\"wf-result-success\"><?php esc_html_e('All Tables Exist', 'wordfence'); ?><\/div>\n\t\t\t\t\t\t\t\t\t<?php else: ?>\n\t\t\t\t\t\t\t\t\t<div class=\"wf-result-error\"><?php echo esc_html(sprintf(\n\t\t\t\t\t\t\t\t\t\t\t\/* translators: 1. WordPress table prefix. 2. Wordfence table case. 3. List of database tables. *\/\n\t\t\t\t\t\t\t\t\t\t\t__('Tables missing (prefix %1$s, %2$s): %3$s', 'wordfence'), wfDB::networkPrefix(), wfSchema::usingLowercase() ? __('lowercase', 'wordfence') : __('regular case', 'wordfence'), implode(', ', $missingTables))); ?><\/div>\n\t\t\t\t\t\t\t\t\t<?php endif; ?>\n\t\t\t\t\t\t\t\t<?php endif; ?>\n\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t<li style=\"border-bottom: 1px solid #e2e2e2;\">\n\t\t\t\t\t\t\t<div style=\"width: 75%; min-width: 300px;\"><?php esc_html_e('Number of Database Tables', 'wordfence'); ?><\/div>\n\t\t\t\t\t\t\t<div class=\"wf-right\">\n\t\t\t\t\t\t\t\t<div class=\"wf-result-info\"><?php echo esc_html( $total ); ?><\/div>\n\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/li>\n\t\t\t\t\t<\/ul>\n\t\t\t\t\t<div class=\"wf-add-top-large\" style=\"max-width: 100%; overflow: auto; padding: 1px;\">\n\t\t\t\t\t\t<table class=\"wf-striped-table\"<?php echo !empty($inEmail) ? ' border=1' : '' ?>>\n\t\t\t\t\t\t\t<tbody class=\"thead thead-subhead\" style=\"font-size: 85%\">\n\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t$val = wfUtils::array_first($q);\n\t\t\t\t\t\t\t$actualKeyOrder = array_keys($val);\n\t\t\t\t\t\t\t$preferredKeyOrder = array('Name', 'Comment', 'Engine', 'Rows', 'Avg_row_length', 'Data_length', 'Index_length', 'Auto_increment', 'Create_time', 'Row_format', 'Collation', 'Version', 'Max_data_length', 'Data_free', 'Update_time', 'Check_time', 'Checksum', 'Create_options');\n\t\t\t\t\t\t\t$leftoverKeys = array();\n\t\t\t\t\t\t\t$displayKeyOrder = array();\n\t\t\t\t\t\t\tforeach ($preferredKeyOrder as $k) {\n\t\t\t\t\t\t\t\tif (in_array($k, $actualKeyOrder)) {\n\t\t\t\t\t\t\t\t\t$displayKeyOrder[] = $k;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t$diff = array_diff($actualKeyOrder, $preferredKeyOrder);\n\t\t\t\t\t\t\t$displayKeyOrder = array_merge($displayKeyOrder, $diff);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<?php foreach ($displayKeyOrder as $tkey): ?>\n\t\t\t\t\t\t\t\t\t<th><?php echo esc_html($tkey) ?><\/th>\n\t\t\t\t\t\t\t\t<?php endforeach; ?>\n\t\t\t\t\t\t\t<\/tr>\n\t\t\t\t\t\t\t<\/tbody>\n\t\t\t\t\t\t\t<tbody style=\"font-size: 85%\">\n\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t$count = 0;\n\t\t\t\t\t\t\tforeach ($q as $val) {\n\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<?php foreach ($displayKeyOrder as $tkey): ?>\n\t\t\t\t\t\t\t\t\t<td><?php if (isset($val[$tkey])) { echo esc_html($val[$tkey]); } ?><\/td>\n\t\t\t\t\t\t\t\t<?php endforeach; ?>\n\t\t\t\t\t\t\t\t<\/tr>\n\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t$count++;\n\t\t\t\t\t\t\t\tif ($count >= 250 && $total > $count) {\n\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t\t\t<td colspan=\"<?php echo $databaseCols; ?>\"><?php echo esc_html(sprintf(\/* translators: Row\/record count. *\/ __('and %d more', 'wordfence'), $total - $count)); ?><\/td>\n\t\t\t\t\t\t\t\t\t<\/tr>\n\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t<\/tbody>\n\n\t\t\t\t\t\t<\/table>\n\t\t\t\t\t<\/div>\n\n\t\t\t\t<\/div>\n\t\t\t<\/div>\n\t\t<?php endif ?>\n\t\t<div class=\"wf-block<?php echo(wfPersistenceController::shared()->isActive('wf-diagnostics-log-files') ? ' wf-active' : '') ?>\" data-persistence-key=\"<?php echo esc_attr('wf-diagnostics-log-files') ?>\">\n\t\t\t<div class=\"wf-block-header\">\n\t\t\t\t<div class=\"wf-block-header-content\">\n\t\t\t\t\t<div class=\"wf-block-title\">\n\t\t\t\t\t\t<strong><?php esc_html_e('Log Files', 'wordfence') ?><\/strong>\n\t\t\t\t\t\t<span class=\"wf-text-small\"><?php esc_html_e('PHP error logs generated by your site, if enabled by your host.', 'wordfence') ?><\/span>\n\t\t\t\t\t<\/div>\n\t\t\t\t\t<div class=\"wf-block-header-action\">\n\t\t\t\t\t\t<div class=\"wf-block-header-action-disclosure\" role=\"checkbox\" aria-checked=\"<?php echo (wfPersistenceController::shared()->isActive('wf-diagnostics-log-files') ? 'true' : 'false'); ?>\" tabindex=\"0\"><\/div>\n\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t<\/div>\n\t\t\t<div class=\"wf-block-content wf-clearfix wf-padding-no-left wf-padding-no-right\">\n\t\t\t\t<div style=\"max-width: 100%; overflow: auto; padding: 1px;\">\n\t\t\t\t\t<table class=\"wf-striped-table\"<?php echo !empty($inEmail) ? ' border=1' : '' ?>>\n\t\t\t\t\t\t<tbody class=\"thead thead-subhead\" style=\"font-size: 85%\">\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<th><?php esc_html_e('File', 'wordfence'); ?><\/th>\n\t\t\t\t\t\t\t<th><?php esc_html_e('Download', 'wordfence'); ?><\/th>\n\t\t\t\t\t\t<\/tr>\n\t\t\t\t\t\t<\/tbody>\n\t\t\t\t\t\t<tbody style=\"font-size: 85%\">\n\t\t\t\t\t\t<?php\n\t\t\t\t\t\t$errorLogs = wfErrorLogHandler::getErrorLogs();\n\t\t\t\t\t\tif (count($errorLogs) < 1): ?>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td colspan=\"2\"><em><?php esc_html_e('No log files found.', 'wordfence'); ?><\/em><\/td>\n\t\t\t\t\t\t\t<\/tr>\n\t\t\t\t\t\t<?php else:\n\t\t\t\t\t\t\tforeach ($errorLogs as $log => $readable): ?>\n\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t$metadata = array();\n\t\t\t\t\t\t\t\tif (is_callable('filesize')) {\n\t\t\t\t\t\t\t\t\t$rawSize = @filesize($log);\n\t\t\t\t\t\t\t\t\tif ($rawSize !== false) {\n\t\t\t\t\t\t\t\t\t\t$metadata[] = wfUtils::formatBytes(filesize($log));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (is_callable('lstat')) {\n\t\t\t\t\t\t\t\t\t$rawStat = @lstat($log);\n\t\t\t\t\t\t\t\t\tif (is_array($rawStat) && isset($rawStat['mtime'])) {\n\t\t\t\t\t\t\t\t\t\t$ts = $rawStat['mtime'];\n\t\t\t\t\t\t\t\t\t\t$utc = new DateTimeZone('UTC');\n\t\t\t\t\t\t\t\t\t\t$dtStr = gmdate(\"c\", (int) $ts); \/\/Have to do it this way because of PHP 5.2\n\t\t\t\t\t\t\t\t\t\t$dt = new DateTime($dtStr, $utc);\n\t\t\t\t\t\t\t\t\t\t$metadata[] = $dt->format('M j, Y G:i:s') . ' ' . __('UTC', 'wordfence');\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t$shortLog = $log;\n\t\t\t\t\t\t\t\tif (strpos($shortLog, ABSPATH) === 0) {\n\t\t\t\t\t\t\t\t\t$shortLog = '~\/' . substr($shortLog, strlen(ABSPATH));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t\t<td style=\"width: 100%\"><?php echo esc_html($shortLog); if (!empty($metadata)) { echo ' (' . esc_html(implode(', ', $metadata)) . ')'; } ?><\/td>\n\t\t\t\t\t\t\t\t\t<td style=\"white-space: nowrap; text-align: right;\"><?php echo($readable ? '<a href=\"#\" data-logfile=\"' . esc_attr($log) . '\" class=\"downloadLogFile\" target=\"_blank\" rel=\"noopener noreferrer\" role=\"button\">' . esc_html__('Download', 'wordfence') . '<span class=\"screen-reader-text\"> (' . esc_html__('opens in new tab', 'wordfence') . ')<\/span><\/a>' : '<em>' . esc_html__('Requires downloading from the server directly', 'wordfence') . '<\/em>'); ?><\/td>\n\t\t\t\t\t\t\t\t<\/tr>\n\t\t\t\t\t\t\t<?php endforeach;\n\t\t\t\t\t\tendif; ?>\n\t\t\t\t\t\t<\/tbody>\n\n\t\t\t\t\t<\/table>\n\t\t\t\t<\/div>\n\t\t\t<\/div>\n\t\t<\/div>\n\t<\/div>\n\t\n\t<?php\n\tif (!empty($inEmail)) {\n\t\techo '<h1>' . esc_html__('Scan Issues', 'wordfence') . \"<\/h1>\\n\";\n\t\t$issues = wfIssues::shared()->getIssues(0, 50, 0, 50);\n\t\t$issueCounts = array_merge(array('new' => 0, 'ignoreP' => 0, 'ignoreC' => 0), wfIssues::shared()->getIssueCounts());\n\t\t$issueTypes = wfIssues::validIssueTypes();\n\t\t\n\t\techo '<h2>' . esc_html(sprintf(\/* translators: Number of scan issues. *\/ __('New Issues (%d total)', 'wordfence'), $issueCounts['new'])) . \"<\/h2>\\n\";\n\t\tif (isset($issues['new']) && count($issues['new'])) {\n\t\t\tforeach ($issues['new'] as $i) {\n\t\t\t\tif (!in_array($i['type'], $issueTypes)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t$viewContent = '';\n\t\t\t\ttry {\n\t\t\t\t\t$viewContent = wfView::create('scanner\/issue-' . $i['type'], array('textOutput' => $i))->render();\n\t\t\t\t}\n\t\t\t\tcatch (wfViewNotFoundException $e) {\n\t\t\t\t\t\/\/Ignore -- should never happen since we validate the type\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!empty($viewContent)) {\n\t\t\t\t\techo nl2br($viewContent) . \"<br><br>\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\techo '<h1>' . esc_html__('No New Issues', 'wordfence') . \"<\/h1>\\n\";\n\t\t}\n\t}\n\t?>\n\t\n\t<?php if (!empty($inEmail)): ?>\n\t<div class=\"wf-diagnostics-wrapper\">\n\t\t<div class=\"wf-block<?php echo(wfPersistenceController::shared()->isActive('wf-diagnostics-wordfence-settings') ? ' wf-active' : '') ?>\" data-persistence-key=\"<?php echo esc_attr('wf-diagnostics-wordfence-settings') ?>\">\n\t\t\t<div class=\"wf-block-header\">\n\t\t\t\t<div class=\"wf-block-header-content\">\n\t\t\t\t\t<div class=\"wf-block-title\">\n\t\t\t\t\t\t<strong><?php esc_html_e('Wordfence Settings', 'wordfence') ?><\/strong>\n\t\t\t\t\t\t<span class=\"wf-text-small\"><?php esc_html_e('Diagnostic Wordfence settings\/constants.', 'wordfence') ?><\/span>\n\t\t\t\t\t<\/div>\n\t\t\t\t\t<div class=\"wf-block-header-action\">\n\t\t\t\t\t\t<div class=\"wf-block-header-action-disclosure\" role=\"checkbox\" aria-checked=\"<?php echo (wfPersistenceController::shared()->isActive('wf-diagnostics-wordfence-settings') ? 'true' : 'false'); ?>\" tabindex=\"0\"><\/div>\n\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t<\/div>\n\t\t\t<div class=\"wf-block-content wf-clearfix wf-padding-no-left wf-padding-no-right\">\n\t\t\t\t<table class=\"wf-striped-table\"<?php echo !empty($inEmail) ? ' border=1' : '' ?>>\n\t\t\t\t\t<tbody>\n\t\t\t\t\t<?php\n\t\t\t\t\tforeach (wfDiagnostic::getWordfenceValues() as $settingName => $settingData):\n\t\t\t\t\t\tif (isset($settingData['subheader'])) {\n\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td colspan=\"2\"><strong><?php echo esc_html($settingData['subheader']) ?><\/strong><\/td>\n\t\t\t\t\t\t\t<\/tr>\n\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t$escapedDescription = strip_tags($settingData['description']);\n\t\t\t\t\t\t$escapedValue = __('(not set)', 'wordfence');\n\t\t\t\t\t\tif (isset($settingData['value'])) {\n\t\t\t\t\t\t\t$escapedValue = nl2br(strip_tags($settingData['value']));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t?>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td><?php echo $escapedDescription ?><\/td>\n\t\t\t\t\t\t\t<td><?php echo $escapedValue ?><\/td>\n\t\t\t\t\t\t<\/tr>\n\t\t\t\t\t<?php endforeach ?>\n\t\t\t\t\t<\/tbody>\n\t\t\t\t<\/table>\n\t\t\t<\/div>\n\t\t<\/div>\n\t<\/div>\n\t<?php endif ?>\n\t\n\t<?php if (!empty($inEmail)): ?>\n\t\t<div class=\"wf-diagnostics-wrapper\">\n\t\t\t<div class=\"wf-block<?php echo(wfPersistenceController::shared()->isActive('wf-diagnostics-wordfence-central') ? ' wf-active' : '') ?>\" data-persistence-key=\"<?php echo esc_attr('wf-diagnostics-wordfence-central') ?>\">\n\t\t\t\t<div class=\"wf-block-header\">\n\t\t\t\t\t<div class=\"wf-block-header-content\">\n\t\t\t\t\t\t<div class=\"wf-block-title\">\n\t\t\t\t\t\t\t<strong><?php esc_html_e('Wordfence Central', 'wordfence') ?><\/strong>\n\t\t\t\t\t\t\t<span class=\"wf-text-small\"><?php esc_html_e('Diagnostic connection information for Wordfence Central.', 'wordfence') ?><\/span>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<div class=\"wf-block-header-action\">\n\t\t\t\t\t\t\t<div class=\"wf-block-header-action-disclosure\" role=\"checkbox\" aria-checked=\"<?php echo (wfPersistenceController::shared()->isActive('wf-diagnostics-wordfence-central') ? 'true' : 'false'); ?>\" tabindex=\"0\"><\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\t<div class=\"wf-block-content wf-clearfix wf-padding-no-left wf-padding-no-right\">\n\t\t\t\t\t<table class=\"wf-striped-table\"<?php echo !empty($inEmail) ? ' border=1' : '' ?>>\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<?php\n\t\t\t\t\t\tforeach (wfDiagnostic::getWordfenceCentralValues() as $settingName => $settingData):\n\t\t\t\t\t\t\tif (isset($settingData['subheader'])) {\n\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t\t<td colspan=\"2\"><strong><?php echo esc_html($settingData['subheader']) ?><\/strong><\/td>\n\t\t\t\t\t\t\t\t<\/tr>\n\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t$escapedDescription = strip_tags($settingData['description']);\n\t\t\t\t\t\t\t$escapedValue = __('(not set)', 'wordfence');\n\t\t\t\t\t\t\tif (isset($settingData['value'])) {\n\t\t\t\t\t\t\t\t$escapedValue = nl2br(strip_tags($settingData['value']));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td><?php echo $escapedDescription ?><\/td>\n\t\t\t\t\t\t\t\t<td><?php echo $escapedValue ?><\/td>\n\t\t\t\t\t\t\t<\/tr>\n\t\t\t\t\t\t<?php endforeach ?>\n\t\t\t\t\t\t<\/tbody>\n\t\t\t\t\t<\/table>\n\t\t\t\t<\/div>\n\t\t\t<\/div>\n\t\t<\/div>\n\t<?php endif ?>\n\n\t<?php if (!empty($inEmail)): ?>\n\t\t<?php if (wfUtils::funcEnabled('phpinfo')) { phpinfo(); } else { echo '<strong>' . esc_html__('Unable to output phpinfo content because it is disabled', 'wordfence') . \"<\/strong>\\n\"; } ?>\n\t<?php endif ?>\n\n\t<?php if (!empty($emailForm)): ?>\n\t\t<div class=\"wf-diagnostics-wrapper\">\n\t\t\t<div id=\"wf-diagnostics-other-tests\" class=\"wf-block<?php echo(wfPersistenceController::shared()->isActive('wf-diagnostics-other-tests') ? ' wf-active' : '') ?>\" data-persistence-key=\"<?php echo esc_attr('wf-diagnostics-other-tests') ?>\">\n\t\t\t\t<div class=\"wf-block-header\">\n\t\t\t\t\t<div class=\"wf-block-header-content\">\n\t\t\t\t\t\t<div class=\"wf-block-title\">\n\t\t\t\t\t\t\t<strong><?php esc_html_e('Other Tests', 'wordfence') ?><\/strong>\n\t\t\t\t\t\t\t<span class=\"wf-text-small\"><?php esc_html_e('System configuration, memory test, send test email from this server.', 'wordfence') ?><\/span>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<div class=\"wf-block-header-action\">\n\t\t\t\t\t\t\t<div class=\"wf-block-header-action-disclosure\" role=\"checkbox\" aria-checked=\"<?php echo (wfPersistenceController::shared()->isActive('wf-diagnostics-other-tests') ? 'true' : 'false'); ?>\" tabindex=\"0\"><\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\t<div class=\"wf-block-content wf-clearfix\">\n\t\t\t\t\t<ul class=\"wf-block-list\">\n\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t\t<a href=\"<?php echo wfUtils::siteURLRelative(); ?>?_wfsf=sysinfo&nonce=<?php echo wp_create_nonce('wp-ajax'); ?>\" target=\"_blank\" rel=\"noopener noreferrer\"><?php esc_html_e('Click to view your system\\'s configuration in a new window', 'wordfence'); ?><span class=\"screen-reader-text\"> (<?php esc_html_e('opens in new tab', 'wordfence') ?>)<\/span><\/a>\n\t\t\t\t\t\t\t\t<a href=\"<?php echo wfSupportController::esc_supportURL(wfSupportController::ITEM_DIAGNOSTICS_SYSTEM_CONFIGURATION); ?>\" target=\"_blank\" rel=\"noopener noreferrer\" class=\"wfhelp wf-inline-help\"><span class=\"screen-reader-text\"> (<?php esc_html_e('opens in new tab', 'wordfence') ?>)<\/span><\/a>\n\t\t\t\t\t\t\t<\/span>\n\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t\t<a href=\"<?php echo wfUtils::siteURLRelative(); ?>?_wfsf=testmem&nonce=<?php echo wp_create_nonce('wp-ajax'); ?>\" target=\"_blank\" rel=\"noopener noreferrer\"><?php esc_html_e('Test your WordPress host\\'s available memory', 'wordfence'); ?><span class=\"screen-reader-text\"> (<?php esc_html_e('opens in new tab', 'wordfence') ?>)<\/span><\/a>\n\t\t\t\t\t\t\t<a href=\"<?php echo wfSupportController::esc_supportURL(wfSupportController::ITEM_DIAGNOSTICS_TEST_MEMORY); ?>\" target=\"_blank\" rel=\"noopener noreferrer\" class=\"wfhelp wf-inline-help\"><span class=\"screen-reader-text\"> (<?php esc_html_e('opens in new tab', 'wordfence') ?>)<\/span><\/a>\n\t\t\t\t\t\t\t<\/span>\n\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t\t<?php esc_html_e('Send a test email from this WordPress server to an email address:', 'wordfence'); ?> <a href=\"<?php echo wfSupportController::esc_supportURL(wfSupportController::ITEM_DIAGNOSTICS_TEST_EMAIL); ?>\" target=\"_blank\" rel=\"noopener noreferrer\" class=\"wfhelp wf-inline-help\"><span class=\"screen-reader-text\"> (<?php esc_html_e('opens in new tab', 'wordfence') ?>)<\/span><\/a>\n\t\t\t\t\t\t\t\t<input type=\"text\" id=\"testEmailDest\" value=\"\" size=\"20\" maxlength=\"255\" class=\"wfConfigElem\"\/>\n\t\t\t\t\t\t\t\t<input class=\"wf-btn wf-btn-default wf-btn-sm\" type=\"button\" value=\"<?php esc_attr_e('Send Test Email', 'wordfence'); ?>\" onclick=\"WFAD.sendTestEmail(jQuery('#testEmailDest').val());\"\/>\n\t\t\t\t\t\t\t<\/span>\n\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t\t<?php esc_html_e('Send a test activity report email:', 'wordfence'); ?> <a href=\"<?php echo wfSupportController::esc_supportURL(wfSupportController::ITEM_DIAGNOSTICS_TEST_ACTIVITY_REPORT); ?>\" target=\"_blank\" rel=\"noopener noreferrer\" class=\"wfhelp wf-inline-help\"><span class=\"screen-reader-text\"> (<?php esc_html_e('opens in new tab', 'wordfence') ?>)<\/span><\/a>\n\t\t\t\t\t\t\t\t<input type=\"email\" id=\"email_summary_email_address_debug\" value=\"\" size=\"20\" maxlength=\"255\" class=\"wfConfigElem\"\/>\n\t\t\t\t\t\t\t\t<input class=\"wf-btn wf-btn-default wf-btn-sm\" type=\"button\" value=\"<?php esc_attr_e('Send Test Activity Report', 'wordfence'); ?>\" onclick=\"WFAD.sendTestActivityReport(jQuery('#email_summary_email_address_debug').val());\"\/>\n\t\t\t\t\t\t\t<\/span>\n\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t\t<?php esc_html_e('Clear all Wordfence Central connection data', 'wordfence'); ?> <a href=\"<?php echo wfSupportController::esc_supportURL(wfSupportController::ITEM_DIAGNOSTICS_REMOVE_CENTRAL_DATA); ?>\" target=\"_blank\" rel=\"noopener noreferrer\" class=\"wfhelp wf-inline-help\"><span class=\"screen-reader-text\"> (<?php esc_html_e('opens in new tab', 'wordfence') ?>)<\/span><\/a>\n\t\t\t\t\t\t\t\t<input class=\"wf-btn wf-btn-default wf-btn-sm\" type=\"button\" value=\"<?php esc_attr_e('Clear All Connection Data', 'wordfence'); ?>\" onclick=\"WFAD.ajax('wordfence_wfcentral_disconnect', { force: true }, function() { WFAD.colorboxModal((self.isSmallScreen ? '300px' : '400px'), <?php echo esc_attr(json_encode(__('Successfully removed data', 'wordfence'))) ?>, <?php echo esc_attr(json_encode(__('All associated Wordfence Central connection data has been cleared.', 'wordfence'))) ?>); });\"\/>\n\t\t\t\t\t\t\t\t<input class=\"wf-btn wf-btn-default wf-btn-sm\" type=\"button\" value=\"<?php esc_attr_e('Clear Local Connection Data', 'wordfence'); ?>\" onclick=\"WFAD.ajax('wordfence_wfcentral_disconnect', { local: true }, function() { WFAD.colorboxModal((self.isSmallScreen ? '300px' : '400px'), <?php echo esc_attr(json_encode(__('Successfully removed data', 'wordfence'))) ?>, <?php echo esc_attr(json_encode(__('All associated Wordfence Central connection data has been removed from the local database.', 'wordfence'))) ?>); });\"\/>\n\t\t\t\t\t\t\t<\/span>\n\t\t\t\t\t\t<\/li>\n\t\t\t\t\t<\/ul>\n\n\t\t\t\t<\/div>\n\t\t\t<\/div>\n\n\t\t\t<div class=\"wf-block<?php echo(wfPersistenceController::shared()->isActive('wf-diagnostics-debugging-options') ? ' wf-active' : '') ?>\" data-persistence-key=\"<?php echo esc_attr('wf-diagnostics-debugging-options') ?>\">\n\t\t\t\t<div class=\"wf-block-header\">\n\t\t\t\t\t<div class=\"wf-block-header-content\">\n\t\t\t\t\t\t<div class=\"wf-block-title\">\n\t\t\t\t\t\t\t<strong><?php esc_html_e('Debugging Options', 'wordfence') ?><\/strong>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<div class=\"wf-block-header-action\">\n\t\t\t\t\t\t\t<div class=\"wf-block-header-action-disclosure\" role=\"checkbox\" aria-checked=\"<?php echo (wfPersistenceController::shared()->isActive('wf-diagnostics-debugging-options') ? 'true' : 'false'); ?>\" tabindex=\"0\"><\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\t<div class=\"wf-block-content wf-clearfix\">\n\t\t\t\t\t<form action=\"#\" id=\"wfDebuggingConfigForm\">\n\t\t\t\t\t\t<ul class=\"wf-block-list\">\n\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\techo wfView::create('options\/option-toggled', array(\n\t\t\t\t\t\t\t\t\t'optionName'    => 'debugOn',\n\t\t\t\t\t\t\t\t\t'enabledValue'  => 1,\n\t\t\t\t\t\t\t\t\t'disabledValue' => 0,\n\t\t\t\t\t\t\t\t\t'value'         => $w->get('debugOn') ? 1 : 0,\n\t\t\t\t\t\t\t\t\t'title'         => __('Enable debugging mode (increases database load)', 'wordfence'),\n\t\t\t\t\t\t\t\t\t'helpLink'      => wfSupportController::supportURL(wfSupportController::ITEM_DIAGNOSTICS_OPTION_DEBUGGING_MODE),\n\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\techo wfView::create('options\/option-toggled', array(\n\t\t\t\t\t\t\t\t\t'optionName'    => 'startScansRemotely',\n\t\t\t\t\t\t\t\t\t'enabledValue'  => 1,\n\t\t\t\t\t\t\t\t\t'disabledValue' => 0,\n\t\t\t\t\t\t\t\t\t'value'         => $w->get('startScansRemotely') ? 1 : 0,\n\t\t\t\t\t\t\t\t\t'title'         => __('Start all scans remotely (Try this if your scans aren\\'t starting and your site is publicly accessible)', 'wordfence'),\n\t\t\t\t\t\t\t\t\t'helpLink'      => wfSupportController::supportURL(wfSupportController::ITEM_DIAGNOSTICS_OPTION_REMOTE_SCANS),\n\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\techo wfView::create('options\/option-toggled', array(\n\t\t\t\t\t\t\t\t\t'optionName'    => 'ssl_verify',\n\t\t\t\t\t\t\t\t\t'enabledValue'  => 1,\n\t\t\t\t\t\t\t\t\t'disabledValue' => 0,\n\t\t\t\t\t\t\t\t\t'value'         => $w->get('ssl_verify') ? 1 : 0,\n\t\t\t\t\t\t\t\t\t'title'         => __('Enable SSL Verification (Disable this if you are consistently unable to connect to the Wordfence servers.)', 'wordfence'),\n\t\t\t\t\t\t\t\t\t'helpLink'      => wfSupportController::supportURL(wfSupportController::ITEM_DIAGNOSTICS_OPTION_SSL_VERIFICATION),\n\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\techo wfView::create('options\/option-toggled', array(\n\t\t\t\t\t\t\t\t\t'optionName'    => 'avoid_php_input',\n\t\t\t\t\t\t\t\t\t'enabledValue'  => 1,\n\t\t\t\t\t\t\t\t\t'disabledValue' => 0,\n\t\t\t\t\t\t\t\t\t'value'         => wfWAF::getInstance()->getStorageEngine()->getConfig('avoid_php_input', false) ? 1 : 0,\n\t\t\t\t\t\t\t\t\t'title'         => __('Disable reading of php:\/\/input', 'wordfence'),\n\t\t\t\t\t\t\t\t\t'helpLink'      => wfSupportController::supportURL(wfSupportController::ITEM_DIAGNOSTICS_OPTION_DISABLE_PHP_INPUT),\n\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\techo wfView::create('options\/option-toggled', array(\n\t\t\t\t\t\t\t\t\t'optionName'    => 'wordfenceI18n',\n\t\t\t\t\t\t\t\t\t'enabledValue'  => 1,\n\t\t\t\t\t\t\t\t\t'disabledValue' => 0,\n\t\t\t\t\t\t\t\t\t'value'         => $w->get('wordfenceI18n') ? 1 : 0,\n\t\t\t\t\t\t\t\t\t'title'         => 'Enable Wordfence translations',\n\t\t\t\t\t\t\t\t\t'helpLink'      => wfSupportController::supportURL(wfSupportController::ITEM_DIAGNOSTICS_OPTION_WORDFENCE_TRANSLATIONS),\n\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t<p>\n\t\t\t\t\t\t\t\t\t<a id=\"wf-restore-defaults\" class=\"wf-btn wf-btn-default wf-btn-callout-subtle\" href=\"#\" data-restore-defaults-section=\"<?php echo esc_attr(wfConfig::OPTIONS_TYPE_DIAGNOSTICS); ?>\" role=\"button\"><?php esc_html_e('Restore Defaults', 'wordfence'); ?><\/a>\n\t\t\t\t\t\t\t\t\t<a id=\"wf-cancel-changes\" class=\"wf-btn wf-btn-default wf-btn-callout-subtle wf-disabled\" href=\"#\" role=\"button\"><?php esc_html_e('Cancel Changes', 'wordfence'); ?><\/a>\n\t\t\t\t\t\t\t\t\t<a id=\"wf-save-changes\" class=\"wf-btn wf-btn-primary wf-btn-callout-subtle wf-disabled\" href=\"#\" role=\"button\"><?php esc_html_e('Save Changes', 'wordfence'); ?><\/a>\n\t\t\t\t\t\t\t\t<\/p>\n\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t<\/ul>\n\t\t\t\t\t<\/form>\n\t\t\t\t<\/div>\n\t\t\t<\/div>\n\t\t<\/div>\n\n\t<?php endif ?>\n<\/div>\n<?php if (!$sendingDiagnosticEmail): ?>\n<div class=\"wf-scrollTop\">\n\t<a href=\"javascript:void(0);\"><i class=\"wf-ionicons wf-ion-chevron-up\"><\/i><\/a>\n<\/div>\n<script type=\"text\/x-jquery-template\" id=\"wfTmpl_restoreDefaultsPrompt\">\n\t<?php\n\techo wfView::create('common\/modal-prompt', array(\n\t\t'title' => __('Confirm Restore Defaults', 'wordfence'),\n\t\t'message' => __('Are you sure you want to restore the default Diagnostics settings? This will undo any custom changes you have made to the options on this page.', 'wordfence'),\n\t\t'primaryButton' => array('id' => 'wf-restore-defaults-prompt-cancel', 'label' => __('Cancel', 'wordfence'), 'link' => '#'),\n\t\t'secondaryButtons' => array(array('id' => 'wf-restore-defaults-prompt-confirm', 'labelHTML' => wp_kses(\/* translators: word order may be reversed as long as HTML remains around \"Defaults\" *\/ __('Restore<span class=\"wf-hidden-xs\"> Defaults<\/span>', 'wordfence'), array('span'=>array('class'=>array()))), 'link' => '#')),\n\t))->render();\n\t?>\n<\/script>\n<?php endif ?>\n"},{"base":"plugins","rel":"wordfence\/lib\/wfVersionCheckController.php","ext":"php","size":19729,"mtime":1757312769,"type":"text","content":"<?php\n\nclass wfVersionCheckController {\n\tconst VERSION_COMPATIBLE = 'compatible';\n\tconst VERSION_DEPRECATED = 'deprecated';\n\tconst VERSION_UNSUPPORTED = 'unsupported';\n\t\n\tconst OPENSSL_DEV = 0;\n\t\/\/Betas are 1-14\n\tconst OPENSSL_RELEASE = 15;\n\t\n\tpublic static function shared() {\n\t\tstatic $_shared = false;\n\t\tif ($_shared === false) {\n\t\t\t$_shared = new wfVersionCheckController();\n\t\t}\n\t\treturn $_shared;\n\t}\n\t\n\t\/**\n\t * Returns whether or not all version checks are successful. If any check returns a value other than VERSION_COMPATIBLE, this returns false.\n\t * \n\t * @return bool\n\t *\/\n\tpublic function checkVersions() {\n\t\treturn ($this->checkPHPVersion() == self::VERSION_COMPATIBLE) && ($this->checkOpenSSLVersion() == self::VERSION_COMPATIBLE) && ($this->checkWordPressVersion() == self::VERSION_COMPATIBLE);\n\t}\n\t\n\t\/**\n\t * Does the same thing as checkVersions but also triggers display of the corresponding warnings.\n\t * \n\t * @return bool\n\t *\/\n\tpublic function checkVersionsAndWarn() {\n\t\trequire(dirname(__FILE__) . '\/wfVersionSupport.php');\n\t\t\/**\n\t\t * @var string $wfPHPDeprecatingVersion\n\t\t * @var string $wfPHPMinimumVersion\n\t\t * @var string $wfOpenSSLDeprecatingVersion\n\t\t * @var string $wfOpenSSLMinimumVersion\n\t\t * @var string $wfWordPressDeprecatingVersion\n\t\t * @var string $wfWordPressMinimumVersion\n\t\t *\/\n\t\t\n\t\t\/\/PHP\n\t\t$php = $this->checkPHPVersion();\n\t\tif ($php == self::VERSION_DEPRECATED) {\n\t\t\t$this->_alertEmail(\n\t\t\t\t'phpVersionCheckDeprecationEmail_' . $wfPHPDeprecatingVersion,\n\t\t\t\t__('PHP version too old', 'wordfence'),\n\t\t\t\tsprintf(\n\t\t\t\t\t\/* translators: 1. PHP version. 2. PHP version. *\/\n\t\t\t\t\t__('Your site is using a PHP version (%1$s) that will no longer be supported by Wordfence in an upcoming release and needs to be updated. We recommend using the newest version of PHP available but will currently support PHP versions as old as %2$s. Version checks are run regularly, so if you have successfully updated, you can dismiss this notice or check that the update has taken effect later.', 'wordfence'),\n\t\t\t\t\tphpversion(),\n\t\t\t\t\t$wfPHPDeprecatingVersion\n\t\t\t\t)\n\t\t\t\t. ' ' .\n\t\t\t\tsprintf(__('Learn More: %s', 'wordfence'), wfSupportController::esc_supportURL(wfSupportController::ITEM_VERSION_PHP))\n\t\t\t);\n\t\t\t\n\t\t\t$this->_adminNotice(\n\t\t\t\t'phpVersionCheckDeprecationNotice_' . $wfPHPDeprecatingVersion,\n\t\t\t\t'phpVersionCheck',\n\t\t\t\twp_kses(sprintf(\n\t\t\t\t\t\/* translators: 1. PHP version. 2. PHP version. *\/\n\t\t\t\t\t__('<strong>WARNING: <\/strong> Your site is using a PHP version (%1$s) that will no longer be supported by Wordfence in an upcoming release and needs to be updated. We recommend using the newest version of PHP available but will currently support PHP versions as old as %2$s. Version checks are run regularly, so if you have successfully updated, you can dismiss this notice or check that the update has taken effect later.', 'wordfence'),\n\t\t\t\t\tphpversion(),\n\t\t\t\t\t$wfPHPDeprecatingVersion\n\t\t\t\t), array('a'=>array('href'=>array(), 'target'=>array(), 'rel'=>array()))) . ' <a href=\"' . wfSupportController::esc_supportURL(wfSupportController::ITEM_VERSION_PHP) . '\" target=\"_blank\" rel=\"noopener noreferrer\">' . esc_html__('Learn More', 'wordfence') . '<span class=\"screen-reader-text\"> (' . esc_html__('opens in new tab', 'wordfence') . ')<\/span><\/a>'\n\t\t\t);\n\t\t}\n\t\telse if ($php == self::VERSION_UNSUPPORTED) {\n\t\t\t$this->_alertEmail(\n\t\t\t\t'phpVersionCheckUnsupportedEmail_' . $wfPHPMinimumVersion,\n\t\t\t\t__('PHP version too old', 'wordfence'),\n\t\t\t\tsprintf(\n\t\t\t\t\t\/* translators: 1. PHP version. 2. PHP version. *\/\n\t\t\t\t\t__('Your site is using a PHP version (%1$s) that is no longer supported by Wordfence and needs to be updated. We recommend using the newest version of PHP available but will currently support PHP versions as old as %2$s. Version checks are run regularly, so if you have successfully updated, you can dismiss this notice or check that the update has taken effect later.', 'wordfence'),\n\t\t\t\t\tphpversion(),\n\t\t\t\t\t$wfPHPDeprecatingVersion\n\t\t\t\t) . ' ' . sprintf(\/* translators: Support URL. *\/ __('Learn More: %s', 'wordfence'), wfSupportController::esc_supportURL(wfSupportController::ITEM_VERSION_PHP))\n\t\t\t);\n\t\t\t\n\t\t\t$this->_adminNotice(\n\t\t\t\t'phpVersionCheckUnsupportedNotice_' . $wfPHPMinimumVersion,\n\t\t\t\t'phpVersionCheck',\n\t\t\t\twp_kses(sprintf(\n\t\t\t\t\t\/* translators: 1. PHP version. 2. PHP version. *\/\n\t\t\t\t\t__('<strong>WARNING: <\/strong> Your site is using a PHP version (%1$s) that is no longer supported by Wordfence and needs to be updated. We recommend using the newest version of PHP available but will currently support PHP versions as old as %2$s. Version checks are run regularly, so if you have successfully updated, you can dismiss this notice or check that the update has taken effect later.', 'wordfence'),\n\t\t\t\t\tphpversion(),\n\t\t\t\t\t$wfPHPDeprecatingVersion\n\t\t\t\t), array('a'=>array('href'=>array(), 'target'=>array(), 'rel'=>array()))) . ' <a href=\"' . wfSupportController::esc_supportURL(wfSupportController::ITEM_VERSION_PHP) . '\" target=\"_blank\" rel=\"noopener noreferrer\">' . esc_html__('Learn More', 'wordfence') . '<span class=\"screen-reader-text\"> (' . esc_html__('opens in new tab', 'wordfence') . ')<\/span><\/a>'\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\twfAdminNoticeQueue::removeAdminNotice(false, 'phpVersionCheck');\n\t\t}\n\t\t\n\t\tif (wfAdminNoticeQueue::hasNotice('phpVersionCheck')) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t\/\/OpenSSL\n\t\twfAdminNoticeQueue::removeAdminNotice(false, 'opensslVersionCheck');\n\t\t\/*$openssl = $this->checkOpenSSLVersion();\n\t\tif ($openssl == self::VERSION_DEPRECATED) {\n\t\t\t$this->_alertEmail(\n\t\t\t\t'opensslVersionCheckDeprecationEmail_' . $wfOpenSSLDeprecatingVersion,\n\t\t\t\t__('OpenSSL version too old', 'wordfence'),\n\t\t\t\tsprintf(__('Your site is using an OpenSSL version (%s) that will no longer be supported by Wordfence in an upcoming release and needs to be updated. We recommend using the newest version of OpenSSL but will currently support OpenSSL versions as old as %s. Version checks are run regularly, so if you have successfully updated, you can dismiss this notice or check that the update has taken effect later.', 'wordfence'), self::openssl_make_text_version(), $wfOpenSSLDeprecatingVersion) . ' ' . sprintf(__('Learn More: %s', 'wordfence'), wfSupportController::esc_supportURL(wfSupportController::ITEM_VERSION_OPENSSL))\n\t\t\t);\n\t\t\t\n\t\t\t$this->_adminNotice(\n\t\t\t\t'opensslVersionCheckDeprecationNotice_' . $wfOpenSSLDeprecatingVersion,\n\t\t\t\t'opensslVersionCheck',\n\t\t\t\tsprintf(__('<strong>WARNING: <\/strong> Your site is using an OpenSSL version (%s) that will no longer be supported by Wordfence in an upcoming release and needs to be updated. We recommend using the newest version of OpenSSL but will currently support OpenSSL versions as old as %s. Version checks are run regularly, so if you have successfully updated, you can dismiss this notice or check that the update has taken effect later.', 'wordfence'), self::openssl_make_text_version(), $wfOpenSSLDeprecatingVersion) . ' <a href=\"' . wfSupportController::esc_supportURL(wfSupportController::ITEM_VERSION_OPENSSL) . '\" target=\"_blank\" rel=\"noopener noreferrer\">' . __('Learn More', 'wordfence') . '<span class=\"screen-reader-text\"> (<?php esc_html_e('opens in new tab', 'wordfence') ?>)<\/span><\/a>'\n\t\t\t);\n\t\t\t\n\t\t\treturn false;\n\t\t}\n\t\telse if ($openssl == self::VERSION_UNSUPPORTED) {\n\t\t\t$this->_alertEmail(\n\t\t\t\t'opensslVersionCheckUnsupportedEmail_' . $wfOpenSSLMinimumVersion,\n\t\t\t\t__('OpenSSL version too old', 'wordfence'),\n\t\t\t\tsprintf(__('Your site is using an OpenSSL version (%s) that is no longer supported by Wordfence and needs to be updated. We recommend using the newest version of OpenSSL but will currently support OpenSSL versions as old as %s. Version checks are run regularly, so if you have successfully updated, you can dismiss this notice or check that the update has taken effect later.', 'wordfence'), self::openssl_make_text_version(), $wfOpenSSLDeprecatingVersion) . ' ' . sprintf(__('Learn More: %s', 'wordfence'), wfSupportController::esc_supportURL(wfSupportController::ITEM_VERSION_OPENSSL))\n\t\t\t);\n\t\t\t\n\t\t\t$this->_adminNotice(\n\t\t\t\t'opensslVersionCheckUnsupportedNotice_' . $wfOpenSSLMinimumVersion,\n\t\t\t\t'opensslVersionCheck',\n\t\t\t\tsprintf(__('<strong>WARNING: <\/strong> Your site is using an OpenSSL version (%s) that is no longer supported by Wordfence and needs to be updated. We recommend using the newest version of OpenSSL but will currently support OpenSSL versions as old as %s. Version checks are run regularly, so if you have successfully updated, you can dismiss this notice or check that the update has taken effect later.', 'wordfence'), self::openssl_make_text_version(), $wfOpenSSLDeprecatingVersion) . ' <a href=\"' . wfSupportController::esc_supportURL(wfSupportController::ITEM_VERSION_OPENSSL) . '\" target=\"_blank\" rel=\"noopener noreferrer\">' . __('Learn More', 'wordfence') . '<span class=\"screen-reader-text\"> (<?php esc_html_e('opens in new tab', 'wordfence') ?>)<\/span><\/a>'\n\t\t\t);\n\t\t\t\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\twfAdminNoticeQueue::removeAdminNotice(false, 'opensslVersionCheck');\n\t\t}\n\t\t\n\t\tif (wfAdminNoticeQueue::hasNotice('opensslVersionCheck')) {\n\t\t\treturn false;\n\t\t}*\/\n\t\t\n\t\t\/\/WordPress\n\t\t$wordpress = $this->checkWordPressVersion();\n\t\tif ($wordpress == self::VERSION_DEPRECATED) {\n\t\t\trequire(ABSPATH . 'wp-includes\/version.php'); \/** @var string $wp_version *\/\n\t\t\t\n\t\t\t$this->_alertEmail(\n\t\t\t\t'wordpressVersionCheckDeprecationEmail_' . $wfWordPressDeprecatingVersion,\n\t\t\t\t__('WordPress version too old', 'wordfence'),\n\t\t\t\tsprintf(\n\t\t\t\t\t\/* translators: 1. WordPress version. 2. WordPress version. *\/\n\t\t\t\t\t__('Your site is using a WordPress version (%1$s) that will no longer be supported by Wordfence in an upcoming release and needs to be updated. We recommend using the newest version of WordPress but will currently support WordPress versions as old as %2$s. Version checks are run regularly, so if you have successfully updated, you can dismiss this notice or check that the update has taken effect later.', 'wordfence'),\n\t\t\t\t\t$wp_version,\n\t\t\t\t\t$wfWordPressDeprecatingVersion\n\t\t\t\t) . ' ' . sprintf(__('Learn More: %s', 'wordfence'), wfSupportController::esc_supportURL(wfSupportController::ITEM_VERSION_WORDPRESS))\n\t\t\t);\n\t\t\t\n\t\t\t$this->_adminNotice(\n\t\t\t\t'wordpressVersionCheckDeprecationNotice_' . $wfWordPressDeprecatingVersion,\n\t\t\t\t'wordpressVersionCheck',\n\t\t\t\twp_kses(sprintf(\n\t\t\t\t\t\/* translators: 1. WordPress version. 2. WordPress version. *\/\n\t\t\t\t\t__('<strong>WARNING: <\/strong> Your site is using a WordPress version (%1$s) that will no longer be supported by Wordfence in an upcoming release and needs to be updated. We recommend using the newest version of WordPress but will currently support WordPress versions as old as %2$s. Version checks are run regularly, so if you have successfully updated, you can dismiss this notice or check that the update has taken effect later.', 'wordfence'),\n\t\t\t\t\t$wp_version,\n\t\t\t\t\t$wfWordPressDeprecatingVersion\n\t\t\t\t), array('a'=>array('href'=>array(), 'target'=>array(), 'rel'=>array()))) . ' <a href=\"' . wfSupportController::esc_supportURL(wfSupportController::ITEM_VERSION_WORDPRESS) . '\" target=\"_blank\" rel=\"noopener noreferrer\">' . esc_html__('Learn More', 'wordfence') . '<span class=\"screen-reader-text\"> (' . esc_html__('opens in new tab', 'wordfence') . ')<\/span><\/a>'\n\t\t\t);\n\t\t}\n\t\telse if ($wordpress == self::VERSION_UNSUPPORTED) {\n\t\t\trequire(ABSPATH . 'wp-includes\/version.php'); \/** @var string $wp_version *\/\n\t\t\t\n\t\t\t$this->_alertEmail(\n\t\t\t\t'wordpressVersionCheckUnsupportedEmail_' . $wfWordPressMinimumVersion,\n\t\t\t\t__('WordPress version too old', 'wordfence'),\n\t\t\t\tsprintf(\n\t\t\t\t\t\/* translators: 1. WordPress version. 2. WordPress version. *\/\n\t\t\t\t\t__('Your site is using a WordPress version (%1$s) that is no longer supported by Wordfence and needs to be updated. We recommend using the newest version of WordPress but will currently support WordPress versions as old as %2$s. Version checks are run regularly, so if you have successfully updated, you can dismiss this notice or check that the update has taken effect later.', 'wordfence'), $wp_version, $wfWordPressDeprecatingVersion) . ' ' . sprintf(__('Learn More: %s', 'wordfence'), wfSupportController::esc_supportURL(wfSupportController::ITEM_VERSION_WORDPRESS))\n\t\t\t);\n\t\t\t\n\t\t\t$this->_adminNotice(\n\t\t\t\t'wordpressVersionCheckUnsupportedNotice_' . $wfWordPressMinimumVersion,\n\t\t\t\t'wordpressVersionCheck',\n\t\t\t\twp_kses(sprintf(\n\t\t\t\t\t\/* translators: 1. WordPress version. 2. WordPress version. *\/\n\t\t\t\t\t__('<strong>WARNING: <\/strong> Your site is using a WordPress version (%1$s) that is no longer supported by Wordfence and needs to be updated. We recommend using the newest version of WordPress but will currently support WordPress versions as old as %2$s. Version checks are run regularly, so if you have successfully updated, you can dismiss this notice or check that the update has taken effect later.', 'wordfence'), $wp_version, $wfWordPressDeprecatingVersion), array('a'=>array('href'=>array(), 'target'=>array(), 'rel'=>array()))) . ' <a href=\"' . wfSupportController::esc_supportURL(wfSupportController::ITEM_VERSION_WORDPRESS) . '\" target=\"_blank\" rel=\"noopener noreferrer\">' . esc_html__('Learn More', 'wordfence') . '<span class=\"screen-reader-text\"> (' . esc_html__('opens in new tab', 'wordfence') . ')<\/span><\/a>'\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\twfAdminNoticeQueue::removeAdminNotice(false, 'wordpressVersionCheck');\n\t\t}\n\t\t\n\t\tif (wfAdminNoticeQueue::hasNotice('wordpressVersionCheck')) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tprivate function _alertEmail($checkKey, $title, $body) {\n\t\tif (!wfConfig::get($checkKey)) {\n\t\t\twordfence::alert($title, $body, wfUtils::getIP());\n\t\t\twfConfig::set($checkKey, true);\n\t\t}\n\t}\n\t\n\tprivate function _adminNotice($checkKey, $noticeKey, $message) {\n\t\tif (!wfConfig::get($checkKey)) {\n\t\t\twfAdminNoticeQueue::addAdminNotice(wfAdminNotice::SEVERITY_CRITICAL, $message, $noticeKey);\n\t\t\twfConfig::set($checkKey, true);\n\t\t}\n\t}\n\t\n\t\/**\n\t * Returns whether or not the PHP version meets our minimum requirement or is a version being deprecated.\n\t * \n\t * @return string One of the VERSION_ constants.\n\t *\/\n\tpublic function checkPHPVersion() {\n\t\trequire(dirname(__FILE__) . '\/wfVersionSupport.php');\n\t\t\/**\n\t\t * @var string $wfPHPDeprecatingVersion\n\t\t * @var string $wfPHPMinimumVersion\n\t\t *\/\n\t\t\n\t\tif (version_compare(phpversion(), $wfPHPDeprecatingVersion, '>=')) {\n\t\t\treturn self::VERSION_COMPATIBLE;\n\t\t}\n\t\t\n\t\tif ($wfPHPDeprecatingVersion != $wfPHPMinimumVersion && version_compare(phpversion(), $wfPHPMinimumVersion, '>=')) {\n\t\t\treturn self::VERSION_DEPRECATED;\n\t\t}\n\t\t\n\t\treturn self::VERSION_UNSUPPORTED;\n\t}\n\t\n\t\/**\n\t * Returns whether or not the OpenSSL version meets our minimum requirement or is a version being deprecated.\n\t *\n\t * @return string One of the VERSION_ constants.\n\t *\/\n\tpublic function checkOpenSSLVersion() {\n\t\trequire(dirname(__FILE__) . '\/wfVersionSupport.php');\n\t\t\/**\n\t\t * @var string $wfOpenSSLDeprecatingVersion\n\t\t * @var string $wfOpenSSLMinimumVersion\n\t\t *\/\n\t\t\n\t\tif (self::openssl_version_compare($wfOpenSSLDeprecatingVersion) <= 0) {\n\t\t\treturn self::VERSION_COMPATIBLE;\n\t\t}\n\t\t\n\t\tif ($wfOpenSSLDeprecatingVersion != $wfOpenSSLMinimumVersion && self::openssl_version_compare($wfOpenSSLMinimumVersion) <= 0) {\n\t\t\treturn self::VERSION_DEPRECATED;\n\t\t}\n\t\t\n\t\treturn self::VERSION_UNSUPPORTED;\n\t}\n\t\n\t\/**\n\t * Returns whether or not the WordPress version meets our minimum requirement or is a version being deprecated.\n\t *\n\t * @return string One of the VERSION_ constants.\n\t *\/\n\tpublic function checkWordPressVersion() {\n\t\trequire(ABSPATH . 'wp-includes\/version.php'); \/** @var string $wp_version *\/\n\t\t\n\t\trequire(dirname(__FILE__) . '\/wfVersionSupport.php');\n\t\t\/**\n\t\t * @var string $wfWordPressDeprecatingVersion\n\t\t * @var string $wfWordPressMinimumVersion\n\t\t *\/\n\t\t\n\t\tif (version_compare($wp_version, $wfWordPressDeprecatingVersion, '>=')) {\n\t\t\treturn self::VERSION_COMPATIBLE;\n\t\t}\n\t\t\n\t\tif ($wfWordPressDeprecatingVersion != $wfWordPressMinimumVersion && version_compare($wp_version, $wfWordPressMinimumVersion, '>=')) {\n\t\t\treturn self::VERSION_DEPRECATED;\n\t\t}\n\t\t\n\t\treturn self::VERSION_UNSUPPORTED;\n\t}\n\t\n\t\/**\n\t * Utility Functions\n\t *\/\n\t\n\t\/**\n\t * Returns whether or not the OpenSSL version is before, after, or equal to the equivalent text version string.\n\t *\n\t * @param string $compareVersion\n\t * @param int $openSSLVersion A version number in the format OpenSSL uses.\n\t * @param bool $allowDevBeta If true, dev and beta versions of $compareVersion are treated as equivalent to release versions despite having a lower version number.\n\t * @return bool|int Returns -1 if $compareVersion is earlier, 0 if equal, 1 if later, and false if not a valid version string.\n\t *\/\n\tpublic static function openssl_version_compare($compareVersion, $openSSLVersion = OPENSSL_VERSION_NUMBER, $allowDevBeta = true) {\n\t\tif (preg_match('\/^(\\d+)\\.(\\d+)\\.(\\d+)([a-z]*)((?:-dev|-beta\\d\\d?)?)\/i', $compareVersion, $matches)) {\n\t\t\t$primary = 0; $major = 0; $minor = 0; $fixLetterIndexes = 0; $patch = self::OPENSSL_RELEASE;\n\t\t\tif (isset($matches[1])) { $primary = (int) $matches[1]; }\n\t\t\tif (isset($matches[2])) { $major = (int) $matches[2]; }\n\t\t\tif (isset($matches[3])) { $minor = (int) $matches[3]; }\n\t\t\tif (isset($matches[4]) && !empty($matches[4])) {\n\t\t\t\t$letters = str_split($matches[4]);\n\t\t\t\tforeach ($letters as $l) {\n\t\t\t\t\t$fixLetterIndexes += strpos('abcdefghijklmnopqrstuvwxyz', strtolower($l)) + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isset($matches[5]) && !empty($matches[5])) {\n\t\t\t\tif (preg_match('\/^-beta(\\d+)$\/i', $matches[5], $betaMatches)) {\n\t\t\t\t\t$patch = (int) $betaMatches[1];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$patch = self::OPENSSL_DEV;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t$compareOpenSSLVersion = self::openssl_make_number_version($primary, $major, $minor, $fixLetterIndexes, $patch);\n\t\t\tif ($allowDevBeta) {\n\t\t\t\t$compareOpenSSLVersion = $compareOpenSSLVersion >> 4;\n\t\t\t\t$openSSLVersion = $openSSLVersion >> 4;\n\t\t\t}\n\t\t\t\n\t\t\tif ($compareOpenSSLVersion < $openSSLVersion) { return -1; }\n\t\t\telse if ($compareOpenSSLVersion == $openSSLVersion) { return 0; }\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t\/**\n\t * Builds a number that can be compared to OPENSSL_VERSION_NUMBER from the parameters given. This is a modified\n\t * version of the macro in the OpenSSL source.\n\t *\n\t * @param int $primary The '1' in 1.0.2g.\n\t * @param int $major The '0' in 1.0.2g.\n\t * @param int $minor The '2' in 1.0.2g.\n\t * @param int $fixLetterIndexes The 'g' in 1.0.2g. This can potentially be multiple letters, in which case, all of the indexes are added.\n\t * @param int $patch\n\t * @return int\n\t *\/\n\tpublic static function openssl_make_number_version($primary, $major, $minor, $fixLetterIndexes = 0, $patch = 0) {\n\t\treturn ((($primary & 0xff) << 28) + (($major & 0xff) << 20) + (($minor & 0xff) << 12) + (($fixLetterIndexes & 0xff) << 4) + $patch);\n\t}\n\t\n\t\/**\n\t * Builds a text version of the OpenSSL version from a number-formatted one.\n\t * \n\t * @param int $number\n\t * @return string\n\t *\/\n\tpublic static function openssl_make_text_version($number = OPENSSL_VERSION_NUMBER) {\n\t\t$primary = (($number >> 28) & 0xff);\n\t\t$major = (($number >> 20) & 0xff);\n\t\t$minor = (($number >> 12) & 0xff);\n\t\t$fix = (($number >> 4) & 0xff);\n\t\t$patch = ($number & 0xf); \/\/0 is dev, 1-14 are betas, 15 is release\n\t\t\n\t\t$alphabet = str_split('abcdefghijklmnopqrstuvwxyz');\n\t\t$fixLetters = '';\n\t\twhile ($fix > 26) {\n\t\t\t$fixLetters .= 'z';\n\t\t\t$fix -= 26;\n\t\t}\n\t\tif (array_key_exists($fix - 1, $alphabet)) {\n\t\t\t$fixLetters .= $alphabet[$fix - 1];\n\t\t}\n\t\t\n\t\t$version = \"{$primary}.{$major}.{$minor}{$fixLetters}\";\n\t\t\n\t\tif ($patch == self::OPENSSL_DEV) {\n\t\t\t$version .= '-dev';\n\t\t}\n\t\telse if ($patch == self::OPENSSL_RELEASE) {\n\t\t\t\/\/Do nothing\n\t\t}\n\t\telse {\n\t\t\t$version .= '-beta' . $patch;\n\t\t}\n\t\t\n\t\treturn $version;\n\t}\n}"},{"base":"plugins","rel":"wordfence\/lib\/wfScanFileLink.php","ext":"php","size":403,"mtime":1757312769,"type":"text","content":"<?php\n\nrequire_once __DIR__ . '\/wfScanFile.php';\n\nclass wfScanFileLink extends wfScanFile {\n\n\tprivate $linkPath;\n\n\tpublic function __construct($linkPath, $realPath, $wordpressPath) {\n\t\tparent::__construct($realPath, $wordpressPath);\n\t\t$this->linkPath = $linkPath;\n\t}\n\n\tpublic function getLinkPath() {\n\t\treturn $this->linkPath;\n\t}\n\n\tpublic function getDisplayPath() {\n\t\treturn $this->getLinkPath();\n\t}\n\n}"},{"base":"plugins","rel":"wordfence\/lib\/wfCrypt.php","ext":"php","size":4146,"mtime":1757312769,"type":"text","content":"<?php\nclass wfCrypt {\n\tprivate static function getPubKey(){\n\t\t#Command to generate our keypair was: openssl req -x509 -newkey rsa:2048 -keyout mycert.key -out mycert.pem -nodes -subj \"\/C=US\/ST=Washington\/L=Seattle\/O=Wordfence\/OU=IT\/CN=wordfence.com\" -days 7300\n\t\t#This is a 2048 bit key using SHA256 with RSA. \n\t\t$key = <<<ENDKEY\n-----BEGIN CERTIFICATE-----\nMIIDrTCCApWgAwIBAgIJAIg6Va5tcvwyMA0GCSqGSIb3DQEBCwUAMG0xCzAJBgNV\nBAYTAlVTMRMwEQYDVQQIDApXYXNoaW5ndG9uMRAwDgYDVQQHDAdTZWF0dGxlMRIw\nEAYDVQQKDAlXb3JkZmVuY2UxCzAJBgNVBAsMAklUMRYwFAYDVQQDDA13b3JkZmVu\nY2UuY29tMB4XDTE1MDMxMjA1NTIzMFoXDTM1MDMwNzA1NTIzMFowbTELMAkGA1UE\nBhMCVVMxEzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxEjAQ\nBgNVBAoMCVdvcmRmZW5jZTELMAkGA1UECwwCSVQxFjAUBgNVBAMMDXdvcmRmZW5j\nZS5jb20wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC\/9Ogj1PIQsuZu\ndTUNWlG0zaDNWpeY1ZiB\/6oBS\/YXkGFuG8R\/nZ\/kYsRmBm6yRp\/3jC\/HiPjg+7Zc\nbA\/CKoHdUlNjFZ+10DmS369wVX+c0oV9f720b\/a0xN0qeKxJTiN2NsAl5szYv2CQ\nBvzjeb5VfKgrfV9tgYr38swudxvexponYaK0OlDL3u\/Xca4SLRKmB+ZYCcZJttoG\nSNFsQMlLHWWmM0FJH9qZ3x8MtRM5KsNEWO+\/op511Rr36ZnLJdzUnETsaxHKwuCv\n0+D9b0mwk8K\/c67l63v4+zywXNkdYIslgo7Aeeyb6t0lyyfruXutEyMinmApACT2\nsDMAbYk7AgMBAAGjUDBOMB0GA1UdDgQWBBTstr\/AoPQyLLIt4\/peFSjj0FFXHzAf\nBgNVHSMEGDAWgBTstr\/AoPQyLLIt4\/peFSjj0FFXHzAMBgNVHRMEBTADAQH\/MA0G\nCSqGSIb3DQEBCwUAA4IBAQA9HsK+XdZh2MGP2SDdggA+MxkNBCCFBtcsmQrpiLUW\n67xt59FPRMwTgSA9Lt8uqcWaXoHXiaTnXTRtN\/BKZR0F71HQfiV6zy511blIRlk2\nnV+vYzwLUENCZ31hQEZsY+uYqBSTiHecUKohn8A9pOOEpis2YEn2zVo4cobdyGa1\nzCnaAN99KT8s9lOO0UW0J52qZhvv4y8YhELtrXKBsFatGEsVIM0NFI+ZDsNpMnSQ\ncmUtLiIJtk5hxNbOaIz2vzbOkbzJ3ehzODJ1X5rya7X0v2akLLhwP9jqz5ua6ttP\nduLv4Q6v3LY6pwDoyKQMDqNNxVjaFmx5HyFWRPofpu\/T\n-----END CERTIFICATE-----\nENDKEY;\n\t\treturn $key;\n\t}\n\tpublic static function makeSymHexKey($length){\n\t\treturn bin2hex(wfWAFUtils::random_bytes($length \/ 2));\n\t}\n\tpublic static function pubCrypt($symKey){ \/\/encrypts a symmetric key and returns it base64\n\t\topenssl_public_encrypt($symKey, $encSymKey, self::getPubKey(), OPENSSL_PKCS1_OAEP_PADDING); \/\/The default OPENSSL_PKCS1_PADDING is deprecated.\n\t\treturn base64_encode($encSymKey);\n\t}\n\t\n\t\/**\n\t * Returns the payload symmetrically encrypted and signed by the noc1 public key. The payload is converted to JSON, \n\t * encrypted using a randomly-generated symmetric key, and then hashed and signed with the noc1 public key.\n\t * \n\t * This is NOT cryptographically secure for verifying that this server sent or was aware of the context of the \n\t * message, rather it is intended to be used in tandem with verification via another method (e.g., a call that \n\t * validates due to the site URL matching the license key or noc1 does a call itself to the server to retrieve the \n\t * encrypted payload). It is solely a means to provide data to noc1 that only it can read.\n\t * \n\t * @param array $payload\n\t * @return array The encrypted and signed payload in the form array('message' => <encrypted message in hex>, 'signature' => <signature in hex>).\n\t *\/\n\tpublic static function noc1_encrypt($payload) {\n\t\t$payloadJSON = json_encode($payload);\n\t\t\n\t\t$keyData = file_get_contents(dirname(__FILE__) . '\/noc1.key');\n\t\t$key = @openssl_get_publickey($keyData);\n\t\tif ($key !== false) {\n\t\t\t$symmetricKey = wfWAFUtils::random_bytes(32);\n\t\t\t$iv = wfWAFUtils::random_bytes(16);\n\t\t\t$encrypted = @openssl_encrypt($payloadJSON, 'aes-256-cbc', $symmetricKey, OPENSSL_RAW_DATA, $iv);\n\t\t\tif ($encrypted !== false) {\n\t\t\t\t$success = openssl_public_encrypt($symmetricKey, $symmetricKeyEncrypted, $key, OPENSSL_PKCS1_OAEP_PADDING);\n\t\t\t\tif ($success) {\n\t\t\t\t\t$message = $iv . $symmetricKeyEncrypted . $encrypted;\n\t\t\t\t\t$signatureRaw = hash('sha256', $message, true);\n\t\t\t\t\t$success = openssl_public_encrypt($signatureRaw, $signature, $key, OPENSSL_PKCS1_OAEP_PADDING);\n\t\t\t\t\tif ($success) {\n\t\t\t\t\t\t$package = array('message' => bin2hex($message), 'signature' => bin2hex($signature));\n\t\t\t\t\t\treturn $package;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn array();\n\t}\n\t\n\t\/**\n\t * Returns a SHA256 HMAC for $payload using the local long key.\n\t * \n\t * @param $payload\n\t * @return false|string\n\t *\/\n\tpublic static function local_sign($payload) {\n\t\treturn hash_hmac('sha256', $payload, wfConfig::get('longEncKey'));\n\t}\n}\n"},{"base":"plugins","rel":"wordfence\/lib\/menu_tools.php","ext":"php","size":1528,"mtime":1757312769,"type":"text","content":"<?php\nif (!defined('WORDFENCE_VERSION')) { exit; }\n\/**\n * @var string $subpage\n * @var string $content\n *\/\n?>\n<?php\nif (!wfOnboardingController::shouldShowAttempt3() && wfConfig::get('touppPromptNeeded')) {\n\techo wfView::create('gdpr\/disabled-overlay')->render();\n\techo wfView::create('gdpr\/banner')->render();\n}\n?>\n<div class=\"wrap wordfence\">\n\t<div class=\"wf-container-fluid\">\n\t\t<?php\n\t\t$tabsArray = array();\n\t\tif (wfCredentialsController::allowLegacy2FA()) {\n\t\t\t$tabsArray[] = array('twofactor', __('Two-Factor Authentication', 'wordfence'));\n\t\t}\n\t\t$tabsArray[] = array('livetraffic', __('Live Traffic', 'wordfence'));\n\t\t$tabsArray[] = array('auditlog', __('Audit Log', 'wordfence'));\n\t\t$tabsArray[] = array('whois', __('Whois Lookup', 'wordfence'));\n\t\t$tabsArray[] = array('importexport', __('Import\/Export Options', 'wordfence'));\n\t\t$tabsArray[] = array('diagnostics', __('Diagnostics', 'wordfence'));\n\n\t\t$tabs = array();\n\t\tforeach ($tabsArray as $tab) {\n\t\t\tlist($tabID, $tabLabel) = $tab;\n\t\t\t$tabs[] = new wfTab($tabID,\n\t\t\t\tnetwork_admin_url('admin.php?page=WordfenceTools&subpage=' . rawurlencode($tabID)),\n\t\t\t\t$tabLabel, $tabLabel, $subpage === $tabID);\n\t\t}\n\n\t\techo wfView::create('common\/page-fixed-tabbar', array(\n\t\t\t'tabs' => $tabs,\n\t\t))->render();\n\t\t?>\n\t\t<div class=\"wf-row\">\n\t\t\t<div class=\"<?php echo wfStyle::contentClasses(); ?>\">\n\t\t\t\t<div class=\"wf-tab-content wf-active\">\n\t\t\t\t\t<?php echo $content ?>\n\t\t\t\t<\/div>\n\t\t\t<\/div> <!-- end content block -->\n\t\t<\/div> <!-- end row -->\n\t<\/div> <!-- end container -->\n<\/div>"},{"base":"plugins","rel":"wordfence\/lib\/compat.php","ext":"php","size":425,"mtime":1757312769,"type":"text","content":"<?php if (!defined('WORDFENCE_VERSION')) { exit; }\n\nif (!function_exists('str_getcsv')) {\n\n\tfunction str_getcsv($input, $delimiter = ',', $enclosure = '\"', $escape = null, $eol = null) {\n\t\t$temp = fopen(\"php:\/\/memory\", \"rw\");\n\t\tfwrite($temp, $input);\n\t\tfseek($temp, 0);\n\t\t$r = array();\n\t\twhile (($data = fgetcsv($temp, 0, $delimiter, $enclosure, $escape)) !== false) {\n\t\t\t$r[] = $data;\n\t\t}\n\t\tfclose($temp);\n\t\treturn $r;\n\t}\n\n}"},{"base":"plugins","rel":"wordfence\/lib\/dashboard\/widget_notifications.php","ext":"php","size":10338,"mtime":1757312769,"type":"text","content":"<?php if (!defined('WORDFENCE_VERSION')) { exit; } ?>\n<div class=\"wf-flex-row wf-flex-row-full-height wf-flex-row-vertical-xs\">\n\t<div class=\"wf-flex-col-xs-100 <?php if (wfCentral::isSupported() && wfConfig::get('showWfCentralUI', false)): ?>wf-flex-col-lg-50 wf-col-lg-half-padding-right wf-dashboard-item-flex-wrapper<?php endif ?>\">\n\t\t<div class=\"wf-dashboard-item active\">\n\t\t\t<div class=\"wf-dashboard-item-inner\">\n\t\t\t\t<div class=\"wf-dashboard-item-content\">\n\t\t\t\t\t<div class=\"wf-dashboard-item-title\">\n\t\t\t\t\t\t<strong><?php esc_html_e('Notifications', 'wordfence') ?><\/strong><span class=\"wf-dashboard-badge wf-notification-count-container wf-notification-count-value<?php echo (count($d->notifications) == 0 ? ' wf-hidden' : ''); ?>\"><?php echo number_format_i18n(count($d->notifications)); ?><\/span>\n\t\t\t\t\t<\/div>\n\t\t\t\t\t<div class=\"wf-dashboard-item-action\"><div class=\"wf-dashboard-item-action-disclosure\"><\/div><\/div>\n\t\t\t\t<\/div>\n\t\t\t<\/div>\n\t\t\t<div class=\"wf-dashboard-item-extra\">\n\t\t\t\t<ul class=\"wf-dashboard-item-list wf-dashboard-item-list-striped\">\n\t\t\t\t\t<?php foreach ($d->notifications as $n): ?>\n\t\t\t\t\t\t<li class=\"wf-notification<?php if ($n->priority % 10 == 1) { echo ' wf-notification-critical'; } else if ($n->priority % 10 == 2) { echo ' wf-notification-warning'; } ?>\" data-notification=\"<?php echo esc_html($n->id); ?>\">\n\t\t\t\t\t\t\t<div class=\"wf-dashboard-item-list-title\"><?php echo $n->html; ?><\/div>\n\t\t\t\t\t\t\t<?php foreach ($n->links as $l): ?>\n\t\t\t\t\t\t\t\t<div class=\"wf-dashboard-item-list-action\"><a href=\"<?php echo esc_html($l['link']); ?>\"<?php if (preg_match('\/^https?:\\\/\\\/\/i', $l['link'])) { echo ' target=\"_blank\" rel=\"noopener noreferrer\"'; } ?>><?php echo esc_html($l['label']); ?><span class=\"screen-reader-text\"> (<?php esc_html_e('opens in new tab', 'wordfence') ?>)<\/span><\/a><\/div>\n\t\t\t\t\t\t\t<?php endforeach; ?>\n\t\t\t\t\t\t\t<div class=\"wf-dashboard-item-list-dismiss\"><a href=\"#\" class=\"wf-dismiss-notification\" role=\"button\"><i class=\"wf-fa wf-fa-times-circle\" aria-hidden=\"true\"><\/i><\/a><\/div>\n\t\t\t\t\t\t<\/li>\n\t\t\t\t\t<?php endforeach; ?>\n\t\t\t\t\t<?php if (count($d->notifications) == 0): ?>\n\t\t\t\t\t\t<li class=\"wf-notifications-empty\"><?php esc_html_e('No notifications received', 'wordfence') ?><\/li>\n\t\t\t\t\t<?php endif; ?>\n\t\t\t\t<\/ul>\n\t\t\t<\/div>\n\t\t<\/div>\n\t<\/div>\n\t<?php if (wfCentral::isSupported() && wfConfig::get('showWfCentralUI', false)): ?>\n\t\t<div class=\"wf-flex-col-xs-100 wf-flex-col-lg-50 wf-col-lg-half-padding-left wf-dashboard-item-flex-wrapper wf-central-connected\">\n\t\t\t<div class=\"wf-dashboard-item active wf-flex-row-1\">\n\t\t\t\t<div class=\"wf-central-dashboard\">\n\t\t\t\t\t<img class=\"wf-central-dashboard-logo\" src=\"<?php echo wfUtils::getBaseURL() ?>images\/wf-central-logo.svg\" alt=\"Wordfence Central\">\n\t\t\t\t\t<div class=\"wf-central-dashboard-copy\">\n\t\t\t\t\t\t<p id=\"wf-central-status\"><strong><?php esc_html_e('Wordfence Central Status', 'wordfence') ?><\/strong><\/p>\n\t\t\t\t\t\t<?php\n\t\t\t\t\t\tif (!($d->wordfenceCentralConnected || $d->wordfenceCentralDisconnected)) {\n\t\t\t\t\t\t?>\n\t\t\t\t\t\t<p><?php\n\t\t\t\t\t\t\t\tif (wfCentral::isPartialConnection()) {\n\t\t\t\t\t\t\t\t\t_e('It looks like you\\'ve tried to connect this site to Wordfence Central, but the installation did not finish.', 'wordfence');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t_e('Wordfence Central allows you to manage Wordfence on multiple sites from one location. It makes security monitoring and configuring Wordfence easier.', 'wordfence');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t?><\/p>\n\t\t\t\t\t\t<?php\n\t\t\t\t\t\t}\n\t\t\t\t\t\t?>\n\t\t\t\t\t\t<p class=\"wf-no-bottom\"><strong><?php esc_html_e('Connection:', 'wordfence') ?><\/strong> <?php\n\t\t\t\t\t\t\tif ($d->wordfenceCentralConnected) {\n\t\t\t\t\t\t\t\techo esc_html(sprintf(\n\t\t\t\t\t\t\t\t\/* translators: 1. Email address. 2. Localized date. *\/\n\t\t\t\t\t\t\t\t\t\t__('Connected by %1$s on %2$s', 'wordfence'), $d->wordfenceCentralConnectEmail, date_i18n(get_option('date_format'), $d->wordfenceCentralConnectTime)));\n\t\t\t\t\t\t\t} elseif ($d->wordfenceCentralDisconnected) {\n\t\t\t\t\t\t\t\tif ($d->wordfenceCentralDisconnectEmail === null) {\n\t\t\t\t\t\t\t\t\techo esc_html(sprintf(\n\t\t\t\t\t\t\t\t\t\/* translators: 1. Localized date. *\/\n\t\t\t\t\t\t\t\t\t\t__('Disconnected on %1$s', 'wordfence'), date_i18n(get_option('date_format'), $d->wordfenceCentralDisconnectTime)));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tif ($d->wordfenceCentralDisconnectEmail == wfRESTConfigController::WF_CENTRAL_USER_MARKER) {\n\t\t\t\t\t\t\t\t\t\t$identifier = __('a Wordfence Central user', 'wordfence');\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if ($d->wordfenceCentralDisconnectEmail == wfRESTConfigController::WF_CENTRAL_FAILURE_MARKER) {\n\t\t\t\t\t\t\t\t\t\t$identifier = __('Wordfence Central', 'wordfence');\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t$identifier = $d->wordfenceCentralDisconnectEmail;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\techo esc_html(sprintf(\n\t\t\t\t\t\t\t\t\t\/* translators: 1. Email address or placeholder. 2. Localized date. *\/\n\t\t\t\t\t\t\t\t\t\t\t__('Disconnected by %1$s on %2$s', 'wordfence'), $identifier, date_i18n(get_option('date_format'), $d->wordfenceCentralDisconnectTime)));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} elseif (wfCentral::isPartialConnection()) {\n\t\t\t\t\t\t\t\t_e('Connection not finished', 'wordfence');\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t_e('Not connected', 'wordfence');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t?><\/p>\n\t\t\t\t\t\t<p class=\"wf-add-top-small wf-no-bottom\"><strong><?php esc_html_e('Audit Log:', 'wordfence') ?><\/strong> <?php\n\t\t\t\t\t\t\t$auditLogMode = wfAuditLog::shared()->mode();\n\t\t\t\t\t\t\t$isPaid = wfLicense::current()->isAtLeastPremium();\n\t\t\t\t\t\t\tif (!$isPaid) {\n\t\t\t\t\t\t\t\techo esc_html(__('Disabled (premium feature)', 'wordfence'));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (!$d->wordfenceCentralConnected) {\n\t\t\t\t\t\t\t\t\techo esc_html(__('Not recording (Central disconnected)', 'wordfence'));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if ($auditLogMode == wfAuditLog::AUDIT_LOG_MODE_DISABLED || $auditLogMode == wfAuditLog::AUDIT_LOG_MODE_PREVIEW) {\n\t\t\t\t\t\t\t\t\techo esc_html(__('Not recording', 'wordfence'));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if ($auditLogMode == wfAuditLog::AUDIT_LOG_MODE_SIGNIFICANT) {\n\t\t\t\t\t\t\t\t\techo esc_html(__('Recording (significant events only)', 'wordfence'));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if ($auditLogMode == wfAuditLog::AUDIT_LOG_MODE_ALL) {\n\t\t\t\t\t\t\t\t\techo esc_html(__('Recording (all events)', 'wordfence'));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (function_exists('network_admin_url') && is_multisite()) { $auditLogURL = network_admin_url('admin.php?page=WordfenceAuditLog'); }\n\t\t\t\t\t\t\telse { $auditLogURL = admin_url('admin.php?page=WordfenceAuditLog'); }\n\t\t\t\t\t\t?>&nbsp;&nbsp;<a href=\"<?php echo esc_url($auditLogURL); ?>\"><?php esc_html_e('Manage', 'wordfence'); ?><\/a>\n\t\t\t\t\t\t<\/p>\n\t\t\t\t\t\t<div class=\"wf-flex-row\">\n\t\t\t\t\t\t\t<?php if (wfCentral::isPartialConnection()): ?>\n\t\t\t\t\t\t\t\t<p>\n\t\t\t\t\t\t\t\t\t<a href=\"<?php echo WORDFENCE_CENTRAL_URL_SEC ?>\/sites\/connection-issues?complete-setup=<?php echo esc_attr(wfConfig::get('wordfenceCentralSiteID')) ?>\"\n\t\t\t\t\t\t\t\t\t\t\tclass=\"wf-central-resume wf-btn wf-btn-sm wf-btn-primary\"\n\t\t\t\t\t\t\t\t\t><?php esc_html_e('Resume Installation', 'wordfence') ?><\/a>\n\t\t\t\t\t\t\t\t\t<a href=\"#\" class=\"wf-central-disconnect wf-btn wf-btn-sm wf-btn-default\" role=\"button\"><strong><?php esc_html_e('Disconnect This Site', 'wordfence') ?><\/strong><\/a>\n\t\t\t\t\t\t\t\t<\/p>\n\t\t\t\t\t\t\t<?php else: ?>\n\t\t\t\t\t\t\t\t<p class=\"wf-flex-row-1\">\n\t\t\t\t\t\t\t\t\t<?php if ($d->wordfenceCentralConnected): ?>\n\t\t\t\t\t\t\t\t\t\t<a href=\"#\" class=\"wf-central-disconnect\" role=\"button\"><strong><?php esc_html_e('Disconnect This Site', 'wordfence') ?><\/strong><\/a>\n\t\t\t\t\t\t\t\t\t<?php else: ?>\n\t\t\t\t\t\t\t\t\t\t<a href=\"<?php echo WORDFENCE_CENTRAL_URL_SEC ?>?newsite=<?php echo esc_attr(home_url()) ?>\"><strong><?php $d->wordfenceCentralDisconnected ? esc_html_e('Reconnect This Site', 'wordfence') : esc_html_e('Connect This Site', 'wordfence') ?><\/strong><\/a>\n\t\t\t\t\t\t\t\t\t<?php endif; ?>\n\t\t\t\t\t\t\t\t<\/p>\n\t\t\t\t\t\t\t\t<p class=\"wf-flex-row-1 wf-right wf-nowrap\"><a href=\"<?php echo esc_url(WORDFENCE_CENTRAL_URL_SEC) ?>\" target=\"_blank\" rel=\"noopener noreferrer\"><strong><?php esc_html_e('Visit Wordfence Central', 'wordfence') ?><\/strong><span class=\"screen-reader-text\"> (<?php esc_html_e('opens in new tab', 'wordfence') ?>)<\/span><\/a><\/p>\n\t\t\t\t\t\t\t<?php endif ?>\n\n\t\t\t\t\t\t<\/div>\n\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t<\/div>\n\t\t<\/div>\n\t<?php endif ?>\n<\/div>\n<script type=\"application\/javascript\">\n\t(function($) {\n\t\t$('.wf-dismiss-notification').on('click', function(e) {\n\t\t\te.preventDefault();\n\t\t\te.stopPropagation();\n\t\t\t\n\t\t\tvar n = $(this).closest('.wf-notification');\n\t\t\tvar id = n.data('notification');\n\t\t\tn.fadeOut(400, function() {\n\t\t\t\tn.remove();\n\t\t\t\t\n\t\t\t\tvar count = $('.wf-dismiss-notification').length;\n\t\t\t\tWFDash.updateNotificationCount(count);\n\t\t\t});\n\t\t\t\n\t\t\tWFAD.ajax('wordfence_dismissNotification', {\n\t\t\t\tid: id\n\t\t\t}, function(res) {\n\t\t\t\t\/\/Do nothing\n\t\t\t});\n\t\t});\n\n\t\t$('.wf-central-disconnect').on('click', function(e) {\n\t\t\te.preventDefault();\n\n\t\t\tvar prompt = $('#wfTmpl_wfCentralDisconnectPrompt').tmpl();\n\t\t\tvar promptHTML = $(\"<div \/>\").append(prompt).html();\n\t\t\tWFAD.colorboxHTML('400px', promptHTML, {\n\t\t\t\toverlayClose: false, closeButton: false, className: 'wf-modal', onComplete: function() {\n\t\t\t\t\t$('#wf-central-prompt-cancel').on('click', function(e) {\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\te.stopPropagation();\n\n\t\t\t\t\t\tWFAD.colorboxClose();\n\t\t\t\t\t});\n\n\t\t\t\t\t$('#wf-central-prompt-disconnect').on('click', function(e) {\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\te.stopPropagation();\n\t\t\t\t\t\tWFAD.colorboxClose();\n\t\t\t\t\t\tWFAD.ajax('wordfence_wfcentral_disconnect', {}, function(response) {\n\t\t\t\t\t\t\tvar onClosed = function() { window.location.reload(true); };\n\t\t\t\t\t\t\tif (response && response.success && response.message && response.title) {\n\t\t\t\t\t\t\t\tWFAD.colorboxModal(\n\t\t\t\t\t\t\t\t\t(self.isSmallScreen ? '300px' : '400px'),\n\t\t\t\t\t\t\t\t\tresponse.title,\n\t\t\t\t\t\t\t\t\tresponse.message,\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tonClosed: onClosed\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tonClosed();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn false;\n\t\t});\n\t})(jQuery);\n<\/script>\n<script type=\"text\/x-jquery-template\" id=\"wfTmpl_wfCentralDisconnectPrompt\">\n\t<?php\n\techo wfView::create('common\/modal-prompt', array(\n\t\t'title'            => __('Confirm Disconnect', 'wordfence'),\n\t\t'message'          => __('Are you sure you want to disconnect your site from Wordfence Central?', 'wordfence'),\n\t\t'primaryButton'    => array('id' => 'wf-central-prompt-cancel', 'label' => __('Cancel', 'wordfence'), 'link' => '#'),\n\t\t'secondaryButtons' => array(array('id' => 'wf-central-prompt-disconnect', 'label' => __('Disconnect', 'wordfence'), 'link' => '#')),\n\t))->render();\n\t?>\n<\/script>"},{"base":"plugins","rel":"wordfence\/lib\/dashboard\/widget_ips.php","ext":"php","size":6605,"mtime":1757312769,"type":"text","content":"<?php if (!defined('WORDFENCE_VERSION')) { exit; } ?>\n<?php\n\/\/$d is defined here as a wfDashboard instance\n\n$initial = false;\nif (!isset($limit)) { $limit = 10; $initial = true; }\n?>\n<div class=\"wf-row\">\n\t<div class=\"wf-col-xs-12\">\n\t\t<div class=\"wf-dashboard-item active\">\n\t\t\t<div class=\"wf-dashboard-item-inner\">\n\t\t\t\t<div class=\"wf-dashboard-item-content\">\n\t\t\t\t\t<div class=\"wf-dashboard-item-title\">\n\t\t\t\t\t\t<strong><?php esc_html_e('Top IPs Blocked', 'wordfence') ?><\/strong>\n\t\t\t\t\t<\/div>\n\t\t\t\t\t<div class=\"wf-dashboard-item-action\"><div class=\"wf-dashboard-item-action-disclosure\"><\/div><\/div>\n\t\t\t\t<\/div>\n\t\t\t<\/div>\n\t\t\t<div class=\"wf-dashboard-item-extra\">\n\t\t\t\t<?php if ($firewall->learningModeStatus() !== false): ?>\n\t\t\t\t\t<div class=\"wf-widget-learning-mode\"><svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" viewBox=\"0 0 100.11 100.44\"><path d=\"M96.14,30.67a50.7,50.7,0,0,0-10.66-16A50,50,0,0,0,69.51,4,49.57,49.57,0,0,0,30.6,4a50,50,0,0,0-16,10.69A50.69,50.69,0,0,0,4,30.67,50,50,0,0,0,4,69.74a50.62,50.62,0,0,0,10.66,16,50,50,0,0,0,16,10.69,49.54,49.54,0,0,0,38.91,0,50,50,0,0,0,16-10.69,50.56,50.56,0,0,0,10.66-16,50,50,0,0,0,0-39.07Zm-75.74,39a35.77,35.77,0,0,1-1-37.35,35.21,35.21,0,0,1,12.91-13A34.65,34.65,0,0,1,50.06,14.6a34.22,34.22,0,0,1,19.55,5.93ZM82.71,64a35.4,35.4,0,0,1-7.56,11.37A36,36,0,0,1,63.84,83a34.32,34.32,0,0,1-13.79,2.84A34.85,34.85,0,0,1,30.7,80L79.84,31a34.57,34.57,0,0,1,5.67,19.23A35.17,35.17,0,0,1,82.71,64Zm0,0\"\/><\/svg><span><?php esc_html_e('No Data Available During Learning Mode', 'wordfence'); ?><\/span><\/div>\n\t\t\t\t<?php else: ?>\n\t\t\t\t<ul class=\"wf-dashboard-item-list\">\n\t\t\t\t\t<li>\n\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t<div class=\"wf-dashboard-toggle-btns\">\n\t\t\t\t\t\t\t\t<ul class=\"wf-pagination wf-pagination-sm\">\n\t\t\t\t\t\t\t\t\t<li class=\"wf-active\"><a href=\"#\" class=\"wf-dashboard-ips\" data-grouping=\"24h\" role=\"button\"><?php  esc_html_e('24 Hours', 'wordfence') ?><\/a><\/li>\n\t\t\t\t\t\t\t\t\t<li><a href=\"#\" class=\"wf-dashboard-ips\" data-grouping=\"7d\" role=\"button\"><?php esc_html_e('7 Days', 'wordfence') ?><\/a><\/li>\n\t\t\t\t\t\t\t\t\t<li><a href=\"#\" class=\"wf-dashboard-ips\" data-grouping=\"30d\" role=\"button\"><?php esc_html_e('30 Days', 'wordfence') ?><\/a><\/li>\n\t\t\t\t\t\t\t\t<\/ul>\n\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t<div class=\"wf-ips wf-ips-24h\">\n\t\t\t\t\t\t\t\t<?php if (count($d->ips24h) == 0): ?>\n\t\t\t\t\t\t\t\t\t<div class=\"wf-dashboard-item-list-text\"><p><em><?php esc_html_e('No blocks have been recorded.', 'wordfence') ?><\/em><\/p><\/div>\n\t\t\t\t\t\t\t\t<?php else: ?>\n\t\t\t\t\t\t\t\t\t<?php $data = array_slice($d->ips24h, 0, min($limit, count($d->ips24h)), true); include(dirname(__FILE__) . '\/widget_content_ips.php'); ?>\n\t\t\t\t\t\t\t\t\t<?php if (count($d->ips24h) > $limit && $initial): ?>\n\t\t\t\t\t\t\t\t\t\t<div class=\"wf-dashboard-item-list-text\"><div class=\"wf-dashboard-show-more\" data-grouping=\"ips\" data-period=\"24h\"><a href=\"#\" role=\"button\"><?php esc_html_e('Show more', 'wordfence') ?><\/a><\/div><\/div>\n\t\t\t\t\t\t\t\t\t<?php endif; ?>\n\t\t\t\t\t\t\t\t<?php endif; ?>\n\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t<div class=\"wf-ips wf-ips-7d wf-hidden\">\n\t\t\t\t\t\t\t\t<?php if (count($d->ips7d) == 0): ?>\n\t\t\t\t\t\t\t\t\t<div class=\"wf-dashboard-item-list-text\"><p><em><?php esc_html_e('No blocks have been recorded.', 'wordfence') ?><\/em><\/p><\/div>\n\t\t\t\t\t\t\t\t<?php else: ?>\n\t\t\t\t\t\t\t\t\t<?php $data = array_slice($d->ips7d, 0, min($limit, count($d->ips7d)), true); include(dirname(__FILE__) . '\/widget_content_ips.php'); ?>\n\t\t\t\t\t\t\t\t\t<?php if (count($d->ips7d) > $limit && $initial): ?>\n\t\t\t\t\t\t\t\t\t\t<div class=\"wf-dashboard-item-list-text\"><div class=\"wf-dashboard-show-more\" data-grouping=\"ips\" data-period=\"7d\"><a href=\"#\" role=\"button\"><?php esc_html_e('Show more', 'wordfence') ?><\/a><\/div><\/div>\n\t\t\t\t\t\t\t\t\t<?php endif; ?>\n\t\t\t\t\t\t\t\t<?php endif; ?>\n\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t<div class=\"wf-ips wf-ips-30d wf-hidden\">\n\t\t\t\t\t\t\t\t<?php if (count($d->ips30d) == 0): ?>\n\t\t\t\t\t\t\t\t\t<div class=\"wf-dashboard-item-list-text\"><p><em><?php esc_html_e('No blocks have been recorded.', 'wordfence') ?><\/em><\/p><\/div>\n\t\t\t\t\t\t\t\t<?php else: ?>\n\t\t\t\t\t\t\t\t\t<?php $data = array_slice($d->ips30d, 0, min($limit, count($d->ips30d)), true); include(dirname(__FILE__) . '\/widget_content_ips.php'); ?>\n\t\t\t\t\t\t\t\t\t<?php if (count($d->ips30d) > $limit && $initial): ?>\n\t\t\t\t\t\t\t\t\t\t<div class=\"wf-dashboard-item-list-text\"><div class=\"wf-dashboard-show-more\" data-grouping=\"ips\" data-period=\"30d\"><a href=\"#\" role=\"button\"><?php esc_html_e('Show more', 'wordfence') ?><\/a><\/div><\/div>\n\t\t\t\t\t\t\t\t\t<?php endif; ?>\n\t\t\t\t\t\t\t\t<?php endif; ?>\n\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t<script type=\"application\/javascript\">\n\t\t\t\t\t\t\t\t(function($) {\n\t\t\t\t\t\t\t\t\t$('.wf-dashboard-ips').on('click', function(e) {\n\t\t\t\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t\t\t\t\te.stopPropagation();\n\n\t\t\t\t\t\t\t\t\t\t$(this).closest('ul').find('li').removeClass('wf-active');\n\t\t\t\t\t\t\t\t\t\t$(this).closest('li').addClass('wf-active');\n\n\t\t\t\t\t\t\t\t\t\t$('.wf-ips').addClass('wf-hidden');\n\t\t\t\t\t\t\t\t\t\t$('.wf-ips-' + $(this).data('grouping')).removeClass('wf-hidden');\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t$('.wf-ips .wf-dashboard-show-more a').on('click', function(e) {\n\t\t\t\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t\t\t\t\te.stopPropagation();\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tvar grouping = $(this).parent().data('grouping');\n\t\t\t\t\t\t\t\t\t\tvar period = $(this).parent().data('period');\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t$(this).closest('.wf-dashboard-item-list-text').fadeOut();\n\n\t\t\t\t\t\t\t\t\t\tvar self = this;\n\t\t\t\t\t\t\t\t\t\tWFAD.ajax('wordfence_dashboardShowMore', {\n\t\t\t\t\t\t\t\t\t\t\tgrouping: grouping,\n\t\t\t\t\t\t\t\t\t\t\tperiod: period\n\t\t\t\t\t\t\t\t\t\t}, function(res) {\n\t\t\t\t\t\t\t\t\t\t\tif (res.ok) {\n\t\t\t\t\t\t\t\t\t\t\t\tvar table = $('#ips-data-template').tmpl(res);\n\t\t\t\t\t\t\t\t\t\t\t\t$(self).closest('.wf-ips').css('overflow-y', 'auto');\n\t\t\t\t\t\t\t\t\t\t\t\t$(self).closest('.wf-ips').find('table').replaceWith(table);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\tWFAD.colorboxModal('300px', <?php echo json_encode(__('An error occurred', 'wordfence')) ?>, <?php echo json_encode(__('We encountered an error trying load more data.', 'wordfence')) ?>);\n\t\t\t\t\t\t\t\t\t\t\t\t$(this).closest('.wf-dashboard-item-list-text').fadeIn();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t})(jQuery);\n\t\t\t\t\t\t\t<\/script>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t\t<\/li>\n\t\t\t\t<\/ul>\n\t\t\t\t<?php endif; ?>\n\t\t\t<\/div>\n\t\t<\/div>\n\t<\/div>\n<\/div>\n<script type=\"text\/x-jquery-template\" id=\"ips-data-template\">\n\t<table class=\"wf-table wf-table-hover\">\n\t\t<thead>\n\t\t<tr>\n\t\t\t<th><?php esc_html_e('IP', 'wordfence') ?><\/th>\n\t\t\t<th colspan=\"2\"><?php esc_html_e('Country', 'wordfence') ?><\/th>\n\t\t\t<th><?php esc_html_e('Block Count', 'wordfence') ?><\/th>\n\t\t<\/tr>\n\t\t<\/thead>\n\t\t<tbody>\n\t\t{{each(idx, d) data}}\n\t\t<tr>\n\t\t\t<td>${d.IP}<\/td>\n\t\t\t<td>${d.countryName}<\/td>\n\t\t\t<td><span class=\"wf-flag ${d.countryFlag}\" title=\"${d.countryName}\"><\/td>\n\t\t\t<td>${d.blockCount}<\/td>\n\t\t<\/tr>\n\t\t{{\/each}}\n\t\t<\/tbody>\n\t<\/table>\n<\/script>"},{"base":"plugins","rel":"wordfence\/lib\/dashboard\/widget_content_logins.php","ext":"php","size":883,"mtime":1757312769,"type":"text","content":"<?php if (!defined('WORDFENCE_VERSION')) { exit; } ?>\n<?php \/\/$data is defined here as an array of login attempts: array('t' => timestamp, 'name' => username, 'ip' => IP address) ?>\n<table class=\"wf-table wf-table-hover\">\n\t<thead>\n\t\t<tr>\n\t\t\t<th><?php esc_html_e('Username', 'wordfence') ?><\/th>\n\t\t\t<th><?php esc_html_e('IP', 'wordfence') ?><\/th>\n\t\t\t<th><?php esc_html_e('Date', 'wordfence') ?><\/th>\n\t\t<\/tr>\n\t<\/thead>\n\t<tbody>\n\t<?php foreach ($data as $l): ?>\n\t\t<tr>\n\t\t\t<td><?php echo esc_html($l['name']); ?><\/td>\n\t\t\t<td><?php echo esc_html($l['ip']); ?><\/td>\n\t\t\t<td><?php\n\t\t\t\tif (time() - $l['t'] < 86400) {\n\t\t\t\t\techo esc_html(wfUtils::makeTimeAgo(time() - $l['t']) . ' ago');\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\techo esc_html(wfUtils::formatLocalTime(get_option('date_format') . ' ' . get_option('time_format'), (int) $l['t']));\n\t\t\t\t}\n\t\t\t\t?><\/td>\n\t\t<\/tr>\n\t<?php endforeach; ?>\n\t<\/tbody>\n<\/table>"},{"base":"plugins","rel":"wordfence\/lib\/dashboard\/widget_localattacks.php","ext":"php","size":4673,"mtime":1757312769,"type":"text","content":"<?php if (!defined('WORDFENCE_VERSION')) { exit; } ?>\n<div class=\"wf-row\">\n\t<div class=\"wf-col-xs-12\">\n\t\t<div class=\"wf-dashboard-item active\">\n\t\t\t<div class=\"wf-dashboard-item-inner\">\n\t\t\t\t<div class=\"wf-dashboard-item-content\">\n\t\t\t\t\t<div class=\"wf-dashboard-item-title\">\n\t\t\t\t\t\t<strong><?php esc_html_e('Firewall Summary:', 'wordfence'); ?> <\/strong><?php echo esc_html(sprintf(\n\t\t\t\t\t\t\/* translators: The site's domain name. *\/\n\t\t\t\t\t\t\t\t__('Attacks Blocked for %s', 'wordfence'), preg_replace('\/^[^:]+:\\\/\\\/\/', '', network_site_url()))); ?>\n\t\t\t\t\t<\/div>\n\t\t\t\t\t<div class=\"wf-dashboard-item-action\"><div class=\"wf-dashboard-item-action-disclosure\"><\/div><\/div>\n\t\t\t\t<\/div>\n\t\t\t<\/div>\n\t\t\t<div class=\"wf-dashboard-item-extra\">\n\t\t\t\t<?php if ($firewall->learningModeStatus() !== false): ?> \n\t\t\t\t\t<div class=\"wf-widget-learning-mode\"><svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" viewBox=\"0 0 100.11 100.44\"><path d=\"M96.14,30.67a50.7,50.7,0,0,0-10.66-16A50,50,0,0,0,69.51,4,49.57,49.57,0,0,0,30.6,4a50,50,0,0,0-16,10.69A50.69,50.69,0,0,0,4,30.67,50,50,0,0,0,4,69.74a50.62,50.62,0,0,0,10.66,16,50,50,0,0,0,16,10.69,49.54,49.54,0,0,0,38.91,0,50,50,0,0,0,16-10.69,50.56,50.56,0,0,0,10.66-16,50,50,0,0,0,0-39.07Zm-75.74,39a35.77,35.77,0,0,1-1-37.35,35.21,35.21,0,0,1,12.91-13A34.65,34.65,0,0,1,50.06,14.6a34.22,34.22,0,0,1,19.55,5.93ZM82.71,64a35.4,35.4,0,0,1-7.56,11.37A36,36,0,0,1,63.84,83a34.32,34.32,0,0,1-13.79,2.84A34.85,34.85,0,0,1,30.7,80L79.84,31a34.57,34.57,0,0,1,5.67,19.23A35.17,35.17,0,0,1,82.71,64Zm0,0\"\/><\/svg><span><?php esc_html_e('No Data Available During Learning Mode', 'wordfence'); ?><\/span><\/div>\n\t\t\t\t<?php else: ?>\n\t\t\t\t<ul class=\"wf-dashboard-item-list\">\n\t\t\t\t\t<li class=\"wf-flex-vertical wf-flex-full-width\">\n\t\t\t\t\t\t<?php\n\t\t\t\t\t\t$hasSome = false;\n\t\t\t\t\t\tforeach ($d->localBlocks as $row) {\n\t\t\t\t\t\t\tif ($row['24h'] > 0 || $row['7d'] > 0 || $row['30d'] > 0) {\n\t\t\t\t\t\t\t\t$hasSome = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!$hasSome):\n\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t<div class=\"wf-dashboard-item-list-text\"><p><em><?php esc_html_e('No blocks have been recorded.', 'wordfence'); ?><\/em><\/p><\/div>\n\t\t\t\t\t\t<?php else: ?>\n\t\t\t\t\t\t\t<table class=\"wf-blocks-summary\">\n\t\t\t\t\t\t\t\t<thead>\n\t\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t\t<th><?php echo wp_kses(__('<span class=\"wf-hidden-xs\">Block <\/span>Type', 'wordfence'), array('span'=>array('class'=>array()))); ?><\/th>\n\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t$totals = array('24h' => 0, '7d' => 0, '30d' => 0);\n\t\t\t\t\t\t\t\tforeach ($d->localBlocks as $row): ?>\n\t\t\t\t\t\t\t\t\t<th width=\"25%\"<?php if ($row['type'] == wfActivityReport::BLOCK_TYPE_BLACKLIST && !wfConfig::get('isPaid')) { echo ' class=\"wf-premium\"'; } ?>><?php echo esc_html($row['title']); ?><\/th>\n\t\t\t\t\t\t\t\t\t<?php $totals['24h'] += $row['24h']; $totals['7d'] += $row['7d']; $totals['30d'] += $row['30d']; ?>\n\t\t\t\t\t\t\t\t<?php endforeach; ?>\n\t\t\t\t\t\t\t\t\t<th width=\"25%\"><?php esc_html_e('Total', 'wordfence'); ?><\/th>\n\t\t\t\t\t\t\t\t<\/tr>\n\t\t\t\t\t\t\t\t<\/thead>\n\t\t\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t$keys = array('24h' => __('Today', 'wordfence'), '7d' => __('Week', 'wordfence'), '30d' => __('Month', 'wordfence'));\n\t\t\t\t\t\t\t\tforeach ($keys as $k => $title): ?>\n\t\t\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t\t\t<th><?php echo esc_html($title); ?><\/th>\n\t\t\t\t\t\t\t\t<?php foreach ($d->localBlocks as $row): ?>\n\t\t\t\t\t\t\t\t\t\t<td<?php if ($row['type'] == wfActivityReport::BLOCK_TYPE_BLACKLIST && !wfConfig::get('isPaid')) { echo ' class=\"wf-premium\"'; } ?>><?php echo ($row['type'] == wfActivityReport::BLOCK_TYPE_BLACKLIST && !wfConfig::get('isPaid')) ? '&mdash;' : esc_html(number_format_i18n($row[$k])); ?><\/td> \n\t\t\t\t\t\t\t\t<?php endforeach; ?>\n\t\t\t\t\t\t\t\t\t\t<td><?php echo esc_html(number_format_i18n($totals[$k])); ?><\/td>\n\t\t\t\t\t\t\t\t\t<\/tr>\n\t\t\t\t\t\t\t\t<?php endforeach; ?>\n\t\t\t\t\t\t\t\t<\/tbody>\n\t\t\t\t\t\t\t\t<tfoot>\n\t\t\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t\t\t<th><\/th>\n\t\t\t\t\t\t\t\t\t\t<?php foreach ($d->localBlocks as $row): ?>\n\t\t\t\t\t\t\t\t\t\t\t<td<?php if ($row['type'] == wfActivityReport::BLOCK_TYPE_BLACKLIST && !wfConfig::get('isPaid')) { echo ' class=\"wf-premium\"'; } ?>><?php if ($row['type'] == wfActivityReport::BLOCK_TYPE_BLACKLIST && !wfConfig::get('isPaid')) { esc_html_e('Premium', 'wordfence'); } ?><\/td>\n\t\t\t\t\t\t\t\t\t\t<?php endforeach; ?>\n\t\t\t\t\t\t\t\t\t\t<td><\/td>\n\t\t\t\t\t\t\t\t\t<\/tr>\n\t\t\t\t\t\t\t\t<\/tfoot>\n\t\t\t\t\t\t\t<\/table>\n\t\t\t\t\t\t\t<p class=\"wf-right wf-no-top\"><a href=\"<?php echo wfSupportController::esc_supportURL(wfSupportController::ITEM_WIDGET_LOCAL_ATTACKS); ?>\" target=\"_blank\" rel=\"noopener noreferrer\"><i class=\"wf-fa wf-fa-question-circle-o\" aria-hidden=\"true\"><\/i> <?php esc_html_e('How are these categorized?', 'wordfence'); ?><span class=\"screen-reader-text\"> (<?php esc_html_e('opens in new tab', 'wordfence') ?>)<\/span><\/a><\/p>\n\t\t\t\t\t\t<?php endif; ?>\n\t\t\t\t\t<\/li>\n\t\t\t\t<\/ul>\n\t\t\t\t<?php endif; ?>\n\t\t\t<\/div>\n\t\t<\/div>\n\t<\/div>\n<\/div>"},{"base":"plugins","rel":"wordfence\/lib\/dashboard\/widget_networkattacks.php","ext":"php","size":7671,"mtime":1757312769,"type":"text","content":"<?php if (!defined('WORDFENCE_VERSION')) { exit; } ?>\n<div class=\"wf-row\">\n\t<div class=\"wf-col-xs-12\">\n\t\t<div class=\"wf-dashboard-item active\">\n\t\t\t<div class=\"wf-dashboard-item-inner\">\n\t\t\t\t<div class=\"wf-dashboard-item-content\">\n\t\t\t\t\t<div class=\"wf-dashboard-item-title\">\n\t\t\t\t\t\t<strong><?php esc_html_e('Total Attacks Blocked:', 'wordfence'); ?> <\/strong><?php esc_html_e('Wordfence Network', 'wordfence'); ?>\n\t\t\t\t\t<\/div>\n\t\t\t\t\t<div class=\"wf-dashboard-item-action\"><div class=\"wf-dashboard-item-action-disclosure\"><\/div><\/div>\n\t\t\t\t<\/div>\n\t\t\t<\/div>\n\t\t\t<div class=\"wf-dashboard-item-extra\">\n\t\t\t\t<ul class=\"wf-dashboard-item-list\">\n\t\t\t\t\t<li>\n\t\t\t\t\t\t<?php if ($d->networkBlock24h === null): ?>\n\t\t\t\t\t\t\t<div class=\"wf-dashboard-item-list-text\"><p><em><?php esc_html_e('Blocked attack counts not available yet.', 'wordfence'); ?><\/em><\/p><\/div>\n\t\t\t\t\t\t<?php else: ?>\n\t\t\t\t\t\t\t<div class=\"wf-dashboard-graph-wrapper\">\n\t\t\t\t\t\t\t\t<div class=\"wf-dashboard-toggle-btns\">\n\t\t\t\t\t\t\t\t\t<ul class=\"wf-pagination wf-pagination-sm\">\n\t\t\t\t\t\t\t\t\t\t<li class=\"wf-active\"><a href=\"#\" class=\"wf-dashboard-graph-attacks\" data-grouping=\"24h\" role=\"button\"><?php esc_html_e('24 Hours', 'wordfence'); ?><\/a><\/li>\n\t\t\t\t\t\t\t\t\t\t<li><a href=\"#\" class=\"wf-dashboard-graph-attacks\" data-grouping=\"30d\" role=\"button\"><?php esc_html_e('30 Days', 'wordfence'); ?><\/a><\/li>\n\t\t\t\t\t\t\t\t\t<\/ul>\n\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t\t<div class=\"wf-dashboard-network-blocks\"><canvas id=\"wf-dashboard-network-blocks-24h\"><\/canvas><\/div>\n\t\t\t\t\t\t\t\t<div class=\"wf-dashboard-network-blocks wf-hidden\"><canvas id=\"wf-dashboard-network-blocks-7d\"><\/canvas><\/div>\n\t\t\t\t\t\t\t\t<div class=\"wf-dashboard-network-blocks wf-hidden\"><canvas id=\"wf-dashboard-network-blocks-30d\"><\/canvas><\/div>\n\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t<script type=\"application\/javascript\">\n\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t$totalAttacksString = json_encode(__(\"Total Attacks\", 'wordfence'));\n\t\t\t\t\t\t\t\t$styling = <<<STYLING\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlabel: $totalAttacksString,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfill: false,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlineTension: 0.1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbackgroundColor: \"rgba(75,192,192,0.4)\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tborderColor: \"#16bc9b\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tborderCapStyle: 'butt',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tborderDash: [],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tborderDashOffset: 0.0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tborderJoinStyle: 'miter',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpointBorderColor: \"rgba(75,192,192,1)\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpointBackgroundColor: \"#fff\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpointBorderWidth: 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpointHoverRadius: 5,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpointHoverBackgroundColor: \"rgba(75,192,192,1)\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpointHoverBorderColor: \"rgba(220,220,220,1)\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpointHoverBorderWidth: 2,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpointRadius: 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpointHitRadius: 10,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tspanGaps: false,\nSTYLING;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t(function($) {\n\t\t\t\t\t\t\t\t\t$(document).ready(function() {\n\t\t\t\t\t\t\t\t\t\tnew Chart($('#wf-dashboard-network-blocks-24h'), {\n\t\t\t\t\t\t\t\t\t\t\ttype: 'line',\n\t\t\t\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\t\t\t\t$blocks = $d->networkBlock24h;\n\t\t\t\t\t\t\t\t\t\t\t\t$labels = array();\n\t\t\t\t\t\t\t\t\t\t\t\t$values = array();\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\tforeach ($blocks as $b) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t$values[] = $b['c'];\n\t\t\t\t\t\t\t\t\t\t\t\t\t$labels[] = \"'\" . wfUtils::formatLocalTime('g a', $b['t']) . \"'\";\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t\t\t\tlabels: [<?php echo implode(',', $labels); ?>],\n\t\t\t\t\t\t\t\t\t\t\t\tdatasets: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<?php echo $styling; ?>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdata: [<?php echo implode(',', $values) ?>]\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\tscales: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ty: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbeginAtZero: true,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tticks: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcallback: function(value, index, values) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn value.toLocaleString();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\ttooltips: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tcallbacks: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar datasetLabel = data.datasets[tooltipItem.datasetIndex].label || 'Other';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar label = parseInt(tooltipItem.yLabel).toLocaleString();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn datasetLabel + ': ' + label;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\tnew Chart($('#wf-dashboard-network-blocks-7d'), {\n\t\t\t\t\t\t\t\t\t\t\ttype: 'line',\n\t\t\t\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\t\t\t\t$blocks = $d->networkBlock7d;\n\t\t\t\t\t\t\t\t\t\t\t\t$labels = array();\n\t\t\t\t\t\t\t\t\t\t\t\t$values = array();\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\tforeach ($blocks as $b) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t$values[] = $b['c'];\n\t\t\t\t\t\t\t\t\t\t\t\t\t$labels[] = \"'\" . wfUtils::formatLocalTime('M j', $b['t']) . \"'\";\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t\t\t\tlabels: [<?php echo implode(',', $labels); ?>],\n\t\t\t\t\t\t\t\t\t\t\t\tdatasets: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<?php echo $styling; ?>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdata: [<?php echo implode(',', $values) ?>]\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\tscales: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ty: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbeginAtZero: true,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tticks: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcallback: function(value, index, values) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn value.toLocaleString();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\ttooltips: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tcallbacks: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar datasetLabel = data.datasets[tooltipItem.datasetIndex].label || 'Other';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar label = parseInt(tooltipItem.yLabel).toLocaleString();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn datasetLabel + ': ' + label;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\tnew Chart($('#wf-dashboard-network-blocks-30d'), {\n\t\t\t\t\t\t\t\t\t\t\ttype: 'line',\n\t\t\t\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\t\t\t\t$blocks = $d->networkBlock30d;\n\t\t\t\t\t\t\t\t\t\t\t\t$labels = array();\n\t\t\t\t\t\t\t\t\t\t\t\t$values = array();\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\tforeach ($blocks as $b) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t$values[] = $b['c'];\n\t\t\t\t\t\t\t\t\t\t\t\t\t$labels[] = \"'\" . wfUtils::formatLocalTime('M j', $b['t']) . \"'\";\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t\t\t\tlabels: [<?php echo implode(',', $labels); ?>],\n\t\t\t\t\t\t\t\t\t\t\t\tdatasets: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<?php echo $styling; ?>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdata: [<?php echo implode(',', $values) ?>]\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\tscales: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ty: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbeginAtZero: true,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tticks: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcallback: function(value, index, values) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn value.toLocaleString();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\ttooltips: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tcallbacks: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar datasetLabel = data.datasets[tooltipItem.datasetIndex].label || 'Other';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar label = parseInt(tooltipItem.yLabel).toLocaleString();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn datasetLabel + ': ' + label;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t$('.wf-dashboard-graph-attacks').on('click', function(e) {\n\t\t\t\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t\t\t\t\te.stopPropagation();\n\n\t\t\t\t\t\t\t\t\t\t$(this).closest('ul').find('li').removeClass('wf-active');\n\t\t\t\t\t\t\t\t\t\t$(this).closest('li').addClass('wf-active');\n\n\t\t\t\t\t\t\t\t\t\t$('.wf-dashboard-network-blocks').addClass('wf-hidden');\n\t\t\t\t\t\t\t\t\t\t$('#wf-dashboard-network-blocks-' + $(this).data('grouping')).closest('.wf-dashboard-network-blocks').removeClass('wf-hidden');\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t})(jQuery);\n\t\t\t\t\t\t\t<\/script>\n\t\t\t\t\t\t<?php endif; ?>\n\t\t\t\t\t<\/li>\n\t\t\t\t<\/ul>\n\t\t\t\t<p class=\"wf-dashboard-last-updated\"><?php echo esc_html(sprintf(\n\t\t\t\t\t\/* translators: Time since. Example: 1 minute, 2 seconds *\/\n\t\t\t\t\t\t__('Last Updated: %s ago', 'wordfence'), wfUtils::makeTimeAgo(time() - $d->lastGenerated))); ?><\/p>\n\t\t\t<\/div>\n\t\t<\/div>\n\t<\/div>\n<\/div>"},{"base":"plugins","rel":"wordfence\/lib\/dashboard\/widget_logins.php","ext":"php","size":4799,"mtime":1757312769,"type":"text","content":"<?php if (!defined('WORDFENCE_VERSION')) { exit; } ?>\n<?php \/\/$d is defined here as a wfDashboard instance ?>\n<div class=\"wf-row\">\n\t<div class=\"wf-col-xs-12\">\n\t\t<div class=\"wf-dashboard-item active\">\n\t\t\t<div class=\"wf-dashboard-item-inner\">\n\t\t\t\t<div class=\"wf-dashboard-item-content\">\n\t\t\t\t\t<div class=\"wf-dashboard-item-title\">\n\t\t\t\t\t\t<strong><?php esc_html_e('Login Attempts', 'wordfence') ?><\/strong>\n\t\t\t\t\t<\/div>\n\t\t\t\t\t<div class=\"wf-dashboard-item-action\"><div class=\"wf-dashboard-item-action-disclosure\"><\/div><\/div>\n\t\t\t\t<\/div>\n\t\t\t<\/div>\n\t\t\t<div class=\"wf-dashboard-item-extra\">\n\t\t\t\t<ul class=\"wf-dashboard-item-list\">\n\t\t\t\t\t<li>\n\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t<div class=\"wf-dashboard-toggle-btns\">\n\t\t\t\t\t\t\t\t<ul class=\"wf-pagination wf-pagination-sm\">\n\t\t\t\t\t\t\t\t\t<li class=\"wf-active\"><a href=\"#\" class=\"wf-dashboard-login-attempts\" data-grouping=\"success\" role=\"button\"><?php esc_html_e('Successful', 'wordfence') ?><\/a><\/li>\n\t\t\t\t\t\t\t\t\t<li><a href=\"#\" class=\"wf-dashboard-login-attempts\" data-grouping=\"fail\" role=\"button\"><?php esc_html_e('Failed', 'wordfence') ?><\/a><\/li>\n\t\t\t\t\t\t\t\t<\/ul>\n\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t<div class=\"wf-recent-logins wf-recent-logins-success\">\n\t\t\t\t\t\t\t\t<?php if (count($d->loginsSuccess) == 0): ?>\n\t\t\t\t\t\t\t\t\t<div class=\"wf-dashboard-item-list-text\"><p><em><?php esc_html_e('No successful logins have been recorded.', 'wordfence') ?><\/em><\/p><\/div>\n\t\t\t\t\t\t\t\t<?php else: ?>\n\t\t\t\t\t\t\t\t\t<?php $data = array_slice($d->loginsSuccess, 0, min(10, count($d->loginsSuccess)), true); include(dirname(__FILE__) . '\/widget_content_logins.php'); ?>\n\t\t\t\t\t\t\t\t\t<?php if (count($d->loginsSuccess) > 10): ?>\n\t\t\t\t\t\t\t\t\t\t<div class=\"wf-dashboard-item-list-text\"><div class=\"wf-dashboard-show-more\" data-grouping=\"logins\" data-period=\"success\"><a href=\"#\" role=\"button\"><?php esc_html_e('Show more', 'wordfence') ?><\/a><\/div><\/div>\n\t\t\t\t\t\t\t\t\t<?php endif; ?>\n\t\t\t\t\t\t\t\t<?php endif; ?>\n\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t<div class=\"wf-recent-logins wf-recent-logins-fail wf-hidden\">\n\t\t\t\t\t\t\t\t<?php if (count($d->loginsFail) == 0): ?>\n\t\t\t\t\t\t\t\t\t<div class=\"wf-dashboard-item-list-text\"><p><em><?php esc_html_e('No failed logins have been recorded.', 'wordfence') ?><\/em><\/p><\/div>\n\t\t\t\t\t\t\t\t<?php else: ?>\n\t\t\t\t\t\t\t\t\t<?php $data = array_slice($d->loginsFail, 0, min(10, count($d->loginsFail)), true); include(dirname(__FILE__) . '\/widget_content_logins.php'); ?>\n\t\t\t\t\t\t\t\t\t<?php if (count($d->loginsFail) > 10): ?>\n\t\t\t\t\t\t\t\t\t\t<div class=\"wf-dashboard-item-list-text\"><div class=\"wf-dashboard-show-more\" data-grouping=\"logins\" data-period=\"fail\"><a href=\"#\" role=\"button\"><?php esc_html_e('Show more', 'wordfence') ?><\/a><\/div><\/div>\n\t\t\t\t\t\t\t\t\t<?php endif; ?>\n\t\t\t\t\t\t\t\t<?php endif; ?>\n\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t<script type=\"application\/javascript\">\n\t\t\t\t\t\t\t\t(function($) {\n\t\t\t\t\t\t\t\t\t$('.wf-dashboard-login-attempts').on('click', function(e) {\n\t\t\t\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t\t\t\t\te.stopPropagation();\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t$(this).closest('ul').find('li').removeClass('wf-active');\n\t\t\t\t\t\t\t\t\t\t$(this).closest('li').addClass('wf-active'); \n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t$('.wf-recent-logins').addClass('wf-hidden');\n\t\t\t\t\t\t\t\t\t\t$('.wf-recent-logins-' + $(this).data('grouping')).removeClass('wf-hidden');\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t$('.wf-recent-logins .wf-dashboard-show-more a').on('click', function(e) {\n\t\t\t\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t\t\t\t\te.stopPropagation();\n\n\t\t\t\t\t\t\t\t\t\tvar grouping = $(this).parent().data('grouping');\n\t\t\t\t\t\t\t\t\t\tvar period = $(this).parent().data('period');\n\n\t\t\t\t\t\t\t\t\t\t$(this).closest('.wf-dashboard-item-list-text').fadeOut();\n\n\t\t\t\t\t\t\t\t\t\tvar self = this;\n\t\t\t\t\t\t\t\t\t\tWFAD.ajax('wordfence_dashboardShowMore', {\n\t\t\t\t\t\t\t\t\t\t\tgrouping: grouping,\n\t\t\t\t\t\t\t\t\t\t\tperiod: period\n\t\t\t\t\t\t\t\t\t\t}, function(res) {\n\t\t\t\t\t\t\t\t\t\t\tif (res.ok) {\n\t\t\t\t\t\t\t\t\t\t\t\tvar table = $('#logins-data-template').tmpl(res);\n\t\t\t\t\t\t\t\t\t\t\t\t$(self).closest('.wf-recent-logins').css('overflow-y', 'auto');\n\t\t\t\t\t\t\t\t\t\t\t\t$(self).closest('.wf-recent-logins').find('table').replaceWith(table);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\tWFAD.colorboxModal('300px', <?php echo json_encode(__('An error occurred', 'wordfence')) ?>, <?php echo json_encode(__('We encountered an error trying load more data.', 'wordfence')) ?>);\n\t\t\t\t\t\t\t\t\t\t\t\t$(this).closest('.wf-dashboard-item-list-text').fadeIn();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t})(jQuery);\n\t\t\t\t\t\t\t<\/script>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t\t<\/li>\n\t\t\t\t<\/ul>\n\t\t\t<\/div>\n\t\t<\/div>\n\t<\/div>\n<\/div>\n<script type=\"text\/x-jquery-template\" id=\"logins-data-template\">\n\t<table class=\"wf-table wf-table-hover\">\n\t\t<thead>\n\t\t<tr>\n\t\t\t<th><?php esc_html_e('Username', 'wordfence') ?><\/th>\n\t\t\t<th><?php esc_html_e('IP', 'wordfence') ?><\/th>\n\t\t\t<th><?php esc_html_e('Date', 'wordfence') ?><\/th>\n\t\t<\/tr>\n\t\t<\/thead>\n\t\t<tbody>\n\t\t{{each(idx, d) data}}\n\t\t<tr>\n\t\t\t<td>${d.name}<\/td>\n\t\t\t<td>${d.ip}<\/td>\n\t\t\t<td>${d.t}<\/td>\n\t\t<\/tr>\n\t\t{{\/each}}\n\t\t<\/tbody>\n\t<\/table>\n<\/script>"},{"base":"plugins","rel":"wordfence\/lib\/dashboard\/widget_content_countries.php","ext":"php","size":871,"mtime":1757312769,"type":"text","content":"<?php if (!defined('WORDFENCE_VERSION')) { exit; } ?>\n<?php \/\/$data is defined here as an array of login attempts: array('IP' => binary ip, 'countryCode' => string, 'blockCount' => int, 'unixday' => int, 'totalIPs' => int, 'totalBlockCount' => int, 'countryName' => string) ?>\n<table class=\"wf-table wf-table-hover\">\n\t<thead>\n\t\t<tr>\n\t\t\t<th colspan=\"2\"><?php esc_html_e('Country', 'wordfence') ?><\/th>\n\t\t\t<th><?php esc_html_e('Block Count', 'wordfence') ?><\/th>\n\t\t<\/tr>\n\t<\/thead>\n\t<tbody>\n\t<?php foreach ($data as $l): ?>\n\t\t<tr>\n\t\t\t<td><?php echo esc_html($l['countryName']); ?><\/td>\n\t\t\t<td><span class=\"wf-flag <?php echo esc_attr('wf-flag-' . strtolower($l['countryCode'])); ?>\" title=\"<?php echo esc_attr($l['countryName']); ?>\"><\/span><\/td>\n\t\t\t<td><?php echo esc_html(number_format_i18n($l['totalBlockCount'])); ?><\/td>\n\t\t<\/tr>\n\t<?php endforeach; ?>\n\t<\/tbody>\n<\/table>"},{"base":"plugins","rel":"wordfence\/lib\/dashboard\/widget_countries.php","ext":"php","size":3713,"mtime":1757312769,"type":"text","content":"<?php if (!defined('WORDFENCE_VERSION')) { exit; } ?>\n<?php \/\/$d is defined here as a wfDashboard instance ?>\n<div class=\"wf-row\">\n\t<div class=\"wf-col-xs-12\">\n\t\t<div class=\"wf-dashboard-item active\">\n\t\t\t<div class=\"wf-dashboard-item-inner\">\n\t\t\t\t<div class=\"wf-dashboard-item-content\">\n\t\t\t\t\t<div class=\"wf-dashboard-item-title\">\n\t\t\t\t\t\t<strong><?php esc_html_e('Top Countries by Number of Attacks - Last 7 Days', 'wordfence') ?><\/strong>\n\t\t\t\t\t<\/div>\n\t\t\t\t\t<div class=\"wf-dashboard-item-action\"><div class=\"wf-dashboard-item-action-disclosure\"><\/div><\/div>\n\t\t\t\t<\/div>\n\t\t\t<\/div>\n\t\t\t<div class=\"wf-dashboard-item-extra\">\n\t\t\t\t<?php if ($firewall->learningModeStatus() !== false): ?>\n\t\t\t\t\t<div class=\"wf-widget-learning-mode\"><svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" viewBox=\"0 0 100.11 100.44\"><path d=\"M96.14,30.67a50.7,50.7,0,0,0-10.66-16A50,50,0,0,0,69.51,4,49.57,49.57,0,0,0,30.6,4a50,50,0,0,0-16,10.69A50.69,50.69,0,0,0,4,30.67,50,50,0,0,0,4,69.74a50.62,50.62,0,0,0,10.66,16,50,50,0,0,0,16,10.69,49.54,49.54,0,0,0,38.91,0,50,50,0,0,0,16-10.69,50.56,50.56,0,0,0,10.66-16,50,50,0,0,0,0-39.07Zm-75.74,39a35.77,35.77,0,0,1-1-37.35,35.21,35.21,0,0,1,12.91-13A34.65,34.65,0,0,1,50.06,14.6a34.22,34.22,0,0,1,19.55,5.93ZM82.71,64a35.4,35.4,0,0,1-7.56,11.37A36,36,0,0,1,63.84,83a34.32,34.32,0,0,1-13.79,2.84A34.85,34.85,0,0,1,30.7,80L79.84,31a34.57,34.57,0,0,1,5.67,19.23A35.17,35.17,0,0,1,82.71,64Zm0,0\"\/><\/svg><span><?php esc_html_e('No Data Available During Learning Mode', 'wordfence'); ?><\/span><\/div>\n\t\t\t\t<?php else: ?>\n\t\t\t\t<ul class=\"wf-dashboard-item-list\">\n\t\t\t\t\t<li>\n\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t<?php if (isset($d->countriesNetwork) && count($d->countriesNetwork) > 0): ?>\n\t\t\t\t\t\t\t<div class=\"wf-dashboard-toggle-btns\">\n\t\t\t\t\t\t\t\t<ul class=\"wf-pagination wf-pagination-sm\">\n\t\t\t\t\t\t\t\t\t<li class=\"wf-active\"><a href=\"#\" class=\"wf-dashboard-countries\" data-grouping=\"local\" role=\"button\">Local Site<\/a><\/li>\n\t\t\t\t\t\t\t\t\t<li><a href=\"#\" class=\"wf-dashboard-countries\" data-grouping=\"network\" role=\"button\"><?php esc_html_e('Wordfence Network', 'wordfence') ?><\/a><\/li>\n\t\t\t\t\t\t\t\t<\/ul>\n\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t<?php endif; ?>\n\t\t\t\t\t\t\t<div class=\"wf-countries wf-countries-local\">\n\t\t\t\t\t\t\t\t<?php if (!isset($d->countriesLocal) || count($d->countriesLocal) == 0): ?>\n\t\t\t\t\t\t\t\t\t<div class=\"wf-dashboard-item-list-text\"><p><em><?php esc_html_e('No blocks have been recorded.', 'wordfence') ?><\/em><\/p><\/div>\n\t\t\t\t\t\t\t\t<?php else: ?>\n\t\t\t\t\t\t\t\t\t<?php $data = array_slice($d->countriesLocal, 0, min(10, count($d->countriesLocal)), true); include(dirname(__FILE__) . '\/widget_content_countries.php'); ?>\n\t\t\t\t\t\t\t\t<?php endif; ?>\n\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t<div class=\"wf-countries wf-countries-network wf-hidden\">\n\t\t\t\t\t\t\t\t<?php if (!isset($d->countriesNetwork) || count($d->countriesNetwork) == 0): ?>\n\t\t\t\t\t\t\t\t\t<div class=\"wf-dashboard-item-list-text\"><p><em><?php esc_html_e('No blocks have been recorded.', 'wordfence') ?><\/em><\/p><\/div>\n\t\t\t\t\t\t\t\t<?php else: ?>\n\t\t\t\t\t\t\t\t\t<?php $data = array_slice($d->countriesNetwork, 0, min(10, count($d->countriesNetwork)), true); include(dirname(__FILE__) . '\/widget_content_countries.php'); ?>\n\t\t\t\t\t\t\t\t<?php endif; ?>\n\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t<script type=\"application\/javascript\">\n\t\t\t\t\t\t\t\t(function($) {\n\t\t\t\t\t\t\t\t\t$('.wf-dashboard-countries').on('click', function(e) {\n\t\t\t\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t\t\t\t\te.stopPropagation();\n\n\t\t\t\t\t\t\t\t\t\t$(this).closest('ul').find('li').removeClass('wf-active');\n\t\t\t\t\t\t\t\t\t\t$(this).closest('li').addClass('wf-active');\n\n\t\t\t\t\t\t\t\t\t\t$('.wf-countries').addClass('wf-hidden');\n\t\t\t\t\t\t\t\t\t\t$('.wf-countries-' + $(this).data('grouping')).removeClass('wf-hidden');\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t})(jQuery);\n\t\t\t\t\t\t\t<\/script>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t\t<\/li>\n\t\t\t\t<\/ul>\n\t\t\t\t<?php endif; ?>\n\t\t\t<\/div>\n\t\t<\/div>\n\t<\/div>\n<\/div>"},{"base":"plugins","rel":"wordfence\/lib\/dashboard\/widget_content_ips.php","ext":"php","size":938,"mtime":1757312769,"type":"text","content":"<?php if (!defined('WORDFENCE_VERSION')) { exit; } ?>\n<?php \/\/$data is defined here as an array of login attempts: array('IP' => binary ip, 'countryCode' => string, 'blockCount' => int, 'unixday' => int, 'countryName' => string) ?>\n<table class=\"wf-table wf-table-hover\">\n\t<thead>\n\t\t<tr>\n\t\t\t<th><?php esc_html_e('IP', 'wordfence') ?><\/th>\n\t\t\t<th colspan=\"2\"><?php esc_html_e('Country', 'wordfence') ?><\/th>\n\t\t\t<th><?php esc_html_e('Block Count', 'wordfence') ?><\/th>\n\t\t<\/tr>\n\t<\/thead>\n\t<tbody>\n\t<?php foreach ($data as $l): ?>\n\t\t<tr>\n\t\t\t<td><?php echo esc_html(wfUtils::inet_ntop($l['IP'])); ?><\/td>\n\t\t\t<td><?php echo esc_html($l['countryName']); ?><\/td>\n\t\t\t<td><span class=\"wf-flag <?php echo esc_attr('wf-flag-' . strtolower($l['countryCode'])); ?>\" title=\"<?php echo esc_attr($l['countryName']); ?>\"><\/span><\/td>\n\t\t\t<td><?php echo esc_html(number_format_i18n($l['blockCount'])); ?><\/td>\n\t\t<\/tr>\n\t<?php endforeach; ?>\n\t<\/tbody>\n<\/table>"},{"base":"plugins","rel":"wordfence\/lib\/wordfenceConstants.php","ext":"php","size":3650,"mtime":1757312769,"type":"text","content":"<?php\ndefine('WORDFENCE_EPOCH', 1312156800);\ndefine('WORDFENCE_FEEDBACK_EPOCH', 1704213261);\ndefine('WORDFENCE_API_VERSION', '2.27');\ndefine('WORDFENCE_API_URL_SEC', 'https:\/\/noc1.wordfence.com\/');\ndefine('WORDFENCE_API_URL_NONSEC', 'http:\/\/noc1.wordfence.com\/');\ndefine('WORDFENCE_API_URL_BASE_SEC', WORDFENCE_API_URL_SEC . 'v' . WORDFENCE_API_VERSION . '\/');\ndefine('WORDFENCE_BREACH_URL_BASE_SEC', WORDFENCE_API_URL_SEC . 'passwords\/');\ndefine('WORDFENCE_HACKATTEMPT_URL_SEC', 'https:\/\/noc3.wordfence.com\/');\nif (!defined('WORDFENCE_CENTRAL_URL_SEC')) { define('WORDFENCE_CENTRAL_URL_SEC', 'https:\/\/www.wordfence.com\/central'); }\nif (!defined('WORDFENCE_CENTRAL_API_URL_SEC')) { define('WORDFENCE_CENTRAL_API_URL_SEC', 'https:\/\/www.wordfence.com\/api\/wf'); }\nif (!defined('WORDFENCE_CENTRAL_PUBLIC_KEY')) { define('WORDFENCE_CENTRAL_PUBLIC_KEY', \"\\xb6\\x33\\x81\\x05\\xdf\\xdf\\xec\\xcf\\xf3\\xe3\\x36\\xc6\\xf0\\x99\\xc6\\xf7\\xca\\x05\\x36\\xca\\x87\\x54\\x53\\x43\\x31\\xf2\\xc6\\x0d\\xe1\\x3d\\x55\\x0f\"); }\ndefine('WORDFENCE_MAX_SCAN_LOCK_TIME', 86400); \/\/Increased this from 10 mins to 1 day because very big scans run for a long time. Users can use kill.\ndefine('WORDFENCE_DEFAULT_MAX_SCAN_TIME', 10800);\nif (!defined('WORDFENCE_SCAN_ISSUES_MAX_REPORT')) { define('WORDFENCE_SCAN_ISSUES_MAX_REPORT', 1500); }\ndefine('WORDFENCE_TRANSIENTS_TIMEOUT', 3600); \/\/how long are items cached in seconds e.g. files downloaded for diffing\ndefine('WORDFENCE_MAX_IPLOC_AGE', 86400); \/\/1 day\ndefine('WORDFENCE_CRAWLER_VERIFY_CACHE_TIME', 604800); \ndefine('WORDFENCE_REVERSE_LOOKUP_CACHE_TIME', 86400);\ndefine('WORDFENCE_MAX_FILE_SIZE_TO_PROCESS', 52428800); \/\/50 megs\ndefine('WORDFENCE_MAX_FILE_SIZE_OFFSET', WORDFENCE_MAX_FILE_SIZE_TO_PROCESS + 1);\ndefine('WORDFENCE_TWO_FACTOR_GRACE_TIME_AUTHENTICATOR', 90);\ndefine('WORDFENCE_TWO_FACTOR_GRACE_TIME_PHONE', 1800);\nif (!defined('WORDFENCE_DISABLE_LIVE_TRAFFIC')) { define('WORDFENCE_DISABLE_LIVE_TRAFFIC', false); }\nif (!defined('WORDFENCE_SCAN_ISSUES_PER_PAGE')) { define('WORDFENCE_SCAN_ISSUES_PER_PAGE', 100); }\nif (!defined('WORDFENCE_BLOCKED_IPS_PER_PAGE')) { define('WORDFENCE_BLOCKED_IPS_PER_PAGE', 100); }\nif (!defined('WORDFENCE_DISABLE_FILE_VIEWER')) { define('WORDFENCE_DISABLE_FILE_VIEWER', false); }\nif (!defined('WORDFENCE_SCAN_FAILURE_THRESHOLD')) { define('WORDFENCE_SCAN_FAILURE_THRESHOLD', 300); }\nif (!defined('WORDFENCE_SCAN_START_FAILURE_THRESHOLD')) { define('WORDFENCE_SCAN_START_FAILURE_THRESHOLD', 15); }\nif (!defined('WORDFENCE_PREFER_WP_HOME_FOR_WPML')) { define('WORDFENCE_PREFER_WP_HOME_FOR_WPML', false); } \/\/When determining the unfiltered `home` and `siteurl` with WPML installed, use WP_HOME and WP_SITEURL if set instead of the database values\nif (!defined('WORDFENCE_SCAN_MIN_EXECUTION_TIME')) { define('WORDFENCE_SCAN_MIN_EXECUTION_TIME', 8); }\nif (!defined('WORDFENCE_SCAN_MAX_INI_EXECUTION_TIME')) { define('WORDFENCE_SCAN_MAX_INI_EXECUTION_TIME', 90); }\nif (!defined('WORDFENCE_ALLOW_DIRECT_MYSQLI')) { define('WORDFENCE_ALLOW_DIRECT_MYSQLI', true); }\nif (!defined('WORDFENCE_NOC3_FAILED_BACKOFF_TIME')) { define('WORDFENCE_NOC3_FAILED_BACKOFF_TIME', 60); }\nif (!defined('WORDFENCE_WWW_BASE_URL'))\n\tdefine('WORDFENCE_WWW_BASE_URL', 'https:\/\/www.wordfence.com\/');\nif (!defined('WORDFENCE_WAF_PREPEND_DIRECTORY')) {\n\tif (WF_IS_PRESSABLE || WF_IS_FLYWHEEL) {\n\t\tdefine('WORDFENCE_WAF_PREPEND_DIRECTORY', WP_CONTENT_DIR);\n\t}\n\telse if (getenv('WORDFENCE_WAF_PREPEND_DIRECTORY') !== false && is_dir(getenv('WORDFENCE_WAF_PREPEND_DIRECTORY'))) {\n\t\tdefine('WORDFENCE_WAF_PREPEND_DIRECTORY', getenv('WORDFENCE_WAF_PREPEND_DIRECTORY'));\n\t}\n\telse {\n\t\tdefine('WORDFENCE_WAF_PREPEND_DIRECTORY', ABSPATH);\n\t}\n}\n"},{"base":"plugins","rel":"wordfence\/lib\/wfImportExportController.php","ext":"php","size":3306,"mtime":1757312769,"type":"text","content":"<?php\n\nclass wfImportExportController {\n\t\/**\n\t * Returns the singleton wfImportExportController.\n\t *\n\t * @return wfImportExportController\n\t *\/\n\tpublic static function shared() {\n\t\tstatic $_shared = null;\n\t\tif ($_shared === null) {\n\t\t\t$_shared = new wfImportExportController();\n\t\t}\n\t\treturn $_shared;\n\t}\n\t\n\tpublic function export() {\n\t\t$export = array();\n\t\t\n\t\t\/\/Basic Options\n\t\t$keys = wfConfig::getExportableOptionsKeys();\n\t\tforeach ($keys as $key) {\n\t\t\t$export[$key] = wfConfig::get($key, '');\n\t\t}\n\t\t\n\t\t\/\/Serialized Options\n\t\t$export['scanSched'] = wfConfig::get_ser('scanSched', array());\n\t\t\n\t\t\/\/Table-based Options\n\t\t$export['blocks'] = wfBlock::exportBlocks();\n\t\t\n\t\t\/\/Make the API call\n\t\ttry {\n\t\t\t$api = new wfAPI(wfConfig::get('apiKey'), wfUtils::getWPVersion());\n\t\t\t$res = $api->call('export_options', array(), array('export' => json_encode($export)));\n\t\t\tif ($res['ok'] && $res['token']) {\n\t\t\t\treturn array(\n\t\t\t\t\t'ok' => 1,\n\t\t\t\t\t'token' => $res['token'],\n\t\t\t\t);\n\t\t\t}\n\t\t\telse if ($res['err']) {\n\t\t\t\treturn array('err' => __(\"An error occurred: \", 'wordfence') . $res['err']);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new Exception(__(\"Invalid response: \", 'wordfence') . var_export($res, true));\n\t\t\t}\n\t\t}\n\t\tcatch (Exception $e) {\n\t\t\treturn array('err' => __(\"An error occurred: \", 'wordfence') . $e->getMessage());\n\t\t}\n\t}\n\t\n\tpublic function import($token) {\n\t\ttry {\n\t\t\t$api = new wfAPI(wfConfig::get('apiKey'), wfUtils::getWPVersion());\n\t\t\t$res = $api->call('import_options', array(), array('token' => $token));\n\t\t\tif ($res['ok'] && $res['export']) {\n\t\t\t\t$totalSet = 0;\n\t\t\t\t$import = @json_decode($res['export'], true);\n\t\t\t\tif (!is_array($import)) {\n\t\t\t\t\treturn array('err' => __(\"An error occurred: Invalid options format received.\", 'wordfence'));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\/\/Basic Options\n\t\t\t\t$keys = wfConfig::getExportableOptionsKeys();\n\t\t\t\t$toSet = array();\n\t\t\t\tforeach ($keys as $key) {\n\t\t\t\t\tif (isset($import[$key])) {\n\t\t\t\t\t\t$toSet[$key] = $import[$key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (count($toSet)) {\n\t\t\t\t\t$validation = wfConfig::validate($toSet);\n\t\t\t\t\t$skipped = array();\n\t\t\t\t\tif ($validation !== true) {\n\t\t\t\t\t\tforeach ($validation as $error) {\n\t\t\t\t\t\t\t$skipped[$error['option']] = $error['error'];\n\t\t\t\t\t\t\tunset($toSet[$error['option']]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$totalSet += count($toSet);\n\t\t\t\t\twfConfig::save(wfConfig::clean($toSet));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\/\/Serialized Options\n\t\t\t\tif (isset($import['scanSched']) && is_array($import['scanSched'])) {\n\t\t\t\t\twfConfig::set_ser('scanSched', $import['scanSched']);\n\t\t\t\t\twfScanner::shared()->scheduleScans();\n\t\t\t\t\t$totalSet++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\/\/Table-based Options\n\t\t\t\tif (isset($import['blocks']) && is_array($import['blocks'])) {\n\t\t\t\t\twfBlock::importBlocks($import['blocks']);\n\t\t\t\t\t$totalSet += count($import['blocks']);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn array(\n\t\t\t\t\t'ok' => 1,\n\t\t\t\t\t'totalSet' => $totalSet,\n\t\t\t\t);\n\t\t\t}\n\t\t\telse if ($res['err']) {\n\t\t\t\treturn array('err' => sprintf(\/* translators: Error message. *\/ __(\"An error occurred: %s\", 'wordfence'), $res['err']));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new Exception(sprintf(\/* translators: Error message. *\/ __(\"Invalid response: %s\", 'wordfence'), var_export($res, true)));\n\t\t\t}\n\t\t}\n\t\tcatch (Exception $e) {\n\t\t\treturn array('err' => sprintf(\/* translators: Error message. *\/ __(\"An error occurred: %s\", 'wordfence'), $e->getMessage()));\n\t\t}\n\t}\n}\n"},{"base":"plugins","rel":"wordfence\/lib\/wf503.php","ext":"php","size":9905,"mtime":1757312769,"type":"text","content":"<?php if (!defined('WORDFENCE_VERSION')) { exit; } ?>\n<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<title><?php wfI18n::esc_html_e('Your access to this site has been limited', 'wordfence'); ?><\/title>\n\t\t<style>\n\t\t\thtml {\n\t\t\t\tfont-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n\t\t\t\tfont-size: 0.875rem;\n\t\t\t\tline-height: 1.42857143;\n\t\t\t\tcolor: #333;\n\t\t\t\tbackground-color: #fff;\n\t\t\t\tpadding: 0;\n\t\t\t\tmargin: 0;\n\t\t\t}\n\n\t\t\tbody {\n\t\t\t\tpadding: 0;\n\t\t\t\tmargin: 0;\n\t\t\t}\n\n\t\t\ta {\n\t\t\t\tcolor:#00709e;\n\t\t\t}\n\n\t\t\th1, h2, h3, h4, h5, h6 {\n\t\t\t\tfont-weight: 200;\n\t\t\t\tline-height: 1.1;\n\t\t\t}\n\n\t\t\th1, .h1 { font-size: 3rem; }\n\t\t\th2, .h2 { font-size: 2.5rem; }\n\t\t\th3, .h3 { font-size: 1.5rem; }\n\t\t\th4, .h4 { font-size: 1rem; }\n\t\t\th5, .h5 { font-size: 0.875rem; }\n\t\t\th6, .h6 { font-size: 0.75rem; }\n\n\t\t\th1, h2, h3 {\n\t\t\t\tmargin-top: 20px;\n\t\t\t\tmargin-bottom: 10px;\n\t\t\t}\n\t\t\th4, h5, h6 {\n\t\t\t\tmargin-top: 10px;\n\t\t\t\tmargin-bottom: 10px;\n\t\t\t}\n\n\t\t\t.wf-btn {\n\t\t\t\tdisplay: inline-block;\n\t\t\t\tmargin-bottom: 0;\n\t\t\t\tfont-weight: normal;\n\t\t\t\ttext-align: center;\n\t\t\t\tvertical-align: middle;\n\t\t\t\ttouch-action: manipulation;\n\t\t\t\tcursor: pointer;\n\t\t\t\tbackground-image: none;\n\t\t\t\tborder: 1px solid transparent;\n\t\t\t\twhite-space: nowrap;\n\t\t\t\ttext-transform: uppercase;\n\t\t\t\tpadding: .4rem 1rem;\n\t\t\t\tfont-size: .875rem;\n\t\t\t\tline-height: 1.3125rem;\n\t\t\t\tborder-radius: 4px;\n\t\t\t\t-webkit-user-select: none;\n\t\t\t\t-moz-user-select: none;\n\t\t\t\t-ms-user-select: none;\n\t\t\t\tuser-select: none\n\t\t\t}\n\n\t\t\t@media (min-width: 768px) {\n\t\t\t\t.wf-btn {\n\t\t\t\t\tpadding: .5rem 1.25rem;\n\t\t\t\t\tfont-size: .875rem;\n\t\t\t\t\tline-height: 1.3125rem;\n\t\t\t\t\tborder-radius: 4px\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t.wf-btn:focus,\n\t\t\t.wf-btn.wf-focus,\n\t\t\t.wf-btn:active:focus,\n\t\t\t.wf-btn:active.wf-focus,\n\t\t\t.wf-btn.wf-active:focus,\n\t\t\t.wf-btn.wf-active.wf-focus {\n\t\t\t\toutline: 5px auto -webkit-focus-ring-color;\n\t\t\t\toutline-offset: -2px\n\t\t\t}\n\n\t\t\t.wf-btn:hover,\n\t\t\t.wf-btn:focus,\n\t\t\t.wf-btn.wf-focus {\n\t\t\t\tcolor: #00709e;\n\t\t\t\ttext-decoration: none\n\t\t\t}\n\n\t\t\t.wf-btn:active,\n\t\t\t.wf-btn.wf-active {\n\t\t\t\toutline: 0;\n\t\t\t\tbackground-image: none;\n\t\t\t\t-webkit-box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125);\n\t\t\t\tbox-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125)\n\t\t\t}\n\n\t\t\t.wf-btn.wf-disabled,\n\t\t\t.wf-btn[disabled],\n\t\t\t.wf-btn[readonly],\n\t\t\tfieldset[disabled] .wf-btn {\n\t\t\t\tcursor: not-allowed;\n\t\t\t\t-webkit-box-shadow: none;\n\t\t\t\tbox-shadow: none\n\t\t\t}\n\n\t\t\ta.wf-btn {\n\t\t\t\ttext-decoration: none\n\t\t\t}\n\n\t\t\ta.wf-btn.wf-disabled,\n\t\t\tfieldset[disabled] a.wf-btn {\n\t\t\t\tcursor: not-allowed;\n\t\t\t\tpointer-events: none\n\t\t\t}\n\n\t\t\t.wf-btn-default {\n\t\t\t\tcolor: #00709e;\n\t\t\t\tbackground-color: #fff;\n\t\t\t\tborder-color: #00709e\n\t\t\t}\n\n\t\t\t.wf-btn-default:focus,\n\t\t\t.wf-btn-default.focus {\n\t\t\t\tcolor: #00709e;\n\t\t\t\tbackground-color: #e6e6e6;\n\t\t\t\tborder-color: #00161f\n\t\t\t}\n\n\t\t\t.wf-btn-default:hover {\n\t\t\t\tcolor: #00709e;\n\t\t\t\tbackground-color: #e6e6e6;\n\t\t\t\tborder-color: #004561\n\t\t\t}\n\n\t\t\t.wf-btn-default:active,\n\t\t\t.wf-btn-default.active {\n\t\t\t\tcolor: #00709e;\n\t\t\t\tbackground-color: #e6e6e6;\n\t\t\t\tborder-color: #004561\n\t\t\t}\n\n\t\t\t.wf-btn-default:active:hover,\n\t\t\t.wf-btn-default:active:focus,\n\t\t\t.wf-btn-default:active.focus,\n\t\t\t.wf-btn-default.active:hover,\n\t\t\t.wf-btn-default.active:focus,\n\t\t\t.wf-btn-default.active.focus {\n\t\t\t\tcolor: #00709e;\n\t\t\t\tbackground-color: #d4d4d4;\n\t\t\t\tborder-color: #00161f\n\t\t\t}\n\n\t\t\t.wf-btn-default:active,\n\t\t\t.wf-btn-default.wf-active {\n\t\t\t\tbackground-image: none\n\t\t\t}\n\n\t\t\t.wf-btn-default.wf-disabled,\n\t\t\t.wf-btn-default[disabled],\n\t\t\t.wf-btn-default[readonly],\n\t\t\tfieldset[disabled] .wf-btn-default {\n\t\t\t\tcolor: #777;\n\t\t\t\tbackground-color: #fff;\n\t\t\t\tborder-color: #e2e2e2;\n\t\t\t\tcursor: not-allowed\n\t\t\t}\n\n\t\t\t.wf-btn-default.wf-disabled:hover,\n\t\t\t.wf-btn-default.wf-disabled:focus,\n\t\t\t.wf-btn-default.wf-disabled.wf-focus,\n\t\t\t.wf-btn-default[disabled]:hover,\n\t\t\t.wf-btn-default[disabled]:focus,\n\t\t\t.wf-btn-default[disabled].wf-focus,\n\t\t\t.wf-btn-default[readonly]:hover,\n\t\t\t.wf-btn-default[readonly]:focus,\n\t\t\t.wf-btn-default[readonly].wf-focus,\n\t\t\tfieldset[disabled] .wf-btn-default:hover,\n\t\t\tfieldset[disabled] .wf-btn-default:focus,\n\t\t\tfieldset[disabled] .wf-btn-default.wf-focus {\n\t\t\t\tbackground-color: #fff;\n\t\t\t\tborder-color: #00709e\n\t\t\t}\n\n\t\t\tinput[type=\"text\"], input.wf-input-text {\n\t\t\t\ttext-align: left;\n\t\t\t\tmax-width: 200px;\n\t\t\t\theight: 30px;\n\t\t\t\tborder-radius: 0;\n\t\t\t\tborder: 0;\n\t\t\t\tbackground-color: #ffffff;\n\t\t\t\tbox-shadow: 0px 0px 0px 1px rgba(215,215,215,0.65);\n\t\t\t\tpadding: 0.25rem;\n\t\t\t}\n\n\t\t\thr {\n\t\t\t\tmargin-top: 1rem;\n\t\t\t\tmargin-bottom: 1rem;\n\t\t\t\tborder: 0;\n\t\t\t\tborder-top: 4px solid #eee\n\t\t\t}\n\n\t\t\tp {\n\t\t\t\tfont-size: 1.4rem;\n\t\t\t\tfont-weight: 300;\n\t\t\t}\n\n\t\t\tp.medium, div.medium p {\n\t\t\t\tfont-size: 1.1rem;\n\t\t\t}\n\n\t\t\tp.small, div.small p {\n\t\t\t\tfont-size: 1rem;\n\t\t\t}\n\n\t\t\t.container {\n\t\t\t\tmax-width: 900px;\n\t\t\t\tpadding: 0 1rem;\n\t\t\t\tmargin: 0 auto;\n\t\t\t}\n\n\t\t\t.top-accent {\n\t\t\t\theight: 25px;\n\t\t\t\tbackground-color: #00709e;\n\t\t\t}\n\n\t\t\t.block-data {\n\t\t\t\twidth: 100%;\n\t\t\t\tborder-top: 6px solid #00709e;\n\t\t\t}\n\n\t\t\t.block-data tr:nth-child(odd) th, .block-data tr:nth-child(odd) td {\n\t\t\t\tbackground-color: #eeeeee;\n\t\t\t}\n\n\t\t\t.block-data th, .block-data td {\n\t\t\t\ttext-align: left;\n\t\t\t\tpadding: 1rem;\n\t\t\t\tfont-size: 1.1rem;\n\t\t\t}\n\n\t\t\t.block-data th.reason, .block-data td.reason {\n\t\t\t\tcolor: #930000;\n\t\t\t}\n\n\t\t\t.block-data th {\n\t\t\t\tfont-weight: 300;\n\t\t\t}\n\n\t\t\t.block-data td {\n\t\t\t\tfont-weight: 500;\n\t\t\t}\n\n\t\t\t.about {\n\t\t\t\tmargin-top: 2rem;\n\t\t\t\tdisplay: flex;\n\t\t\t\tflex-direction: row;\n\t\t\t\talign-items: stretch;\n\t\t\t}\n\n\t\t\t.about .badge {\n\t\t\t\tflex-basis: 116px;\n\t\t\t\tflex-grow: 0;\n\t\t\t\tflex-shrink: 0;\n\t\t\t\tdisplay: flex;\n\t\t\t\talign-items: center;\n\t\t\t\tjustify-content: flex-start;\n\t\t\t}\n\n\t\t\t.about svg {\n\t\t\t\twidth: 100px;\n\t\t\t\theight: 100px;\n\n\t\t\t}\n\n\t\t\t.about-text {\n\t\t\t\tbackground-color: #00709e;\n\t\t\t\tcolor: #ffffff;\n\t\t\t\tpadding: 1rem;\n\t\t\t}\n\n\t\t\t.about-text .h4 {\n\t\t\t\tfont-weight: 500;\n\t\t\t\tmargin-top: 0;\n\t\t\t\tmargin-bottom: 0.25rem;\n\t\t\t\tfont-size: 0.875rem;\n\t\t\t}\n\n\t\t\t.about-text p {\n\t\t\t\tfont-size: 0.875rem;\n\t\t\t\tfont-weight: 200;\n\t\t\t\tmargin-top: 0.3rem;\n\t\t\t\tmargin-bottom: 0.3rem;\n\t\t\t}\n\n\t\t\t.about-text p:first-of-type {\n\t\t\t\tmargin-top: 0;\n\t\t\t}\n\n\t\t\t.about-text p:last-of-type {\n\t\t\t\tmargin-bottom: 0;\n\t\t\t}\n\n\t\t\t.st0{fill:#00709e;}\n\t\t\t.st1{fill:#FFFFFF;}\n\n\t\t\t.generated {\n\t\t\t\tcolor: #999999;\n\t\t\t\tmargin-top: 2rem;\n\t\t\t}\n\n\t\t\t\/* Text meant only for screen readers. *\/\n\t\t\t.screen-reader-text {\n\t\t\t  border: 0;\n\t\t\t  clip: rect(1px, 1px, 1px, 1px);\n\t\t\t  clip-path: inset(50%);\n\t\t\t  height: 1px;\n\t\t\t  margin: -1px;\n\t\t\t  overflow: hidden;\n\t\t\t  padding: 0;\n\t\t\t  position: absolute;\n\t\t\t  width: 1px;\n\t\t\t  word-wrap: normal !important;\n\t\t\t}\n\t\t\t.screen-reader-text:focus {\n\t\t\t  background-color: #eee;\n\t\t\t  clip: auto !important;\n\t\t\t  clip-path: none;\n\t\t\t  color: #444;\n\t\t\t  display: block;\n\t\t\t  font-size: 1em;\n\t\t\t  height: auto;\n\t\t\t  left: 5px;\n\t\t\t  line-height: normal;\n\t\t\t  padding: 15px 23px 14px;\n\t\t\t  text-decoration: none;\n\t\t\t  top: 5px;\n\t\t\t  width: auto;\n\t\t\t  z-index: 100000; \/* Above WP toolbar. *\/\n\t\t\t}\n\t\t<\/style>\n\t<\/head>\n\t<body>\n\t<div class=\"top-accent\"><\/div>\n\t<div class=\"container\">\n\t\t<h1><?php wfI18n::esc_html_e('Your access to this site has been limited by the site owner', 'wordfence'); ?><\/h1>\n\t\t<p><?php wfI18n::esc_html_e('Your access to this service has been limited. (HTTP response code 503)', 'wordfence'); ?><\/p>\n\t\t<p><?php wfI18n::esc_html_e('If you think you have been blocked in error, contact the owner of this site for assistance.', 'wordfence'); ?><\/p>\n\t\t<?php if (!empty($customText)): ?>\n\t\t\t<hr>\n\t\t\t<div class=\"medium\"><?php echo $customText; ?><\/div>\n\t\t<?php endif; ?>\n\t\t<hr>\n\t\t<?php require(dirname(__FILE__) . '\/wfUnlockMsg.php'); ?>\n\n\t\t<h2 class=\"h3\"><?php wfI18n::esc_html_e('Block Technical Data', 'wordfence') ?><\/h2>\n\t\t<table border=\"0\" cellspacing=\"0\" cellpadding=\"0\" class=\"block-data\">\n\t\t\t<tr>\n\t\t\t\t<th class=\"reason\"><?php wfI18n::esc_html_e('Block Reason', 'wordfence'); ?>:<\/th>\n\t\t\t\t<td class=\"reason\"><?php echo htmlspecialchars($reason); ?><\/td>\n\t\t\t<\/tr>\n\t\t\t<tr>\n\t\t\t\t<th class=\"time\"><?php wfI18n::esc_html_e('Time', 'wordfence'); ?>:<\/th>\n\t\t\t\t<td class=\"time\"><?php echo htmlspecialchars(gmdate('D, j M Y G:i:s T', wfWAFUtils::normalizedTime())); ?><\/td>\n\t\t\t<\/tr>\n\t\t<\/table>\n\n\t\t<div class=\"about\">\n\t\t\t<div class=\"badge\">\n\t\t\t\t<?php\n\t\t\t\t$contents = file_get_contents(WORDFENCE_PATH . '\/images\/wf-error-badge.svg');\n\t\t\t\t$contents = preg_replace('\/^<\\?xml.+?\\?>\\s*\/i', '', $contents);\n\t\t\t\t$contents = preg_replace('\/^<!DOCTYPE.+?>\\s*\/i', '', $contents);\n\t\t\t\t$contents = preg_replace('\/<svg\\s+xmlns=\"[^\"]*\"\/i', '<svg', $contents);\n\t\t\t\techo $contents;\n\t\t\t\t?>\n\t\t\t<\/div>\n\t\t\t<div class=\"about-text\">\n\t\t\t\t<h3 class=\"h4\"><?php wfI18n::esc_html_e('About Wordfence', 'wordfence'); ?><\/h3>\n\t\t\t\t<p><?php wfI18n::esc_html_e('Wordfence is a security plugin installed on over 5 million WordPress sites. The owner of this site is using Wordfence to manage access to their site.', 'wordfence'); ?><\/p>\n\t\t\t\t<p><?php wfI18n::esc_html_e('You can also read the documentation to learn about Wordfence\\'s blocking tools, or visit wordfence.com to learn more about Wordfence.', 'wordfence'); ?><\/p>\n\t\t\t<\/div>\n\t\t<\/div>\n\n\t\t<p class=\"documentation small\"><?php echo wp_kses(sprintf(wfI18n::__('Click here to learn more: <a href=\"%s\" target=\"_blank\" rel=\"noopener noreferrer\">Documentation<span class=\"screen-reader-text\"> (' . wfI18n::esc_html__('opens in new tab', 'wordfence') . ')<\/span><\/a>', 'wordfence'), wfSupportController::esc_supportURL(wfSupportController::ITEM_LOCKED_OUT)), array('a'=>array('href'=>array(), 'target'=>array(), 'rel'=>array()), 'span'=>array('class'=>array()))); ?><\/p>\n\t\t<p class=\"generated small\"><em><?php echo wp_kses(sprintf(wfI18n::__('Generated by Wordfence at %s', 'wordfence'), gmdate('D, j M Y G:i:s T', wfWAFUtils::normalizedTime())), array('a'=>array('href'=>array(), 'target'=>array(), 'rel'=>array()))); ?>.<br><?php wfI18n::esc_html_e('Your computer\\'s time:', 'wordfence'); ?> <script type=\"application\/javascript\">document.write(new Date().toUTCString());<\/script>.<\/em><\/p>\n\t<\/div>\n\t<\/body>\n<\/html>"},{"base":"plugins","rel":"wordfence\/lib\/wfCommonPasswords.php","ext":"php","size":1282,"mtime":1757312769,"type":"text","content":"<?php\n\nclass wfCommonPasswords {\n\n\tconst BASE_LIST = [\n\t\t\"password\",\n\t\t\"1234567890\",\n\t\t\"123456789\",\n\t\t\"12345678\",\n\t\t\"1234567\",\n\t\t\"123456\",\n\t\t\"12345\",\n\t\t\"1234\",\n\t\t\"123\",\n\t\t\"12\",\n\t\t\"1\"\n\t];\n\n\tconst EXTENDED_LIST = [\n\t\t\"Password\",\n\t\t\"passwd\",\n\t\t\"admin\",\n\t\t\"administrator\",\n\t\t\"super\",\n\t\t\"superuser\",\n\t\t\"supervisor\",\n\t\t\"root\",\n\t\t\"manager\",\n\t\t\"mgr\",\n\t\t\"abc123\",\n\t\t\"qwerty\",\n\t\t\"asdf\",\n\t\t\"zxcv\",\n\t\t\"9876543210\",\n\t\t\"876543210\",\n\t\t\"76543210\",\n\t\t\"6543210\",\n\t\t\"543210\",\n\t\t\"43210\",\n\t\t\"3210\",\n\t\t\"210\",\n\t\t\"10\",\n\t\t\"0\",\n\t\t\"1\",\n\t\t\"11\",\n\t\t\"111\",\n\t\t\"1111\",\n\t\t\"11111\",\n\t\t\"2\",\n\t\t\"22\",\n\t\t\"222\",\n\t\t\"2222\",\n\t\t\"22222\",\n\t\t\"3\",\n\t\t\"33\",\n\t\t\"333\",\n\t\t\"3333\",\n\t\t\"33333\",\n\t\t\"4\",\n\t\t\"44\",\n\t\t\"444\",\n\t\t\"4444\",\n\t\t\"44444\",\n\t\t\"5\",\n\t\t\"55\",\n\t\t\"555\",\n\t\t\"5555\",\n\t\t\"55555\",\n\t\t\"6\",\n\t\t\"66\",\n\t\t\"666\",\n\t\t\"6666\",\n\t\t\"66666\",\n\t\t\"7\",\n\t\t\"77\",\n\t\t\"777\",\n\t\t\"7777\",\n\t\t\"77777\",\n\t\t\"8\",\n\t\t\"88\",\n\t\t\"888\",\n\t\t\"8888\",\n\t\t\"88888\",\n\t\t\"9\",\n\t\t\"99\",\n\t\t\"999\",\n\t\t\"9999\",\n\t\t\"99999\",\n\t\t\"0\",\n\t\t\"00\",\n\t\t\"000\",\n\t\t\"0000\",\n\t\t\"00000\"\n\t];\n\n\tpublic static function getList($extended = false) {\n\t\t$list = self::BASE_LIST;\n\t\tif ($extended)\n\t\t\t$list = array_merge($list, self::EXTENDED_LIST);\n\t\treturn $list;\n\t}\n\n\tpublic static function addToKeyedList(&$list, $extended = false) {\n\t\tforeach (self::getList($extended) as $password) {\n\t\t\t$list[$password] = true;\n\t\t}\n\t}\n\n}"},{"base":"plugins","rel":"wordfence\/lib\/wfLicense.php","ext":"php","size":10800,"mtime":1757312769,"type":"text","content":"<?php\n\nrequire_once __DIR__ . '\/wfWebsite.php';\n\nclass wfLicense {\n\n\tconst TYPE_FREE = 'free';\n\tconst TYPE_PREMIUM = 'premium';\n\tconst TYPE_CARE = 'care';\n\tconst TYPE_RESPONSE = 'response';\n\n\tconst KEY_TYPE_FREE = 'free';\n\tconst KEY_TYPE_PAID_CURRENT = 'paid-current';\n\tconst KEY_TYPE_PAID_EXPIRED = 'paid-expired';\n\tconst KEY_TYPE_PAID_DELETED = 'paid-deleted';\n\n\tconst CONFIG_API_KEY = 'apiKey';\n\tconst CONFIG_REMAINING_DAYS = 'keyExpDays';\n\tconst CONFIG_PAID = 'isPaid';\n\tconst CONFIG_KEY_TYPE = 'keyType';\n\tconst CONFIG_HAS_KEY_CONFLICT = 'hasKeyConflict';\n\tconst CONFIG_TYPE = 'licenseType';\n\n\tconst REGISTRATION_PAYLOAD_VERSION = 1;\n\n\tprivate static $TYPES = array(\n\t\tself::TYPE_FREE,\n\t\tself::TYPE_PREMIUM,\n\t\tself::TYPE_CARE,\n\t\tself::TYPE_RESPONSE\n\t);\n\n\tprivate static $reflectionClass = null;\n\tprivate static $current = null;\n\n\tprivate $apiKey;\n\tprivate $paid;\n\tprivate $type;\n\tprivate $remainingDays;\n\tprivate $conflicting;\n\tprivate $deleted;\n\tprivate $keyType;\n\n\t\/**\n\t * @param string $apiKey\n\t * @param bool $paid whether or not this is a paid license\n\t * @param ?string $type the license type (@see self::$TYPES)\n\t * @param int $remainingDays the number of days remaining before the license expires\n\t *\t(may be negative if already expired)\n\t * @param bool $conflicting whether or not there is a conflict with this license\n\t * @param bool $deleted whether or not the key was deleted\n\t *\/\n\tprivate function __construct($apiKey = null, $paid = null, $type = null, $remainingDays = null, $conflicting = false, $deleted = false, $keyType = null) {\n\t\t$this->apiKey = $apiKey;\n\t\t$this->paid = $paid;\n\t\t$this->setType($type);\n\t\t$this->remainingDays = $remainingDays;\n\t\t$this->conflicting = $conflicting;\n\t\t$this->deleted = $deleted;\n\t\t$this->keyType = $keyType;\n\t}\n\n\tpublic function setApiKey($apiKey) {\n\t\t$this->apiKey = $apiKey;\n\t\treturn $this;\n\t}\n\n\tpublic function getApiKey() {\n\t\treturn $this->apiKey;\n\t}\n\n\tpublic function setPaid($paid) {\n\t\t$this->paid = $paid;\n\t\treturn $this;\n\t}\n\n\tpublic function isPaid() {\n\t\treturn $this->paid;\n\t}\n\n\tpublic function setType($type) {\n\t\t$this->type = $type !== null && self::isValidType($type) ? (string) $type : ($this->isPaid() ? self::TYPE_PREMIUM : self::TYPE_FREE);\n\t\treturn $this;\n\t}\n\n\tpublic function getType() {\n\t\treturn $this->type === null ? self::TYPE_FREE : $this->type;\n\t}\n\n\tpublic function is($type, $orGreater = false) {\n\t\treturn $this->type === $type || ($orGreater && $this->isAtLeast($type));\n\t}\n\n\tpublic function setRemainingDays($days) {\n\t\t$this->remainingDays = (int) $days;\n\t\treturn $this;\n\t}\n\n\tpublic function getRemainingDays() {\n\t\treturn $this->remainingDays;\n\t}\n\n\tpublic function setConflicting($conflicting = true) {\n\t\t$this->conflicting = $conflicting;\n\t\treturn $this;\n\t}\n\n\tpublic function hasConflict() {\n\t\treturn $this->conflicting;\n\t}\n\n\tpublic function setDeleted($deleted = true) {\n\t\t$this->deleted = $deleted;\n\t\treturn $this;\n\t}\n\n\tpublic function isExpired() {\n\t\treturn $this->getKeyType() === self::KEY_TYPE_PAID_EXPIRED;\n\t}\n\n\tpublic function isValid() {\n\t\treturn !$this->isExpired();\n\t}\n\n\tpublic function isPaidAndCurrent() {\n\t\treturn $this->getKeyType() === self::KEY_TYPE_PAID_CURRENT;\n\t}\n\n\tprivate function resolveKeyType() {\n\t\tif ($this->deleted)\n\t\t\treturn self::KEY_TYPE_PAID_DELETED;\n\t\tif ($this->paid) {\n\t\t\tif ($this->remainingDays >= 0)\n\t\t\t\treturn self::KEY_TYPE_PAID_CURRENT;\n\t\t\telse \n\t\t\t\treturn self::KEY_TYPE_PAID_EXPIRED;\n\t\t}\n\t\treturn self::KEY_TYPE_FREE;\n\t}\n\n\tpublic function getKeyType() {\n\t\tif (!$this->keyType)\n\t\t\t$this->keyType = $this->resolveKeyType();\n\t\treturn $this->keyType;\n\t}\n\n\tprivate function clearCache() {\n\t\t$this->keyType = null;\n\t}\n\n\tprivate function compareTiers($a, $b, $inclusive = true) {\n\t\tif ($a === $b)\n\t\t\treturn $inclusive;\n\t\tforeach (self::$TYPES as $tier) {\n\t\t\tif ($tier === $a)\n\t\t\t\treturn true;\n\t\t\tif ($tier === $b)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn false;\n\t}\n\n\t\/**\n\t * Check if the license type is at or above the given tier\n\t *\/\n\tpublic function isAtLeast($type) {\n\t\tif ($type !== self::TYPE_FREE && !$this->isValid())\n\t\t\treturn false;\n\t\treturn $this->compareTiers($type, $this->getType());\n\t}\n\n\tpublic function isBelow($type) {\n\t\tif ($type !== self::TYPE_FREE && !$this->isValid())\n\t\t\treturn true;\n\t\treturn $this->compareTiers($this->getType(), $type, false);\n\t}\n\n\tpublic function isPremium($orGreater = false) {\n\t\treturn $this->is(self::TYPE_PREMIUM, $orGreater);\n\t}\n\n\tpublic function isAtLeastPremium() {\n\t\treturn $this->isPremium(true);\n\t}\n\n\tpublic function isBelowPremium() {\n\t\treturn $this->isBelow(self::TYPE_PREMIUM);\n\t}\n\n\tpublic function isCare($orGreater = false) {\n\t\treturn $this->is(self::TYPE_CARE, $orGreater);\n\t}\n\n\tpublic function isAtLeastCare() {\n\t\treturn $this->isCare(true);\n\t}\n\n\tpublic function isBelowCare() {\n\t\treturn $this->isBelow(self::TYPE_CARE);\n\t}\n\n\tpublic function isResponse($orGreater = false) {\n\t\treturn $this->is(self::TYPE_RESPONSE, $orGreater);\n\t}\n\n\tpublic function isAtLeastResponse() {\n\t\treturn $this->isResponse(true);\n\t}\n\n\tpublic function isBelowResponse() {\n\t\treturn $this->isBelow(self::TYPE_RESPONSE);\n\t}\n\n\tpublic function getShieldLogo() {\n\t\t$type = $this->getType();\n\t\treturn wfUtils::getBaseURL() . \"images\/logos\/shield-{$type}.svg\";\n\t}\n\n\tpublic function getStylesheet($global = false) {\n\t\t$type = $this->getType();\n\t\t$suffix = $global ? '-global' : '';\n\t\treturn wfUtils::getBaseURL() . wfUtils::versionedAsset(\"css\/license\/{$type}{$suffix}.css\", '', WORDFENCE_VERSION);\n\t}\n\n\tpublic function getGlobalStylesheet() {\n\t\treturn $this->getStylesheet(true);\n\t}\n\n\tpublic function getTypeLabel($requireCurrent = true, $includePrefix = null) {\n\t\t$paidKeyTypes = array(self::KEY_TYPE_PAID_CURRENT);\n\t\tif (!$requireCurrent) {\n\t\t\t$paidKeyTypes[] = self::KEY_TYPE_PAID_EXPIRED;\n\t\t\t$paidKeyTypes[] = self::KEY_TYPE_PAID_DELETED;\n\t\t}\n\t\tif (in_array($this->getKeyType(), $paidKeyTypes)) {\n\t\t\tswitch ($this->type) {\n\t\t\tcase self::TYPE_CARE:\n\t\t\t\treturn $includePrefix || $includePrefix === null ? __('Wordfence Care', 'wordfence') : __('Care', 'wordfence');\n\t\t\tcase self::TYPE_RESPONSE:\n\t\t\t\treturn $includePrefix || $includePrefix === null ? __('Wordfence Response', 'wordfence') : __('Response', 'wordfence');\n\t\t\tcase self::TYPE_PREMIUM:\n\t\t\tdefault:\n\t\t\t\treturn $includePrefix ? __('Wordfence Premium', 'wordfence') : __('Premium', 'wordfence');\n\t\t\t}\n\t\t}\n\t\treturn $includePrefix ? __('Wordfence Free', 'wordfence') : __('Free', 'wordfence');\n\t}\n\n\tpublic function getBaseTypeLabel($requireCurrent = true) {\n\t\treturn $this->getTypeLabel($requireCurrent, false);\n\t}\n\n\tpublic function getPrefixedTypeLabel($requireCurrent = true) {\n\t\treturn $this->getTypeLabel($requireCurrent, true);\n\t}\n\n\tprivate function generateLicenseUrl($path, $query = array(), $campaign = null) {\n\t\tif ($campaign !== null)\n\t\t\t$campaign = \"gnl1{$campaign}\";\n\t\t$url = implode(\n\t\t\t'\/',\n\t\t\tarray_filter(array(\n\t\t\t\t'https:\/\/www.wordfence.com',\n\t\t\t\t$campaign,\n\t\t\t\t$path\n\t\t\t))\n\t\t);\n\t\treturn $url . (empty($query) ? '' : ('?' . http_build_query($query)));\n\t}\n\n\tpublic function getSupportUrl($campaign = null) {\n\t\treturn $this->generateLicenseUrl(\n\t\t\t'get-help',\n\t\t\tarray(\n\t\t\t\t'license' => $this->apiKey\n\t\t\t),\n\t\t\t$campaign\n\t\t);\n\t}\n\n\tpublic function getUpgradeUrl($campaign = null) {\n\t\tif ($this->isAtLeastPremium()) {\n\t\t\treturn $this->generateLicenseUrl(\n\t\t\t\t'licenses',\n\t\t\t\tarray(\n\t\t\t\t\t'upgrade' => $this->apiKey\n\t\t\t\t),\n\t\t\t\t$campaign\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn $this->generateLicenseUrl(\n\t\t\t\t'products\/pricing\/',\n\t\t\t\tarray(),\n\t\t\t\t$campaign\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate function writeConfig($hasError = false) {\n\t\t$this->clearCache();\n\t\t$keyType = $this->getKeyType();\n\t\twfConfig::set(self::CONFIG_API_KEY, $this->apiKey);\n\t\twfConfig::set(self::CONFIG_TYPE, $this->type);\n\t\twfConfig::set(self::CONFIG_REMAINING_DAYS, $this->remainingDays);\n\t\twfConfig::set(self::CONFIG_PAID, $keyType === self::KEY_TYPE_PAID_CURRENT);\n\t\twfConfig::setOrRemove(self::CONFIG_HAS_KEY_CONFLICT, $this->conflicting ? 1 : null);\n\t\tif (!$hasError) { \/\/Only save a limited subset of the config if an API error occurred\n\t\t\twfConfig::set(self::CONFIG_KEY_TYPE, $keyType);\n\t\t}\n\t}\n\n\t\/**\n\t * @param bool $hasError whether or not an error occurred while retrieving the current license data\n\t *\/\n\tpublic function save($hasError = false) {\n\t\t$this->writeConfig($hasError);\n\t}\n\n\tpublic function downgradeToFree($apiKey) {\n\t\t$this->apiKey = $apiKey;\n\t\t$this->type = self::TYPE_FREE;\n\t\t$this->paid = false;\n\t\t$this->keyType = self::KEY_TYPE_FREE;\n\t\t$this->conflicting = false;\n\t\t$this->deleted = false;\n\t\t$this->remainingDays = -1;\n\t\treturn $this;\n\t}\n\n\tpublic static function isValidType($type) {\n\t\treturn in_array($type, self::$TYPES);\n\t}\n\n\tprivate static function fromConfig() {\n\t\t$remainingDays = wfConfig::get(self::CONFIG_REMAINING_DAYS, null);\n\t\tif ($remainingDays !== null)\n\t\t\t$remainingDays = (int) $remainingDays;\n\t\t$keyType = wfConfig::get(self::CONFIG_KEY_TYPE, null);\n\t\treturn new self(\n\t\t\t(string) wfConfig::get(self::CONFIG_API_KEY),\n\t\t\t(bool) wfConfig::get(self::CONFIG_PAID),\n\t\t\t(string) wfConfig::get(self::CONFIG_TYPE, self::TYPE_FREE),\n\t\t\t$remainingDays,\n\t\t\t(bool) wfConfig::get(self::CONFIG_HAS_KEY_CONFLICT, false),\n\t\t\t$keyType === self::KEY_TYPE_PAID_DELETED,\n\t\t\t$keyType\n\t\t);\n\t}\n\n\tpublic static function current() {\n\t\tif (self::$current === null) {\n\t\t\tself::$current = self::fromConfig();\n\t\t}\n\t\treturn self::$current;\n\t}\n\n\tconst REGISTRATION_TOKEN_TTL = 86400; \/\/24 hours\n\tconst REGISTRATION_TOKEN_KEY = 'wfRegistrationToken';\n\tconst REGISTRATION_TOKEN_LENGTH = 32;\n\n\tpublic static function getRegistrationToken($refreshTtl = false) {\n\t\t$token = get_transient(self::REGISTRATION_TOKEN_KEY);\n\t\tif ($token === false) {\n\t\t\t$token = openssl_random_pseudo_bytes(self::REGISTRATION_TOKEN_LENGTH);\n\t\t\tif ($token === false)\n\t\t\t\tthrow new Exception('Unable to generate registration token');\n\t\t\t$token = wfUtils::base64url_encode($token);\n\t\t\t$refreshTtl = true;\n\t\t}\n\t\tif ($refreshTtl)\n\t\t\tset_transient(self::REGISTRATION_TOKEN_KEY, $token, self::REGISTRATION_TOKEN_TTL);\n\t\treturn $token;\n\t}\n\n\tpublic static function validateRegistrationToken($token) {\n\t\t$expected = self::getRegistrationToken();\n\t\t\/\/Note that the length of $expected is publicly known since it's in the plugin source, so differening lengths immediately triggering a false return is not a cause for concern\n\t\treturn hash_equals($expected, $token);\n\t}\n\n\tpublic static function generateRegistrationLink() {\n\t\t$wfWebsite = wfWebsite::getInstance();\n\t\t$stats = wfAPI::generateSiteStats();\n\t\t$token = self::getRegistrationToken(true);\n\t\t$returnUrl = network_admin_url('admin.php?page=WordfenceInstall');\n\t\t$payload = array(\n\t\t\tself::REGISTRATION_PAYLOAD_VERSION,\n\t\t\t$stats,\n\t\t\t$token,\n\t\t\t$returnUrl,\n\t\t);\n\t\t$payload = implode(';', $payload);\n\t\t$payload = wfUtils::base64url_encode($payload);\n\t\treturn $wfWebsite->getUrl(\"plugin\/registration\/{$payload}\");\n\t}\n\n}"},{"base":"plugins","rel":"wordfence\/lib\/menu_firewall_waf_options.php","ext":"php","size":11357,"mtime":1757312769,"type":"text","content":"<?php\nif (!defined('WORDFENCE_VERSION')) { exit; }\n$waf = wfWAF::getInstance();\n$d = new wfDashboard(); unset($d->countriesNetwork);\n$firewall = new wfFirewall();\n$config = $waf->getStorageEngine();\n$wafURL = wfPage::pageURL(wfPage::PAGE_FIREWALL);\n$wafConfigURL = network_admin_url('admin.php?page=WordfenceWAF&subpage=waf_options#configureAutoPrepend');\n$wafRemoveURL = network_admin_url('admin.php?page=WordfenceWAF&subpage=waf_options#removeAutoPrepend');\n\/** @var array $wafData *\/\n\n$backPage = new wfPage(wfPage::PAGE_FIREWALL);\nif (isset($_GET['source']) && wfPage::isValidPage($_GET['source'])) {\n\t$backPage = new wfPage($_GET['source']);\n}\n?>\n<script type=\"application\/javascript\">\n\t(function($) {\n\t\tWFAD.wafData = <?php echo json_encode($wafData); ?>;\n\t\tWFAD.restoreWAFData = JSON.parse(JSON.stringify(WFAD.wafData)); \/\/Copied into wafData when canceling changes\n\n\t\t$(function() {\n\t\t\tdocument.title = \"<?php esc_attr_e('Firewall Options', 'wordfence'); ?>\" + \" \\u2039 \" + WFAD.basePageName;\n\t\t\t\n\t\t\tWFAD.wafConfigPageRender();\n\n\t\t\t\/\/Hash-based option block linking\n\t\t\tif (window.location.hash) {\n\t\t\t\tvar hashes = WFAD.parseHashes();\n\t\t\t\tvar hash = hashes[hashes.length - 1];\n\t\t\t\tvar target = $(\"#\" + hash);\n\t\t\t\tvar block = target.parents('.wf-block');\n\t\t\t\tif (!block.length) {\n\t\t\t\t\tblock = $('.wf-block[data-persistence-key=\"' + hash + '\"]');\n\t\t\t\t\ttarget = block;\n\t\t\t\t}\n\t\t\t\tif (block.length) {\n\t\t\t\t\tif (!block.hasClass('wf-active')) {\n\t\t\t\t\t\tblock.find('.wf-block-content').slideDown({\n\t\t\t\t\t\t\talways: function() {\n\t\t\t\t\t\t\t\tblock.addClass('wf-active');\n\t\t\t\t\t\t\t\t$('html, body').animate({\n\t\t\t\t\t\t\t\t\tscrollTop: target.offset().top - 100\n\t\t\t\t\t\t\t\t}, 1000);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tWFAD.ajax('wordfence_saveDisclosureState', {name: block.data('persistenceKey'), state: true}, function() {});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t$('html, body').animate({\n\t\t\t\t\t\t\tscrollTop: target.offset().top - 100\n\t\t\t\t\t\t}, 1000);\n\t\t\t\t\t}\n\n\t\t\t\t\thistory.replaceState('', document.title, window.location.pathname + window.location.search);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar updatePendingCircles = function() {\n\t\t\t\t$('#circle-waf-coverage, #circle-waf-rules, #circle-waf-blacklist, #circle-waf-brute').wfCircularProgress({pendingOverlay: Object.keys(WFAD.pendingChanges).length > 0});\n\t\t\t};\n\t\t\tvar coalescingUpdateTimer = false;\n\n\t\t\t$('.wf-option, .wf-rule-toggle').on('change', function() {\n\t\t\t\tclearTimeout(coalescingUpdateTimer);\n\t\t\t\tcoalescingUpdateTimer = setTimeout(updatePendingCircles, 100);\n\t\t\t});\n\t\t});\n\n\t\t$(window).on('wfOptionsReset', function() {\n\t\t\tWFAD.wafData = JSON.parse(JSON.stringify(WFAD.restoreWAFData));\n\t\t\tWFAD.wafConfigPageRender();\n\t\t});\n\t})(jQuery);\n<\/script>\n<div class=\"wf-options-controls\">\n\t<div class=\"wf-row\">\n\t\t<div class=\"wf-col-xs-12\">\n\t\t\t<?php\n\t\t\techo wfView::create('options\/block-controls', array(\n\t\t\t\t'backLink' => $backPage->url(),\n\t\t\t\t'backLabelHTML' => wp_kses(sprintf(__('<span class=\"wf-hidden-xs\">Back to <\/span>%s', 'wordfence'), $backPage->label()), array('span'=>array('class'=>array()))),\n\t\t\t\t'restoreDefaultsSection' => wfConfig::OPTIONS_TYPE_FIREWALL,\n\t\t\t\t'restoreDefaultsMessage' => __('Are you sure you want to restore the default Firewall settings? This will undo any custom changes you have made to the options on this page. If you have manually disabled any rules or added any custom allowlisted URLs, those changes will not be overwritten.', 'wordfence'),\n\t\t\t))->render();\n\t\t\t?>\n\t\t<\/div>\n\t<\/div>\n<\/div>\n<div class=\"wf-options-controls-spacer\"><\/div>\n<?php\nif (!wfOnboardingController::shouldShowAttempt3() && wfConfig::get('touppPromptNeeded')) {\n\techo wfView::create('gdpr\/disabled-overlay')->render();\n\techo wfView::create('gdpr\/banner')->render();\n}\n?>\n<div class=\"wrap wordfence\">\n\t<div class=\"wf-container-fluid\">\n\t\t<?php\n\t\tif (function_exists('network_admin_url') && is_multisite()) {\n\t\t\t$firewallURL = network_admin_url('admin.php?page=WordfenceWAF#top#waf');\n\t\t\t$blockingURL = network_admin_url('admin.php?page=WordfenceWAF#top#blocking');\n\t\t}\n\t\telse {\n\t\t\t$firewallURL = admin_url('admin.php?page=WordfenceWAF#top#waf');\n\t\t\t$blockingURL = admin_url('admin.php?page=WordfenceWAF#top#blocking');\n\t\t}\n\t\t?>\n\t\t<div class=\"wf-row\">\n\t\t\t<div class=\"wf-col-xs-12\">\n\t\t\t\t<div class=\"wp-header-end\"><\/div>\n\t\t\t\t<?php if (isset($storageExceptionMessage)): ?>\n\t\t\t\t<div class=\"notice notice-error\"><p><?php echo $storageExceptionMessage; ?><\/p><\/div>\n\t\t\t\t<?php endif; ?>\n\t\t\t<\/div>\n\t\t<\/div>\n\t\t<div class=\"wf-row\">\n\t\t\t<div class=\"<?php echo wfStyle::contentClasses(); ?>\">\n\t\t\t\t<div id=\"waf-options\" class=\"wf-fixed-tab-content\">\n\t\t\t\t\t<?php\n\t\t\t\t\techo wfView::create('common\/section-title', array(\n\t\t\t\t\t\t'title' => __('Firewall Options', 'wordfence'),\n\t\t\t\t\t\t'helpLink' => wfSupportController::supportURL(wfSupportController::ITEM_FIREWALL_WAF),\n\t\t\t\t\t\t'helpLabelHTML' => wp_kses(__('Learn more<span class=\"wf-hidden-xs\"> about the Firewall<\/span>', 'wordfence'), array('span'=>array('class'=>array()))),\n\t\t\t\t\t\t'showIcon' => true,\n\t\t\t\t\t))->render();\n\t\t\t\t\t?>\n\t\t\t\t\t<div class=\"wf-row\">\n\t\t\t\t\t\t<div class=\"wf-col-xs-12\">\n\t\t\t\t\t\t\t<div class=\"wf-block wf-active\">\n\t\t\t\t\t\t\t\t<div class=\"wf-block-content\">\n\t\t\t\t\t\t\t\t\t<ul class=\"wf-block-list wf-block-list-horizontal wf-block-list-nowrap wf-waf-coverage\">\n\t\t\t\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\t\t\tif (function_exists('network_admin_url') && is_multisite()) { $optionsURL = network_admin_url('admin.php?page=WordfenceWAF&subpage=waf_options'); }\n\t\t\t\t\t\t\t\t\t\t\telse { $optionsURL = admin_url('admin.php?page=WordfenceWAF&subpage=waf_options'); }\n\t\t\t\t\t\t\t\t\t\t\techo wfView::create('common\/status-detail', array(\n\t\t\t\t\t\t\t\t\t\t\t\t'id' => 'waf-coverage',\n\t\t\t\t\t\t\t\t\t\t\t\t'percentage' => $firewall->wafStatus(),\n\t\t\t\t\t\t\t\t\t\t\t\t'activeColor' => ($firewall->firewallMode() == wfFirewall::FIREWALL_MODE_LEARNING ? '#ececec' : null \/* automatic *\/),\n\t\t\t\t\t\t\t\t\t\t\t\t'title' => __('Web Application Firewall', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t'subtitle' => ($firewall->firewallMode() == wfFirewall::FIREWALL_MODE_LEARNING ? __('Currently in Learning Mode', 'wordfence') : __('Stops Complex Attacks', 'wordfence')),\n\t\t\t\t\t\t\t\t\t\t\t\t'link' => $optionsURL,\n\t\t\t\t\t\t\t\t\t\t\t\t'linkLabel' => null,\n\t\t\t\t\t\t\t\t\t\t\t\t'statusTitle' => __('Web Application Firewall Status', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t'statusList' => $firewall->wafStatusList(),\n\t\t\t\t\t\t\t\t\t\t\t\t'statusExtra' => ($firewall->firewallMode() == wfFirewall::FIREWALL_MODE_LEARNING ? wfView::create('waf\/status-tooltip-learning-mode')->render() : ''),\n\t\t\t\t\t\t\t\t\t\t\t\t'helpLink' => wfSupportController::supportURL(wfSupportController::ITEM_FIREWALL_WAF_STATUS_OVERALL),\n\t\t\t\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\t\t\techo wfView::create('common\/status-detail', array(\n\t\t\t\t\t\t\t\t\t\t\t\t'id' => 'waf-rules',\n\t\t\t\t\t\t\t\t\t\t\t\t'percentage' => $firewall->ruleStatus(),\n\t\t\t\t\t\t\t\t\t\t\t\t'activeColor' => ($firewall->firewallMode() == wfFirewall::FIREWALL_MODE_LEARNING ? '#ececec' : null \/* automatic *\/),\n\t\t\t\t\t\t\t\t\t\t\t\t'title' => __('Firewall Rules: ', 'wordfence') . ($firewall->ruleMode() == wfFirewall::RULE_MODE_PREMIUM ? __('Premium', 'wordfence') : __('Community', 'wordfence')),\n\t\t\t\t\t\t\t\t\t\t\t\t'subtitle' => ($firewall->firewallMode() == wfFirewall::FIREWALL_MODE_LEARNING ? __('Currently in Learning Mode', 'wordfence') : ($firewall->ruleMode() == wfFirewall::RULE_MODE_PREMIUM ? __('Rules updated in real-time', 'wordfence') : __('Rule updates delayed by 30 days', 'wordfence'))),\n\t\t\t\t\t\t\t\t\t\t\t\t'link' => 'https:\/\/www.wordfence.com\/gnl1wafUpgrade\/wordfence-signup\/',\n\t\t\t\t\t\t\t\t\t\t\t\t'linkLabel' => null,\n\t\t\t\t\t\t\t\t\t\t\t\t'linkNewWindow' => true,\n\t\t\t\t\t\t\t\t\t\t\t\t'statusTitle' => __('Firewall Rules Status', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t'statusList' => $firewall->wafStatusList('rules'),\n\t\t\t\t\t\t\t\t\t\t\t\t'statusExtra' => ($firewall->firewallMode() == wfFirewall::FIREWALL_MODE_LEARNING ? wfView::create('waf\/status-tooltip-learning-mode')->render() : ''),\n\t\t\t\t\t\t\t\t\t\t\t\t'helpLink' => wfSupportController::supportURL(wfSupportController::ITEM_FIREWALL_WAF_STATUS_RULES),\n\t\t\t\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\t\t\techo wfView::create('common\/status-detail', array(\n\t\t\t\t\t\t\t\t\t\t\t\t'id' => 'waf-blacklist',\n\t\t\t\t\t\t\t\t\t\t\t\t'percentage' => $firewall->blacklistStatus(),\n\t\t\t\t\t\t\t\t\t\t\t\t'title' => __('Real-Time IP Blocklist: ', 'wordfence') . ($firewall->blacklistMode() == wfFirewall::BLACKLIST_MODE_ENABLED ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\t\t\t\t\t\t\t\t\t\t'subtitle' => __('Blocks requests from known malicious IPs', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t'link' => (($firewall->ruleMode() == wfFirewall::RULE_MODE_PREMIUM && $firewall->blacklistMode() == wfFirewall::BLACKLIST_MODE_DISABLED) ? network_admin_url('admin.php?page=WordfenceWAF&subpage=waf_options#waf-options-advanced') : 'https:\/\/www.wordfence.com\/gnl1wafUpgrade\/wordfence-signup\/'),\n\t\t\t\t\t\t\t\t\t\t\t\t'linkLabel' => null,\n\t\t\t\t\t\t\t\t\t\t\t\t'linkNewWindow' => !($firewall->ruleMode() == wfFirewall::RULE_MODE_PREMIUM && $firewall->blacklistMode() == wfFirewall::BLACKLIST_MODE_DISABLED),\n\t\t\t\t\t\t\t\t\t\t\t\t'statusTitle' => __('Blocklist Status', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t'statusList' => $firewall->wafStatusList('blacklist'),\n\t\t\t\t\t\t\t\t\t\t\t\t'helpLink' => wfSupportController::supportURL(wfSupportController::ITEM_FIREWALL_WAF_STATUS_BLACKLIST),\n\t\t\t\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\t\t\techo wfView::create('common\/status-detail', array(\n\t\t\t\t\t\t\t\t\t\t\t\t'id' => 'waf-brute',\n\t\t\t\t\t\t\t\t\t\t\t\t'percentage' => $firewall->bruteForceStatus(),\n\t\t\t\t\t\t\t\t\t\t\t\t'title' => __('Brute Force Protection', 'wordfence') . ($firewall->bruteForceStatus() == 0 ? __(': Disabled', 'wordfence') : ''),\n\t\t\t\t\t\t\t\t\t\t\t\t'subtitle' => __('Stops Password Guessing Attacks', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t'link' => network_admin_url('admin.php?page=WordfenceWAF&subpage=waf_options#waf-options-bruteforce'),\n\t\t\t\t\t\t\t\t\t\t\t\t'linkLabel' => null,\n\t\t\t\t\t\t\t\t\t\t\t\t'statusTitle' => __('Brute Force Protection Status', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t'statusList' => $firewall->bruteForceStatusList(),\n\t\t\t\t\t\t\t\t\t\t\t\t'helpLink' => wfSupportController::supportURL(wfSupportController::ITEM_FIREWALL_WAF_STATUS_BRUTE_FORCE),\n\t\t\t\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t\t\t<\/ul>\n\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t\t<\/div>\n\t\t\t\t\t<?php\n\t\t\t\t\techo wfView::create('waf\/options-group-basic-firewall', array(\n\t\t\t\t\t\t'firewall' => $firewall,\n\t\t\t\t\t\t'waf' => $waf,\n\t\t\t\t\t\t'stateKey' => 'waf-options-basic',\n\t\t\t\t\t\t'collapseable' => false,\n\t\t\t\t\t))->render();\n\t\t\t\t\t?>\n\t\t\t\t\t<?php\n\t\t\t\t\techo wfView::create('waf\/options-group-advanced-firewall', array(\n\t\t\t\t\t\t'firewall' => $firewall,\n\t\t\t\t\t\t'waf' => $waf,\n\t\t\t\t\t\t'stateKey' => 'waf-options-advanced',\n\t\t\t\t\t))->render();\n\t\t\t\t\t?>\n\t\t\t\t\t<?php\n\t\t\t\t\techo wfView::create('waf\/options-group-brute-force', array(\n\t\t\t\t\t\t'firewall' => $firewall,\n\t\t\t\t\t\t'waf' => $waf,\n\t\t\t\t\t\t'stateKey' => 'waf-options-bruteforce',\n\t\t\t\t\t))->render();\n\t\t\t\t\t?>\n\t\t\t\t\t<?php\n\t\t\t\t\techo wfView::create('waf\/options-group-rate-limiting', array(\n\t\t\t\t\t\t'firewall' => $firewall,\n\t\t\t\t\t\t'waf' => $waf,\n\t\t\t\t\t\t'stateKey' => 'waf-options-ratelimiting',\n\t\t\t\t\t))->render();\n\t\t\t\t\t?>\n\t\t\t\t\t<?php\n\t\t\t\t\techo wfView::create('waf\/options-group-whitelisted', array(\n\t\t\t\t\t\t'firewall' => $firewall,\n\t\t\t\t\t\t'waf' => $waf,\n\t\t\t\t\t\t'stateKey' => 'waf-options-whitelisted',\n\t\t\t\t\t))->render();\n\t\t\t\t\t?>\n\t\t\t\t<\/div> <!-- end waf options block -->\n\t\t\t<\/div> <!-- end content block -->\n\t\t<\/div> <!-- end row -->\n\t<\/div> <!-- end container -->\n<\/div>"},{"base":"plugins","rel":"wordfence\/lib\/wfIpLocator.php","ext":"php","size":2810,"mtime":1757312769,"type":"text","content":"<?php\n\nrequire_once __DIR__ . '\/..\/vendor\/autoload.php';\n\nrequire_once __DIR__ . '\/wfIpLocation.php';\n\nuse Wordfence\\MmdbReader\\Database;\nuse Wordfence\\MmdbReader\\Exception\\MmdbThrowable;\n\nclass wfIpLocator {\n\n\tconst SOURCE_BUNDLED = 0;\n\tconst SOURCE_WFLOGS = 1;\n\n\tconst DATABASE_FILE_NAME = 'GeoLite2-Country.mmdb';\n\n\tprivate static $instances = array();\n\n\tprivate $database;\n\tprivate $preferred;\n\n\tprivate function __construct($database, $preferred) {\n\t\t$this->database = $database;\n\t\t$this->preferred = $preferred;\n\t}\n\n\tpublic function isPreferred() {\n\t\treturn $this->preferred;\n\t}\n\n\tprivate static function logError($message) {\n\t\tif (class_exists('wfUtils'))\n\t\t\twfUtils::check_and_log_last_error('ip_locator', 'IP Location Error:', $message, 0);\n\t}\n\n\tpublic function locate($ip) {\n\t\tif ($this->database !== null) {\n\t\t\ttry {\n\t\t\t\t$record = $this->database->search($ip);\n\t\t\t\tif ($record !== null)\n\t\t\t\t\treturn new wfIpLocation($record);\n\t\t\t}\n\t\t\tcatch (MmdbThrowable $t) {\n\t\t\t\tself::logError('Failed to locate IP address: ' . $t->getMessage());\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic function getCountryCode($ip, $default = '') {\n\t\t$record = $this->locate($ip);\n\t\tif ($record !== null)\n\t\t\treturn $record->getCountryCode();\n\t\treturn $default;\n\t}\n\n\tpublic function getDatabaseVersion() {\n\t\tif ($this->database !== null) {\n\t\t\ttry {\n\t\t\t\treturn $this->database->getMetadata()->getBuildEpoch();\n\t\t\t}\n\t\t\tcatch (MmdbThrowable $t) {\n\t\t\t\tself::logError('Failed to retrieve database version: ' . $t->getMessage());\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate static function getDatabaseDirectory($source) {\n\t\tswitch ($source) {\n\t\tcase self::SOURCE_BUNDLED:\n\t\t\treturn WFWAF_LOG_PATH;\n\t\tcase self::SOURCE_BUNDLED:\n\t\tdefault:\n\t\t\treturn __DIR__;\n\t\t}\n\t}\n\n\tprivate static function initializeDatabase($preferredSource, &$isPreferred) {\n\t\t$sources = array();\n\t\tif ($preferredSource !== self::SOURCE_BUNDLED)\n\t\t\t$sources[] = $preferredSource;\n\t\t$sources[] = self::SOURCE_BUNDLED;\n\t\t$isPreferred = true;\n\t\tforeach ($sources as $source) {\n\t\t\t$directory = self::getDatabaseDirectory($source);\n\t\t\ttry {\n\t\t\t\t$path = $directory . '\/' . self::DATABASE_FILE_NAME;\n\t\t\t\tif (file_exists($path)) \/\/Preemptive check to prevent warnings\n\t\t\t\t\treturn Database::open($path);\n\t\t\t}\n\t\t\tcatch (MmdbThrowable $t) {\n\t\t\t\tself::logError('Failed to initialize IP location database: ' . $t->getMessage());\n\t\t\t}\n\t\t\t$preferred = false;\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static function getInstance($preferredSource = null) {\n\t\tif ($preferredSource === null)\n\t\t\t$preferredSource = self::SOURCE_WFLOGS;\n\t\tif (!array_key_exists($preferredSource, self::$instances)) {\n\t\t\t$database = self::initializeDatabase($preferredSource, $isPreferred);\n\t\t\tself::$instances[$preferredSource] = new wfIpLocator($database, $isPreferred);\n\t\t}\n\t\treturn self::$instances[$preferredSource];\n\t}\n\n}"},{"base":"plugins","rel":"wordfence\/lib\/wfCache.php","ext":"php","size":6166,"mtime":1757312769,"type":"text","content":"<?php\nclass wfCache {\n\tprivate static $cacheStats = array();\n\tprivate static $cacheClearedThisRequest = false;\n\tprivate static $lastRecursiveDeleteError = false;\n\t\n\tpublic static function removeCaching() {\n\t\t$cacheType = wfConfig::get('cacheType', false);\n\t\tif ($cacheType === 'disabled') {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif ($cacheType == 'falcon') {\n\t\t\tself::addHtaccessCode('remove');\n\t\t\tself::updateBlockedIPs('remove');\n\t\t}\n\t\t\n\t\twfConfig::set('cacheType', 'disabled');\n\t\t\n\t\t$cacheDir = WP_CONTENT_DIR . '\/wfcache\/';\n\t\tif (file_exists($cacheDir . '.htaccess')) {\n\t\t\tunlink($cacheDir . '.htaccess');\n\t\t}\n\t\t\n\t\tself::clearPageCacheSafe();\n\t}\n\tpublic static function clearPageCacheSafe(){\n\t\tif(self::$cacheClearedThisRequest){ return; }\n\t\tself::$cacheClearedThisRequest = true;\n\t\tself::clearPageCache();\n\t}\n\tpublic static function clearPageCache(){ \/\/If a clear is in progress this does nothing. \n\t\tself::$cacheStats = array(\n\t\t\t'dirsDeleted' => 0,\n\t\t\t'filesDeleted' => 0,\n\t\t\t'totalData' => 0,\n\t\t\t'totalErrors' => 0,\n\t\t\t'error' => '',\n\t\t\t);\n\t\t\n\t\t$cacheDir = WP_CONTENT_DIR . '\/wfcache\/';\n\t\tif (!file_exists($cacheDir)) {\n\t\t\treturn self::$cacheStats;\n\t\t}\n\t\t\n\t\t$cacheClearLock = WP_CONTENT_DIR . '\/wfcache\/clear.lock';\n\t\tif(! is_file($cacheClearLock)){\n\t\t\tif(! touch($cacheClearLock)){\n\t\t\t\tself::$cacheStats['error'] = \"Could not create a lock file $cacheClearLock to clear the cache.\";\n\t\t\t\tself::$cacheStats['totalErrors']++;\n\t\t\t\treturn self::$cacheStats;\n\t\t\t}\n\t\t}\n\t\t$fp = fopen($cacheClearLock, 'w');\n\t\tif(! $fp){ \n\t\t\tself::$cacheStats['error'] = \"Could not open the lock file $cacheClearLock to clear the cache. Please make sure the directory is writable by your web server.\";\n\t\t\tself::$cacheStats['totalErrors']++;\n\t\t\treturn self::$cacheStats;\n\t\t}\n\t\tif(flock($fp, LOCK_EX | LOCK_NB)){ \/\/non blocking exclusive flock attempt. If we get a lock then it continues and returns true. If we don't lock, then return false, don't block and don't clear the cache. \n\t\t\t\t\t\/\/ This logic means that if a cache clear is currently in progress we don't try to clear the cache.\n\t\t\t\t\t\/\/ This prevents web server children from being queued up waiting to be able to also clear the cache. \n\t\t\tself::$lastRecursiveDeleteError = false;\n\t\t\tself::recursiveDelete(WP_CONTENT_DIR . '\/wfcache\/');\n\t\t\tif(self::$lastRecursiveDeleteError){\n\t\t\t\tself::$cacheStats['error'] = self::$lastRecursiveDeleteError;\n\t\t\t\tself::$cacheStats['totalErrors']++;\n\t\t\t}\n\t\t\tflock($fp, LOCK_UN);\n\t\t\t@unlink($cacheClearLock);\n\t\t\t@rmdir($cacheDir);\n\t\t}\n\t\tfclose($fp);\n\n\t\treturn self::$cacheStats;\n\t}\n\tprivate static function recursiveDelete($dir) {\n\t\t$files = array_diff(scandir($dir), array('.','..')); \n\t\tforeach ($files as $file) { \n\t\t\tif(is_dir($dir . '\/' . $file)){\n\t\t\t\tif(! self::recursiveDelete($dir . '\/' . $file)){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif($file == 'clear.lock'){ continue; } \/\/Don't delete our lock file\n\t\t\t\t$size = filesize($dir . '\/' . $file);\n\t\t\t\tif($size){\n\t\t\t\t\tself::$cacheStats['totalData'] += round($size \/ 1024);\n\t\t\t\t}\n\t\t\t\tif(strpos($dir, 'wfcache\/') === false){\n\t\t\t\t\tself::$lastRecursiveDeleteError = \"Not deleting file in directory $dir because it appears to be in the wrong path.\";\n\t\t\t\t\tself::$cacheStats['totalErrors']++;\n\t\t\t\t\treturn false; \/\/Safety check that we're in a subdir of the cache\n\t\t\t\t}\n\t\t\t\tif(@unlink($dir . '\/' . $file)){\n\t\t\t\t\tself::$cacheStats['filesDeleted']++;\n\t\t\t\t} else {\n\t\t\t\t\tself::$lastRecursiveDeleteError = \"Could not delete file \" . $dir . \"\/\" . $file . \" : \" . wfUtils::getLastError();\n\t\t\t\t\tself::$cacheStats['totalErrors']++;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t\tif($dir != WP_CONTENT_DIR . '\/wfcache\/'){\n\t\t\tif(strpos($dir, 'wfcache\/') === false){\n\t\t\t\tself::$lastRecursiveDeleteError = \"Not deleting directory $dir because it appears to be in the wrong path.\";\n\t\t\t\tself::$cacheStats['totalErrors']++;\n\t\t\t\treturn false; \/\/Safety check that we're in a subdir of the cache\n\t\t\t}\n\t\t\tif(@rmdir($dir)){\n\t\t\t\tself::$cacheStats['dirsDeleted']++;\n\t\t\t} else {\n\t\t\t\tself::$lastRecursiveDeleteError = \"Could not delete directory $dir : \" . wfUtils::getLastError();\n\t\t\t\tself::$cacheStats['totalErrors']++;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n\tpublic static function addHtaccessCode($action){\n\t\tif($action != 'remove'){\n\t\t\tdie(\"Error: addHtaccessCode must be called with 'remove' as param\");\n\t\t}\n\t\t$htaccessPath = self::getHtaccessPath();\n\t\tif(! $htaccessPath){\n\t\t\treturn \"Wordfence could not find your .htaccess file.\";\n\t\t}\n\t\t$fh = @fopen($htaccessPath, 'r+');\n\t\tif(! $fh){\n\t\t\t$err = error_get_last();\n\t\t\treturn $err['message'];\n\t\t}\n\t\tflock($fh, LOCK_EX);\n\t\tfseek($fh, 0, SEEK_SET); \/\/start of file\n\t\tclearstatcache();\n\t\t$contents = fread($fh, filesize($htaccessPath));\n\t\tif(! $contents){\n\t\t\tfclose($fh);\n\t\t\treturn \"Could not read from $htaccessPath\";\n\t\t}\n\t\t$contents = preg_replace('\/#WFCACHECODE.*WFCACHECODE[\\r\\s\\n\\t]*\/s', '', $contents);\n\t\tftruncate($fh, 0);\n\t\tfflush($fh);\n\t\tfseek($fh, 0, SEEK_SET);\n\t\tfwrite($fh, $contents);\n\t\tflock($fh, LOCK_UN);\n\t\tfclose($fh);\n\t\treturn false;\n\t}\n\n\t\/**\n\t * @param $action\n\t * @return bool|string|void\n\t *\/\n\tpublic static function updateBlockedIPs($action){ \/\/'add' or 'remove'\n\t\t$htaccessPath = self::getHtaccessPath();\n\t\tif(! $htaccessPath){\n\t\t\treturn \"Wordfence could not find your .htaccess file.\";\n\t\t}\n\t\tif($action == 'remove'){\n\t\t\t$fh = @fopen($htaccessPath, 'r+');\n\t\t\tif(! $fh){\n\t\t\t\t$err = error_get_last();\n\t\t\t\treturn $err['message'];\n\t\t\t}\n\t\t\tflock($fh, LOCK_EX);\n\t\t\tfseek($fh, 0, SEEK_SET); \/\/start of file\n\t\t\tclearstatcache();\n\t\t\t$contents = @fread($fh, filesize($htaccessPath));\n\t\t\tif(! $contents){\n\t\t\t\tfclose($fh);\n\t\t\t\treturn \"Could not read from $htaccessPath\";\n\t\t\t}\n\n\t\t\t$contents = preg_replace('\/#WFIPBLOCKS.*WFIPBLOCKS[\\r\\s\\n\\t]*\/s', '', $contents);\n\n\t\t\tftruncate($fh, 0);\n\t\t\tfflush($fh);\n\t\t\tfseek($fh, 0, SEEK_SET);\n\t\t\t@fwrite($fh, $contents);\n\t\t\tflock($fh, LOCK_UN);\n\t\t\tfclose($fh);\n\t\t\treturn false;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic static function getHtaccessPath(){\n\n\t\t$homePath = wfUtils::getHomePath();\n\t\t$htaccessFile = $homePath.'.htaccess';\n\t\treturn $htaccessFile;\n\t}\n\tpublic static function doNotCache(){\n\t\tif(! defined('WFDONOTCACHE')){\n\t\t\tdefine('WFDONOTCACHE', true);\n\t\t}\n\t}\n}"},{"base":"plugins","rel":"wordfence\/lib\/wfDashboard.php","ext":"php","size":8399,"mtime":1757312769,"type":"text","content":"<?php\n\nclass wfDashboard {\n\tconst SCAN_SUCCESS = 1;\n\tconst SCAN_FAILED = 0;\n\tconst SCAN_NEVER_RAN = -1;\n\tconst SCAN_WARNINGS = 2;\n\t\n\tconst FEATURE_ENABLED = 1;\n\tconst FEATURE_DISABLED = 0;\n\tconst FEATURE_PREMIUM = -1;\n\t\n\tpublic $scanLastCompletion;\n\tpublic $scanLastStatusMessage;\n\tpublic $scanLastStatus;\n\t\n\tpublic $notifications = array();\n\t\n\tpublic $features = array();\n\t\n\tpublic $lastGenerated;\n\t\n\tpublic $tdfCommunity;\n\tpublic $tdfPremium;\n\t\n\tpublic $ips24h;\n\tpublic $ips7d;\n\tpublic $ips30d;\n\t\n\tpublic $loginsSuccess;\n\tpublic $loginsFail;\n\t\n\tpublic $localBlocks;\n\t\n\tpublic $networkBlock24h;\n\tpublic $networkBlock7d;\n\tpublic $networkBlock30d;\n\t\n\tpublic $countriesLocal;\n\tpublic $countriesNetwork;\n\tpublic $wordfenceCentralConnected;\n\tpublic $wordfenceCentralConnectTime;\n\tpublic $wordfenceCentralConnectEmail;\n\tpublic $wordfenceCentralDisconnected;\n\tpublic $wordfenceCentralDisconnectTime;\n\tpublic $wordfenceCentralDisconnectEmail;\n\n\tpublic static function processDashboardResponse($data) {\n\t\tif (isset($data['notifications'])) {\n\t\t\tforeach ($data['notifications'] as $n) {\n\t\t\t\tif (!isset($n['id']) || !isset($n['priority']) || !isset($n['html'])) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tnew wfNotification($n['id'], $n['priority'], $n['html'], (isset($n['category']) ? $n['category'] : null));\n\t\t\t}\n\t\t\t\n\t\t\tunset($data['notifications']);\n\t\t}\n\t\t\n\t\tif (isset($data['revoked'])) {\n\t\t\tforeach ($data['revoked'] as $r) {\n\t\t\t\tif (!isset($r['id'])) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t$notification = wfNotification::getNotificationForID($r['id']);\n\t\t\t\tif ($notification !== null) {\n\t\t\t\t\t$notification->markAsRead();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tunset($data['revoked']);\n\t\t}\n\t\twfConfig::set_ser('dashboardData', $data, false, wfConfig::DONT_AUTOLOAD);\n\t}\n\t\n\tpublic function __construct() {\n\t\t\/\/ Scan values\n\t\t$lastScanCompleted = wfConfig::get('lastScanCompleted');\n\t\tif ($lastScanCompleted === false || empty($lastScanCompleted)) {\n\t\t\t$this->scanLastStatus = self::SCAN_NEVER_RAN;\n\t\t}\n\t\telse if ($lastScanCompleted == 'ok') {\n\t\t\t$this->scanLastStatus = self::SCAN_SUCCESS;\n\t\t\t\n\t\t\t$i = new wfIssues();\n\t\t\t$this->scanLastCompletion = (int) wfScanner::shared()->lastScanTime();\n\t\t\t$issueCount = $i->getIssueCount();\n\t\t\tif ($issueCount) {\n\t\t\t\t$this->scanLastStatus = self::SCAN_WARNINGS;\n\t\t\t\t$this->scanLastStatusMessage = \"{$issueCount} issue\" . ($issueCount == 1 ? ' found' : 's found');\n\t\t\t}\n\t\t} \n\t\telse {\n\t\t\t$this->scanLastStatus = self::SCAN_FAILED;\n\t\t\t$n = wfNotification::getNotificationForCategory('wfplugin_scan', false);\n\t\t\tif ($n !== null) {\n\t\t\t\t$this->scanLastStatusMessage = $n->html;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$this->scanLastStatusMessage = esc_html(substr($lastScanCompleted, 0, 100) . (strlen($lastScanCompleted) > 100 ? '...' : ''));\n\t\t\t}\n\t\t}\n\t\t\n\t\t\/\/ Notifications\n\t\t$this->notifications = wfNotification::notifications();\n\t\t\n\t\t\/\/ Features\n\t\t$countryBlocking = self::FEATURE_PREMIUM;\n\t\tif (wfConfig::get('isPaid')) {\n\t\t\t$countryBlocking = self::FEATURE_DISABLED;\n\t\t\t$countryList = wfConfig::get('cbl_countries');\n\t\t\tif (!empty($countryList) && (wfConfig::get('cbl_loggedInBlocked', false) || wfConfig::get('cbl_loginFormBlocked', false) || wfConfig::get('cbl_restOfSiteBlocked', false))) {\n\t\t\t\t$countryBlocking = self::FEATURE_ENABLED;\n\t\t\t}\n\t\t}\n\t\t\n\t\t$this->features = array(); \/\/Deprecated\n\t\t\n\t\t$data = wfConfig::get_ser('dashboardData');\n\t\t$lastChecked = wfConfig::get('lastDashboardCheck', 0);\n\t\tif ((!is_array($data) || (isset($data['generated']) && $data['generated'] + 3600 < time())) && $lastChecked + 3600 < time()) {\n\t\t\t$wp_version = wfUtils::getWPVersion();\n\t\t\t$apiKey = wfConfig::get('apiKey');\n\t\t\t$api = new wfAPI($apiKey, $wp_version);\n\t\t\twfConfig::set('lastDashboardCheck', time());\n\t\t\ttry {\n\t\t\t\t$json = $api->getStaticURL('\/stats.json');\n\t\t\t\t$data = @json_decode($json, true);\n\t\t\t\tif ($json && is_array($data)) {\n\t\t\t\t\tself::processDashboardResponse($data);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception $e) {\n\t\t\t\t\/\/Do nothing\n\t\t\t}\n\t\t}\n\t\t\n\t\t\/\/ Last Generated\n\t\tif (is_array($data) && isset($data['generated'])) {\n\t\t\t$this->lastGenerated = $data['generated'];\n\t\t}\n\t\t\n\t\t\/\/ TDF\n\t\tif (is_array($data) && isset($data['tdf']) && isset($data['tdf']['community'])) {\n\t\t\t$this->tdfCommunity = (int) $data['tdf']['community'];\n\t\t\t$this->tdfPremium = (int) $data['tdf']['premium'];\n\t\t}\n\t\t\n\t\t\/\/ Top IPs Blocked\n\t\t$activityReport = new wfActivityReport();\n\t\t$this->ips24h = (array) $activityReport->getTopIPsBlocked(100, 1);\n\t\tforeach ($this->ips24h as &$r24h) {\n\t\t\t$r24h = (array) $r24h;\n\t\t\tif (empty($r24h['countryName'])) { $r24h['countryName'] = 'Unknown'; }\n\t\t}\n\t\t$this->ips7d = (array) $activityReport->getTopIPsBlocked(100, 7);\n\t\tforeach ($this->ips7d as &$r7d) {\n\t\t\t$r7d = (array) $r7d;\n\t\t\tif (empty($r7d['countryName'])) { $r7d['countryName'] = 'Unknown'; }\n\t\t}\n\t\t$this->ips30d = (array) $activityReport->getTopIPsBlocked(100, 30);\n\t\tforeach ($this->ips30d as &$r30d) {\n\t\t\t$r30d = (array) $r30d;\n\t\t\tif (empty($r30d['countryName'])) { $r30d['countryName'] = 'Unknown'; }\n\t\t}\n\t\t\n\t\t\/\/ Recent Logins\n\t\t$logins = wordfence::getLog()->getHits('logins', 'loginLogout', 0, 200);\n\t\t$this->loginsSuccess = array();\n\t\t$this->loginsFail = array();\n\t\tforeach ($logins as $l) {\n\t\t\tif ($l['fail']) {\n\t\t\t\t$this->loginsFail[] = array('t' => $l['ctime'], 'name' => $l['username'], 'ip' => $l['IP']);\n\t\t\t}\n\t\t\telse if ($l['action'] != 'logout') {\n\t\t\t\t$this->loginsSuccess[] = array('t' => $l['ctime'], 'name' => $l['username'], 'ip' => $l['IP']);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\/\/ Local Attack Data\n\t\t$this->localBlocks = array();\n\t\t$this->localBlocks[] = array('title' => __('Complex', 'wordfence'), 'type' => wfActivityReport::BLOCK_TYPE_COMPLEX,\n\t\t\t'24h' => (int) $activityReport->getBlockedCount(1, wfActivityReport::BLOCK_TYPE_COMPLEX),\n\t\t\t'7d' => (int) $activityReport->getBlockedCount(7, wfActivityReport::BLOCK_TYPE_COMPLEX),\n\t\t\t'30d' => (int) $activityReport->getBlockedCount(30, wfActivityReport::BLOCK_TYPE_COMPLEX),\n\t\t);\n\t\t$this->localBlocks[] = array('title' => __('Brute Force', 'wordfence'), 'type' => wfActivityReport::BLOCK_TYPE_BRUTE_FORCE,\n\t\t\t'24h' => (int) $activityReport->getBlockedCount(1, wfActivityReport::BLOCK_TYPE_BRUTE_FORCE),\n\t\t\t'7d' => (int) $activityReport->getBlockedCount(7, wfActivityReport::BLOCK_TYPE_BRUTE_FORCE),\n\t\t\t'30d' => (int) $activityReport->getBlockedCount(30, wfActivityReport::BLOCK_TYPE_BRUTE_FORCE),\n\t\t);\n\t\t$this->localBlocks[] = array('title' => __('Blocklist', 'wordfence'), 'type' => wfActivityReport::BLOCK_TYPE_BLACKLIST,\n\t\t\t'24h' => (int) $activityReport->getBlockedCount(1, wfActivityReport::BLOCK_TYPE_BLACKLIST),\n\t\t\t'7d' => (int) $activityReport->getBlockedCount(7, wfActivityReport::BLOCK_TYPE_BLACKLIST),\n\t\t\t'30d' => (int) $activityReport->getBlockedCount(30, wfActivityReport::BLOCK_TYPE_BLACKLIST),\n\t\t);\n\t\t\n\t\t\/\/ Network Attack Data\n\t\tif (is_array($data) && isset($data['attackdata']) && isset($data['attackdata']['24h'])) {\n\t\t\t$this->networkBlock24h = $data['attackdata']['24h'];\n\t\t\t$this->networkBlock7d = $data['attackdata']['7d'];\n\t\t\t$this->networkBlock30d = $data['attackdata']['30d'];\n\t\t}\n\t\t\n\t\t\/\/ Blocked Countries\n\t\t$this->countriesLocal = (array) $activityReport->getTopCountriesBlocked(10, 7);\n\t\tforeach ($this->countriesLocal as &$rLocal) {\n\t\t\t$rLocal = (array) $rLocal;\n\t\t\tif (empty($rLocal['countryName'])) { $rLocal['countryName'] = 'Unknown'; }\n\t\t}\n\t\t\n\t\tif (is_array($data) && isset($data['countries']) && isset($data['countries']['7d'])) {\n\t\t\t$networkCountries = array();\n\t\t\tforeach ($data['countries']['7d'] as $rNetwork) {\n\t\t\t\t$countryCode = $rNetwork['cd'];\n\t\t\t\t$countryName = $activityReport->getCountryNameByCode($countryCode);\n\t\t\t\tif (empty($countryName)) { $countryName = 'Unknown'; }\n\t\t\t\t$totalBlockCount = $rNetwork['ct'];\n\t\t\t\t$networkCountries[] = array('countryCode' => $countryCode, 'countryName' => $countryName, 'totalBlockCount' => $totalBlockCount);\n\t\t\t}\n\t\t\t$this->countriesNetwork = $networkCountries;\n\t\t}\n\n\t\t\/\/ Wordfence Central\n\t\t$this->wordfenceCentralConnected = wfCentral::_isConnected(); \/\/ This value is cached.\n\t\t$this->wordfenceCentralConnectTime = wfConfig::get('wordfenceCentralConnectTime');\n\t\t$this->wordfenceCentralConnectEmail = wfConfig::get('wordfenceCentralConnectEmail');\n\t\t$this->wordfenceCentralDisconnected = wfConfig::get('wordfenceCentralDisconnected');\n\t\t$this->wordfenceCentralDisconnectTime = wfConfig::get('wordfenceCentralDisconnectTime');\n\t\t$this->wordfenceCentralDisconnectEmail = wfConfig::get('wordfenceCentralDisconnectEmail');\n\t}\n}\n"},{"base":"plugins","rel":"wordfence\/lib\/wordfenceClass.php","ext":"php","size":450511,"mtime":1757312769},{"base":"plugins","rel":"wordfence\/lib\/IPTrafList.php","ext":"php","size":3054,"mtime":1757312769,"type":"text","content":"<?php if (!defined('WORDFENCE_VERSION')) { exit; } ?>\n<?php\nif (!wfUtils::isAdmin()) {\n\texit();\n}\n\/**\n * @var array $results\n *\/\n?>\n<table border=\"0\" cellpadding=\"2\" cellspacing=\"0\" class=\"wf-recent-traffic-table\">\n\t<?php foreach ($results as $key => $v) { ?>\n\t\t<tr>\n\t\t\t<th><?php esc_html_e('Time:', 'wordfence') ?><\/th>\n\t\t\t<td><?php esc_html_e(sprintf(\n\t\t\t\t\/* translators: 1. Time ago, example: 2 hours, 40 seconds. 2. Localized date. 3. Unix timestamp.  *\/\n\t\t\t\t\t__('%1$s ago -- %2$s -- %3$s in Unixtime', 'wordfence'), $v['timeAgo'], date(DATE_RFC822, (int) $v['ctime']), $v['ctime'])) ?><\/td>\n\t\t<\/tr>\n\t\t<?php if ($v['timeSinceLastHit']) {\n\t\t\techo '<th>' . esc_html__('Seconds since last hit:', 'wordfence') . '<\/th><td>' . $v['timeSinceLastHit'] . '<\/td><\/tr>';\n\t\t} ?>\n\t\t<tr>\n\t\t\t<th><?php esc_html_e('URL:', 'wordfence') ?><\/th>\n\t\t\t<td>\n\t\t\t\t<a href=\"<?php echo esc_url($v['URL']) ?>\" target=\"_blank\" rel=\"noopener noreferrer\"><?php echo esc_html($v['URL']); ?><span class=\"screen-reader-text\"> (<?php esc_html_e('opens in new tab', 'wordfence') ?>)<\/span><\/a>\n\t\t\t<\/td>\n\t\t<\/tr>\n\t\t<tr>\n\t\t\t<th>Type:<\/th>\n\t\t\t<td><?php\n\t\t\t\tif ($v['statusCode'] == '404') {\n\t\t\t\t\techo '<span style=\"color: #F00;\">' . esc_html__('Page not found', 'wordfence') . '<\/span>';\n\t\t\t\t}\n\t\t\t\telse if ($v['type'] == 'hit') {\n\t\t\t\t\tesc_html_e('Normal request', 'wordfence');\n\t\t\t\t} ?><\/td>\n\t\t<\/tr>\n\t\t<?php if ($v['referer']) { ?>\n\t\t\t<tr>\n\t\t\t<th><?php esc_html_e('Referrer:', 'wordfence') ?><\/th>\n\t\t\t<td>\n\t\t\t\t<a href=\"<?php echo esc_url($v['referer']); ?>\" target=\"_blank\" rel=\"noopener noreferrer\"><?php echo esc_html($v['referer']); ?><span class=\"screen-reader-text\"> (<?php esc_html_e('opens in new tab', 'wordfence') ?>)<\/span><\/a>\n\t\t\t<\/td><\/tr><?php } ?>\n\t\t<tr>\n\t\t\t<th><?php esc_html_e('Full Browser ID:', 'wordfence') ?><\/th>\n\t\t\t<td><?php echo esc_html($v['UA']); ?><\/td>\n\t\t<\/tr>\n\t\t<?php if ($v['user']) { ?>\n\t\t\t<tr>\n\t\t\t\t<th><?php esc_html_e('User:', 'wordfence') ?><\/th>\n\t\t\t\t<td>\n\t\t\t\t\t<a href=\"<?php echo esc_url($v['user']['editLink']); ?>\" target=\"_blank\" rel=\"noopener noreferrer\"><span data-userid=\"<?php echo esc_attr($v['user']['ID']); ?>\" class=\"wfAvatar\"><\/span><?php echo esc_html($v['user']['display_name']); ?><span class=\"screen-reader-text\"> (<?php esc_html_e('opens in new tab', 'wordfence') ?>)<\/span><\/a>\n\t\t\t\t<\/td>\n\t\t\t<\/tr>\n\t\t<?php } ?>\n\t\t<?php if ($v['loc']) { ?>\n\t\t\t<tr>\n\t\t\t\t<th><?php esc_html_e('Location:', 'wordfence') ?><\/th>\n\t\t\t\t<td>\n\t\t\t\t\t<span class=\"wf-flag <?php echo esc_attr('wf-flag-' . strtolower($v['loc']['countryCode'])); ?>\" title=\"<?php echo esc_attr($v['loc']['countryName']); ?>\"><\/span>\n\t\t\t\t\t<?php if ($v['loc']['city']) {\n\t\t\t\t\t\techo esc_html($v['loc']['city']) . ', ';\n\t\t\t\t\t} ?>\n\t\t\t\t\t<?php \n\t\t\t\t\tif ($v['loc']['region'] && wfUtils::shouldDisplayRegion($v['loc']['countryName'])) {\n\t\t\t\t\t\techo esc_html($v['loc']['region']) . ', ';\n\t\t\t\t\t} ?>\n\t\t\t\t\t<?php echo esc_html($v['loc']['countryName']); ?>\n\t\t\t\t<\/td>\n\t\t\t<\/tr>\n\t\t<?php } ?>\n\t\t<tr class=\"wf-recent-traffic-table-row-border\">\n\t\t\t<td colspan=\"2\"><div><\/div><\/td>\n\t\t<\/tr>\n\t<?php } ?>\n\n<\/table>"},{"base":"plugins","rel":"wordfence\/lib\/rest-api\/wfRESTScanController.php","ext":"php","size":5190,"mtime":1757312769,"type":"text","content":"<?php\n\nrequire_once(dirname(__FILE__) . '\/wfRESTBaseController.php');\n\nclass wfRESTScanController extends wfRESTBaseController {\n\n\t\/**\n\t * @todo Setup routes to modify scan results.\n\t *\/\n\tpublic function registerRoutes() {\n\t\tregister_rest_route('wordfence\/v1', '\/scan\/issues', array(\n\t\t\t'methods'             => WP_REST_Server::READABLE,\n\t\t\t'callback'            => array($this, 'getIssuesList'),\n\t\t\t'permission_callback' => array($this, 'verifyToken'),\n\t\t\t'group'               => array(\n\t\t\t\t'description' => __('Scan result group or all results.', 'wordfence'),\n\t\t\t\t'type'        => 'string',\n\t\t\t\t'required'    => false,\n\t\t\t),\n\t\t\t'offset'              => array(\n\t\t\t\t'description' => __('Offset of scan results to return.', 'wordfence'),\n\t\t\t\t'type'        => 'int',\n\t\t\t\t'required'    => false,\n\t\t\t),\n\t\t\t'limit'               => array(\n\t\t\t\t'description' => __('Number of scan results to return.', 'wordfence'),\n\t\t\t\t'type'        => 'int',\n\t\t\t\t'required'    => false,\n\t\t\t),\n\t\t));\n\t\tregister_rest_route('wordfence\/v1', '\/scan', array(\n\t\t\t'methods'             => WP_REST_Server::CREATABLE,\n\t\t\t'callback'            => array($this, 'startScan'),\n\t\t\t'permission_callback' => array($this, 'verifyToken'),\n\t\t));\n\t\tregister_rest_route('wordfence\/v1', '\/scan', array(\n\t\t\t'methods'             => WP_REST_Server::DELETABLE,\n\t\t\t'callback'            => array($this, 'stopScan'),\n\t\t\t'permission_callback' => array($this, 'verifyToken'),\n\t\t));\n\t\tregister_rest_route('wordfence\/v1', '\/scan\/issue', array(\n\t\t\t'methods'             => WP_REST_Server::EDITABLE,\n\t\t\t'callback'            => array($this, 'updateIssue'),\n\t\t\t'permission_callback' => array($this, 'verifyToken'),\n\t\t));\n\t}\n\n\t\/**\n\t * @param WP_REST_Request $request\n\t * @return mixed|WP_REST_Response\n\t *\/\n\tpublic function getIssuesList($request) {\n\t\t$group = $request['group'] ? $request['group'] : 'all';\n\t\t$offset = absint($request['offset']);\n\t\t$limit = absint($request['limit']);\n\t\tif ($limit === 0) {\n\t\t\t$limit = 100;\n\t\t}\n\t\tswitch ($group) {\n\t\t\tcase 'pending':\n\t\t\t\t$count = wfIssues::shared()->getPendingIssueCount();\n\t\t\t\t$issues = wfIssues::shared()->getPendingIssues($offset, $limit);\n\t\t\t\tbreak;\n\n\t\t\tdefault: \/\/ Return all issues.\n\t\t\t\t$count = wfIssues::shared()->getIssueCount();\n\t\t\t\t$issues = wfIssues::shared()->getIssues($offset, $limit);\n\t\t\t\tbreak;\n\t\t}\n\n\t\t$response = rest_ensure_response(array(\n\t\t\t'count'          => $count,\n\t\t\t'last-scan-time' => wfConfig::get('scanTime'),\n\t\t\t'issues'         => $issues,\n\t\t));\n\t\treturn $response;\n\t}\n\n\t\/**\n\t * @param WP_REST_Request $request\n\t * @return mixed|WP_REST_Response\n\t *\/\n\tpublic function startScan($request) {\n\t\twordfence::status(1, 'info', sprintf(\/* translators: Localized date. *\/ __('Wordfence scan starting at %s from Wordfence Central', 'wordfence'),\n\t\t\tdate('l jS \\of F Y h:i:s A', current_time('timestamp'))));\n\n\t\ttry {\n\t\t\twfScanEngine::startScan();\n\n\t\t} catch (wfScanEngineTestCallbackFailedException $e) {\n\t\t\twfConfig::set('lastScanCompleted', $e->getMessage());\n\t\t\twfConfig::set('lastScanFailureType', wfIssues::SCAN_FAILED_CALLBACK_TEST_FAILED);\n\t\t\twfUtils::clearScanLock();\n\t\t\t$response = rest_ensure_response(array(\n\t\t\t\t'success'    => false,\n\t\t\t\t'error-code' => $e->getCode(),\n\t\t\t\t'error'      => $e->getMessage(),\n\t\t\t));\n\t\t\treturn $response;\n\n\t\t} catch (Exception $e) {\n\t\t\tif ($e->getCode() != wfScanEngine::SCAN_MANUALLY_KILLED) {\n\t\t\t\twfConfig::set('lastScanCompleted', $e->getMessage());\n\t\t\t\twfConfig::set('lastScanFailureType', wfIssues::SCAN_FAILED_GENERAL);\n\n\t\t\t\t$response = rest_ensure_response(array(\n\t\t\t\t\t'success'    => false,\n\t\t\t\t\t'error-code' => $e->getCode(),\n\t\t\t\t\t'error'      => $e->getMessage(),\n\t\t\t\t));\n\t\t\t\treturn $response;\n\t\t\t}\n\t\t}\n\n\t\t$response = rest_ensure_response(array(\n\t\t\t'success' => true,\n\t\t));\n\t\treturn $response;\n\n\t}\n\n\t\/**\n\t * @param WP_REST_Request $request\n\t * @return mixed|WP_REST_Response\n\t *\/\n\tpublic function stopScan($request) {\n\t\twordfence::status(1, 'info', __('Scan stop request received from Wordfence Central.', 'wordfence'));\n\t\twordfence::status(10, 'info', __('SUM_KILLED:A request was received to stop the previous scan from Wordfence Central.', 'wordfence'));\n\t\twfUtils::clearScanLock(); \/\/Clear the lock now because there may not be a scan running to pick up the kill request and clear the lock\n\t\twfScanEngine::requestKill();\n\t\twfConfig::remove('scanStartAttempt');\n\t\twfConfig::set('lastScanFailureType', false);\n\t\t$response = rest_ensure_response(array(\n\t\t\t'success' => true,\n\t\t));\n\t\treturn $response;\n\t}\n\n\t\/**\n\t * @param WP_REST_Request $request\n\t * @return mixed|WP_REST_Response\n\t *\/\n\tpublic function updateIssue($request) {\n\t\t$issue = $request['issue'];\n\t\t$id = is_array($issue) && array_key_exists('id', $issue) ? $issue['id'] : null;\n\t\t$status = is_array($issue) && array_key_exists('status', $issue) ? $issue['status'] : null;\n\n\t\tif ($id) {\n\t\t\t$wfdb = new wfDB();\n\t\t\t$wfdb->queryWrite(\"update \" . wfDB::networkTable('wfIssues') . \" set status='%s' where id=%d\", $status, $id);\n\t\t\t$response = rest_ensure_response(array(\n\t\t\t\t'success' => true,\n\t\t\t));\n\t\t\treturn $response;\n\t\t}\n\t\t$response = rest_ensure_response(array(\n\t\t\t'success'    => false,\n\t\t\t'error'      => 'Issue not found.',\n\t\t));\n\t\treturn $response;\n\n\t}\n}"},{"base":"plugins","rel":"wordfence\/lib\/rest-api\/wfRESTAuthenticationController.php","ext":"php","size":6024,"mtime":1757312769,"type":"text","content":"<?php\n\nclass wfRESTAuthenticationController {\n\n\tconst NONCE_AGE = 600;\n\n\tpublic static function generateNonce($tickOffset = 0) {\n\t\tadd_filter('nonce_life', 'wfRESTAuthenticationController::nonceAge');\n\n\t\t$i = wp_nonce_tick();\n\t\t$salt = wp_salt('nonce');\n\t\t$nonce = hash_hmac('sha256', ($i + $tickOffset) . '|wordfence-rest-api-auth', $salt);\n\n\t\tremove_filter('nonce_life', 'wfRESTAuthenticationController::nonceAge');\n\n\t\treturn $nonce;\n\t}\n\n\tpublic static function generateToken() {\n\t\treturn new wfJWT(wfConfig::get('wordfenceCentralSiteID'));\n\t}\n\n\tpublic static function nonceAge() {\n\t\treturn self::NONCE_AGE;\n\t}\n\n\tpublic function registerRoutes() {\n\t\tregister_rest_route('wordfence\/v1', '\/authenticate', array(\n\t\t\t'methods'  => WP_REST_Server::READABLE,\n\t\t\t'callback' => array($this, 'nonce'),\n\t\t\t'permission_callback' => '__return_true',\n\t\t));\n\t\tregister_rest_route('wordfence\/v1', '\/authenticate', array(\n\t\t\t'methods'  => WP_REST_Server::CREATABLE,\n\t\t\t'callback' => array($this, 'authenticate'),\n\t\t\t'permission_callback' => '__return_true',\n\t\t));\n\t\tregister_rest_route('wordfence\/v1', '\/authenticate-premium', array(\n\t\t\t'methods'  => WP_REST_Server::CREATABLE,\n\t\t\t'callback' => array($this, 'authenticatePremium'),\n\t\t\t'permission_callback' => '__return_true',\n\t\t));\n\t}\n\n\t\/**\n\t * @param WP_REST_Request $request\n\t * @return mixed|WP_REST_Response\n\t *\/\n\tpublic function nonce($request) {\n\t\t$response = rest_ensure_response(array(\n\t\t\t'nonce' => self::generateNonce(),\n\t\t\t'admin_url' => network_admin_url(),\n\t\t));\n\t\treturn $response;\n\t}\n\n\t\/**\n\t * @param WP_REST_Request $request\n\t * @return mixed|WP_REST_Response\n\t *\/\n\tpublic function authenticate($request) {\n\t\trequire_once(WORDFENCE_PATH . '\/lib\/sodium_compat_fast.php');\n\n\t\t$siteID = wfConfig::get('wordfenceCentralSiteID');\n\t\tif (!$siteID) {\n\t\t\treturn new WP_Error('rest_forbidden_context',\n\t\t\t\t__('Site is not connected to Wordfence Central.', 'wordfence'),\n\t\t\t\tarray('status' => rest_authorization_required_code()));\n\t\t}\n\n\t\t\/\/ verify signature.\n\t\t$data = $request->get_param('data');\n\t\t$dataChunks = explode('|', $data, 2);\n\t\tif (count($dataChunks) !== 2) {\n\t\t\treturn new WP_Error('rest_forbidden_context',\n\t\t\t\t__('Data is invalid.', 'wordfence'),\n\t\t\t\tarray('status' => rest_authorization_required_code()));\n\t\t}\n\t\tif (!preg_match('\/[0-9a-f]{64}\/i', $dataChunks[0])) {\n\t\t\treturn new WP_Error('rest_forbidden_context',\n\t\t\t\t__('Nonce format is invalid.', 'wordfence'),\n\t\t\t\tarray('status' => rest_authorization_required_code()));\n\t\t}\n\t\tif (!preg_match('\/[0-9a-f\\-]{36}\/i', $dataChunks[1])) {\n\t\t\treturn new WP_Error('rest_forbidden_context',\n\t\t\t\t__('Site ID is invalid.', 'wordfence'),\n\t\t\t\tarray('status' => rest_authorization_required_code()));\n\t\t}\n\t\tif (!hash_equals($siteID, $dataChunks[1])) {\n\t\t\treturn new WP_Error('rest_forbidden_context',\n\t\t\t\t__('Site ID is invalid.', 'wordfence'),\n\t\t\t\tarray('status' => rest_authorization_required_code()));\n\t\t}\n\n\t\t$signature = $request->get_param('signature');\n\t\t$nonce1 = self::generateNonce();\n\t\t$nonce2 = self::generateNonce(-1);\n\t\t$verfiedNonce = hash_equals($nonce1, $dataChunks[0]) || hash_equals($nonce2, $dataChunks[0]);\n\n\t\tif (!$verfiedNonce) {\n\t\t\treturn new WP_Error('rest_forbidden_context',\n\t\t\t\t__('Nonce is invalid.', 'wordfence'),\n\t\t\t\tarray('status' => rest_authorization_required_code()));\n\t\t}\n\t\t$signature = pack('H*', $signature);\n\t\tif (!ParagonIE_Sodium_Compat::crypto_sign_verify_detached($signature, $data, wfConfig::get('wordfenceCentralPK'))) {\n\t\t\treturn new WP_Error('rest_forbidden_context',\n\t\t\t\t__('Signature is invalid.', 'wordfence'),\n\t\t\t\tarray('status' => rest_authorization_required_code()));\n\t\t}\n\n\t\t$response = rest_ensure_response(array(\n\t\t\t'token' => (string) self::generateToken(),\n\t\t));\n\t\treturn $response;\n\t}\n\n\t\/**\n\t * @param WP_REST_Request $request\n\t * @return mixed|WP_REST_Response\n\t *\/\n\tpublic function authenticatePremium($request) {\n\t\trequire_once(WORDFENCE_PATH . '\/lib\/sodium_compat_fast.php');\n\n\t\t\/\/ verify signature.\n\t\t$data = $request->get_param('data');\n\t\t$dataChunks = explode('|', $data, 2);\n\t\tif (count($dataChunks) !== 2) {\n\t\t\treturn new WP_Error('rest_forbidden_context',\n\t\t\t\t__('Data is invalid.', 'wordfence'),\n\t\t\t\tarray('status' => rest_authorization_required_code()));\n\t\t}\n\t\tif (!preg_match('\/[0-9a-f]{64}\/i', $dataChunks[0])) {\n\t\t\treturn new WP_Error('rest_forbidden_context',\n\t\t\t\t__('Nonce format is invalid.', 'wordfence'),\n\t\t\t\tarray('status' => rest_authorization_required_code()));\n\t\t}\n\t\tif (!is_email($dataChunks[1])) {\n\t\t\treturn new WP_Error('rest_forbidden_context',\n\t\t\t\t__('Email address is invalid.', 'wordfence'),\n\t\t\t\tarray('status' => rest_authorization_required_code()));\n\t\t}\n\n\t\t$adminEmail = $dataChunks[1];\n\n\t\t$signature = $request->get_param('signature');\n\t\t$nonce1 = self::generateNonce();\n\t\t$nonce2 = self::generateNonce(-1);\n\t\t$verfiedNonce = hash_equals($nonce1, $dataChunks[0]) || hash_equals($nonce2, $dataChunks[0]);\n\n\t\tif (!$verfiedNonce) {\n\t\t\treturn new WP_Error('rest_forbidden_context',\n\t\t\t\t__('Nonce is invalid.', 'wordfence'),\n\t\t\t\tarray('status' => rest_authorization_required_code()));\n\t\t}\n\t\t$signature = pack('H*', $signature);\n\t\tif (!ParagonIE_Sodium_Compat::crypto_sign_verify_detached($signature, $data, WORDFENCE_CENTRAL_PUBLIC_KEY)) {\n\t\t\treturn new WP_Error('rest_forbidden_context',\n\t\t\t\t__('Signature is invalid.', 'wordfence'),\n\t\t\t\tarray('status' => rest_authorization_required_code()));\n\t\t}\n\n\t\t$user_query = new WP_User_Query(array(\n\t\t\t'role'           => 'administrator',\n\t\t\t'search'         => $adminEmail,\n\t\t\t'search_columns' => array('user_email')\n\t\t));\n\t\t$users = $user_query->get_results();\n\t\tif (is_array($users) && count($users) === 1) {\n\t\t\t$jwt = new wfJWT('wordfence-central-premium');\n\t\t\t$jwt->addClaims(array('email' => $adminEmail));\n\t\t\t$response = rest_ensure_response(array(\n\t\t\t\t'token' => (string) $jwt,\n\t\t\t));\n\t\t\treturn $response;\n\t\t}\n\n\t\treturn new WP_Error('rest_forbidden_context',\n\t\t\t__('Admin user with this email address not found.', 'wordfence'),\n\t\t\tarray('status' => rest_authorization_required_code()));\n\t}\n\n}"},{"base":"plugins","rel":"wordfence\/lib\/rest-api\/wfRESTBaseController.php","ext":"php","size":2094,"mtime":1757312769,"type":"text","content":"<?php\n\nabstract class wfRESTBaseController {\n\n\tprotected $tokenData;\n\n\t\/**\n\t * @param WP_REST_Request $request\n\t * @return WP_Error|bool\n\t *\/\n\tpublic function verifyToken($request) {\n\t\t$validToken = $this->isTokenValid($request);\n\n\t\tif ($validToken &&\n\t\t\t!is_wp_error($validToken) &&\n\t\t\t$this->tokenData['body']['sub'] === wfConfig::get('wordfenceCentralSiteID')\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (is_wp_error($validToken)) {\n\t\t\treturn $validToken;\n\t\t}\n\n\t\treturn new WP_Error('rest_forbidden_context',\n\t\t\t__('Token is invalid.', 'wordfence'),\n\t\t\tarray('status' => rest_authorization_required_code()));\n\t}\n\n\t\/**\n\t * @param WP_REST_Request $request\n\t * @return WP_Error|bool\n\t *\/\n\tpublic function verifyTokenPremium($request) {\n\t\t$validToken = $this->isTokenValid($request);\n\n\t\tif ($validToken &&\n\t\t\t!is_wp_error($validToken) &&\n\t\t\t$this->tokenData['body']['sub'] === 'wordfence-central-premium'\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (is_wp_error($validToken)) {\n\t\t\treturn $validToken;\n\t\t}\n\n\t\treturn new WP_Error('rest_forbidden_context',\n\t\t\t__('Token is invalid.', 'wordfence'),\n\t\t\tarray('status' => rest_authorization_required_code()));\n\t}\n\n\t\/**\n\t * @param WP_REST_Request $request\n\t * @return bool|WP_Error\n\t *\/\n\tpublic function isTokenValid($request) {\n\t\t$authHeader = $request->get_header('Authorization');\n\t\tif (!$authHeader) {\n\t\t\t$authHeader = $request->get_header('X-Authorization');\n\t\t}\n\t\tif (stripos($authHeader, 'bearer ') !== 0) {\n\t\t\treturn new WP_Error('rest_forbidden_context',\n\t\t\t\t__('Authorization header format is invalid.', 'wordfence'),\n\t\t\t\tarray('status' => rest_authorization_required_code()));\n\t\t}\n\n\t\t$token = trim(substr($authHeader, 7));\n\t\t$jwt = new wfJWT();\n\n\t\ttry {\n\t\t\t$this->tokenData = $jwt->decode($token);\n\n\t\t} catch (wfJWTException $e) {\n\t\t\treturn new WP_Error('rest_forbidden_context',\n\t\t\t\t$e->getMessage(),\n\t\t\t\tarray('status' => rest_authorization_required_code()));\n\n\t\t} catch (Exception $e) {\n\t\t\treturn new WP_Error('rest_forbidden_context',\n\t\t\t\t__('Token is invalid.', 'wordfence'),\n\t\t\t\tarray('status' => rest_authorization_required_code()));\n\t\t}\n\n\t\treturn true;\n\t}\n}"},{"base":"plugins","rel":"wordfence\/lib\/rest-api\/wfRESTConfigController.php","ext":"php","size":13921,"mtime":1757312769,"type":"text","content":"<?php\n\nuse WordfenceLS\\Controller_Settings;\n\nrequire_once(dirname(__FILE__) . '\/wfRESTBaseController.php');\n\nclass wfRESTConfigController extends wfRESTBaseController {\n\tconst WF_CENTRAL_USER_MARKER = '_wf_central_user_'; \/\/Marker used to indicate that the site was disconnected by a user associated with the site's Central account\n\tconst WF_CENTRAL_FAILURE_MARKER = '_wf_central_failure_'; \/\/Marker used to indicate that the site was disconnected due to exceeding the error threshold\n\n\tpublic static function disconnectConfig($adminEmail = null) {\n\t\tglobal $wpdb;\n\t\tdelete_transient('wordfenceCentralJWT' . wfConfig::get('wordfenceCentralSiteID'));\n\n\t\tif (is_null($adminEmail)) {\n\t\t\t$user = wp_get_current_user();\n\t\t\tif ($user && $user->exists()) {\n\t\t\t\t$adminEmail = $user->user_email;\n\t\t\t}\n\t\t\t\n\t\t\tif (is_null($adminEmail)) {\n\t\t\t\t$adminEmail = wfConfig::get('wordfenceCentralConnectEmail');\n\t\t\t}\n\t\t}\n\n\t\t$result = $wpdb->query('DELETE FROM ' . wfDB::networkTable('wfConfig') . \" WHERE name LIKE 'wordfenceCentral%'\");\n\n\t\twfConfig::set('wordfenceCentralDisconnected', true);\n\t\twfConfig::set('wordfenceCentralDisconnectTime', time());\n\t\twfConfig::set('wordfenceCentralDisconnectEmail', $adminEmail);\n\t\twfConfig::set('wordfenceCentralConfigurationIssue', false);\n\n\t\treturn !!$result;\n\t}\n\n\tpublic function registerRoutes() {\n\t\tregister_rest_route('wordfence\/v1', '\/config', array(\n\t\t\t'methods'             => WP_REST_Server::READABLE,\n\t\t\t'callback'            => array($this, 'getConfig'),\n\t\t\t'permission_callback' => array($this, 'verifyToken'),\n\t\t\t'fields'              => array(\n\t\t\t\t'description' => __('Specific config options to return.', 'wordfence'),\n\t\t\t\t'type'        => 'array',\n\t\t\t\t'required'    => false,\n\t\t\t),\n\t\t));\n\t\tregister_rest_route('wordfence\/v1', '\/config', array(\n\t\t\t'methods'             => WP_REST_Server::EDITABLE,\n\t\t\t'callback'            => array($this, 'setConfig'),\n\t\t\t'permission_callback' => array($this, 'verifyToken'),\n\t\t\t'fields'              => array(\n\t\t\t\t'description' => __('Specific config options to set.', 'wordfence'),\n\t\t\t\t'type'        => 'array',\n\t\t\t\t'required'    => true,\n\t\t\t),\n\t\t));\n\t\tregister_rest_route('wordfence\/v1', '\/disconnect', array(\n\t\t\t'methods'             => WP_REST_Server::EDITABLE,\n\t\t\t'callback'            => array($this, 'disconnect'),\n\t\t\t'permission_callback' => array($this, 'verifyToken'),\n\t\t));\n\t\tregister_rest_route('wordfence\/v1', '\/premium-connect', array(\n\t\t\t'methods'             => WP_REST_Server::EDITABLE,\n\t\t\t'callback'            => array($this, 'premiumConnect'),\n\t\t\t'permission_callback' => array($this, 'verifyTokenPremium'),\n\t\t));\n\t}\n\n\t\/**\n\t * @param WP_REST_Request $request\n\t * @return mixed|WP_REST_Response\n\t *\/\n\tpublic function getConfig($request) {\n\t\t$fields = (array) $request['fields'];\n\n\t\t$config = array();\n\n\t\t$firewall = new wfFirewall();\n\t\t$wafFields = array(\n\t\t\t'autoPrepend'                    => $firewall->protectionMode() === wfFirewall::PROTECTION_MODE_EXTENDED,\n\t\t\t'avoid_php_input'                => wfWAF::getInstance()->getStorageEngine()->getConfig('avoid_php_input', false) ? 1 : 0,\n\t\t\t'disabledRules'                  => array_keys((array) wfWAF::getInstance()->getStorageEngine()->getConfig('disabledRules')),\n\t\t\t'ruleCount'                      => count((array) wfWAF::getInstance()->getRules()),\n\t\t\t'disableWAFBlacklistBlocking'    => wfWAF::getInstance()->getStorageEngine()->getConfig('disableWAFBlacklistBlocking'),\n\t\t\t'enabled'                        => $firewall->wafStatus() !== wfFirewall::FIREWALL_MODE_DISABLED,\n            'firewallMode'                   => $firewall->firewallMode(),\n\t\t\t'learningModeGracePeriod'        => wfWAF::getInstance()->getStorageEngine()->getConfig('learningModeGracePeriod'),\n\t\t\t'learningModeGracePeriodEnabled' => wfWAF::getInstance()->getStorageEngine()->getConfig('learningModeGracePeriodEnabled'),\n\t\t\t'subdirectoryInstall'            => $firewall->isSubDirectoryInstallation(),\n\t\t\t'wafStatus'                      => $firewall->wafStatus(),\n\t\t);\n\t\t$lsFields = array(\n\t\t\tController_Settings::OPTION_XMLRPC_ENABLED                   => Controller_Settings::shared()->get(Controller_Settings::OPTION_XMLRPC_ENABLED),\n\t\t\tController_Settings::OPTION_2FA_WHITELISTED                  => Controller_Settings::shared()->get(Controller_Settings::OPTION_2FA_WHITELISTED),\n\t\t\tController_Settings::OPTION_IP_SOURCE                        => Controller_Settings::shared()->get(Controller_Settings::OPTION_IP_SOURCE),\n\t\t\tController_Settings::OPTION_IP_TRUSTED_PROXIES               => Controller_Settings::shared()->get(Controller_Settings::OPTION_IP_TRUSTED_PROXIES),\n\t\t\tController_Settings::OPTION_REQUIRE_2FA_ADMIN                => Controller_Settings::shared()->get(Controller_Settings::OPTION_REQUIRE_2FA_ADMIN),\n\t\t\tController_Settings::OPTION_REQUIRE_2FA_GRACE_PERIOD_ENABLED => Controller_Settings::shared()->get(Controller_Settings::OPTION_REQUIRE_2FA_GRACE_PERIOD_ENABLED),\n\t\t\tController_Settings::OPTION_GLOBAL_NOTICES                   => Controller_Settings::shared()->get(Controller_Settings::OPTION_GLOBAL_NOTICES),\n\t\t\tController_Settings::OPTION_REMEMBER_DEVICE_ENABLED          => Controller_Settings::shared()->get(Controller_Settings::OPTION_REMEMBER_DEVICE_ENABLED),\n\t\t\tController_Settings::OPTION_REMEMBER_DEVICE_DURATION         => Controller_Settings::shared()->get(Controller_Settings::OPTION_REMEMBER_DEVICE_DURATION),\n\t\t\tController_Settings::OPTION_ALLOW_XML_RPC                    => Controller_Settings::shared()->get(Controller_Settings::OPTION_ALLOW_XML_RPC),\n\t\t\tController_Settings::OPTION_ENABLE_AUTH_CAPTCHA              => Controller_Settings::shared()->get(Controller_Settings::OPTION_ENABLE_AUTH_CAPTCHA),\n\t\t\tController_Settings::OPTION_RECAPTCHA_THRESHOLD              => Controller_Settings::shared()->get(Controller_Settings::OPTION_RECAPTCHA_THRESHOLD),\n\t\t\tController_Settings::OPTION_LAST_SECRET_REFRESH              => Controller_Settings::shared()->get(Controller_Settings::OPTION_LAST_SECRET_REFRESH),\n\t\t);\n\t\t\/\/ Convert the database strings to typed values.\n\t\tforeach ($lsFields as $lsField => $value) {\n\t\t\t$lsFields[$lsField] = Controller_Settings::shared()->clean($lsField, $value);\n\t\t}\n\n\t\tif (!$fields) {\n\t\t\tforeach (wfConfig::$defaultConfig as $group => $groupOptions) {\n\t\t\t\tforeach ($groupOptions as $field => $values) {\n\t\t\t\t\t$fields[] = $field;\n\t\t\t\t}\n\t\t\t}\n\t\t\tforeach ($wafFields as $wafField => $value) {\n\t\t\t\t$fields[] = 'waf.' . $wafField;\n\t\t\t}\n\t\t\tforeach ($lsFields as $lsField => $value) {\n\t\t\t\t$fields[] = 'wfls_settings_' . $lsField;\n\t\t\t}\n\t\t}\n\n\t\tforeach ($fields as $field) {\n\t\t\tif (strpos($field, 'waf.') === 0) {\n\t\t\t\t$wafField = substr($field, 4);\n\t\t\t\tif (array_key_exists($wafField, $wafFields)) {\n\t\t\t\t\t$config['waf'][$wafField] = $wafFields[$wafField];\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (strpos($field, 'wfls_settings_') === 0) {\n\t\t\t\t$lsField = substr($field, 14);\n\t\t\t\tif (array_key_exists($lsField, $lsFields)) {\n\t\t\t\t\t$config['wfls_settings_' . $lsField] = $lsFields[$lsField];\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (array_key_exists($field, wfConfig::$defaultConfig['checkboxes'])) {\n\t\t\t\t$config[$field] = (bool) wfConfig::get($field);\n\n\t\t\t} else if (array_key_exists($field, wfConfig::$defaultConfig['otherParams']) ||\n\t\t\t\tarray_key_exists($field, wfConfig::$defaultConfig['defaultsOnly'])) {\n\n\t\t\t\t$configConfig = !empty(wfConfig::$defaultConfig['otherParams'][$field]) ?\n\t\t\t\t\twfConfig::$defaultConfig['otherParams'][$field] : wfConfig::$defaultConfig['defaultsOnly'][$field];\n\n\t\t\t\tif (!empty($configConfig['validation']['type'])) {\n\t\t\t\t\tswitch ($configConfig['validation']['type']) {\n\t\t\t\t\t\tcase wfConfig::TYPE_INT:\n\t\t\t\t\t\t\t$config[$field] = wfConfig::getInt($field);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase wfConfig::TYPE_DOUBLE:\n\t\t\t\t\t\tcase wfConfig::TYPE_FLOAT:\n\t\t\t\t\t\t\t$config[$field] = floatval(wfConfig::get($field));\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase wfConfig::TYPE_BOOL:\n\t\t\t\t\t\t\t$config[$field] = (bool) wfConfig::get($field);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase wfConfig::TYPE_ARRAY:\n\t\t\t\t\t\t\t$config[$field] = wfConfig::get_ser($field);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase wfConfig::TYPE_STRING:\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t$config[$field] = wfConfig::get($field);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$config[$field] = wfConfig::get($field);\n\t\t\t\t}\n\n\t\t\t} else if (in_array($field, wfConfig::$serializedOptions)) {\n\t\t\t\t$config[$field] = wfConfig::get_ser($field);\n\t\t\t}\n\t\t}\n\n\t\t$api = new wfAPI(wfConfig::get('apiKey'), wfUtils::getWPVersion());\n\t\tparse_str($api->makeAPIQueryString(), $qs);\n\t\t$systemInfo = json_decode(wfUtils::base64url_decode($qs['s']), true);\n\t\t$systemInfo['output_buffering'] = ini_get('output_buffering');\n\t\t$systemInfo['ip'] = wfUtils::getIPAndServerVariable();\n\t\t$systemInfo['detected_ips'] = wfUtils::getAllServerVariableIPs();\n\t\t$systemInfo['admin_url'] = network_admin_url();\n\n\t\t$response = rest_ensure_response(array(\n\t\t\t'config' => $config,\n\t\t\t'info'   => $systemInfo,\n\t\t));\n\t\treturn $response;\n\t}\n\n\t\/**\n\t * @param WP_REST_Request $request\n\t * @return mixed|WP_REST_Response\n\t *\/\n\tpublic function setConfig($request) {\n\t\twfCentral::preventConfigurationSync();\n\n\t\t$fields = $request['fields'];\n\t\tif (is_array($fields) && $fields) {\n\t\t\t$loginSecurityConfig = array();\n\t\t\tforeach ($fields as $key => $value) {\n\t\t\t\tif (strpos($key, 'wfls_settings_') === 0) {\n\t\t\t\t\t$lsField = substr($key, 14);\n\t\t\t\t\t$loginSecurityConfig[$lsField] = $value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ($loginSecurityConfig) {\n\t\t\t\t$errors = Controller_Settings::shared()->validate_multiple($loginSecurityConfig);\n\n\t\t\t\tif ($errors !== true) {\n\t\t\t\t\tif (count($errors) == 1) {\n\t\t\t\t\t\treturn new WP_Error('rest_set_config_error',\n\t\t\t\t\t\t\tsprintf(\n\t\t\t\t\t\t\t\t\/* translators: Error message. *\/\n\t\t\t\t\t\t\t\t__('An error occurred while saving the configuration: %s', 'wordfence'), $errors[0]['error']),\n\t\t\t\t\t\t\tarray('status' => 422));\n\n\t\t\t\t\t} else if (count($errors) > 1) {\n\t\t\t\t\t\t$compoundMessage = array();\n\t\t\t\t\t\tforeach ($errors as $e) {\n\t\t\t\t\t\t\t$compoundMessage[] = $e['error'];\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn new WP_Error('rest_set_config_error',\n\t\t\t\t\t\t\tsprintf(\n\t\t\t\t\t\t\t\t\/* translators: Error message. *\/\n\t\t\t\t\t\t\t\t__('Errors occurred while saving the configuration: %s', 'wordfence'), implode(', ', $compoundMessage)),\n\t\t\t\t\t\t\tarray('status' => 422));\n\t\t\t\t\t}\n\n\t\t\t\t\treturn new WP_Error('rest_set_config_error',\n\t\t\t\t\t\t__('Errors occurred while saving the configuration.', 'wordfence'),\n\t\t\t\t\t\tarray('status' => 422));\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tController_Settings::shared()->set_multiple($loginSecurityConfig);\n\t\t\t\t\tforeach ($fields as $key => $value) {\n\t\t\t\t\t\tif (strpos($key, 'wfls_settings_') === 0) {\n\t\t\t\t\t\t\tunset($fields[$key]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t} catch (Exception $e) {\n\t\t\t\t\treturn new WP_Error('rest_save_config_error',\n\t\t\t\t\t\tsprintf(\n\t\t\t\t\t\t\/* translators: Error message. *\/\n\t\t\t\t\t\t\t__('A server error occurred while saving the configuration: %s', 'wordfence'), $e->getMessage()),\n\t\t\t\t\t\tarray('status' => 500));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$errors = wfConfig::validate($fields);\n\t\t\tif ($errors !== true) {\n\t\t\t\tif (count($errors) == 1) {\n\t\t\t\t\treturn new WP_Error('rest_set_config_error',\n\t\t\t\t\t\tsprintf(\n\t\t\t\t\t\t\/* translators: Error message. *\/\n\t\t\t\t\t\t\t__('An error occurred while saving the configuration: %s', 'wordfence'), $errors[0]['error']),\n\t\t\t\t\t\tarray('status' => 422));\n\n\t\t\t\t} else if (count($errors) > 1) {\n\t\t\t\t\t$compoundMessage = array();\n\t\t\t\t\tforeach ($errors as $e) {\n\t\t\t\t\t\t$compoundMessage[] = $e['error'];\n\t\t\t\t\t}\n\t\t\t\t\treturn new WP_Error('rest_set_config_error',\n\t\t\t\t\t\tsprintf(\n\t\t\t\t\t\t\/* translators: Error message. *\/\n\t\t\t\t\t\t\t__('Errors occurred while saving the configuration: %s', 'wordfence'), implode(', ', $compoundMessage)),\n\t\t\t\t\t\tarray('status' => 422));\n\t\t\t\t}\n\n\t\t\t\treturn new WP_Error('rest_set_config_error',\n\t\t\t\t\t__('Errors occurred while saving the configuration.', 'wordfence'),\n\t\t\t\t\tarray('status' => 422));\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\twfConfig::save($fields);\n\t\t\t\treturn rest_ensure_response(array(\n\t\t\t\t\t'success' => true,\n\t\t\t\t));\n\n\t\t\t} catch (Exception $e) {\n\t\t\t\treturn new WP_Error('rest_save_config_error',\n\t\t\t\t\tsprintf(\n\t\t\t\t\t\/* translators: Error message. *\/\n\t\t\t\t\t\t__('A server error occurred while saving the configuration: %s', 'wordfence'), $e->getMessage()),\n\t\t\t\t\tarray('status' => 500));\n\t\t\t}\n\t\t}\n\t\treturn new WP_Error('rest_save_config_error',\n\t\t\t__(\"Validation error: 'fields' parameter is empty or not an array.\", 'wordfence'),\n\t\t\tarray('status' => 422));\n\n\t}\n\n\t\/**\n\t * @param WP_REST_Request $request\n\t * @return mixed|WP_REST_Response\n\t *\/\n\tpublic function disconnect($request) {\n\t\tself::disconnectConfig(!empty($this->tokenData['adminEmail']) ? $this->tokenData['adminEmail'] : self::WF_CENTRAL_USER_MARKER);\n\t\treturn rest_ensure_response(array(\n\t\t\t'success' => true,\n\t\t));\n\t}\n\n\t\/**\n\t * @param WP_REST_Request $request\n\t * @return mixed|WP_REST_Response\n\t *\/\n\tpublic function premiumConnect($request) {\n\t\trequire_once(WORDFENCE_PATH . '\/lib\/sodium_compat_fast.php');\n\n\t\t\/\/ Store values sent by Central.\n\t\t$wordfenceCentralPK = $request['public-key'];\n\t\t$wordfenceCentralSiteData = $request['site-data'];\n\t\t$wordfenceCentralSiteID = $request['site-id'];\n\n\t\t$keypair = ParagonIE_Sodium_Compat::crypto_sign_keypair();\n\t\t$publicKey = ParagonIE_Sodium_Compat::crypto_sign_publickey($keypair);\n\t\t$secretKey = ParagonIE_Sodium_Compat::crypto_sign_secretkey($keypair);\n\t\twfConfig::set('wordfenceCentralSecretKey', $secretKey);\n\n\t\twfConfig::set('wordfenceCentralConnected', 1);\n\t\twfConfig::set('wordfenceCentralCurrentStep', 6);\n\t\twfConfig::set('wordfenceCentralPK', pack(\"H*\", $wordfenceCentralPK));\n\t\twfConfig::set('wordfenceCentralSiteData', json_encode($wordfenceCentralSiteData));\n\t\twfConfig::set('wordfenceCentralSiteID', $wordfenceCentralSiteID);\n\t\twfConfig::set('wordfenceCentralConnectTime', time());\n\t\twfConfig::set('wordfenceCentralConnectEmail', !empty($this->tokenData['adminEmail']) ? $this->tokenData['adminEmail'] : null);\n\n\t\t\/\/ Return values created by Wordfence.\n\t\treturn rest_ensure_response(array(\n\t\t\t'success'    => true,\n\t\t\t'public-key' => ParagonIE_Sodium_Compat::bin2hex($publicKey),\n\t\t));\n\t}\n}"},{"base":"plugins","rel":"wordfence\/lib\/menu_dashboard.php","ext":"php","size":28832,"mtime":1757312769,"type":"text","content":"<?php\nif (!defined('WORDFENCE_VERSION')) { exit; }\n$firewall = new wfFirewall();\n$scanner = wfScanner::shared();\n$d = new wfDashboard();\n?>\n<?php\nif (!wfOnboardingController::shouldShowAttempt3() && wfConfig::get('touppPromptNeeded')) {\n\techo wfView::create('gdpr\/disabled-overlay')->render();\n\techo wfView::create('gdpr\/banner')->render();\n}\n?>\n<div class=\"wrap wordfence\" id=\"wf-dashboard\">\n\t<div class=\"wf-container-fluid\">\n\t\t<div class=\"wf-row\">\n\t\t\t<div class=\"wf-col-xs-12\">\n\t\t\t\t<div class=\"wp-header-end\"><\/div>\n\t\t\t\t<?php\n\t\t\t\techo wfView::create('common\/section-title', array(\n\t\t\t\t\t'title' => __('Wordfence Dashboard', 'wordfence'),\n\t\t\t\t\t'helpLink' => wfSupportController::supportURL(wfSupportController::ITEM_DASHBOARD),\n\t\t\t\t\t'helpLabelHTML' => wp_kses(__('Learn more<span class=\"wf-hidden-xs\"> about the Dashboard<\/span>', 'wordfence'), array('span'=>array('class'=>array()))),\n\t\t\t\t\t'showIcon' => true,\n\t\t\t\t))->render();\n\t\t\t\t?>\n\t\t\t<\/div>\n\t\t<\/div>\n\t\t<div class=\"wf-row\">\n\t\t\t<div class=\"wf-col-xs-12\">\n\t\t\t\t<div class=\"wf-block wf-active wf-add-bottom\">\n\t\t\t\t\t<div class=\"wf-block-content\">\n\t\t\t\t\t\t<ul class=\"wf-block-list\">\n\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\techo wfView::create('dashboard\/global-status', array(\n\t\t\t\t\t\t\t\t\t'firewall' => $firewall,\n\t\t\t\t\t\t\t\t\t'scanner' => $scanner,\n\t\t\t\t\t\t\t\t\t'dashboard' => $d,\n\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t<ul class=\"wf-block-list wf-block-list-horizontal wf-block-list-nowrap wf-waf-coverage\">\n\t\t\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\t\techo wfView::create('common\/status-detail', array(\n\t\t\t\t\t\t\t\t\t\t\t'id' => 'waf-coverage',\n\t\t\t\t\t\t\t\t\t\t\t'percentage' => $firewall->overallStatus(),\n\t\t\t\t\t\t\t\t\t\t\t'activeColor' => ($firewall->firewallMode() == wfFirewall::FIREWALL_MODE_LEARNING ? '#ececec' : null \/* automatic *\/),\n\t\t\t\t\t\t\t\t\t\t\t'title' => __('Firewall', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t'subtitle' => ($firewall->firewallMode() == wfFirewall::FIREWALL_MODE_LEARNING ? __('WAF Currently in Learning Mode', 'wordfence') : __('Protection from known and emerging threats', 'wordfence')),\n\t\t\t\t\t\t\t\t\t\t\t'link' => wfPage::pageURL(wfPage::PAGE_FIREWALL_OPTIONS, wfPage::PAGE_DASHBOARD),\n\t\t\t\t\t\t\t\t\t\t\t'linkLabel' => __('Manage Firewall', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t'statusTitle' => __('Firewall Status', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t'statusList' => $firewall->statusList(),\n\t\t\t\t\t\t\t\t\t\t\t'statusExtra' => ($firewall->firewallMode() == wfFirewall::FIREWALL_MODE_LEARNING ? wfView::create('waf\/status-tooltip-learning-mode')->render() : ''),\n\t\t\t\t\t\t\t\t\t\t\t'helpLink' => __('https:\/\/www.wordfence.com\/help\/dashboard\/#dashboard-status', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\t\techo wfView::create('common\/status-detail', array(\n\t\t\t\t\t\t\t\t\t\t\t'id' => 'wf-scanner-type',\n\t\t\t\t\t\t\t\t\t\t\t'percentage' => $scanner->scanTypeStatus(),\n\t\t\t\t\t\t\t\t\t\t\t'activeColor' => (!$scanner->isEnabled() ? '#ececec' : null \/* automatic *\/),\n\t\t\t\t\t\t\t\t\t\t\t'title' => __('Scan', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t'subtitle' => __('Detection of security issues', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t'link' => wfPage::pageURL(wfPage::PAGE_SCAN_OPTIONS, wfPage::PAGE_DASHBOARD),\n\t\t\t\t\t\t\t\t\t\t\t'linkLabel' => __('Manage Scan', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t'statusTitle' => __('Scan Status', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t'statusList' => $scanner->scanTypeStatusList(),\n\t\t\t\t\t\t\t\t\t\t\t'helpLink' => __('https:\/\/www.wordfence.com\/help\/dashboard\/#dashboard-status', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t\t\t<?php if (wfConfig::get('hasKeyConflict')): ?>\n\t\t\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\t\t\techo wfView::create('common\/status-critical', array(\n\t\t\t\t\t\t\t\t\t\t\t\t'id' => 'wf-premium-alert',\n\t\t\t\t\t\t\t\t\t\t\t\t'title' => __('Premium License Conflict', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t'subtitle' => __('License already in use', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t'link' => 'https:\/\/www.wordfence.com\/gnl1manageConflict\/manage-wordfence-api-keys\/',\n\t\t\t\t\t\t\t\t\t\t\t\t'linkLabel' => __('Reset License', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t'linkNewWindow' => true,\n\t\t\t\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t\t<?php elseif (wfConfig::get('keyType') == wfLicense::KEY_TYPE_PAID_EXPIRED): ?>\n\t\t\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\t\t\techo wfView::create('common\/status-critical', array(\n\t\t\t\t\t\t\t\t\t\t\t\t'id' => 'wf-premium-alert',\n\t\t\t\t\t\t\t\t\t\t\t\t'title' => __('Premium Protection Disabled', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t'subtitle' => __('License is expired', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t'link' => 'https:\/\/www.wordfence.com\/gnl1renewExpired\/manage-wordfence-api-keys\/',\n\t\t\t\t\t\t\t\t\t\t\t\t'linkLabel' => __('Renew License', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t'linkNewWindow' => true,\n\t\t\t\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t\t<?php elseif (wfConfig::get('keyType') == wfLicense::KEY_TYPE_PAID_DELETED): ?>\n\t\t\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\t\t\techo wfView::create('common\/status-critical', array(\n\t\t\t\t\t\t\t\t\t\t\t\t'id' => 'wf-premium-alert',\n\t\t\t\t\t\t\t\t\t\t\t\t'title' => __('Premium Protection Disabled', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t'subtitleHtml' => wp_kses(__('The license you were using has been removed from your account. Please reach out to <a href=\"mailto:billing@wordfence.com\">billing@wordfence.com<\/a> or create a Premium support case at <a href=\"https:\/\/support.wordfence.com\/support\/tickets\" target=\"_blank\">https:\/\/support.wordfence.com\/support\/tickets<span class=\"screen-reader-text\"> (opens in new tab)<\/span><\/a> for more information. Our staff is happy to help.', 'wordfence'), array('a'=>array('href'=>array(), 'target'=>array()), 'span'=>array('class'=>array()))),\n\t\t\t\t\t\t\t\t\t\t\t\t'link' => null,\n\t\t\t\t\t\t\t\t\t\t\t\t'linkLabel' => null\n\t\t\t\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t\t<?php elseif (wfConfig::get('keyType') == wfLicense::KEY_TYPE_FREE || wfConfig::get('keyType') === false): ?>\n\t\t\t\t\t\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t\t\t\t\t\t<p><h3><?php esc_html_e('Premium Protection Disabled', 'wordfence'); ?><\/h3><\/p>\n\t\t\t\t\t\t\t\t\t\t\t\t<p><?php esc_html_e('As a free Wordfence user, you are currently using the Community version of the Threat Defense Feed. Premium users are protected by additional firewall rules and malware signatures. Upgrade to Premium today to improve your protection.', 'wordfence'); ?><\/p>\n\t\t\t\t\t\t\t\t\t\t\t\t<p><a class=\"wf-btn wf-btn-primary wf-btn-callout-subtle\" href=\"https:\/\/www.wordfence.com\/gnl1dashboardUpgrade\/products\/wordfence-premium\/\" target=\"_blank\" rel=\"noopener noreferrer\"><?php esc_html_e('Upgrade to Premium', 'wordfence'); ?><\/a>&nbsp;&nbsp;<a class=\"wf-btn wf-btn-callout-subtle wf-btn-default\" href=\"https:\/\/www.wordfence.com\/gnl1dashboardLearn\/products\/pricing\/\" target=\"_blank\" rel=\"noopener noreferrer\"><?php esc_html_e('Learn More', 'wordfence'); ?><span class=\"screen-reader-text\"> (<?php esc_html_e('opens in new tab', 'wordfence') ?>)<\/span><\/a><\/p>\n\t\t\t\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t\t\t\t<?php elseif (wfConfig::get('keyExpDays') < 30 && (wfConfig::get('premiumAutoRenew', null) === '0' || wfConfig::get('premiumAutoRenew', null) === 0)): ?>\n\t\t\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\t\t\techo wfView::create('common\/status-critical', array(\n\t\t\t\t\t\t\t\t\t\t\t\t'id' => 'wf-premium-alert',\n\t\t\t\t\t\t\t\t\t\t\t\t'title' => sprintf(\/* translators: %s: License type *\/__('%s License Expiring', 'wordfence'), wfLicense::current()->getBaseTypeLabel()),\n\t\t\t\t\t\t\t\t\t\t\t\t'subtitle' => __('Auto-renew is disabled', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t'link' => 'https:\/\/www.wordfence.com\/gnl1renewExpiring\/manage-wordfence-api-keys\/',\n\t\t\t\t\t\t\t\t\t\t\t\t'linkLabel' => __('Renew License', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t'linkNewWindow' => true,\n\t\t\t\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t\t<?php elseif (wfConfig::get('keyExpDays') < 30): ?>\n\t\t\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\t\t\tif (wfConfig::get('premiumPaymentExpiring')) {\n\t\t\t\t\t\t\t\t\t\t\t\t$title = __('Payment Method Expiring', 'wordfence');\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse if (wfConfig::get('premiumPaymentExpired')) {\n\t\t\t\t\t\t\t\t\t\t\t\t$title = __('Payment Method Expired', 'wordfence');\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse if (wfConfig::get('premiumPaymentMissing')) {\n\t\t\t\t\t\t\t\t\t\t\t\t$title = __('Payment Method Missing', 'wordfence');\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse if (wfConfig::get('premiumPaymentHold')) {\n\t\t\t\t\t\t\t\t\t\t\t\t$title = __('Payment Method Invalid', 'wordfence');\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tif (isset($title)) {\n\t\t\t\t\t\t\t\t\t\t\t\t$days = floor(((int) wfConfig::get('premiumNextRenew') - time()) \/ 86400);\n\t\t\t\t\t\t\t\t\t\t\t\tif ($days <= 0) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t$subtitle = __('License renews today', 'wordfence');\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\telse if ($days == 1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t$subtitle = __('License renews tomorrow', 'wordfence');\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t$subtitle = sprintf(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\/* translators: Number of days *\/\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__('License renews in %d days', 'wordfence'), $days);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\techo wfView::create('dashboard\/status-payment-expiring', array(\n\t\t\t\t\t\t\t\t\t\t\t\t\t'id' => 'wf-premium-alert',\n\t\t\t\t\t\t\t\t\t\t\t\t\t'title' => $title,\n\t\t\t\t\t\t\t\t\t\t\t\t\t'subtitle' => $subtitle,\n\t\t\t\t\t\t\t\t\t\t\t\t\t'link' => 'https:\/\/www.wordfence.com\/gnl1renewExpiring\/manage-wordfence-api-keys\/',\n\t\t\t\t\t\t\t\t\t\t\t\t\t'linkLabel' => __('Update Payment Method', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t\t'linkNewWindow' => true,\n\t\t\t\t\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t$days = floor(((int) wfConfig::get('premiumNextRenew') - time()) \/ 86400);\n\t\t\t\t\t\t\t\t\t\t\t\tif ($days == 0) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t$subtitle = __('License renews today', 'wordfence');\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\telse if ($days == 1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t$subtitle = __('License renews in 1 day', 'wordfence');\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t$subtitle = sprintf(__('License renews in %d days', 'wordfence'), $days);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\techo wfView::create('dashboard\/status-renewing', array(\n\t\t\t\t\t\t\t\t\t\t\t\t\t'id' => 'wf-premium-alert',\n\t\t\t\t\t\t\t\t\t\t\t\t\t'title' => sprintf(\/* translators: %s: License type *\/__('%s License Expiring', 'wordfence'), wfLicense::current()->getBaseTypeLabel()),\n\t\t\t\t\t\t\t\t\t\t\t\t\t'subtitle' => $subtitle,\n\t\t\t\t\t\t\t\t\t\t\t\t\t'link' => 'https:\/\/www.wordfence.com\/gnl1reviewExpiring\/manage-wordfence-api-keys\/',\n\t\t\t\t\t\t\t\t\t\t\t\t\t'linkLabel' => __('Review Payment Method', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t\t'linkNewWindow' => true,\n\t\t\t\t\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t\t<?php elseif (wfLicense::current()->isPaidAndCurrent()): ?>\n\t\t\t\t\t\t\t\t\t\t\t<div class=\"wf-block-labeled-value wf-protection-status wf-protection-status-<?php echo esc_attr($firewall->ruleMode()); ?>\">\n\t\t\t\t\t\t\t\t\t\t\t\t<div class=\"wf-block-labeled-value-value\"><i class=\"wf-fa wf-fa-check\" aria-hidden=\"true\"><\/i><\/div>\n\t\t\t\t\t\t\t\t\t\t\t\t<div class=\"wf-block-labeled-value-label\"><?php echo esc_html(sprintf(__('%s Enabled', 'wordfence'), wfLicense::current()->getTypeLabel(true))); ?><\/div>\n\t\t\t\t\t\t\t\t\t\t\t\t<?php if (wfLicense::current()->isBelowResponse()): ?>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<p>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<?php if (wfLicense::current()->isBelowCare()): ?>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<a href=\"https:\/\/www.wordfence.com\/gnl1dashboardLearnCareResponse\/products\/pricing\/\"><?php esc_html_e('Learn about Wordfence Care and Wordfence Response', 'wordfence') ?><\/a>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<?php else: ?>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<a href=\"https:\/\/www.wordfence.com\/gnl1dashboardLearnResponse\/products\/wordfence-response\/\"><?php esc_html_e('Learn about Wordfence Response', 'wordfence') ?><\/a>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<?php endif ?>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<\/p>\n\t\t\t\t\t\t\t\t\t\t\t\t<?php endif ?>\n\t\t\t\t\t\t\t\t\t\t\t<\/div> \n\t\t\t\t\t\t\t\t\t\t<?php endif; ?>\n\t\t\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t\t<\/ul>\n\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t<\/ul>\n\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t<\/div>\n\t\t<\/div>\n\t\t<!-- begin notifications -->\n\t\t<?php include(dirname(__FILE__) . '\/dashboard\/widget_notifications.php'); ?>\n\t\t<!-- end notifications -->\n\t\t<div class=\"wf-row\">\n\t\t\t<div class=\"wf-col-xs-12\">\n\t\t\t\t<div class=\"wf-block wf-active wf-add-bottom\">\n\t\t\t\t\t<div class=\"wf-block-content\">\n\t\t\t\t\t\t<ul class=\"wf-block-list\">\n\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t<ul class=\"wf-block-list wf-block-list-horizontal wf-dashboard-navigation\">\n\t\t\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\t\techo wfView::create('common\/block-navigation-option', array(\n\t\t\t\t\t\t\t\t\t\t\t'id' => 'wf-dashboard-option-tools',\n\t\t\t\t\t\t\t\t\t\t\t'img' => 'tools.svg',\n\t\t\t\t\t\t\t\t\t\t\t'title' => __('Tools', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t'subtitle' => __('Live Traffic, Whois Lookup, Import\/Export, and Diagnostics', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t'link' => network_admin_url('admin.php?page=WordfenceTools'),\n\t\t\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\t\techo wfView::create('common\/block-navigation-option', array(\n\t\t\t\t\t\t\t\t\t\t\t'id' => 'wf-dashboard-option-support',\n\t\t\t\t\t\t\t\t\t\t\t'img' => 'support.svg',\n\t\t\t\t\t\t\t\t\t\t\t'title' => __('Help', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t'subtitle' => __('Find the documentation and help you need', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t'link' => network_admin_url('admin.php?page=WordfenceSupport'),\n\t\t\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\t\techo wfView::create('common\/block-navigation-option', array(\n\t\t\t\t\t\t\t\t\t\t\t'id' => 'wf-dashboard-option-options',\n\t\t\t\t\t\t\t\t\t\t\t'img' => 'options.svg',\n\t\t\t\t\t\t\t\t\t\t\t'title' => __('Global Options', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t'subtitle' => __('Manage global options for Wordfence such as alerts, premium status, and more', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t'link' => network_admin_url('admin.php?page=Wordfence&subpage=global_options'),\n\t\t\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t\t<\/ul>\n\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t<\/ul>\n\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t<\/div>\n\t\t<\/div>\n\t\t<div class=\"wf-row\">\n\t\t\t<div class=\"wf-col-xs-12 wf-col-lg-6 wf-col-lg-half-padding-right\">\n\t\t\t\t<!-- begin firewall summary site -->\n\t\t\t\t<?php include(dirname(__FILE__) . '\/dashboard\/widget_localattacks.php'); ?>\n\t\t\t\t<!-- end firewall summary site -->\n\t\t\t<\/div> <!-- end content block -->\n\t\t\t<div class=\"wf-col-xs-12 wf-col-lg-6 wf-col-lg-half-padding-left\">\n\t\t\t\t<!-- begin total attacks blocked network -->\n\t\t\t\t<?php include(dirname(__FILE__) . '\/dashboard\/widget_networkattacks.php'); ?>\n\t\t\t\t<!-- end total attacks blocked network -->\n\t\t\t<\/div> <!-- end content block -->\n\t\t<\/div> <!-- end row -->\n\t<\/div> <!-- end container -->\n<\/div>\n\n<?php if (wfOnboardingController::willShowNewTour(wfOnboardingController::TOUR_DASHBOARD)): ?>\n<script type=\"application\/javascript\">\n\t(function($) {\n\t\t$(function() {\n\t\t\tWFAD.tour1 = function() {\n\t\t\t\tWFAD.tour('wfNewTour1', 'wfStatusTourMarker', 'top', 'left', null, WFAD.tour2);\n\t\t\t};\n\t\t\tWFAD.tour2 = function() {\n\t\t\t\tWFAD.tour('wfNewTour2', 'waf-coverage', 'top', 'left', WFAD.tour1, WFAD.tour3);\n\t\t\t};\n\t\t\tWFAD.tour3 = function() {\n\t\t\t\tWFAD.tour('wfNewTour3', 'wf-dashboard-option-options', 'right', 'right', WFAD.tour2, WFAD.tourComplete);\n\t\t\t};\n\t\t\tWFAD.tourComplete = function() { WFAD.tourFinish('<?php echo esc_attr(wfOnboardingController::TOUR_DASHBOARD); ?>'); };\n\t\t\t\n\t\t\t<?php if (wfOnboardingController::shouldShowNewTour(wfOnboardingController::TOUR_DASHBOARD) && !isset($_GET['onboarding'])): ?>\n\t\t\tif (!WFAD.isSmallScreen) { WFAD.tour1(); }\n\t\t\t<?php endif; ?>\n\t\t});\n\t})(jQuery);\n<\/script>\n\n<script type=\"text\/x-jquery-template\" id=\"wfNewTour1\">\n\t<div>\n\t\t<h3><?php esc_html_e('This is your Dashboard', 'wordfence'); ?><\/h3>\n\t\t<p><?php esc_html_e('The Wordfence Dashboard provides valuable insights into the current state of your site\\'s security. You\\'ll find useful data summarized here as well as important status updates and notifications.', 'wordfence'); ?><\/p>\n\t\t<div class=\"wf-pointer-footer\">\n\t\t\t<ul class=\"wf-tour-pagination\">\n\t\t\t\t<li class=\"wf-active\">&bullet;<\/li>\n\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t<li>&bullet;<\/li>\n\t\t\t<\/ul>\n\t\t\t<div id=\"wf-tour-continue\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-primary\" role=\"button\"><?php esc_html_e('Next', 'wordfence'); ?><\/a><\/div>\n\t\t<\/div>\n\t\t<div id=\"wf-tour-close\"><a href=\"#\" role=\"button\"><i class=\"wf-fa wf-fa-times-circle\" aria-hidden=\"true\"><\/i><\/a><\/div>\n\t<\/div>\n<\/script>\n<script type=\"text\/x-jquery-template\" id=\"wfNewTour2\">\n\t<div>\n\t\t<h3><?php esc_html_e('Easily Monitor Your Wordfence Protection', 'wordfence'); ?><\/h3>\n\t\t<p><?php esc_html_e('Each feature contains a status that reminds you what\\'s enabled, disabled or needs attention. The Notifications section will highlight actions you need to take.', 'wordfence'); ?><\/p>\n\t\t<div class=\"wf-pointer-footer\">\n\t\t\t<ul class=\"wf-tour-pagination\">\n\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t<li class=\"wf-active\">&bullet;<\/li>\n\t\t\t\t<li>&bullet;<\/li>\n\t\t\t<\/ul>\n\t\t\t<div id=\"wf-tour-previous\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-default\" role=\"button\"><?php esc_html_e('Previous', 'wordfence'); ?><\/a><\/div>\n\t\t\t<div id=\"wf-tour-continue\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-primary\" role=\"button\"><?php esc_html_e('Next', 'wordfence'); ?><\/a><\/div>\n\t\t<\/div>\n\t\t<div id=\"wf-tour-close\"><a href=\"#\" role=\"button\"><i class=\"wf-fa wf-fa-times-circle\" aria-hidden=\"true\"><\/i><\/a><\/div>\n\t<\/div>\n<\/script>\n<script type=\"text\/x-jquery-template\" id=\"wfNewTour3\">\n\t<div>\n\t\t<h3><?php esc_html_e('Global Wordfence Options', 'wordfence'); ?><\/h3>\n\t\t<p class=\"wf-center\"><svg viewBox=\"0 0 100.11 100.11\" class=\"wf-icon\"><path d=\"M99.59,41.42a2.06,2.06,0,0,0-1.37-.82L86.3,38.78a39.34,39.34,0,0,0-2.67-6.39q1.17-1.63,3.52-4.6t3.32-4.33A2.52,2.52,0,0,0,91,22a2.1,2.1,0,0,0-.46-1.43Q88.18,17.2,79.78,9.45a2.52,2.52,0,0,0-1.63-.65,2.12,2.12,0,0,0-1.57.59l-9.25,7a40.09,40.09,0,0,0-5.87-2.41L59.64,2a1.92,1.92,0,0,0-.75-1.4A2.46,2.46,0,0,0,57.29,0H42.82a2.19,2.19,0,0,0-2.34,1.82,106,106,0,0,0-1.89,12.12,37.62,37.62,0,0,0-5.93,2.48l-9-7A2.78,2.78,0,0,0,22,8.8q-1.44,0-6.16,4.66a64.88,64.88,0,0,0-6.42,7A2.75,2.75,0,0,0,8.8,22a2.44,2.44,0,0,0,.65,1.56q4.37,5.28,7,9a32.38,32.38,0,0,0-2.54,6L1.76,40.34a2,2,0,0,0-1.24.85A2.5,2.5,0,0,0,0,42.69V57.16a2.44,2.44,0,0,0,.52,1.53,2,2,0,0,0,1.37.82l11.93,1.76a31.91,31.91,0,0,0,2.67,6.45Q15.31,69.35,13,72.31T9.65,76.65a2.54,2.54,0,0,0-.07,3q2.54,3.52,10.75,11a2.25,2.25,0,0,0,1.63.71,2.35,2.35,0,0,0,1.63-.59l9.19-7a40.54,40.54,0,0,0,5.87,2.41l1.82,12a1.92,1.92,0,0,0,.75,1.4,2.45,2.45,0,0,0,1.6.55H57.29a2.2,2.2,0,0,0,2.35-1.82,107.41,107.41,0,0,0,1.89-12.12,37.19,37.19,0,0,0,5.93-2.48l9,7a3.18,3.18,0,0,0,1.69.59q1.43,0,6.13-4.62a65.86,65.86,0,0,0,6.45-7,2.16,2.16,0,0,0,.59-1.5,2.51,2.51,0,0,0-.65-1.63q-4.69-5.74-7-9a41.57,41.57,0,0,0,2.54-5.93l12.06-1.82a2,2,0,0,0,1.3-.85,2.52,2.52,0,0,0,.52-1.5V43a2.46,2.46,0,0,0-.52-1.53ZM61.85,61.86a16.08,16.08,0,0,1-11.8,4.89A16.69,16.69,0,0,1,33.37,50.06,16.69,16.69,0,0,1,50.06,33.37,16.69,16.69,0,0,1,66.74,50.06a16.08,16.08,0,0,1-4.89,11.8Zm0,0\"><\/path><\/svg><\/p>\n\t\t<p><?php echo wp_kses(__('You\\'ll find this icon throughout the plugin. Clicking it will show you the options and features for each section of Wordfence. From the dashboard, you can find the <strong>Global Options<\/strong> for Wordfence such as alerts, automatic updates, and managing your site\\'s Premium License.', 'wordfence'), array('strong'=>array())); ?><\/p>\n\t\t<div class=\"wf-pointer-footer\">\n\t\t\t<ul class=\"wf-tour-pagination\">\n\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t<li class=\"wf-active\">&bullet;<\/li>\n\t\t\t<\/ul>\n\t\t\t<div id=\"wf-tour-previous\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-default\" role=\"button\"><?php esc_html_e('Previous', 'wordfence'); ?><\/a><\/div>\n\t\t\t<div id=\"wf-tour-continue\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-primary\" role=\"button\"><?php esc_html_e('Got it', 'wordfence'); ?><\/a><\/div>\n\t\t<\/div>\n\t\t<div id=\"wf-tour-close\"><a href=\"#\" role=\"button\"><i class=\"wf-fa wf-fa-times-circle\" aria-hidden=\"true\"><\/i><\/a><\/div>\n\t<\/div>\n<\/script>\n<?php endif; ?>\n\n<?php if (wfOnboardingController::willShowUpgradeTour(wfOnboardingController::TOUR_DASHBOARD)): ?>\n<script type=\"application\/javascript\">\n\t(function($) {\n\t\t$(function() {\n\t\t\tWFAD.tour1 = function() {\n\t\t\t\tWFAD.tour('wfUpgradeTour1', 'wfStatusTourMarker', 'top', 'left', null, WFAD.tour2);\n\t\t\t};\n\t\t\tWFAD.tour2 = function() {\n\t\t\t\tWFAD.tour('wfUpgradeTour2', 'waf-coverage', 'top', 'left', WFAD.tour1, WFAD.tour3);\n\t\t\t};\n\t\t\tWFAD.tour3 = function() {\n\t\t\t\tWFAD.tour('wfUpgradeTour3', 'wf-dashboard-option-options', 'right', 'right', WFAD.tour2, WFAD.tour4);\n\t\t\t};\n\t\t\tWFAD.tour4 = function() {\n\t\t\t\tWFAD.tour('wfUpgradeTour4', 'toplevel_page_Wordfence', 'left', 'left', WFAD.tour3, WFAD.tourComplete);\n\t\t\t};\n\t\t\tWFAD.tourComplete = function() { WFAD.tourFinish('<?php echo esc_attr(wfOnboardingController::TOUR_DASHBOARD); ?>'); };\n\t\t\t\n\t\t\t<?php if (wfOnboardingController::shouldShowUpgradeTour(wfOnboardingController::TOUR_DASHBOARD) && !isset($_GET['onboarding'])): ?>\n\t\t\tif (!WFAD.isSmallScreen) { WFAD.tour1(); }\n\t\t\t<?php endif; ?>\n\t\t});\n\t})(jQuery);\n<\/script>\n\n<script type=\"text\/x-jquery-template\" id=\"wfUpgradeTour1\">\n\t<div>\n\t\t<h3><?php printf(\n\t\t\t\t\/* translators: Wordfence version. *\/\n\t\t\t\tesc_html__('You have successfully updated to Wordfence %s', 'wordfence'), WORDFENCE_VERSION); ?><\/h3>\n\t\t<p><?php esc_html_e('This update includes a number of significant interface changes. We\\'d like to walk you through  some of them, but you can bypass the tour for a section at any time by closing the dialogs.', 'wordfence'); ?><\/p>\n\t\t<p><?php echo wp_kses(__('We welcome your feedback and comments at <a href=\"mailto:feedback@wordfence.com\">feedback@wordfence.com<\/a>. For a deeper dive on all of the changes, <a href=\"https:\/\/www.wordfence.com\/blog\/2018\/01\/introducing-wordfence-7\/\" target=\"_blank\" rel=\"noopener noreferrer\">click here<span class=\"screen-reader-text\"> (opens in new tab)<\/span><\/a>.', 'wordfence'), array('a'=>array('href'=>array(), 'target'=>array()), 'span'=>array('class'=>array()))); ?><\/p>\n\t\t<div class=\"wf-pointer-footer\">\n\t\t\t<ul class=\"wf-tour-pagination\">\n\t\t\t\t<li class=\"wf-active\">&bullet;<\/li>\n\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t<li>&bullet;<\/li>\n\t\t\t<\/ul>\n\t\t\t<div id=\"wf-tour-continue\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-primary\" role=\"button\"><?php esc_html_e('Next', 'wordfence'); ?><\/a><\/div>\n\t\t<\/div>\n\t\t<div id=\"wf-tour-close\"><a href=\"#\" role=\"button\"><i class=\"wf-fa wf-fa-times-circle\" aria-hidden=\"true\"><\/i><\/a><\/div>\n\t<\/div>\n<\/script>\n<script type=\"text\/x-jquery-template\" id=\"wfUpgradeTour2\">\n\t<div>\n\t\t<h3><?php esc_html_e('Monitor Your Wordfence Protection', 'wordfence'); ?><\/h3>\n\t\t<p><?php esc_html_e('Each feature contains a status percentage reminding you at a high level of what\\'s enabled, disabled, or needing your attention. The Notifications section highlights actions you need to take.', 'wordfence'); ?><\/p>\n\t\t<div class=\"wf-pointer-footer\">\n\t\t\t<ul class=\"wf-tour-pagination\">\n\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t<li class=\"wf-active\">&bullet;<\/li>\n\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t<li>&bullet;<\/li>\n\t\t\t<\/ul>\n\t\t\t<div id=\"wf-tour-previous\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-default\" role=\"button\"><?php esc_html_e('Previous', 'wordfence'); ?><\/a><\/div>\n\t\t\t<div id=\"wf-tour-continue\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-primary\" role=\"button\"><?php esc_html_e('Next', 'wordfence'); ?><\/a><\/div>\n\t\t<\/div>\n\t\t<div id=\"wf-tour-close\"><a href=\"#\" role=\"button\"><i class=\"wf-fa wf-fa-times-circle\" aria-hidden=\"true\"><\/i><\/a><\/div>\n\t<\/div>\n<\/script>\n<script type=\"text\/x-jquery-template\" id=\"wfUpgradeTour3\">\n\t<div>\n\t\t<h3><?php esc_html_e('Global Wordfence Options', 'wordfence'); ?><\/h3>\n\t\t<p class=\"wf-center\"><svg viewBox=\"0 0 100.11 100.11\" class=\"wf-icon\"><path d=\"M99.59,41.42a2.06,2.06,0,0,0-1.37-.82L86.3,38.78a39.34,39.34,0,0,0-2.67-6.39q1.17-1.63,3.52-4.6t3.32-4.33A2.52,2.52,0,0,0,91,22a2.1,2.1,0,0,0-.46-1.43Q88.18,17.2,79.78,9.45a2.52,2.52,0,0,0-1.63-.65,2.12,2.12,0,0,0-1.57.59l-9.25,7a40.09,40.09,0,0,0-5.87-2.41L59.64,2a1.92,1.92,0,0,0-.75-1.4A2.46,2.46,0,0,0,57.29,0H42.82a2.19,2.19,0,0,0-2.34,1.82,106,106,0,0,0-1.89,12.12,37.62,37.62,0,0,0-5.93,2.48l-9-7A2.78,2.78,0,0,0,22,8.8q-1.44,0-6.16,4.66a64.88,64.88,0,0,0-6.42,7A2.75,2.75,0,0,0,8.8,22a2.44,2.44,0,0,0,.65,1.56q4.37,5.28,7,9a32.38,32.38,0,0,0-2.54,6L1.76,40.34a2,2,0,0,0-1.24.85A2.5,2.5,0,0,0,0,42.69V57.16a2.44,2.44,0,0,0,.52,1.53,2,2,0,0,0,1.37.82l11.93,1.76a31.91,31.91,0,0,0,2.67,6.45Q15.31,69.35,13,72.31T9.65,76.65a2.54,2.54,0,0,0-.07,3q2.54,3.52,10.75,11a2.25,2.25,0,0,0,1.63.71,2.35,2.35,0,0,0,1.63-.59l9.19-7a40.54,40.54,0,0,0,5.87,2.41l1.82,12a1.92,1.92,0,0,0,.75,1.4,2.45,2.45,0,0,0,1.6.55H57.29a2.2,2.2,0,0,0,2.35-1.82,107.41,107.41,0,0,0,1.89-12.12,37.19,37.19,0,0,0,5.93-2.48l9,7a3.18,3.18,0,0,0,1.69.59q1.43,0,6.13-4.62a65.86,65.86,0,0,0,6.45-7,2.16,2.16,0,0,0,.59-1.5,2.51,2.51,0,0,0-.65-1.63q-4.69-5.74-7-9a41.57,41.57,0,0,0,2.54-5.93l12.06-1.82a2,2,0,0,0,1.3-.85,2.52,2.52,0,0,0,.52-1.5V43a2.46,2.46,0,0,0-.52-1.53ZM61.85,61.86a16.08,16.08,0,0,1-11.8,4.89A16.69,16.69,0,0,1,33.37,50.06,16.69,16.69,0,0,1,50.06,33.37,16.69,16.69,0,0,1,66.74,50.06a16.08,16.08,0,0,1-4.89,11.8Zm0,0\"><\/path><\/svg><\/p>\n\t\t<p><?php esc_html_e('Manage your Wordfence license, see alerts and automatic plugin updates, and import\/export your settings.', 'wordfence'); ?><\/p>\n\t\t<div class=\"wf-pointer-footer\">\n\t\t\t<ul class=\"wf-tour-pagination\">\n\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t<li class=\"wf-active\">&bullet;<\/li>\n\t\t\t\t<li>&bullet;<\/li>\n\t\t\t<\/ul>\n\t\t\t<div id=\"wf-tour-previous\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-default\" role=\"button\"><?php esc_html_e('Previous', 'wordfence'); ?><\/a><\/div>\n\t\t\t<div id=\"wf-tour-continue\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-primary\" role=\"button\"><?php esc_html_e('Next', 'wordfence'); ?><\/a><\/div>\n\t\t<\/div>\n\t\t<div id=\"wf-tour-close\"><a href=\"#\" role=\"button\"><i class=\"wf-fa wf-fa-times-circle\" aria-hidden=\"true\"><\/i><\/a><\/div>\n\t<\/div>\n<\/script>\n<script type=\"text\/x-jquery-template\" id=\"wfUpgradeTour4\">\n\t<div>\n\t\t<h3><?php esc_html_e('Updated Navigation', 'wordfence'); ?><\/h3>\n\t\t<p><?php echo wp_kses(__('The main navigation no longer includes an <strong>Options<\/strong> link. Options are now accessed via the <strong>Options<\/strong> link on each feature\\'s main page. Live Traffic is now located in the Tools section, and blocking is found under the Firewall. Shortcuts to add a <strong>Blocking<\/strong> link back to the main navigation are available under Blocking options.', 'wordfence'), array('strong'=>array())); ?><\/p>\n\t\t<div class=\"wf-pointer-footer\">\n\t\t\t<ul class=\"wf-tour-pagination\">\n\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t<li class=\"wf-active\">&bullet;<\/li>\n\t\t\t<\/ul>\n\t\t\t<div id=\"wf-tour-previous\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-default\" role=\"button\"><?php esc_html_e('Previous', 'wordfence'); ?><\/a><\/div>\n\t\t\t<div id=\"wf-tour-continue\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-primary\" role=\"button\"><?php esc_html_e('Got it', 'wordfence'); ?><\/a><\/div>\n\t\t<\/div>\n\t\t<div id=\"wf-tour-close\"><a href=\"#\" role=\"button\"><i class=\"wf-fa wf-fa-times-circle\" aria-hidden=\"true\"><\/i><\/a><\/div>\n\t<\/div>\n<\/script>\n<?php endif; ?>\n<?php\n$hostSetting = false;\n$recordAll = wfConfig::liveTrafficEnabled($hostSetting);\n\nif ($recordAll && !$hostSetting && !wfUtils::truthyToBoolean(wfConfig::get('switchLiveTrafficSecurityOnlyChoice'))):\n?>\n<script type=\"application\/javascript\">\n\t(function($) {\n\t\t$(function() {\n\t\t\tvar prompt = $('#wfLiveTrafficMigration').tmpl();\n\t\t\tvar promptHTML = $(\"<div \/>\").append(prompt).html();\n\t\t\tWFAD.colorboxHTML((WFAD.isSmallScreen ? '300px' : '700px'), promptHTML, {overlayClose: false, closeButton: false, className: 'wf-modal', onComplete: function() {\n\t\t\t\t$('#wf-livetrafficmigrate-no').on('click', function(e) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\te.stopPropagation();\n\n\t\t\t\t\twordfenceExt.switchLiveTrafficSecurityOnlyChoice('no');\n\t\t\t\t\tWFAD.colorboxClose();\n\t\t\t\t});\n\n\t\t\t\t$('#wf-livetrafficmigrate-yes').on('click', function(e) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\te.stopPropagation();\n\n\t\t\t\t\twordfenceExt.switchLiveTrafficSecurityOnlyChoice('yes');\n\t\t\t\t\tWFAD.colorboxClose();\n\t\t\t\t});\n\t\t\t}});\n\t\t});\n\t})(jQuery);\n<\/script>\n<script type=\"text\/x-jquery-template\" id=\"wfLiveTrafficMigration\">\n\t<?php\n\techo wfView::create('common\/modal-prompt', array(\n\t\t'title' => __('Recommended Settings Change', 'wordfence'),\n\t\t'messageHTML' => '<p>' . esc_html__('Greetings! The default configuration for Wordfence Live Traffic has changed. The new default saves only logins and blocked requests, while this site is currently recording all traffic. Would you like to change to the new default?', 'wordfence') . '<\/p>' . (!wfRateLimit::identicalHumanBotRateLimits() ? '<p>' . __('Rate limiting based on type of request (human vs crawler) may be less accurate because this prevents loading the extra JavaScript used for that identification.', 'wordfence') . '<\/p>' : ''),\n\t\t'primaryButton' => array('id' => 'wf-livetrafficmigrate-yes', 'label' => __('Yes Please', 'wordfence'), 'link' => '#', 'type' => 'wf-btn-primary'),\n\t\t'secondaryButtons' => array(\n\t\t\tarray('id' => 'wf-livetrafficmigrate-no', 'label' => __('No Thanks', 'wordfence'), 'link' => '#', 'type' => 'wf-btn-default'),\n\t\t\tarray('id' => 'wf-livetrafficmigrate-learn', 'label' => __('Learn More', 'wordfence'), 'link' => wfSupportController::supportURL(wfSupportController::ITEM_NOTICE_SWITCH_LIVE_TRAFFIC), 'type' => 'wf-btn-default', 'target' => '_blank', 'rel' => 'noopener noreferrer'),\n\t\t),\n\t))->render();\n\t?>\n<\/script>\n<?php endif; ?>"},{"base":"plugins","rel":"wordfence\/lib\/wfCurlInterceptor.php","ext":"php","size":1047,"mtime":1757312769,"type":"text","content":"<?php\n\nclass wfCurlInterceptionFailedException extends RuntimeException {\n}\n\nclass wfCurlInterceptor {\n\n\tconst HOOK_NAME = 'http_api_curl';\n\n\tprivate $handle = null;\n\tprivate $options = array();\n\tprivate $requireInterception;\n\n\tpublic function __construct($requireInterception = true) {\n\t\t$this->requireInterception = $requireInterception;\n\t}\n\n\tprivate function reset() {\n\t\t$this->handle = null;\n\t}\n\n\tpublic function setOption($option, $value) {\n\t\t$this->options[$option] = $value;\n\t}\n\n\tpublic function getHandle() {\n\t\treturn $this->handle;\n\t}\n\n\tpublic function handleHook($handle) {\n\t\t$this->handle = $handle;\n\t\tcurl_setopt_array($handle, $this->options);\n\t}\n\n\tpublic function intercept($callable) {\n\t\t$this->reset();\n\t\t$action = array($this, 'handleHook');\n\t\tadd_action(self::HOOK_NAME, $action);\n\t\t$result = $callable();\n\t\tif ($this->handle === null && $this->requireInterception)\n\t\t\tthrow new wfCurlInterceptionFailedException('Hook was not invoked with a valid cURL handle');\n\t\tremove_action(self::HOOK_NAME, $action);\n\t\treturn $result;\n\t}\n\n}"},{"base":"plugins","rel":"wordfence\/lib\/menu_scanner.php","ext":"php","size":22114,"mtime":1757312769,"type":"text","content":"<?php\nif (!defined('WORDFENCE_VERSION')) { exit; }\n$scanner = wfScanner::shared();\n$issues = wfIssues::shared();\n$dashboard = new wfDashboard();\n?>\n<?php if (wfConfig::get('liveActivityPauseEnabled')): ?>\n\t<div id=\"wfLiveTrafficOverlayAnchor\"><\/div>\n\t<div id=\"wfLiveTrafficDisabledMessage\">\n\t\t<h2><?php echo wp_kses(__('Status Updates Paused<br \/><small>Click inside window to resume<\/small>', 'wordfence'), array('small'=>array(), 'br'=>array())); ?><\/h2>\n\t<\/div>\n<?php endif; ?>\n<?php\nif (!wfOnboardingController::shouldShowAttempt3() && wfConfig::get('touppPromptNeeded')) {\n\techo wfView::create('gdpr\/disabled-overlay')->render();\n\techo wfView::create('gdpr\/banner')->render();\n}\n?>\n<div id=\"wordfenceMode_scan\"><\/div>\n<div class=\"wrap wordfence\">\n\t<div class=\"wf-container-fluid\">\n\t\t<div class=\"wf-row\">\n\t\t\t<div class=\"wf-col-xs-12\">\n\t\t\t\t<div class=\"wp-header-end\"><\/div> \n\t\t\t\t<?php\n\t\t\t\techo wfView::create('common\/section-title', array(\n\t\t\t\t\t'title' => __('Scan', 'wordfence'),\n\t\t\t\t\t'headerID' => 'wf-section-scan',\n\t\t\t\t\t'helpLink' => wfSupportController::supportURL(wfSupportController::ITEM_SCAN),\n\t\t\t\t\t'helpLabelHTML' => wp_kses(__('Learn more<span class=\"wf-hidden-xs\"> about the Scanner<\/span>', 'wordfence'), array('span'=>array('class'=>array()))),\n\t\t\t\t\t'showIcon' => true,\n\t\t\t\t))->render();\n\t\t\t\t?>\n\t\t\t<\/div>\n\t\t\t<div class=\"wf-col-xs-12\">\n\t\t\t\t<div class=\"wf-block wf-active\">\n\t\t\t\t\t<div class=\"wf-block-content\">\n\t\t\t\t\t\t<ul class=\"wf-block-list\">\n\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\techo wfView::create('scanner\/scanner-status', array(\n\t\t\t\t\t\t\t\t\t'scanner' => $scanner,\n\t\t\t\t\t\t\t\t\t'dashboard' => $dashboard,\n\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t<ul class=\"wf-block-list wf-block-list-horizontal wf-block-list-nowrap wf-scanner-coverage\">\n\t\t\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\t\tif (function_exists('network_admin_url') && is_multisite()) { $optionsURL = network_admin_url('admin.php?page=WordfenceScan&subpage=scan_options'); }\n\t\t\t\t\t\t\t\t\t\telse { $optionsURL = admin_url('admin.php?page=WordfenceScan&subpage=scan_options'); }\n\t\t\t\t\t\t\t\t\t\techo wfView::create('common\/status-detail', array(\n\t\t\t\t\t\t\t\t\t\t\t'id' => 'wf-scanner-type',\n\t\t\t\t\t\t\t\t\t\t\t'percentage' => $scanner->scanTypeStatus(),\n\t\t\t\t\t\t\t\t\t\t\t'activeColor' => (!$scanner->isEnabled() ? '#ececec' : null \/* automatic *\/),\n\t\t\t\t\t\t\t\t\t\t\t'title' => __('Scan Type: ', 'wordfence') . wfScanner::displayScanType($scanner->scanType()),\n\t\t\t\t\t\t\t\t\t\t\t'subtitle' => wfScanner::displayScanTypeDetail($scanner->scanType()),\n\t\t\t\t\t\t\t\t\t\t\t'link' => $optionsURL,\n\t\t\t\t\t\t\t\t\t\t\t'linkLabel' => __('Manage Scan', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t'statusTitle' => __('Scan Status', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t'statusList' => $scanner->scanTypeStatusList(),\n\t\t\t\t\t\t\t\t\t\t\t'helpLink' => __('https:\/\/www.wordfence.com\/help\/scan\/#scan-status', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\t\techo wfView::create('common\/status-detail', array(\n\t\t\t\t\t\t\t\t\t\t\t'id' => 'wf-scanner-malware-type',\n\t\t\t\t\t\t\t\t\t\t\t'percentage' => $scanner->signatureMode() == wfScanner::SIGNATURE_MODE_PREMIUM ? 1.0 : 0.7,\n\t\t\t\t\t\t\t\t\t\t\t'activeColor' => (!$scanner->isEnabled() ? '#ececec' : null \/* automatic *\/),\n\t\t\t\t\t\t\t\t\t\t\t'title' => __('Malware Signatures: ', 'wordfence') . ($scanner->signatureMode() == wfScanner::SIGNATURE_MODE_PREMIUM ? __('Premium', 'wordfence') : __('Community', 'wordfence')),\n\t\t\t\t\t\t\t\t\t\t\t'subtitle' => ($scanner->signatureMode() == wfScanner::SIGNATURE_MODE_PREMIUM ? __('Signatures updated in real-time', 'wordfence') : __('Signature updates delayed by 30 days', 'wordfence')),\n\t\t\t\t\t\t\t\t\t\t\t'link' => 'https:\/\/www.wordfence.com\/gnl1scanUpgrade\/wordfence-signup\/',\n\t\t\t\t\t\t\t\t\t\t\t'linkLabel' => ($scanner->signatureMode() == wfScanner::SIGNATURE_MODE_PREMIUM ? __('Protect More Sites', 'wordfence') : __('Upgrade to Premium', 'wordfence')),\n\t\t\t\t\t\t\t\t\t\t\t'linkNewWindow' => true,\n\t\t\t\t\t\t\t\t\t\t\t'statusTitle' => __('Malware Signatures Status', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t'statusList' => $scanner->signatureMode() == wfScanner::SIGNATURE_MODE_PREMIUM ? array() : array(array(\n\t\t\t\t\t\t\t\t\t\t\t\t'percentage' => 0.30,\n\t\t\t\t\t\t\t\t\t\t\t\t'title'      => __('Enable Premium Scan Signatures.', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t)),\n\t\t\t\t\t\t\t\t\t\t\t'helpLink' => __('https:\/\/www.wordfence.com\/help\/scan\/#scan-status', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\t\techo wfView::create('common\/status-detail', array(\n\t\t\t\t\t\t\t\t\t\t\t'id' => 'wf-scanner-reputation',\n\t\t\t\t\t\t\t\t\t\t\t'percentage' => $scanner->reputationStatus(),\n\t\t\t\t\t\t\t\t\t\t\t'activeColor' => (!$scanner->isEnabled() ? '#ececec' : null \/* automatic *\/),\n\t\t\t\t\t\t\t\t\t\t\t'title' => __('Reputation Checks', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t'subtitle' => __('Check spam &amp; spamvertising blocklists', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t'link' => $optionsURL . '#wf-scanner-options-general',\n\t\t\t\t\t\t\t\t\t\t\t'linkLabel' => __('Manage Options', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t'statusTitle' => __('Reputation Check Status', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t'statusList' => $scanner->reputationStatusList(),\n\t\t\t\t\t\t\t\t\t\t\t'helpLink' => __('https:\/\/www.wordfence.com\/help\/scan\/#scan-status', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t\t<\/ul>\n\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t<\/ul>\n\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t<\/div>\n\t\t<\/div>\n\t\t<div class=\"wf-row\">\n\t\t\t<div class=\"wf-col-xs-12\">\n\t\t\t\t<div class=\"wf-block wf-active\">\n\t\t\t\t\t<div class=\"wf-block-content\">\n\t\t\t\t\t\t<ul class=\"wf-block-list\">\n\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t<ul class=\"wf-block-list wf-block-list-horizontal wf-scan-navigation\">\n\t\t\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\t\techo wfView::create('scanner\/scan-starter', array(\n\t\t\t\t\t\t\t\t\t\t\t'running' => wfScanner::shared()->isRunning(),\n\t\t\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\t\techo wfView::create('common\/block-navigation-option', array(\n\t\t\t\t\t\t\t\t\t\t\t'id' => 'wf-scan-option-support',\n\t\t\t\t\t\t\t\t\t\t\t'img' => 'support.svg',\n\t\t\t\t\t\t\t\t\t\t\t'title' => __('Help', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t'subtitle' => __('Find the documentation and help you need', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t'link' => network_admin_url('admin.php?page=WordfenceSupport'),\n\t\t\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\t\techo wfView::create('common\/block-navigation-option', array(\n\t\t\t\t\t\t\t\t\t\t\t'id' => 'wf-scan-option-all-options',\n\t\t\t\t\t\t\t\t\t\t\t'img' => 'options.svg',\n\t\t\t\t\t\t\t\t\t\t\t'title' => __('Scan Options and Scheduling', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t'subtitle' => __('Manage scan options including scheduling', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t'link' => network_admin_url('admin.php?page=WordfenceScan&subpage=scan_options'),\n\t\t\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t\t<\/ul>\n\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t<li id=\"wf-scan-progress-bar\">\n\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\techo wfView::create('scanner\/scan-progress', array(\n\t\t\t\t\t\t\t\t\t'scanner' => $scanner,\n\t\t\t\t\t\t\t\t\t'running' => wfScanner::shared()->isRunning(),\n\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t<\/ul>\n\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t<\/div>\n\t\t<\/div>\n\t\t<div class=\"wf-row\">\n\t\t\t<div class=\"wf-col-xs-12\">\n\t\t\t\t<?php\n\t\t\t\techo wfView::create('scanner\/scan-progress-detailed', array(\n\t\t\t\t\t'scanner' => $scanner,\n\t\t\t\t))->render();\n\t\t\t\t?>\n\t\t\t<\/div>\n\t\t<\/div>\n\t\t<div class=\"wf-row\">\n            <div class=\"wf-col-xs-12\">\n\t\t\t  <?php\n\t\t\t  echo wfView::create('scanner\/scan-results', array(\n\t\t\t\t'scanner' => $scanner, \n\t\t\t\t 'issues' => $issues,\n\t\t\t  ))->render();\n\t\t\t  ?>\n            <\/div>\n        <\/div>\n\t\t<div class=\"wf-row\">\n\t\t\t<div class=\"wf-col-xs-12\">\n\t\t\t\t<?php\n\t\t\t\techo wfView::create('scanner\/site-cleaning-bottom', array(\n\t\t\t\t))->render();\n\t\t\t\t?>\n\t\t\t<\/div>\n\t\t<\/div>\n\t<\/div> <!-- end container -->\n<\/div>\n<script type=\"application\/javascript\">\n\t(function($) {\n\t\t$(function() {\n\t\t\tWFAD.updateActivityLog();\n\t\t\tWFAD.startActivityLogUpdates();\n\t\t});\n\t})(jQuery);\n<\/script>\n\n<script type=\"text\/x-jquery-template\" id=\"wfTmpl_scannerDelete\">\n\t<?php\n\techo wfView::create('common\/modal-prompt', array(\n\t\t'title' => __('Are you sure you want to delete?', 'wordfence'),\n\t\t'messageHTML' => '<p class=\"wf-callout-warning\"><i class=\"wf-fa wf-fa-exclamation-triangle\" aria-hidden=\"true\"><\/i> ' . wp_kses(__('<strong>WARNING:<\/strong> If you delete the wrong file, it could cause your WordPress website to stop functioning, and you will probably have to restore from a backup.', 'wordfence'), array('strong'=>array())) . '<\/p>' . \n\t\t\t'<p>' . wp_kses(sprintf(\n\t\t\t\/* translators: Support URL. *\/\n\t\t\t\t\t__('Do not delete files on your system unless you\\'re ABSOLUTELY sure you know what you\\'re doing. If you delete the wrong file it could cause your WordPress website to stop functioning and you will probably have to restore from backups. If you\\'re unsure, Cancel and work with your hosting provider to clean your system of infected files. If you\\'d like to learn more, <a href=\"%s\" target=\"_blank\" rel=\"noopener noreferrer\">click here for our help article<span class=\"screen-reader-text\"> (opens in new tab)<\/span><\/a>.', 'wordfence'), wfSupportController::esc_supportURL(wfSupportController::ITEM_SCAN_BULK_DELETE_WARNING)), array('a'=>array('href'=>array(), 'target'=>array(), 'rel'=>array()), 'span'=>array('class'=>array()))) . '<\/p>',\n\t\t'primaryButton' => array('id' => 'wf-scanner-prompt-cancel', 'label' => __('Cancel', 'wordfence'), 'link' => '#', 'type' => 'wf-btn-default'),\n\t\t'secondaryButtons' => array(array('id' => 'wf-scanner-prompt-confirm', 'label' => __('Delete Files', 'wordfence'), 'link' => '#', 'type' => 'wf-btn-danger')),\n\t))->render();\n\t?>\n<\/script>\n\n<script type=\"text\/x-jquery-template\" id=\"wfTmpl_scannerRepair\">\n\t<?php\n\techo wfView::create('common\/modal-prompt', array(\n\t\t'title' => __('Are you sure you want to repair?', 'wordfence'),\n\t\t'message' => __('Do not repair files on your system unless you\\'re ABSOLUTELY sure you know what you\\'re doing. If you repair the wrong file it could cause your WordPress website to stop functioning and you will probably have to restore from backups. If you\\'re unsure, Cancel and work with your hosting provider to clean your system of infected files.', 'wordfence'),\n\t\t'primaryButton' => array('id' => 'wf-scanner-prompt-cancel', 'label' => __('Cancel', 'wordfence'), 'link' => '#'),\n\t\t'secondaryButtons' => array(array('id' => 'wf-scanner-prompt-confirm', 'label' => __('Repair Files', 'wordfence'), 'link' => '#')),\n\t))->render();\n\t?>\n<\/script>\n\n<script type=\"text\/x-jquery-template\" id=\"wfTmpl_scannerStop\">\n\t<?php\n\techo wfView::create('common\/modal-prompt', array(\n\t\t'title' => '${title}',\n\t\t'message' => '${message}',\n\t\t'primaryButton' => array('id' => 'wf-generic-modal-close', 'label' => __('Close', 'wordfence'), 'link' => '#'),\n\t))->render();\n\t?>\n<\/script>\n\n<?php\necho wfView::create('scanner\/site-cleaning')->render();\necho wfView::create('scanner\/site-cleaning-high-sense')->render();\necho wfView::create('scanner\/site-cleaning-beta-sigs')->render();\necho wfView::create('scanner\/no-issues')->render();\necho wfView::create('scanner\/issue-wfUpgrade')->render();\necho wfView::create('scanner\/issue-wfUpgradeError')->render();\necho wfView::create('scanner\/issue-wfPluginUpgrade')->render();\necho wfView::create('scanner\/issue-wfThemeUpgrade')->render();\necho wfView::create('scanner\/issue-wfPluginRemoved')->render();\necho wfView::create('scanner\/issue-wfPluginAbandoned')->render();\necho wfView::create('scanner\/issue-wfPluginVulnerable')->render();\necho wfView::create('scanner\/issue-file')->render();\necho wfView::create('scanner\/issue-skippedPaths')->render();\necho wfView::create('scanner\/issue-knownfile')->render();\necho wfView::create('scanner\/issue-configReadable')->render();\necho wfView::create('scanner\/issue-publiclyAccessible')->render();\necho wfView::create('scanner\/issue-coreUnknown')->render();\necho wfView::create('scanner\/issue-diskSpace')->render();\necho wfView::create('scanner\/issue-wafStatus')->render();\necho wfView::create('scanner\/issue-geoipSupport')->render();\necho wfView::create('scanner\/issue-easyPassword')->render();\necho wfView::create('scanner\/issue-commentBadURL')->render();\necho wfView::create('scanner\/issue-postBadURL')->render();\necho wfView::create('scanner\/issue-postBadTitle')->render();\necho wfView::create('scanner\/issue-optionBadURL')->render();\necho wfView::create('scanner\/issue-database')->render();\necho wfView::create('scanner\/issue-checkSpamIP')->render();\necho wfView::create('scanner\/issue-spamvertizeCheck')->render();\necho wfView::create('scanner\/issue-checkGSB')->render();\necho wfView::create('scanner\/issue-checkHowGetIPs')->render();\necho wfView::create('scanner\/issue-suspiciousAdminUsers')->render();\necho wfView::create('scanner\/issue-timelimit')->render();\necho wfView::create('scanner\/issue-wfAssistantPresent')->render();\n\n\/\/Currently unused\necho wfView::create('scanner\/issue-wpscan_fullPathDiscl')->render();\necho wfView::create('scanner\/issue-wpscan_directoryList')->render();\n\nif (wfOnboardingController::willShowNewTour(wfOnboardingController::TOUR_SCAN)): ?>\n\t<script type=\"application\/javascript\">\n\t\t(function($) {\n\t\t\t$(function() {\n\t\t\t\tWFAD.tour1 = function() {\n\t\t\t\t\tWFAD.tour('wfNewTour1', 'wf-section-scan', 'top', 'left', null, WFAD.tour2);\n\t\t\t\t};\n\t\t\t\tWFAD.tour2 = function() {\n\t\t\t\t\tWFAD.tour('wfNewTour2', 'wf-scan-option-all-options', 'right', 'right', WFAD.tour1, WFAD.tour3);\n\t\t\t\t};\n\t\t\t\tWFAD.tour3 = function() {\n\t\t\t\t\tWFAD.tour('wfNewTour3', 'wf-scan-starter', 'left', 'left', WFAD.tour2, WFAD.tourComplete); \n\t\t\t\t};\n\t\t\t\tWFAD.tourComplete = function() { WFAD.tourFinish('<?php echo esc_attr(wfOnboardingController::TOUR_SCAN); ?>'); };\n\n\t\t\t\t<?php if (wfOnboardingController::shouldShowNewTour(wfOnboardingController::TOUR_SCAN)): ?>\n\t\t\t\tif (!WFAD.isSmallScreen) { WFAD.tour1(); }\n\t\t\t\t<?php endif; ?>\n\t\t\t});\n\t\t})(jQuery);\n\t<\/script>\n\n\t<script type=\"text\/x-jquery-template\" id=\"wfNewTour1\">\n\t\t<div>\n\t\t\t<h3><?php esc_html_e('Scan', 'wordfence'); ?><\/h3>\n\t\t\t<p><?php esc_html_e('A Wordfence scan looks for malware, malicious URLs, and patterns of infections by examining all of the files, posts, and comments on your WordPress website. It also checks your server and monitors your site\\'s online reputation.', 'wordfence'); ?><\/p>\n\t\t\t<div class=\"wf-pointer-footer\">\n\t\t\t\t<ul class=\"wf-tour-pagination\">\n\t\t\t\t\t<li class=\"wf-active\">&bullet;<\/li>\n\t\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t<\/ul>\n\t\t\t\t<div id=\"wf-tour-continue\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-primary\" role=\"button\"><?php esc_html_e('Next', 'wordfence'); ?><\/a><\/div>\n\t\t\t<\/div>\n\t\t\t<div id=\"wf-tour-close\"><a href=\"#\" role=\"button\"><i class=\"wf-fa wf-fa-times-circle\" aria-hidden=\"true\"><\/i><\/a><\/div>\n\t\t<\/div>\n\t<\/script>\n\t<script type=\"text\/x-jquery-template\" id=\"wfNewTour2\">\n\t\t<div>\n\t\t\t<h3><?php esc_html_e('Manage Scan Settings', 'wordfence'); ?><\/h3>\n\t\t\t<p class=\"wf-center\"><svg viewBox=\"0 0 100.11 100.11\" class=\"wf-icon\"><path d=\"M99.59,41.42a2.06,2.06,0,0,0-1.37-.82L86.3,38.78a39.34,39.34,0,0,0-2.67-6.39q1.17-1.63,3.52-4.6t3.32-4.33A2.52,2.52,0,0,0,91,22a2.1,2.1,0,0,0-.46-1.43Q88.18,17.2,79.78,9.45a2.52,2.52,0,0,0-1.63-.65,2.12,2.12,0,0,0-1.57.59l-9.25,7a40.09,40.09,0,0,0-5.87-2.41L59.64,2a1.92,1.92,0,0,0-.75-1.4A2.46,2.46,0,0,0,57.29,0H42.82a2.19,2.19,0,0,0-2.34,1.82,106,106,0,0,0-1.89,12.12,37.62,37.62,0,0,0-5.93,2.48l-9-7A2.78,2.78,0,0,0,22,8.8q-1.44,0-6.16,4.66a64.88,64.88,0,0,0-6.42,7A2.75,2.75,0,0,0,8.8,22a2.44,2.44,0,0,0,.65,1.56q4.37,5.28,7,9a32.38,32.38,0,0,0-2.54,6L1.76,40.34a2,2,0,0,0-1.24.85A2.5,2.5,0,0,0,0,42.69V57.16a2.44,2.44,0,0,0,.52,1.53,2,2,0,0,0,1.37.82l11.93,1.76a31.91,31.91,0,0,0,2.67,6.45Q15.31,69.35,13,72.31T9.65,76.65a2.54,2.54,0,0,0-.07,3q2.54,3.52,10.75,11a2.25,2.25,0,0,0,1.63.71,2.35,2.35,0,0,0,1.63-.59l9.19-7a40.54,40.54,0,0,0,5.87,2.41l1.82,12a1.92,1.92,0,0,0,.75,1.4,2.45,2.45,0,0,0,1.6.55H57.29a2.2,2.2,0,0,0,2.35-1.82,107.41,107.41,0,0,0,1.89-12.12,37.19,37.19,0,0,0,5.93-2.48l9,7a3.18,3.18,0,0,0,1.69.59q1.43,0,6.13-4.62a65.86,65.86,0,0,0,6.45-7,2.16,2.16,0,0,0,.59-1.5,2.51,2.51,0,0,0-.65-1.63q-4.69-5.74-7-9a41.57,41.57,0,0,0,2.54-5.93l12.06-1.82a2,2,0,0,0,1.3-.85,2.52,2.52,0,0,0,.52-1.5V43a2.46,2.46,0,0,0-.52-1.53ZM61.85,61.86a16.08,16.08,0,0,1-11.8,4.89A16.69,16.69,0,0,1,33.37,50.06,16.69,16.69,0,0,1,50.06,33.37,16.69,16.69,0,0,1,66.74,50.06a16.08,16.08,0,0,1-4.89,11.8Zm0,0\"><\/path><\/svg><\/p>\n\t\t\t<p><?php esc_html_e('Set up the way you want the scan to monitor your site security including custom scan configurations and scheduling.', 'wordfence'); ?><\/p>\n\t\t\t<div class=\"wf-pointer-footer\">\n\t\t\t\t<ul class=\"wf-tour-pagination\">\n\t\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t\t<li class=\"wf-active\">&bullet;<\/li>\n\t\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t<\/ul>\n\t\t\t\t<div id=\"wf-tour-previous\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-default\" role=\"button\"><?php esc_html_e('Previous', 'wordfence'); ?><\/a><\/div>\n\t\t\t\t<div id=\"wf-tour-continue\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-primary\" role=\"button\"><?php esc_html_e('Next', 'wordfence'); ?><\/a><\/div>\n\t\t\t<\/div>\n\t\t\t<div id=\"wf-tour-close\"><a href=\"#\" role=\"button\"><i class=\"wf-fa wf-fa-times-circle\" aria-hidden=\"true\"><\/i><\/a><\/div>\n\t\t<\/div>\n\t<\/script>\n\t<script type=\"text\/x-jquery-template\" id=\"wfNewTour3\">\n\t\t<div>\n\t\t\t<h3><?php esc_html_e('Start Your First Scan', 'wordfence'); ?><\/h3>\n\t\t\t<p><?php esc_html_e('By default, Wordfence will scan your site daily. Start your first scan now to see if your site has any security issues that need to be addressed. From here you can run manual scans any time you like.', 'wordfence'); ?><\/p>\n\t\t\t<div class=\"wf-pointer-footer\">\n\t\t\t\t<ul class=\"wf-tour-pagination\">\n\t\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t\t<li class=\"wf-active\">&bullet;<\/li>\n\t\t\t\t<\/ul>\n\t\t\t\t<div id=\"wf-tour-previous\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-default\" role=\"button\"><?php esc_html_e('Previous', 'wordfence'); ?><\/a><\/div>\n\t\t\t\t<div id=\"wf-tour-continue\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-primary\" role=\"button\"><?php esc_html_e('Got it', 'wordfence'); ?><\/a><\/div>\n\t\t\t<\/div>\n\t\t\t<div id=\"wf-tour-close\"><a href=\"#\" role=\"button\"><i class=\"wf-fa wf-fa-times-circle\" aria-hidden=\"true\"><\/i><\/a><\/div>\n\t\t<\/div>\n\t<\/script>\n<?php endif; ?>\n\n<?php if (wfOnboardingController::willShowUpgradeTour(wfOnboardingController::TOUR_SCAN)): ?>\n\t<script type=\"application\/javascript\">\n\t\t(function($) {\n\t\t\t$(function() {\n\t\t\t\tWFAD.tour1 = function() {\n\t\t\t\t\tWFAD.tour('wfUpgradeTour1', 'wf-scan-option-all-options', 'right', 'right', null, WFAD.tour2);\n\t\t\t\t};\n\t\t\t\tWFAD.tour2 = function() {\n\t\t\t\t\tWFAD.tour('wfUpgradeTour2', 'wf-scan-starter', 'left', 'left', WFAD.tour1, WFAD.tourComplete);\n\t\t\t\t};\n\t\t\t\tWFAD.tourComplete = function() { WFAD.tourFinish('<?php echo esc_attr(wfOnboardingController::TOUR_SCAN); ?>'); };\n\n\t\t\t\t<?php if (wfOnboardingController::shouldShowUpgradeTour(wfOnboardingController::TOUR_SCAN)): ?>\n\t\t\t\tif (!WFAD.isSmallScreen) { WFAD.tour1(); }\n\t\t\t\t<?php endif; ?>\n\t\t\t});\n\t\t})(jQuery);\n\t<\/script>\n\n\t<script type=\"text\/x-jquery-template\" id=\"wfUpgradeTour1\">\n\t\t<div>\n\t\t\t<h3><?php esc_html_e('Scan Options &amp; Settings', 'wordfence'); ?><\/h3>\n\t\t\t<p class=\"wf-center\"><svg viewBox=\"0 0 100.11 100.11\" class=\"wf-icon\"><path d=\"M99.59,41.42a2.06,2.06,0,0,0-1.37-.82L86.3,38.78a39.34,39.34,0,0,0-2.67-6.39q1.17-1.63,3.52-4.6t3.32-4.33A2.52,2.52,0,0,0,91,22a2.1,2.1,0,0,0-.46-1.43Q88.18,17.2,79.78,9.45a2.52,2.52,0,0,0-1.63-.65,2.12,2.12,0,0,0-1.57.59l-9.25,7a40.09,40.09,0,0,0-5.87-2.41L59.64,2a1.92,1.92,0,0,0-.75-1.4A2.46,2.46,0,0,0,57.29,0H42.82a2.19,2.19,0,0,0-2.34,1.82,106,106,0,0,0-1.89,12.12,37.62,37.62,0,0,0-5.93,2.48l-9-7A2.78,2.78,0,0,0,22,8.8q-1.44,0-6.16,4.66a64.88,64.88,0,0,0-6.42,7A2.75,2.75,0,0,0,8.8,22a2.44,2.44,0,0,0,.65,1.56q4.37,5.28,7,9a32.38,32.38,0,0,0-2.54,6L1.76,40.34a2,2,0,0,0-1.24.85A2.5,2.5,0,0,0,0,42.69V57.16a2.44,2.44,0,0,0,.52,1.53,2,2,0,0,0,1.37.82l11.93,1.76a31.91,31.91,0,0,0,2.67,6.45Q15.31,69.35,13,72.31T9.65,76.65a2.54,2.54,0,0,0-.07,3q2.54,3.52,10.75,11a2.25,2.25,0,0,0,1.63.71,2.35,2.35,0,0,0,1.63-.59l9.19-7a40.54,40.54,0,0,0,5.87,2.41l1.82,12a1.92,1.92,0,0,0,.75,1.4,2.45,2.45,0,0,0,1.6.55H57.29a2.2,2.2,0,0,0,2.35-1.82,107.41,107.41,0,0,0,1.89-12.12,37.19,37.19,0,0,0,5.93-2.48l9,7a3.18,3.18,0,0,0,1.69.59q1.43,0,6.13-4.62a65.86,65.86,0,0,0,6.45-7,2.16,2.16,0,0,0,.59-1.5,2.51,2.51,0,0,0-.65-1.63q-4.69-5.74-7-9a41.57,41.57,0,0,0,2.54-5.93l12.06-1.82a2,2,0,0,0,1.3-.85,2.52,2.52,0,0,0,.52-1.5V43a2.46,2.46,0,0,0-.52-1.53ZM61.85,61.86a16.08,16.08,0,0,1-11.8,4.89A16.69,16.69,0,0,1,33.37,50.06,16.69,16.69,0,0,1,50.06,33.37,16.69,16.69,0,0,1,66.74,50.06a16.08,16.08,0,0,1-4.89,11.8Zm0,0\"><\/path><\/svg><\/p>\n\t\t\t<p class=\"wf-center\"><?php esc_html_e('All of your scan options, including scheduling, are now located here.', 'wordfence'); ?><\/p>\n\t\t\t<div class=\"wf-pointer-footer\">\n\t\t\t\t<ul class=\"wf-tour-pagination\">\n\t\t\t\t\t<li class=\"wf-active\">&bullet;<\/li>\n\t\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t<\/ul>\n\t\t\t\t<div id=\"wf-tour-continue\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-primary\" role=\"button\"><?php esc_html_e('Next', 'wordfence'); ?><\/a><\/div>\n\t\t\t<\/div>\n\t\t\t<div id=\"wf-tour-close\"><a href=\"#\" role=\"button\"><i class=\"wf-fa wf-fa-times-circle\" aria-hidden=\"true\"><\/i><\/a><\/div>\n\t\t<\/div>\n\t<\/script>\n\t<script type=\"text\/x-jquery-template\" id=\"wfUpgradeTour2\">\n\t\t<div>\n\t\t\t<h3><?php esc_html_e('Scan Progress and Activity', 'wordfence'); ?><\/h3>\n\t\t\t<p><?php esc_html_e('Track each scan stage as Wordfence scans your entire site. Along the way you can see the activity log one line at a time or expand the activity log for a more detailed view. Clicking on scan results will reveal detailed scan findings.', 'wordfence'); ?><\/p>\n\t\t\t<div class=\"wf-pointer-footer\">\n\t\t\t\t<ul class=\"wf-tour-pagination\">\n\t\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t\t<li class=\"wf-active\">&bullet;<\/li>\n\t\t\t\t<\/ul>\n\t\t\t\t<div id=\"wf-tour-previous\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-default\" role=\"button\"><?php esc_html_e('Previous', 'wordfence'); ?><\/a><\/div>\n\t\t\t\t<div id=\"wf-tour-continue\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-primary\" role=\"button\"><?php esc_html_e('Got it', 'wordfence'); ?><\/a><\/div>\n\t\t\t<\/div>\n\t\t\t<div id=\"wf-tour-close\"><a href=\"#\" role=\"button\"><i class=\"wf-fa wf-fa-times-circle\" aria-hidden=\"true\"><\/i><\/a><\/div>\n\t\t<\/div>\n\t<\/script>\n<?php endif; ?>"},{"base":"plugins","rel":"wordfence\/lib\/WFLSPHP52Compatability.php","ext":"php","size":1303,"mtime":1757312769,"type":"text","content":"<?php\n\n\/**\n * Class WFLSPHP52Compatability\n * \n * This class exists solely to contain syntax incompatible with PHP 5.2 into a single file.\n *\/\nclass WFLSPHP52Compatability {\n\tpublic static function install_plugin() {\n\t\t\\WordfenceLS\\Controller_WordfenceLS::shared()->_install_plugin();\n\t}\n\t\n\tpublic static function uninstall_plugin() {\n\t\t\\WordfenceLS\\Controller_WordfenceLS::shared()->_uninstall_plugin();\n\t}\n\t\n\tpublic static function import_2fa($import) {\n\t\t$imported = \\WordfenceLS\\Controller_Users::shared()->import_2fa($import);\n\t\tif ($imported && wfConfig::get('loginSec_requireAdminTwoFactor')) {\n\t\t\t\\WordfenceLS\\Controller_Settings::shared()->set(\\WordfenceLS\\Controller_Settings::OPTION_REQUIRE_2FA_ADMIN, true);\n\t\t}\n\t\treturn $imported;\n\t}\n\t\n\tpublic static function secrets_table() {\n\t\treturn \\WordfenceLS\\Controller_DB::shared()->secrets;\n\t}\n\t\n\tpublic static function ntp_time() {\n\t\treturn \\WordfenceLS\\Controller_Time::ntp_time();\n\t}\n\t\n\tpublic static function using_ntp_time() {\n\t\treturn \\WordfenceLS\\Controller_Settings::shared()->get_bool(\\WordfenceLS\\Controller_Settings::OPTION_USE_NTP);\n\t}\n\t\n\tpublic static function using_wf_time() {\n\t\treturn !self::using_ntp_time() && defined('WORDFENCE_LS_FROM_CORE') && WORDFENCE_LS_FROM_CORE && ((int) wfConfig::get('timeoffset_wf', false)) != 0;\n\t}\n}"},{"base":"plugins","rel":"wordfence\/lib\/wfConfig.php","ext":"php","size":125493,"mtime":1757312769,"type":"text","content":"<?php\nclass wfConfig {\n\tconst TABLE_EXISTS_OPTION = 'wordfence_installed'; \/\/Also exists in bootstrap.php\n\t\n\tconst AUTOLOAD = 'yes';\n\tconst DONT_AUTOLOAD = 'no';\n\t\n\tconst TYPE_BOOL = 'boolean';\n\tconst TYPE_INT = 'integer';\n\tconst TYPE_FLOAT = 'double';\n\tconst TYPE_DOUBLE = 'double';\n\tconst TYPE_STRING = 'string';\n\tconst TYPE_MULTI_STRING = 'multi-string';\n\tconst TYPE_ARRAY = 'array';\n\tconst TYPE_JSON = 'json';\n\t\n\tconst OPTIONS_TYPE_GLOBAL = 'global';\n\tconst OPTIONS_TYPE_FIREWALL = 'firewall';\n\tconst OPTIONS_TYPE_BLOCKING = 'blocking';\n\tconst OPTIONS_TYPE_SCANNER = 'scanner';\n\tconst OPTIONS_TYPE_TWO_FACTOR = 'twofactor';\n\tconst OPTIONS_TYPE_LIVE_TRAFFIC = 'livetraffic';\n\tconst OPTIONS_TYPE_AUDIT_LOG = 'auditlog';\n\tconst OPTIONS_TYPE_DIAGNOSTICS = 'diagnostics';\n\tconst OPTIONS_TYPE_ALL = 'all';\n\n\tconst DEFAULT_ALERT_MAX_HOURLY = 5;\n\t\n\tprivate static $tableExists = true;\n\tprivate static $cache = array();\n\tprivate static $DB = false;\n\tpublic static $defaultConfig = array(\n\t\t\/\/All exportable boolean options\n\t\t\"checkboxes\" => array(\n\t\t\t\"alertOn_update\" => array('value' => false, 'autoload' => self::AUTOLOAD),\n\t\t\t\"alertOn_scanIssues\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"alertOn_throttle\" => array('value' => false, 'autoload' => self::AUTOLOAD),\n\t\t\t\"alertOn_block\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"alertOn_loginLockout\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t'alertOn_breachLogin' => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"alertOn_lostPasswdForm\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"alertOn_adminLogin\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"alertOn_firstAdminLoginOnly\" => array('value' => false, 'autoload' => self::AUTOLOAD),\n\t\t\t\"alertOn_nonAdminLogin\" => array('value' => false, 'autoload' => self::AUTOLOAD),\n\t\t\t\"alertOn_firstNonAdminLoginOnly\" => array('value' => false, 'autoload' => self::AUTOLOAD),\n\t\t\t\"alertOn_wordfenceDeactivated\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"alertOn_wafDeactivated\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"liveTrafficEnabled\" => array('value' => false, 'autoload' => self::AUTOLOAD),\n\t\t\t\"advancedCommentScanning\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"checkSpamIP\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"spamvertizeCheck\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"liveTraf_ignorePublishers\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"liveTraf_displayExpandedRecords\" => array('value' => false, 'autoload' => self::DONT_AUTOLOAD),\n\t\t\t\"scheduledScansEnabled\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"lowResourceScansEnabled\" => array('value' => false, 'autoload' => self::AUTOLOAD),\n\t\t\t\"scansEnabled_checkGSB\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"scansEnabled_checkHowGetIPs\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"scansEnabled_core\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"scansEnabled_themes\" => array('value' => false, 'autoload' => self::AUTOLOAD),\n\t\t\t\"scansEnabled_plugins\" => array('value' => false, 'autoload' => self::AUTOLOAD),\n\t\t\t\"scansEnabled_coreUnknown\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"scansEnabled_malware\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"scansEnabled_fileContents\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"scansEnabled_fileContentsGSB\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"scansEnabled_checkReadableConfig\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"scansEnabled_suspectedFiles\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"scansEnabled_posts\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"scansEnabled_comments\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"scansEnabled_suspiciousOptions\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"scansEnabled_passwds\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"scansEnabled_diskSpace\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t'scansEnabled_wafStatus' => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"scansEnabled_options\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"scansEnabled_wpscan_fullPathDisclosure\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"scansEnabled_wpscan_directoryListingEnabled\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"scansEnabled_scanImages\" => array('value' => false, 'autoload' => self::AUTOLOAD),\n\t\t\t\"scansEnabled_highSense\" => array('value' => false, 'autoload' => self::AUTOLOAD),\n\t\t\t\"scansEnabled_oldVersions\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"scansEnabled_suspiciousAdminUsers\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"scan_force_ipv4_start\" => array('value' => false, 'autoload' => self::AUTOLOAD),\n\t\t\t\"liveActivityPauseEnabled\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"firewallEnabled\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"autoBlockScanners\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"loginSecurityEnabled\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"loginSec_strongPasswds_enabled\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"loginSec_breachPasswds_enabled\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"loginSec_lockInvalidUsers\" => array('value' => false, 'autoload' => self::AUTOLOAD),\n\t\t\t\"loginSec_maskLoginErrors\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"loginSec_blockAdminReg\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"loginSec_disableAuthorScan\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"loginSec_disableApplicationPasswords\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"loginSec_disableOEmbedAuthor\" => array('value' => false, 'autoload' => self::AUTOLOAD),\n\t\t\t'loginSec_requireAdminTwoFactor' => array('value' => false, 'autoload' => self::AUTOLOAD),\n\t\t\t\"notification_updatesNeeded\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"notification_securityAlerts\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"notification_promotions\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"notification_blogHighlights\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"notification_productUpdates\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"notification_scanStatus\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"enableRemoteIpLookup\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"other_hideWPVersion\" => array('value' => false, 'autoload' => self::AUTOLOAD),\n\t\t\t\"other_blockBadPOST\" => array('value' => false, 'autoload' => self::AUTOLOAD),\n\t\t\t\"other_scanComments\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"other_pwStrengthOnUpdate\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"other_WFNet\" => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t\"other_scanOutside\" => array('value' => false, 'autoload' => self::AUTOLOAD),\n\t\t\t\"other_bypassLitespeedNoabort\" => array('value' => false, 'autoload' => self::AUTOLOAD),\n\t\t\t\"deleteTablesOnDeact\" => array('value' => false, 'autoload' => self::AUTOLOAD),\n\t\t\t\"autoUpdate\" => array('value' => false, 'autoload' => self::AUTOLOAD),\n\t\t\t\"startScansRemotely\" => array('value' => false, 'autoload' => self::AUTOLOAD),\n\t\t\t\"disableConfigCaching\" => array('value' => false, 'autoload' => self::AUTOLOAD),\n\t\t\t\"addCacheComment\" => array('value' => false, 'autoload' => self::AUTOLOAD),\n\t\t\t\"disableCodeExecutionUploads\" => array('value' => false, 'autoload' => self::AUTOLOAD),\n\t\t\t\"allowHTTPSCaching\" => array('value' => false, 'autoload' => self::AUTOLOAD),\n\t\t\t\"debugOn\" => array('value' => false, 'autoload' => self::AUTOLOAD),\n\t\t\t'email_summary_enabled' => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t'email_summary_dashboard_widget_enabled' => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t'ssl_verify' => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t'ajaxWatcherDisabled_front' => array('value' => false, 'autoload' => self::AUTOLOAD),\n\t\t\t'ajaxWatcherDisabled_admin' => array('value' => false, 'autoload' => self::AUTOLOAD),\n\t\t\t'wafAlertOnAttacks' => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t'disableWAFIPBlocking' => array('value' => false, 'autoload' => self::AUTOLOAD),\n\t\t\t'showAdminBarMenu' => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t'displayTopLevelOptions' => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t'displayTopLevelBlocking' => array('value' => false, 'autoload' => self::AUTOLOAD),\n\t\t\t'displayTopLevelLiveTraffic' => array('value' => false, 'autoload' => self::AUTOLOAD),\n\t\t\t'displayTopLevelAuditLog' => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t'displayAutomaticBlocks' => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t\t'allowLegacy2FA' => array('value' => false, 'autoload' => self::AUTOLOAD),\n\t\t\t'wordfenceI18n' => array('value' => true, 'autoload' => self::AUTOLOAD),\n\t\t),\n\t\t\/\/All exportable variable type options\n\t\t\"otherParams\" => array(\n\t\t\t\"scan_include_extra\" => array('value' => \"\", 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t\"alertEmails\" => array('value' => \"\", 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)), \n\t\t\t\"liveTraf_ignoreUsers\" => array('value' => \"\", 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)), \n\t\t\t\"liveTraf_ignoreIPs\" => array('value' => \"\", 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)), \n\t\t\t\"liveTraf_ignoreUA\" => array('value' => \"\", 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),   \n\t\t\t\"maxMem\" => array('value' => 256, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_INT)), \n\t\t\t'scan_exclude' => array('value' => '', 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)), \n\t\t\t'scan_maxIssues' => array('value' => 1000, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_INT)), \n\t\t\t'scan_maxDuration' => array('value' => '', 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)), \n\t\t\t\"scan_max_resume_attempts\" => array('value' => wfScanMonitor::DEFAULT_RESUME_ATTEMPTS, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_INT)),\n\t\t\t'whitelisted' => array('value' => '', 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'whitelistedServices' => array('value' => '{}', 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_JSON)),\n\t\t\t'bannedURLs' => array('value' => '', 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)), \n\t\t\t'maxExecutionTime' => array('value' => 0, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_INT)), \n\t\t\t'howGetIPs' => array('value' => '', 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)), \n\t\t\t'actUpdateInterval' => array('value' => 2, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_INT)), \n\t\t\t'alert_maxHourly' => array('value' => self::DEFAULT_ALERT_MAX_HOURLY, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_INT)),\n\t\t\t'loginSec_userBlacklist' => array('value' => '', 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'liveTraf_maxRows' => array('value' => 2000, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_INT)),\n\t\t\t'liveTraf_maxAge' => array('value' => 30, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_INT)),\n\t\t\t\"neverBlockBG\" => array('value' => \"neverBlockVerified\", 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t\"loginSec_countFailMins\" => array('value' => 240, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_INT)),\n\t\t\t\"loginSec_lockoutMins\" => array('value' => 240, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_INT)),\n\t\t\t'loginSec_strongPasswds' => array('value' => 'pubs', 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'loginSec_breachPasswds' => array('value' => 'admins', 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'loginSec_maxFailures' => array('value' => 20, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_INT)),\n\t\t\t'loginSec_maxForgotPasswd' => array('value' => 20, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_INT)),\n\t\t\t'maxGlobalRequests' => array('value' => 'DISABLED', 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'maxGlobalRequests_action' => array('value' => \"throttle\", 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'maxRequestsCrawlers' => array('value' => 'DISABLED', 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'maxRequestsCrawlers_action' => array('value' => \"throttle\", 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'maxRequestsHumans' => array('value' => 'DISABLED', 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'maxRequestsHumans_action' => array('value' => \"throttle\", 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'max404Crawlers' => array('value' => 'DISABLED', 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'max404Crawlers_action' => array('value' => \"throttle\", 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'max404Humans' => array('value' => 'DISABLED', 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'max404Humans_action' => array('value' => \"throttle\", 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'blockedTime' => array('value' => 300, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_INT)),\n\t\t\t'email_summary_interval' => array('value' => 'weekly', 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'email_summary_excluded_directories' => array('value' => 'wp-content\/cache,wp-content\/wflogs', 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'allowed404s' => array('value' => \"\/favicon.ico\\n\/apple-touch-icon*.png\\n\/*@2x.png\\n\/browserconfig.xml\", 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'wafAlertWhitelist' => array('value' => '', 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'wafAlertInterval' => array('value' => 600, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_INT)),\n\t\t\t'wafAlertThreshold' => array('value' => 100, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_INT)),\n\t\t\t'howGetIPs_trusted_proxies' => array('value' => '', 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'howGetIPs_trusted_proxy_preset' => array('value' => '', 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'scanType' => array('value' => wfScanner::SCAN_TYPE_STANDARD, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'manualScanType' => array('value' => wfScanner::MANUAL_SCHEDULING_ONCE_DAILY, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'schedStartHour' => array('value' => -1, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_INT)),\n\t\t\t'schedMode' => array('value' => wfScanner::SCAN_SCHEDULING_MODE_AUTOMATIC, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'cbl_loggedInBlocked' => array('value' => false, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_BOOL)),\n\t\t\t'cbl_action' => array('value' => 'block', 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'cbl_redirURL' => array('value' => '', 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'cbl_bypassRedirURL' => array('value' => '', 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'cbl_bypassRedirDest' => array('value' => '', 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'cbl_bypassViewURL' => array('value' => '', 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'loginSec_enableSeparateTwoFactor' => array('value' => false, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_BOOL)),\n\t\t\t'blockCustomText' => array('value' => '', 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'alertOn_severityLevel' => array('value' => wfIssues::SEVERITY_LOW, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_INT)),\n\t\t\t'auditLogMode' => array('value' => wfAuditLog::AUDIT_LOG_MODE_DEFAULT, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t),\n\t\t\/\/Set as default only, not included automatically in the settings import\/export or options page saving\n\t\t'defaultsOnly' => array(\n\t\t\t\"apiKey\" => array('value' => \"\", 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'keyType' => array('value' => wfLicense::KEY_TYPE_FREE, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'isPaid' => array('value' => false, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_BOOL)),\n\t\t\t'hasKeyConflict' => array('value' => false, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_BOOL)),\n\t\t\t'timeoffset_wf_updated' => array('value' => 0, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_INT)),\n\t\t\t'cacheType' => array('value' => 'disabled', 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'detectProxyRecommendation' => array('value' => '', 'autoload' => self::DONT_AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'dismissAutoPrependNotice' => array('value' => false, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_BOOL)),\n\t\t\t'onboardingAttempt1' => array('value' => '', 'autoload' => self::DONT_AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'onboardingAttempt2' => array('value' => '', 'autoload' => self::DONT_AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'onboardingAttempt3' => array('value' => '', 'autoload' => self::DONT_AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'onboardingAttempt3Initial' => array('value' => false, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_BOOL)),\n\t\t\t'onboardingDelayedAt' => array('value' => false, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_INT)),\n\t\t\t'onboardingLastVersion' => array('value' => '', 'autoload' => self::DONT_AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'needsNewTour_dashboard' => array('value' => true, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_BOOL)),\n\t\t\t'needsNewTour_firewall' => array('value' => true, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_BOOL)),\n\t\t\t'needsNewTour_scan' => array('value' => true, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_BOOL)),\n\t\t\t'needsNewTour_blocking' => array('value' => true, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_BOOL)),\n\t\t\t'needsNewTour_livetraffic' => array('value' => true, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_BOOL)),\n\t\t\t'needsNewTour_loginsecurity' => array('value' => true, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_BOOL)),\n\t\t\t'needsNewTour_auditlog' => array('value' => true, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_BOOL)),\n\t\t\t'needsUpgradeTour_dashboard' => array('value' => false, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_BOOL)),\n\t\t\t'needsUpgradeTour_firewall' => array('value' => false, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_BOOL)),\n\t\t\t'needsUpgradeTour_scan' => array('value' => false, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_BOOL)),\n\t\t\t'needsUpgradeTour_blocking' => array('value' => false, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_BOOL)),\n\t\t\t'needsUpgradeTour_livetraffic' => array('value' => false, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_BOOL)),\n\t\t\t'needsUpgradeTour_loginsecurity' => array('value' => false, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_BOOL)),\n\t\t\t'needsUpgradeTour_auditlog' => array('value' => false, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_BOOL)),\n\t\t\t'supportContent' => array('value' => '{}', 'autoload' => self::DONT_AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'supportHash' => array('value' => '', 'autoload' => self::DONT_AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'whitelistPresets' => array('value' => '{}', 'autoload' => self::DONT_AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'whitelistHash' => array('value' => '', 'autoload' => self::DONT_AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'touppPromptNeeded' => array('value' => false, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_BOOL)),\n\t\t\t'touppBypassNextCheck' => array('value' => false, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_BOOL)),\n\t\t\t'autoUpdateAttempts' => array('value' => 0, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_INT)),\n\t\t\t'lastPermissionsTemplateCheck' => array('value' => 0, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_INT)),\n\t\t\t'previousWflogsFileList' => array('value' => '[]', 'autoload' => self::DONT_AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'diagnosticsWflogsRemovalHistory' => array('value' => '[]', 'autoload' => self::DONT_AUTOLOAD, 'validation' => array('type' => self::TYPE_STRING)),\n\t\t\t'satisfactionPromptDismissed' => array('value' => 0, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_INT)),\n\t\t\t'satisfactionPromptInstallDate' => array('value' => 0, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_INT)),\n\t\t\t'satisfactionPromptOverride' => array('value' => true, 'autoload' => self::AUTOLOAD, 'validation' => array('type' => self::TYPE_BOOL)),\n\t\t),\n\t);\n\tpublic static $serializedOptions = array('lastAdminLogin', 'scanSched', 'emailedIssuesList', 'wf_summaryItems', 'adminUserList', 'twoFactorUsers', 'alertFreqTrack', 'wfStatusStartMsgs', 'vulnerabilities_core', 'vulnerabilities_plugin', 'vulnerabilities_theme', 'dashboardData', 'malwarePrefixes', 'coreHashes', 'noc1ScanSchedule', 'allScansScheduled', 'disclosureStates', 'scanStageStatuses', 'adminNoticeQueue', 'suspiciousAdminUsernames', 'wordpressPluginVersions', 'wordpressThemeVersions', 'lastAuditEvents');\n\t\/\/ Configuration keypairs that can be set from Central.\n\tprivate static $wfCentralInternalConfig = array(\n\t\t'wordfenceCentralUserSiteAuthGrant',\n\t\t'wordfenceCentralConnected',\n\t\t'wordfenceCentralPluginAlertingDisabled',\n\t);\n\n\tpublic static function setDefaults() {\n\t\tforeach (self::$defaultConfig['checkboxes'] as $key => $config) {\n\t\t\t$val = $config['value'];\n\t\t\t$autoload = $config['autoload'];\n\t\t\tif (self::get($key) === false) {\n\t\t\t\tself::set($key, $val ? '1' : '0', $autoload);\n\t\t\t}\n\t\t}\n\t\tforeach (self::$defaultConfig['otherParams'] as $key => $config) {\n\t\t\t$val = $config['value'];\n\t\t\t$autoload = $config['autoload'];\n\t\t\tif (self::get($key) === false) {\n\t\t\t\tself::set($key, $val, $autoload);\n\t\t\t}\n\t\t}\n\t\tforeach (self::$defaultConfig['defaultsOnly'] as $key => $config) {\n\t\t\t$val = $config['value'];\n\t\t\t$autoload = $config['autoload'];\n\t\t\tif (self::get($key) === false) {\n\t\t\t\tif ($val === false) {\n\t\t\t\t\tself::set($key, '0', $autoload);\n\t\t\t\t}\n\t\t\t\telse if ($val === true) {\n\t\t\t\t\tself::set($key, '1', $autoload);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tself::set($key, $val, $autoload);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tself::set('encKey', substr(wfUtils::bigRandomHex(), 0, 16));\n\t\tself::set('longEncKey', bin2hex(wfWAFUtils::random_bytes(32)));\n\t\tif (self::get('maxMem', false) === false) {\n\t\t\tself::set('maxMem', '256');\n\t\t}\n\t\tif (self::get('other_scanOutside', false) === false) {\n\t\t\tself::set('other_scanOutside', 0);\n\t\t}\n\n\t\tif (self::get('email_summary_enabled')) {\n\t\t\twfActivityReport::scheduleCronJob();\n\t\t} else {\n\t\t\twfActivityReport::disableCronJob();\n\t\t}\n\t}\n\tpublic static function loadAllOptions() {\n\t\tglobal $wpdb;\n\t\t\n\t\tif (empty(self::$cache)) {\n\t\t\t$table = self::table();\n\t\t\tself::updateTableExists();\n\t\t\t$suppress = $wpdb->suppress_errors();\n\t\t\tif (!($rawOptions = $wpdb->get_results(\"SELECT name, val FROM {$table} WHERE autoload = 'yes'\"))) {\n\t\t\t\t$rawOptions = $wpdb->get_results(\"SELECT name, val FROM {$table}\");\n\t\t\t}\n\t\t\t$wpdb->suppress_errors($suppress);\n\t\t\t$options = array();\n\t\t\tforeach ((array) $rawOptions as $o) {\n\t\t\t\tif (in_array($o->name, self::$serializedOptions)) {\n\t\t\t\t\t$val = maybe_unserialize($o->val);\n\t\t\t\t\tif ($val) {\n\t\t\t\t\t\t$options[$o->name] = $val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$options[$o->name] = $o->val;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tself::$cache = $options;\n\t\t}\n\t\t\n\t\treturn self::$cache;\n\t}\n\t\n\t\/**\n\t * Bases the table's existence on the option specified by wfConfig::TABLE_EXISTS_OPTION for performance. We only\n\t * set that option just prior to deletion in the uninstall handler and after table creation in the install handler.\n\t *\/\n\tpublic static function updateTableExists($change = null) {\n\t\tif ($change !== null) {\n\t\t\tself::$tableExists = !!$change;\n\t\t\tif (is_multisite() && function_exists('update_network_option')) {\n\t\t\t\tupdate_network_option(null, wfConfig::TABLE_EXISTS_OPTION, self::$tableExists);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tupdate_option(wfConfig::TABLE_EXISTS_OPTION, self::$tableExists);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tself::$tableExists = true;\n\t\tif (is_multisite() && function_exists('get_network_option')) {\n\t\t\t$optionValue = get_network_option(null, wfConfig::TABLE_EXISTS_OPTION, null);\n\t\t}\n\t\telse {\n\t\t\t$optionValue = get_option(wfConfig::TABLE_EXISTS_OPTION, null);\n\t\t}\n\t\t\n\t\tif ($optionValue === null) { \/\/No value, set an initial one\n\t\t\tglobal $wpdb;\n\t\t\tself::updateTableExists(!!$wpdb->get_col($wpdb->prepare('SELECT TABLE_NAME FROM information_schema.TABLES WHERE TABLE_SCHEMA=DATABASE() AND TABLE_NAME=%s', self::table())));\n\t\t\treturn;\n\t\t}\n\t\tif (!$optionValue) {\n\t\t\tself::$tableExists = false;\n\t\t}\n\t}\n\t\n\tpublic static function tableExists() {\n\t\treturn self::$tableExists;\n\t}\n\t\n\tprivate static function updateCachedOption($name, $val) {\n\t\t$options = self::loadAllOptions();\n\t\t$options[$name] = $val;\n\t\tself::$cache = $options;\n\t}\n\tprivate static function removeCachedOption($name) {\n\t\t$options = self::loadAllOptions();\n\t\tif (isset($options[$name])) {\n\t\t\tunset($options[$name]);\n\t\t\tself::$cache = $options;\n\t\t}\n\t}\n\tprivate static function getCachedOption($name) {\n\t\t$options = self::loadAllOptions();\n\t\tif (isset($options[$name])) {\n\t\t\treturn $options[$name];\n\t\t}\n\t\t\n\t\t$table = self::table();\n\t\t$val = self::getDB()->querySingle(\"SELECT val FROM {$table} WHERE name='%s'\", $name);\n\t\tif ($val !== null) {\n\t\t\t$options[$name] = $val;\n\t\t\tself::$cache = $options;\n\t\t}\n\t\treturn $val;\n\t}\n\tpublic static function hasCachedOption($name) {\n\t\t$options = self::loadAllOptions();\n\t\treturn isset($options[$name]);\n\t}\n\t\n\t\/**\n\t * Returns an array of all option keys that are eligible for export with the exception of serialized options.\n\t * \n\t * @return array\n\t *\/\n\tpublic static function getExportableOptionsKeys() {\n\t\t$ret = array();\n\t\tforeach (self::$defaultConfig['checkboxes'] as $key => $val) {\n\t\t\t$ret[] = $key;\n\t\t}\n\t\tforeach (self::$defaultConfig['otherParams'] as $key => $val) {\n\t\t\t$ret[] = $key;\n\t\t}\n\t\treturn $ret;\n\t}\n\tpublic static function parseOptions($excludeOmitted = false) {\n\t\t$ret = array();\n\t\tforeach (self::$defaultConfig['checkboxes'] as $key => $val) { \/\/value is not used. We just need the keys for validation\n\t\t\tif ($excludeOmitted && isset($_POST[$key])) {\n\t\t\t\t$ret[$key] = (int) $_POST[$key];\n\t\t\t}\n\t\t\telse if (!$excludeOmitted || isset($_POST[$key])) {\n\t\t\t\t$ret[$key] = isset($_POST[$key]) ? '1' : '0';\n\t\t\t}\n\t\t}\n\t\tforeach (self::$defaultConfig['otherParams'] as $key => $val) {\n\t\t\tif (!$excludeOmitted || isset($_POST[$key])) {\n\t\t\t\tif (isset($_POST[$key])) {\n\t\t\t\t\t$ret[$key] = stripslashes($_POST[$key]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\terror_log(\"Missing options param \\\"$key\\\" when parsing parameters.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\/* for debugging only:\n\t\tforeach($_POST as $key => $val){\n\t\t\tif($key != 'action' && $key != 'nonce' && (! array_key_exists($key, self::$checkboxes)) && (! array_key_exists($key, self::$otherParams)) ){\n\t\t\t\terror_log(\"Unrecognized option: $key\");\n\t\t\t}\n\t\t}\n\t\t*\/\n\t\treturn $ret;\n\t}\n\tpublic static function setArray($arr){\n\t\tforeach($arr as $key => $val){\n\t\t\tself::set($key, $val);\n\t\t}\n\t}\n\tpublic static function getHTML($key){\n\t\treturn esc_html(self::get($key));\n\t}\n\tpublic static function inc($key){\n\t\t$val = self::get($key, false);\n\t\tif(! $val){\n\t\t\t$val = 0;\n\t\t}\n\t\tself::set($key, $val + 1);\n\t\treturn $val + 1;\n\t}\n\tpublic static function atomicInc($key) {\n\t\tif (!self::$tableExists) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tglobal $wpdb;\n\t\t$old_suppress_errors = $wpdb->suppress_errors(true);\n\t\t$table = self::table();\n\t\t$rowExists = false;\n\t\t$successful = false;\n\t\t$attempts = 0;\n\t\tdo {\n\t\t\tif (!$rowExists && $wpdb->query($wpdb->prepare(\"INSERT INTO {$table} (name, val, autoload) values (%s, %s, %s)\", $key, 1, self::DONT_AUTOLOAD))) {\n\t\t\t\t$val = 1;\n\t\t\t\t$successful = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$rowExists = true;\n\t\t\t\t$val = self::get($key, 1);\n\t\t\t\tif ($wpdb->query($wpdb->prepare(\"UPDATE {$table} SET val = %s WHERE name = %s AND val = %s\", $val + 1, $key, $val))) {\n\t\t\t\t\t$val++;\n\t\t\t\t\t$successful = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t$attempts++;\n\t\t} while (!$successful && $attempts < 100);\n\t\t$wpdb->suppress_errors($old_suppress_errors);\n\t\treturn $val;\n\t}\n\tpublic static function remove($key) {\n\t\tglobal $wpdb;\n\t\t\n\t\tif (!self::$tableExists) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t$table = self::table();\n\t\t$wpdb->query($wpdb->prepare(\"DELETE FROM {$table} WHERE name = %s\", $key));\n\t\tself::removeCachedOption($key);\n\t\t\n\t\tif (!WFWAF_SUBDIRECTORY_INSTALL && class_exists('wfWAFIPBlocksController') && (substr($key, 0, 4) == 'cbl_' || $key == 'blockedTime' || $key == 'disableWAFIPBlocking')) {\n\t\t\twfWAFIPBlocksController::setNeedsSynchronizeConfigSettings();\n\t\t}\n\t}\n\tpublic static function set($key, $val, $autoload = self::AUTOLOAD) {\n\t\tglobal $wpdb;\n\t\t\n\t\tif (is_array($val)) {\n\t\t\t$msg = sprintf(\n\t\t\t\t\/* translators: 1. Key in key-value store. 2. Value in key-value store. *\/\n\t\t\t\t__('wfConfig::set() got an array as second param with key: %1$s and value: %2$s', 'wordfence'), $key, var_export($val, true));\n\t\t\twordfence::status(1, 'error', $msg);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t\n\t\tself::_handleActionHooks($key, $val);\n\n\t\tif (($key == 'apiKey' || $key == 'isPaid' || $key == 'other_WFNet') && wfWAF::getInstance() && !WFWAF_SUBDIRECTORY_INSTALL) {\n\t\t\tif ($key == 'isPaid' || $key == 'other_WFNet') {\n\t\t\t\t$val = !!$val;\n\t\t\t}\n\t\t\t\n\t\t\ttry {\n\t\t\t\twfWAF::getInstance()->getStorageEngine()->setConfig($key, $val, 'synced');\n\t\t\t} catch (wfWAFStorageFileException $e) {\n\t\t\t\terror_log($e->getMessage());\n\t\t\t} catch (wfWAFStorageEngineMySQLiException $e) {\n\t\t\t\terror_log($e->getMessage());\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!self::$tableExists) {\n\t\t\treturn;\n\t\t\n\t\t}\n\t\t$table = self::table();\n\t\tif ($wpdb->query($wpdb->prepare(\"INSERT INTO {$table} (name, val, autoload) values (%s, %s, %s) ON DUPLICATE KEY UPDATE val = %s, autoload = %s\", $key, $val, $autoload, $val, $autoload)) !== false && $autoload != self::DONT_AUTOLOAD) {\n\t\t\tself::updateCachedOption($key, $val);\n\t\t}\n\t\t\n\t\tif (!WFWAF_SUBDIRECTORY_INSTALL && class_exists('wfWAFIPBlocksController') && (substr($key, 0, 4) == 'cbl_' || $key == 'blockedTime' || $key == 'disableWAFIPBlocking')) {\n\t\t\twfWAFIPBlocksController::setNeedsSynchronizeConfigSettings();\n\t\t} \n\t}\n\tpublic static function setJSON($key, $val, $autoload = self::AUTOLOAD) {\n\t\tself::set($key, @json_encode($val), $autoload);\n\t}\n\tpublic static function setBool($key, $val, $autoload = self::AUTOLOAD) {\n\t\tself::set($key, wfUtils::truthyToBoolean($val) ? 1 : 0, $autoload);\n\t}\n\tpublic static function setOrRemove($key, $value, $autoload = self::AUTOLOAD) {\n\t\tif ($value === null) {\n\t\t\tself::remove($key);\n\t\t}\n\t\telse {\n\t\t\tself::set($key, $value, $autoload);\n\t\t}\n\t}\n\tpublic static function get($key, $default = false, $allowCached = true, &$isDefault = false) {\n\t\tglobal $wpdb;\n\t\t\n\t\tif ($allowCached && self::hasCachedOption($key)) {\n\t\t\treturn self::getCachedOption($key);\n\t\t}\n\t\t\n\t\tif (!self::$tableExists) {\n\t\t\t$isDefault = true;\n\t\t\treturn $default;\n\t\t}\n\t\t\n\t\t$table = self::table();\n\t\tif (!($option = $wpdb->get_row($wpdb->prepare(\"SELECT name, val, autoload FROM {$table} WHERE name = %s\", $key)))) {\n\t\t\t$isDefault = true;\n\t\t\treturn $default;\n\t\t}\n\t\t\n\t\tif ($option->autoload != self::DONT_AUTOLOAD) {\n\t\t\tself::updateCachedOption($key, $option->val);\n\t\t}\n\t\treturn $option->val;\n\t}\n\t\n\tpublic static function getInt($key, $default = 0, $allowCached = true) {\n\t\treturn (int) self::get($key, $default, $allowCached);\n\t}\n\t\n\tpublic static function getJSON($key, $default = false, $allowCached = true) {\n\t\t$json = self::get($key, $default, $allowCached, $isDefault);\n\t\tif ($isDefault)\n\t\t\treturn $json;\n\t\t$decoded = @json_decode($json, true);\n\t\tif ($decoded === null) {\n\t\t\treturn $default;\n\t\t}\n\t\treturn $decoded;\n\t}\n\t\n\tpublic static function getBool($key, $default = false, $allowCached = true) {\n\t\treturn wfUtils::truthyToBoolean(self::get($key, $default, $allowCached));\n\t}\n\t\n\t\/**\n\t * Runs a test against the database to verify set_ser is working via MySQLi.\n\t * \n\t * @return bool\n\t *\/\n\tpublic static function testDB() {\n\t\t$nonce = bin2hex(wfWAFUtils::random_bytes(32));\n\t\t$payload = array('nonce' => $nonce);\n\t\t$allow = wfConfig::get('allowMySQLi', true);\n\t\twfConfig::set('allowMySQLi', true);\n\t\twfConfig::set_ser('dbTest', $payload, false, wfConfig::DONT_AUTOLOAD);\n\t\t\n\t\t$stored = wfConfig::get_ser('dbTest', false, false);\n\t\twfConfig::set('allowMySQLi', $allow);\n\t\t$result = false;\n\t\tif (is_array($stored) && isset($stored['nonce']) && hash_equals($nonce, $stored['nonce'])) {\n\t\t\t$result = true;\n\t\t}\n\t\t\n\t\twfConfig::delete_ser_chunked('dbTest');\n\t\treturn $result;\n\t}\n\t\n\tprivate static function canCompressValue() {\n\t\tif (!function_exists('gzencode') || !function_exists('gzdecode')) {\n\t\t\treturn false;\n\t\t}\n\t\t$disabled = explode(',', ini_get('disable_functions'));\n\t\tif (in_array('gzencode', $disabled) || in_array('gzdecode', $disabled)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tprivate static function isCompressedValue($data) {\n\t\t\/\/Based on http:\/\/www.ietf.org\/rfc\/rfc1952.txt\n\t\tif (strlen($data) < 2) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t$magicBytes = substr($data, 0, 2);\n\t\tif ($magicBytes !== (chr(0x1f) . chr(0x8b))) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t\/\/Small chance of false positives here -- can check the header CRC if it turns out it's needed\n\t\treturn true;\n\t}\n\t\n\tprivate static function ser_chunked_key($key) {\n\t\treturn 'wordfence_chunked_' . $key . '_';\n\t}\n\t\n\tpublic static function get_ser($key, $default = false, $cache = true) {\n\t\tif (self::hasCachedOption($key)) {\n\t\t\treturn self::getCachedOption($key);\n\t\t}\n\t\t\n\t\tif (!self::$tableExists) {\n\t\t\treturn $default;\n\t\t}\n\t\t\n\t\t\/\/Check for a chunked value first\n\t\t$chunkedValueKey = self::ser_chunked_key($key);\n\t\t$header = self::getDB()->querySingle(\"select val from \" . self::table() . \" where name=%s\", $chunkedValueKey . 'header');\n\t\tif ($header) {\n\t\t\t$header = unserialize($header);\n\t\t\t$count = $header['count'];\n\t\t\t$path = tempnam(sys_get_temp_dir(), $key); \/\/Writing to a file like this saves some of PHP's in-memory copying when just appending each chunk to a string\n\t\t\t$fh = fopen($path, 'r+');\n\t\t\t$length = 0;\n\t\t\tfor ($i = 0; $i < $count; $i++) {\n\t\t\t\t$chunk = self::getDB()->querySingle(\"select val from \" . self::table() . \" where name=%s\", $chunkedValueKey . $i);\n\t\t\t\tself::getDB()->flush(); \/\/clear cache\n\t\t\t\tif (!$chunk) {\n\t\t\t\t\twordfence::status(2, 'error', sprintf(\/* translators: Key in key-value store. *\/ __(\"Error reassembling value for %s\", 'wordfence'), $key));\n\t\t\t\t\treturn $default;\n\t\t\t\t}\n\t\t\t\tfwrite($fh, $chunk);\n\t\t\t\t$length += strlen($chunk);\n\t\t\t\tunset($chunk);\n\t\t\t}\n\t\t\t\n\t\t\tfseek($fh, 0);\n\t\t\t$serialized = fread($fh, $length);\n\t\t\tfclose($fh);\n\t\t\tunlink($path);\n\t\t\t\n\t\t\tif (self::canCompressValue() && self::isCompressedValue($serialized)) {\n\t\t\t\t$inflated = @gzdecode($serialized);\n\t\t\t\tif ($inflated !== false) {\n\t\t\t\t\tunset($serialized);\n\t\t\t\t\tif ($cache) {\n\t\t\t\t\t\tself::updateCachedOption($key, unserialize($inflated));\n\t\t\t\t\t\treturn self::getCachedOption($key);\n\t\t\t\t\t}\n\t\t\t\t\treturn unserialize($inflated);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ($cache) {\n\t\t\t\tself::updateCachedOption($key, unserialize($serialized));\n\t\t\t\treturn self::getCachedOption($key);\n\t\t\t}\n\t\t\treturn unserialize($serialized);\n\t\t}\n\t\telse {\n\t\t\t$serialized = self::getDB()->querySingle(\"select val from \" . self::table() . \" where name=%s\", $key);\n\t\t\tself::getDB()->flush(); \/\/clear cache\n\t\t\tif ($serialized) {\n\t\t\t\tif (self::canCompressValue() && self::isCompressedValue($serialized)) {\n\t\t\t\t\t$inflated = @gzdecode($serialized);\n\t\t\t\t\tif ($inflated !== false) {\n\t\t\t\t\t\tunset($serialized);\n\t\t\t\t\t\treturn unserialize($inflated);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ($cache) {\n\t\t\t\t\tself::updateCachedOption($key, unserialize($serialized));\n\t\t\t\t\treturn self::getCachedOption($key);\n\t\t\t\t}\n\t\t\t\treturn unserialize($serialized);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $default;\n\t}\n\t\n\tpublic static function set_ser($key, $val, $allowCompression = false, $autoload = self::AUTOLOAD) {\n\t\t\/*\n\t\t * Because of the small default value for `max_allowed_packet` and `max_long_data_size`, we're stuck splitting\n\t\t * large values into multiple chunks. To minimize memory use, the MySQLi driver is used directly when possible.\n\t\t *\/\n\t\t\n\t\tglobal $wpdb;\n\t\t$dbh = $wpdb->dbh;\n\t\t$useMySQLi = wfUtils::useMySQLi();\n\t\t\n\t\tif (!self::$tableExists) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tself::_handleActionHooks($key, $val);\n\t\t\n\t\tself::delete_ser_chunked($key); \/\/Ensure any old values for a chunked value are deleted first\n\t\t\n\t\tif (self::canCompressValue() && $allowCompression) {\n\t\t\t$data = gzencode(serialize($val));\n\t\t}\n\t\telse {\n\t\t\t$data = serialize($val);\n\t\t}\n\t\t\n\t\tif (!$useMySQLi) {\n\t\t\t$data = bin2hex($data);\n\t\t}\n\t\t\n\t\t$dataLength = strlen($data);\n\t\t$maxAllowedPacketBytes = self::getDB()->getMaxAllowedPacketBytes();\n\t\t$chunkSize = intval((($maxAllowedPacketBytes < 1024 \/* MySQL minimum, probably failure to fetch it *\/ ? 1024 * 1024 \/* MySQL default *\/ : $maxAllowedPacketBytes) - 50) \/ 1.2); \/\/Based on max_allowed_packet + 20% for escaping and SQL\n\t\t$chunkSize = $chunkSize - ($chunkSize % 2); \/\/Ensure it's even\n\t\t$chunkedValueKey = self::ser_chunked_key($key);\n\t\tif ($dataLength > $chunkSize) {\n\t\t\t$chunks = 0;\n\t\t\twhile (($chunks * $chunkSize) < $dataLength) {\n\t\t\t\t$dataChunk = substr($data, $chunks * $chunkSize, $chunkSize);\n\t\t\t\tif ($useMySQLi) {\n\t\t\t\t\t$chunkKey = $chunkedValueKey . $chunks;\n\t\t\t\t\t$stmt = $dbh->prepare(\"INSERT IGNORE INTO \" . self::table() . \" (name, val, autoload) VALUES (?, ?, 'no')\");\n\t\t\t\t\tif ($stmt === false) {\n\t\t\t\t\t\twordfence::status(2, 'error', sprintf(\n\t\t\t\t\t\t\/* translators: 1. Key in key-value store. 2. MySQL error number. 3. MySQL error message. *\/\n\t\t\t\t\t\t\t__('Error writing value chunk for %1$s (MySQLi error: [%2$s] %3$s)', 'wordfence'), $key, $dbh->errno, $dbh->error));\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t$null = NULL;\n\t\t\t\t\t$stmt->bind_param(\"sb\", $chunkKey, $null);\n\t\t\t\t\t\n\t\t\t\t\tif (!$stmt->send_long_data(1, $dataChunk)) {\n\t\t\t\t\t\twordfence::status(2, 'error', sprintf(\n\t\t\t\t\t\t\/* translators: 1. Key in key-value store. 2. MySQL error number. 3. MySQL error message. *\/\n\t\t\t\t\t\t\t__('Error writing value chunk for %1$s (MySQLi error: [%2$s] %3$s)', 'wordfence'), $key, $dbh->errno, $dbh->error));\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (!$stmt->execute()) {\n\t\t\t\t\t\twordfence::status(2, 'error', sprintf(\n\t\t\t\t\t\t\/* translators: 1. Key in key-value store. 2. MySQL error number. 3. MySQL error message. *\/\n\t\t\t\t\t\t\t__('Error writing value chunk for %1$s (MySQLi error: [%2$s] %3$s)', 'wordfence'), $key, $dbh->errno, $dbh->error));\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!self::getDB()->queryWrite(sprintf(\"insert ignore into \" . self::table() . \" (name, val, autoload) values (%%s, X'%s', 'no')\", $dataChunk), $chunkedValueKey . $chunks)) {\n\t\t\t\t\t\tif ($useMySQLi) {\n\t\t\t\t\t\t\t$errno = mysqli_errno($wpdb->dbh);\n\t\t\t\t\t\t\twordfence::status(2, 'error', sprintf(\n\t\t\t\t\t\t\t\/* translators: 1. Key in key-value store. 2. MySQL error number. 3. MySQL error message. *\/\n\t\t\t\t\t\t\t\t__('Error writing value chunk for %1$s (MySQLi error: [%2$s] %3$s)', 'wordfence'), $key, $errno, $wpdb->last_error));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (function_exists('mysql_errno')) {\n\t\t\t\t\t\t\t\/\/ phpcs:ignore PHPCompatibility.Extensions.RemovedExtensions.mysql_DeprecatedRemoved\n\t\t\t\t\t\t\t$errno = mysql_errno($wpdb->dbh);\n\t\t\t\t\t\t\twordfence::status(2, 'error', sprintf(\n\t\t\t\t\t\t\t\/* translators: 1. Key in key-value store. 2. MySQL error number. 3. MySQL error message. *\/\n\t\t\t\t\t\t\t\t__('Error writing value chunk for %1$s (MySQLi error: [%2$s] %3$s)', 'wordfence'), $key, $errno, $wpdb->last_error));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$chunks++;\n\t\t\t}\n\t\t\t\n\t\t\tif (!self::getDB()->queryWrite(sprintf(\"insert ignore into \" . self::table() . \" (name, val, autoload) values (%%s, X'%s', 'no')\", bin2hex(serialize(array('count' => $chunks)))), $chunkedValueKey . 'header')) {\n\t\t\t\twordfence::status(2, 'error', sprintf(\n\t\t\t\t\/* translators: Key in key-value store. *\/\n\t\t\t\t\t__(\"Error writing value header for %s\", 'wordfence'), $key));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t$exists = self::getDB()->querySingle(\"select name from \" . self::table() . \" where name='%s'\", $key);\n\t\t\t\n\t\t\tif ($useMySQLi) {\n\t\t\t\tif ($exists) {\n\t\t\t\t\t$stmt = $dbh->prepare(\"UPDATE \" . self::table() . \" SET val=?, autoload=? WHERE name=?\");\n\t\t\t\t\tif ($stmt === false) {\n\t\t\t\t\t\twordfence::status(2, 'error', sprintf(\n\t\t\t\t\t\t\/* translators: 1. Key in key-value store. 2. MySQL error number. 3. MySQL error message. *\/\n\t\t\t\t\t\t\t__('Error writing value for %1$s (MySQLi error: [%2$s] %3$s)', 'wordfence'), $key, $dbh->errno, $dbh->error));\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t$null = NULL;\n\t\t\t\t\t$stmt->bind_param(\"bss\", $null, $autoload, $key);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$stmt = $dbh->prepare(\"INSERT IGNORE INTO \" . self::table() . \" (val, name, autoload) VALUES (?, ?, ?)\");\n\t\t\t\t\tif ($stmt === false) {\n\t\t\t\t\t\twordfence::status(2, 'error', sprintf(\n\t\t\t\t\t\t\/* translators: 1. Key in key-value store. 2. MySQL error number. 3. MySQL error message. *\/\n\t\t\t\t\t\t\t__('Error writing value for %1$s (MySQLi error: [%2$s] %3$s)', 'wordfence'), $key, $dbh->errno, $dbh->error));\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t$null = NULL;\n\t\t\t\t\t$stmt->bind_param(\"bss\", $null, $key, $autoload);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!$stmt->send_long_data(0, $data)) {\n\t\t\t\t\twordfence::status(2, 'error', sprintf(\n\t\t\t\t\t\/* translators: 1. Key in key-value store. 2. MySQL error number. 3. MySQL error message. *\/\n\t\t\t\t\t\t__('Error writing value for %1$s (MySQLi error: [%2$s] %3$s)', 'wordfence'), $key, $dbh->errno, $dbh->error));\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!$stmt->execute()) {\n\t\t\t\t\twordfence::status(2, 'error', sprintf(\n\t\t\t\t\t\/* translators: 1. Key in key-value store. 2. MySQL error number. 3. MySQL error message. *\/\n\t\t\t\t\t__('Error finishing writing value for %1$s (MySQLi error: [%2$s] %3$s)', 'wordfence'), $key, $dbh->errno, $dbh->error));\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ($exists) {\n\t\t\t\t\tself::getDB()->queryWrite(sprintf(\"update \" . self::table() . \" set val=X'%s', autoload=%%s where name=%%s\", $data), $autoload, $key);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tself::getDB()->queryWrite(sprintf(\"insert ignore into \" . self::table() . \" (name, val, autoload) values (%%s, X'%s', %%s)\", $data), $key, $autoload);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tself::getDB()->flush();\n\t\t\n\t\tif ($autoload != self::DONT_AUTOLOAD) {\n\t\t\tself::updateCachedOption($key, $val);\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tprivate static function delete_ser_chunked($key) {\n\t\tif (!self::$tableExists) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tself::removeCachedOption($key);\n\t\t\n\t\t$chunkedValueKey = self::ser_chunked_key($key);\n\t\t$header = self::getDB()->querySingle(\"select val from \" . self::table() . \" where name=%s\", $chunkedValueKey . 'header');\n\t\tif (!$header) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t$header = unserialize($header);\n\t\t$count = $header['count'];\n\t\tfor ($i = 0; $i < $count; $i++) {\n\t\t\tself::getDB()->queryWrite(\"delete from \" . self::table() . \" where name='%s'\", $chunkedValueKey . $i);\n\t\t}\n\t\tself::getDB()->queryWrite(\"delete from \" . self::table() . \" where name='%s'\", $chunkedValueKey . 'header');\n\t}\n\tpublic static function f($key){\n\t\techo esc_attr(self::get($key));\n\t}\n\tpublic static function p() {\n\t\treturn self::get('isPaid');\n\t}\n\tpublic static function cbp($key){\n\t\tif(self::get('isPaid') && self::get($key)){\n\t\t\techo ' checked ';\n\t\t}\n\t}\n\tpublic static function cb($key){\n\t\tif(self::get($key)){\n\t\t\techo ' checked ';\n\t\t}\n\t}\n\tpublic static function sel($key, $val, $isDefault = false){\n\t\tif((! self::get($key)) && $isDefault){ echo ' selected '; }\n\t\tif(self::get($key) == $val){ echo ' selected '; }\n\t}\n\tprivate static function getDB(){\n\t\tif(! self::$DB){ \n\t\t\tself::$DB = new wfDB();\n\t\t}\n\t\treturn self::$DB;\n\t}\n\tprivate static function table(){\n\t\treturn wfDB::networkTable('wfConfig');\n\t}\n\tpublic static function haveAlertEmails(){\n\t\t$emails = self::getAlertEmails();\n\t\treturn sizeof($emails) > 0 ? true : false;\n\t}\n\tpublic static function alertEmailBlacklist() {\n\t\treturn array('3c4aa9bd643bd9bb9873014227151a85b24ab8d72fe02cc5799b0edc56eabb67', 'aa06081e3962a3c17a85a06ddf9e418ca1ba8fead3f9b7a20beaf51848a1fd75', 'a25a360bded101e25ebabe5643161ddbb6c3fa33838bbe9a123c2ec0cda8d370', '36e8407dfa80d64cfe42ede4d9d5ce2d4840a5e4781b5f8a7b3b8eacec86fcad', '50cf95aec25369583efdfeff9f0818b4b9266f10e140ea2b648e30202450c21b', '72a09e746cb90ff2646ba1f1d0c0f5ffed6b380642bbbf826d273fffa6ef673b');\n\t}\n\tpublic static function getAlertEmails() {\n\t\t$blacklist = self::alertEmailBlacklist();\n\t\t$dat = explode(',', self::get('alertEmails'));\n\t\t$emails = array();\n\t\tforeach ($dat as $email) {\n\t\t\t$email = strtolower(trim($email));\n\t\t\tif (preg_match('\/\\@\/', $email)) {\n\t\t\t\t$hash = hash('sha256', $email);\n\t\t\t\tif (!in_array($hash, $blacklist)) {\n\t\t\t\t\t$emails[] = $email;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn $emails;\n\t}\n\tpublic static function getAlertLevel(){\n\t\tif (self::get('alertOn_scanIssues')) {\n\t\t\treturn self::get('alertOn_severityLevel', 0);\n\t\t}\n\t\treturn 0;\n\t}\n\tpublic static function liveTrafficEnabled(&$overriden = null){\n\t\t$enabled = self::get('liveTrafficEnabled');\n\t\tif (WORDFENCE_DISABLE_LIVE_TRAFFIC || WF_IS_WP_ENGINE) {\n\t\t\t$enabled = false;\n\t\t\tif ($overriden !== null) {\n\t\t\t\t$overriden = true;\n\t\t\t}\n\t\t}\n\t\treturn $enabled;\n\t}\n\tpublic static function enableAutoUpdate(){\n\t\twfConfig::set('autoUpdate', '1');\n\t\twp_clear_scheduled_hook('wordfence_daily_autoUpdate');\n\t\tif (is_main_site()) {\n\t\t\twp_schedule_event(time(), 'daily', 'wordfence_daily_autoUpdate');\n\t\t}\n\t}\n\tpublic static function disableAutoUpdate(){\n\t\twfConfig::set('autoUpdate', '0');\t\n\t\twp_clear_scheduled_hook('wordfence_daily_autoUpdate');\n\t}\n\tpublic static function createLock($name, $timeout = null) { \/\/Our own version of WP_Upgrader::create_lock that uses our table instead\n\t\tglobal $wpdb;\n\t\t\n\t\tif (!$timeout) {\n\t\t\t$timeout = 3600;\n\t\t}\n\t\t\n\t\t$table = self::table();\n\t\t\n\t\t$lock_option = $name . '.lock';\n\t\t$lock_result = $wpdb->query($wpdb->prepare(\"INSERT IGNORE INTO `$table` (`name`, `val`, `autoload`) VALUES (%s, %s, 'no')\", $lock_option, time()));\n\t\t\n\t\tif (!$lock_result) {\n\t\t\t$lock_result = self::get($lock_option, false, false);\n\t\t\tif (!$lock_result) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tif ($lock_result > (time() - $timeout)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tself::releaseLock($name);\n\t\t\treturn self::createLock($name, $timeout);\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\tpublic static function releaseLock($name) {\n\t\tself::remove($name . '.lock');\n\t}\n\tpublic static function autoUpdate(){\n\t\trequire(dirname(__FILE__) . '\/wfVersionSupport.php');\n\t\t\/**\n\t\t * @var string $wfPHPDeprecatingVersion\n\t\t * @var string $wfPHPMinimumVersion\n\t\t *\/\n\t\tif (version_compare(PHP_VERSION, $wfPHPMinimumVersion, '<')) {\n\t\t\treturn;\n\t\t}\n\n\t\t\/\/ Prevent WF auto-update if the user has enabled auto-update through the plugins page.\n\t\tif (version_compare(wfUtils::getWPVersion(), '5.5-x', '>=')) {\n\t\t\t$autoUpdatePlugins = get_site_option('auto_update_plugins');\n\t\t\tif (is_array($autoUpdatePlugins) && in_array(WORDFENCE_BASENAME, $autoUpdatePlugins)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (!wfConfig::get('other_bypassLitespeedNoabort', false) && getenv('noabort') != '1' && stristr($_SERVER['SERVER_SOFTWARE'], 'litespeed') !== false) {\n\t\t\t$lastEmail = self::get('lastLiteSpdEmail', false);\n\t\t\tif( (! $lastEmail) || (time() - (int)$lastEmail > (86400 * 30))){\n\t\t\t\tself::set('lastLiteSpdEmail', time());\n\t\t\t\twordfence::alert(\n\t\t\t\t\/* translators: Support URL. *\/\n\t\t\t\t__(\"Wordfence Upgrade not run. Please modify your .htaccess\", 'wordfence'), sprintf(__(\"To preserve the integrity of your website we are not running Wordfence auto-update.\\n\" .\n\t\t\t\t\t\"You are running the LiteSpeed web server which has been known to cause a problem with Wordfence auto-update.\\n\" .\n\t\t\t\t\t\"Please go to your website now and make a minor change to your .htaccess to fix this.\\n\" .\n\t\t\t\t\t\"You can find out how to make this change at:\\n\" .\n\t\t\t\t\t\"%s\\n\" .\n\t\t\t\t\t\"\\nAlternatively you can disable auto-update on your website to stop receiving this message and upgrade Wordfence manually.\\n\", 'wordfence'), wfSupportController::supportURL(wfSupportController::ITEM_DASHBOARD_OPTION_LITESPEED_WARNING)),\n\t\t\t\t\tfalse\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t$runUpdate = false;\n\t\twp_update_plugins();\n\t\t$update_plugins = get_site_transient('update_plugins');\n\t\tif ($update_plugins && is_array($update_plugins->response) && isset($update_plugins->response[WORDFENCE_BASENAME])) {\n\t\t\t$status = $update_plugins->response[WORDFENCE_BASENAME];\n\t\t\tif (is_object($status) && property_exists($status, 'new_version')) {\n\t\t\t\t$runUpdate = (version_compare($status->new_version, WORDFENCE_VERSION) > 0);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif ($runUpdate) {\n\t\t\ttry {\n\t\t\t\t$api = new wfAPI(wfConfig::get('apiKey'), wfUtils::getWPVersion());\n\t\t\t\t$response = $api->call('should_auto_update', array(), array('currentVersion' => WORDFENCE_VERSION));\n\t\t\t\tif (!(is_array($response) && isset($response['ok']) && wfUtils::truthyToBoolean($response['ok']))) {\n\t\t\t\t\t$runUpdate = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception $e) {\n\t\t\t\twfConfig::inc('autoUpdateAttempts');\n\t\t\t\t$runUpdate = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!$runUpdate && wfConfig::get('autoUpdateAttempts') < 7) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\ttry {\n\t\t\trequire_once(ABSPATH . 'wp-admin\/includes\/class-wp-upgrader.php');\n\t\t\trequire_once(ABSPATH . 'wp-admin\/includes\/misc.php');\n\t\t\t\/* We were creating show_message here so that WP did not write to STDOUT. This had the strange effect of throwing an error about redeclaring show_message function, but only when a crawler hit the site and triggered the cron job. Not a human. So we're now just require'ing misc.php which does generate output, but that's OK because it is a loopback cron request.  \n\t\t\tif(! function_exists('show_message')){ \n\t\t\t\tfunction show_message($msg = 'null'){}\n\t\t\t}\n\t\t\t*\/\n\t\t\tif(! defined('FS_METHOD')){ \n\t\t\t\tdefine('FS_METHOD', 'direct'); \/\/May be defined already and might not be 'direct' so this could cause problems. But we were getting reports of a warning that this is already defined, so this check added. \n\t\t\t}\n\t\t\trequire_once(ABSPATH . 'wp-includes\/update.php');\n\t\t\trequire_once(ABSPATH . 'wp-admin\/includes\/file.php');\n\t\t\t\n\t\t\tif (!self::createLock('wfAutoUpdate')) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tob_start();\n\t\t\t$upgrader = new Plugin_Upgrader();\n\t\t\t$upret = $upgrader->upgrade(WORDFENCE_BASENAME);\n\t\t\tif($upret){\n\t\t\t\t$cont = file_get_contents(WORDFENCE_FCPATH);\n\t\t\t\tpreg_match('\/Version: (\\d+\\.\\d+\\.\\d+)\/', $cont, $matches);\n\t\t\t\t$version = !empty($matches) ? $matches[1] : null;\n\t\t\t\t$alertCallback = array(new wfAutoUpdatedAlert($version), 'send');\n\t\t\t\tdo_action('wordfence_security_event', 'autoUpdate', array(\n\t\t\t\t\t'version' => $version,\n\t\t\t\t), $alertCallback);\n\n\t\t\t\twfConfig::set('autoUpdateAttempts', 0);\n\t\t\t}\n\t\t\t$output = @ob_get_contents();\n\t\t\t@ob_end_clean();\n\t\t} catch(Exception $e){}\n\t\t\n\t\tself::releaseLock('wfAutoUpdate');\n\t}\n\t\n\t\/**\n\t * .htaccess file contents to disable all script execution in a given directory.\n\t *\/\n\tprivate static $_disable_scripts_htaccess = '# BEGIN Wordfence code execution protection\n<IfModule mod_php5.c>\nphp_flag engine 0\n<\/IfModule>\n<IfModule mod_php7.c>\nphp_flag engine 0\n<\/IfModule>\n<IfModule mod_php.c>\nphp_flag engine 0\n<\/IfModule>\n\nAddHandler cgi-script .php .phtml .php3 .pl .py .jsp .asp .htm .shtml .sh .cgi\nOptions -ExecCGI\n# END Wordfence code execution protection\n';\n\tprivate static $_disable_scripts_regex = '\/# BEGIN Wordfence code execution protection.+?# END Wordfence code execution protection\/s';\n\t\n\tprivate static function _uploadsHtaccessFilePath() {\n\t\t$upload_dir = wp_upload_dir();\n\t\treturn $upload_dir['basedir'] . '\/.htaccess';\n\t}\n\n\t\/**\n\t * Add\/Merge .htaccess file in the uploads directory to prevent code execution.\n\t *\n\t * @return bool\n\t * @throws wfConfigException\n\t *\/\n\tpublic static function disableCodeExecutionForUploads() {\n\t\t$uploads_htaccess_file_path = self::_uploadsHtaccessFilePath();\n\t\t$uploads_htaccess_has_content = false;\n\t\tif (file_exists($uploads_htaccess_file_path)) {\n\t\t\t$htaccess_contents = file_get_contents($uploads_htaccess_file_path);\n\t\t\t\n\t\t\t\/\/ htaccess exists and contains our htaccess code to disable script execution, nothing more to do\n\t\t\tif (strpos($htaccess_contents, self::$_disable_scripts_htaccess) !== false) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t$uploads_htaccess_has_content = strlen(trim($htaccess_contents)) > 0;\n\t\t}\n\t\tif (@file_put_contents($uploads_htaccess_file_path, ($uploads_htaccess_has_content ? \"\\n\\n\" : \"\") . self::$_disable_scripts_htaccess, FILE_APPEND | LOCK_EX) === false) {\n\t\t\tthrow new wfConfigException(__(\"Unable to save the .htaccess file needed to disable script execution in the uploads directory. Please check your permissions on that directory.\", 'wordfence'));\n\t\t}\n\t\tself::set('disableCodeExecutionUploadsPHP7Migrated', true);\n\t\treturn true;\n\t}\n\t\n\tpublic static function migrateCodeExecutionForUploadsPHP7() {\n\t\tif (self::get('disableCodeExecutionUploads')) {\n\t\t\tif (!self::get('disableCodeExecutionUploadsPHP7Migrated')) {\n\t\t\t\t$uploads_htaccess_file_path = self::_uploadsHtaccessFilePath();\n\t\t\t\tif (file_exists($uploads_htaccess_file_path)) {\n\t\t\t\t\t$htaccess_contents = file_get_contents($uploads_htaccess_file_path);\n\t\t\t\t\tif (preg_match(self::$_disable_scripts_regex, $htaccess_contents)) {\n\t\t\t\t\t\t$htaccess_contents = preg_replace(self::$_disable_scripts_regex, self::$_disable_scripts_htaccess, $htaccess_contents); \n\t\t\t\t\t\t@file_put_contents($uploads_htaccess_file_path, $htaccess_contents);\n\t\t\t\t\t\tself::set('disableCodeExecutionUploadsPHP7Migrated', true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t\/**\n\t * Remove script execution protections for our the .htaccess file in the uploads directory.\n\t *\n\t * @return bool\n\t * @throws wfConfigException\n\t *\/\n\tpublic static function removeCodeExecutionProtectionForUploads() {\n\t\t$uploads_htaccess_file_path = self::_uploadsHtaccessFilePath();\n\t\tif (file_exists($uploads_htaccess_file_path)) {\n\t\t\t$htaccess_contents = file_get_contents($uploads_htaccess_file_path);\n\n\t\t\t\/\/ Check that it is in the file\n\t\t\tif (preg_match(self::$_disable_scripts_regex, $htaccess_contents)) {\n\t\t\t\t$htaccess_contents = preg_replace(self::$_disable_scripts_regex, '', $htaccess_contents);\n\n\t\t\t\t$error_message = __(\"Unable to remove code execution protections applied to the .htaccess file in the uploads directory. Please check your permissions on that file.\", 'wordfence');\n\t\t\t\tif (strlen(trim($htaccess_contents)) === 0) {\n\t\t\t\t\t\/\/ empty file, remove it\n\t\t\t\t\tif (!@unlink($uploads_htaccess_file_path)) {\n\t\t\t\t\t\tthrow new wfConfigException($error_message);\n\t\t\t\t\t}\n\n\t\t\t\t} elseif (@file_put_contents($uploads_htaccess_file_path, $htaccess_contents, LOCK_EX) === false) {\n\t\t\t\t\tthrow new wfConfigException($error_message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\t\/**\n\t * Validates the array of configuration changes without applying any. All bounds checks must be performed here.\n\t *\n\t * @param array $changes\n\t * @return bool|array Returns true if valid, otherwise a displayable error message per error encountered.\n\t * @throws wfWAFStorageFileException\n\t *\/\n\tpublic static function validate($changes) {\n\t\t$errors = array();\n\t\t$waf = wfWAF::getInstance();\n\t\t$wafConfig = $waf->getStorageEngine();\n\t\t\n\t\tforeach ($changes as $key => $value) {\n\t\t\t$checked = false;\n\t\t\tswitch ($key) {\n\t\t\t\t\/\/============ WAF\n\t\t\t\tcase 'learningModeGracePeriod':\n\t\t\t\t{\n\t\t\t\t\t\/\/If currently in or will be in learning mode, restrict the grace period to be in the future\n\t\t\t\t\t$wafStatus = (isset($changes['wafStatus']) ? $changes['wafStatus'] : $wafConfig->getConfig('wafStatus'));\n\t\t\t\t\t$gracePeriodEnd = strtotime($value);\n\t\t\t\t\tif ($wafStatus == wfFirewall::FIREWALL_MODE_LEARNING && $gracePeriodEnd <= time()) {\n\t\t\t\t\t\t$errors[] = array('option' => $key, 'error' => __('The grace period end time must be in the future.', 'wordfence'));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$checked = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'wafStatus':\n\t\t\t\t{\n\t\t\t\t\tif ($value != wfFirewall::FIREWALL_MODE_ENABLED && $value != wfFirewall::FIREWALL_MODE_LEARNING && $value != wfFirewall::FIREWALL_MODE_DISABLED) {\n\t\t\t\t\t\t$errors[] = array('option' => $key, 'error' => __('Unknown firewall mode.', 'wordfence'));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$checked = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\/\/============ Plugin\n\t\t\t\tcase 'alertEmails':\n\t\t\t\t{\n\t\t\t\t\t$dirtyEmails = !is_string($value) ? '' : $value;\n\t\t\t\t\t$dirtyEmails = explode(',', preg_replace('\/[\\r\\n\\s\\t]+\/', '', $dirtyEmails));\n\t\t\t\t\t$dirtyEmails = array_filter($dirtyEmails);\n\t\t\t\t\t$badEmails = array();\n\t\t\t\t\tforeach ($dirtyEmails as $email) {\n\t\t\t\t\t\tif (!wfUtils::isValidEmail($email)) {\n\t\t\t\t\t\t\t$badEmails[] = $email;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (count($badEmails) > 0) {\n\t\t\t\t\t\t$errors[] = array('option' => $key, 'error' => __('The following emails are invalid: ', 'wordfence') . esc_html(implode(', ', $badEmails), array()));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$checked = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'scan_include_extra':\n\t\t\t\t{\n\t\t\t\t\t$dirtyRegexes = !is_string($value) ? '' : $value;\n\t\t\t\t\t$dirtyRegexes = explode(\"\\n\", $dirtyRegexes);\n\t\t\t\t\tforeach ($dirtyRegexes as $regex) {\n\t\t\t\t\t\tif (@preg_match(\"\/$regex\/\", \"\") === false) {\n\t\t\t\t\t\t\t$errors[] = array('option' => $key, 'error' => sprintf(\n\t\t\t\t\t\t\t\/* translators: Regular expression. *\/\n\t\t\t\t\t\t\t\t__('\"%s\" is not a valid regular expression.', 'wordfence'), esc_html($regex)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t$checked = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'whitelisted':\n\t\t\t\t{\n\t\t\t\t\t$dirtyWhitelisted = !is_string($value) ? '' : $value;\n\t\t\t\t\t$dirtyWhitelisted = explode(',', preg_replace('\/[\\r\\n\\s\\t]+\/', ',', $dirtyWhitelisted));\n\t\t\t\t\t$dirtyWhitelisted = array_filter($dirtyWhitelisted);\n\t\t\t\t\t$badWhiteIPs = array();\n\t\t\t\t\t$range = new wfUserIPRange();\n\t\t\t\t\tforeach ($dirtyWhitelisted as $whiteIP) {\n\t\t\t\t\t\t$range->setIPString($whiteIP);\n\t\t\t\t\t\tif (!$range->isValidRange()) {\n\t\t\t\t\t\t\t$badWhiteIPs[] = $whiteIP;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (count($badWhiteIPs) > 0) {\n\t\t\t\t\t\t$errors[] = array('option' => $key, 'error' => __('Please make sure you separate your IP addresses with commas or newlines. The following allowlisted IP addresses are invalid: ', 'wordfence') . esc_html(implode(', ', $badWhiteIPs), array()));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$checked = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'liveTraf_ignoreUsers':\n\t\t\t\t{\n\t\t\t\t\t$dirtyUsers = !is_string($value) ? '' : $value;\n\t\t\t\t\t$dirtyUsers = explode(',', $dirtyUsers);\n\t\t\t\t\t$invalidUsers = array();\n\t\t\t\t\tforeach ($dirtyUsers as $val) {\n\t\t\t\t\t\t$val = trim($val);\n\t\t\t\t\t\tif (strlen($val) > 0) {\n\t\t\t\t\t\t\tif (!get_user_by('login', $val)) {\n\t\t\t\t\t\t\t\t$invalidUsers[] = $val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (count($invalidUsers) > 0) {\n\t\t\t\t\t\t$errors[] = array('option' => $key, 'error' => __('The following users you selected to ignore in live traffic reports are not valid on this system: ', 'wordfence') . esc_html(implode(', ', $invalidUsers), array()));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$checked = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'liveTraf_ignoreIPs':\n\t\t\t\t{\n\t\t\t\t\t$dirtyIPs = !is_string($value) ? '' : $value;\n\t\t\t\t\t$dirtyIPs = explode(',', preg_replace('\/[\\r\\n\\s\\t]+\/', '', $dirtyIPs));\n\t\t\t\t\t$dirtyIPs = array_filter($dirtyIPs);\n\t\t\t\t\t$invalidIPs = array();\n\t\t\t\t\tforeach ($dirtyIPs as $val) {\n\t\t\t\t\t\tif (!wfUtils::isValidIP($val)) {\n\t\t\t\t\t\t\t$invalidIPs[] = $val;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (count($invalidIPs) > 0) {\n\t\t\t\t\t\t$errors[] = array('option' => $key, 'error' => __('The following IPs you selected to ignore in live traffic reports are not valid: ', 'wordfence') . esc_html(implode(', ', $invalidIPs), array()));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$checked = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'howGetIPs_trusted_proxies':\n\t\t\t\t{\n\t\t\t\t\t$dirtyIPs = !is_string($value) ? '' : $value;\n\t\t\t\t\t$dirtyIPs = preg_split('\/[\\r\\n,]+\/', $dirtyIPs);\n\t\t\t\t\t$dirtyIPs = array_filter($dirtyIPs);\n\t\t\t\t\t$invalidIPs = array();\n\t\t\t\t\tforeach ($dirtyIPs as $val) {\n\t\t\t\t\t\tif (!(wfUtils::isValidIP($val) || wfUtils::isValidCIDRRange($val))) {\n\t\t\t\t\t\t\t$invalidIPs[] = $val;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (count($invalidIPs) > 0) {\n\t\t\t\t\t\t$errors[] = array('option' => $key, 'error' => __('The following IPs\/ranges you selected to trust as proxies are not valid: ', 'wordfence') . esc_html(implode(', ', $invalidIPs), array()));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$checked = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'howGetIPs_trusted_proxy_preset':\n\t\t\t\t{\n\t\t\t\t\t$presets = wfConfig::getJSON('ipResolutionList', array());\n\t\t\t\t\tif (!is_array($presets)) {\n\t\t\t\t\t\t$presets = array();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (!(empty($value) \/* \"None\" *\/ || isset($presets[$value]))) {\n\t\t\t\t\t\t$errors[] = array('option' => $key, 'error' => __('The selected trusted proxy preset is not valid: ', 'wordfence') . esc_html($value));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$checked = true;\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'apiKey':\n\t\t\t\t{\n\t\t\t\t\t$value = trim($value);\n\t\t\t\t\tif (empty($value)) {\n\t\t\t\t\t\t$errors[] = array('option' => $key, 'error' => __('An empty license key was entered.', 'wordfence'));\n\t\t\t\t\t}\n\t\t\t\t\telse if ($value && !preg_match('\/^[a-fA-F0-9]+$\/', $value)) {\n\t\t\t\t\t\t$errors[] = array('option' => $key, 'error' => __('The license key entered is not in a valid format. It must contain only numbers and the letters A-F.', 'wordfence'));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$checked = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'scan_exclude':\n\t\t\t\t{\n\t\t\t\t\t$exclusionList = explode(\"\\n\", trim($value));\n\t\t\t\t\tforeach ($exclusionList as $exclusion) {\n\t\t\t\t\t\t$exclusion = trim($exclusion);\n\t\t\t\t\t\tif ($exclusion === '*') {\n\t\t\t\t\t\t\t$errors[] = array('option' => $key, 'error' => __('A wildcard cannot be used to exclude all files from the scan.', 'wordfence'));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t$checked = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'scan_max_resume_attempts':\n\t\t\t\t{\n\t\t\t\t\t$value = (int) $value;\n\t\t\t\t\twfScanMonitor::validateResumeAttempts($value, $valid);\n\t\t\t\t\tif (!$valid)\n\t\t\t\t\t\t$errors[] = array('option' => $key, 'error' => sprintf(__('Invalid number of scan resume attempts specified: %d', 'wordfence'), $value));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (empty($errors)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn $errors;\n\t}\n\t\n\tpublic static function clean($changes) {\n\t\t$cleaned = array();\n\t\tforeach ($changes as $key => $value) {\n\t\t\tif (preg_match('\/^whitelistedServices\\.([a-z0-9]+)$\/i', $key, $matches)) {\n\t\t\t\tif (!isset($cleaned['whitelistedServices']) || !is_array($cleaned['whitelistedServices'])) {\n\t\t\t\t\t$cleaned['whitelistedServices'] = wfConfig::getJSON('whitelistedServices', array());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t$cleaned['whitelistedServices'][$matches[1]] = wfUtils::truthyToBoolean($value);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$cleaned[$key] = $value;\n\t\t\t}\n\t\t}\n\t\treturn $cleaned;\n\t}\n\t\n\t\/**\n\t * Saves the array of configuration changes in the correct place. This may currently be the wfConfig table, the WAF's config file, or both. The\n\t * validation function will handle all bounds checks and this will be limited to normalizing the values as needed.\n\t * \n\t * @param array $changes\n\t * @throws wfConfigException\n\t * @throws wfWAFStorageFileException\n\t *\/\n\tpublic static function save($changes) {\n\t\t$waf = wfWAF::getInstance();\n\t\t$wafConfig = $waf->getStorageEngine();\n\t\t\n\t\t$events = array();\n\t\t\n\t\t$apiKey = false;\n\t\tif (isset($changes['apiKey'])) { \/\/Defer to end\n\t\t\t$apiKey = $changes['apiKey'];\n\t\t\tunset($changes['apiKey']);\n\t\t}\n\t\t\n\t\tforeach ($changes as $key => $value) {\n\t\t\t$saved = false;\n\t\t\tswitch ($key) {\n\t\t\t\t\/\/============ WAF\n\t\t\t\tcase 'learningModeGracePeriod':\n\t\t\t\t{\n\t\t\t\t\t$wafStatus = (isset($changes['wafStatus']) ? $changes['wafStatus'] : $wafConfig->getConfig('wafStatus'));\n\t\t\t\t\tif ($wafStatus == wfFirewall::FIREWALL_MODE_LEARNING) {\n\t\t\t\t\t\t$dt = wfUtils::parseLocalTime($value);\n\t\t\t\t\t\t$gracePeriodEnd = $dt->format('U');\n\t\t\t\t\t\t$wafConfig->setConfig($key, $gracePeriodEnd);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$saved = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'learningModeGracePeriodEnabled':\n\t\t\t\t{\n\t\t\t\t\t$wafStatus = (isset($changes['wafStatus']) ? $changes['wafStatus'] : $wafConfig->getConfig('wafStatus'));\n\t\t\t\t\tif ($wafStatus == wfFirewall::FIREWALL_MODE_LEARNING) {\n\t\t\t\t\t\t$wafConfig->setConfig($key, wfUtils::truthyToInt($value));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$saved = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'wafStatus':\n\t\t\t\t{\n\t\t\t\t\t$before = $wafConfig->getConfig($key);\n\t\t\t\t\t$wafConfig->setConfig($key, $value);\n\t\t\t\t\tif ($value != wfFirewall::FIREWALL_MODE_LEARNING) {\n\t\t\t\t\t\t$wafConfig->setConfig('learningModeGracePeriodEnabled', 0);\n\t\t\t\t\t\t$wafConfig->unsetConfig('learningModeGracePeriod');\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$firewall = new wfFirewall();\n\t\t\t\t\t$firewall->syncStatus(true);\n\t\t\t\t\t\n\t\t\t\t\tif ($value == wfFirewall::FIREWALL_MODE_DISABLED) {\n\t\t\t\t\t\t$currentUser = wp_get_current_user();\n\t\t\t\t\t\t$username = $currentUser->user_login;\n\n\t\t\t\t\t\t$alertCallback = array(new wfWafDeactivatedAlert($username, wfUtils::getIP()), 'send');\n\t\t\t\t\t\tdo_action('wordfence_security_event', 'wafDeactivated', array(\n\t\t\t\t\t\t\t'username' => $username,\n\t\t\t\t\t\t\t'ip' => wfUtils::getIP(),\n\t\t\t\t\t\t), $alertCallback);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ($before != $value) {\n\t\t\t\t\t\t\/**\n\t\t\t\t\t\t * Fires when the WAF mode changes.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * @param string $before The previous mode.\n\t\t\t\t\t\t * @param string $after The new mode.\n\t\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t\t *\n\t\t\t\t\t\t *\/\n\t\t\t\t\t\tdo_action('wordfence_waf_mode', $before, $value);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$saved = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'wafRules':\n\t\t\t\t{\n\t\t\t\t\t$changes = array('enabled' => array(), 'disabled' => array());\n\t\t\t\t\t$disabledRules = (array) $wafConfig->getConfig('disabledRules');\n\t\t\t\t\tforeach ($value as $ruleID => $ruleEnabled) {\n\t\t\t\t\t\t$ruleID = (int) $ruleID;\n\t\t\t\t\t\tif ($ruleEnabled) {\n\t\t\t\t\t\t\tif (isset($disabledRules[$ruleID])) {\n\t\t\t\t\t\t\t\t$changes['enabled'][] = $ruleID;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tunset($disabledRules[$ruleID]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (!isset($disabledRules[$ruleID])) {\n\t\t\t\t\t\t\t\t$changes['disabled'][] = $ruleID;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$disabledRules[$ruleID] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t$wafConfig->setConfig('disabledRules', $disabledRules);\n\t\t\t\t\t\n\t\t\t\t\tif (!empty($changes['enabled']) || !empty($changes['disabled'])) {\n\t\t\t\t\t\t\/**\n\t\t\t\t\t\t * Fires when the rules are enabled or disabled for the WAF.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * @param array $changes {\n\t\t\t\t\t\t *        An array containing the rule status changes.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * @type int[] $enabled The rules that were enabled.\n\t\t\t\t\t\t * @type int[] $disabled The rules that were disabled.\n\t\t\t\t\t\t * }\n\t\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t\t *\n\t\t\t\t\t\t *\/\n\t\t\t\t\t\tdo_action('wordfence_waf_changed_rule_status', $changes);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$saved = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'whitelistedURLParams':\n\t\t\t\t{\n\t\t\t\t\t$deleting = array();\n\t\t\t\t\t$toggling = array();\n\t\t\t\t\t$adding = array();\n\t\t\t\t\t\n\t\t\t\t\t$whitelistedURLParams = (array) $wafConfig->getConfig('whitelistedURLParams', null, 'livewaf');\n\t\t\t\t\tif (isset($value['delete'])) {\n\t\t\t\t\t\tforeach ($value['delete'] as $whitelistKey => $d) {\n\t\t\t\t\t\t\tif (array_key_exists($whitelistKey, $whitelistedURLParams) && is_array($whitelistedURLParams[$whitelistKey])) {\n\t\t\t\t\t\t\t\t\/\/Start with the metadata for the rule (e.g., time created, description, etc)\n\t\t\t\t\t\t\t\t$value = isset($whitelistedURLParams[$whitelistKey]['all']) ? $whitelistedURLParams[$whitelistKey]['all'] : wfUtils::array_first($whitelistedURLParams[$whitelistKey]); \/\/It is possible that an entry may apply to multiple rules, but the values are similar enough we can grab only one\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\/\/Add the parameters\n\t\t\t\t\t\t\t\t$value['rule'] = (count($whitelistedURLParams[$whitelistKey]) > 1) ? array_keys($whitelistedURLParams[$whitelistKey]) : wfUtils::array_key_first($whitelistedURLParams[$whitelistKey]);\n\t\t\t\t\t\t\t\t$components = explode('|', $whitelistKey);\n\t\t\t\t\t\t\t\tif (count($components) >= 2) {\n\t\t\t\t\t\t\t\t\t$value['path'] = base64_decode($components[0]);\n\t\t\t\t\t\t\t\t\t$value['paramKey'] = base64_decode($components[1]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t$deleting[] = $value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tunset($whitelistedURLParams[$whitelistKey]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (isset($value['enabled'])) {\n\t\t\t\t\t\tforeach ($value['enabled'] as $whitelistKey => $enabled) {\n\t\t\t\t\t\t\tif (array_key_exists($whitelistKey, $whitelistedURLParams) && is_array($whitelistedURLParams[$whitelistKey])) {\n\t\t\t\t\t\t\t\tforeach ($whitelistedURLParams[$whitelistKey] as $ruleID => $data) {\n\t\t\t\t\t\t\t\t\t$whitelistedURLParams[$whitelistKey][$ruleID]['disabled'] = !$enabled;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t$value = isset($whitelistedURLParams[$whitelistKey]['all']) ? $whitelistedURLParams[$whitelistKey]['all'] : wfUtils::array_first($whitelistedURLParams[$whitelistKey]);\n\t\t\t\t\t\t\t\t$value['rule'] = (count($whitelistedURLParams[$whitelistKey]) > 1) ? array_keys($whitelistedURLParams[$whitelistKey]) : wfUtils::array_key_first($whitelistedURLParams[$whitelistKey]);\n\t\t\t\t\t\t\t\t$components = explode('|', $whitelistKey);\n\t\t\t\t\t\t\t\tif (count($components) >= 2) {\n\t\t\t\t\t\t\t\t\t$value['path'] = base64_decode($components[0]);\n\t\t\t\t\t\t\t\t\t$value['paramKey'] = base64_decode($components[1]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t$toggling[] = $value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t$wafConfig->setConfig('whitelistedURLParams', $whitelistedURLParams, 'livewaf');\n\t\t\t\t\t\n\t\t\t\t\tif (isset($value['add'])) {\n\t\t\t\t\t\tforeach ($value['add'] as $entry) {\n\t\t\t\t\t\t\t$path = @base64_decode($entry['path']);\n\t\t\t\t\t\t\t$paramKey = @base64_decode($entry['paramKey']);\n\t\t\t\t\t\t\tif (!$path || !$paramKey) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$data = array(\n\t\t\t\t\t\t\t\t'timestamp'   => (int) $entry['data']['timestamp'],\n\t\t\t\t\t\t\t\t'description' => $entry['data']['description'],\n\t\t\t\t\t\t\t\t'ip'          => wfUtils::getIP(),\n\t\t\t\t\t\t\t\t'disabled'    => !!$entry['data']['disabled'],\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (function_exists('get_current_user_id')) {\n\t\t\t\t\t\t\t\t$data['userID'] = get_current_user_id();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$waf->whitelistRuleForParam($path, $paramKey, 'all', $data);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t$adding[] = array_merge(array('rule' => 'all', 'path' => $path, 'paramKey' => $paramKey), $data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (!empty($toggling)) {\n\t\t\t\t\t\t\/**\n\t\t\t\t\t\t * Fires when WAF allow entries are manually enabled\/disabled.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * @param array $toggling {\n\t\t\t\t\t\t * \t\tAn array containing the entries that were enabled\/disabled.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * \t\t@type string|array $rule The rule(s) that the entry applies to. May be `all` or rule number(s)\n\t\t\t\t\t\t * \t\t@type int $timestamp The timestamp when the entry was created.\n\t\t\t\t\t\t * \t\t@type string $description The description of the entry.\n\t\t\t\t\t\t * \t\t@type string $ip The IP address that caused the entry to be created.\n\t\t\t\t\t\t * \t\t@type bool $disabled Whether or not the entry is disabled.\n\t\t\t\t\t\t * \t\t@type int $userID (optional) The user ID that created the entry if applicable.\n\t\t\t\t\t\t *\t\t@type string $path The URL path the entry applies to.\n\t\t\t\t\t\t * \t\t@type string $paramKey The parameter key the entry applies to. \n\t\t\t\t\t\t * }\n\t\t\t\t\t\t *\/\n\t\t\t\t\t\tdo_action('wordfence_waf_toggled_allow_entry', $toggling);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (!empty($deleting)) {\n\t\t\t\t\t\t\/**\n\t\t\t\t\t\t * Fires when WAF allow entries are manually deleted.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t\t * \n\t\t\t\t\t\t * @see wfConfig.php::wordfence_waf_toggled_allow_entry for the payload structure\n\t\t\t\t\t\t *\/\n\t\t\t\t\t\tdo_action('wordfence_waf_deleted_allow_entry', $deleting);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (!empty($adding)) {\n\t\t\t\t\t\t\/**\n\t\t\t\t\t\t * Fires when WAF allow entries are manually added.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * @see wfConfig.php::wordfence_waf_toggled_allow_entry for the payload structure\n\t\t\t\t\t\t *\/\n\t\t\t\t\t\tdo_action('wordfence_waf_created_allow_entry', $adding);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$saved = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'disableWAFBlacklistBlocking':\n\t\t\t\t{\n\t\t\t\t\t$before = $wafConfig->getConfig($key);\n\t\t\t\t\t$wafConfig->setConfig($key, wfUtils::truthyToInt($value));\n\t\t\t\t\tif (method_exists(wfWAF::getInstance()->getStorageEngine(), 'purgeIPBlocks')) {\n\t\t\t\t\t\twfWAF::getInstance()->getStorageEngine()->purgeIPBlocks(wfWAFStorageInterface::IP_BLOCKS_BLACKLIST);\n\t\t\t\t\t}\n\t\t\t\t\tif ($value) {\n\t\t\t\t\t\t$cron = wfWAF::getInstance()->getStorageEngine()->getConfig('cron', array(), 'livewaf');\n\t\t\t\t\t\tif (!is_array($cron)) {\n\t\t\t\t\t\t\t$cron = array();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tforeach ($cron as $cronKey => $cronJob) {\n\t\t\t\t\t\t\tif ($cronJob instanceof wfWAFCronFetchBlacklistPrefixesEvent) {\n\t\t\t\t\t\t\t\tunset($cron[$cronKey]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$cron[] = new wfWAFCronFetchBlacklistPrefixesEvent(time() - 1);\n\t\t\t\t\t\twfWAF::getInstance()->getStorageEngine()->setConfig('cron', $cron, 'livewaf');\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (wfUtils::truthyToBoolean($before) != wfUtils::truthyToBoolean($value)) {\n\t\t\t\t\t\t\/**\n\t\t\t\t\t\t * Fires when the WAF mode changes.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * @param string $before The previous mode.\n\t\t\t\t\t\t * @param string $after The new mode. True means enabled, false means disabled.\n\t\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t\t *\n\t\t\t\t\t\t *\/\n\t\t\t\t\t\tdo_action('wordfence_waf_toggled_blocklist', !wfUtils::truthyToBoolean($before), !wfUtils::truthyToBoolean($value));\n\t\t\t\t\t}\n\n\t\t\t\t\t$saved = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'avoid_php_input':\n\t\t\t\t{\n\t\t\t\t\t$wafConfig->setConfig($key, wfUtils::truthyToInt($value));\n\t\t\t\t\t$saved = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\/\/============ Plugin (specialty treatment)\n\t\t\t\tcase 'alertEmails':\n\t\t\t\t{\n\t\t\t\t\t$emails = !is_string($value) ? '' : $value;\n\t\t\t\t\t$emails = explode(',', preg_replace('\/[\\r\\n\\s\\t]+\/', '', $emails));\n\t\t\t\t\t$emails = array_filter($emails); \/\/Already validated above\n\t\t\t\t\tif (count($emails) > 0) {\n\t\t\t\t\t\twfConfig::set($key, implode(',', $emails));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twfConfig::set($key, '');\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$saved = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'loginSec_userBlacklist':\n\t\t\t\tcase 'scan_exclude':\n\t\t\t\tcase 'email_summary_excluded_directories':\n\t\t\t\t{\n\t\t\t\t\tif (is_array($value)) {\n\t\t\t\t\t\t$value = implode(\"\\n\", $value);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\twfConfig::set($key, wfUtils::cleanupOneEntryPerLine($value));\n\t\t\t\t\t$saved = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'whitelisted':\n\t\t\t\t{\n\t\t\t\t\t$whiteIPs = !is_string($value) ? '' : $value;\n\t\t\t\t\t$whiteIPs = explode(',', preg_replace('\/[\\r\\n\\s\\t]+\/', ',', $whiteIPs));\n\t\t\t\t\t$whiteIPs = array_filter($whiteIPs); \/\/Already validated above\n\t\t\t\t\tif (count($whiteIPs) > 0) {\n\t\t\t\t\t\twfConfig::set($key, implode(',', $whiteIPs));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twfConfig::set($key, '');\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (method_exists(wfWAF::getInstance()->getStorageEngine(), 'purgeIPBlocks')) {\n\t\t\t\t\t\twfWAF::getInstance()->getStorageEngine()->purgeIPBlocks(wfWAFStorageInterface::IP_BLOCKS_BLACKLIST);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$saved = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'whitelistedServices':\n\t\t\t\t{\n\t\t\t\t\tif (is_string($value)) { \/\/Already JSON (import\/export settings)\n\t\t\t\t\t\twfConfig::set($key, $value);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twfConfig::setJSON($key, (array) $value);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$wafConfig->setConfig('whitelistedServiceIPs', @json_encode(wfUtils::whitelistedServiceIPs()), 'synced');\n\t\t\t\t\t\n\t\t\t\t\tif (method_exists(wfWAF::getInstance()->getStorageEngine(), 'purgeIPBlocks')) {\n\t\t\t\t\t\twfWAF::getInstance()->getStorageEngine()->purgeIPBlocks(wfWAFStorageInterface::IP_BLOCKS_BLACKLIST);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$saved = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'liveTraf_ignoreUsers':\n\t\t\t\t{\n\t\t\t\t\t$dirtyUsers = !is_string($value) ? '' : $value;\n\t\t\t\t\t$dirtyUsers = explode(',', $dirtyUsers);\n\t\t\t\t\t$validUsers = array();\n\t\t\t\t\tforeach ($dirtyUsers as $val) {\n\t\t\t\t\t\t$val = trim($val);\n\t\t\t\t\t\tif (strlen($val) > 0) {\n\t\t\t\t\t\t\t$validUsers[] = $val; \/\/Already validated above\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (count($validUsers) > 0) {\n\t\t\t\t\t\twfConfig::set($key, implode(',', $validUsers));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twfConfig::set($key, '');\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$saved = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'liveTraf_ignoreIPs':\n\t\t\t\t{\n\t\t\t\t\t$validIPs = !is_string($value) ? '' : $value;\n\t\t\t\t\t$validIPs = explode(',', preg_replace('\/[\\r\\n\\s\\t]+\/', '', $validIPs));\n\t\t\t\t\t$validIPs = array_filter($validIPs); \/\/Already validated above\n\t\t\t\t\tif (count($validIPs) > 0) {\n\t\t\t\t\t\twfConfig::set($key, implode(',', $validIPs));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twfConfig::set($key, '');\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$saved = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'liveTraf_ignoreUA':\n\t\t\t\t{\n\t\t\t\t\t$value = !is_string($value) ? '' : $value;\n\t\t\t\t\tif (preg_match('\/[a-zA-Z0-9\\d]+\/', $value)) {\n\t\t\t\t\t\twfConfig::set($key, trim($value));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twfConfig::set($key, '');\n\t\t\t\t\t}\n\t\t\t\t\t$saved = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'howGetIPs_trusted_proxies':\n\t\t\t\t{\n\t\t\t\t\t$validIPs = !is_string($value) ? '' : $value;\n\t\t\t\t\t$validIPs = preg_split('\/[\\r\\n,]+\/', $validIPs);\n\t\t\t\t\t$validIPs = array_filter($validIPs); \/\/Already validated above\n\t\t\t\t\tif (count($validIPs) > 0) {\n\t\t\t\t\t\twfConfig::set($key, implode(\"\\n\", $validIPs));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twfConfig::set($key, '');\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$saved = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'other_WFNet':\n\t\t\t\t{\n\t\t\t\t\t$value = wfUtils::truthyToBoolean($value);\n\t\t\t\t\twfConfig::set($key, $value);\n\t\t\t\t\tif (!$value) {\n\t\t\t\t\t\twfBlock::removeTemporaryWFSNBlocks();\n\t\t\t\t\t}\n\t\t\t\t\t$saved = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'howGetIPs':\n\t\t\t\t{\n\t\t\t\t\twfConfig::set($key, $value);\n\t\t\t\t\twfConfig::set('detectProxyNextCheck', false, wfConfig::DONT_AUTOLOAD);\n\t\t\t\t\t$saved = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'bannedURLs':\n\t\t\t\t{\n\t\t\t\t\t$bannedURLs = !is_string($value) ? '' : $value;\n\t\t\t\t\twfConfig::set($key, preg_replace('\/[\\n\\r]+\/', ',', $bannedURLs));\n\t\t\t\t\t$saved = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'autoUpdate':\n\t\t\t\t{\n\t\t\t\t\tif (wfUtils::truthyToBoolean($value)) {\n\t\t\t\t\t\twfConfig::enableAutoUpdate(); \/\/Also sets the option\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twfConfig::disableAutoUpdate();\n\t\t\t\t\t}\n\t\t\t\t\t$saved = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'disableCodeExecutionUploads':\n\t\t\t\t{\n\t\t\t\t\t$value = wfUtils::truthyToBoolean($value);\n\t\t\t\t\twfConfig::set($key, $value);\n\t\t\t\t\tif ($value) {\n\t\t\t\t\t\twfConfig::disableCodeExecutionForUploads(); \/\/Can throw wfConfigException\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twfConfig::removeCodeExecutionProtectionForUploads();\n\t\t\t\t\t}\n\t\t\t\t\t$saved = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'email_summary_interval':\n\t\t\t\t{\n\t\t\t\t\twfConfig::set($key, $value);\n\t\t\t\t\twfActivityReport::scheduleCronJob();\n\t\t\t\t\t$saved = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'email_summary_enabled':\n\t\t\t\t{\n\t\t\t\t\t$value = wfUtils::truthyToBoolean($value);\n\t\t\t\t\twfConfig::set($key, $value);\n\t\t\t\t\tif ($value) {\n\t\t\t\t\t\twfActivityReport::scheduleCronJob();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twfActivityReport::disableCronJob();\n\t\t\t\t\t}\n\t\t\t\t\t$saved = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'other_hideWPVersion':\n\t\t\t\t{\n\t\t\t\t\t$value = wfUtils::truthyToBoolean($value);\n\t\t\t\t\twfConfig::set($key, $value);\n\t\t\t\t\tif ($value) {\n\t\t\t\t\t\twfUtils::hideReadme();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twfUtils::showReadme();\n\t\t\t\t\t}\n\t\t\t\t\t$saved = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'liveTraf_maxAge':\n\t\t\t\t{\n\t\t\t\t\t$value = max(1, $value);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\/\/Scan scheduling\n\t\t\t\tcase 'scanSched':\n\t\t\t\tcase 'schedStartHour':\n\t\t\t\tcase 'manualScanType':\n\t\t\t\tcase 'schedMode':\n\t\t\t\tcase 'scheduledScansEnabled':\n\t\t\t\t{\n\t\t\t\t\twfScanner::setNeedsRescheduling();\n\t\t\t\t\t\/\/Letting these fall through to the default save handler\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\/\/============ Plugin (default treatment)\n\t\t\tif (!$saved) {\n\t\t\t\tif (isset(self::$defaultConfig['checkboxes'][$key]) ||\n\t\t\t\t\t(isset(self::$defaultConfig['otherParams'][$key]) && self::$defaultConfig['otherParams'][$key]['validation']['type'] == self::TYPE_BOOL) ||\n\t\t\t\t\t(isset(self::$defaultConfig['defaultsOnly'][$key]) && self::$defaultConfig['defaultsOnly'][$key]['validation']['type'] == self::TYPE_BOOL)) { \/\/Boolean\n\t\t\t\t\twfConfig::set($key, wfUtils::truthyToInt($value));\n\t\t\t\t}\n\t\t\t\telse if ((isset(self::$defaultConfig['otherParams'][$key]) && self::$defaultConfig['otherParams'][$key]['validation']['type'] == self::TYPE_INT) ||\n\t\t\t\t\t\t (isset(self::$defaultConfig['defaultsOnly'][$key]) && self::$defaultConfig['defaultsOnly'][$key]['validation']['type'] == self::TYPE_INT)) {\n\t\t\t\t\twfConfig::set($key, (int) $value);\n\t\t\t\t}\n\t\t\t\telse if ((isset(self::$defaultConfig['otherParams'][$key]) && (self::$defaultConfig['otherParams'][$key]['validation']['type'] == self::TYPE_FLOAT || self::$defaultConfig['otherParams'][$key]['validation']['type'] == self::TYPE_DOUBLE)) ||\n\t\t\t\t\t\t (isset(self::$defaultConfig['defaultsOnly'][$key]) && (self::$defaultConfig['defaultsOnly'][$key]['validation']['type'] == self::TYPE_FLOAT || self::$defaultConfig['defaultsOnly'][$key]['validation']['type'] == self::TYPE_DOUBLE))) {\n\t\t\t\t\twfConfig::set($key, (double) $value);\n\t\t\t\t}\n\t\t\t\telse if ((isset(self::$defaultConfig['otherParams'][$key]) && self::$defaultConfig['otherParams'][$key]['validation']['type'] == self::TYPE_STRING) ||\n\t\t\t\t\t\t (isset(self::$defaultConfig['defaultsOnly'][$key]) && self::$defaultConfig['defaultsOnly'][$key]['validation']['type'] == self::TYPE_STRING)) {\n\t\t\t\t\twfConfig::set($key, (string) $value);\n\t\t\t\t}\n\t\t\t\telse if (in_array($key, self::$serializedOptions)) {\n\t\t\t\t\twfConfig::set_ser($key, $value);\n\t\t\t\t}\n\t\t\t\telse if (in_array($key, self::$wfCentralInternalConfig)) {\n\t\t\t\t\twfConfig::set($key, $value);\n\t\t\t\t}\n\t\t\t\telse if (WFWAF_DEBUG) {\n\t\t\t\t\terror_log(\"*** DEBUG: Config option '{$key}' missing save handler.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tif ($apiKey !== false) {\n\t\t\t$existingAPIKey = wfConfig::get('apiKey', '');\n\t\t\t$apiKey = strtolower(trim($apiKey)); \/\/Already validated above\n\t\t\t$ping = false;\n\t\t\tif (empty($apiKey)) { \/\/Empty, try getting a free key\n\t\t\t\t$api = new wfAPI('', wfUtils::getWPVersion());\n\t\t\t\ttry {\n\t\t\t\t\t$keyData = $api->call('get_anon_api_key');\n\t\t\t\t\tif ($keyData['ok'] && $keyData['apiKey']) {\n\t\t\t\t\t\twfConfig::set('apiKey', $keyData['apiKey']);\n\t\t\t\t\t\twfConfig::set('isPaid', false);\n\t\t\t\t\t\twfConfig::set('keyType', wfLicense::KEY_TYPE_FREE);\n\t\t\t\t\t\twordfence::licenseStatusChanged();\n\t\t\t\t\t\twfConfig::set('touppPromptNeeded', true);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow new Exception(__(\"The Wordfence server's response did not contain the expected elements.\", 'wordfence'));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception $e) {\n\t\t\t\t\tthrow new wfConfigException(__('Your options have been saved, but you left your license key blank, so we tried to get you a free license key from the Wordfence servers. There was a problem fetching the free key: ', 'wordfence') . wp_kses($e->getMessage(), array()));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ($existingAPIKey != $apiKey) { \/\/Key changed, try activating\n\t\t\t\t$api = new wfAPI($apiKey, wfUtils::getWPVersion());\n\t\t\t\ttry {\n\t\t\t\t\t$res = $api->call('check_api_key', array(), array('previousLicense' => $existingAPIKey));\n\t\t\t\t\tif ($res['ok'] && isset($res['isPaid'])) {\n\t\t\t\t\t\t$isPaid = wfUtils::truthyToBoolean($res['isPaid']);\n\t\t\t\t\t\twfConfig::set('apiKey', $apiKey);\n\t\t\t\t\t\twfConfig::set('isPaid', $isPaid); \/\/res['isPaid'] is boolean coming back as JSON and turned back into PHP struct. Assuming JSON to PHP handles bools.\n\t\t\t\t\t\twordfence::licenseStatusChanged();\n\t\t\t\t\t\tif (!$isPaid) {\n\t\t\t\t\t\t\twfConfig::set('keyType', wfLicense::KEY_TYPE_FREE);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$ping = true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow new Exception(__(\"The Wordfence server's response did not contain the expected elements.\", 'wordfence'));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception $e) {\n\t\t\t\t\tthrow new wfConfigException(__('Your options have been saved. However we noticed you changed your license key, and we tried to verify it with the Wordfence servers but received an error: ', 'wordfence') . wp_kses($e->getMessage(), array()));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse { \/\/Key unchanged, just ping it\n\t\t\t\t$ping = true;\n\t\t\t}\n\t\t\t\n\t\t\tif ($ping) {\n\t\t\t\t$api = new wfAPI($apiKey, wfUtils::getWPVersion());\n\t\t\t\ttry {\n\t\t\t\t\t$keyType = wfLicense::KEY_TYPE_FREE;\n\t\t\t\t\t$keyData = $api->call('ping_api_key', array(), array('supportHash' => wfConfig::get('supportHash', ''), 'whitelistHash' => wfConfig::get('whitelistHash', ''), 'tldlistHash' => wfConfig::get('tldlistHash', ''), 'ipResolutionListHash' => wfConfig::get('ipResolutionListHash', '')));\n\t\t\t\t\tif (isset($keyData['_isPaidKey'])) {\n\t\t\t\t\t\t$keyType = wfConfig::get('keyType');\n\t\t\t\t\t}\n\t\t\t\t\tif (isset($keyData['dashboard'])) {\n\t\t\t\t\t\twfConfig::set('lastDashboardCheck', time());\n\t\t\t\t\t\twfDashboard::processDashboardResponse($keyData['dashboard']);\n\t\t\t\t\t}\n\t\t\t\t\tif (isset($keyData['support']) && isset($keyData['supportHash'])) {\n\t\t\t\t\t\twfConfig::set('supportContent', $keyData['support'], wfConfig::DONT_AUTOLOAD);\n\t\t\t\t\t\twfConfig::set('supportHash', $keyData['supportHash']);\n\t\t\t\t\t}\n\t\t\t\t\tif (isset($keyData['_whitelist']) && isset($keyData['_whitelistHash'])) {\n\t\t\t\t\t\twfConfig::setJSON('whitelistPresets', $keyData['_whitelist']);\n\t\t\t\t\t\twfConfig::set('whitelistHash', $keyData['_whitelistHash']);\n\t\t\t\t\t}\n\t\t\t\t\tif (isset($keyData['_tldlist']) && isset($keyData['_tldlistHash'])) {\n\t\t\t\t\t\twfConfig::set('tldlist', $keyData['_tldlist'], wfConfig::DONT_AUTOLOAD);\n\t\t\t\t\t\twfConfig::set('tldlistHash', $keyData['_tldlistHash']);\n\t\t\t\t\t}\n\t\t\t\t\tif (isset($keyData['_ipResolutionList']) && isset($keyData['_ipResolutionListHash'])) {\n\t\t\t\t\t\twfConfig::setJSON('ipResolutionList', $keyData['_ipResolutionList']);\n\t\t\t\t\t\twfConfig::set('ipResolutionListHash', $keyData['_ipResolutionListHash']);\n\t\t\t\t\t}\n\t\t\t\t\tif (isset($keyData['scanSchedule']) && is_array($keyData['scanSchedule'])) {\n\t\t\t\t\t\twfConfig::set_ser('noc1ScanSchedule', $keyData['scanSchedule']);\n\t\t\t\t\t\tif (wfScanner::shared()->schedulingMode() == wfScanner::SCAN_SCHEDULING_MODE_AUTOMATIC) {\n\t\t\t\t\t\t\twfScanner::shared()->scheduleScans();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (isset($keyData['showWfCentralUI'])) {\n\t\t\t\t\t\twfConfig::set('showWfCentralUI', (int) $keyData['showWfCentralUI']);\n\t\t\t\t\t}\n\n\t\t\t\t\twfConfig::set('keyType', $keyType);\n\t\t\t\t}\n\t\t\t\tcatch (Exception $e){\n\t\t\t\t\tthrow new wfConfigException(__('Your options have been saved. However we tried to verify your license key with the Wordfence servers and received an error: ', 'wordfence') . wp_kses($e->getMessage(), array()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\twfNotification::reconcileNotificationsWithOptions();\n\t\twfCentral::requestConfigurationSync();\n\t}\n\t\n\tpublic static function restoreDefaults($section) {\n\t\tswitch ($section) {\n\t\t\tcase self::OPTIONS_TYPE_GLOBAL:\n\t\t\t\t$options = array(\n\t\t\t\t\t'alertOn_critical',\n\t\t\t\t\t'alertOn_update',\n\t\t\t\t\t'alertOn_warnings',\n\t\t\t\t\t'alertOn_throttle',\n\t\t\t\t\t'alertOn_block',\n\t\t\t\t\t'alertOn_loginLockout',\n\t\t\t\t\t'alertOn_breachLogin',\n\t\t\t\t\t'alertOn_lostPasswdForm',\n\t\t\t\t\t'alertOn_adminLogin',\n\t\t\t\t\t'alertOn_firstAdminLoginOnly',\n\t\t\t\t\t'alertOn_nonAdminLogin',\n\t\t\t\t\t'alertOn_firstNonAdminLoginOnly',\n\t\t\t\t\t'alertOn_wordfenceDeactivated',\n\t\t\t\t\t'liveActivityPauseEnabled',\n\t\t\t\t\t'notification_updatesNeeded',\n\t\t\t\t\t'notification_securityAlerts',\n\t\t\t\t\t'notification_promotions',\n\t\t\t\t\t'notification_blogHighlights',\n\t\t\t\t\t'notification_productUpdates',\n\t\t\t\t\t'notification_scanStatus',\n\t\t\t\t\t'enableRemoteIpLookup',\n\t\t\t\t\t'other_hideWPVersion',\n\t\t\t\t\t'other_bypassLitespeedNoabort',\n\t\t\t\t\t'deleteTablesOnDeact',\n\t\t\t\t\t'autoUpdate',\n\t\t\t\t\t'disableCodeExecutionUploads',\n\t\t\t\t\t'email_summary_enabled',\n\t\t\t\t\t'email_summary_dashboard_widget_enabled',\n\t\t\t\t\t'howGetIPs',\n\t\t\t\t\t'actUpdateInterval',\n\t\t\t\t\t'alert_maxHourly',\n\t\t\t\t\t'email_summary_interval',\n\t\t\t\t\t'email_summary_excluded_directories',\n\t\t\t\t\t'howGetIPs_trusted_proxies',\n\t\t\t\t\t'howGetIPs_trusted_proxy_preset',\n\t\t\t\t\t'displayTopLevelOptions',\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase self::OPTIONS_TYPE_FIREWALL:\n\t\t\t\t$options = array(\n\t\t\t\t\t'firewallEnabled',\n\t\t\t\t\t'autoBlockScanners',\n\t\t\t\t\t'loginSecurityEnabled',\n\t\t\t\t\t'loginSec_strongPasswds_enabled',\n\t\t\t\t\t'loginSec_breachPasswds_enabled',\n\t\t\t\t\t'loginSec_lockInvalidUsers',\n\t\t\t\t\t'loginSec_maskLoginErrors',\n\t\t\t\t\t'loginSec_blockAdminReg',\n\t\t\t\t\t'loginSec_disableAuthorScan',\n\t\t\t\t\t'loginSec_disableOEmbedAuthor',\n\t\t\t\t\t'other_blockBadPOST',\n\t\t\t\t\t'other_pwStrengthOnUpdate',\n\t\t\t\t\t'other_WFNet',\n\t\t\t\t\t'ajaxWatcherDisabled_front',\n\t\t\t\t\t'ajaxWatcherDisabled_admin',\n\t\t\t\t\t'wafAlertOnAttacks',\n\t\t\t\t\t'disableWAFIPBlocking',\n\t\t\t\t\t'whitelisted',\n\t\t\t\t\t'whitelistedServices',\n\t\t\t\t\t'bannedURLs',\n\t\t\t\t\t'loginSec_userBlacklist',\n\t\t\t\t\t'neverBlockBG',\n\t\t\t\t\t'loginSec_countFailMins',\n\t\t\t\t\t'loginSec_lockoutMins',\n\t\t\t\t\t'loginSec_strongPasswds',\n\t\t\t\t\t'loginSec_breachPasswds',\n\t\t\t\t\t'loginSec_maxFailures',\n\t\t\t\t\t'loginSec_maxForgotPasswd',\n\t\t\t\t\t'maxGlobalRequests',\n\t\t\t\t\t'maxGlobalRequests_action',\n\t\t\t\t\t'maxRequestsCrawlers',\n\t\t\t\t\t'maxRequestsCrawlers_action',\n\t\t\t\t\t'maxRequestsHumans',\n\t\t\t\t\t'maxRequestsHumans_action',\n\t\t\t\t\t'max404Crawlers',\n\t\t\t\t\t'max404Crawlers_action',\n\t\t\t\t\t'max404Humans',\n\t\t\t\t\t'max404Humans_action',\n\t\t\t\t\t'blockedTime',\n\t\t\t\t\t'allowed404s',\n\t\t\t\t\t'wafAlertWhitelist',\n\t\t\t\t\t'wafAlertInterval',\n\t\t\t\t\t'wafAlertThreshold',\n\t\t\t\t\t'dismissAutoPrependNotice',\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase self::OPTIONS_TYPE_BLOCKING:\n\t\t\t\t$options = array(\n\t\t\t\t\t'displayTopLevelBlocking',\n\t\t\t\t\t'cbl_loggedInBlocked',\n\t\t\t\t\t'cbl_action',\n\t\t\t\t\t'cbl_redirURL',\n\t\t\t\t\t'cbl_bypassRedirURL',\n\t\t\t\t\t'cbl_bypassRedirDest',\n\t\t\t\t\t'cbl_bypassViewURL',\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase self::OPTIONS_TYPE_SCANNER:\n\t\t\t\t$options = array(\n\t\t\t\t\t'checkSpamIP',\n\t\t\t\t\t'spamvertizeCheck',\n\t\t\t\t\t'scheduledScansEnabled',\n\t\t\t\t\t'lowResourceScansEnabled',\n\t\t\t\t\t'scansEnabled_checkGSB',\n\t\t\t\t\t'scansEnabled_checkHowGetIPs',\n\t\t\t\t\t'scansEnabled_core',\n\t\t\t\t\t'scansEnabled_themes',\n\t\t\t\t\t'scansEnabled_plugins',\n\t\t\t\t\t'scansEnabled_coreUnknown',\n\t\t\t\t\t'scansEnabled_malware',\n\t\t\t\t\t'scansEnabled_fileContents',\n\t\t\t\t\t'scansEnabled_fileContentsGSB',\n\t\t\t\t\t'scansEnabled_checkReadableConfig',\n\t\t\t\t\t'scansEnabled_suspectedFiles',\n\t\t\t\t\t'scansEnabled_posts',\n\t\t\t\t\t'scansEnabled_comments',\n\t\t\t\t\t'scansEnabled_suspiciousOptions',\n\t\t\t\t\t'scansEnabled_passwds',\n\t\t\t\t\t'scansEnabled_diskSpace',\n\t\t\t\t\t'scansEnabled_wafStatus',\n\t\t\t\t\t'scansEnabled_options',\n\t\t\t\t\t'scansEnabled_wpscan_fullPathDisclosure',\n\t\t\t\t\t'scansEnabled_wpscan_directoryListingEnabled',\n\t\t\t\t\t'scansEnabled_scanImages',\n\t\t\t\t\t'scansEnabled_highSense',\n\t\t\t\t\t'scansEnabled_oldVersions',\n\t\t\t\t\t'scansEnabled_suspiciousAdminUsers',\n\t\t\t\t\t'scan_include_extra',\n\t\t\t\t\t'maxMem',\n\t\t\t\t\t'scan_exclude',\n\t\t\t\t\t'scan_maxIssues',\n\t\t\t\t\t'scan_maxDuration',\n\t\t\t\t\t'maxExecutionTime',\n\t\t\t\t\t'scanType',\n\t\t\t\t\t'manualScanType',\n\t\t\t\t\t'schedMode',\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase self::OPTIONS_TYPE_TWO_FACTOR:\n\t\t\t\t$options = array(\n\t\t\t\t\t'loginSec_requireAdminTwoFactor',\n\t\t\t\t\t'loginSec_enableSeparateTwoFactor',\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase self::OPTIONS_TYPE_LIVE_TRAFFIC:\n\t\t\t\t$options = array(\n\t\t\t\t\t'liveTrafficEnabled',\n\t\t\t\t\t'liveTraf_ignorePublishers',\n\t\t\t\t\t'liveTraf_displayExpandedRecords',\n\t\t\t\t\t'liveTraf_ignoreUsers',\n\t\t\t\t\t'liveTraf_ignoreIPs',\n\t\t\t\t\t'liveTraf_ignoreUA',\n\t\t\t\t\t'liveTraf_maxRows',\n\t\t\t\t\t'liveTraf_maxAge',\n\t\t\t\t\t'displayTopLevelLiveTraffic',\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase self::OPTIONS_TYPE_AUDIT_LOG:\n\t\t\t\t$options = array(\n\t\t\t\t\t'auditLogMode',\n\t\t\t\t\t'displayTopLevelAuditLog',\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase self::OPTIONS_TYPE_DIAGNOSTICS:\n\t\t\t\t$options = array(\n\t\t\t\t\t'debugOn',\n\t\t\t\t\t'startScansRemotely',\n\t\t\t\t\t'ssl_verify',\n\t\t\t\t\t'wordfenceI18n',\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase self::OPTIONS_TYPE_ALL:\n\t\t\t\t$options = array(\n\t\t\t\t\t'alertOn_critical',\n\t\t\t\t\t'alertOn_update',\n\t\t\t\t\t'alertOn_warnings',\n\t\t\t\t\t'alertOn_throttle',\n\t\t\t\t\t'alertOn_block',\n\t\t\t\t\t'alertOn_loginLockout',\n\t\t\t\t\t'alertOn_breachLogin',\n\t\t\t\t\t'alertOn_lostPasswdForm',\n\t\t\t\t\t'alertOn_adminLogin',\n\t\t\t\t\t'alertOn_firstAdminLoginOnly',\n\t\t\t\t\t'alertOn_nonAdminLogin',\n\t\t\t\t\t'alertOn_firstNonAdminLoginOnly',\n\t\t\t\t\t'alertOn_wordfenceDeactivated',\n\t\t\t\t\t'liveActivityPauseEnabled',\n\t\t\t\t\t'notification_updatesNeeded',\n\t\t\t\t\t'notification_securityAlerts',\n\t\t\t\t\t'notification_promotions',\n\t\t\t\t\t'notification_blogHighlights',\n\t\t\t\t\t'notification_productUpdates',\n\t\t\t\t\t'notification_scanStatus',\n\t\t\t\t\t'other_hideWPVersion',\n\t\t\t\t\t'other_bypassLitespeedNoabort',\n\t\t\t\t\t'deleteTablesOnDeact',\n\t\t\t\t\t'autoUpdate',\n\t\t\t\t\t'disableCodeExecutionUploads',\n\t\t\t\t\t'email_summary_enabled',\n\t\t\t\t\t'email_summary_dashboard_widget_enabled',\n\t\t\t\t\t'howGetIPs',\n\t\t\t\t\t'actUpdateInterval',\n\t\t\t\t\t'alert_maxHourly',\n\t\t\t\t\t'email_summary_interval',\n\t\t\t\t\t'email_summary_excluded_directories',\n\t\t\t\t\t'howGetIPs_trusted_proxies',\n\t\t\t\t\t'howGetIPs_trusted_proxy_preset',\n\t\t\t\t\t'firewallEnabled',\n\t\t\t\t\t'autoBlockScanners',\n\t\t\t\t\t'loginSecurityEnabled',\n\t\t\t\t\t'loginSec_strongPasswds_enabled',\n\t\t\t\t\t'loginSec_breachPasswds_enabled',\n\t\t\t\t\t'loginSec_lockInvalidUsers',\n\t\t\t\t\t'loginSec_maskLoginErrors',\n\t\t\t\t\t'loginSec_blockAdminReg',\n\t\t\t\t\t'loginSec_disableAuthorScan',\n\t\t\t\t\t'loginSec_disableOEmbedAuthor',\n\t\t\t\t\t'other_blockBadPOST',\n\t\t\t\t\t'other_pwStrengthOnUpdate',\n\t\t\t\t\t'other_WFNet',\n\t\t\t\t\t'ajaxWatcherDisabled_front',\n\t\t\t\t\t'ajaxWatcherDisabled_admin',\n\t\t\t\t\t'wafAlertOnAttacks',\n\t\t\t\t\t'disableWAFIPBlocking',\n\t\t\t\t\t'whitelisted',\n\t\t\t\t\t'whitelistedServices',\n\t\t\t\t\t'bannedURLs',\n\t\t\t\t\t'loginSec_userBlacklist',\n\t\t\t\t\t'neverBlockBG',\n\t\t\t\t\t'loginSec_countFailMins',\n\t\t\t\t\t'loginSec_lockoutMins',\n\t\t\t\t\t'loginSec_strongPasswds',\n\t\t\t\t\t'loginSec_breachPasswds',\n\t\t\t\t\t'loginSec_maxFailures',\n\t\t\t\t\t'loginSec_maxForgotPasswd',\n\t\t\t\t\t'maxGlobalRequests',\n\t\t\t\t\t'maxGlobalRequests_action',\n\t\t\t\t\t'maxRequestsCrawlers',\n\t\t\t\t\t'maxRequestsCrawlers_action',\n\t\t\t\t\t'maxRequestsHumans',\n\t\t\t\t\t'maxRequestsHumans_action',\n\t\t\t\t\t'max404Crawlers',\n\t\t\t\t\t'max404Crawlers_action',\n\t\t\t\t\t'max404Humans',\n\t\t\t\t\t'max404Humans_action',\n\t\t\t\t\t'blockedTime',\n\t\t\t\t\t'allowed404s',\n\t\t\t\t\t'wafAlertWhitelist',\n\t\t\t\t\t'wafAlertInterval',\n\t\t\t\t\t'wafAlertThreshold',\n\t\t\t\t\t'dismissAutoPrependNotice',\n\t\t\t\t\t'displayTopLevelBlocking',\n\t\t\t\t\t'cbl_loggedInBlocked',\n\t\t\t\t\t'cbl_action',\n\t\t\t\t\t'cbl_redirURL',\n\t\t\t\t\t'cbl_bypassRedirURL',\n\t\t\t\t\t'cbl_bypassRedirDest',\n\t\t\t\t\t'cbl_bypassViewURL',\n\t\t\t\t\t'checkSpamIP',\n\t\t\t\t\t'spamvertizeCheck',\n\t\t\t\t\t'scheduledScansEnabled',\n\t\t\t\t\t'lowResourceScansEnabled',\n\t\t\t\t\t'scansEnabled_checkGSB',\n\t\t\t\t\t'scansEnabled_checkHowGetIPs',\n\t\t\t\t\t'scansEnabled_core',\n\t\t\t\t\t'scansEnabled_themes',\n\t\t\t\t\t'scansEnabled_plugins',\n\t\t\t\t\t'scansEnabled_coreUnknown',\n\t\t\t\t\t'scansEnabled_malware',\n\t\t\t\t\t'scansEnabled_fileContents',\n\t\t\t\t\t'scansEnabled_fileContentsGSB',\n\t\t\t\t\t'scansEnabled_checkReadableConfig',\n\t\t\t\t\t'scansEnabled_suspectedFiles',\n\t\t\t\t\t'scansEnabled_posts',\n\t\t\t\t\t'scansEnabled_comments',\n\t\t\t\t\t'scansEnabled_suspiciousOptions',\n\t\t\t\t\t'scansEnabled_passwds',\n\t\t\t\t\t'scansEnabled_diskSpace',\n\t\t\t\t\t'scansEnabled_wafStatus',\n\t\t\t\t\t'scansEnabled_options',\n\t\t\t\t\t'scansEnabled_wpscan_fullPathDisclosure',\n\t\t\t\t\t'scansEnabled_wpscan_directoryListingEnabled',\n\t\t\t\t\t'scansEnabled_scanImages',\n\t\t\t\t\t'scansEnabled_highSense',\n\t\t\t\t\t'scansEnabled_oldVersions',\n\t\t\t\t\t'scansEnabled_suspiciousAdminUsers',\n\t\t\t\t\t'scan_include_extra',\n\t\t\t\t\t'maxMem',\n\t\t\t\t\t'scan_exclude',\n\t\t\t\t\t'scan_maxIssues',\n\t\t\t\t\t'scan_maxDuration',\n\t\t\t\t\t'maxExecutionTime',\n\t\t\t\t\t'scanType',\n\t\t\t\t\t'manualScanType',\n\t\t\t\t\t'schedMode',\n\t\t\t\t\t'loginSec_requireAdminTwoFactor',\n\t\t\t\t\t'loginSec_enableSeparateTwoFactor',\n\t\t\t\t\t'liveTrafficEnabled',\n\t\t\t\t\t'liveTraf_ignorePublishers',\n\t\t\t\t\t'liveTraf_displayExpandedRecords',\n\t\t\t\t\t'liveTraf_ignoreUsers',\n\t\t\t\t\t'liveTraf_ignoreIPs',\n\t\t\t\t\t'liveTraf_ignoreUA',\n\t\t\t\t\t'liveTraf_maxRows',\n\t\t\t\t\t'liveTraf_maxAge',\n\t\t\t\t\t'displayTopLevelLiveTraffic',\n\t\t\t\t\t'other_scanComments',\n\t\t\t\t\t'advancedCommentScanning',\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (isset($options)) {\n\t\t\t$changes = array();\n\t\t\tforeach ($options as $key) {\n\t\t\t\tif (isset(self::$defaultConfig['checkboxes'][$key])) {\n\t\t\t\t\t$changes[$key] = self::$defaultConfig['checkboxes'][$key]['value'];\n\t\t\t\t}\n\t\t\t\telse if (isset(self::$defaultConfig['otherParams'][$key])) {\n\t\t\t\t\t$changes[$key] = self::$defaultConfig['otherParams'][$key]['value'];\n\t\t\t\t}\n\t\t\t\telse if (isset(self::$defaultConfig['defaultsOnly'][$key])) {\n\t\t\t\t\t$changes[$key] = self::$defaultConfig['defaultsOnly'][$key]['value'];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\ttry {\n\t\t\t\tself::save($changes);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch (Exception $e) {\n\t\t\t\t\/\/Do nothing\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tprivate static function _handleActionHooks($key, $newValue) {\n\t\tswitch ($key) {\n\t\t\tcase 'whitelisted':\n\t\t\t{\n\t\t\t\t$before = explode(',', wfConfig::get($key));\n\t\t\t\t\n\t\t\t\t\/**\n\t\t\t\t * Fires when the allowed IP list changes.\n\t\t\t\t *\n\t\t\t\t * @since 8.0.0\n\t\t\t\t *\n\t\t\t\t * @param string[] $before The previous IP list.\n\t\t\t\t * @param string[] $after The new IP list.\n\t\t\t\t *\/\n\t\t\t\tdo_action('wordfence_updated_allowed_ips', $before, explode(',', $newValue));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'whitelistedServices':\n\t\t\t{\n\t\t\t\t$before = (array) wfConfig::getJSON($key, array());\n\t\t\t\t$after = json_decode($newValue, true);\n\t\t\t\t\n\t\t\t\t\/**\n\t\t\t\t * Fires when the allowed service list changes.\n\t\t\t\t *\n\t\t\t\t * @since 8.0.0\n\t\t\t\t *\n\t\t\t\t * @param string[] $before The previous service list.\n\t\t\t\t * @param string[] $after The new service list.\n\t\t\t\t *\/\n\t\t\t\tdo_action('wordfence_updated_allowed_services', $before, $after);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'whitelistPresets':\n\t\t\t{\n\t\t\t\t$before = (array) wfConfig::getJSON($key, array());\n\t\t\t\t$after = json_decode($newValue, true);\n\t\t\t\t\n\t\t\t\t\/**\n\t\t\t\t * Fires when the allowed service list definitions changes.\n\t\t\t\t *\n\t\t\t\t * @since 8.0.0\n\t\t\t\t *\n\t\t\t\t * @param array $before The previous service list definitions.\n\t\t\t\t * @param array $after The new service list definitions.\n\t\t\t\t *\/\n\t\t\t\tdo_action('wordfence_updated_allowed_services_definitions', $before, $after);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'bannedURLs':\n\t\t\t{\n\t\t\t\t$before = array_filter(explode(\"\\n\", wfUtils::cleanupOneEntryPerLine(wfConfig::get($key))));\n\t\t\t\t$after = array_filter(explode(\"\\n\", wfUtils::cleanupOneEntryPerLine($newValue)));\n\t\t\t\t\n\t\t\t\t\/**\n\t\t\t\t * Fires when the banned URLs list changes.\n\t\t\t\t *\n\t\t\t\t * @since 8.0.0\n\t\t\t\t *\n\t\t\t\t * @param string[] $before The previous list.\n\t\t\t\t * @param string[] $after The new list.\n\t\t\t\t *\/\n\t\t\t\tdo_action('wordfence_updated_banned_urls', $before, $after);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'wafAlertWhitelist':\n\t\t\t{\n\t\t\t\t$before = array_filter(explode(\"\\n\", wfUtils::cleanupOneEntryPerLine(wfConfig::get($key))));\n\t\t\t\t$after = array_filter(explode(\"\\n\", wfUtils::cleanupOneEntryPerLine($newValue)));\n\t\t\t\t\n\t\t\t\t\/**\n\t\t\t\t * Fires when the WAF alerting ignored IP list changes.\n\t\t\t\t *\n\t\t\t\t * @since 8.0.0\n\t\t\t\t *\n\t\t\t\t * @param string[] $before The previous list.\n\t\t\t\t * @param string[] $after The new list.\n\t\t\t\t *\/\n\t\t\t\tdo_action('wordfence_updated_ignored_alert_ips', $before, $after);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'loginSecurityEnabled':\n\t\t\t{\n\t\t\t\t$before = wfUtils::truthyToBoolean(wfConfig::get($key));\n\t\t\t\t$after = wfUtils::truthyToBoolean($newValue);\n\t\t\t\t\n\t\t\t\tif ($before != $after) {\n\t\t\t\t\t\/**\n\t\t\t\t\t * Fires when brute force protection is enabled\/disabled.\n\t\t\t\t\t *\n\t\t\t\t\t * @param bool $before The previous status.\n\t\t\t\t\t * @param bool $after The new status.\n\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t *\n\t\t\t\t\t *\/\n\t\t\t\t\tdo_action('wordfence_toggled_brute_force_protection', $before, $after);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'loginSec_maxFailures':\n\t\t\t{\n\t\t\t\t$before = intval(wfConfig::get($key));\n\t\t\t\t$after = intval($newValue);\n\t\t\t\t\n\t\t\t\tif ($before != $after) {\n\t\t\t\t\t\/**\n\t\t\t\t\t * Fires when the login failure count threshold changes.\n\t\t\t\t\t *\n\t\t\t\t\t * @param int $before The previous count.\n\t\t\t\t\t * @param int $after The new count.\n\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t *\n\t\t\t\t\t *\/\n\t\t\t\t\tdo_action('wordfence_updated_login_failure_count', $before, $after);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'loginSec_maxForgotPasswd':\n\t\t\t{\n\t\t\t\t$before = intval(wfConfig::get($key));\n\t\t\t\t$after = intval($newValue);\n\t\t\t\t\n\t\t\t\tif ($before != $after) {\n\t\t\t\t\t\/**\n\t\t\t\t\t * Fires when the forgot password count threshold changes.\n\t\t\t\t\t *\n\t\t\t\t\t * @param int $before The previous count.\n\t\t\t\t\t * @param int $after The new count.\n\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t *\n\t\t\t\t\t *\/\n\t\t\t\t\tdo_action('wordfence_updated_forgot_password_count', $before, $after);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'loginSec_countFailMins':\n\t\t\t{\n\t\t\t\t$before = intval(wfConfig::get($key));\n\t\t\t\t$after = intval($newValue);\n\t\t\t\t\n\t\t\t\tif ($before != $after) {\n\t\t\t\t\t\/**\n\t\t\t\t\t * Fires when the count failures over time period value changes.\n\t\t\t\t\t *\n\t\t\t\t\t * @param int $before The previous minutes.\n\t\t\t\t\t * @param int $after The new minutes.\n\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t *\n\t\t\t\t\t *\/\n\t\t\t\t\tdo_action('wordfence_updated_login_security_period', $before, $after);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'loginSec_lockoutMins':\n\t\t\t{\n\t\t\t\t$before = intval(wfConfig::get($key));\n\t\t\t\t$after = intval($newValue);\n\t\t\t\t\n\t\t\t\tif ($before != $after) {\n\t\t\t\t\t\/**\n\t\t\t\t\t * Fires when the duration for lockout changed.\n\t\t\t\t\t *\n\t\t\t\t\t * @param int $before The previous minutes.\n\t\t\t\t\t * @param int $after The new minutes.\n\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t *\n\t\t\t\t\t *\/\n\t\t\t\t\tdo_action('wordfence_updated_login_security_duration', $before, $after);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'loginSec_lockInvalidUsers':\n\t\t\t{\n\t\t\t\t$before = wfUtils::truthyToBoolean(wfConfig::get($key));\n\t\t\t\t$after = wfUtils::truthyToBoolean($newValue);\n\t\t\t\t\n\t\t\t\tif ($before != $after) {\n\t\t\t\t\t\/**\n\t\t\t\t\t * Fires when the immediately lock out invalid usernames setting is enabled\/disabled.\n\t\t\t\t\t *\n\t\t\t\t\t * @param bool $before The previous status.\n\t\t\t\t\t * @param bool $after The new status.\n\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t *\n\t\t\t\t\t *\/\n\t\t\t\t\tdo_action('wordfence_toggled_lock_out_invalid', $before, $after);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'loginSec_userBlacklist':\n\t\t\t{\n\t\t\t\t$before = array_filter(explode(\"\\n\", wfUtils::cleanupOneEntryPerLine(wfConfig::get($key))));\n\t\t\t\t$after = array_filter(explode(\"\\n\", wfUtils::cleanupOneEntryPerLine($newValue)));\n\t\t\t\t\n\t\t\t\t\/**\n\t\t\t\t * Fires when the banned username list changes.\n\t\t\t\t *\n\t\t\t\t * @since 8.0.0\n\t\t\t\t *\n\t\t\t\t * @param string[] $before The previous user list.\n\t\t\t\t * @param string[] $after The new user list.\n\t\t\t\t *\/\n\t\t\t\tdo_action('wordfence_updated_banned_usernames', $before, $after);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'loginSec_breachPasswds_enabled':\n\t\t\t{\n\t\t\t\t$before = wfUtils::truthyToBoolean(wfConfig::get($key));\n\t\t\t\t$after = wfUtils::truthyToBoolean($newValue);\n\t\t\t\t\n\t\t\t\tif ($before != $after) {\n\t\t\t\t\t\/**\n\t\t\t\t\t * Fires when the breached password protection setting is enabled\/disabled.\n\t\t\t\t\t *\n\t\t\t\t\t * @param bool $before The previous status.\n\t\t\t\t\t * @param bool $after The new status.\n\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t *\n\t\t\t\t\t *\/\n\t\t\t\t\tdo_action('wordfence_toggled_breached_password_protection', $before, $after);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'loginSec_strongPasswds_enabled':\n\t\t\t{\n\t\t\t\t$before = wfUtils::truthyToBoolean(wfConfig::get($key));\n\t\t\t\t$after = wfUtils::truthyToBoolean($newValue);\n\t\t\t\t\n\t\t\t\tif ($before != $after) {\n\t\t\t\t\t\/**\n\t\t\t\t\t * Fires when the enforce strong passwords setting is enabled\/disabled.\n\t\t\t\t\t *\n\t\t\t\t\t * @param bool $before The previous status.\n\t\t\t\t\t * @param bool $after The new status.\n\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t *\n\t\t\t\t\t *\/\n\t\t\t\t\tdo_action('wordfence_toggled_enforce_strong_passwords', $before, $after);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'loginSec_maskLoginErrors':\n\t\t\t{\n\t\t\t\t$before = wfUtils::truthyToBoolean(wfConfig::get($key));\n\t\t\t\t$after = wfUtils::truthyToBoolean($newValue);\n\t\t\t\t\n\t\t\t\tif ($before != $after) {\n\t\t\t\t\t\/**\n\t\t\t\t\t * Fires when the mask login errors setting is enabled\/disabled.\n\t\t\t\t\t *\n\t\t\t\t\t * @param bool $before The previous status.\n\t\t\t\t\t * @param bool $after The new status.\n\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t *\n\t\t\t\t\t *\/\n\t\t\t\t\tdo_action('wordfence_toggled_mask_login_errors', $before, $after);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'loginSec_blockAdminReg':\n\t\t\t{\n\t\t\t\t$before = wfUtils::truthyToBoolean(wfConfig::get($key));\n\t\t\t\t$after = wfUtils::truthyToBoolean($newValue);\n\t\t\t\t\n\t\t\t\tif ($before != $after) {\n\t\t\t\t\t\/**\n\t\t\t\t\t * Fires when the prevent `admin` as a username during registration setting is enabled\/disabled.\n\t\t\t\t\t *\n\t\t\t\t\t * @param bool $before The previous status.\n\t\t\t\t\t * @param bool $after The new status.\n\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t *\n\t\t\t\t\t *\/\n\t\t\t\t\tdo_action('wordfence_toggled_prevent_admin_username', $before, $after);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'loginSec_disableAuthorScan':\n\t\t\t{\n\t\t\t\t$before = wfUtils::truthyToBoolean(wfConfig::get($key));\n\t\t\t\t$after = wfUtils::truthyToBoolean($newValue);\n\t\t\t\t\n\t\t\t\tif ($before != $after) {\n\t\t\t\t\t\/**\n\t\t\t\t\t * Fires when the prevent discovery of usernames through a variety of endpoints setting is enabled\/disabled.\n\t\t\t\t\t *\n\t\t\t\t\t * @param bool $before The previous status.\n\t\t\t\t\t * @param bool $after The new status.\n\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t *\n\t\t\t\t\t *\/\n\t\t\t\t\tdo_action('wordfence_toggled_block_author_scan', $before, $after);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'loginSec_disableApplicationPasswords':\n\t\t\t{\n\t\t\t\t$before = wfUtils::truthyToBoolean(wfConfig::get($key));\n\t\t\t\t$after = wfUtils::truthyToBoolean($newValue);\n\t\t\t\t\n\t\t\t\tif ($before != $after) {\n\t\t\t\t\t\/**\n\t\t\t\t\t * Fires when the prevent WordPress application passwords setting is enabled\/disabled.\n\t\t\t\t\t *\n\t\t\t\t\t * @param bool $before The previous status.\n\t\t\t\t\t * @param bool $after The new status.\n\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t *\n\t\t\t\t\t *\/\n\t\t\t\t\tdo_action('wordfence_toggled_prevent_application_passwords', $before, $after);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'other_blockBadPOST':\n\t\t\t{\n\t\t\t\t$before = wfUtils::truthyToBoolean(wfConfig::get($key));\n\t\t\t\t$after = wfUtils::truthyToBoolean($newValue);\n\t\t\t\t\n\t\t\t\tif ($before != $after) {\n\t\t\t\t\t\/**\n\t\t\t\t\t * Fires when the block bad POST requests setting is enabled\/disabled.\n\t\t\t\t\t *\n\t\t\t\t\t * @param bool $before The previous status.\n\t\t\t\t\t * @param bool $after The new status.\n\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t *\n\t\t\t\t\t *\/\n\t\t\t\t\tdo_action('wordfence_toggled_block_bad_post', $before, $after);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'blockCustomText':\n\t\t\t{\n\t\t\t\t$before = wfConfig::get($key);\n\t\t\t\t$after = $newValue;\n\t\t\t\t\n\t\t\t\tif ($before != $after) {\n\t\t\t\t\t\/**\n\t\t\t\t\t * Fires when the custom block page text changes.\n\t\t\t\t\t *\n\t\t\t\t\t * @param string $before The previous text.\n\t\t\t\t\t * @param string $after The new text.\n\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t *\n\t\t\t\t\t *\/\n\t\t\t\t\tdo_action('wordfence_updated_custom_block_text', $before, $after);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'other_pwStrengthOnUpdate':\n\t\t\t{\n\t\t\t\t$before = wfUtils::truthyToBoolean(wfConfig::get($key));\n\t\t\t\t$after = wfUtils::truthyToBoolean($newValue);\n\t\t\t\t\n\t\t\t\tif ($before != $after) {\n\t\t\t\t\t\/**\n\t\t\t\t\t * Fires when the check password strength when changed setting is enabled\/disabled.\n\t\t\t\t\t *\n\t\t\t\t\t * @param bool $before The previous status.\n\t\t\t\t\t * @param bool $after The new status.\n\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t *\n\t\t\t\t\t *\/\n\t\t\t\t\tdo_action('wordfence_toggled_change_password_check_strength', $before, $after);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'other_WFNet':\n\t\t\t{\n\t\t\t\t$before = wfUtils::truthyToBoolean(wfConfig::get($key));\n\t\t\t\t$after = wfUtils::truthyToBoolean($newValue);\n\t\t\t\t\n\t\t\t\t\/**\n\t\t\t\t * Fires when the participate in the Wordfence Security Network setting is enabled\/disabled.\n\t\t\t\t *\n\t\t\t\t * @since 8.0.0\n\t\t\t\t *\n\t\t\t\t * @param bool $before The previous status.\n\t\t\t\t * @param bool $after The new status.\n\t\t\t\t *\/\n\t\t\t\tdo_action('wordfence_toggled_participate_security_network', $before, $after);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'firewallEnabled':\n\t\t\t{\n\t\t\t\t$before = wfUtils::truthyToBoolean(wfConfig::get($key));\n\t\t\t\t$after = wfUtils::truthyToBoolean($newValue);\n\t\t\t\t\n\t\t\t\tif ($before != $after) {\n\t\t\t\t\t\/**\n\t\t\t\t\t * Fires when the rate limiting\/advanced blocking setting is enabled\/disabled.\n\t\t\t\t\t *\n\t\t\t\t\t * @param bool $before The previous status.\n\t\t\t\t\t * @param bool $after The new status.\n\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t *\n\t\t\t\t\t *\/\n\t\t\t\t\tdo_action('wordfence_toggled_general_rate_limiting_blocking', $before, $after);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'neverBlockBG':\n\t\t\t{\n\t\t\t\t$before = wfConfig::get($key);\n\t\t\t\t$after = $newValue;\n\t\t\t\t\n\t\t\t\tif ($before != $after) {\n\t\t\t\t\t\/**\n\t\t\t\t\t * Fires when the never block crawlers setting is enabled\/disabled.\n\t\t\t\t\t *\n\t\t\t\t\t * @param string $before The previous status.\n\t\t\t\t\t * @param string $after The new status.\n\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t *\n\t\t\t\t\t *\/\n\t\t\t\t\tdo_action('wordfence_toggled_never_block_crawlers', $before, $after);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'maxGlobalRequests':\n\t\t\tcase 'maxGlobalRequests_action':\n\t\t\t{\n\t\t\t\tpreg_match('\/([^_]+)_?(.*)$\/', $key, $matches);\n\t\t\t\t$stem = $matches[1];\n\t\t\t\t$sub = empty($matches[2]) ? 'threshold' : $matches[2];\n\t\t\t\t$before = array(\n\t\t\t\t\t'threshold' => wfConfig::get($stem),\n\t\t\t\t\t'action' => wfConfig::get(\"{$stem}_action\"),\n\t\t\t\t);\n\t\t\t\t$after = $before;\n\t\t\t\tswitch ($sub) {\n\t\t\t\t\tcase 'threshold':\n\t\t\t\t\t\t$after[$sub] = $newValue;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'action':\n\t\t\t\t\t\t$after[$sub] = $newValue;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ($before != $after) {\n\t\t\t\t\t\/**\n\t\t\t\t\t * Fires when the max global requests rate limit setting changes.\n\t\t\t\t\t *\n\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t *\n\t\t\t\t\t * @param array $before {\n\t\t\t\t\t * \t\tThe previous setting value.\n\t\t\t\t\t * \n\t\t\t\t\t * \t\t@type int|string $threshold The number of requests before the rate limit is enforced\n\t\t\t\t\t * \t\t@type string $action The action taken when enforcing the rate limit\n\t\t\t\t\t * }\n\t\t\t\t\t * @param array $after {\n\t\t\t\t\t * \t\tThe new setting value.\n\t\t\t\t\t *\n\t\t\t\t\t * \t\t@type int|string $threshold The number of requests before the rate limit is enforced\n\t\t\t\t\t * \t\t@type string $action The action taken when enforcing the rate limit\n\t\t\t\t\t * }\n\t\t\t\t\t *\/\n\t\t\t\t\tdo_action('wordfence_updated_max_global_requests', $before, $after);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'maxRequestsCrawlers':\n\t\t\tcase 'maxRequestsCrawlers_action':\n\t\t\t{\n\t\t\t\tpreg_match('\/([^_]+)_?(.*)$\/', $key, $matches);\n\t\t\t\t$stem = $matches[1];\n\t\t\t\t$sub = empty($matches[2]) ? 'threshold' : $matches[2];\n\t\t\t\t$before = array(\n\t\t\t\t\t'threshold' => wfConfig::get($stem),\n\t\t\t\t\t'action' => wfConfig::get(\"{$stem}_action\"),\n\t\t\t\t);\n\t\t\t\t$after = $before;\n\t\t\t\tswitch ($sub) {\n\t\t\t\t\tcase 'threshold':\n\t\t\t\t\t\t$after[$sub] = $newValue;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'action':\n\t\t\t\t\t\t$after[$sub] = $newValue;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ($before != $after) {\n\t\t\t\t\t\/**\n\t\t\t\t\t * Fires when the max crawler requests rate limit setting changes.\n\t\t\t\t\t *\n\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t *\n\t\t\t\t\t * @param array $before {\n\t\t\t\t\t * \t\tThe previous setting value.\n\t\t\t\t\t *\n\t\t\t\t\t * \t\t@type int|string $threshold The number of requests before the rate limit is enforced\n\t\t\t\t\t * \t\t@type string $action The action taken when enforcing the rate limit\n\t\t\t\t\t * }\n\t\t\t\t\t * @param array $after {\n\t\t\t\t\t * \t\tThe new setting value.\n\t\t\t\t\t *\n\t\t\t\t\t * \t\t@type int|string $threshold The number of requests before the rate limit is enforced\n\t\t\t\t\t * \t\t@type string $action The action taken when enforcing the rate limit\n\t\t\t\t\t * }\n\t\t\t\t\t *\/\n\t\t\t\t\tdo_action('wordfence_updated_max_crawler_requests', $before, $after);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'max404Crawlers':\n\t\t\tcase 'max404Crawlers_action':\n\t\t\t{\n\t\t\t\tpreg_match('\/([^_]+)_?(.*)$\/', $key, $matches);\n\t\t\t\t$stem = $matches[1];\n\t\t\t\t$sub = empty($matches[2]) ? 'threshold' : $matches[2];\n\t\t\t\t$before = array(\n\t\t\t\t\t'threshold' => wfConfig::get($stem),\n\t\t\t\t\t'action' => wfConfig::get(\"{$stem}_action\"),\n\t\t\t\t);\n\t\t\t\t$after = $before;\n\t\t\t\tswitch ($sub) {\n\t\t\t\t\tcase 'threshold':\n\t\t\t\t\t\t$after[$sub] = $newValue;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'action':\n\t\t\t\t\t\t$after[$sub] = $newValue;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ($before != $after) {\n\t\t\t\t\t\/**\n\t\t\t\t\t * Fires when the max crawler 404s rate limit changes.\n\t\t\t\t\t *\n\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t *\n\t\t\t\t\t * @param array $before {\n\t\t\t\t\t * \t\tThe previous setting value.\n\t\t\t\t\t *\n\t\t\t\t\t * \t\t@type int|string $threshold The number of requests before the rate limit is enforced\n\t\t\t\t\t * \t\t@type string $action The action taken when enforcing the rate limit\n\t\t\t\t\t * }\n\t\t\t\t\t * @param array $after {\n\t\t\t\t\t * \t\tThe new setting value.\n\t\t\t\t\t *\n\t\t\t\t\t * \t\t@type int|string $threshold The number of requests before the rate limit is enforced\n\t\t\t\t\t * \t\t@type string $action The action taken when enforcing the rate limit\n\t\t\t\t\t * }\n\t\t\t\t\t *\/\n\t\t\t\t\tdo_action('wordfence_updated_max_crawler_404', $before, $after);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'maxRequestsHumans':\n\t\t\tcase 'maxRequestsHumans_action':\n\t\t\t{\n\t\t\t\tpreg_match('\/([^_]+)_?(.*)$\/', $key, $matches);\n\t\t\t\t$stem = $matches[1];\n\t\t\t\t$sub = empty($matches[2]) ? 'threshold' : $matches[2];\n\t\t\t\t$before = array(\n\t\t\t\t\t'threshold' => wfConfig::get($stem),\n\t\t\t\t\t'action' => wfConfig::get(\"{$stem}_action\"),\n\t\t\t\t);\n\t\t\t\t$after = $before;\n\t\t\t\tswitch ($sub) {\n\t\t\t\t\tcase 'threshold':\n\t\t\t\t\t\t$after[$sub] = $newValue;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'action':\n\t\t\t\t\t\t$after[$sub] = $newValue;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ($before != $after) {\n\t\t\t\t\t\/**\n\t\t\t\t\t * Fires when the max human requests rate limit changes.\n\t\t\t\t\t *\n\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t *\n\t\t\t\t\t * @param array $before {\n\t\t\t\t\t * \t\tThe previous setting value.\n\t\t\t\t\t *\n\t\t\t\t\t * \t\t@type int|string $threshold The number of requests before the rate limit is enforced\n\t\t\t\t\t * \t\t@type string $action The action taken when enforcing the rate limit\n\t\t\t\t\t * }\n\t\t\t\t\t * @param array $after {\n\t\t\t\t\t * \t\tThe new setting value.\n\t\t\t\t\t *\n\t\t\t\t\t * \t\t@type int|string $threshold The number of requests before the rate limit is enforced\n\t\t\t\t\t * \t\t@type string $action The action taken when enforcing the rate limit\n\t\t\t\t\t * }\n\t\t\t\t\t *\/\n\t\t\t\t\tdo_action('wordfence_updated_max_human_requests', $before, $after);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'max404Humans':\n\t\t\tcase 'max404Humans_action':\n\t\t\t{\n\t\t\t\tpreg_match('\/([^_]+)_?(.*)$\/', $key, $matches);\n\t\t\t\t$stem = $matches[1];\n\t\t\t\t$sub = empty($matches[2]) ? 'threshold' : $matches[2];\n\t\t\t\t$before = array(\n\t\t\t\t\t'threshold' => wfConfig::get($stem),\n\t\t\t\t\t'action' => wfConfig::get(\"{$stem}_action\"),\n\t\t\t\t);\n\t\t\t\t$after = $before;\n\t\t\t\tswitch ($sub) {\n\t\t\t\t\tcase 'threshold':\n\t\t\t\t\t\t$after[$sub] = $newValue;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'action':\n\t\t\t\t\t\t$after[$sub] = $newValue;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ($before != $after) {\n\t\t\t\t\t\/**\n\t\t\t\t\t * Fires when the max human 404s rate limit changes.\n\t\t\t\t\t *\n\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t *\n\t\t\t\t\t * @param array $before {\n\t\t\t\t\t * \t\tThe previous setting value.\n\t\t\t\t\t *\n\t\t\t\t\t * \t\t@type int|string $threshold The number of requests before the rate limit is enforced\n\t\t\t\t\t * \t\t@type string $action The action taken when enforcing the rate limit\n\t\t\t\t\t * }\n\t\t\t\t\t * @param array $after {\n\t\t\t\t\t * \t\tThe new setting value.\n\t\t\t\t\t *\n\t\t\t\t\t * \t\t@type int|string $threshold The number of requests before the rate limit is enforced\n\t\t\t\t\t * \t\t@type string $action The action taken when enforcing the rate limit\n\t\t\t\t\t * }\n\t\t\t\t\t *\/\n\t\t\t\t\tdo_action('wordfence_updated_max_human_404', $before, $after);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'blockedTime':\n\t\t\t{\n\t\t\t\t$before = intval(wfConfig::get($key));\n\t\t\t\t$after = intval($newValue);\n\t\t\t\t\n\t\t\t\tif ($before != $after) {\n\t\t\t\t\t\/**\n\t\t\t\t\t * Fires when the block duration changes.\n\t\t\t\t\t *\n\t\t\t\t\t * @param int $before The previous value.\n\t\t\t\t\t * @param int $after The new value.\n\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t *\n\t\t\t\t\t *\/\n\t\t\t\t\tdo_action('wordfence_updated_block_duration', $before, $after);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'allowed404s':\n\t\t\t{\n\t\t\t\t$before = array_filter(preg_split('\/[\\r\\n]+\/', wfConfig::get($key)));\n\t\t\t\t$after = array_filter(preg_split('\/[\\r\\n]+\/', $newValue));\n\t\t\t\t\n\t\t\t\t\/**\n\t\t\t\t * Fires when the allowed 404 URL list changes.\n\t\t\t\t *\n\t\t\t\t * @since 8.0.0\n\t\t\t\t *\n\t\t\t\t * @param string[] $before The previous list.\n\t\t\t\t * @param string[] $after The new list.\n\t\t\t\t *\/\n\t\t\t\tdo_action('wordfence_updated_allowed_404', $before, $after);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'scansEnabled_checkGSB':\n\t\t\tcase 'spamvertizeCheck':\n\t\t\tcase 'checkSpamIP':\n\t\t\tcase 'scansEnabled_checkHowGetIPs':\n\t\t\tcase 'scansEnabled_checkReadableConfig':\n\t\t\tcase 'scansEnabled_suspectedFiles':\n\t\t\tcase 'scansEnabled_core':\n\t\t\tcase 'scansEnabled_themes':\n\t\t\tcase 'scansEnabled_plugins':\n\t\t\tcase 'scansEnabled_coreUnknown':\n\t\t\tcase 'scansEnabled_malware':\n\t\t\tcase 'scansEnabled_fileContents':\n\t\t\tcase 'scansEnabled_fileContentsGSB':\n\t\t\tcase 'scansEnabled_posts':\n\t\t\tcase 'scansEnabled_comments':\n\t\t\tcase 'scansEnabled_suspiciousOptions':\n\t\t\tcase 'scansEnabled_oldVersions':\n\t\t\tcase 'scansEnabled_suspiciousAdminUsers':\n\t\t\tcase 'scansEnabled_passwds':\n\t\t\tcase 'scansEnabled_diskSpace':\n\t\t\tcase 'scansEnabled_wafStatus':\n\t\t\tcase 'other_scanOutside':\n\t\t\tcase 'scansEnabled_scanImages':\n\t\t\tcase 'lowResourceScansEnabled':\n\t\t\tcase 'scan_maxIssues':\n\t\t\tcase 'scan_maxDuration':\n\t\t\tcase 'maxMem':\n\t\t\tcase 'maxExecutionTime':\n\t\t\tcase 'scan_exclude':\n\t\t\tcase 'scan_include_extra':\n\t\t\tcase 'scan_force_ipv4_start':\n\t\t\tcase 'scan_max_resume_attempts':\n\t\t\t{\n\t\t\t\t$options = array(\n\t\t\t\t\t'scansEnabled_checkGSB' => self::TYPE_BOOL,\n\t\t\t\t\t'spamvertizeCheck' => self::TYPE_BOOL,\n\t\t\t\t\t'checkSpamIP' => self::TYPE_BOOL,\n\t\t\t\t\t'scansEnabled_checkHowGetIPs' => self::TYPE_BOOL,\n\t\t\t\t\t'scansEnabled_checkReadableConfig' => self::TYPE_BOOL,\n\t\t\t\t\t'scansEnabled_suspectedFiles' => self::TYPE_BOOL,\n\t\t\t\t\t'scansEnabled_core' => self::TYPE_BOOL,\n\t\t\t\t\t'scansEnabled_themes' => self::TYPE_BOOL,\n\t\t\t\t\t'scansEnabled_plugins' => self::TYPE_BOOL,\n\t\t\t\t\t'scansEnabled_coreUnknown' => self::TYPE_BOOL,\n\t\t\t\t\t'scansEnabled_malware' => self::TYPE_BOOL,\n\t\t\t\t\t'scansEnabled_fileContents' => self::TYPE_BOOL,\n\t\t\t\t\t'scansEnabled_fileContentsGSB' => self::TYPE_BOOL,\n\t\t\t\t\t'scansEnabled_posts' => self::TYPE_BOOL,\n\t\t\t\t\t'scansEnabled_comments' => self::TYPE_BOOL,\n\t\t\t\t\t'scansEnabled_suspiciousOptions' => self::TYPE_BOOL,\n\t\t\t\t\t'scansEnabled_oldVersions' => self::TYPE_BOOL,\n\t\t\t\t\t'scansEnabled_suspiciousAdminUsers' => self::TYPE_BOOL,\n\t\t\t\t\t'scansEnabled_passwds' => self::TYPE_BOOL,\n\t\t\t\t\t'scansEnabled_diskSpace' => self::TYPE_BOOL,\n\t\t\t\t\t'scansEnabled_wafStatus' => self::TYPE_BOOL,\n\t\t\t\t\t'other_scanOutside' => self::TYPE_BOOL,\n\t\t\t\t\t'scansEnabled_scanImages' => self::TYPE_BOOL,\n\t\t\t\t\t\n\t\t\t\t\t'lowResourceScansEnabled' => self::TYPE_BOOL,\n\t\t\t\t\t'scan_maxIssues' => self::TYPE_INT,\n\t\t\t\t\t'scan_maxDuration' => self::TYPE_INT,\n\t\t\t\t\t'maxMem' => self::TYPE_INT,\n\t\t\t\t\t'maxExecutionTime' => self::TYPE_INT,\n\t\t\t\t\t\n\t\t\t\t\t'scan_exclude' => self::TYPE_MULTI_STRING,\n\t\t\t\t\t'scan_include_extra' => self::TYPE_MULTI_STRING,\n\t\t\t\t\t'scan_force_ipv4_start' => self::TYPE_BOOL,\n\t\t\t\t\t'scan_max_resume_attempts' => self::TYPE_INT,\n\t\t\t\t);\n\t\t\t\t\n\t\t\t\t$before = array();\n\t\t\t\t$after = array();\n\t\t\t\tforeach ($options as $k => $t) {\n\t\t\t\t\t$rawBefore = wfConfig::get($k);\n\t\t\t\t\t$rawAfter = ($key == $k ? $newValue : $rawBefore);\n\t\t\t\t\tswitch ($t) { \/\/Not all types are implemented -- only those that we use in the array above\n\t\t\t\t\t\tcase self::TYPE_BOOL:\n\t\t\t\t\t\t\t$before[$k] = wfUtils::truthyToBoolean($rawBefore);\n\t\t\t\t\t\t\t$after[$k] = wfUtils::truthyToBoolean($rawAfter);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase self::TYPE_INT:\n\t\t\t\t\t\t\t$before[$k] = intval($rawBefore);\n\t\t\t\t\t\t\t$after[$k] = intval($rawAfter);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase self::TYPE_STRING:\n\t\t\t\t\t\t\t$before[$k] = $rawBefore;\n\t\t\t\t\t\t\t$after[$k] = $rawAfter;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase self::TYPE_MULTI_STRING:\n\t\t\t\t\t\t\t$before[$k] = array_filter(preg_split('\/[\\r\\n]+\/', $rawBefore));\n\t\t\t\t\t\t\t$after[$k] = array_filter(preg_split('\/[\\r\\n]+\/', $rawAfter));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ($before != $after) {\n\t\t\t\t\t\/**\n\t\t\t\t\t * Fires when the scan options change. This may be called multiple times if multiple options are \n\t\t\t\t\t * changed (once each).\n\t\t\t\t\t *\n\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t *\n\t\t\t\t\t * @param string[] $before The previous options.\n\t\t\t\t\t * @param string[] $after The new options.\n\t\t\t\t\t *\/\n\t\t\t\t\tdo_action('wordfence_updated_scan_options', $before, $after);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'scheduledScansEnabled':\n\t\t\tcase 'schedMode':\n\t\t\tcase 'manualScanType':\n\t\t\tcase 'schedStartHour':\n\t\t\tcase 'scanSched':\n\t\t\t{\n\t\t\t\t$options = array(\n\t\t\t\t\t'scheduledScansEnabled' => self::TYPE_BOOL,\n\t\t\t\t\t'schedMode' => self::TYPE_STRING,\n\t\t\t\t\t'manualScanType' => self::TYPE_STRING,\n\t\t\t\t\t'schedStartHour' => self::TYPE_INT,\n\t\t\t\t\t'scanSched' => self::TYPE_ARRAY,\n\t\t\t\t);\n\t\t\t\t\n\t\t\t\t$before = array();\n\t\t\t\t$after = array();\n\t\t\t\tforeach ($options as $k => $t) {\n\t\t\t\t\tswitch ($t) { \/\/Not all types are implemented -- only those that we use in the array above\n\t\t\t\t\t\tcase self::TYPE_BOOL:\n\t\t\t\t\t\t\t$rawBefore = wfConfig::get($k);\n\t\t\t\t\t\t\t$rawAfter = ($key == $k ? $newValue : $rawBefore);\n\t\t\t\t\t\t\t$before[$k] = wfUtils::truthyToBoolean($rawBefore);\n\t\t\t\t\t\t\t$after[$k] = wfUtils::truthyToBoolean($rawAfter);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase self::TYPE_INT:\n\t\t\t\t\t\t\t$rawBefore = wfConfig::get($k);\n\t\t\t\t\t\t\t$rawAfter = ($key == $k ? $newValue : $rawBefore);\n\t\t\t\t\t\t\t$before[$k] = intval($rawBefore);\n\t\t\t\t\t\t\t$after[$k] = intval($rawAfter);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase self::TYPE_STRING:\n\t\t\t\t\t\t\t$rawBefore = wfConfig::get($k);\n\t\t\t\t\t\t\t$rawAfter = ($key == $k ? $newValue : $rawBefore);\n\t\t\t\t\t\t\t$before[$k] = $rawBefore;\n\t\t\t\t\t\t\t$after[$k] = $rawAfter;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase self::TYPE_ARRAY:\n\t\t\t\t\t\t\t$rawBefore = wfConfig::get_ser($k, array());\n\t\t\t\t\t\t\t$rawAfter = ($key == $k ? $newValue : $rawBefore);\n\t\t\t\t\t\t\t$before[$k] = $rawBefore;\n\t\t\t\t\t\t\t$after[$k] = $rawAfter;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ($before != $after) {\n\t\t\t\t\t\/**\n\t\t\t\t\t * Fires when the scan scheduling change. This may be called multiple times if multiple options are\n\t\t\t\t\t * changed (once each).\n\t\t\t\t\t *\n\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t *\n\t\t\t\t\t * @param string[] $before The previous schedule\/options.\n\t\t\t\t\t * @param string[] $after The new schedule\/options.\n\t\t\t\t\t *\/\n\t\t\t\t\tdo_action('wordfence_updated_scan_schedule', $before, $after);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'cbl_loggedInBlocked':\n\t\t\tcase 'cbl_action':\n\t\t\tcase 'cbl_redirURL':\n\t\t\tcase 'cbl_bypassRedirURL':\n\t\t\tcase 'cbl_bypassRedirDest':\n\t\t\tcase 'cbl_bypassViewURL':\n\t\t\t{\n\t\t\t\t$block = wfUtils::array_first(wfBlock::countryBlocks(true)); \/** @var wfBlock $block *\/\n\t\t\t\t$before = array(\n\t\t\t\t\t'parameters' => $block ? $block->parameters : null,\n\t\t\t\t\t'bypass' => array(\n\t\t\t\t\t\t'cbl_loggedInBlocked' => wfConfig::get('cbl_loggedInBlocked', false),\n\t\t\t\t\t\t'cbl_action' => wfConfig::get('cbl_action'),\n\t\t\t\t\t\t'cbl_redirURL' => wfConfig::get('cbl_redirURL', ''),\n\t\t\t\t\t\t'cbl_bypassRedirURL' => wfConfig::get('cbl_bypassRedirURL', ''),\n\t\t\t\t\t\t'cbl_bypassRedirDest' => wfConfig::get('cbl_bypassRedirDest', ''),\n\t\t\t\t\t\t'cbl_bypassViewURL' => wfConfig::get('cbl_bypassViewURL', ''),\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t\t$after = $before;\n\t\t\t\t$after['bypass'][$key] = $newValue;\n\t\t\t\t\n\t\t\t\t\/**\n\t\t\t\t * @see wfBlock::createCountry()\n\t\t\t\t *\/\n\t\t\t\tdo_action('wordfence_updated_country_blocking', $before, $after);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'auditLogMode':\n\t\t\t{\n\t\t\t\t$before = wfConfig::get($key);\n\t\t\t\t$after = $newValue;\n\t\t\t\t\n\t\t\t\tif ($before != $after) {\n\t\t\t\t\t\/**\n\t\t\t\t\t * Fires when the audit log recording mode changes.\n\t\t\t\t\t *\n\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t *\n\t\t\t\t\t * @param string $before The previous status.\n\t\t\t\t\t * @param string $after The new status.\n\t\t\t\t\t *\/\n\t\t\t\t\tdo_action('wordfence_changed_audit_log_mode', $before, $after);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'apiKey':\n\t\t\t{\n\t\t\t\t$before = wfConfig::get($key);\n\t\t\t\t$after = $newValue;\n\t\t\t\t\n\t\t\t\tif ($before != $after) {\n\t\t\t\t\t\/**\n\t\t\t\t\t * Fires when the license key changes.\n\t\t\t\t\t *\n\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t *\n\t\t\t\t\t * @param string $before The previous key.\n\t\t\t\t\t * @param string $after The new key.\n\t\t\t\t\t *\/\n\t\t\t\t\tdo_action('wordfence_changed_license_key', $before, $after);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'howGetIPs':\n\t\t\t{\n\t\t\t\t$before = wfConfig::get($key);\n\t\t\t\t$after = $newValue;\n\t\t\t\t\n\t\t\t\tif ($before != $after) {\n\t\t\t\t\t\/**\n\t\t\t\t\t * Fires when the IP source changes.\n\t\t\t\t\t *\n\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t *\n\t\t\t\t\t * @param string $before The previous value.\n\t\t\t\t\t * @param string $after The new value.\n\t\t\t\t\t *\/\n\t\t\t\t\tdo_action('wordfence_changed_ip_source', $before, $after);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'howGetIPs_trusted_proxies':\n\t\t\t{\n\t\t\t\t$before = array_filter(preg_split('\/[\\r\\n]+\/', wfConfig::get($key)));\n\t\t\t\t$after = array_filter(preg_split('\/[\\r\\n]+\/', $newValue));\n\t\t\t\t\n\t\t\t\tif (!(count($before) == count($after) && empty(array_diff($before, $after)))) {\n\t\t\t\t\t\/**\n\t\t\t\t\t * Fires when the trusted proxy list changes.\n\t\t\t\t\t *\n\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t *\n\t\t\t\t\t * @param string[] $before The previous list.\n\t\t\t\t\t * @param string[] $after The new list.\n\t\t\t\t\t *\/\n\t\t\t\t\tdo_action('wordfence_updated_trusted_proxies', $before, $after);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'howGetIPs_trusted_proxy_preset':\n\t\t\t{\n\t\t\t\t$before = wfConfig::get($key);\n\t\t\t\t$after = $newValue;\n\t\t\t\t\n\t\t\t\tif ($before != $after) {\n\t\t\t\t\t\/**\n\t\t\t\t\t * Fires when the trusted proxy preset changes.\n\t\t\t\t\t *\n\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t *\n\t\t\t\t\t * @param string $before The previous value.\n\t\t\t\t\t * @param string $after The new value.\n\t\t\t\t\t *\/\n\t\t\t\t\tdo_action('wordfence_changed_trusted_proxy_preset', $before, $after);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'ipResolutionList':\n\t\t\t{\n\t\t\t\t$before = (array) wfConfig::getJSON($key, array());\n\t\t\t\t$after = json_decode($newValue, true);\n\t\t\t\t\n\t\t\t\t\/**\n\t\t\t\t * Fires when the trusted proxy list definitions changes.\n\t\t\t\t *\n\t\t\t\t * @since 8.0.0\n\t\t\t\t *\n\t\t\t\t * @param array $before The previous definitions.\n\t\t\t\t * @param array $after The new definitions.\n\t\t\t\t *\/\n\t\t\t\tdo_action('wordfence_updated_trusted_proxy_preset_definitions', $before, $after);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass wfConfigException extends Exception {}"},{"base":"plugins","rel":"wordfence\/lib\/wfHelperString.php","ext":"php","size":2180,"mtime":1757312769,"type":"text","content":"<?php\n\n\nclass wfHelperString {\n\n\t\/**\n\t * cycle through arguments\n\t *\n\t * @return mixed\n\t *\/\n\tpublic static function cycle() {\n\t\tstatic $counter = 0;\n\t\t$args = func_get_args();\n\t\tif (empty($args)) {\n\t\t\t$counter = 0;\n\t\t\treturn null;\n\t\t}\n\t\t$return_val = $args[$counter % count($args)];\n\t\t$counter++;\n\t\treturn $return_val;\n\t}\n\n\tpublic static function plainTextTable($table, $maxColumnWidth = 60) {\n\t\tif (count($table) === 0) {\n\t\t\treturn '';\n\t\t}\n\t\t\n\t\t$colLengths = array();\n\t\tfor ($row = 0; $row < count($table); $row++) {\n\t\t\tif (is_string($table[$row])) { \/\/Special handling to show a sub-header\/divider\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor ($col = 0; $col < count($table[$row]); $col++) {\n\t\t\t\t$table[$row][$col] = wordwrap(str_replace(\"\\t\", \"    \", $table[$row][$col]), $maxColumnWidth, \"\\n\", true);\n\t\t\t\t\n\t\t\t\tforeach (explode(\"\\n\", $table[$row][$col]) as $colText) {\n\t\t\t\t\tif (!isset($colLengths[$col])) {\n\t\t\t\t\t\t$colLengths[$col] = strlen($colText);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t$len = strlen($colText);\n\t\t\t\t\tif ($len > $colLengths[$col]) {\n\t\t\t\t\t\t$colLengths[$col] = $len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t$totalWidth = array_sum($colLengths) + (count($colLengths) * 3) + 1;\n\t\t$hr = str_repeat('-', $totalWidth);\n\t\t$output = $hr . \"\\n\";\n\t\tfor ($row = 0; $row < count($table); $row++) {\n\t\t\tif (is_string($table[$row])) { \/\/Special handling to show a sub-header\/divider\n\t\t\t\tif ($row > 1) { $output .= $hr . \"\\n\"; }\n\t\t\t\t$output .= '| ' . str_pad($table[$row], $totalWidth - 4, ' ', STR_PAD_BOTH) . ' ' . \"|\\n\";\n\t\t\t\t$output .= $hr . \"\\n\";\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t$colHeight = 0;\n\t\t\tfor ($col = 0; $col < count($table[$row]); $col++) {\n\t\t\t\t$height = substr_count($table[$row][$col], \"\\n\");\n\t\t\t\tif ($height > $colHeight) {\n\t\t\t\t\t$colHeight = $height;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor ($colRow = 0; $colRow <= $colHeight; $colRow++) {\n\t\t\t\tfor ($col = 0; $col < count($table[$row]); $col++) {\n\t\t\t\t\t$colRows = explode(\"\\n\", $table[$row][$col]);\n\t\t\t\t\t$output .= '| ' . str_pad(isset($colRows[$colRow]) ? $colRows[$colRow] : '', $colLengths[$col], ' ', STR_PAD_RIGHT) . ' ';\n\t\t\t\t}\n\t\t\t\t$output .= \"|\\n\";\n\t\t\t}\n\t\t\tif ($row === 0) {\n\t\t\t\t$output .= $hr . \"\\n\";\n\t\t\t}\n\t\t}\n\t\treturn trim($output . (count($table) > 1 ? $hr : ''));\n\t}\n}"},{"base":"plugins","rel":"wordfence\/lib\/Diff.php","ext":"php","size":5762,"mtime":1757312769,"type":"text","content":"<?php\n\/**\n * Diff\n *\n * A comprehensive library for generating differences between two strings\n * in multiple formats (unified, side by side HTML etc)\n *\n * PHP version 5\n *\n * Copyright (c) 2009 Chris Boulton <chris.boulton@interspire.com>\n * \n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without \n * modification, are permitted provided that the following conditions are met:\n *\n *  - Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *  - Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and\/or other materials provided with the distribution.\n *  - Neither the name of the Chris Boulton nor the names of its contributors \n *    may be used to endorse or promote products derived from this software \n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n * POSSIBILITY OF SUCH DAMAGE.\n *\n * @package Diff\n * @author Chris Boulton <chris.boulton@interspire.com>\n * @copyright (c) 2009 Chris Boulton\n * @license New BSD License http:\/\/www.opensource.org\/licenses\/bsd-license.php\n * @version 1.1\n * @link http:\/\/github.com\/chrisboulton\/php-diff\n *\/\n\nclass Diff\n{\n\t\/**\n\t * @var array The \"old\" sequence to use as the basis for the comparison.\n\t *\/\n\tprivate $a = null;\n\n\t\/**\n\t * @var array The \"new\" sequence to generate the changes for.\n\t *\/\n\tprivate $b = null;\n\n\t\/**\n\t * @var array Array containing the generated opcodes for the differences between the two items.\n\t *\/\n\tprivate $groupedCodes = null;\n\n\t\/**\n\t * @var array Associative array of the default options available for the diff class and their default value.\n\t *\/\n\tprivate $defaultOptions = array(\n\t\t'context' => 3,\n\t\t'ignoreNewLines' => false,\n\t\t'ignoreWhitespace' => false,\n\t\t'ignoreCase' => false\n\t);\n\n\t\/**\n\t * @var array Array of the options that have been applied for generating the diff.\n\t *\/\n\tprivate $options = array();\n\n\t\/**\n\t * The constructor.\n\t *\n\t * @param array $a Array containing the lines of the first string to compare.\n\t * @param array $b Array containing the lines for the second string to compare.\n\t *\/\n\tpublic function __construct($a, $b, $options=array())\n\t{\n\t\t$this->a = $a;\n\t\t$this->b = $b;\n\n\t\t$this->options = array_merge($this->defaultOptions, $options);\n\t}\n\n\t\/**\n\t * Render a diff using the supplied rendering class and return it.\n\t *\n\t * @param object $renderer An instance of the rendering object to use for generating the diff.\n\t * @return mixed The generated diff. Exact return value depends on the rendered.\n\t *\/\n\tpublic function render(Diff_Renderer_Abstract $renderer)\n\t{\n\t\t$renderer->diff = $this;\n\t\treturn $renderer->render();\n\t}\n\n\t\/**\n\t * Get a range of lines from $start to $end from the first comparison string\n\t * and return them as an array. If no values are supplied, the entire string\n\t * is returned. It's also possible to specify just one line to return only\n\t * that line.\n\t *\n\t * @param int $start The starting number.\n\t * @param int $end The ending number. If not supplied, only the item in $start will be returned.\n\t * @return array Array of all of the lines between the specified range.\n\t *\/\n\tpublic function getA($start=0, $end=null)\n\t{\n\t\tif($start == 0 && $end === null) {\n\t\t\treturn $this->a;\n\t\t}\n\n\t\tif($end === null) {\n\t\t\t$length = 1;\n\t\t}\n\t\telse {\n\t\t\t$length = $end - $start;\n\t\t}\n\n\t\treturn array_slice($this->a, $start, $length);\n\n\t}\n\n\t\/**\n\t * Get a range of lines from $start to $end from the second comparison string\n\t * and return them as an array. If no values are supplied, the entire string\n\t * is returned. It's also possible to specify just one line to return only\n\t * that line.\n\t *\n\t * @param int $start The starting number.\n\t * @param int $end The ending number. If not supplied, only the item in $start will be returned.\n\t * @return array Array of all of the lines between the specified range.\n\t *\/\n\tpublic function getB($start=0, $end=null)\n\t{\n\t\tif($start == 0 && $end === null) {\n\t\t\treturn $this->b;\n\t\t}\n\n\t\tif($end === null) {\n\t\t\t$length = 1;\n\t\t}\n\t\telse {\n\t\t\t$length = $end - $start;\n\t\t}\n\n\t\treturn array_slice($this->b, $start, $length);\n\t}\n\n\t\/**\n\t * Generate a list of the compiled and grouped opcodes for the differences between the\n\t * two strings. Generally called by the renderer, this class instantiates the sequence\n\t * matcher and performs the actual diff generation and return an array of the opcodes\n\t * for it. Once generated, the results are cached in the diff class instance.\n\t *\n\t * @return array Array of the grouped opcodes for the generated diff.\n\t *\/\n\tpublic function getGroupedOpcodes()\n\t{\n\t\tif(!is_null($this->groupedCodes)) {\n\t\t\treturn $this->groupedCodes;\n\t\t}\n\n\t\trequire_once(dirname(__FILE__) . '\/Diff\/SequenceMatcher.php');\n\t\t$sequenceMatcher = new Diff_SequenceMatcher($this->a, $this->b, null, $this->options);\n\t\t$this->groupedCodes = $sequenceMatcher->getGroupedOpcodes();\n\t\treturn $this->groupedCodes;\n\t}\n}\n"},{"base":"plugins","rel":"wordfence\/lib\/wfAdminNoticeQueue.php","ext":"php","size":5323,"mtime":1757312769,"type":"text","content":"<?php\n\nclass wfAdminNoticeQueue {\n\tprotected static function _notices() {\n\t\treturn self::_purgeObsoleteNotices(wfConfig::get_ser('adminNoticeQueue', array()));\n\t}\n\n\tprivate static function _purgeObsoleteNotices($notices) {\n\t\t$altered = false;\n\t\tforeach ($notices as $id => $notice) {\n\t\t\tif ($notice['category'] === 'php8') {\n\t\t\t\tunset($notices[$id]);\n\t\t\t\t$altered = true;\n\t\t\t}\n\t\t}\n\t\tif ($altered)\n\t\t\tself::_setNotices($notices);\n\t\treturn $notices;\n\t}\n\t\n\tprotected static function _setNotices($notices) {\n\t\twfConfig::set_ser('adminNoticeQueue', $notices);\n\t}\n\t\n\t\/**\n\t * Adds an admin notice to the display queue.\n\t * \n\t * @param string $severity\n\t * @param string $messageHTML\n\t * @param bool|string $category If not false, notices with the same category will be removed prior to adding this one.\n\t * @param bool|array $users If not false, an array of user IDs the notice should show for.\n\t *\/\n\tpublic static function addAdminNotice($severity, $messageHTML, $category = false, $users = false) {\n\t\t$notices = self::_notices();\n\t\tforeach ($notices as $id => $n) {\n\t\t\t$usersMatches = false;\n\t\t\tif (isset($n['users'])) {\n\t\t\t\t$usersMatches = wfUtils::sets_equal($n['users'], $users);\n\t\t\t}\n\t\t\telse if ($users === false) {\n\t\t\t\t$usersMatches = true;\n\t\t\t}\n\t\t\t\n\t\t\t$categoryMatches = false;\n\t\t\tif ($category !== false && isset($n['category']) && $n['category'] == $category) {\n\t\t\t\t$categoryMatches = true;\n\t\t\t}\n\t\t\t\n\t\t\tif ($usersMatches && $categoryMatches) {\n\t\t\t\tunset($notices[$id]);\n\t\t\t}\n\t\t}\n\t\t\n\t\t$id = wfUtils::uuid();\n\t\t$notices[$id] = array(\n\t\t\t'severity' => $severity,\n\t\t\t'messageHTML' => $messageHTML,\n\t\t);\n\t\t\n\t\tif ($category !== false) {\n\t\t\t$notices[$id]['category'] = $category;\n\t\t}\n\t\t\n\t\tif ($users !== false) {\n\t\t\t$notices[$id]['users'] = $users;\n\t\t}\n\t\t\n\t\tself::_setNotices($notices);\n\t}\n\t\n\t\/**\n\t * Removes an admin notice using one of three possible search methods:\n\t * \n\t * \t1. If $id matches. $category and $users are ignored\n\t * \t2. If $category matches. $users must be false for this.\n\t * \t3. If $category matches and the notice's user IDs matches $users.\n\t * \n\t * @param bool|int $id\n\t * @param bool|string $category\n\t * @param bool|int[] $users\n\t *\/\n\tpublic static function removeAdminNotice($id = false, $category = false, $users = false) {\n\t\tif ($id === false && $category === false && $users === false) {\n\t\t\treturn;\n\t\t}\n\t\telse if ($id !== false) {\n\t\t\t$category = false;\n\t\t\t$users = false;\n\t\t}\n\n\t\t$notices = self::_notices();\n\t\t$found = false;\n\t\tforeach ($notices as $nid => $n) {\n\t\t\tif ($id == $nid) { \/\/ID match\n\t\t\t\tunset($notices[$nid]);\n\t\t\t\t$found=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if ($id !== false) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif ($category !== false && isset($n['category']) && $category == $n['category']) {\n\t\t\t\tif ($users !== false) {\n\t\t\t\t\tif (isset($n['users']) && wfUtils::sets_equal($users, $n['users'])) {\n\t\t\t\t\t\tunset($notices[$nid]);\n\t\t\t\t\t\t$found=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tunset($notices[$nid]);\n\t\t\t\t\t$found=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif($found)\n\t\t\tself::_setNotices($notices);\n\t}\n\t\n\tpublic static function hasNotice($category = false, $users = false) {\n\t\t$notices = self::_notices();\n\t\tforeach ($notices as $nid => $n) {\n\t\t\t$categoryMatches = false;\n\t\t\tif (($category === false && !isset($n['category'])) || ($category !== false && isset($n['category']) && $category == $n['category'])) {\n\t\t\t\t$categoryMatches = true;\n\t\t\t}\n\t\t\t\n\t\t\t$usersMatches = false;\n\t\t\tif (($users === false && !isset($n['users'])) || ($users !== false && isset($n['users']) && wfUtils::sets_equal($users, $n['users']))) {\n\t\t\t\t$usersMatches = true;\n\t\t\t}\n\t\t\t\n\t\t\tif ($categoryMatches && $usersMatches) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic static function enqueueAdminNotices() {\n\t\t$user = wp_get_current_user();\n\t\tif ($user->ID == 0) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t$networkAdmin = is_multisite() && is_network_admin();\n\t\t$notices = self::_notices();\n\t\t$added = false;\n\t\tforeach ($notices as $nid => $n) {\n\t\t\tif (isset($n['users']) && array_search($user->ID, $n['users']) === false) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t$notice = new wfAdminNotice($nid, $n['severity'], $n['messageHTML']);\n\t\t\tif ($networkAdmin) {\n\t\t\t\tadd_action('network_admin_notices', array($notice, 'displayNotice'));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd_action('admin_notices', array($notice, 'displayNotice'));\n\t\t\t}\n\t\t\t\n\t\t\t$added = true;\n\t\t}\n\t\t\n\t\treturn $added;\n\t}\n}\n\nclass wfAdminNotice {\n\tconst SEVERITY_CRITICAL = 'critical';\n\tconst SEVERITY_WARNING = 'warning';\n\tconst SEVERITY_INFO = 'info';\n\t\n\tprivate $_id;\n\tprivate $_severity;\n\tprivate $_messageHTML;\n\t\n\tpublic function __construct($id, $severity, $messageHTML) {\n\t\t$this->_id = $id;\n\t\t$this->_severity = $severity;\n\t\t$this->_messageHTML = $messageHTML;\n\t}\n\t\n\tpublic function displayNotice() {\n\t\t$severityClass = 'notice-info';\n\t\tif ($this->_severity == self::SEVERITY_CRITICAL) {\n\t\t\t$severityClass = 'notice-error';\n\t\t}\n\t\telse if ($this->_severity == self::SEVERITY_WARNING) {\n\t\t\t$severityClass = 'notice-warning';\n\t\t}\n\t\t\n\t\techo '<div class=\"wf-admin-notice notice ' . $severityClass . '\" data-notice-id=\"' . esc_attr($this->_id) . '\"><p>' . $this->_messageHTML . '<\/p><p><a class=\"wf-btn wf-btn-default wf-btn-sm wf-dismiss-link\" href=\"#\" onclick=\"wordfenceExt.dismissAdminNotice(\\'' . esc_attr($this->_id) . '\\'); return false;\" role=\"button\">' . esc_html__('Dismiss', 'wordfence') . '<\/a><\/p><\/div>';\n\t}\n}"},{"base":"plugins","rel":"wordfence\/lib\/wfSchema.php","ext":"php","size":11175,"mtime":1757312769,"type":"text","content":"<?php\nrequire_once(dirname(__FILE__) . '\/wfDB.php');\nclass wfSchema {\n\tconst TABLE_CASE_OPTION = 'wordfence_case'; \/\/false is camel case, true is lower\n\t\n\tprivate static $_usingLowercase = null;\n\tprivate static $deprecatedTables = array(\n\t\t'wfBlocks',\n\t\t'wfBlocksAdv',\n\t\t'wfLockedOut',\n\t\t'wfThrottleLog',\n\t\t'wfNet404s',\n\t\t'wfBlockedCommentLog',\n\t\t'wfVulnScanners',\n\t\t'wfBadLeechers',\n\t\t'wfLeechers',\n\t\t'wfScanners',\n\t);\n\t\n\tprivate static $tables = array(\n\"wfAuditEvents\" => \"(\n  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,\n  `type` varchar(255) NOT NULL DEFAULT '',\n  `data` text NOT NULL,\n  `event_time` double(14,4) NOT NULL,\n  `request_id` bigint(20) unsigned NOT NULL,\n  `state` enum('new','sending','sent') NOT NULL DEFAULT 'new',\n  `state_timestamp` timestamp NOT NULL DEFAULT current_timestamp() ON UPDATE current_timestamp(),\n  PRIMARY KEY (`id`)\n) DEFAULT CHARSET=utf8\",\n\"wfSecurityEvents\" => \"(\n  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,\n  `type` varchar(255) NOT NULL DEFAULT '',\n  `data` text NOT NULL,\n  `event_time` double(14,4) NOT NULL,\n  `state` enum('new','sending','sent') NOT NULL DEFAULT 'new',\n  `state_timestamp` timestamp NOT NULL DEFAULT current_timestamp() ON UPDATE current_timestamp(),\n  PRIMARY KEY (`id`)\n) DEFAULT CHARSET=utf8\",\n\"wfBlocks7\" => \"(\n  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,\n  `type` int(10) unsigned NOT NULL DEFAULT '0',\n  `IP` binary(16) NOT NULL DEFAULT '\\\\\\0\\\\\\0\\\\\\0\\\\\\0\\\\\\0\\\\\\0\\\\\\0\\\\\\0\\\\\\0\\\\\\0\\\\\\0\\\\\\0\\\\\\0\\\\\\0\\\\\\0\\\\\\0',\n  `blockedTime` bigint(20) NOT NULL,\n  `reason` varchar(255) NOT NULL,\n  `lastAttempt` int(10) unsigned DEFAULT '0',\n  `blockedHits` int(10) unsigned DEFAULT '0',\n  `expiration` bigint(20) unsigned NOT NULL DEFAULT '0',\n  `parameters` text,\n  PRIMARY KEY (`id`),\n  KEY `type` (`type`),\n  KEY `IP` (`IP`),\n  KEY `expiration` (`expiration`)\n) DEFAULT CHARSET=utf8\",\n\"wfConfig\" => \"(\n  `name` varchar(100) NOT NULL,\n  `val` longblob,\n  `autoload` enum('no','yes') NOT NULL DEFAULT 'yes',\n  PRIMARY KEY (`name`)\n) DEFAULT CHARSET=utf8\",\n\"wfCrawlers\" => \"(\n  `IP` binary(16) NOT NULL DEFAULT '\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0',\n  `patternSig` binary(16) NOT NULL,\n  `status` char(8) NOT NULL,\n  `lastUpdate` int(10) unsigned NOT NULL,\n  `PTR` varchar(255) DEFAULT '',\n  PRIMARY KEY (`IP`,`patternSig`)\n) DEFAULT CHARSET=utf8\",\n\"wfFileChanges\" => \"(\n  `filenameHash` char(64) NOT NULL,\n  `file` varchar(1000) NOT NULL,\n  `md5` char(32) NOT NULL,\n  PRIMARY KEY (`filenameHash`)\n) CHARSET=utf8\",\n\"wfHits\" => \"(\n  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,\n  `attackLogTime` double(17,6) unsigned NOT NULL,\n  `ctime` double(17,6) unsigned NOT NULL,\n  `IP` binary(16) DEFAULT NULL,\n  `jsRun` tinyint(4) DEFAULT '0',\n  `statusCode` int(11) NOT NULL DEFAULT '200',\n  `isGoogle` tinyint(4) NOT NULL,\n  `userID` int(10) unsigned NOT NULL,\n  `newVisit` tinyint(3) unsigned NOT NULL,\n  `URL` text,\n  `referer` text,\n  `UA` text,\n  `action` varchar(64) NOT NULL DEFAULT '',\n  `actionDescription` text,\n  `actionData` text,\n  PRIMARY KEY (`id`),\n  KEY `k1` (`ctime`),\n  KEY `k2` (`IP`,`ctime`),\n  KEY `attackLogTime` (`attackLogTime`)\n) DEFAULT CHARSET=utf8\",\n\"wfIssues\" => \"(\n  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,\n  `time` int(10) unsigned NOT NULL,\n  `lastUpdated` int(10) unsigned NOT NULL,\n  `status` varchar(10) NOT NULL,\n  `type` varchar(20) NOT NULL,\n  `severity` tinyint(3) unsigned NOT NULL,\n  `ignoreP` char(32) NOT NULL,\n  `ignoreC` char(32) NOT NULL,\n  `shortMsg` varchar(255) NOT NULL,\n  `longMsg` text,\n  `data` text,\n  PRIMARY KEY (`id`),\n  KEY `lastUpdated` (`lastUpdated`),\n  KEY `status` (`status`),\n  KEY `ignoreP` (`ignoreP`),\n  KEY `ignoreC` (`ignoreC`)\n) DEFAULT CHARSET=utf8\",\n\"wfPendingIssues\" => \"(\n  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,\n  `time` int(10) unsigned NOT NULL,\n  `lastUpdated` int(10) unsigned NOT NULL,\n  `status` varchar(10) NOT NULL,\n  `type` varchar(20) NOT NULL,\n  `severity` tinyint(3) unsigned NOT NULL,\n  `ignoreP` char(32) NOT NULL,\n  `ignoreC` char(32) NOT NULL,\n  `shortMsg` varchar(255) NOT NULL,\n  `longMsg` text,\n  `data` text,\n  PRIMARY KEY (`id`),\n  KEY `lastUpdated` (`lastUpdated`),\n  KEY `status` (`status`),\n  KEY `ignoreP` (`ignoreP`),\n  KEY `ignoreC` (`ignoreC`)\n) DEFAULT CHARSET=utf8\",\n\"wfTrafficRates\" => \"(\n  `eMin` int(10) unsigned NOT NULL,\n  `IP` binary(16) NOT NULL DEFAULT '\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0',\n  `hitType` enum('hit','404') NOT NULL DEFAULT 'hit',\n  `hits` int(10) unsigned NOT NULL,\n  PRIMARY KEY (`eMin`,`IP`,`hitType`)\n) DEFAULT CHARSET=utf8\",\n\"wfLocs\" => \"(\n  `IP` binary(16) NOT NULL DEFAULT '\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0',\n  `ctime` int(10) unsigned NOT NULL,\n  `failed` tinyint(3) unsigned NOT NULL,\n  `city` varchar(255) DEFAULT '',\n  `region` varchar(255) DEFAULT '',\n  `countryName` varchar(255) DEFAULT '',\n  `countryCode` char(2) DEFAULT '',\n  `lat` float(10,7) DEFAULT '0.0000000',\n  `lon` float(10,7) DEFAULT '0.0000000',\n  PRIMARY KEY (`IP`)\n) DEFAULT CHARSET=utf8\",\n\"wfLogins\" => \"(\n  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,\n  `hitID` int(11) DEFAULT NULL,\n  `ctime` double(17,6) unsigned NOT NULL,\n  `fail` tinyint(3) unsigned NOT NULL,\n  `action` varchar(40) NOT NULL,\n  `username` varchar(255) NOT NULL,\n  `userID` int(10) unsigned NOT NULL,\n  `IP` binary(16) DEFAULT NULL,\n  `UA` text,\n  PRIMARY KEY (`id`),\n  KEY `k1` (`IP`,`fail`),\n  KEY `hitID` (`hitID`)\n) DEFAULT CHARSET=utf8\",\n\"wfReverseCache\" => \"(\n  `IP` binary(16) NOT NULL DEFAULT '\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0',\n  `host` varchar(255) NOT NULL,\n  `lastUpdate` int(10) unsigned NOT NULL,\n  PRIMARY KEY (`IP`)\n) DEFAULT CHARSET=utf8\",\n\"wfStatus\" => \"(\n  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,\n  `ctime` double(17,6) unsigned NOT NULL,\n  `level` tinyint(3) unsigned NOT NULL,\n  `type` char(5) NOT NULL,\n  `msg` varchar(1000) NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `k1` (`ctime`),\n  KEY `k2` (`type`)\n) DEFAULT CHARSET=utf8\",\n'wfHoover' => \"(\n  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,\n  `owner` text,\n  `host` text,\n  `path` text,\n  `hostKey` varbinary(124) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `k2` (`hostKey`)\n) DEFAULT CHARSET=utf8\",\n'wfFileMods' => \"(\n  `filenameMD5` binary(16) NOT NULL,\n  `filename` varchar(1000) NOT NULL,\n  `knownFile` tinyint(3) unsigned NOT NULL,\n  `oldMD5` binary(16) NOT NULL DEFAULT '',\n  `newMD5` binary(16) NOT NULL,\n  `SHAC` binary(32) NOT NULL DEFAULT '\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0',\n  `stoppedOnSignature` varchar(255) NOT NULL DEFAULT '',\n  `stoppedOnPosition` int(10) unsigned NOT NULL DEFAULT '0',\n  `isSafeFile` varchar(1) NOT NULL DEFAULT '?',\n  PRIMARY KEY (`filenameMD5`)\n) DEFAULT CHARSET=utf8\",\n'wfBlockedIPLog' => \"(\n  `IP` binary(16) NOT NULL DEFAULT '\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0',\n  `countryCode` varchar(2) NOT NULL,\n  `blockCount` int(10) unsigned NOT NULL DEFAULT '0',\n  `unixday` int(10) unsigned NOT NULL,\n  `blockType` varchar(50) NOT NULL DEFAULT 'generic',\n  PRIMARY KEY (`IP`,`unixday`,`blockType`)\n) DEFAULT CHARSET=utf8\",\n'wfSNIPCache' => \"(\n  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,\n  `IP` varchar(45) NOT NULL DEFAULT '',\n  `expiration` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  `body` varchar(255) NOT NULL DEFAULT '',\n  `count` int(10) unsigned NOT NULL DEFAULT '0',\n  `type` int(10) unsigned NOT NULL DEFAULT '0',\n  PRIMARY KEY (`id`),\n  KEY `expiration` (`expiration`),\n  KEY `IP` (`IP`),\n  KEY `type` (`type`)\n) DEFAULT CHARSET=utf8\",\n'wfKnownFileList' => \"(\n  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,\n  `path` text NOT NULL,\n  PRIMARY KEY (`id`)\n) DEFAULT CHARSET=utf8\",\n'wfNotifications' => \"(\n  `id` varchar(32) NOT NULL DEFAULT '',\n  `new` tinyint(3) unsigned NOT NULL DEFAULT '1',\n  `category` varchar(255) NOT NULL,\n  `priority` int(11) NOT NULL DEFAULT '1000',\n  `ctime` int(10) unsigned NOT NULL,\n  `html` text NOT NULL,\n  `links` text NOT NULL,\n  PRIMARY KEY (`id`)\n) DEFAULT CHARSET=utf8;\",\n'wfLiveTrafficHuman' => \"(\n  `IP` binary(16) NOT NULL DEFAULT '\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0',\n  `identifier` binary(32) NOT NULL DEFAULT '\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0',\n  `expiration` int(10) unsigned NOT NULL,\n  PRIMARY KEY (`IP`,`identifier`),\n  KEY `expiration` (`expiration`)\n) DEFAULT CHARSET=utf8;\",\n'wfWafFailures' => \"(\n  `id` INT(10) UNSIGNED AUTO_INCREMENT PRIMARY KEY,\n  `throwable` TEXT NOT NULL,\n  `rule_id` INT(10) UNSIGNED,\n  `timestamp` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP\n) DEFAULT CHARSET=utf8\"\n);\n\tprivate $db = false;\n\tpublic function __construct($dbhost = false, $dbuser = false, $dbpassword = false, $dbname = false){\n\t\t$this->db = new wfDB();\n\t}\n\tpublic function dropAll(){\n\t\tforeach(self::$tables as $table => $def) {\n\t\t\t$originalTable = wfDB::networkPrefix() . $table;\n\t\t\t$convertedTable = wfDB::networkPrefix() . strtolower($table);\n\t\t\t\n\t\t\t$this->db->queryWrite(\"DROP TABLE IF EXISTS {$convertedTable}\");\n\t\t\t$this->db->queryWrite(\"DROP TABLE IF EXISTS {$originalTable}\");\n\t\t}\n\t\t\n\t\tforeach (self::$deprecatedTables as $table) {\n\t\t\t$originalTable = wfDB::networkTable($table, false);\n\t\t\t$convertedTable = wfDB::networkTable($table);\n\t\t\t\n\t\t\t$this->db->queryWrite(\"DROP TABLE IF EXISTS {$convertedTable}\");\n\t\t\tif ($originalTable !== $convertedTable) {\n\t\t\t\t$this->db->queryWrite(\"DROP TABLE IF EXISTS {$originalTable}\");\n\t\t\t}\n\t\t}\n\t}\n\tpublic function createAll() {\n\t\tforeach(self::$tables as $table => $def){\n\t\t\t$this->db->queryWrite(\"CREATE TABLE IF NOT EXISTS \" . wfDB::networkTable($table) . \" \" . $def);\n\t\t}\n\t}\n\tpublic function create($table) {\n\t\t$this->db->queryWrite(\"CREATE TABLE IF NOT EXISTS \" . wfDB::networkTable($table) . \" \" . self::$tables[$table]);\n\t}\n\tpublic function drop($table) {\n\t\t$originalTable = wfDB::networkTable($table, false);\n\t\t$convertedTable = wfDB::networkTable($table);\n\t\t\n\t\t$this->db->queryWrite(\"DROP TABLE IF EXISTS {$convertedTable}\");\n\t\tif ($originalTable !== $convertedTable) {\n\t\t\t$this->db->queryWrite(\"DROP TABLE IF EXISTS {$originalTable}\");\n\t\t}\n\t}\n\t\n\tpublic static function tableList() {\n\t\treturn array_keys(self::$tables);\n\t}\n\t\n\tpublic static function updateTableCase() {\n\t\tglobal $wpdb;\n\t\t$hasCamelCaseTable = !!$wpdb->get_var($wpdb->prepare('SELECT TABLE_NAME FROM information_schema.TABLES WHERE TABLE_SCHEMA=DATABASE() AND TABLE_NAME=%s', wfDB::networkTable('wfConfig', false)));\n\t\tif (is_multisite() && function_exists('update_network_option')) {\n\t\t\tupdate_network_option(null, self::TABLE_CASE_OPTION, !$hasCamelCaseTable);\n\t\t\tself::$_usingLowercase = !$hasCamelCaseTable;\n\t\t}\n\t\telse {\n\t\t\tupdate_option(self::TABLE_CASE_OPTION, !$hasCamelCaseTable);\n\t\t\tself::$_usingLowercase = !$hasCamelCaseTable;\n\t\t}\n\t}\n\t\n\tpublic static function usingLowercase() {\n\t\tif (self::$_usingLowercase === null) {\n\t\t\tif (is_multisite() && function_exists('update_network_option')) {\n\t\t\t\tself::$_usingLowercase = !!get_network_option(null, self::TABLE_CASE_OPTION);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tself::$_usingLowercase = !!get_option(self::TABLE_CASE_OPTION);\n\t\t\t}\n\t\t}\n\t\treturn self::$_usingLowercase;\n\t}\n}"},{"base":"plugins","rel":"wordfence\/lib\/wfCentralAPI.php","ext":"php","size":26419,"mtime":1757312769,"type":"text","content":"<?php\n\nclass wfCentralAPIRequest {\n\t\/**\n\t * @var string\n\t *\/\n\tprivate $endpoint;\n\t\/**\n\t * @var string\n\t *\/\n\tprivate $method;\n\t\/**\n\t * @var null\n\t *\/\n\tprivate $token;\n\t\/**\n\t * @var array\n\t *\/\n\tprivate $body;\n\t\/**\n\t * @var array\n\t *\/\n\tprivate $args;\n\n\n\t\/**\n\t * @param string $endpoint\n\t * @param string $method\n\t * @param string|null $token\n\t * @param array $body\n\t * @param array $args\n\t *\/\n\tpublic function __construct($endpoint, $method = 'GET', $token = null, $body = array(), $args = array()) {\n\t\t$this->endpoint = $endpoint;\n\t\t$this->method = $method;\n\t\t$this->token = $token;\n\t\t$this->body = $body;\n\t\t$this->args = $args;\n\t}\n\t\n\t\/**\n\t * Handles an internal error when making a Central API request (e.g., a second sodium_compat library with an\n\t * incompatible interface loading instead or in addition to ours).\n\t * \n\t * @param Exception|Throwable $e\n\t *\/\n\tpublic static function handleInternalCentralAPIError($e) {\n\t\terror_log('Wordfence encountered an internal Central API error: ' . $e->getMessage());\n\t\terror_log('Wordfence stack trace: ' . $e->getTraceAsString());\n\t}\n\n\tpublic function execute($timeout = 10) {\n\t\t$args = array(\n\t\t\t'timeout' => $timeout,\n\t\t);\n\t\t$args = wp_parse_args($this->getArgs(), $args);\n\t\t$args['method'] = $this->getMethod();\n\t\tif (empty($args['headers'])) {\n\t\t\t$args['headers'] = array();\n\t\t}\n\n\t\t$token = $this->getToken();\n\t\tif ($token) {\n\t\t\t$args['headers']['Authorization'] = 'Bearer ' . $token;\n\t\t}\n\t\tif ($this->getBody()) {\n\t\t\t$args['headers']['Content-Type'] = 'application\/json';\n\t\t\t$args['body'] = json_encode($this->getBody());\n\t\t}\n\n\t\t$http = _wp_http_get_object();\n\t\t$response = $http->request(WORDFENCE_CENTRAL_API_URL_SEC . $this->getEndpoint(), $args);\n\n\t\tif (!is_wp_error($response)) {\n\t\t\t$body = wp_remote_retrieve_body($response);\n\t\t\t$statusCode = wp_remote_retrieve_response_code($response);\n\n\t\t\t\/\/ Check if site has been disconnected on Central's end, but the plugin is still trying to connect.\n\t\t\tif ($statusCode === 404 && strpos($body, 'Site has been disconnected') !== false) {\n\t\t\t\t\/\/ Increment attempt count.\n\t\t\t\t$centralDisconnectCount = (int) get_site_transient('wordfenceCentralDisconnectCount');\n\t\t\t\tset_site_transient('wordfenceCentralDisconnectCount', ++$centralDisconnectCount, 86400);\n\n\t\t\t\t\/\/ Once threshold is hit, disconnect Central.\n\t\t\t\tif ($centralDisconnectCount > 3) {\n\t\t\t\t\twfRESTConfigController::disconnectConfig(wfRESTConfigController::WF_CENTRAL_FAILURE_MARKER);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new wfCentralAPIResponse($response);\n\t}\n\n\t\/**\n\t * @return string\n\t *\/\n\tpublic function getEndpoint() {\n\t\treturn $this->endpoint;\n\t}\n\n\t\/**\n\t * @param string $endpoint\n\t *\/\n\tpublic function setEndpoint($endpoint) {\n\t\t$this->endpoint = $endpoint;\n\t}\n\n\t\/**\n\t * @return string\n\t *\/\n\tpublic function getMethod() {\n\t\treturn $this->method;\n\t}\n\n\t\/**\n\t * @param string $method\n\t *\/\n\tpublic function setMethod($method) {\n\t\t$this->method = $method;\n\t}\n\n\t\/**\n\t * @return null\n\t *\/\n\tpublic function getToken() {\n\t\treturn $this->token;\n\t}\n\n\t\/**\n\t * @param null $token\n\t *\/\n\tpublic function setToken($token) {\n\t\t$this->token = $token;\n\t}\n\n\t\/**\n\t * @return array\n\t *\/\n\tpublic function getBody() {\n\t\treturn $this->body;\n\t}\n\n\t\/**\n\t * @param array $body\n\t *\/\n\tpublic function setBody($body) {\n\t\t$this->body = $body;\n\t}\n\n\t\/**\n\t * @return array\n\t *\/\n\tpublic function getArgs() {\n\t\treturn $this->args;\n\t}\n\n\t\/**\n\t * @param array $args\n\t *\/\n\tpublic function setArgs($args) {\n\t\t$this->args = $args;\n\t}\n}\n\nclass wfCentralAPIResponse {\n\n\tpublic static function parseErrorJSON($json) {\n\t\t$data = json_decode($json, true);\n\t\tif (is_array($data) && array_key_exists('message', $data)) {\n\t\t\treturn $data['message'];\n\t\t}\n\t\treturn $json;\n\t}\n\n\t\/**\n\t * @var array|null\n\t *\/\n\tprivate $response;\n\n\t\/**\n\t * @param array $response\n\t *\/\n\tpublic function __construct($response = null) {\n\t\t$this->response = $response;\n\t}\n\n\tpublic function getStatusCode() {\n\t\treturn wp_remote_retrieve_response_code($this->getResponse());\n\t}\n\n\tpublic function getBody() {\n\t\treturn wp_remote_retrieve_body($this->getResponse());\n\t}\n\n\tpublic function getJSONBody() {\n\t\treturn json_decode($this->getBody(), true);\n\t}\n\n\tpublic function isError() {\n\t\tif (is_wp_error($this->getResponse())) {\n\t\t\treturn true;\n\t\t}\n\t\t$statusCode = $this->getStatusCode();\n\t\treturn !($statusCode >= 200 && $statusCode < 300);\n\t}\n\n\tpublic function returnErrorArray() {\n\t\treturn array(\n\t\t\t'err'      => 1,\n\t\t\t'errorMsg' => sprintf(\n\t\t\t\t\/* translators: 1. HTTP status code. 2. Error message. *\/\n\t\t\t\t__('HTTP %1$d received from Wordfence Central: %2$s', 'wordfence'),\n\t\t\t\t$this->getStatusCode(), $this->parseErrorJSON($this->getBody())),\n\t\t);\n\t}\n\n\t\/**\n\t * @return array|null\n\t *\/\n\tpublic function getResponse() {\n\t\treturn $this->response;\n\t}\n\n\t\/**\n\t * @param array|null $response\n\t *\/\n\tpublic function setResponse($response) {\n\t\t$this->response = $response;\n\t}\n}\n\n\nclass wfCentralAuthenticatedAPIRequest extends wfCentralAPIRequest {\n\n\tprivate $retries = 3;\n\n\t\/**\n\t * @param string $endpoint\n\t * @param string $method\n\t * @param array $body\n\t * @param array $args\n\t *\/\n\tpublic function __construct($endpoint, $method = 'GET', $body = array(), $args = array()) {\n\t\tparent::__construct($endpoint, $method, null, $body, $args);\n\t}\n\n\t\/**\n\t * @return mixed|null\n\t * @throws wfCentralAPIException\n\t *\/\n\tpublic function getToken() {\n\t\t$token = parent::getToken();\n\t\tif ($token) {\n\t\t\treturn $token;\n\t\t}\n\n\t\t$token = get_transient('wordfenceCentralJWT' . wfConfig::get('wordfenceCentralSiteID'));\n\t\tif ($token) {\n\t\t\treturn $token;\n\t\t}\n\n\t\tfor ($i = 0; $i < $this->retries; $i++) {\n\t\t\ttry {\n\t\t\t\t$token = $this->fetchToken();\n\t\t\t\tbreak;\n\t\t\t} catch (wfCentralConfigurationException $e) {\n\t\t\t\twfConfig::set('wordfenceCentralConfigurationIssue', true);\n\t\t\t\tthrow new wfCentralAPIException(__('Fetching token for Wordfence Central authentication due to configuration issue.', 'wordfence'));\n\t\t\t} catch (wfCentralAPIException $e) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (empty($token)) {  \n\t\t\tif (isset($e)) {\n\t\t\t\tthrow $e;\n\t\t\t} else {\n\t\t\t\tthrow new wfCentralAPIException(__('Unable to authenticate with Wordfence Central.', 'wordfence'));\n\t\t\t}\n\t\t}\n\t\t$tokenContents = wfJWT::extractTokenContents($token);\n\n\t\tif (!empty($tokenContents['body']['exp'])) {\n\t\t\tset_transient('wordfenceCentralJWT' . wfConfig::get('wordfenceCentralSiteID'), $token, $tokenContents['body']['exp'] - time());\n\t\t}\n\t\twfConfig::set('wordfenceCentralConfigurationIssue', false);\n\t\treturn $token;\n\t}\n\n\tpublic function fetchToken() {\n\t\trequire_once(WORDFENCE_PATH . '\/lib\/sodium_compat_fast.php');\n\n\t\t$defaultArgs = array(\n\t\t\t'timeout' => 6,\n\t\t);\n\t\t$siteID = wfConfig::get('wordfenceCentralSiteID');\n\t\tif (!$siteID) {\n\t\t\tthrow new wfCentralAPIException(__('Wordfence Central site ID has not been created yet.', 'wordfence'));\n\t\t}\n\t\t$secretKey = wfConfig::get('wordfenceCentralSecretKey');\n\t\tif (!$secretKey) {\n\t\t\tthrow new wfCentralAPIException(__('Wordfence Central secret key has not been created yet.', 'wordfence'));\n\t\t}\n\n\t\t\/\/ Pull down nonce.\n\t\t$request = new wfCentralAPIRequest(sprintf('\/site\/%s\/login', $siteID), 'GET', null, array(), $defaultArgs);\n\t\t$nonceResponse = $request->execute();\n\t\tif ($nonceResponse->isError()) {\n\t\t\t$errorArray = $nonceResponse->returnErrorArray();\n\t\t\tthrow new wfCentralAPIException($errorArray['errorMsg']);\n\t\t}\n\t\t$body = $nonceResponse->getJSONBody();\n\t\tif (!is_array($body) || !isset($body['nonce'])) {\n\t\t\tthrow new wfCentralAPIException(__('Invalid response received from Wordfence Central when fetching nonce.', 'wordfence'));\n\t\t}\n\t\t$nonce = $body['nonce'];\n\n\t\t\/\/ Sign nonce to pull down JWT.\n\t\t$data = $nonce . '|' . $siteID;\n\t\ttry {\n\t\t\t$signature = ParagonIE_Sodium_Compat::crypto_sign_detached($data, $secretKey);\n\t\t}\n\t\tcatch (SodiumException $e) {\n\t\t\tthrow new wfCentralConfigurationException('Signing failed, likely due to malformed secret key', $e);\n\t\t}\n\t\t$request = new wfCentralAPIRequest(sprintf('\/site\/%s\/login', $siteID), 'POST', null, array(\n\t\t\t'data'      => $data,\n\t\t\t'signature' => ParagonIE_Sodium_Compat::bin2hex($signature),\n\t\t), $defaultArgs);\n\t\t$authResponse = $request->execute();\n\t\tif ($authResponse->isError()) {\n\t\t\t$errorArray = $authResponse->returnErrorArray();\n\t\t\tthrow new wfCentralAPIException($errorArray['errorMsg']);\n\t\t}\n\t\t$body = $authResponse->getJSONBody();\n\t\tif (!is_array($body)) {\n\t\t\tthrow new wfCentralAPIException(__('Invalid response received from Wordfence Central when fetching token.', 'wordfence'));\n\t\t}\n\t\tif (!isset($body['jwt'])) { \/\/ Possible authentication error.\n\t\t\tthrow new wfCentralAPIException(__('Unable to authenticate with Wordfence Central.', 'wordfence'));\n\t\t}\n\t\treturn $body['jwt'];\n\t}\n}\n\nclass wfCentralAPIException extends Exception {\n\n}\n\nclass wfCentralConfigurationException extends RuntimeException {\n\n\tpublic function __construct($message, $previous = null) {\n\t\tparent::__construct($message, 0, $previous);\n\t}\n\n}\n\nclass wfCentral {\n\n\t\/**\n\t * @return bool\n\t *\/\n\tpublic static function isSupported() {\n\t\treturn function_exists('register_rest_route') && version_compare(phpversion(), '5.3', '>=');\n\t}\n\n\t\/**\n\t * @return bool\n\t *\/\n\tpublic static function isConnected() {\n\t\treturn self::isSupported() && ((bool) self::_isConnected());\n\t}\n\n\t\/**\n\t * @return bool\n\t *\/\n\tpublic static function isPartialConnection() {\n\t\treturn !self::_isConnected() && wfConfig::get('wordfenceCentralSiteID');\n\t}\n\n\tpublic static function _isConnected($forceUpdate = false) {\n\t\tstatic $isConnected;\n\t\tif (!isset($isConnected) || $forceUpdate) {\n\t\t\t$isConnected = wfConfig::get('wordfenceCentralConnected', false);\n\t\t}\n\t\treturn $isConnected;\n\t}\n\n\t\/**\n\t * @param array $issue\n\t * @return bool|wfCentralAPIResponse\n\t *\/\n\tpublic static function sendIssue($issue) {\n\t\treturn self::sendIssues(array($issue));\n\t}\n\n\t\/**\n\t * @param $issues\n\t * @return bool|wfCentralAPIResponse\n\t *\/\n\tpublic static function sendIssues($issues) {\n\t\t$data = array();\n\t\tforeach ($issues as $issue) {\n\t\t\t$issueData = array(\n\t\t\t\t'type'       => 'issue',\n\t\t\t\t'attributes' => $issue,\n\t\t\t);\n\t\t\tif (array_key_exists('id', $issueData)) {\n\t\t\t\t$issueData['id'] = $issue['id'];\n\t\t\t}\n\t\t\t$data[] = $issueData;\n\t\t}\n\n\t\t$siteID = wfConfig::get('wordfenceCentralSiteID');\n\t\t$request = new wfCentralAuthenticatedAPIRequest('\/site\/' . $siteID . '\/issues', 'POST', array(\n\t\t\t'data' => $data,\n\t\t));\n\t\ttry {\n\t\t\t$response = $request->execute();\n\t\t\treturn $response;\n\t\t}\n\t\tcatch (wfCentralAPIException $e) {\n\t\t\terror_log($e);\n\t\t}\n\t\tcatch (Exception $e) {\n\t\t\twfCentralAPIRequest::handleInternalCentralAPIError($e);\n\t\t}\n\t\tcatch (Throwable $t) {\n\t\t\twfCentralAPIRequest::handleInternalCentralAPIError($t);\n\t\t}\n\t\treturn false;\n\t}\n\n\t\/**\n\t * @param int $issueID\n\t * @return bool|wfCentralAPIResponse\n\t *\/\n\tpublic static function deleteIssue($issueID) {\n\t\treturn self::deleteIssues(array($issueID));\n\t}\n\n\t\/**\n\t * @param $issues\n\t * @return bool|wfCentralAPIResponse\n\t *\/\n\tpublic static function deleteIssues($issues) {\n\t\tif (empty($issues)) { return true; }\n\t\t$siteID = wfConfig::get('wordfenceCentralSiteID');\n\t\t$request = new wfCentralAuthenticatedAPIRequest('\/site\/' . $siteID . '\/issues', 'DELETE', array(\n\t\t\t'data' => array(\n\t\t\t\t'type'       => 'issue-list',\n\t\t\t\t'attributes' => array(\n\t\t\t\t\t'ids' => $issues,\n\t\t\t\t)\n\t\t\t),\n\t\t));\n\t\ttry {\n\t\t\t$response = $request->execute();\n\t\t\treturn $response;\n\t\t}\n\t\tcatch (wfCentralAPIException $e) {\n\t\t\terror_log($e);\n\t\t}\n\t\tcatch (Exception $e) {\n\t\t\twfCentralAPIRequest::handleInternalCentralAPIError($e);\n\t\t}\n\t\tcatch (Throwable $t) {\n\t\t\twfCentralAPIRequest::handleInternalCentralAPIError($t);\n\t\t}\n\t\treturn false;\n\t}\n\n\t\/**\n\t * @return bool|wfCentralAPIResponse\n\t *\/\n\tpublic static function deleteNewIssues() {\n\t\t$siteID = wfConfig::get('wordfenceCentralSiteID');\n\t\t$request = new wfCentralAuthenticatedAPIRequest('\/site\/' . $siteID . '\/issues', 'DELETE', array(\n\t\t\t'data' => array(\n\t\t\t\t'type'       => 'issue-list',\n\t\t\t\t'attributes' => array(\n\t\t\t\t\t'status' => 'new',\n\t\t\t\t)\n\t\t\t),\n\t\t));\n\t\ttry {\n\t\t\t$response = $request->execute();\n\t\t\treturn $response;\n\t\t}\n\t\tcatch (wfCentralAPIException $e) {\n\t\t\terror_log($e);\n\t\t}\n\t\tcatch (Exception $e) {\n\t\t\twfCentralAPIRequest::handleInternalCentralAPIError($e);\n\t\t}\n\t\tcatch (Throwable $t) {\n\t\t\twfCentralAPIRequest::handleInternalCentralAPIError($t);\n\t\t}\n\t\treturn false;\n\t}\n\n\t\/**\n\t * @param array $types Array of issue types to delete\n\t * @param string $status Issue status to delete\n\t * @return bool|wfCentralAPIResponse\n\t *\/\n\tpublic static function deleteIssueTypes($types, $status = 'new') {\n\t\t$siteID = wfConfig::get('wordfenceCentralSiteID');\n\t\t$request = new wfCentralAuthenticatedAPIRequest('\/site\/' . $siteID . '\/issues', 'DELETE', array(\n\t\t\t'data' => array(\n\t\t\t\t'type'       => 'issue-list',\n\t\t\t\t'attributes' => array(\n\t\t\t\t\t'types' => $types,\n\t\t\t\t\t'status' => $status,\n\t\t\t\t)\n\t\t\t),\n\t\t));\n\t\ttry {\n\t\t\t$response = $request->execute();\n\t\t\treturn $response;\n\t\t}\n\t\tcatch (wfCentralAPIException $e) {\n\t\t\terror_log($e);\n\t\t}\n\t\tcatch (Exception $e) {\n\t\t\twfCentralAPIRequest::handleInternalCentralAPIError($e);\n\t\t}\n\t\tcatch (Throwable $t) {\n\t\t\twfCentralAPIRequest::handleInternalCentralAPIError($t);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static function requestConfigurationSync() {\n\t\tif (! wfCentral::isConnected() || !self::$syncConfig) {\n\t\t\treturn;\n\t\t}\n\n\t\t$endpoint = '\/site\/'.wfConfig::get('wordfenceCentralSiteID').'\/config';\n\t\t$args = array('timeout' => 0.01, 'blocking'  => false);\n\t\t$request = new wfCentralAuthenticatedAPIRequest($endpoint, 'POST', array(), $args);\n\n\t\ttry {\n\t\t\t$request->execute();\n\t\t}\n\t\tcatch (Exception $e) {\n\t\t\t\/\/ We can safely ignore an error here for now.\n\t\t}\n\t\tcatch (Throwable $t) {\n\t\t\twfCentralAPIRequest::handleInternalCentralAPIError($t);\n\t\t}\n\t}\n\n\tprotected static $syncConfig = true;\n\n\tpublic static function preventConfigurationSync() {\n\t\tself::$syncConfig = false;\n\t}\n\n\t\/**\n\t * @param $scan\n\t * @param $running\n\t * @return bool|wfCentralAPIResponse\n\t *\/\n\tpublic static function updateScanStatus($scan = null) {\n\t\tif ($scan === null) {\n\t\t\t$scan = wfConfig::get_ser('scanStageStatuses');\n\t\t\tif (!is_array($scan)) {\n\t\t\t\t$scan = array();\n\t\t\t}\n\t\t}\n\t\t\n\t\twfScanner::shared()->flushSummaryItems();\n\n\t\t$siteID = wfConfig::get('wordfenceCentralSiteID');\n\t\t$running = wfScanner::shared()->isRunning();\n\t\t$request = new wfCentralAuthenticatedAPIRequest('\/site\/' . $siteID . '\/scan', 'PATCH', array(\n\t\t\t'data' => array(\n\t\t\t\t'type'       => 'scan',\n\t\t\t\t'attributes' => array(\n\t\t\t\t\t'running'      => $running,\n\t\t\t\t\t'scan'         => $scan,\n\t\t\t\t\t'scan-summary' => wfConfig::get('wf_summaryItems'),\n\t\t\t\t),\n\t\t\t),\n\t\t));\n\t\ttry {\n\t\t\t$response = $request->execute();\n\t\t\twfConfig::set('lastScanStageStatusUpdate', time(), wfConfig::DONT_AUTOLOAD);\n\t\t\treturn $response;\n\t\t}\n\t\tcatch (wfCentralAPIException $e) {\n\t\t\terror_log($e);\n\t\t}\n\t\tcatch (Exception $e) {\n\t\t\twfCentralAPIRequest::handleInternalCentralAPIError($e);\n\t\t}\n\t\tcatch (Throwable $t) {\n\t\t\twfCentralAPIRequest::handleInternalCentralAPIError($t);\n\t\t}\n\t\treturn false;\n\t}\n\n\t\/**\n\t * @param string $event\n\t * @param array $data\n\t * @param callable|null $alertCallback\n\t *\/\n\tpublic static function sendSecurityEvent($event, $data = array(), $alertCallback = null, $sendImmediately = false) {\n\t\treturn self::sendSecurityEvents(array(array('type' => $event, 'data' => $data, 'event_time' => microtime(true))), $alertCallback, $sendImmediately);\n\t}\n\t\n\tpublic static function sendSecurityEvents($events, $alertCallback = null, $sendImmediately = false) {\n\t\tif (empty($events)) {\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif (!$sendImmediately && defined('DISABLE_WP_CRON') && DISABLE_WP_CRON) {\n\t\t\t$sendImmediately = true;\n\t\t}\n\t\t\n\t\t$alerted = false;\n\t\tif (!self::pluginAlertingDisabled() && is_callable($alertCallback)) {\n\t\t\tcall_user_func($alertCallback);\n\t\t\t$alerted = true;\n\t\t}\n\t\t\n\t\tif ($sendImmediately) {\n\t\t\t$payload = array();\n\t\t\tforeach ($events as $e) {\n\t\t\t\t$payload[] = array(\n\t\t\t\t\t'type' => 'security-event',\n\t\t\t\t\t'attributes' => array(\n\t\t\t\t\t\t'type' => $e['type'],\n\t\t\t\t\t\t'data' => $e['data'],\n\t\t\t\t\t\t'event_time' => $e['event_time'],\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\t\t\t\n\t\t\t$siteID = wfConfig::get('wordfenceCentralSiteID');\n\t\t\t$request = new wfCentralAuthenticatedAPIRequest('\/site\/' . $siteID . '\/security-events', 'POST', array(\n\t\t\t\t'data' => $payload,\n\t\t\t));\n\t\t\ttry {\n\t\t\t\t\/\/ Attempt to send the security events to Central.\n\t\t\t\t$doing_cron = function_exists('wp_doing_cron') \/* WP >= 4.8 *\/ ? wp_doing_cron() : (defined('DOING_CRON') && DOING_CRON);\n\t\t\t\t$response = $request->execute($doing_cron ? 10 : 3);\n\t\t\t}\n\t\t\tcatch (wfCentralAPIException $e) {\n\t\t\t\t\/\/ If we didn't alert previously, notify the user now in the event Central is down.\n\t\t\t\tif (!$alerted && is_callable($alertCallback)) {\n\t\t\t\t\tcall_user_func($alertCallback);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcatch (Exception $e) {\n\t\t\t\twfCentralAPIRequest::handleInternalCentralAPIError($e);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcatch (Throwable $t) {\n\t\t\t\twfCentralAPIRequest::handleInternalCentralAPIError($t);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t$wfdb = new wfDB();\n\t\t\t$table_wfSecurityEvents = wfDB::networkTable('wfSecurityEvents');\n\t\t\t$query = \"INSERT INTO {$table_wfSecurityEvents} (`type`, `data`, `event_time`, `state`, `state_timestamp`) VALUES \";\n\t\t\t$query .= implode(', ', array_fill(0, count($events), \"('%s', '%s', %f, 'new', NOW())\"));\n\t\t\t\n\t\t\t$immediateSendTypes = array('adminLogin',\n\t\t\t\t\t\t\t\t\t\t'adminLoginNewLocation',\n\t\t\t\t\t\t\t\t\t\t'nonAdminLogin',\n\t\t\t\t\t\t\t\t\t\t'nonAdminLoginNewLocation',\n\t\t\t\t\t\t\t\t\t\t'wordfenceDeactivated',\n\t\t\t\t\t\t\t\t\t\t'wafDeactivated',\n\t\t\t\t\t\t\t\t\t\t'autoUpdate');\n\t\t\t$args = array();\n\t\t\tforeach ($events as $e) {\n\t\t\t\t$sendImmediately = $sendImmediately || in_array($e['type'], $immediateSendTypes);\n\t\t\t\t$args[] = $e['type'];\n\t\t\t\t$args[] = json_encode($e['data']);\n\t\t\t\t$args[] = $e['event_time'];\n\t\t\t}\n\t\t\t$wfdb->queryWriteArray($query, $args);\n\t\t\t\n\t\t\tif (($ts = self::isScheduledSecurityEventCronOverdue()) || $sendImmediately) {\n\t\t\t\tif ($ts) {\n\t\t\t\t\tself::unscheduleSendPendingSecurityEvents($ts);\n\t\t\t\t}\n\t\t\t\tself::sendPendingSecurityEvents();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tself::scheduleSendPendingSecurityEvents();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static function sendPendingSecurityEvents() {\n\t\t$wfdb = new wfDB();\n\t\t$table_wfSecurityEvents = wfDB::networkTable('wfSecurityEvents');\n\t\t\n\t\t$rawEvents = $wfdb->querySelect(\"SELECT * FROM {$table_wfSecurityEvents} WHERE `state` = 'new' ORDER BY `id` ASC LIMIT 100\");\n\n\t\tif (empty($rawEvents))\n\t\t\treturn;\n\n\t\t$ids = array();\n\t\t$events = array();\n\t\tforeach ($rawEvents as $r) {\n\t\t\t$ids[] = intval($r['id']);\n\t\t\t$events[] = array(\n\t\t\t\t'type' => $r['type'],\n\t\t\t\t'data' => json_decode($r['data'], true),\n\t\t\t\t'event_time' => $r['event_time'],\n\t\t\t);\n\t\t}\n\t\t\n\t\t$idParam = '(' . implode(', ', $ids) . ')';\n\t\t$wfdb->queryWrite(\"UPDATE {$table_wfSecurityEvents} SET `state` = 'sending', `state_timestamp` = NOW() WHERE `id` IN {$idParam}\");\n\t\tif (self::sendSecurityEvents($events, null, true)) {\n\t\t\t$wfdb->queryWrite(\"UPDATE {$table_wfSecurityEvents} SET `state` = 'sent', `state_timestamp` = NOW() WHERE `id` IN {$idParam}\");\n\t\t\t\n\t\t\tself::checkForUnsentSecurityEvents();\n\t\t}\n\t\telse {\n\t\t\t$wfdb->queryWrite(\"UPDATE {$table_wfSecurityEvents} SET `state` = 'new', `state_timestamp` = NOW() WHERE `id` IN {$idParam}\");\n\t\t\tself::scheduleSendPendingSecurityEvents();\n\t\t}\n\t}\n\t\n\tpublic static function scheduleSendPendingSecurityEvents() {\n\t\tif (!defined('DONOTCACHEDB')) { define('DONOTCACHEDB', true); }\n\t\t$notMainSite = is_multisite() && !is_main_site();\n\t\tif ($notMainSite) {\n\t\t\tglobal $current_site;\n\t\t\tswitch_to_blog($current_site->blog_id);\n\t\t}\n\t\tif (!wp_next_scheduled('wordfence_batchSendSecurityEvents')) {\n\t\t\twp_schedule_single_event(time() + 300, 'wordfence_batchSendSecurityEvents');\n\t\t}\n\t\tif ($notMainSite) {\n\t\t\trestore_current_blog();\n\t\t}\n\t}\n\t\n\tpublic static function unscheduleSendPendingSecurityEvents($timestamp) {\n\t\tif (!defined('DONOTCACHEDB')) { define('DONOTCACHEDB', true); }\n\t\t$notMainSite = is_multisite() && !is_main_site();\n\t\tif ($notMainSite) {\n\t\t\tglobal $current_site;\n\t\t\tswitch_to_blog($current_site->blog_id);\n\t\t}\n\t\tif (!wp_next_scheduled('wordfence_batchSendSecurityEvents')) {\n\t\t\twp_unschedule_event($timestamp, 'wordfence_batchSendSecurityEvents');\n\t\t}\n\t\tif ($notMainSite) {\n\t\t\trestore_current_blog();\n\t\t}\n\t}\n\t\n\tpublic static function isScheduledSecurityEventCronOverdue() {\n\t\tif (!defined('DONOTCACHEDB')) { define('DONOTCACHEDB', true); }\n\t\t$notMainSite = is_multisite() && !is_main_site();\n\t\tif ($notMainSite) {\n\t\t\tglobal $current_site;\n\t\t\tswitch_to_blog($current_site->blog_id);\n\t\t}\n\t\t\n\t\t$overdue = false;\n\t\tif ($ts = wp_next_scheduled('wordfence_batchSendSecurityEvents')) {\n\t\t\tif ((time() - $ts) > 900) {\n\t\t\t\t$overdue = $ts;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif ($notMainSite) {\n\t\t\trestore_current_blog();\n\t\t}\n\t\t\n\t\treturn $overdue;\n\t}\n\t\n\tpublic static function checkForUnsentSecurityEvents() {\n\t\t$wfdb = new wfDB();\n\t\t$table_wfSecurityEvents = wfDB::networkTable('wfSecurityEvents');\n\t\t$wfdb->queryWrite(\"UPDATE {$table_wfSecurityEvents} SET `state` = 'new', `state_timestamp` = NOW() WHERE `state` = 'sending' AND `state_timestamp` < DATE_SUB(NOW(), INTERVAL 30 MINUTE)\");\n\t\t\n\t\t$count = $wfdb->querySingle(\"SELECT COUNT(*) AS cnt FROM {$table_wfSecurityEvents} WHERE `state` = 'new'\");\n\t\tif ($count) {\n\t\t\tself::scheduleSendPendingSecurityEvents();\n\t\t}\n\t}\n\t\n\tpublic static function trimSecurityEvents() {\n\t\t$wfdb = new wfDB();\n\t\t$table_wfSecurityEvents = wfDB::networkTable('wfSecurityEvents');\n\t\t$count = $wfdb->querySingle(\"SELECT COUNT(*) AS cnt FROM {$table_wfSecurityEvents}\");\n\t\tif ($count > 20000) {\n\t\t\t$wfdb->truncate($table_wfSecurityEvents); \/\/Similar behavior to other logged data, assume possible DoS so truncate\n\t\t}\n\t\telse if ($count > 1000) {\n\t\t\t$wfdb->queryWrite(\"DELETE FROM {$table_wfSecurityEvents} ORDER BY id ASC LIMIT %d\", $count - 1000);\n\t\t}\n\t}\n\n\t\/**\n\t * @param $event\n\t * @param array $data\n\t * @param callable|null $alertCallback\n\t *\/\n\tpublic static function sendAlertCallback($event, $data = array(), $alertCallback = null) {\n\t\tif (is_callable($alertCallback)) {\n\t\t\tcall_user_func($alertCallback);\n\t\t}\n\t}\n\n\tpublic static function pluginAlertingDisabled() {\n\t\tif (!self::isConnected()) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn wfConfig::get('wordfenceCentralPluginAlertingDisabled', false);\n\t}\n\t\n\t\/**\n\t * Returns the site URL as associated with this site's Central linking.\n\t * \n\t * The return value may be:\n\t *  - null if there is no `site-url` key present in the stored Central data\n\t *  - a string if there is a `site-url` value\n\t * \n\t * @return string|null\n\t *\/\n\tpublic static function getCentralSiteUrl() {\n\t\t$siteData = json_decode(wfConfig::get('wordfenceCentralSiteData', '[]'), true);\n\t\treturn (is_array($siteData) && array_key_exists('site-url', $siteData)) ? (string) $siteData['site-url'] : null;\n\t}\n\t\n\t\/**\n\t * Populates the Central record's site data if missing or incomplete locally.\n\t * \n\t * @return array|bool\n\t *\/\n\tpublic static function populateCentralSiteData() {\n\t\tif (!wfCentral::_isConnected()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t$siteData = json_decode(wfConfig::get('wordfenceCentralSiteData', '[]'), true);\n\t\tif (!is_array($siteData) || !array_key_exists('site-url', $siteData) || !array_key_exists('audit-log-url', $siteData)) {\n\t\t\ttry {\n\t\t\t\t$request = new wfCentralAuthenticatedAPIRequest('\/site\/' . wfConfig::get('wordfenceCentralSiteID'), 'GET', array(), array('timeout' => 2));\n\t\t\t\t$response = $request->execute();\n\t\t\t\tif ($response->isError()) {\n\t\t\t\t\treturn $response->returnErrorArray();\n\t\t\t\t}\n\t\t\t\t$responseData = $response->getJSONBody();\n\t\t\t\tif (is_array($responseData) && isset($responseData['data']['attributes'])) {\n\t\t\t\t\t$siteData = $responseData['data']['attributes'];\n\t\t\t\t\twfConfig::set('wordfenceCentralSiteData', json_encode($siteData));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (wfCentralAPIException $e) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcatch (Exception $e) {\n\t\t\t\twfCentralAPIRequest::handleInternalCentralAPIError($e);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcatch (Throwable $t) {\n\t\t\t\twfCentralAPIRequest::handleInternalCentralAPIError($t);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static function isCentralSiteUrlMismatched() {\n\t\tif (!wfCentral::_isConnected()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t$centralSiteUrl = self::getCentralSiteUrl();\n\t\tif (!is_string($centralSiteUrl)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t$localSiteUrl = get_site_url();\n\t\treturn !wfUtils::compareSiteUrls($centralSiteUrl, $localSiteUrl, array('www'));\n\t}\n\t\n\tpublic static function mismatchedCentralUrlNotice() {\n\t\techo '<div id=\"wordfenceMismatchedCentralUrlNotice\" class=\"fade notice notice-warning\"><p><strong>' .\n\t\t\t__('Your site is currently linked to Wordfence Central under a different site URL.', 'wordfence')\n\t\t\t. '<\/strong> '\n\t\t\t. __('This may cause duplicated scan issues if both sites are currently active and reporting and is generally caused by duplicating the database from one site to another (e.g., from a production site to staging). We recommend disconnecting this site only, which will leave the matching site still connected.', 'wordfence')\n\t\t\t. '<\/p><p>'\n\t\t\t. __('If this is a single site with multiple domains or subdomains, you can dismiss this message.', 'wordfence')\n\t\t\t. '<\/p><p>'\n\t\t\t. '<a class=\"wf-btn wf-btn-primary wf-btn-sm wf-dismiss-link\" href=\"#\" onclick=\"wordfenceExt.centralUrlMismatchChoice(\\'local\\'); return false;\" role=\"button\">' .\n\t\t\t__('Disconnect This Site', 'wordfence')\n\t\t\t. '<\/a> '\n\t\t\t. '<a class=\"wf-btn wf-btn-default wf-btn-sm wf-dismiss-link\" href=\"#\" onclick=\"wordfenceExt.centralUrlMismatchChoice(\\'global\\'); return false;\" role=\"button\">' .\n\t\t\t__('Disconnect All', 'wordfence')\n\t\t\t. '<\/a> '\n\t\t\t. '<a class=\"wf-btn wf-btn-default wf-btn-sm wf-dismiss-link\" href=\"#\" onclick=\"wordfenceExt.centralUrlMismatchChoice(\\'dismiss\\'); return false;\" role=\"button\">' .\n\t\t\t__('Dismiss', 'wordfence')\n\t\t\t. '<\/a> '\n\t\t\t. '<a class=\"wfhelp\" target=\"_blank\" rel=\"noopener noreferrer\" href=\"' . wfSupportController::esc_supportURL(wfSupportController::ITEM_DIAGNOSTICS_REMOVE_CENTRAL_DATA) . '\"><span class=\"screen-reader-text\"> (' . esc_html__('opens in new tab', 'wordfence') . ')<\/span><\/a><\/p><\/div>';\n\t}\n\t\n\t\/**\n\t * Returns the audit log URL for this site in Wordfence Central.\n\t *\n\t * The return value may be:\n\t *  - null if there is no `audit-log-url` key present in the stored Central data\n\t *  - a string if there is a `audit-log-url` value\n\t *\n\t * @return string|null\n\t *\/\n\tpublic static function getCentralAuditLogUrl() {\n\t\t$siteData = json_decode(wfConfig::get('wordfenceCentralSiteData', '[]'), true);\n\t\treturn (is_array($siteData) && array_key_exists('audit-log-url', $siteData)) ? (string) $siteData['audit-log-url'] : null;\n\t}\n}"},{"base":"plugins","rel":"wordfence\/lib\/wfSupportController.php","ext":"php","size":24758,"mtime":1757312769,"type":"text","content":"<?php\n\nclass wfSupportController {\n\tconst ITEM_INDEX = 'index';\n\tconst ITEM_FREE = 'free';\n\tconst ITEM_PREMIUM = 'premium';\n\t\n\tconst ITEM_CHANGELOG = 'changelog';\n\t\n\tconst ITEM_NOTICE_WAF_INACCESSIBLE_CONFIG = 'notice-waf-inaccessible-config';\n\tconst ITEM_NOTICE_WAF_MOD_PHP_FIX = 'notice-waf-mod-php-fix';\n\tconst ITEM_NOTICE_WAF_READ_ONLY_WARNING = 'notice-waf-read-only-warning';\n\tconst ITEM_NOTICE_MISCONFIGURED_HOW_GET_IPS = 'notice-misconfigured-how-get-ips';\n\tconst ITEM_NOTICE_SWITCH_LIVE_TRAFFIC = 'notice-switch-live-traffic';\n\t\n\tconst ITEM_LOCKED_OUT = 'locked-out';\n\tconst ITEM_AJAX_BLOCKED = 'ajax-blocked';\n\tconst ITEM_USING_BREACH_PASSWORD = 'using-breach-password';\n\t\n\tconst ITEM_WIDGET_LOCAL_ATTACKS = 'widget-local-attacks';\n\t\n\tconst ITEM_VERSION_WORDPRESS = 'version-wordpress';\n\tconst ITEM_VERSION_PHP = 'version-php';\n\tconst ITEM_VERSION_OPENSSL = 'version-ssl';\n\t\n\tconst ITEM_GDPR = 'gdpr';\n\tconst ITEM_GDPR_DPA = 'gdpr-dpa';\n\n\tconst ITEM_GENERAL_REMOTE_IP_LOOKUP = 'general-remote-ip-lookup';\n\t\n\tconst ITEM_DASHBOARD = 'dashboard';\n\tconst ITEM_DASHBOARD_STATUS_FIREWALL = 'dashboard-status-firewall';\n\tconst ITEM_DASHBOARD_STATUS_SCAN = 'dashboard-status-scan';\n\tconst ITEM_DASHBOARD_OPTIONS = 'dashboard-options';\n\tconst ITEM_DASHBOARD_OPTION_API_KEY = 'dashboard-option-api-key';\n\tconst ITEM_DASHBOARD_OPTION_HOW_GET_IPS = 'dashboard-option-how-get-ips';\n\tconst ITEM_DASHBOARD_OPTION_AUTOMATIC_UPDATE = 'dashboard-option-automatic-update';\n\tconst ITEM_DASHBOARD_OPTION_ALERT_EMAILS = 'dashboard-option-alert-emails';\n\tconst ITEM_DASHBOARD_OPTION_HIDE_VERSION = 'dashboard-option-hide-version';\n\tconst ITEM_DASHBOARD_OPTION_DISABLE_UPLOADS_EXECUTION = 'dashboard-option-disable-uploads-execution';\n\tconst ITEM_DASHBOARD_OPTION_DISABLE_COOKIES = 'dashboard-option-disable-cookies';\n\tconst ITEM_DASHBOARD_OPTION_PAUSE_LIVE_UPDATES = 'dashboard-option-pause-live-updates';\n\tconst ITEM_DASHBOARD_OPTION_UPDATE_INTERVAL = 'dashboard-option-refresh-period';\n\tconst ITEM_DASHBOARD_OPTION_LITESPEED_WARNING = 'dashboard-litespeed-warning';\n\tconst ITEM_DASHBOARD_OPTION_BYPASS_LITESPEED_CHECK = 'dashboard-option-bypass-litespeed-check';\n\tconst ITEM_DASHBOARD_OPTION_DELETE_DEACTIVATION = 'dashboard-option-delete-deactivation';\n\tconst ITEM_DASHBOARD_OPTION_EXPORT = 'dashboard-option-export';\n\tconst ITEM_DASHBOARD_OPTION_IMPORT = 'dashboard-option-import';\n\t\n\tconst ITEM_FIREWALL_WAF = 'firewall-waf';\n\tconst ITEM_FIREWALL_WAF_STATUS_OVERALL = 'firewall-waf-status-overall';\n\tconst ITEM_FIREWALL_WAF_STATUS_RULES = 'firewall-waf-status-rules';\n\tconst ITEM_FIREWALL_WAF_STATUS_BLACKLIST = 'firewall-waf-status-blacklist';\n\tconst ITEM_FIREWALL_WAF_STATUS_BRUTE_FORCE = 'firewall-waf-status-brute-force';\n\tconst ITEM_FIREWALL_WAF_INSTALL_MANUALLY = 'firewall-waf-install-manually';\n\tconst ITEM_FIREWALL_WAF_INSTALL_NGINX = 'firewall-waf-install-nginx';\n\tconst ITEM_FIREWALL_WAF_REMOVE_MANUALLY = 'firewall-waf-remove-manually';\n\tconst ITEM_FIREWALL_WAF_LEARNING_MODE = 'firewall-waf-learning-mode';\n\tconst ITEM_FIREWALL_WAF_RULES = 'firewall-waf-rules';\n\tconst ITEM_FIREWALL_WAF_WHITELIST = 'firewall-waf-whitelist';\n\tconst ITEM_FIREWALL_WAF_OPTION_DELAY_BLOCKING = 'firewall-waf-option-delay-blocking';\n\tconst ITEM_FIREWALL_WAF_OPTION_WHITELISTED_IPS = 'firewall-waf-option-whitelisted-ips';\n\tconst ITEM_FIREWALL_WAF_OPTION_WHITELISTED_SERVICES = 'firewall-waf-option-whitelisted-services';\n\tconst ITEM_FIREWALL_WAF_IGNORED_ALERT_IPS = 'firewall-waf-option-ignored-alert-ips';\n\tconst ITEM_FIREWALL_WAF_OPTION_IMMEDIATELY_BLOCK_URLS = 'firewall-waf-option-immediately-block-urls';\n\tconst ITEM_FIREWALL_WAF_OPTION_ENABLE_LOGIN_SECURITY = 'firewall-waf-option-enable-login-security';\n\tconst ITEM_FIREWALL_WAF_OPTION_LOCK_OUT_FAILURE_COUNT = 'firewall-waf-option-lock-out-failure-count';\n\tconst ITEM_FIREWALL_WAF_OPTION_LOCK_OUT_FORGOT_PASSWORD_COUNT = 'firewall-waf-option-lock-out-forgot-password-count';\n\tconst ITEM_FIREWALL_WAF_OPTION_COUNT_TIME_PERIOD = 'firewall-waf-option-count-time-period';\n\tconst ITEM_FIREWALL_WAF_OPTION_LOCKOUT_DURATION = 'firewall-waf-option-lockout-duration';\n\tconst ITEM_FIREWALL_WAF_OPTION_IMMEDIATELY_LOCK_OUT_INVALID_USERS = 'firewall-waf-option-immediately-lock-out-invalid-users';\n\tconst ITEM_FIREWALL_WAF_OPTION_IMMEDIATELY_BLOCK_USERS = 'firewall-waf-option-immediately-block-users';\n\tconst ITEM_FIREWALL_WAF_OPTION_ENFORCE_STRONG_PASSWORDS = 'firewall-waf-option-enforce-strong-passwords';\n\tconst ITEM_FIREWALL_WAF_OPTION_PREVENT_BREACH_PASSWORDS = 'firewall-waf-option-prevent-breach-passwords';\n\tconst ITEM_FIREWALL_WAF_OPTION_MASK_LOGIN_ERRORS = 'firewall-waf-option-mask-login-errors';\n\tconst ITEM_FIREWALL_WAF_OPTION_PREVENT_ADMIN_REGISTRATION = 'firewall-waf-option-prevent-admin-registration';\n\tconst ITEM_FIREWALL_WAF_OPTION_PREVENT_AUTHOR_SCAN = 'firewall-waf-option-prevent-author-scan';\n\tconst ITEM_FIREWALL_WAF_OPTION_DISABLE_APPLICATION_PASSWORDS = 'firewall-waf-option-disable-application-passwords';\n\tconst ITEM_FIREWALL_WAF_OPTION_BLOCK_BAD_POST = 'firewall-waf-option-block-bad-post';\n\tconst ITEM_FIREWALL_WAF_OPTION_CUSTOM_BLOCK_TEXT = 'firewall-waf-option-custom-block-text';\n\tconst ITEM_FIREWALL_WAF_OPTION_CHECK_PASSWORD = 'firewall-waf-option-check-password';\n\tconst ITEM_FIREWALL_WAF_OPTION_PARTICIPATE_WFSN = 'firewall-waf-option-participate-wfsn';\n\tconst ITEM_FIREWALL_WAF_OPTION_ENABLE_ADVANCED_BLOCKING = 'firewall-waf-option-enable-advanced-blocking';\n\tconst ITEM_FIREWALL_WAF_OPTION_IMMEDIATELY_BLOCK_FAKE_GOOGLE = 'firewall-waf-option-immediately-block-fake-google';\n\tconst ITEM_FIREWALL_WAF_OPTION_GOOGLE_ACTION = 'firewall-waf-option-google-action';\n\tconst ITEM_FIREWALL_WAF_OPTION_RATE_LIMIT_ANY = 'firewall-waf-option-rate-limit-any';\n\tconst ITEM_FIREWALL_WAF_OPTION_RATE_LIMIT_CRAWLER = 'firewall-waf-option-rate-limit-crawler';\n\tconst ITEM_FIREWALL_WAF_OPTION_RATE_LIMIT_CRAWLER_404 = 'firewall-waf-option-rate-limit-crawler-404';\n\tconst ITEM_FIREWALL_WAF_OPTION_RATE_LIMIT_HUMAN = 'firewall-waf-option-rate-limit-human';\n\tconst ITEM_FIREWALL_WAF_OPTION_RATE_LIMIT_HUMAN_404 = 'firewall-waf-option-rate-limit-human-404';\n\tconst ITEM_FIREWALL_WAF_OPTION_RATE_LIMIT_ANY_404 = 'firewall-waf-option-rate-limit-any-404';\n\tconst ITEM_FIREWALL_WAF_OPTION_AUTOMATIC_BLOCK_DURATION = 'firewall-waf-option-automatic-block-duration';\n\tconst ITEM_FIREWALL_WAF_OPTION_WHITELISTED_404 = 'firewall-waf-option-whitelisted-404';\n\tconst ITEM_FIREWALL_WAF_OPTION_MONITOR_AJAX = 'firewall-waf-option-monitor-ajax';\n\t\n\tconst ITEM_FIREWALL_BLOCKING = 'firewall-blocking';\n\tconst ITEM_FIREWALL_BLOCKING_FILTER = 'firewall-blocking-filter';\n\tconst ITEM_FIREWALL_BLOCKING_OPTION_WHAT_TO_DO = 'firewall-blocking-option-what-to-do';\n\tconst ITEM_FIREWALL_BLOCKING_OPTION_REDIRECT = 'firewall-blocking-option-redirect';\n\tconst ITEM_FIREWALL_BLOCKING_OPTION_BLOCK_LOGGED_IN = 'firewall-blocking-option-block-logged-in';\n\tconst ITEM_FIREWALL_BLOCKING_BYPASS_COOKIE = 'firewall-blocking-bypass-cookie';\n\tconst ITEM_FIREWALL_BLOCKING_BYPASS_REDIRECT = 'firewall-blocking-bypass-redirect';\n\tconst ITEM_FIREWALL_BLOCKING_FULL_SITE = 'firewall-blocking-full-site';\n\n\tconst ITEM_FIREWALL_REMOVE_OPTIMIZATION = 'firewall-remove-optimization';\n\t\n\tconst ITEM_SCAN = 'scan';\n\tconst ITEM_SCAN_STATUS_OVERALL = 'scan-status-overall';\n\tconst ITEM_SCAN_STATUS_MALWARE = 'scan-status-malware';\n\tconst ITEM_SCAN_STATUS_REPUTATION = 'scan-status-reputation';\n\tconst ITEM_SCAN_OPTION_CHECK_SITE_BLACKLISTED = 'scan-option-check-site-blacklisted';\n\tconst ITEM_SCAN_OPTION_CHECK_SITE_SPAMVERTIZED = 'scan-option-check-site-spamvertized';\n\tconst ITEM_SCAN_OPTION_CHECK_IP_SPAMMING = 'scan-option-ip-spamming';\n\tconst ITEM_SCAN_OPTION_CHECK_MISCONFIGURED_HOW_GET_IPS = 'scan-option-misconfigured-how-get-ips';\n\tconst ITEM_SCAN_OPTION_PUBLIC_CONFIG = 'scan-option-public-config';\n\tconst ITEM_SCAN_OPTION_PUBLIC_QUARANTINED = 'scan-option-public-quarantined';\n\tconst ITEM_SCAN_OPTION_CORE_CHANGES = 'scan-option-core-changes';\n\tconst ITEM_SCAN_OPTION_THEME_CHANGES = 'scan-option-theme-changes';\n\tconst ITEM_SCAN_OPTION_PLUGIN_CHANGES = 'scan-option-plugin-changes';\n\tconst ITEM_SCAN_OPTION_UNKNOWN_CORE = 'scan-option-unknown-core';\n\tconst ITEM_SCAN_OPTION_MALWARE_HASHES = 'scan-option-malware-hashes';\n\tconst ITEM_SCAN_OPTION_MALWARE_SIGNATURES = 'scan-option-malware-signatures';\n\tconst ITEM_SCAN_OPTION_MALWARE_URLS = 'scan-option-malware-urls';\n\tconst ITEM_SCAN_OPTION_POST_URLS = 'scan-option-post-urls';\n\tconst ITEM_SCAN_OPTION_COMMENT_URLS = 'scan-option-comment-urls';\n\tconst ITEM_SCAN_OPTION_MALWARE_OPTIONS = 'scan-option-malware-options';\n\tconst ITEM_SCAN_OPTION_UPDATES = 'scan-option-updates';\n\tconst ITEM_SCAN_OPTION_UNKNOWN_ADMINS = 'scan-option-unknown-admins';\n\tconst ITEM_SCAN_OPTION_PASSWORD_STRENGTH = 'scan-option-password-strength';\n\tconst ITEM_SCAN_OPTION_DISK_SPACE = 'scan-option-disk-space';\n\tconst ITEM_SCAN_OPTION_WAF_STATUS = 'scan-option-waf-status';\n\tconst ITEM_SCAN_OPTION_OUTSIDE_WORDPRESS = 'scan-option-outside-wordpress';\n\tconst ITEM_SCAN_OPTION_IMAGES_EXECUTABLE = 'scan-option-images-executable';\n\tconst ITEM_SCAN_OPTION_HIGH_SENSITIVITY = 'scan-option-high-sensitivity';\n\tconst ITEM_SCAN_OPTION_LOW_RESOURCE = 'scan-option-low-resource';\n\tconst ITEM_SCAN_OPTION_LIMIT_ISSUES = 'scan-option-limit-issues';\n\tconst ITEM_SCAN_OPTION_OVERALL_TIME_LIMIT = 'scan-option-overall-time-limit';\n\tconst ITEM_SCAN_OPTION_MEMORY_LIMIT = 'scan-option-memory-limit';\n\tconst ITEM_SCAN_OPTION_STAGE_TIME_LIMIT = 'scan-option-stage-time-limit';\n\tconst ITEM_SCAN_OPTION_EXCLUDE_PATTERNS = 'scan-option-exclude-patterns';\n\tconst ITEM_SCAN_OPTION_CUSTOM_MALWARE_SIGNATURES = 'scan-option-custom-malware-signatures';\n\tconst ITEM_SCAN_OPTION_MAX_RESUME_ATTEMPTS = 'scan-option-max-resume-attempts';\n\tconst ITEM_SCAN_OPTION_USE_ONLY_IPV4 = 'scan-option-use-only-ipv4';\n\tconst ITEM_SCAN_TIME_LIMIT = 'scan-time-limit';\n\tconst ITEM_SCAN_FAILS = 'scan-fails';\n\tconst ITEM_SCAN_FAILED_START = 'scan-failed-start';\n\tconst ITEM_SCAN_BULK_DELETE_WARNING = 'scan-bulk-delete-warning';\n\tconst ITEM_SCAN_SCHEDULING = 'scan-scheduling';\n\tconst ITEM_SCAN_RESULT_PUBLIC_CONFIG = 'scan-result-public-config';\n\tconst ITEM_SCAN_RESULT_PLUGIN_ABANDONED = 'scan-result-plugin-abandoned';\n\tconst ITEM_SCAN_RESULT_PLUGIN_REMOVED = 'scan-result-plugin-removed';\n\tconst ITEM_SCAN_RESULT_UPDATE_CHECK_FAILED = 'scan-result-update-check-failed';\n\tconst ITEM_SCAN_RESULT_OPTION_MALWARE_URL = 'scan-result-option-malware-url';\n\tconst ITEM_SCAN_RESULT_GEOIP_UPDATE = 'scan-result-geoip-update';\n\tconst ITEM_SCAN_RESULT_WAF_DISABLED = 'scan-result-waf-disabled';\n\tconst ITEM_SCAN_RESULT_UNKNOWN_FILE_CORE = 'scan-result-unknown-file-in-wordpress-core';\n\tconst ITEM_SCAN_RESULT_SKIPPED_PATHS = 'scan-result-skipped-paths';\n\tconst ITEM_SCAN_RESULT_REPAIR_MODIFIED_FILES = 'scan-result-repair-modified-files';\n\tconst ITEM_SCAN_RESULT_MODIFIED_PLUGIN = 'scan-result-modified-plugin';\n\tconst ITEM_SCAN_RESULT_MODIFIED_THEME = 'scan-result-modified-theme';\n\tconst ITEM_SCAN_RESULT_PLUGIN_VULNERABLE = 'scan-result-plugin-vulnerable';\n\tconst ITEM_SCAN_RESULT_CORE_UPGRADE = 'scan-result-core-upgrade';\n\n\tconst ITEM_TOOLS_TWO_FACTOR = 'tools-two-factor';\n\tconst ITEM_TOOLS_LIVE_TRAFFIC = 'tools-live-traffic';\n\tconst ITEM_TOOLS_LIVE_TRAFFIC_OPTION_ENABLE = 'tools-live-traffic-option-enable';\n\tconst ITEM_TOOLS_AUDIT_LOG = 'tools-audit-log';\n\tconst ITEM_TOOLS_AUDIT_LOG_OPTION_MODE = 'tools-audit-log-option-mode';\n\tconst ITEM_TOOLS_WHOIS_LOOKUP = 'tools-whois-lookup';\n\tconst ITEM_TOOLS_IMPORT_EXPORT = 'tools-import-export';\n\t\n\tconst ITEM_DIAGNOSTICS = 'diagnostics';\n\tconst ITEM_DIAGNOSTICS_SYSTEM_CONFIGURATION = 'diagnostics-system-configuration';\n\tconst ITEM_DIAGNOSTICS_TEST_MEMORY = 'diagnostics-test-memory';\n\tconst ITEM_DIAGNOSTICS_TEST_EMAIL = 'diagnostics-test-email';\n\tconst ITEM_DIAGNOSTICS_TEST_ACTIVITY_REPORT = 'diagnostics-test-activity-report';\n\tconst ITEM_DIAGNOSTICS_REMOVE_CENTRAL_DATA = 'diagnostics-remove-central-data';\n\tconst ITEM_DIAGNOSTICS_OPTION_DEBUGGING_MODE = 'diagnostics-option-debugging-mode';\n\tconst ITEM_DIAGNOSTICS_OPTION_REMOTE_SCANS = 'diagnostics-option-remote-scans';\n\tconst ITEM_DIAGNOSTICS_OPTION_SSL_VERIFICATION = 'diagnostics-option-ssl-verification';\n\tconst ITEM_DIAGNOSTICS_OPTION_DISABLE_PHP_INPUT = 'diagnostics-option-disable-php-input';\n\tconst ITEM_DIAGNOSTICS_OPTION_BETA_TDF = 'diagnostics-option-beta-tdf';\n\tconst ITEM_DIAGNOSTICS_OPTION_WORDFENCE_TRANSLATIONS = 'diagnostics-option-wordfence-translations';\n\tconst ITEM_DIAGNOSTICS_IPV6 = 'diagnostics-ipv6';\n\tconst ITEM_DIAGNOSTICS_CLOUDFLARE_BLOCK = 'compatibility-cloudflare';\n\n\tconst ITEM_MODULE_LOGIN_SECURITY = 'module-login-security';\n\tconst ITEM_MODULE_LOGIN_SECURITY_2FA = 'module-login-security-2fa';\n\tconst ITEM_MODULE_LOGIN_SECURITY_CAPTCHA = 'module-login-security-captcha';\n\t\n\tpublic static function esc_supportURL($item = self::ITEM_INDEX) {\n\t\treturn esc_url(self::supportURL($item));\n\t}\n\t\n\tpublic static function supportURL($item = self::ITEM_INDEX) {\n\t\t$base = 'https:\/\/www.wordfence.com\/help\/';\n\t\tswitch ($item) {\n\t\t\tcase self::ITEM_INDEX:\n\t\t\t\treturn 'https:\/\/www.wordfence.com\/help\/';\n\t\t\tcase self::ITEM_FREE:\n\t\t\t\treturn 'https:\/\/wordpress.org\/support\/plugin\/wordfence\/';\n\t\t\tcase self::ITEM_PREMIUM:\n\t\t\t\treturn 'https:\/\/support.wordfence.com\/';\n\t\t\t\n\t\t\t\/\/These all fall through to the query format\n\t\t\t\t\n\t\t\tcase self::ITEM_NOTICE_WAF_INACCESSIBLE_CONFIG:\n\t\t\tcase self::ITEM_NOTICE_WAF_MOD_PHP_FIX:\n\t\t\tcase self::ITEM_NOTICE_WAF_READ_ONLY_WARNING:\n\t\t\tcase self::ITEM_NOTICE_MISCONFIGURED_HOW_GET_IPS:\n\t\t\tcase self::ITEM_NOTICE_SWITCH_LIVE_TRAFFIC:\n\t\t\t\t\n\t\t\tcase self::ITEM_LOCKED_OUT:\n\t\t\tcase self::ITEM_AJAX_BLOCKED:\n\t\t\tcase self::ITEM_USING_BREACH_PASSWORD:\n\t\t\t\t\n\t\t\tcase self::ITEM_WIDGET_LOCAL_ATTACKS:\n\t\t\t\t\n\t\t\tcase self::ITEM_VERSION_WORDPRESS:\n\t\t\tcase self::ITEM_VERSION_PHP:\n\t\t\tcase self::ITEM_VERSION_OPENSSL:\n\t\t\t\t\n\t\t\tcase self::ITEM_GDPR:\n\t\t\tcase self::ITEM_GDPR_DPA:\n\n\t\t\tcase self::ITEM_GENERAL_REMOTE_IP_LOOKUP:\n\t\t\t\t\n\t\t\tcase self::ITEM_DASHBOARD:\n\t\t\tcase self::ITEM_DASHBOARD_STATUS_FIREWALL:\n\t\t\tcase self::ITEM_DASHBOARD_STATUS_SCAN:\n\t\t\tcase self::ITEM_DASHBOARD_OPTIONS:\n\t\t\tcase self::ITEM_DASHBOARD_OPTION_API_KEY:\n\t\t\tcase self::ITEM_DASHBOARD_OPTION_HOW_GET_IPS:\n\t\t\tcase self::ITEM_DASHBOARD_OPTION_AUTOMATIC_UPDATE:\n\t\t\tcase self::ITEM_DASHBOARD_OPTION_ALERT_EMAILS:\n\t\t\tcase self::ITEM_DASHBOARD_OPTION_HIDE_VERSION:\n\t\t\tcase self::ITEM_DASHBOARD_OPTION_DISABLE_UPLOADS_EXECUTION:\n\t\t\tcase self::ITEM_DASHBOARD_OPTION_DISABLE_COOKIES:\n\t\t\tcase self::ITEM_DASHBOARD_OPTION_PAUSE_LIVE_UPDATES:\n\t\t\tcase self::ITEM_DASHBOARD_OPTION_UPDATE_INTERVAL:\n\t\t\tcase self::ITEM_DASHBOARD_OPTION_LITESPEED_WARNING:\n\t\t\tcase self::ITEM_DASHBOARD_OPTION_BYPASS_LITESPEED_CHECK:\n\t\t\tcase self::ITEM_DASHBOARD_OPTION_DELETE_DEACTIVATION:\n\t\t\tcase self::ITEM_DASHBOARD_OPTION_EXPORT:\n\t\t\tcase self::ITEM_DASHBOARD_OPTION_IMPORT:\n\n\t\t\tcase self::ITEM_FIREWALL_WAF:\n\t\t\tcase self::ITEM_FIREWALL_WAF_STATUS_OVERALL:\n\t\t\tcase self::ITEM_FIREWALL_WAF_STATUS_RULES:\n\t\t\tcase self::ITEM_FIREWALL_WAF_STATUS_BLACKLIST:\n\t\t\tcase self::ITEM_FIREWALL_WAF_STATUS_BRUTE_FORCE:\n\t\t\tcase self::ITEM_FIREWALL_WAF_INSTALL_MANUALLY:\n\t\t\tcase self::ITEM_FIREWALL_WAF_INSTALL_NGINX:\n\t\t\tcase self::ITEM_FIREWALL_WAF_REMOVE_MANUALLY:\n\t\t\tcase self::ITEM_FIREWALL_WAF_LEARNING_MODE:\n\t\t\tcase self::ITEM_FIREWALL_WAF_RULES:\n\t\t\tcase self::ITEM_FIREWALL_WAF_WHITELIST:\n\t\t\tcase self::ITEM_FIREWALL_WAF_OPTION_DELAY_BLOCKING:\n\t\t\tcase self::ITEM_FIREWALL_WAF_OPTION_WHITELISTED_IPS:\n\t\t\tcase self::ITEM_FIREWALL_WAF_OPTION_WHITELISTED_SERVICES:\n\t\t\tcase self::ITEM_FIREWALL_WAF_IGNORED_ALERT_IPS:\n\t\t\tcase self::ITEM_FIREWALL_WAF_OPTION_IMMEDIATELY_BLOCK_URLS:\n\t\t\tcase self::ITEM_FIREWALL_WAF_OPTION_ENABLE_LOGIN_SECURITY:\n\t\t\tcase self::ITEM_FIREWALL_WAF_OPTION_LOCK_OUT_FAILURE_COUNT:\n\t\t\tcase self::ITEM_FIREWALL_WAF_OPTION_LOCK_OUT_FORGOT_PASSWORD_COUNT:\n\t\t\tcase self::ITEM_FIREWALL_WAF_OPTION_COUNT_TIME_PERIOD:\n\t\t\tcase self::ITEM_FIREWALL_WAF_OPTION_LOCKOUT_DURATION:\n\t\t\tcase self::ITEM_FIREWALL_WAF_OPTION_IMMEDIATELY_LOCK_OUT_INVALID_USERS:\n\t\t\tcase self::ITEM_FIREWALL_WAF_OPTION_IMMEDIATELY_BLOCK_USERS:\n\t\t\tcase self::ITEM_FIREWALL_WAF_OPTION_ENFORCE_STRONG_PASSWORDS:\n\t\t\tcase self::ITEM_FIREWALL_WAF_OPTION_PREVENT_BREACH_PASSWORDS:\n\t\t\tcase self::ITEM_FIREWALL_WAF_OPTION_MASK_LOGIN_ERRORS:\n\t\t\tcase self::ITEM_FIREWALL_WAF_OPTION_PREVENT_ADMIN_REGISTRATION:\n\t\t\tcase self::ITEM_FIREWALL_WAF_OPTION_PREVENT_AUTHOR_SCAN:\n\t\t\tcase self::ITEM_FIREWALL_WAF_OPTION_DISABLE_APPLICATION_PASSWORDS:\n\t\t\tcase self::ITEM_FIREWALL_WAF_OPTION_BLOCK_BAD_POST:\n\t\t\tcase self::ITEM_FIREWALL_WAF_OPTION_CUSTOM_BLOCK_TEXT:\n\t\t\tcase self::ITEM_FIREWALL_WAF_OPTION_CHECK_PASSWORD:\n\t\t\tcase self::ITEM_FIREWALL_WAF_OPTION_PARTICIPATE_WFSN:\n\t\t\tcase self::ITEM_FIREWALL_WAF_OPTION_ENABLE_ADVANCED_BLOCKING:\n\t\t\tcase self::ITEM_FIREWALL_WAF_OPTION_IMMEDIATELY_BLOCK_FAKE_GOOGLE:\n\t\t\tcase self::ITEM_FIREWALL_WAF_OPTION_GOOGLE_ACTION:\n\t\t\tcase self::ITEM_FIREWALL_WAF_OPTION_RATE_LIMIT_ANY:\n\t\t\tcase self::ITEM_FIREWALL_WAF_OPTION_RATE_LIMIT_CRAWLER:\n\t\t\tcase self::ITEM_FIREWALL_WAF_OPTION_RATE_LIMIT_CRAWLER_404:\n\t\t\tcase self::ITEM_FIREWALL_WAF_OPTION_RATE_LIMIT_HUMAN:\n\t\t\tcase self::ITEM_FIREWALL_WAF_OPTION_RATE_LIMIT_HUMAN_404:\n\t\t\tcase self::ITEM_FIREWALL_WAF_OPTION_RATE_LIMIT_ANY_404:\n\t\t\tcase self::ITEM_FIREWALL_WAF_OPTION_AUTOMATIC_BLOCK_DURATION:\n\t\t\tcase self::ITEM_FIREWALL_WAF_OPTION_WHITELISTED_404:\n\t\t\tcase self::ITEM_FIREWALL_WAF_OPTION_MONITOR_AJAX:\n\t\t\t\t\n\t\t\tcase self::ITEM_FIREWALL_BLOCKING:\n\t\t\tcase self::ITEM_FIREWALL_BLOCKING_FILTER:\n\t\t\tcase self::ITEM_FIREWALL_BLOCKING_OPTION_WHAT_TO_DO:\n\t\t\tcase self::ITEM_FIREWALL_BLOCKING_OPTION_REDIRECT:\n\t\t\tcase self::ITEM_FIREWALL_BLOCKING_OPTION_BLOCK_LOGGED_IN:\n\t\t\tcase self::ITEM_FIREWALL_BLOCKING_BYPASS_COOKIE:\n\t\t\tcase self::ITEM_FIREWALL_BLOCKING_BYPASS_REDIRECT:\n\t\t\tcase self::ITEM_FIREWALL_BLOCKING_FULL_SITE:\n\n\t\t\tcase self::ITEM_FIREWALL_REMOVE_OPTIMIZATION:\n\t\t\t\t\n\t\t\tcase self::ITEM_SCAN:\n\t\t\tcase self::ITEM_SCAN_STATUS_OVERALL:\n\t\t\tcase self::ITEM_SCAN_STATUS_MALWARE:\n\t\t\tcase self::ITEM_SCAN_STATUS_REPUTATION:\n\t\t\tcase self::ITEM_SCAN_TIME_LIMIT:\n\t\t\tcase self::ITEM_SCAN_FAILS:\n\t\t\tcase self::ITEM_SCAN_FAILED_START:\n\t\t\tcase self::ITEM_SCAN_BULK_DELETE_WARNING:\n\t\t\tcase self::ITEM_SCAN_SCHEDULING:\n\t\t\tcase self::ITEM_SCAN_OPTION_CHECK_SITE_BLACKLISTED:\n\t\t\tcase self::ITEM_SCAN_OPTION_CHECK_SITE_SPAMVERTIZED:\n\t\t\tcase self::ITEM_SCAN_OPTION_CHECK_IP_SPAMMING:\n\t\t\tcase self::ITEM_SCAN_OPTION_CHECK_MISCONFIGURED_HOW_GET_IPS:\n\t\t\tcase self::ITEM_SCAN_OPTION_PUBLIC_CONFIG:\n\t\t\tcase self::ITEM_SCAN_OPTION_PUBLIC_QUARANTINED:\n\t\t\tcase self::ITEM_SCAN_OPTION_CORE_CHANGES:\n\t\t\tcase self::ITEM_SCAN_OPTION_THEME_CHANGES:\n\t\t\tcase self::ITEM_SCAN_OPTION_PLUGIN_CHANGES:\n\t\t\tcase self::ITEM_SCAN_OPTION_UNKNOWN_CORE:\n\t\t\tcase self::ITEM_SCAN_OPTION_MALWARE_HASHES:\n\t\t\tcase self::ITEM_SCAN_OPTION_MALWARE_SIGNATURES:\n\t\t\tcase self::ITEM_SCAN_OPTION_MALWARE_URLS:\n\t\t\tcase self::ITEM_SCAN_OPTION_POST_URLS:\n\t\t\tcase self::ITEM_SCAN_OPTION_COMMENT_URLS:\n\t\t\tcase self::ITEM_SCAN_OPTION_MALWARE_OPTIONS:\n\t\t\tcase self::ITEM_SCAN_OPTION_UPDATES:\n\t\t\tcase self::ITEM_SCAN_OPTION_UNKNOWN_ADMINS:\n\t\t\tcase self::ITEM_SCAN_OPTION_PASSWORD_STRENGTH:\n\t\t\tcase self::ITEM_SCAN_OPTION_DISK_SPACE:\n\t\t\tcase self::ITEM_SCAN_OPTION_WAF_STATUS:\n\t\t\tcase self::ITEM_SCAN_OPTION_OUTSIDE_WORDPRESS:\n\t\t\tcase self::ITEM_SCAN_OPTION_IMAGES_EXECUTABLE:\n\t\t\tcase self::ITEM_SCAN_OPTION_HIGH_SENSITIVITY:\n\t\t\tcase self::ITEM_SCAN_OPTION_LOW_RESOURCE:\n\t\t\tcase self::ITEM_SCAN_OPTION_LIMIT_ISSUES:\n\t\t\tcase self::ITEM_SCAN_OPTION_OVERALL_TIME_LIMIT:\n\t\t\tcase self::ITEM_SCAN_OPTION_MEMORY_LIMIT:\n\t\t\tcase self::ITEM_SCAN_OPTION_STAGE_TIME_LIMIT:\n\t\t\tcase self::ITEM_SCAN_OPTION_EXCLUDE_PATTERNS:\n\t\t\tcase self::ITEM_SCAN_OPTION_CUSTOM_MALWARE_SIGNATURES:\n\t\t\tcase self::ITEM_SCAN_OPTION_MAX_RESUME_ATTEMPTS:\n\t\t\tcase self::ITEM_SCAN_OPTION_USE_ONLY_IPV4:\n\t\t\tcase self::ITEM_SCAN_RESULT_PUBLIC_CONFIG:\n\t\t\tcase self::ITEM_SCAN_RESULT_PLUGIN_ABANDONED:\n\t\t\tcase self::ITEM_SCAN_RESULT_PLUGIN_REMOVED:\n\t\t\tcase self::ITEM_SCAN_RESULT_UPDATE_CHECK_FAILED:\n\t\t\tcase self::ITEM_SCAN_RESULT_OPTION_MALWARE_URL:\n\t\t\tcase self::ITEM_SCAN_RESULT_GEOIP_UPDATE:\n\t\t\tcase self::ITEM_SCAN_RESULT_WAF_DISABLED:\n\t\t\tcase self::ITEM_SCAN_RESULT_UNKNOWN_FILE_CORE:\n\t\t\tcase self::ITEM_SCAN_RESULT_SKIPPED_PATHS:\n\t\t\tcase self::ITEM_SCAN_RESULT_REPAIR_MODIFIED_FILES:\n\t\t\tcase self::ITEM_SCAN_RESULT_MODIFIED_PLUGIN:\n\t\t\tcase self::ITEM_SCAN_RESULT_MODIFIED_THEME:\n\t\t\tcase self::ITEM_SCAN_RESULT_PLUGIN_VULNERABLE:\n\t\t\tcase self::ITEM_SCAN_RESULT_CORE_UPGRADE:\n\n\t\t\tcase self::ITEM_TOOLS_TWO_FACTOR:\n\t\t\tcase self::ITEM_TOOLS_LIVE_TRAFFIC:\n\t\t\tcase self::ITEM_TOOLS_LIVE_TRAFFIC_OPTION_ENABLE:\n\t\t\tcase self::ITEM_TOOLS_AUDIT_LOG:\n\t\t\tcase self::ITEM_TOOLS_AUDIT_LOG_OPTION_MODE:\n\t\t\tcase self::ITEM_TOOLS_WHOIS_LOOKUP:\n\t\t\tcase self::ITEM_TOOLS_IMPORT_EXPORT:\n\t\t\t\t\n\t\t\tcase self::ITEM_DIAGNOSTICS:\n\t\t\tcase self::ITEM_DIAGNOSTICS_SYSTEM_CONFIGURATION:\n\t\t\tcase self::ITEM_DIAGNOSTICS_TEST_MEMORY:\n\t\t\tcase self::ITEM_DIAGNOSTICS_TEST_EMAIL:\n\t\t\tcase self::ITEM_DIAGNOSTICS_TEST_ACTIVITY_REPORT:\n\t\t\tcase self::ITEM_DIAGNOSTICS_REMOVE_CENTRAL_DATA:\n\t\t\tcase self::ITEM_DIAGNOSTICS_OPTION_DEBUGGING_MODE:\n\t\t\tcase self::ITEM_DIAGNOSTICS_OPTION_REMOTE_SCANS:\n\t\t\tcase self::ITEM_DIAGNOSTICS_OPTION_SSL_VERIFICATION:\n\t\t\tcase self::ITEM_DIAGNOSTICS_OPTION_DISABLE_PHP_INPUT:\n\t\t\tcase self::ITEM_DIAGNOSTICS_OPTION_BETA_TDF:\n\t\t\tcase self::ITEM_DIAGNOSTICS_OPTION_WORDFENCE_TRANSLATIONS:\n\t\t\tcase self::ITEM_DIAGNOSTICS_IPV6:\n\t\t\tcase self::ITEM_DIAGNOSTICS_CLOUDFLARE_BLOCK:\n\n\t\t\tcase self::ITEM_MODULE_LOGIN_SECURITY:\n\t\t\tcase self::ITEM_MODULE_LOGIN_SECURITY_2FA:\n\t\t\tcase self::ITEM_MODULE_LOGIN_SECURITY_CAPTCHA:\n\t\t\t\treturn $base . '?query=' . $item;\n\t\t}\n\t\t\n\t\treturn '';\n\t}\n\t\n\tpublic static function shouldShowSatisfactionPrompt() {\n\t\t\/\/Don't show if overridden\n\t\tif (!wfConfig::getBool('satisfactionPromptOverride')) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t\/\/Only show on our pages\n\t\tif (!isset($_REQUEST['page'])) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!preg_match('\/^Wordfence\/', $_REQUEST['page'])) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t\/\/Only show until dismissed\n\t\tif (wfConfig::get('satisfactionPromptDismissed') > 0) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t\/\/Only show to users installing after the release date of the version this was introduced\n\t\tif (WORDFENCE_FEEDBACK_EPOCH > wfConfig::get('satisfactionPromptInstallDate')) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t\/\/Don't show for at least 7 days post-install\n\t\tif ((time() - wfConfig::get('satisfactionPromptInstallDate')) < 86400 * 7) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static function satisfactionPromptNotice() {\n?>\n\t\t<div id=\"wordfenceSatisfactionPrompt\" class=\"fade notice notice-info\">\n\t\t\t<p id=\"wordfenceSatisfactionPrompt-initial\"><strong><?php printf(__('Are you enjoying using Wordfence Security?', 'wordfence')); ?><\/strong>&nbsp;&nbsp;&nbsp;<a href=\"#\" onclick=\"WFAD.wordfenceSatisfactionChoice('yes'); return false;\" class=\"wf-btn wf-btn-default wf-btn-sm\" role=\"button\"><?php printf(__('Yes', 'wordfence')); ?><\/a>&nbsp;&nbsp;&nbsp;<a href=\"#\" onclick=\"WFAD.wordfenceSatisfactionChoice('no'); return false;\" class=\"wf-btn wf-btn-default wf-btn-sm\" role=\"button\"><?php printf(__('No', 'wordfence')); ?><\/a><\/p>\n\t\t\t<div id=\"wordfenceSatisfactionPrompt-yes\" style=\"display: none;\">\n\t\t\t\t<p><?php printf(__('Please consider leaving us a 5-star review on wordpress.org. Your review helps other members of the WordPress community find plugins that fit their needs.', 'wordfence')); ?><\/p>\n\t\t\t\t<p><a href=\"https:\/\/wordpress.org\/support\/plugin\/wordfence\/reviews\/\" class=\"wf-btn wf-btn-default wf-btn-sm\" role=\"button\" target=\"_blank\" rel=\"noopener noreferrer\"><?php printf(__('Leave Review', 'wordfence')); ?><\/a><\/p>\n\t\t\t<\/div>\n\t\t\t<div id=\"wordfenceSatisfactionPrompt-no\" style=\"display: none;\">\n\t\t\t\t<p><?php printf(__('What can we do to improve Wordfence Security?', 'wordfence')); ?><\/p>\n\t\t\t\t<p><textarea rows=\"6\" cols=\"50\" id=\"wordfenceSatisfactionPrompt-feedback\"><\/textarea><\/p>\n\t\t\t\t<p><a href=\"#\" onclick=\"WFAD.wordfenceSatisfactionChoice('feedback'); return false;\" class=\"wf-btn wf-btn-default wf-btn-sm\" role=\"button\" target=\"_blank\" rel=\"noopener noreferrer\"><?php printf(__('Submit Feedback', 'wordfence')); ?><\/a>&nbsp;&nbsp;&nbsp;<a href=\"#\" onclick=\"WFAD.wordfenceSatisfactionChoice('dismiss'); return false;\" class=\"wf-btn wf-btn-default wf-btn-sm\" role=\"button\"><?php printf(__('Dismiss', 'wordfence')); ?><\/a><\/p>\n\t\t\t<\/div>\n\t\t\t<p id=\"wordfenceSatisfactionPrompt-complete\" style=\"display: none;\"><?php printf(__('Thank you for providing your feedback on Wordfence Security', 'wordfence')); ?><\/p>\n\t\t\t<button type=\"button\" class=\"notice-dismiss\" onclick=\"WFAD.wordfenceSatisfactionChoice('dismiss'); return false;\"><span class=\"screen-reader-text\">Dismiss this notice.<\/span><\/button>\n\t\t<\/div>\n<?php\n\t}\n}"},{"base":"plugins","rel":"wordfence\/lib\/wfAPI.php","ext":"php","size":10338,"mtime":1757312769,"type":"text","content":"<?php\nrequire_once(dirname(__FILE__) . '\/wordfenceConstants.php');\nrequire_once(dirname(__FILE__) . '\/wordfenceClass.php');\nrequire_once(dirname(__FILE__) . '\/wfLicense.php');\n\nclass wfAPI {\n\n\tpublic $lastHTTPStatus = '';\n\tpublic $lastCurlErrorNo = '';\n\tprivate $curlContent = 0;\n\tprivate $APIKey = '';\n\tprivate $wordpressVersion = '';\n\n\tpublic function __construct($apiKey, $wordpressVersion) {\n\t\t$this->APIKey = $apiKey;\n\t\t$this->wordpressVersion = $wordpressVersion;\n\t}\n\n\tpublic function getStaticURL($url) { \/\/ In the form '\/something.bin' without quotes\n\t\treturn $this->getURL(rtrim($this->getAPIURL(), '\/') . '\/' . ltrim($url, '\/'));\n\t}\n\n\tpublic function call($action, $getParams = array(), $postParams = array(), $forceSSL = false, $timeout = 900, $passThroughErrorMsg = false) {\n\t\t$apiURL = $this->getAPIURL();\n\t\t\/\/Sanity check. Developer should call wfAPI::SSLEnabled() to check if SSL is enabled before forcing SSL and return a user friendly msg if it's not.\n\t\tif ($forceSSL && (!preg_match('\/^https:\/i', $apiURL))) {\n\t\t\t\/\/User's should never see this message unless we aren't calling SSLEnabled() to check if SSL is enabled before using call() with forceSSL\n\t\t\tthrow new wfAPICallSSLUnavailableException(__(\"SSL is not supported by your web server and is required to use this function. Please ask your hosting provider or site admin to install cURL with openSSL to use this feature.\", 'wordfence'));\n\t\t}\n\t\t$json = $this->getURL(rtrim($apiURL, '\/') . '\/v' . WORDFENCE_API_VERSION . '\/?' . $this->makeAPIQueryString() . '&' . self::buildQuery(\n\t\t\t\tarray_merge(\n\t\t\t\t\tarray('action' => $action),\n\t\t\t\t\t$getParams\n\t\t\t\t)), $postParams, $timeout, $passThroughErrorMsg);\n\t\tif (!$json) {\n\t\t\tthrow new wfAPICallInvalidResponseException(sprintf(\/* translators: API call\/action\/endpoint. *\/__(\"We received an empty data response from the Wordfence scanning servers when calling the '%s' function.\", 'wordfence'), $action));\n\t\t}\n\n\t\t$dat = json_decode($json, true);\n\n\t\tif (!is_array($dat)) {\n\t\t\tthrow new wfAPICallInvalidResponseException(sprintf(\/* translators: API call\/action\/endpoint. *\/ __(\"We received a data structure that is not the expected array when contacting the Wordfence scanning servers and calling the '%s' function.\", 'wordfence'), $action));\n\t\t}\n\n\t\t\/\/Only process key data for responses that include it\n\t\tif (array_key_exists('_isPaidKey', $dat))\n\t\t\t$this->processKeyData($dat);\n\t\t\n\t\tif (isset($dat['_touppChanged'])) {\n\t\t\twfConfig::set('touppPromptNeeded', wfUtils::truthyToBoolean($dat['_touppChanged']));\n\t\t}\n\n\t\tif (isset($dat['errorMsg'])) {\n\t\t\tthrow new wfAPICallErrorResponseException($dat['errorMsg']);\n\t\t}\n\n\t\treturn $dat;\n\t}\n\n\tprivate function processKeyData($dat) {\n\t\t$license = wfLicense::current()\n\t\t\t->setApiKey($this->APIKey)\n\t\t\t->setPaid($dat['_isPaidKey'])\n\t\t\t->setRemainingDays($dat['_keyExpDays'])\n\t\t\t->setType(array_key_exists('_licenseType', $dat) ? $dat['_licenseType'] : null);\n\n\t\tif (isset($dat['_isPaidKey']) && !isset($dat['errorMsg'])) {\n\t\t\twfConfig::setOrRemove('premiumAutoRenew', isset($dat['_autoRenew']) ? wfUtils::truthyToInt($dat['_autoRenew']) : null);\n\t\t\twfConfig::setOrRemove('premiumNextRenew', isset($dat['_nextRenewAttempt']) ? time() + $dat['_nextRenewAttempt'] * 86400 : null);\n\t\t\twfConfig::setOrRemove('premiumPaymentExpiring', isset($dat['_paymentExpiring']) ? wfUtils::truthyToInt($dat['_paymentExpiring']) : null);\n\t\t\twfConfig::setOrRemove('premiumPaymentExpired', isset($dat['_paymentExpired']) ? wfUtils::truthyToInt($dat['_paymentExpired']) : null);\n\t\t\twfConfig::setOrRemove('premiumPaymentMissing', isset($dat['_paymentMissing']) ? wfUtils::truthyToInt($dat['_paymentMissing']) : null);\n\t\t\twfConfig::setOrRemove('premiumPaymentHold', isset($dat['_paymentHold']) ? wfUtils::truthyToInt($dat['_paymentHold']) : null);\t\n\t\t}\n\t\t\n\t\t$hasKeyConflict = false;\n\t\tif (isset($dat['_hasKeyConflict'])) {\n\t\t\t$hasKeyConflict = ($dat['_hasKeyConflict'] == 1);\n\t\t\tif ($hasKeyConflict) {\n\t\t\t\tnew wfNotification(null, wfNotification::PRIORITY_HIGH_CRITICAL, '<a href=\"' . wfUtils::wpAdminURL('admin.php?page=Wordfence&subpage=global_options') . '\">' . esc_html__('The Wordfence license you\\'re using does not match this site\\'s address. Premium features are disabled.', 'wordfence') . '<\/a>', 'wfplugin_keyconflict', null, array(array('link' => 'https:\/\/www.wordfence.com\/manage-wordfence-api-keys\/', 'label' => 'Manage Keys')));\n\t\t\t\t$license->setConflicting();\n\t\t\t}\n\t\t}\n\t\t\n\t\t$license->setDeleted(isset($dat['_keyNoLongerValid']) && $dat['_keyNoLongerValid'] == 1);\n\t\t\n\t\tif (!$hasKeyConflict) {\n\t\t\t$license->setConflicting(false);\n\t\t\t$n = wfNotification::getNotificationForCategory('wfplugin_keyconflict');\n\t\t\tif ($n !== null) {\n\t\t\t\twordfence::status(1, 'info', 'Idle');\n\t\t\t\t$n->markAsRead();\n\t\t\t}\n\t\t}\n\n\t\t$license->save(isset($dat['errorMsg']));\n\t}\n\n\tprotected function getURL($url, $postParams = array(), $timeout = 900, $passThroughErrorMsg = false) {\n\t\twordfence::status(4, 'info', sprintf(\/* translators: API version. *\/ __(\"Calling Wordfence API v%s:\", 'wordfence'), WORDFENCE_API_VERSION) . $url);\n\n\t\tif (!function_exists('wp_remote_post')) {\n\t\t\trequire_once(ABSPATH . WPINC . 'http.php');\n\t\t}\n\n\t\t$ssl_verify = (bool) wfConfig::get('ssl_verify');\n\t\t$args = array(\n\t\t\t'timeout'    => $timeout,\n\t\t\t'user-agent' => \"Wordfence.com UA \" . (defined('WORDFENCE_VERSION') ? WORDFENCE_VERSION : '[Unknown version]'),\n\t\t\t'body'       => $postParams,\n\t\t\t'sslverify'  => $ssl_verify,\n\t\t\t'headers'\t => array('Referer' => false),\n\t\t);\n\t\tif (!$ssl_verify) {\n\t\t\t\/\/ Some versions of cURL will complain that SSL verification is disabled but the CA bundle was supplied.\n\t\t\t$args['sslcertificates'] = false;\n\t\t}\n\n\t\t$response = wp_remote_post($url, $args);\n\n\t\t$this->lastHTTPStatus = (int) wp_remote_retrieve_response_code($response);\n\n\t\tif (is_wp_error($response)) {\n\t\t\t$error_message = $response->get_error_message();\n\t\t\tif ($error_message) {\n\t\t\t\t$apiExceptionMessage = sprintf(\/* translators: Error message. *\/ __('There was an error connecting to the Wordfence scanning servers: %s', 'wordfence'), $error_message);\n\t\t\t} else {\n\t\t\t\t$apiExceptionMessage = __('There was an unknown error connecting to the Wordfence scanning servers.', 'wordfence');\n\t\t\t}\n\n\t\t\tthrow new wfAPICallFailedException($apiExceptionMessage);\n\t\t}\n\t\t\n\t\t$dateHeader = null;\n\t\tif (isset($response['headers']['date'])) {\n\t\t\t$dateHeader = $response['headers']['date'];\n\t\t}\n\t\t\n\t\tif (!empty($dateHeader) && (time() - wfConfig::get('timeoffset_wf_updated', 0) > 3600)) {\n\t\t\tif (function_exists('date_create_from_format')) {\n\t\t\t\t$dt = DateTime::createFromFormat('D, j M Y G:i:s O', $dateHeader);\n\t\t\t\t$timestamp = $dt->getTimestamp();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$timestamp = strtotime($dateHeader);\n\t\t\t}\n\t\t\t$offset = $timestamp - time();\n\t\t\twfConfig::set('timeoffset_wf', $offset);\n\t\t\twfConfig::set('timeoffset_wf_updated', time());\n\t\t}\n\n\t\tif (!empty($response['response']['code'])) {\n\t\t\t$this->lastHTTPStatus = (int) $response['response']['code'];\n\t\t}\n\t\t\n\t\tif ($this->lastHTTPStatus == 429) {\n\t\t\t$passThroughErrorMsg = true;\n\t\t}\n\n\t\tif (200 != $this->lastHTTPStatus) {\n\t\t\tif ($passThroughErrorMsg) {\n\t\t\t\t$content = wp_remote_retrieve_body($response);\n\t\t\t\tif (!is_wp_error($content) && ($dat = json_decode($content, true)) && isset($dat['errorMsg'])) {\n\t\t\t\t\treturn $content;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new wfAPICallFailedException(sprintf(\/* translators: HTTP status code. *\/__(\"The Wordfence scanning servers are currently unavailable. This may be for maintenance or a temporary outage. If this still occurs in an hour, please contact support. [%s]\", 'wordfence'), $this->lastHTTPStatus));\n\t\t}\n\n\t\t$content = wp_remote_retrieve_body($response);\n\t\treturn $content;\n\t}\n\n\tpublic function binCall($func, $postData) {\n\t\t$url = rtrim($this->getAPIURL(), '\/') . '\/v' . WORDFENCE_API_VERSION . '\/?' . $this->makeAPIQueryString() . '&action=' . $func;\n\n\t\t$data = $this->getURL($url, $postData);\n\n\t\tif (preg_match('\/\\{.*errorMsg\/', $data)) {\n\t\t\t$jdat = @json_decode($data, true);\n\t\t\tif (is_array($jdat) && $jdat['errorMsg']) {\n\t\t\t\tthrow new Exception($jdat['errorMsg']);\n\t\t\t}\n\t\t}\n\t\treturn array('code' => $this->lastHTTPStatus, 'data' => $data);\n\t}\n\n\tpublic static function generateSiteStats($wordpressVersion = null) {\n\t\tif ($wordpressVersion === null)\n\t\t\t$wordpressVersion = wfUtils::getWPVersion();\n\t\t$cv = null;\n\t\t$cs = null;\n\t\tif (function_exists('curl_version')) {\n\t\t\t$curl = curl_version();\n\t\t\t$cv = $curl['version'];\n\t\t\t$cs = $curl['ssl_version'];\n\t\t}\n\t\t\n\t\t$values = array(\n\t\t\t'wp' => $wordpressVersion,\n\t\t\t'wf' => WORDFENCE_VERSION,\n\t\t\t'ms' => (is_multisite() ? get_blog_count() : false),\n\t\t\t'h' => wfUtils::wpHomeURL(),\n\t\t\t'sslv' => function_exists('openssl_verify') && defined('OPENSSL_VERSION_NUMBER') ? OPENSSL_VERSION_NUMBER : null,\n\t\t\t'pv' => phpversion(),\n\t\t\t'pt' => php_sapi_name(),\n\t\t\t'cv' => $cv,\n\t\t\t'cs' => $cs,\n\t\t\t'sv' => (isset($_SERVER['SERVER_SOFTWARE']) ? $_SERVER['SERVER_SOFTWARE'] : null),\n\t\t\t'dv' => wfConfig::get('dbVersion', null),\n\t\t\t'lang' => get_site_option('WPLANG'),\n\t\t);\n\n\t\treturn wfUtils::base64url_encode(wfUtils::jsonEncodeSafely($values));\n\t}\n\n\tpublic function makeAPIQueryString() {\n\t\treturn self::buildQuery(array(\n\t\t\t'k' => $this->APIKey,\n\t\t\t's' => self::generateSiteStats($this->wordpressVersion)\n\t\t));\n\t}\n\n\tprivate function buildQuery($data) {\n\t\tif (version_compare(phpversion(), '5.1.2', '>=')) {\n\t\t\treturn http_build_query($data, '', '&'); \/\/arg_separator parameter was only added in PHP 5.1.2. We do this because some PHP.ini's have arg_separator.output set to '&amp;'\n\t\t} else {\n\t\t\treturn http_build_query($data);\n\t\t}\n\t}\n\n\tprivate function getAPIURL() {\n\t\treturn self::SSLEnabled() ? WORDFENCE_API_URL_SEC : WORDFENCE_API_URL_NONSEC;\n\t}\n\n\tpublic static function SSLEnabled() {\n\t\tif (!function_exists('wp_http_supports')) {\n\t\t\trequire_once(ABSPATH . WPINC . 'http.php');\n\t\t}\n\t\treturn wp_http_supports(array('ssl'));\n\t}\n\t\n\tpublic function getTextImageURL($text) {\n\t\t$apiURL = $this->getAPIURL();\n\t\treturn rtrim($apiURL, '\/') . '\/v' . WORDFENCE_API_VERSION . '\/?' . $this->makeAPIQueryString() . '&' . self::buildQuery(array('action' => 'image', 'txt' => base64_encode($text)));\n\t}\n}\n\nclass wfAPICallSSLUnavailableException extends Exception {\n}\n\nclass wfAPICallFailedException extends Exception {\n}\n\nclass wfAPICallInvalidResponseException extends Exception {\n}\n\nclass wfAPICallErrorResponseException extends Exception {\n}"},{"base":"plugins","rel":"wordfence\/lib\/wfUpdateCheck.php","ext":"php","size":27888,"mtime":1757312769,"type":"text","content":"<?php\n\nclass wfUpdateCheck {\n\tconst VULN_SEVERITY_CRITICAL = 90;\n\tconst VULN_SEVERITY_HIGH = 70;\n\tconst VULN_SEVERITY_MEDIUM = 40;\n\tconst VULN_SEVERITY_LOW = 1;\n\tconst VULN_SEVERITY_NONE = 0;\n\t\n\tconst LAST_UPDATE_CHECK_ERROR_KEY = 'lastUpdateCheckError';\n\tconst LAST_UPDATE_CHECK_ERROR_SLUG_KEY = 'lastUpdateCheckErrorSlug';\n\n\tprivate $needs_core_update = false;\n\tprivate $core_update_patch_available = false;\n\tprivate $core_earlier_branch = false;\n\tprivate $core_update_version = 0;\n\tprivate $core_update_patch_version = 0;\n\tprivate $plugin_updates = array();\n\tprivate $all_plugins = array();\n\tprivate $plugin_slugs = array();\n\tprivate $theme_updates = array();\n\tprivate $api = null;\n\t\n\t\/**\n\t * This hook exists because some plugins override their own update check and can return invalid \n\t * responses (e.g., null) due to logic errors or their update check server being unreachable. This\n\t * can interfere with our scan running the outdated plugins check. When scanning, we adjust the \n\t * response in those cases to be `false`, which causes WP to fall back to the plugin repo data.\n\t *\/\n\tpublic static function installPluginAPIFixer() {\n\t\tadd_filter('plugins_api', 'wfUpdateCheck::_pluginAPIFixer', 999, 3);\n\t}\n\t\n\tpublic static function _pluginAPIFixer($result, $action, $args) {\n\t\tif ($result === false || is_object($result) || is_array($result)) {\n\t\t\treturn $result;\n\t\t}\n\t\t\n\t\tif (!wfScanEngine::isScanRunning(true)) { \/\/Skip fixing if it's not the call the scanner made\n\t\t\treturn $result;\n\t\t}\n\t\t\n\t\t$slug = null;\n\t\tif (is_object($args) && isset($args->slug)) {\n\t\t\t$slug = $args->slug;\n\t\t}\n\t\telse if (is_array($args) && isset($args['slug'])) {\n\t\t\t$slug = $args['slug'];\n\t\t}\n\t\twordfence::status(2, 'info', sprintf(\/* translators: 1. Plugin slug. *\/ __('Outdated plugin scan adjusted invalid return value in plugins_api filter for %s', 'wordfence'), $slug));\n\t\treturn false;\n\t}\n\n\tpublic static function syncAllVersionInfo() {\n\t\t\/\/ Load the core\/plugin\/theme versions into the WAF configuration.\n\t\twfConfig::set('wordpressVersion', wfUtils::getWPVersion());\n\t\twfWAFConfig::set('wordpressVersion', wfUtils::getWPVersion(), wfWAF::getInstance(), 'synced');\n\n\t\tif (!function_exists('get_plugins')) {\n\t\t\trequire_once(ABSPATH . '\/wp-admin\/includes\/plugin.php');\n\t\t}\n\n\t\t$pluginVersions = array();\n\t\tforeach (get_plugins() as $pluginFile => $pluginData) {\n\t\t\t$slug = plugin_basename($pluginFile);\n\t\t\tif (preg_match('\/^([^\\\/]+)\\\/\/', $pluginFile, $matches)) {\n\t\t\t\t$slug = $matches[1];\n\t\t\t} else if (preg_match('\/^([^\\\/.]+)\\.php$\/', $pluginFile, $matches)) {\n\t\t\t\t$slug = $matches[1];\n\t\t\t}\n\t\t\t$pluginVersions[$slug] = isset($pluginData['Version']) ? $pluginData['Version'] : null;\n\t\t}\n\n\t\twfConfig::set_ser('wordpressPluginVersions', $pluginVersions);\n\t\twfWAFConfig::set('wordpressPluginVersions', $pluginVersions, wfWAF::getInstance(), 'synced');\n\n\t\tif (!function_exists('wp_get_themes')) {\n\t\t\trequire_once(ABSPATH . '\/wp-includes\/theme.php');\n\t\t}\n\n\t\t$themeVersions = array();\n\t\tforeach (wp_get_themes() as $slug => $theme) {\n\t\t\t$themeVersions[$slug] = isset($theme['Version']) ? $theme['Version'] : null;\n\t\t}\n\n\t\twfConfig::set_ser('wordpressThemeVersions', $themeVersions);\n\t\twfWAFConfig::set('wordpressThemeVersions', $themeVersions, wfWAF::getInstance(), 'synced');\n\t}\n\t\n\tpublic static function cvssScoreSeverity($score) {\n\t\t$intScore = floor($score * 10);\n\t\tif ($intScore >= self::VULN_SEVERITY_CRITICAL) {\n\t\t\treturn self::VULN_SEVERITY_CRITICAL;\n\t\t}\n\t\telse if ($intScore >= self::VULN_SEVERITY_HIGH) {\n\t\t\treturn self::VULN_SEVERITY_HIGH;\n\t\t}\n\t\telse if ($intScore >= self::VULN_SEVERITY_MEDIUM) {\n\t\t\treturn self::VULN_SEVERITY_MEDIUM;\n\t\t}\n\t\telse if ($intScore >= self::VULN_SEVERITY_LOW) {\n\t\t\treturn self::VULN_SEVERITY_LOW;\n\t\t}\n\t\t\n\t\treturn self::VULN_SEVERITY_NONE;\n\t}\n\t\n\tpublic static function cvssScoreSeverityLabel($score) {\n\t\t$severity = self::cvssScoreSeverity($score);\n\t\tswitch ($severity) {\n\t\t\tcase self::VULN_SEVERITY_CRITICAL:\n\t\t\t\treturn __('Critical', 'wordfence');\n\t\t\tcase self::VULN_SEVERITY_HIGH:\n\t\t\t\treturn __('High', 'wordfence');\n\t\t\tcase self::VULN_SEVERITY_MEDIUM:\n\t\t\t\treturn __('Medium', 'wordfence');\n\t\t\tcase self::VULN_SEVERITY_LOW:\n\t\t\t\treturn __('Low', 'wordfence');\n\t\t}\n\t\treturn __('None', 'wordfence');\n\t}\n\t\n\tpublic static function cvssScoreSeverityHexColor($score) {\n\t\t$severity = self::cvssScoreSeverity($score);\n\t\tswitch ($severity) {\n\t\t\tcase self::VULN_SEVERITY_CRITICAL:\n\t\t\t\treturn '#cc0500';\n\t\t\tcase self::VULN_SEVERITY_HIGH:\n\t\t\t\treturn '#df3d03';\n\t\t\tcase self::VULN_SEVERITY_MEDIUM:\n\t\t\t\treturn '#f9a009';\n\t\t\tcase self::VULN_SEVERITY_LOW:\n\t\t\t\treturn '#ffcb0d';\n\t\t}\n\t\treturn '#000000';\n\t}\n\t\n\tpublic static function cvssScoreSeverityClass($score) {\n\t\t$severity = self::cvssScoreSeverity($score);\n\t\tswitch ($severity) {\n\t\t\tcase self::VULN_SEVERITY_CRITICAL:\n\t\t\t\treturn 'wf-vulnerability-severity-critical';\n\t\t\tcase self::VULN_SEVERITY_HIGH:\n\t\t\t\treturn 'wf-vulnerability-severity-high';\n\t\t\tcase self::VULN_SEVERITY_MEDIUM:\n\t\t\t\treturn 'wf-vulnerability-severity-medium';\n\t\t\tcase self::VULN_SEVERITY_LOW:\n\t\t\t\treturn 'wf-vulnerability-severity-low';\n\t\t}\n\t\treturn 'wf-vulnerability-severity-none';\n\t}\n\t\n\tpublic function __construct() {\n\t\t$this->api = new wfAPI(wfConfig::get('apiKey'), wfUtils::getWPVersion());\n\t}\n\t\n\tpublic function __sleep() {\n\t\treturn array('needs_core_update', 'core_update_version', 'plugin_updates', 'all_plugins', 'plugin_slugs', 'theme_updates');\n\t}\n\t\n\tpublic function __wakeup() {\n\t\t$this->api = new wfAPI(wfConfig::get('apiKey'), wfUtils::getWPVersion());\n\t}\n\t\n\t\/**\n\t * @return bool\n\t *\/\n\tpublic function needsAnyUpdates() {\n\t\treturn $this->needsCoreUpdate() || count($this->getPluginUpdates()) > 0 || count($this->getThemeUpdates()) > 0;\n\t}\n\n\t\/**\n\t * Check for any core, plugin or theme updates.\n\t *\n\t * @return $this\n\t *\/\n\tpublic function checkAllUpdates($useCachedValued = true) {\n\t\tif (!$useCachedValued) {\n\t\t\twfConfig::remove(self::LAST_UPDATE_CHECK_ERROR_KEY);\n\t\t\twfConfig::remove(self::LAST_UPDATE_CHECK_ERROR_SLUG_KEY);\n\t\t}\n\t\t\n\t\treturn $this->checkCoreUpdates($useCachedValued)\n\t\t\t->checkPluginUpdates($useCachedValued)\n\t\t\t->checkThemeUpdates($useCachedValued);\n\t}\n\n\t\/**\n\t * Check if there is an update to the WordPress core.\n\t *\n\t * @return $this\n\t *\/\n\tpublic function checkCoreUpdates($useCachedValued = true) {\n\t\t$this->needs_core_update = false;\n\n\t\tif (!function_exists('wp_version_check')) {\n\t\t\trequire_once(ABSPATH . WPINC . '\/update.php');\n\t\t}\n\t\tif (!function_exists('get_preferred_from_update_core')) {\n\t\t\trequire_once(ABSPATH . 'wp-admin\/includes\/update.php');\n\t\t}\n\t\t\n\t\tinclude(ABSPATH . WPINC . '\/version.php'); \/** @var $wp_version *\/\n\t\t\n\t\t$availableUpdates = get_site_transient('update_core');\n\t\t\/**\n\t\t * Sample Structure:\n\t\t * \n\t\t * class stdClass#1 (4) {\n\t\t\t  public $updates =>\n\t\t\t  array(3) {\n\t\t\t\t[0] =>\n\t\t\t\tclass stdClass#2 (10) {\n\t\t\t\t  public $response => string(7) \"upgrade\"\n\t\t\t\t  public $version => string(5) \"6.4.2\"\n\t\t\t\t  ...\n\t\t\t\t}\n\t\t\t\t[1] =>\n\t\t\t\tclass stdClass#4 (11) {\n\t\t\t\t  public $response => string(10) \"autoupdate\"\n\t\t\t\t  public $version => string(5) \"6.4.2\"\n\t\t\t\t  ...\n\t\t\t\t}\n\t\t\t\t[2] =>\n\t\t\t\tclass stdClass#6 (11) {\n\t\t\t\t  public $response => string(10) \"autoupdate\"\n\t\t\t\t  public $version => string(5) \"6.3.2\"\n\t\t\t\t  ...\n\t\t\t\t}\n\t\t\t  }\n\t\t\t  public $last_checked => int(1703025218)\n\t\t\t  public $version_checked => string(5) \"6.3.1\"\n\t\t\t  public $translations => ...\n\t\t\t}\n\n\t\t *\/\n\t\t\n\t\tif ($useCachedValued && \n\t\t\tisset($availableUpdates->updates) && is_array($availableUpdates->updates) && \n\t\t\tisset($availableUpdates->last_checked) && 12 * HOUR_IN_SECONDS > (time() - $availableUpdates->last_checked) && $availableUpdates->version_checked == $wp_version) {\n\t\t\t\/\/Do nothing, use cached value\n\t\t}\n\t\telse {\n\t\t\twp_version_check();\n\t\t\t$availableUpdates = get_site_transient('update_core');\n\t\t}\n\t\t\n\t\tif (isset($availableUpdates->updates) && is_array($availableUpdates->updates)) {\n\t\t\t$current = wfUtils::parse_version($wp_version);\n\t\t\t$updates = $availableUpdates->updates;\n\t\t\tforeach ($updates as $update) {\n\t\t\t\tif (version_compare($update->version, $wp_version) <= 0) { continue; } \/\/Array will contain the reinstall info for the current version if non-prerelease or the last production version if prerelease, skip\n\t\t\t\t\n\t\t\t\tif (version_compare($update->version, $this->core_update_version) > 0) {\n\t\t\t\t\t$this->needs_core_update = true;\n\t\t\t\t\t$this->core_update_version = $update->version;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t$checking = wfUtils::parse_version($update->version);\n\t\t\t\tif ($checking[wfUtils::VERSION_MAJOR] == $current[wfUtils::VERSION_MAJOR] && $checking[wfUtils::VERSION_MINOR] == $current[wfUtils::VERSION_MINOR] && $checking[wfUtils::VERSION_PATCH] > $current[wfUtils::VERSION_PATCH]) {\n\t\t\t\t\t$this->core_update_patch_available = true;\n\t\t\t\t\t$this->core_update_patch_version = $update->version;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif ($this->needs_core_update && $this->core_update_patch_available && version_compare($this->core_update_version, $this->core_update_patch_version) === 0) { \/\/Patch and edge update are the same, clear patch values\n\t\t\t\t$this->core_update_patch_available = false;\n\t\t\t\t$this->core_update_patch_version = 0;\n\t\t\t}\n\t\t\t\n\t\t\tif ($this->needs_core_update) {\n\t\t\t\t$checking = wfUtils::parse_version($this->core_update_version);\n\t\t\t\t$this->core_earlier_branch = ($checking[wfUtils::VERSION_MAJOR] > $current[wfUtils::VERSION_MAJOR] || $checking[wfUtils::VERSION_MINOR] > $current[wfUtils::VERSION_MINOR]);\n\t\t\t}\n\t\t}\n\n\t\treturn $this;\n\t}\n\n\tprivate function checkPluginFile($plugin, &$installedPlugins) {\n\t\tif (!array_key_exists($plugin, $installedPlugins))\n\t\t\treturn null;\n\t\t$file = wfUtils::getPluginBaseDir() . $plugin;\n\t\tif (!file_exists($file)) {\n\t\t\tunset($installedPlugins[$plugin]);\n\t\t\treturn null;\n\t\t}\n\t\treturn $file;\n\t}\n\n\tprivate function initializePluginUpdateData($plugin, &$installedPlugins, $checkVulnerabilities, $populator = null) {\n\t\t$file = $this->checkPluginFile($plugin, $installedPlugins);\n\t\tif ($file === null)\n\t\t\treturn null;\n\t\t$data = $installedPlugins[$plugin];\n\t\t$data['pluginFile'] = $file;\n\t\tif ($populator !== null)\n\t\t\t$populator($data, $file);\n\t\tif (!array_key_exists('slug', $data) || empty($data['slug']))\n\t\t\t$data['slug'] = $this->extractSlug($plugin);\n\t\t$slug = $data['slug'];\n\t\tif ($slug !== null) {\n\t\t\t$vulnerable = $checkVulnerabilities ? $this->isPluginVulnerable($slug, $data['Version']) : null;\n\t\t\t$data['vulnerable'] = !empty($vulnerable);\n\t\t\tif ($data['vulnerable']) {\n\t\t\t\tif (isset($vulnerable['link']) && is_string($vulnerable['link'])) { $data['vulnerabilityLink'] = $vulnerable['link']; }\n\t\t\t\tif (isset($vulnerable['score'])) {\n\t\t\t\t\t$data['cvssScore'] = number_format(floatval($vulnerable['score']), 1);\n\t\t\t\t\t$data['severityColor'] = self::cvssScoreSeverityHexColor($data['cvssScore']);\n\t\t\t\t\t$data['severityLabel'] = self::cvssScoreSeverityLabel($data['cvssScore']);\n\t\t\t\t\t$data['severityClass'] = self::cvssScoreSeverityClass($data['cvssScore']);\n\t\t\t\t}\n\t\t\t\tif (isset($vulnerable['vector']) && is_string($vulnerable['vector'])) { $data['cvssVector'] = $vulnerable['vector']; }\n\t\t\t}\n\t\t\t$this->plugin_slugs[] = $slug;\n\t\t\t$this->all_plugins[$slug] = $data;\n\t\t}\n\t\tunset($installedPlugins[$plugin]);\n\t\treturn $data;\n\t}\n\n\tpublic function extractSlug($plugin, $data = null) {\n\t\t$slug = null;\n\t\tif (is_array($data) && array_key_exists('slug', $data))\n\t\t\t$slug = $data['slug'];\n\t\tif (!is_string($slug) || empty($slug)) {\n\t\t\tif (preg_match('\/^([^\\\/]+)\\\/\/', $plugin, $matches)) {\n\t\t\t\t$slug = $matches[1];\n\t\t\t}\n\t\t\telse if (preg_match('\/^([^\\\/.]+)\\.php$\/', $plugin, $matches)) {\n\t\t\t\t$slug = $matches[1];\n\t\t\t}\n\t\t}\n\t\treturn $slug;\n\t}\n\n\tprivate static function requirePluginsApi() {\n\t\tif (!function_exists('plugins_api'))\n\t\t\trequire_once(ABSPATH . '\/wp-admin\/includes\/plugin-install.php');\n\t}\n\n\tprivate function fetchPluginUpdates($useCache = true) {\n\t\t$update_plugins = get_site_transient('update_plugins');\n\t\tif ($useCache && isset($update_plugins->last_checked) && 12 * HOUR_IN_SECONDS > (time() - $update_plugins->last_checked)) \/\/Duplicate of _maybe_update_plugins, which is a private call\n\t\t\treturn $update_plugins;\n\t\tif (!function_exists('wp_update_plugins'))\n\t\t\trequire_once(ABSPATH . WPINC . '\/update.php');\n\t\ttry {\n\t\t\twp_update_plugins();\n\t\t}\n\t\tcatch (Exception $e) {\n\t\t\twfConfig::set(self::LAST_UPDATE_CHECK_ERROR_KEY, $e->getMessage(), false);\n\t\t\twfConfig::remove(self::LAST_UPDATE_CHECK_ERROR_SLUG_KEY);\n\t\t\terror_log('Caught exception while attempting to refresh plugin update status: ' . $e->getMessage());\n\t\t}\n\t\tcatch (Throwable $t) {\n\t\t\twfConfig::set(self::LAST_UPDATE_CHECK_ERROR_KEY, $t->getMessage(), false);\n\t\t\twfConfig::remove(self::LAST_UPDATE_CHECK_ERROR_SLUG_KEY);\n\t\t\terror_log('Caught error while attempting to refresh plugin update status: ' . $t->getMessage());\n\t\t}\n\t\treturn get_site_transient('update_plugins');\n\t}\n\n\t\/**\n\t * Check if any plugins need an update.\n\t *\n\t * @param bool $checkVulnerabilities whether or not to check for vulnerabilities while checking updates\n\t *\n\t * @return $this\n\t *\/\n\tpublic function checkPluginUpdates($useCachedValued = true, $checkVulnerabilities = true) {\n\t\tif($checkVulnerabilities)\n\t\t\t$this->plugin_updates = array();\n\n\t\tself::requirePluginsApi();\n\n\t\t$update_plugins = $this->fetchPluginUpdates($useCachedValued);\n\t\t\n\t\t\/\/Get the full plugin list\n\t\tif (!function_exists('get_plugins')) {\n\t\t\trequire_once(ABSPATH . '\/wp-admin\/includes\/plugin.php');\n\t\t}\n\t\t$installedPlugins = get_plugins();\n\n\t\t$context = $this;\n\n\t\tif ($update_plugins && !empty($update_plugins->response)) {\n\t\t\tforeach ($update_plugins->response as $plugin => $vals) {\n\t\t\t\t$data = $this->initializePluginUpdateData($plugin, $installedPlugins, $checkVulnerabilities, function (&$data, $file) use ($context, $plugin, $vals) {\n\t\t\t\t\t$vals = (array) $vals;\n\t\t\t\t\t$data['slug'] = $context->extractSlug($plugin, $vals);\n\t\t\t\t\t$data['newVersion'] = (isset($vals['new_version']) ? $vals['new_version'] : 'Unknown');\n\t\t\t\t\t$data['wpURL'] = (isset($vals['url']) ? rtrim($vals['url'], '\/') : null);\n\t\t\t\t\t$data['updateAvailable'] = true;\n\t\t\t\t});\n\n\t\t\t\tif($checkVulnerabilities && $data !== null)\n\t\t\t\t\t$this->plugin_updates[] = $data;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\/\/We have to grab the slugs from the update response because no built-in function exists to return the true slug from the local files\n\t\tif ($update_plugins && !empty($update_plugins->no_update)) {\n\t\t\tforeach ($update_plugins->no_update as $plugin => $vals) {\n\t\t\t\t$this->initializePluginUpdateData($plugin, $installedPlugins, $checkVulnerabilities, function (&$data, $file) use ($context, $plugin, $vals) {\n\t\t\t\t\t$vals = (array) $vals;\n\t\t\t\t\t$data['slug'] = $context->extractSlug($plugin, $vals);\n\t\t\t\t\t$data['wpURL'] = (isset($vals['url']) ? rtrim($vals['url'], '\/') : null);\n\t\t\t\t});\n\t\t\t}\t\n\t\t}\n\t\t\n\t\t\/\/Get the remaining plugins (not in the wordpress.org repo for whatever reason)\n\t\tforeach ($installedPlugins as $plugin => $data) {\n\t\t\t$data = $this->initializePluginUpdateData($plugin, $installedPlugins, $checkVulnerabilities);\n\t\t}\n\n\t\treturn $this;\n\t}\n\n\t\/**\n\t * Check if any themes need an update.\n\t *\n\t * @param bool $checkVulnerabilities whether or not to check for vulnerabilities while checking for updates\n\t *\n\t * @return $this\n\t *\/\n\tpublic function checkThemeUpdates($useCachedValued = true, $checkVulnerabilities = true) {\n\t\tif($checkVulnerabilities)\n\t\t\t$this->theme_updates = array();\n\n\t\tif (!function_exists('wp_update_themes')) {\n\t\t\trequire_once(ABSPATH . WPINC . '\/update.php');\n\t\t}\n\t\t\n\t\t$update_themes = get_site_transient('update_themes');\n\t\tif ($useCachedValued && isset($update_themes->last_checked) && 12 * HOUR_IN_SECONDS > (time() - $update_themes->last_checked)) { \/\/Duplicate of _maybe_update_themes, which is a private call\n\t\t\t\/\/Do nothing, use cached value\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\twp_update_themes();\n\t\t\t}\n\t\t\tcatch (Exception $e) {\n\t\t\t\twfConfig::set(self::LAST_UPDATE_CHECK_ERROR_KEY, $e->getMessage(), false);\n\t\t\t\terror_log('Caught exception while attempting to refresh theme update status: ' . $e->getMessage());\n\t\t\t}\n\t\t\tcatch (Throwable $t) {\n\t\t\t\twfConfig::set(self::LAST_UPDATE_CHECK_ERROR_KEY, $t->getMessage(), false);\n\t\t\t\terror_log('Caught error while attempting to refresh theme update status: ' . $t->getMessage());\n\t\t\t}\n\t\t\t\n\t\t\t$update_themes = get_site_transient('update_themes');\n\t\t}\n\n\t\tif ($update_themes && (!empty($update_themes->response)) && $checkVulnerabilities) {\n\t\t\tif (!function_exists('wp_get_themes')) {\n\t\t\t\trequire_once(ABSPATH . '\/wp-includes\/theme.php');\n\t\t\t}\n\t\t\t$themes = wp_get_themes();\n\t\t\tforeach ($update_themes->response as $theme => $vals) {\n\t\t\t\tforeach ($themes as $name => $themeData) {\n\t\t\t\t\tif (strtolower($name) == $theme) {\n\t\t\t\t\t\t$vulnerable = false;\n\t\t\t\t\t\tif (isset($themeData['Version'])) {\n\t\t\t\t\t\t\t$vulnerable = $this->isThemeVulnerable($theme, $themeData['Version']);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t$data = array(\n\t\t\t\t\t\t\t'newVersion' => (isset($vals['new_version']) ? $vals['new_version'] : 'Unknown'),\n\t\t\t\t\t\t\t'package'    => (isset($vals['package']) ? $vals['package'] : null),\n\t\t\t\t\t\t\t'URL'        => (isset($vals['url']) ? $vals['url'] : null),\n\t\t\t\t\t\t\t'Name'       => $themeData['Name'],\n\t\t\t\t\t\t\t'name'       => $themeData['Name'],\n\t\t\t\t\t\t\t'version'    => $themeData['Version'],\n\t\t\t\t\t\t\t'vulnerable' => $vulnerable\n\t\t\t\t\t\t);\n\t\t\t\t\t\t\n\t\t\t\t\t\t$data['vulnerable'] = !empty($vulnerable);\n\t\t\t\t\t\tif ($data['vulnerable']) {\n\t\t\t\t\t\t\tif (isset($vulnerable['link']) && is_string($vulnerable['link'])) { $data['vulnerabilityLink'] = $vulnerable['link']; }\n\t\t\t\t\t\t\tif (isset($vulnerable['score'])) {\n\t\t\t\t\t\t\t\t$data['cvssScore'] = number_format(floatval($vulnerable['score']), 1);\n\t\t\t\t\t\t\t\t$data['severityColor'] = self::cvssScoreSeverityHexColor($data['cvssScore']);\n\t\t\t\t\t\t\t\t$data['severityLabel'] = self::cvssScoreSeverityLabel($data['cvssScore']);\n\t\t\t\t\t\t\t\t$data['severityClass'] = self::cvssScoreSeverityClass($data['cvssScore']);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (isset($vulnerable['vector']) && is_string($vulnerable['vector'])) { $data['cvssVector'] = $vulnerable['vector']; }\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t$this->theme_updates[] = $data;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn $this;\n\t}\n\t\n\t\/**\n\t * @param bool $initial if true, treat as the initial scan run\n\t *\/\n\tpublic function checkCoreVulnerabilities($initial = false) {\n\t\t$vulnerabilities = array();\n\t\t\n\t\tinclude(ABSPATH . WPINC . '\/version.php'); \/** @var $wp_version *\/\n\t\t\n\t\t$core = array(\n\t\t\t'current' => $wp_version,\n\t\t);\n\t\t\n\t\tif ($this->needs_core_update) {\n\t\t\t$core['edge'] = $this->core_update_version;\n\t\t}\n\t\t\n\t\tif ($this->core_update_patch_available) {\n\t\t\t$core['patch'] = $this->core_update_patch_version;\n\t\t}\n\t\t\n\t\ttry {\n\t\t\t$result = $this->api->call('core_vulnerability_check', array(), array(\n\t\t\t\t'core' => json_encode($core),\n\t\t\t));\n\t\t\t\n\t\t\twfConfig::set_ser('vulnerabilities_core', $result['vulnerable'], false, wfConfig::DONT_AUTOLOAD); \/\/Will have the index `current` with possibly `edge` and `patch` depending on what was provided above\n\t\t}\n\t\tcatch (Exception $e) {\n\t\t\t\/\/Do nothing\n\t\t}\n\t}\n\n\tprivate function initializePluginVulnerabilityData($plugin, &$installedPlugins, &$records, $values = null, $update = false) {\n\t\t$file = $this->checkPluginFile($plugin, $installedPlugins);\n\t\tif ($file === null)\n\t\t\treturn null;\n\t\t$data = $installedPlugins[$plugin];\n\t\t$record = array(\n\t\t\t'slug' => $this->extractSlug($plugin, $values),\n\t\t\t'fromVersion' => isset($data['Version']) ? $data['Version'] : 'Unknown',\n\t\t\t'vulnerable' => false\n\t\t);\n\t\tif ($update && is_array($values))\n\t\t\t$record['toVersion'] = isset($values['new_version']) ? $values['new_version'] : 'Unknown';\n\t\t$records[] = $record;\n\t\tunset($installedPlugins[$plugin]);\n\t}\n\n\t\/**\n\t * @param bool $initial if true, treat as the initial scan run\n\t *\/\n\tpublic function checkPluginVulnerabilities($initial=false) {\n\n\t\tself::requirePluginsApi();\n\t\t\n\t\t$vulnerabilities = array();\n\t\t\n\t\t\/\/Get the full plugin list\n\t\tif (!function_exists('get_plugins')) {\n\t\t\trequire_once(ABSPATH . '\/wp-admin\/includes\/plugin.php');\n\t\t}\n\t\t$installedPlugins = get_plugins();\n\t\t\n\t\t\/\/Get the info for plugins on wordpress.org\n\t\t$update_plugins = $this->fetchPluginUpdates();\n\t\tif ($update_plugins) {\n\t\t\tif (!empty($update_plugins->response)) {\n\t\t\t\tforeach ($update_plugins->response as $plugin => $vals) {\n\t\t\t\t\t$this->initializePluginVulnerabilityData($plugin, $installedPlugins, $vulnerabilities, (array) $vals, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (!empty($update_plugins->no_update)) {\n\t\t\t\tforeach ($update_plugins->no_update as $plugin => $vals) {\n\t\t\t\t\t$this->initializePluginVulnerabilityData($plugin, $installedPlugins, $vulnerabilities, (array) $vals);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\/\/Get the remaining plugins (not in the wordpress.org repo for whatever reason)\n\t\tforeach ($installedPlugins as $plugin => $data) {\n\t\t\t$this->initializePluginVulnerabilityData($plugin, $installedPlugins, $vulnerabilities, $data);\n\t\t}\n\t\t\n\t\tif (count($vulnerabilities) > 0) {\n\t\t\ttry {\n\t\t\t\t$result = $this->api->call('plugin_vulnerability_check', array(), array(\n\t\t\t\t\t'plugins' => json_encode($vulnerabilities),\n\t\t\t\t));\n\t\t\t\t\n\t\t\t\tforeach ($vulnerabilities as &$v) {\n\t\t\t\t\t$vulnerableList = $result['vulnerable'];\n\t\t\t\t\tforeach ($vulnerableList as $r) {\n\t\t\t\t\t\tif ($r['slug'] == $v['slug']) {\n\t\t\t\t\t\t\t$v['vulnerable'] = !!$r['vulnerable'];\n\t\t\t\t\t\t\tif (isset($r['link'])) {\n\t\t\t\t\t\t\t\t$v['link'] = $r['link'];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (isset($r['score'])) {\n\t\t\t\t\t\t\t\t$v['score'] = $r['score'];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (isset($r['vector'])) {\n\t\t\t\t\t\t\t\t$v['vector'] = $r['vector'];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception $e) {\n\t\t\t\t\/\/Do nothing\n\t\t\t}\n\t\t\t\n\t\t\twfConfig::set_ser('vulnerabilities_plugin', $vulnerabilities, false, wfConfig::DONT_AUTOLOAD);\n\t\t}\n\t}\n\n\t\/**\n\t * @param bool $initial whether or not this is the initial run\n\t *\/\n\tpublic function checkThemeVulnerabilities($initial = false) {\n\t\tif (!function_exists('wp_update_themes')) {\n\t\t\trequire_once(ABSPATH . WPINC . '\/update.php');\n\t\t}\n\t\t\n\t\tself::requirePluginsApi();\n\t\t\n\t\t$this->checkThemeUpdates(!$initial, false);\n\t\t$update_themes = get_site_transient('update_themes');\n\t\t\n\t\t$vulnerabilities = array();\n\t\tif ($update_themes && !empty($update_themes->response)) {\n\t\t\tif (!function_exists('get_plugin_data'))\n\t\t\t{\n\t\t\t\trequire_once(ABSPATH . '\/wp-admin\/includes\/plugin.php');\n\t\t\t}\n\t\t\t\n\t\t\tforeach ($update_themes->response as $themeSlug => $vals) {\n\t\t\t\t\n\t\t\t\t$valsArray = (array) $vals;\n\t\t\t\t$theme = wp_get_theme($themeSlug);\n\t\t\t\t\n\t\t\t\t$record = array();\n\t\t\t\t$record['slug'] = $themeSlug;\n\t\t\t\t$record['toVersion'] = (isset($valsArray['new_version']) ? $valsArray['new_version'] : 'Unknown');\n\t\t\t\t$record['fromVersion'] = $theme->version;\n\t\t\t\t$record['vulnerable'] = false;\n\t\t\t\t$vulnerabilities[] = $record;\n\t\t\t}\n\t\t\t\n\t\t\ttry {\n\t\t\t\t$result = $this->api->call('theme_vulnerability_check', array(), array(\n\t\t\t\t\t'themes' => json_encode($vulnerabilities),\n\t\t\t\t));\n\t\t\t\t\n\t\t\t\tforeach ($vulnerabilities as &$v) {\n\t\t\t\t\t$vulnerableList = $result['vulnerable'];\n\t\t\t\t\tforeach ($vulnerableList as $r) {\n\t\t\t\t\t\tif ($r['slug'] == $v['slug']) {\n\t\t\t\t\t\t\t$v['vulnerable'] = !!$r['vulnerable'];\n\t\t\t\t\t\t\tif (isset($r['link'])) {\n\t\t\t\t\t\t\t\t$v['link'] = $r['link'];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (isset($r['score'])) {\n\t\t\t\t\t\t\t\t$v['score'] = $r['score'];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (isset($r['vector'])) {\n\t\t\t\t\t\t\t\t$v['vector'] = $r['vector'];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception $e) {\n\t\t\t\t\/\/Do nothing\n\t\t\t}\n\t\t\t\n\t\t\twfConfig::set_ser('vulnerabilities_theme', $vulnerabilities, false, wfConfig::DONT_AUTOLOAD);\n\t\t}\n\t}\n\t\n\t\/**\n\t * Returns whether the core version is vulnerable. Available $which values are `current` for the version running now,\n\t * `patch` for the patch update (if available), and `edge` for the most recent update available. `patch` and `edge`\n\t * are accurate only if an update is actually available and will return false otherwise.\n\t * \n\t * @param string $which\n\t * @return bool\n\t *\/\n\tpublic function isCoreVulnerable($which = 'current') {\n\t\tstatic $_vulnerabilitiesRefreshed = false;\n\t\t$vulnerabilities = wfConfig::get_ser('vulnerabilities_core', null);\n\t\tif ($vulnerabilities === null) {\n\t\t\tif (!$_vulnerabilitiesRefreshed) {\n\t\t\t\t$this->checkCoreVulnerabilities(true);\n\t\t\t\t$_vulnerabilitiesRefreshed = true;\n\t\t\t}\n\t\t\t\n\t\t\t\/\/Verify that we got a valid response, if not, avoid infinite recursion\n\t\t\t$vulnerabilities = wfConfig::get_ser('vulnerabilities_core', null);\n\t\t\tif ($vulnerabilities === null) {\n\t\t\t\twordfence::status(4, 'error', __(\"Failed obtaining core vulnerability data, skipping check.\", 'wordfence'));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\treturn $this->isCoreVulnerable($which);\n\t\t}\n\t\t\n\t\tif (!isset($vulnerabilities[$which])) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn !!$vulnerabilities[$which]['vulnerable'];\n\t}\n\t\n\tpublic function isPluginVulnerable($slug, $version) {\n\t\treturn $this->_isSlugVulnerable('vulnerabilities_plugin', $slug, $version, function(){ $this->checkPluginVulnerabilities(true); });\n\t}\n\t\n\tpublic function isThemeVulnerable($slug, $version) {\n\t\treturn $this->_isSlugVulnerable('vulnerabilities_theme', $slug, $version, function(){ $this->checkThemeVulnerabilities(true); });\n\t}\n\t\n\tprivate function _isSlugVulnerable($vulnerabilitiesKey, $slug, $version, $populateVulnerabilities=null) {\n\t\tstatic $_vulnerabilitiesRefreshed = array();\n\t\t$vulnerabilities = wfConfig::get_ser($vulnerabilitiesKey, null);\n\t\tif ( $vulnerabilities === null) {\n\t\t\tif (is_callable($populateVulnerabilities)) {\n\t\t\t\tif (!isset($_vulnerabilitiesRefreshed[$vulnerabilitiesKey])) {\n\t\t\t\t\t$populateVulnerabilities();\n\t\t\t\t\t$_vulnerabilitiesRefreshed[$vulnerabilitiesKey] = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t$vulnerabilities = wfConfig::get_ser($vulnerabilitiesKey, null);\n\t\t\t\tif ($vulnerabilities === null) {\n\t\t\t\t\twordfence::status(4, 'error', __(\"Failed obtaining vulnerability data, skipping check.\", 'wordfence'));\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn $this->_isSlugVulnerable($vulnerabilitiesKey, $slug, $version);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tforeach ($vulnerabilities as $v) {\n\t\t\tif ($v['slug'] == $slug) {\n\t\t\t\tif (\n\t\t\t\t\t($v['fromVersion'] == 'Unknown' && $v['toVersion'] == 'Unknown') ||\n\t\t\t\t\t((!isset($v['toVersion']) || $v['toVersion'] == 'Unknown') && version_compare($version, $v['fromVersion']) >= 0) ||\n\t\t\t\t\t($v['fromVersion'] == 'Unknown' && isset($v['toVersion']) && version_compare($version, $v['toVersion']) < 0) ||\n\t\t\t\t\t(version_compare($version, $v['fromVersion']) >= 0 && isset($v['toVersion']) && version_compare($version, $v['toVersion']) < 0)\n\t\t\t\t) {\n\t\t\t\t\tif ($v['vulnerable']) { return $v; }\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t\/**\n\t * @return boolean\n\t *\/\n\tpublic function needsCoreUpdate() {\n\t\treturn $this->needs_core_update;\n\t}\n\n\t\/**\n\t * @return string\n\t *\/\n\tpublic function getCoreUpdateVersion() {\n\t\treturn $this->core_update_version;\n\t}\n\t\n\t\/**\n\t * Returns true if there is a patch version available for the site's current minor branch and the site is not on\n\t * the most recent minor branch (e.g., a backported security update).\n\t * \n\t * Example: suppose the site is currently on 4.1.37. This will return true and `getCoreUpdatePatchVersion` will \n\t * return 4.1.39. `getCoreUpdateVersion` will return 6.4.2 (as of writing this comment). \n\t * \n\t * @return bool\n\t *\/\n\tpublic function coreUpdatePatchAvailable() {\n\t\treturn $this->core_update_patch_available;\n\t}\n\t\n\t\/**\n\t * The version number for the patch update if available.\n\t * \n\t * @return string\n\t *\/\n\tpublic function getCoreUpdatePatchVersion() {\n\t\treturn $this->core_update_patch_version;\n\t}\n\t\n\t\/**\n\t * Returns whether or not the current core version is on a major or minor release earlier than the current available \n\t * edge update.\n\t * \n\t * @return bool\n\t *\/\n\tpublic function getCoreEarlierBranch() {\n\t\treturn $this->core_earlier_branch;\n\t}\n\n\t\/**\n\t * @return array\n\t *\/\n\tpublic function getPluginUpdates() {\n\t\treturn $this->plugin_updates;\n\t}\n\t\n\t\/**\n\t * @return array\n\t *\/\n\tpublic function getAllPlugins() {\n\t\treturn $this->all_plugins;\n\t}\n\t\n\t\/**\n\t * @return array\n\t *\/\n\tpublic function getPluginSlugs() {\n\t\treturn $this->plugin_slugs;\n\t}\n\n\t\/**\n\t * @return array\n\t *\/\n\tpublic function getThemeUpdates() {\n\t\treturn $this->theme_updates;\n\t}\n}"},{"base":"plugins","rel":"wordfence\/lib\/menu_support.php","ext":"php","size":18243,"mtime":1757312769,"type":"text","content":"<?php\nif (!defined('WORDFENCE_VERSION')) { exit; }\nif (!wfOnboardingController::shouldShowAttempt3() && wfConfig::get('touppPromptNeeded')) {\n\techo wfView::create('gdpr\/banner')->render();\n}\n\n$support = @json_decode(wfConfig::get('supportContent'), true);\nif (!is_array($support)) { $support = array(); }\n?>\n\t<div class=\"wrap wordfence\">\n\t\t<div class=\"wf-container-fluid\">\n\t\t\t<div class=\"wf-row\">\n\t\t\t\t<div class=\"wf-col-xs-12\">\n\t\t\t\t\t<div class=\"wp-header-end\"><\/div>\n\t\t\t\t\t<?php\n\t\t\t\t\techo wfView::create('common\/section-title', array(\n\t\t\t\t\t\t'title' => __('Help', 'wordfence'),\n\t\t\t\t\t\t'showIcon' => true,\n\t\t\t\t\t))->render();\n\t\t\t\t\t?>\n\t\t\t\t<\/div>\n\t\t\t\t<div class=\"wf-col-xs-12\">\n\t\t\t\t\t<div class=\"wf-block wf-active\">\n\t\t\t\t\t\t<div class=\"wf-block-content\">\n\t\t\t\t\t\t\t<ul class=\"wf-block-list\">\n\t\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t\t<ul class=\"wf-block-list wf-block-list-horizontal\">\n\t\t\t\t\t\t\t\t\t\t<li class=\"wf-flex-vertical\">\n\t\t\t\t\t\t\t\t\t\t<?php if (wfLicense::current()->isPaidAndCurrent()): ?>\n\t\t\t\t\t\t\t\t\t\t\t<h3><?php esc_html_e('Premium Support', 'wordfence'); ?><\/h3>\n\t\t\t\t\t\t\t\t\t\t\t<p class=\"wf-center\">\n\t\t\t\t\t\t\t\t\t\t\t\t<?php if (wfLicense::current()->isResponse()): ?>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<?php esc_html_e('As a Wordfence Response customer you are entitled to hands-on priority support 24 hours a day 365 days a year. Our incident response team is available out of hours to handle urgent issues and security incidents. Our customer support team is available during business hours (Monday to Friday, 6am to 5pm Pacific and 9am to 8pm Eastern time) for product assistance. Both teams can sign-in to your site to assist, on request.', 'wordfence'); ?>\n\t\t\t\t\t\t\t\t\t\t\t\t<?php elseif (wfLicense::current()->isCare()): ?>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<?php esc_html_e('As a Wordfence Care customer you are entitled to hands-on priority support and have access to our incident response team. Our senior support engineers and incident response team respond to requests quickly within business hours (Monday to Friday, 6am to 5pm Pacific and 9am to 8pm Eastern time) and can sign-in to your site on request to assist with complex issues.', 'wordfence'); ?>\n\t\t\t\t\t\t\t\t\t\t\t\t<?php else: ?>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<?php esc_html_e('As a Wordfence Premium customer you\\'re entitled to paid support via our ticketing system. Our senior support engineers respond to Premium tickets during regular business hours (Monday to Friday, 6am to 5pm Pacific and 9am to 8pm Eastern time) and have a direct line to our QA and development teams.', 'wordfence') ?>\n\t\t\t\t\t\t\t\t\t\t\t\t<?php endif ?>\n\t\t\t\t\t\t\t\t\t\t\t<\/p>\n\t\t\t\t\t\t\t\t\t\t\t<p>\n\t\t\t\t\t\t\t\t\t\t\t\t<a href=\"<?php echo esc_attr(wfLicense::current()->getSupportUrl('helpPageSupport')) ?>\" target=\"_blank\" rel=\"noopener noreferrer\" class=\"wf-btn wf-btn-primary wf-btn-callout-subtle\"><?php esc_html_e('Get Help', 'wordfence'); ?><span class=\"screen-reader-text\"> (<?php esc_html_e('opens in new tab', 'wordfence') ?>)<\/span><\/a>\n\t\t\t\t\t\t\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t\t\t\t\t\t<?php if (wfLicense::current()->isBelowCare()): ?>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<a href=\"https:\/\/www.wordfence.com\/gnl1helpPageCare\/products\/wordfence-care\/\" target=\"_blank\" rel=\"noopener noreferrer\"><?php esc_html_e('Upgrade to hands-on support with Wordfence Care', 'wordfence') ?><\/a>\n\t\t\t\t\t\t\t\t\t\t\t\t<?php elseif (wfLicense::current()->isBelowResponse()): ?>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<a href=\"https:\/\/www.wordfence.com\/gnl1helpPageResponse\/products\/wordfence-response\/\" target=\"_blank\" rel=\"noopener noreferrer\"><?php esc_html_e('Upgrade to a 24\/7 1-hour response time with Wordfence Response', 'wordfence') ?><\/a>\n\t\t\t\t\t\t\t\t\t\t\t\t<?php endif ?>\n\t\t\t\t\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t\t\t\t\t<\/p>\n\t\t\t\t\t\t\t\t\t\t<?php else: ?>\n\t\t\t\t\t\t\t\t\t\t\t<h3><?php esc_html_e('Upgrade Now to Access Premium Support', 'wordfence'); ?><\/h3>\n\t\t\t\t\t\t\t\t\t\t\t<p class=\"wf-center\"><?php echo wp_kses(__('Our senior support engineers <strong>respond to Premium tickets within a few hours<\/strong> on average and have a direct line to our QA and development teams.', 'wordfence'), array('strong'=>array())); ?><\/p>\n\t\t\t\t\t\t\t\t\t\t\t<p><a href=\"https:\/\/www.wordfence.com\/gnl1supportUpgrade\/wordfence-signup\/\" target=\"_blank\" rel=\"noopener noreferrer\" class=\"wf-btn wf-btn-primary wf-btn-callout-subtle\"><?php esc_html_e('Upgrade to Premium', 'wordfence'); ?><span class=\"screen-reader-text\"> (<?php esc_html_e('opens in new tab', 'wordfence') ?>)<\/span><\/a><\/p>\n\t\t\t\t\t\t\t\t\t\t<?php endif; ?>\n\t\t\t\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t\t\t\t<li class=\"wf-flex-vertical\">\n\t\t\t\t\t\t\t\t\t\t\t<h3><?php esc_html_e('Free Support', 'wordfence'); ?><\/h3>\n\t\t\t\t\t\t\t\t\t\t\t<p class=\"wf-center\"><?php echo wp_kses(__('Support for free customers is available via our forums page on wordpress.org. The majority of requests <strong>receive an answer within a few days.<\/strong>', 'wordfence'), array('strong'=>array())); ?><\/p>\n\t\t\t\t\t\t\t\t\t\t\t<p><a href=\"<?php echo wfSupportController::esc_supportURL(wfSupportController::ITEM_FREE); ?>\" target=\"_blank\" rel=\"noopener noreferrer\" class=\"wf-btn wf-btn-default wf-btn-callout-subtle\"><?php esc_html_e('Go to Support Forums', 'wordfence'); ?><span class=\"screen-reader-text\"> (<?php esc_html_e('opens in new tab', 'wordfence') ?>)<\/span><\/a><\/p>\n\t\t\t\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t\t\t<\/ul>\n\t\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t<\/ul>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t<\/div>\n\t\t\t<div class=\"wf-row\">\n\t\t\t\t<div class=\"wf-col-xs-12\">\n\t\t\t\t\t<div class=\"wf-block<?php echo (wfPersistenceController::shared()->isActive('support-gdpr') ? ' wf-active' : ''); ?>\" data-persistence-key=\"support-gdpr\">\n\t\t\t\t\t\t<div class=\"wf-block-header\">\n\t\t\t\t\t\t\t<div class=\"wf-block-header-content\">\n\t\t\t\t\t\t\t\t<div class=\"wf-block-title\">\n\t\t\t\t\t\t\t\t\t<strong><?php esc_html_e('GDPR Information', 'wordfence'); ?><\/strong>\n\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t\t<div class=\"wf-block-header-action\"><div class=\"wf-block-header-action-disclosure\" role=\"checkbox\" aria-checked=\"<?php echo (wfPersistenceController::shared()->isActive('support-gdpr') ? 'true' : 'false'); ?>\" tabindex=\"0\"><\/div><\/div>\n\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<div class=\"wf-block-content\">\n\t\t\t\t\t\t\t<ul class=\"wf-block-list\">\n\t\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t\t<ul class=\"wf-option wf-option-static\">\n\t\t\t\t\t\t\t\t\t\t<li class=\"wf-option-title\">\n\t\t\t\t\t\t\t\t\t\t\t<ul class=\"wf-flex-vertical wf-flex-align-left\">\n\t\t\t\t\t\t\t\t\t\t\t\t<li><?php esc_html_e('General Data Protection Regulation', 'wordfence'); ?> <a href=\"<?php echo wfSupportController::esc_supportURL(wfSupportController::ITEM_GDPR); ?>\" target=\"_blank\" rel=\"noopener noreferrer\" class=\"wf-inline-help\"><i class=\"wf-fa wf-fa-question-circle-o\" aria-hidden=\"true\"><\/i><span class=\"screen-reader-text\"> (<?php esc_html_e('opens in new tab', 'wordfence') ?>)<\/span><\/a><\/li>\n\t\t\t\t\t\t\t\t\t\t\t\t<li class=\"wf-option-subtitle\"><?php esc_html_e('The GDPR is a set of rules that provides more control over EU personal data. Defiant has updated its terms of service, privacy policies, and software, as well as made available standard contractual clauses to meet GDPR compliance.', 'wordfence'); ?><\/li>\n\t\t\t\t\t\t\t\t\t\t\t<\/ul>\n\t\t\t\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t\t\t<\/ul>\n\t\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t\t<ul class=\"wf-option wf-option-static\">\n\t\t\t\t\t\t\t\t\t\t<li class=\"wf-option-title\">\n\t\t\t\t\t\t\t\t\t\t\t<ul class=\"wf-flex-vertical wf-flex-align-left\">\n\t\t\t\t\t\t\t\t\t\t\t\t<li><?php esc_html_e('Agreement to New Terms and Privacy Policies', 'wordfence'); ?><\/li>\n\t\t\t\t\t\t\t\t\t\t\t\t<li class=\"wf-option-subtitle\"><?php esc_html_e('To continue using Defiant products and services including the Wordfence plugin, all customers must review and agree to the updated terms and privacy policies. These changes reflect our commitment to follow data protection best practices and regulations. The Wordfence interface will remain disabled until these terms are agreed to.', 'wordfence'); ?><\/li>\n\t\t\t\t\t\t\t\t\t\t\t<\/ul>\n\t\t\t\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t\t\t<\/ul>\n\t\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t<\/ul>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t<\/div> <!-- end GDPR -->\n\t\t\t<?php if (isset($support['all'])): ?>\n\t\t\t<div class=\"wf-row\">\n\t\t\t\t<div class=\"wf-col-xs-12 wf-col-sm-9 wf-col-sm-half-padding-right wf-add-top\">\n\t\t\t\t\t<h3 class=\"wf-no-top\"><?php esc_html_e('All Documentation', 'wordfence'); ?><\/h3>\n\t\t\t\t<\/div>\n\t\t\t<\/div>\n\t\t\t<div class=\"wf-row\">\n\t\t\t\t<div class=\"wf-col-xs-12 wf-col-sm-3 wf-col-sm-push-9 wf-col-sm-half-padding-left\"> \n\t\t\t\t\t<div class=\"wf-block wf-active\">\n\t\t\t\t\t\t<div class=\"wf-block-content\">\n\t\t\t\t\t\t\t<div class=\"wf-support-top-block\">\n\t\t\t\t\t\t\t\t<h4><?php esc_html_e('Top Topics and Questions', 'wordfence'); ?><\/h4> \n\t\t\t\t\t\t\t\t<ol>\n\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\tif (isset($support['top'])):\n\t\t\t\t\t\t\t\t\tforeach ($support['top'] as $entry):\n\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t<li><a href=\"<?php echo esc_url($entry['permalink']); ?>\" target=\"_blank\" rel=\"noopener noreferrer\"><?php echo esc_html($entry['title']); ?><span class=\"screen-reader-text\"> (<?php esc_html_e('opens in new tab', 'wordfence') ?>)<\/span><\/a><\/li>\n\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\tendforeach;\n\t\t\t\t\t\t\t\tendif;\n\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t<\/ol>\n\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\t<div class=\"wf-col-xs-12 wf-col-sm-9 wf-col-sm-pull-3 wf-col-sm-half-padding-right\">\n\t\t\t\t<?php\n\t\t\t\tif (isset($support['all'])):\n\t\t\t\t\tforeach ($support['all'] as $entry):\n\t\t\t\t?>\n\t\t\t\t\t<div class=\"wf-block wf-active wf-add-bottom\">\n\t\t\t\t\t\t<div class=\"wf-block-content\">\n\t\t\t\t\t\t\t<div class=\"wf-support-block\">\n\t\t\t\t\t\t\t\t<h4><a href=\"<?php echo esc_url($entry['permalink']); ?>\" target=\"_blank\" rel=\"noopener noreferrer\"><?php echo esc_html($entry['title']); ?><span class=\"screen-reader-text\"> (<?php esc_html_e('opens in new tab', 'wordfence') ?>)<\/span><\/a><\/h4>\n\t\t\t\t\t\t\t\t<p><?php echo esc_html($entry['excerpt']); ?><\/p>\n\t\t\t\t\t\t\t\t<?php if (isset($entry['children'])): ?>\n\t\t\t\t\t\t\t\t<ul>\n\t\t\t\t\t\t\t\t<?php foreach ($entry['children'] as $child): ?>\n\t\t\t\t\t\t\t\t\t<li><a href=\"<?php echo esc_url($child['permalink']); ?>\" target=\"_blank\" rel=\"noopener noreferrer\"><?php echo esc_html($child['title']); ?><span class=\"screen-reader-text\"> (<?php esc_html_e('opens in new tab', 'wordfence') ?>)<\/span><\/a><\/li>\n\t\t\t\t\t\t\t\t<?php endforeach; ?>\n\t\t\t\t\t\t\t\t<\/ul>\n\t\t\t\t\t\t\t\t<?php endif; ?>\n\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t\t<\/div>\n\t\t\t\t<?php\n\t\t\t\t\tendforeach;\n\t\t\t\tendif;\n\t\t\t\t?>\n\t\t\t\t<\/div>\n\t\t\t<\/div>\n\t\t\t<?php else: ?>\n\t\t\t<div class=\"wf-row\">\n\t\t\t\t<div class=\"wf-col-xs-12\">\n\t\t\t\t\t<div class=\"wf-block wf-active\">\n\t\t\t\t\t\t<div class=\"wf-block-content\">\n\t\t\t\t\t\t\t<div class=\"wf-support-missing-block\">\n\t\t\t\t\t\t\t\t<h4><?php esc_html_e('Documentation', 'wordfence'); ?><\/h4>\n\t\t\t\t\t\t\t\t<p><?php echo wp_kses(__('Documentation about Wordfence may be found on our website by clicking the button below or by clicking the <i class=\"wf-fa wf-fa-question-circle-o\" aria-hidden=\"true\"><\/i> links on any of the plugin\\'s pages.', 'wordfence'), array('i'=>array('class'=>array(), 'aria-hidden'=>array()))); ?><\/p>\n\t\t\t\t\t\t\t\t<p class=\"wf-no-bottom\"><a href=\"<?php echo wfSupportController::esc_supportURL(wfSupportController::ITEM_INDEX); ?>\" target=\"_blank\" rel=\"noopener noreferrer\" class=\"wf-btn wf-btn-default wf-btn-callout-subtle\"><?php esc_html_e('View Documentation', 'wordfence'); ?><span class=\"screen-reader-text\"> (<?php esc_html_e('opens in new tab', 'wordfence') ?>)<\/span><\/a><\/p>\n\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t<\/div>\n\t\t\t<?php endif; ?>\n\t\t<\/div> <!-- end container -->\n\t<\/div>\n<?php if (wfOnboardingController::shouldShowAttempt3()): ?>\n\t<?php wfConfig::set('onboardingAttempt3Initial', true); ?>\n\t<script type=\"text\/x-jquery-template\" id=\"wfTmpl_onboardingFinal\">\n\t\t<?php echo wfView::create('onboarding\/modal-final-attempt')->render(); ?>\n\t<\/script>\n\t<script type=\"application\/javascript\">\n\t\t(function($) {\n\t\t\t$(function() {\n\t\t\t\tvar prompt = $('#wfTmpl_onboardingFinal').tmpl();\n\t\t\t\tvar promptHTML = $(\"<div \/>\").append(prompt).html();\n\t\t\t\tWFAD.colorboxHTML('800px', promptHTML, {overlayClose: false, closeButton: false, className: 'wf-modal', onComplete: function() {\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\t$('#wf-onboarding-subscribe-controls > p').show();\n\t\t\t\t\t\t$.wfcolorbox.resize();\n\t\t\t\t\t}, 30000);\n\n\t\t\t\t\t$('#wf-onboarding-subscribe .wf-switch > li').each(function(index, element) {\n\t\t\t\t\t\t$(element).on('click', function(e) {\n\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t\te.stopPropagation();\n\n\t\t\t\t\t\t\tvar control = $(this).closest('.wf-switch');\n\t\t\t\t\t\t\tcontrol.find('li').removeClass('wf-active');\n\t\t\t\t\t\t\t$(this).addClass('wf-active');\n\n\t\t\t\t\t\t\t$('#wf-onboarding-continue').toggleClass('wf-disabled', wordfenceExt.parseEmails($('#wf-onboarding-alerts').val()).length == 0 || !($('#wf-onboarding-agree').is(':checked')) || $('#wf-onboarding-subscribe .wf-switch > li.wf-active').length == 0);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\t$('#wf-onboarding-agree').on('change', function() {\n\t\t\t\t\t\t$('#wf-onboarding-continue').toggleClass('wf-disabled', wordfenceExt.parseEmails($('#wf-onboarding-alerts').val()).length == 0 || !($('#wf-onboarding-agree').is(':checked')) || $('#wf-onboarding-subscribe .wf-switch > li.wf-active').length == 0);\n\t\t\t\t\t});\n\n\t\t\t\t\t$('#wf-onboarding-alerts').on('change paste keyup', function() {\n\t\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\t\t$('#wf-onboarding-continue').toggleClass('wf-disabled', wordfenceExt.parseEmails($('#wf-onboarding-alerts').val()).length == 0 || !($('#wf-onboarding-agree').is(':checked')) || $('#wf-onboarding-subscribe .wf-switch > li.wf-active').length == 0);\n\t\t\t\t\t\t}, 100);\n\t\t\t\t\t}).trigger('change');\n\n\t\t\t\t\t$('#wf-onboarding-continue').on('click', function(e) {\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\te.stopPropagation();\n\n\t\t\t\t\t\tvar touppAgreed = !!$('#wf-onboarding-agree').is(':checked');\n\t\t\t\t\t\tif (!touppAgreed) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar emails = wordfenceExt.parseEmails($('#wf-onboarding-alerts').val());\n\t\t\t\t\t\tif (emails.length > 0) {\n\t\t\t\t\t\t\tvar subscribe = !!parseInt($('#wf-onboarding-subscribe .wf-switch > li.wf-active').data('optionValue'));\n\t\t\t\t\t\t\twordfenceExt.onboardingProcessEmails(emails, subscribe, touppAgreed);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t<?php if (wfConfig::get('isPaid')): ?>\n\t\t\t\t\t\t\twordfenceExt.setOption('onboardingAttempt3', '<?php echo esc_attr(wfOnboardingController::ONBOARDING_LICENSE); ?>');\n\t\t\t\t\t\t\t$('#wf-onboarding-banner').slideUp();\n\t\t\t\t\t\t\tWFAD.colorboxClose();\n\t\t\t\t\t\t\tif (WFAD.tour1) { setTimeout(function() { WFAD.tour1(); }, 500); }\n\t\t\t\t\t\t\t<?php else: ?>\n\t\t\t\t\t\t\twordfenceExt.setOption('onboardingAttempt3', '<?php echo esc_attr(wfOnboardingController::ONBOARDING_EMAILS); ?>');\n\n\t\t\t\t\t\t\t$('#wf-onboarding-final-attempt-1, .wf-modal-footer').fadeOut(400, function() {\n\t\t\t\t\t\t\t\t$('#wf-onboarding-final-attempt-2').fadeIn();\n\t\t\t\t\t\t\t\t$.wfcolorbox.resize();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t<?php endif; ?>\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\t$('#wf-onboarding-license input').on('change paste keyup', function() {\n\t\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\t\t$('#wf-onboarding-license-install').toggleClass('wf-disabled', $('#wf-onboarding-license input').val().length == 0);\n\t\t\t\t\t\t}, 100);\n\t\t\t\t\t}).trigger('change');\n\n\t\t\t\t\t$('#wf-onboarding-license-install').on('click', function(e) {\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\te.stopPropagation();\n\n\t\t\t\t\t\t$('#wf-onboarding-license-status').fadeOut();\n\n\t\t\t\t\t\tvar license = $('#wf-onboarding-license input').val();\n\t\t\t\t\t\twordfenceExt.onboardingInstallLicense(license,\n\t\t\t\t\t\t\tfunction(res) { \/\/Success\n\t\t\t\t\t\t\t\tif (res.isPaid) {\n\t\t\t\t\t\t\t\t\twordfenceExt.setOption('onboardingAttempt3', '<?php echo esc_attr(wfOnboardingController::ONBOARDING_LICENSE); ?>');\n\t\t\t\t\t\t\t\t\t\/\/$('#wf-onboarding-license-status').addClass('wf-green-dark').removeClass('wf-yellow-dark wf-red-dark').text('You have successfully installed a premium license.').fadeIn();\n\t\t\t\t\t\t\t\t\t\/\/$('#wf-onboarding-license-install').text('Installed').addClass('wf-disabled');\n\t\t\t\t\t\t\t\t\t\/\/$('#wf-onboarding-license input').attr('disabled', true);\n\t\t\t\t\t\t\t\t\t$('#wf-onboarding-banner').slideUp();\n\t\t\t\t\t\t\t\t\t$('#wf-onboarding-final-attempt .wf-modal-header-action-close').off('click');\n\t\t\t\t\t\t\t\t\t\/*$('#wf-onboarding-premium-cta, #wf-onboarding-license-footer, #wf-onboarding-or').fadeOut(400, function() {\n\t\t\t\t\t\t\t\t\t $('#wf-onboarding-license-finished').fadeIn();\n\t\t\t\t\t\t\t\t\t $.wfcolorbox.resize();\n\t\t\t\t\t\t\t\t\t });*\/\n\n\t\t\t\t\t\t\t\t\tvar html = '<div class=\"wf-modal wf-modal-success\"><div class=\"wf-model-success-wrapper\"><div class=\"wf-modal-header\"><div class=\"wf-modal-header-content\"><div class=\"wf-modal-title\"><?php esc_html_e('Premium License Installed', 'wordfence'); ?><\/div><\/div><\/div><div class=\"wf-modal-content\"><?php esc_html_e('Congratulations! Wordfence Premium is now active on your website. Please note that some Premium features are not enabled by default.', 'wordfence'); ?><\/div><\/div><div class=\"wf-modal-footer\"><ul class=\"wf-onboarding-flex-horizontal wf-onboarding-flex-align-right wf-onboarding-full-width\"><li><a href=\"<?php echo esc_url(network_admin_url('admin.php?page=Wordfence')); ?>\" class=\"wf-onboarding-btn wf-onboarding-btn-primary\"><?php esc_html_e('Continue', 'wordfence'); ?><\/a><\/li><\/ul><\/div><\/div>';\n\t\t\t\t\t\t\t\t\t$.wfcolorbox({\n\t\t\t\t\t\t\t\t\t\twidth: (wordfenceExt.isSmallScreen ? '300px' : '500px'),\n\t\t\t\t\t\t\t\t\t\thtml: html,\n\t\t\t\t\t\t\t\t\t\toverlayClose: true,\n\t\t\t\t\t\t\t\t\t\tcloseButton: false,\n\t\t\t\t\t\t\t\t\t\tclassName: 'wf-modal'\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\t\/\/Congratulations! Wordfence Premium is now active on your website. Please note that some Premium features are not enabled by default. Read this brief article to learn more about <a href=\"#todo\" target=\"_blank\" rel=\"noopener noreferrer\">getting the most out of Wordfence Premium<\/a>.\n\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse { \/\/Unlikely to happen but possible\n\t\t\t\t\t\t\t\t\t$('#wf-onboarding-license-status').addClass('wf-yellow-dark').removeClass('wf-green-dark wf-red-dark').text('You have successfully installed a free license.').fadeIn();\n\t\t\t\t\t\t\t\t\t$.wfcolorbox.resize();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tfunction(error) { \/\/Error\n\t\t\t\t\t\t\t\t$('#wf-onboarding-license-status').addClass('wf-red-dark').removeClass('wf-green-dark wf-yellow-dark').text(error || <?php echo json_encode(__('An unknown error occurred.', 'wordfence')) ?>).fadeIn();\n\t\t\t\t\t\t\t\t$.wfcolorbox.resize();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t});\n\n\t\t\t\t\t$('#wf-onboarding-no-thanks, #wf-onboarding-final-attempt .wf-modal-header-action-close').on('click', function(e) {\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\te.stopPropagation();\n\n\t\t\t\t\t\tif ($('#wf-onboarding-final-attempt-2').is(':visible')) {\n\t\t\t\t\t\t\twordfenceExt.setOption('onboardingAttempt3', '<?php echo esc_attr(wfOnboardingController::ONBOARDING_LICENSE); ?>');\n\t\t\t\t\t\t\t$('#wf-onboarding-banner').slideUp();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tWFAD.colorboxClose();\n\t\t\t\t\t\tif (WFAD.tour1) { setTimeout(function() { WFAD.tour1(); }, 500); }\n\t\t\t\t\t});\n\t\t\t\t}});\n\t\t\t});\n\t\t})(jQuery);\n\t<\/script>\n<?php endif; ?>"},{"base":"plugins","rel":"wordfence\/lib\/wfBinaryList.php","ext":"php","size":1043,"mtime":1757312769,"type":"text","content":"<?php\n\n\/**\n * Class wfBinaryList implements an interface to interact with binary lists. These are internally a sorted list of \n * values of a specific size. The sorted aspect allows for very quick searching.\n *\/\nclass wfBinaryList {\n\tprivate $size = 0;\n\tprivate $list = '';\n\t\n\tpublic function __construct($binary) {\n\t\t$this->size = ord(wfWAFUtils::substr($binary, 0, 1));\n\t\t$this->list = wfWAFUtils::substr($binary, 1);\n\t}\n\t\n\tpublic function contains($value) {\n\t\tif ($this->size == 0) { return false; }\n\t\t$length = wfWAFUtils::strlen($this->list);\n\t\tif ($length == 0) { return false; }\n\t\t\n\t\t$p = wfWAFUtils::substr($value, 0, $this->size);\n\t\t\n\t\t$count = ceil($length \/ $this->size);\n\t\t$low = 0;\n\t\t$high = $count - 1;\n\t\t\n\t\twhile ($low <= $high) {\n\t\t\t$mid = (int) (($high + $low) \/ 2);\n\t\t\t$val = wfWAFUtils::substr($this->list, $mid * $this->size, $this->size);\n\t\t\t$cmp = strcmp($val, $p);\n\t\t\tif ($cmp < 0) {\n\t\t\t\t$low = $mid + 1;\n\t\t\t}\n\t\t\telse if ($cmp > 0) {\n\t\t\t\t$high = $mid - 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn $mid;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n}"},{"base":"plugins","rel":"wordfence\/lib\/menu_tools_importExport.php","ext":"php","size":1310,"mtime":1757312769,"type":"text","content":"<?php\nif (!defined('WORDFENCE_VERSION')) { exit; }\n?>\n<script type=\"application\/javascript\">\n\t(function($) {\n\t\t$(function() {\n\t\t\tdocument.title = \"<?php esc_attr_e('Import\/Export Options', 'wordfence'); ?>\" + \" \\u2039 \" + WFAD.basePageName;\n\t\t});\n\t})(jQuery);\n<\/script>\n<div id=\"wf-tools-importexport\">\n\t<div class=\"wf-section-title\">\n\t\t<h2><?php esc_html_e('Import\/Export Options', 'wordfence') ?><\/h2>\n\t\t<span><?php echo wp_kses(sprintf(\n\t\t\t\/* translators: URL to support page. *\/\n\t\t\t\t__('<a href=\"%s\" target=\"_blank\" rel=\"noopener noreferrer\" class=\"wf-help-link\">Learn more<span class=\"wf-hidden-xs\"> about importing and exporting options<\/span><span class=\"screen-reader-text\"> (opens in new tab)<\/span><\/a>', 'wordfence'), wfSupportController::esc_supportURL(wfSupportController::ITEM_TOOLS_IMPORT_EXPORT)), array('a'=>array('href'=>array(), 'target'=>array(), 'rel'=>array(), 'class'=>array()), 'span'=>array('class'=>array()))); ?>\n\t\t\t<i class=\"wf-fa wf-fa-external-link\" aria-hidden=\"true\"><\/i><\/span>\n\t<\/div>\n\t\n\t<p><?php esc_html_e(\"To clone one site's configuration to another, use the import\/export tools below.\", 'wordfence') ?><\/p>\n\t\n\t<?php\n\techo wfView::create('dashboard\/options-group-import', array(\n\t\t'stateKey' => 'global-options-import',\n\t\t'collapseable' => false,\n\t))->render();\n\t?>\n<\/div>"},{"base":"plugins","rel":"wordfence\/lib\/sysinfo.php","ext":"php","size":1501,"mtime":1757312769,"type":"text","content":"<?php if (!defined('WORDFENCE_VERSION')) { exit; } ?>\n<?php if(! wfUtils::isAdmin()){ exit(); } ?><!DOCTYPE html PUBLIC \"-\/\/W3C\/\/DTD XHTML 1.0 Transitional\/\/EN\" \"http:\/\/www.w3.org\/TR\/xhtml1\/DTD\/xhtml1-transitional.dtd\">\n<html xmlns=\"http:\/\/www.w3.org\/1999\/xhtml\"  dir=\"ltr\" lang=\"en-US\">\n<head>\n<title><?php esc_html_e('Wordfence System Info', 'wordfence') ?><\/title>\n<meta http-equiv=\"Content-Type\" content=\"text\/html; charset=UTF-8\" \/>\n<link rel='stylesheet' id='wordfence-main-style-css'  href='<?php echo wfUtils::getBaseURL() . wfUtils::versionedAsset('css\/phpinfo.css'); ?>?ver=<?php echo WORDFENCE_VERSION; ?>' type='text\/css' media='all' \/>\n<body>\n<?php \nob_start();\nif (wfUtils::funcEnabled('phpinfo')) { phpinfo(INFO_ALL); } else { echo '<center><strong>' . esc_html__('Unable to output phpinfo content because it is disabled', 'wordfence') . \"<\/strong><\/center>\\n\"; }\n$out = ob_get_clean();\n$out = str_replace('width=\"600\"','width=\"900\"', $out);\n\/\/ $out = preg_replace('\/<hr.*?PHP Credits.*?<\\\/h1>\/s', '', $out);\n$out = preg_replace('\/<a [^>]+>\/', '', $out);\n$out = preg_replace('\/<\\\/a>\/', '', $out);\n$out = preg_replace('\/<title>[^<]*<\\\/title>\/','', $out);\necho $out;\n?>\n<div class=\"diffFooter\"><?php echo wp_kses(sprintf(__('&copy;&nbsp;%d to %d Wordfence &mdash; Visit <a href=\"https:\/\/www.wordfence.com\/\">Wordfence.com<\/a> for help, security updates and more.', 'wordfence'), date_i18n('Y', WORDFENCE_EPOCH), date_i18n('Y')), array('a'=>array('href'=>array()))) ?><\/div>\n<\/body>\n<\/html>"},{"base":"plugins","rel":"wordfence\/lib\/wfCrawl.php","ext":"php","size":6722,"mtime":1757312769,"type":"text","content":"<?php\nrequire_once(dirname(__FILE__) . '\/wfUtils.php');\nclass wfCrawl {\n\tconst GOOGLE_BOT_VERIFIED = 'verified';\n\tconst GOOGLE_BOT_FAKE = 'fakeBot';\n\tconst GOOGLE_BOT_UNDETERMINED = 'undetermined';\n\t\n\tpublic static function isCrawler($UA){\n\t\t$browscap = new wfBrowscap();\n\t\t$b = $browscap->getBrowser($UA);\n\t\tif (!$b || $b['Parent'] == 'DefaultProperties') {\n\t\t\t$IP = wfUtils::getIP(); \n\t\t\treturn !wfLog::isHumanRequest($IP, $UA);\n\t\t}\n\t\telse if (isset($b['Crawler']) && $b['Crawler']) {\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\tpublic static function verifyCrawlerPTR($hostPattern, $IP){\n\t\t$table = wfDB::networkTable('wfCrawlers');\n\t\t$db = new wfDB();\n\t\t$IPn = wfUtils::inet_pton($IP);\n\t\t$ipHex = wfDB::binaryValueToSQLHex(wfUtils::inet_pton($IPn));\n\t\t$status = $db->querySingle(\"select status from $table where IP={$ipHex} and patternSig=UNHEX(MD5('%s')) and lastUpdate > unix_timestamp() - %d\", $hostPattern, WORDFENCE_CRAWLER_VERIFY_CACHE_TIME);\n\t\tif($status){\n\t\t\tif($status == 'verified'){\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t$host = wfUtils::reverseLookup($IP);\n\t\tif(! $host){ \n\t\t\t$db->queryWrite(\"insert into $table (IP, patternSig, status, lastUpdate, PTR) values ({$ipHex}, UNHEX(MD5('%s')), '%s', unix_timestamp(), '%s') ON DUPLICATE KEY UPDATE status='%s', lastUpdate=unix_timestamp(), PTR='%s'\", $hostPattern, 'noPTR', '', 'noPTR', '');\n\t\t\treturn false; \n\t\t}\n\t\tif(preg_match($hostPattern, $host)){\n\t\t\t$resultIPs = wfUtils::resolveDomainName($host);\n\t\t\t$addrsMatch = false;\n\t\t\tforeach($resultIPs as $resultIP){\n\t\t\t\tif($resultIP == $IP){\n\t\t\t\t\t$addrsMatch = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif($addrsMatch){\n\t\t\t\t$db->queryWrite(\"insert into $table (IP, patternSig, status, lastUpdate, PTR) values ({$ipHex}, UNHEX(MD5('%s')), '%s', unix_timestamp(), '%s') ON DUPLICATE KEY UPDATE status='%s', lastUpdate=unix_timestamp(), PTR='%s'\", $hostPattern, 'verified', $host, 'verified', $host);\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\t$db->queryWrite(\"insert into $table (IP, patternSig, status, lastUpdate, PTR) values ({$ipHex}, UNHEX(MD5('%s')), '%s', unix_timestamp(), '%s') ON DUPLICATE KEY UPDATE status='%s', lastUpdate=unix_timestamp(), PTR='%s'\", $hostPattern, 'fwdFail', $host, 'fwdFail', $host);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\t$db->queryWrite(\"insert into $table (IP, patternSig, status, lastUpdate, PTR) values ({$ipHex}, UNHEX(MD5('%s')), '%s', unix_timestamp(), '%s') ON DUPLICATE KEY UPDATE status='%s', lastUpdate=unix_timestamp(), PTR='%s'\", $hostPattern, 'badPTR', $host, 'badPTR', $host);\n\t\t\treturn false;\n\t\t}\n\t}\n\tpublic static function isGooglebot($userAgent = null){\n\t\tif ($userAgent === null) {\n\t\t\t$userAgent = isset($_SERVER['HTTP_USER_AGENT']) ? $_SERVER['HTTP_USER_AGENT'] : '';\n\t\t}\n\t\treturn (bool) preg_match('\/Googlebot\\\/\\d\\.\\d\/', $userAgent);\n\t}\n\tpublic static function isGoogleCrawler($userAgent = null){\n\t\tif ($userAgent === null) {\n\t\t\t$userAgent = isset($_SERVER['HTTP_USER_AGENT']) ? $_SERVER['HTTP_USER_AGENT'] : '';\n\t\t}\n\t\tforeach (self::$googPat as $pat) {\n\t\t\tif (preg_match($pat . 'i', $userAgent)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tprivate static $googPat = array(\n'@^Mozilla\/5\\\\.0 \\\\(.*Google Keyword Tool.*\\\\)$@',\n'@^Mozilla\/5\\\\.0 \\\\(.*Feedfetcher\\\\-Google.*\\\\)$@',\n'@^Feedfetcher\\\\-Google\\\\-iGoogleGadgets.*$@',\n'@^searchbot admin\\\\@google\\\\.com$@',\n'@^Google\\\\-Site\\\\-Verification.*$@',\n'@^Google OpenSocial agent.*$@',\n'@^.*Googlebot\\\\-Mobile\/2\\\\..*$@',\n'@^AdsBot\\\\-Google\\\\-Mobile.*$@',\n'@^google \\\\(.*Enterprise.*\\\\)$@',\n'@^Mediapartners\\\\-Google.*$@',\n'@^GoogleFriendConnect.*$@',\n'@^googlebot\\\\-urlconsole$@',\n'@^.*Google Web Preview.*$@',\n'@^Feedfetcher\\\\-Google.*$@',\n'@^AppEngine\\\\-Google.*$@',\n'@^Googlebot\\\\-Video.*$@',\n'@^Googlebot\\\\-Image.*$@',\n'@^Google\\\\-Sitemaps.*$@',\n'@^Googlebot\/Test.*$@',\n'@^Googlebot\\\\-News.*$@',\n'@^.*Googlebot\/2\\\\.1.*$@',\n'@^AdsBot\\\\-Google.*$@',\n'@^Google$@'\n\t);\n\n\n\t\/**\n\t * Has correct user agent and PTR record points to .googlebot.com domain.\n\t *\n\t * @param string|null $ip\n\t * @param string|null $ua\n\t * @return bool\n\t *\/\n\tpublic static function isVerifiedGoogleCrawler($ip = null, $ua = null) {\n\t\tstatic $verified;\n\t\tif (!isset($verified)) {\n\t\t\t$verified = array();\n\t\t}\n\t\tif ($ip === null) {\n\t\t\t$ip = wfUtils::getIP();\n\t\t}\n\t\t\n\t\tif ($ip === null || $ip === false) { \/\/Likely a CLI execution\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (array_key_exists($ip, $verified)) {\n\t\t\treturn $verified[$ip];\n\t\t}\n\t\tif (self::isGoogleCrawler($ua)) {\n\t\t\tif (self::verifyCrawlerPTR(wordfence::getLog()->getGooglePattern(), $ip)) {\n\t\t\t\t$verified[$ip] = true;\n\t\t\t\treturn $verified[$ip];\n\t\t\t}\n\t\t\t$noc1Status = self::verifyGooglebotViaNOC1($ip);\n\t\t\tif ($noc1Status == self::GOOGLE_BOT_VERIFIED) {\n\t\t\t\t$verified[$ip] = true;\n\t\t\t\treturn $verified[$ip];\n\t\t\t}\n\t\t\telse if ($noc1Status == self::GOOGLE_BOT_FAKE) {\n\t\t\t\t$verified[$ip] = false;\n\t\t\t\treturn $verified[$ip];\n\t\t\t}\n\t\t\t\n\t\t\treturn true; \/\/We were unable to successfully validate Googlebot status so default to being permissive\n\t\t}\n\t\t$verified[$ip] = false;\n\t\treturn $verified[$ip];\n\t}\n\n\t\/**\n\t * Attempts to verify whether an IP claiming to be Googlebot is actually Googlebot.\n\t * \n\t * @param string|null $ip\n\t * @return string\n\t *\/\n\tpublic static function verifyGooglebotViaNOC1($ip = null) {\n\t\t$table = wfDB::networkTable('wfCrawlers');\n\t\tif ($ip === null) {\n\t\t\t$ip = wfUtils::getIP();\n\t\t}\n\t\t$db = new wfDB();\n\t\t$IPn = wfUtils::inet_pton($ip);\n\t\t$ipHex = wfDB::binaryValueToSQLHex($IPn);\n\t\t$patternSig = 'googlenoc1';\n\t\t$status = $db->querySingle(\"select status from $table\n\t\t\t\twhere IP={$ipHex}\n\t\t\t\tand patternSig=UNHEX(MD5('%s'))\n\t\t\t\tand lastUpdate > unix_timestamp() - %d\",\n\t\t\t\t$patternSig,\n\t\t\t\tWORDFENCE_CRAWLER_VERIFY_CACHE_TIME);\n\t\tif ($status === 'verified') {\n\t\t\treturn self::GOOGLE_BOT_VERIFIED;\n\t\t} else if ($status === 'fakeBot') {\n\t\t\treturn self::GOOGLE_BOT_FAKE;\n\t\t}\n\n\t\t$api = new wfAPI(wfConfig::get('apiKey'), wfUtils::getWPVersion());\n\t\ttry {\n\t\t\t$data = $api->call('verify_googlebot', array(\n\t\t\t\t'ip' => $ip,\n\t\t\t));\n\t\t\tif (is_array($data) && !empty($data['verified'])) {\n\t\t\t\t\/\/ Cache results\n\t\t\t\t$db->queryWrite(\"INSERT INTO {$table} (IP, patternSig, status, lastUpdate) VALUES ({$ipHex}, UNHEX(MD5('%s')), '%s', unix_timestamp()) ON DUPLICATE KEY UPDATE status = VALUES(status), lastUpdate = VALUES(lastUpdate)\", $patternSig, 'verified');\n\t\t\t\treturn self::GOOGLE_BOT_VERIFIED;\n\t\t\t} else {\n\t\t\t\t$db->queryWrite(\"INSERT INTO {$table} (IP, patternSig, status, lastUpdate) VALUES ({$ipHex}, UNHEX(MD5('%s')), '%s', unix_timestamp()) ON DUPLICATE KEY UPDATE status = VALUES(status), lastUpdate = VALUES(lastUpdate)\", $patternSig, 'fakeBot');\n\t\t\t\tself::GOOGLE_BOT_FAKE;\n\t\t\t}\n\t\t} catch (Exception $e) {\n\t\t\t\/\/ Do nothing, bail\n\t\t}\n\t\treturn self::GOOGLE_BOT_UNDETERMINED;\n\t}\n}\n"},{"base":"plugins","rel":"wordfence\/lib\/wfIPWhitelist.php","ext":"php","size":1596,"mtime":1757312769,"type":"text","content":"<?php\n\/**\n * Addresses should be in human readable format as a single IP (e.g. 1.2.3.4) or CIDR (e.g. 1.2.3.4\/32)\n *\/\n$wfIPWhitelist = array(\n\t'private' => array(\n\t\t\/\/We've modified this and removed some addresses which may be routable on the Net and cause auto-whitelisting.\n\t\t\/\/'0.0.0.0\/8',\t\t\t#Broadcast addr\n\t\t'10.0.0.0\/8',\t\t\t#Private addrs\n\t\t\/\/'100.64.0.0\/10',\t\t#carrier-grade-nat for comms between ISP and subscribers\n\t\t'127.0.0.0\/8',\t\t\t#loopback\n\t\t\/\/'169.254.0.0\/16',\t\t#link-local when DHCP fails e.g. os x\n\t\t'172.16.0.0\/12',\t\t#private addrs\n\t\t'192.0.0.0\/29',\t\t\t#used for NAT with IPv6, so basically a private addr\n\t\t\/\/'192.0.2.0\/24',\t\t#Only for use in docs and examples, not for public use\n\t\t\/\/'192.88.99.0\/24',\t\t#Used by 6to4 anycast relays\n\t\t'192.168.0.0\/16',\t\t#Used for local communications within a private network\n\t\t\/\/'198.18.0.0\/15',\t\t#Used for testing of inter-network communications between two separate subnets\n\t\t\/\/'198.51.100.0\/24',\t#Assigned as \"TEST-NET-2\" in RFC 5737 for use solely in documentation and example source code and should not be used publicly.\n\t\t\/\/'203.0.113.0\/24',\t\t#Assigned as \"TEST-NET-3\" in RFC 5737 for use solely in documentation and example source code and should not be used publicly.\n\t\t\/\/'224.0.0.0\/4',\t\t#Reserved for multicast assignments as specified in RFC 5771\n\t\t\/\/'240.0.0.0\/4',\t\t#Reserved for future use, as specified by RFC 6890\n\t\t\/\/'255.255.255.255\/32',\t#Reserved for the \"limited broadcast\" destination address, as specified by RFC 6890\n\t),\n\t'wordfence' => array(\n\t\t'54.68.32.247', \/\/ Central @ AWS\n\t\t'44.235.211.232',\n\t\t'54.71.203.174'\n\t),\n);\n"},{"base":"plugins","rel":"wordfence\/lib\/wfVersionSupport.php","ext":"php","size":535,"mtime":1757312769,"type":"text","content":"<?php\n\n$wfPHPDeprecatingVersion = '7.2.0'; \/\/When greater than PHP_MINIMUM, will issue a discontinuing warning the first time we check it and find a version less than this (also applies to the other similar constant pairs)\n$wfPHPMinimumVersion = '7.0.0'; \/\/The currently supported minimum\n\n$wfOpenSSLDeprecatingVersion = '1.0.1';\n$wfOpenSSLMinimumVersion = '1.0.1';\n\n$wfWordPressDeprecatingVersion = '4.9.0';\n$wfWordPressMinimumVersion = '4.7.0';\n\n$wfCURLMinimumVersion = '1.0';\n\n\/\/Feature Cutoffs\n$wfFeatureWPVersionAuditLog = '6.0';\n"},{"base":"plugins","rel":"wordfence\/lib\/email_unlockRequest.php","ext":"php","size":2397,"mtime":1757312769,"type":"text","content":"<?php if (!defined('WORDFENCE_VERSION')) { exit; } ?>\n<?php echo wp_kses(sprintf(\n\t\/* translators: 1. IP address. 2. Site URL. 3. Site name.  *\/\n\t\t__('Either you or someone else at IP address <b>%1$s<\/b> requested instructions to regain access to the website <a href=\"%2$s\"><b>%3$s<\/b><\/a>.', 'wordfence'), esc_html($IP), esc_attr(wfUtils::getSiteBaseURL()), esc_html($siteName)), array('a'=>array('href'=>array()), 'b'=>array())); ?>\n<br><br>\n<?php printf(\n\t\/* translators: Localized date.  *\/\n\t\t__('Request was generated at: %s', 'wordfence'), wfUtils::localHumanDate()); ?>\n<br><br>\n<?php esc_html_e('If you did not request these instructions then you can safely ignore them.', 'wordfence'); ?><br>\n<?php echo wp_kses(__('These instructions <b>will be valid for 30 minutes<\/b> from the time they were sent.', 'wordfence'), array('b'=>array())); ?>\n<ul>\n\t<li>\n\t\t<a href=\"<?php echo $unlockHref; ?>&func=unlockMyIP\"><?php esc_html_e('Click here to unlock your ability to sign-in and to access to the site.', 'wordfence'); ?><\/a> <?php esc_html_e('Do this if you simply need to regain access because you were accidentally locked out. If you received an \"Insecure Password\" message before getting locked out, you may also need to reset your password.', 'wordfence'); ?> <a href=\"<?php echo wfSupportController::esc_supportURL(wfSupportController::ITEM_USING_BREACH_PASSWORD); ?>\"><?php esc_html_e('Learn More', 'wordfence'); ?><\/a>\n\t<\/li>\n\t<li>\n\t<a href=\"<?php echo $unlockHref; ?>&func=unlockAllIPs\"><?php esc_html_e('Click here to unblock all IP addresses.', 'wordfence'); ?><\/a> <?php esc_html_e('Do this if you still can\\'t regain access using the link above. It causes everyone who is blocked or locked out to be able to access your site again.', 'wordfence'); ?>\n\t<\/li>\n\t<li>\n\t<a href=\"<?php echo $unlockHref; ?>&func=disableRules\"><?php esc_html_e('Click here to unlock all IP addresses and disable the Wordfence Firewall and Wordfence login security for all users', 'wordfence'); ?><\/a>. <?php esc_html_e('Do this if you keep getting locked out or blocked and can\\'t access your site. You can re-enable login security and the firewall once you sign-in to the site by visiting the Wordfence Firewall menu, clicking and then turning on the firewall and login security options. If you use country blocking, you will also need to choose which countries to block.', 'wordfence'); ?>\n\t<\/li>\n<\/ul>"},{"base":"plugins","rel":"wordfence\/lib\/wfCredentialsController.php","ext":"php","size":5284,"mtime":1757312769,"type":"text","content":"<?php\n\nclass wfCredentialsController {\n\tconst UNCACHED = 'uncached';\n\tconst NOT_LEAKED = 'not-leaked';\n\tconst LEAKED = 'leaked';\n\t\n\tconst ALLOW_LEGACY_2FA_OPTION = 'allowLegacy2FA';\n\tconst DISABLE_LEGACY_2FA_OPTION = 'disableLegacy2FA';\n\t\n\tpublic static function allowLegacy2FA() {\n\t\treturn wfConfig::get(self::ALLOW_LEGACY_2FA_OPTION, false);\n\t}\n\t\n\tpublic static function useLegacy2FA() {\n\t\tif (!self::allowLegacy2FA()) {\n\t\t\treturn false;\n\t\t}\n\t\treturn !wfConfig::get(self::DISABLE_LEGACY_2FA_OPTION, false);\n\t}\n\t\n\tpublic static function hasOld2FARecords() {\n\t\t$twoFactorUsers = wfConfig::get_ser('twoFactorUsers', array());\n\t\tif (is_array($twoFactorUsers) && !empty($twoFactorUsers)) {\n\t\t\tforeach ($twoFactorUsers as &$t) {\n\t\t\t\tif ($t[3] == 'activated') {\n\t\t\t\t\t$user = new WP_User($t[0]);\n\t\t\t\t\tif ($user instanceof WP_User && $user->exists()) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic static function hasNew2FARecords() {\n\t\tif (version_compare(phpversion(), '5.3', '>=') && class_exists('\\WordfenceLS\\Controller_DB')) {\n\t\t\tglobal $wpdb;\n\t\t\t$table = WFLSPHP52Compatability::secrets_table();\n\t\t\treturn !!intval($wpdb->get_var(\"SELECT COUNT(*) FROM `{$table}`\"));\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\/**\n\t * Queries the API and returns whether or not the password exists in the breach database.\n\t * \n\t * @param string $login\n\t * @param string $password\n\t * @return bool\n\t *\/\n\tpublic static function isLeakedPassword($login, $password) {\n\t\t$sha1 = strtoupper(hash('sha1', $password));\n\t\t$prefix = substr($sha1, 0, 5);\n\t\t\n\t\t$ssl_verify = (bool) wfConfig::get('ssl_verify');\n\t\t$args = array(\n\t\t\t'timeout'    => 5,\n\t\t\t'user-agent' => \"Wordfence.com UA \" . (defined('WORDFENCE_VERSION') ? WORDFENCE_VERSION : '[Unknown version]'),\n\t\t\t'sslverify'  => $ssl_verify,\n\t\t\t'headers'\t => array('Referer' => false),\n\t\t);\n\t\t\n\t\tif (!$ssl_verify) { \/\/ Some versions of cURL will complain that SSL verification is disabled but the CA bundle was supplied.\n\t\t\t$args['sslcertificates'] = false;\n\t\t}\n\t\t\n\t\t$response = wp_remote_get(sprintf(WORDFENCE_BREACH_URL_BASE_SEC . \"%s.txt\", $prefix), $args);\n\t\t\n\t\tif (!is_wp_error($response)) {\n\t\t\t$data = wp_remote_retrieve_body($response);\n\t\t\t$lines = explode(\"\\n\", $data);\n\t\t\tforeach ($lines as $l) {\n\t\t\t\t$components = explode(\":\", $l);\n\t\t\t\t$teshSHA1 = $prefix . strtoupper($components[0]);\n\t\t\t\tif (hash_equals($sha1, $teshSHA1)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t\/**\n\t * Returns the transient key for the given user.\n\t * \n\t * @param WP_User $user\n\t * @return string\n\t *\/\n\tprotected static function _cachedCredentialStatusKey($user) {\n\t\t$key = 'wfcredentialstatus_' . $user->ID;\n\t\treturn $key;\n\t}\n\t\n\t\/**\n\t * Returns the cached credential status for the given user: self::UNCACHED, self::NOT_LEAKED, or self::LEAKED.\n\t * \n\t * @param WP_User $user\n\t * @return string\n\t *\/\n\tpublic static function cachedCredentialStatus($user) {\n\t\t$key = self::_cachedCredentialStatusKey($user);\n\t\t$value = get_transient($key);\n\t\tif ($value === false) {\n\t\t\treturn self::UNCACHED;\n\t\t}\n\t\t\n\t\t$status = substr($value, 0, 1);\n\t\tif (strlen($value) > 1) {\n\t\t\tif (!hash_equals(substr($value, 1), hash('sha256', $user->user_pass))) { \/\/Different hash but our clear function wasn't called so treat it as uncached\n\t\t\t\treturn self::UNCACHED;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif ($status) {\n\t\t\treturn self::LEAKED;\n\t\t}\n\t\treturn self::NOT_LEAKED;\n\t}\n\t\n\t\/**\n\t * Stores a cached leak value for the given user.\n\t * \n\t * @param WP_User $user\n\t * @param bool $isLeaked\n\t *\/\n\tpublic static function setCachedCredentialStatus($user, $isLeaked) {\n\t\t$key = self::_cachedCredentialStatusKey($user);\n\t\tset_transient($key, ($isLeaked ? '1' : '0') . hash('sha256', $user->user_pass), 3600);\n\t}\n\t\n\t\/**\n\t * Clears the cache for the given user.\n\t * \n\t * @param WP_User $user\n\t *\/\n\tpublic static function clearCachedCredentialStatus($user) {\n\t\t$key = self::_cachedCredentialStatusKey($user);\n\t\tdelete_transient($key);\n\t}\n\t\n\t\/**\n\t * Returns whether or not we've seen a successful login from $ip for the given user.\n\t * \n\t * @param WP_User $user\n\t * @param string $ip\n\t * @return bool\n\t *\/\n\tpublic static function hasPreviousLoginFromIP($user, $ip) {\n\t\tglobal $wpdb;\n\t\t$table_wfLogins = wfDB::networkTable('wfLogins');\n\t\t\n\t\t$id = property_exists($user, 'ID') ? $user->ID : 0;\n\t\tif ($id == 0) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t$ipHex = wfDB::binaryValueToSQLHex(wfUtils::inet_pton($ip));\n\t\t$result = $wpdb->get_row($wpdb->prepare(\"SELECT id FROM {$table_wfLogins} WHERE action = 'loginOK' AND userID = %d AND IP = {$ipHex} LIMIT 0,1\", $id), ARRAY_A);\n\t\tif (is_array($result)) {\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\t$lastAdminLogin = wfConfig::get_ser('lastAdminLogin');\n\t\tif (is_array($lastAdminLogin) && isset($lastAdminLogin['userID']) && isset($lastAdminLogin['IP'])) {\n\t\t\tif ($lastAdminLogin['userID'] == $id && wfUtils::inet_pton($lastAdminLogin['IP']) == wfUtils::inet_pton($ip)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t\/\/Final check -- if the IP recorded at plugin activation matches, let it through. This is __only__ checked when we don't have any other record of an admin login.\n\t\t$activatingIP = wfConfig::get('activatingIP');\n\t\tif (wfUtils::isValidIP($activatingIP)) {\n\t\t\tif (wfUtils::inet_pton($activatingIP) == wfUtils::inet_pton($ip)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n}"},{"base":"plugins","rel":"wordfence\/lib\/wfUnlockMsg.php","ext":"php","size":1168,"mtime":1757312769,"type":"text","content":"<?php if (!defined('WORDFENCE_VERSION')) { exit; } ?>\n<p><?php wfI18n::esc_html_e('If you are a WordPress user with administrative privileges on this site please enter your email in the box below and click \"Send\". You will then receive an email that helps you regain access.', 'wordfence'); ?><\/p>\n<form method=\"POST\" id=\"unlock-form\" action=\"#\">\n\t<?php require_once(ABSPATH . 'wp-includes\/pluggable.php'); ?>\n\t<input type=\"hidden\" name=\"nonce\" value=\"<?php echo wp_create_nonce('wf-form'); ?>\">\n\t<input type=\"text\" size=\"50\" name=\"email\" id=\"unlock-email\" value=\"\" maxlength=\"255\" placeholder=\"email@example.com\">&nbsp;&nbsp;<input type=\"submit\" class=\"wf-btn wf-btn-default\" id=\"unlock-submit\" name=\"s\" value=\"<?php wfI18n::esc_html_e('Send Unlock Email', 'wordfence'); ?>\" disabled>\n<\/form>\n<script type=\"application\/javascript\">\n\t(function() {\n\t\tvar textfield = document.getElementById('unlock-email');\n\t\ttextfield.addEventListener('focus', function() {\n\t\t\tdocument.getElementById('unlock-form').action = \"<?php echo esc_js(wfUtils::getSiteBaseURL()); ?>\" + \"?_wfsf=unlockEmail\";\n\t\t\tdocument.getElementById('unlock-submit').disabled = false;\n\t\t});\n\t})();\n<\/script>"},{"base":"plugins","rel":"wordfence\/lib\/wfDirectoryIterator.php","ext":"php","size":1937,"mtime":1757312769,"type":"text","content":"<?php\n\nabstract class wfDirectoryIterator {\n\n\tabstract public function file($file);\n\n\t\/**\n\t * @var string\n\t *\/\n\tprivate $directory;\n\n\t\/**\n\t * @var int\n\t *\/\n\tprivate $directory_limit;\n\t\n\t\n\tprivate $directories_entered = array();\n\tprivate $directories_processed = array();\n\n\t\/**\n\t * @var callback\n\t *\/\n\tprivate $callback;\n\t\/**\n\t * @var int\n\t *\/\n\tprivate $max_iterations;\n\tprivate $iterations;\n\n\t\/**\n\t * @param string $directory\n\t * @param int    $max_files_per_directory\n\t * @param int    $max_iterations\n\t *\/\n\tpublic function __construct($directory = ABSPATH, $max_files_per_directory = 20000, $max_iterations = 1000000) {\n\t\t$this->directory = $directory;\n\t\t$this->directory_limit = $max_files_per_directory;\n\t\t$this->max_iterations = $max_iterations;\n\t}\n\n\tpublic function run() {\n\t\t$this->iterations = 0;\n\t\t$this->scan($this->directory);\n\t}\n\n\tprotected function scan($dir) {\n\t\t$dir = rtrim($dir, DIRECTORY_SEPARATOR);\n\t\t$handle = opendir($dir);\n\t\t$file_count = 0;\n\t\twhile ($file = readdir($handle)) {\n\t\t\tif ($file == '.' || $file == '..') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t$file_path = $dir . '\/' . $file;\n\t\t\t$real_path = realpath($file_path);\n\t\t\tif (isset($this->directories_processed[$real_path]) || isset($this->directories_entered[$real_path])) { \/\/Already processed or being processed, possibly a recursive symlink\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\telse if (is_dir($file_path)) {\n\t\t\t\t$this->directories_entered[$real_path] = 1;\n\t\t\t\tif ($this->scan($file_path) === false) {\n\t\t\t\t\tclosedir($handle);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t$this->directories_processed[$real_path] = 1;\n\t\t\t\tunset($this->directories_entered[$real_path]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ($this->file($file_path) === false) {\n\t\t\t\t\tclosedir($handle);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (++$file_count >= $this->directory_limit) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++$this->iterations >= $this->max_iterations) {\n\t\t\t\tclosedir($handle);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tclosedir($handle);\n\t\treturn true;\n\t}\n}\n\n"},{"base":"plugins","rel":"wordfence\/lib\/menu_firewall_blocking.php","ext":"php","size":10495,"mtime":1757312769,"type":"text","content":"<?php\nif (!defined('WORDFENCE_VERSION')) { exit; }\n?>\n<div class=\"wf-row\">\n\t<div class=\"wf-col-xs-12\">\n\t\t<div class=\"wf-block wf-block-no-header wf-active\">\n\t\t\t<div class=\"wf-block-content\">\n\t\t\t\t<ul class=\"wf-block-list\">\n\t\t\t\t\t<li>\n\t\t\t\t\t\t<?php\n\t\t\t\t\t\techo wfView::create('blocking\/blocking-status', array(\n\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t?>\n\t\t\t\t\t<\/li>\n\t\t\t\t<\/ul>\n\t\t\t<\/div>\n\t\t<\/div>\n\t<\/div>\n<\/div>\n<div class=\"wf-row\">\n\t<div class=\"wf-col-xs-12\">\n\t\t<div class=\"wf-block wf-always-active\">\n\t\t\t<?php if (!wfConfig::get('firewallEnabled')): ?>\n\t\t\t<ul class=\"wf-block-banner\">\n\t\t\t\t<li><?php echo wp_kses(__('<strong>Note:<\/strong> Blocking is disabled when the option \"Enable Rate Limiting and Advanced Blocking\" is off.', 'wordfence'), array('strong'=>array())); ?><\/li>\n\t\t\t\t<li><a href=\"#\" class=\"wf-btn wf-btn-default\" id=\"wf-blocking-enable\" role=\"button\"><?php esc_html_e('Turn On', 'wordfence'); ?><\/a><\/li>\n\t\t\t<\/ul>\n\t\t\t<?php endif; ?>\n\t\t\t<?php if (version_compare(phpversion(), '5.4') < 0 && wfConfig::get('isPaid') && wfBlock::hasCountryBlock()): ?>\n\t\t\t\t<ul class=\"wf-block-banner\">\n\t\t\t\t\t<li><?php echo esc_html(sprintf(\n\t\t\t\t\t\t\t\/* translators: PHP version. *\/\n\t\t\t\t\t\t\t__('<strong>Note:<\/strong> The GeoIP database that is required for country blocking has been updated to a new format. This new format requires sites to run PHP 5.4 or newer, and this site is on PHP %s. To ensure country blocking continues functioning, please update PHP.', 'wordfence'), wfUtils::cleanPHPVersion())); ?><\/li>\n\t\t\t\t\t<li><a href=\"<?php echo wfSupportController::esc_supportURL(wfSupportController::ITEM_SCAN_RESULT_GEOIP_UPDATE); ?>\" class=\"wf-btn wf-btn-default\" target=\"_blank\" rel=\"noopener noreferrer\"><?php esc_html_e('More Information', 'wordfence'); ?><span class=\"screen-reader-text\"> (<?php esc_html_e('opens in new tab', 'wordfence') ?>)<\/span><\/a><\/li>\n\t\t\t\t<\/ul>\n\t\t\t<?php endif; ?>\n\t\t\t<div class=\"wf-block-header\">\n\t\t\t\t<div class=\"wf-block-header-content\">\n\t\t\t\t\t<div class=\"wf-block-title\">\n\t\t\t\t\t\t<strong id=\"wf-block-parameters-title\" data-new-title=\"<?php esc_attr_e('Create a Blocking Rule', 'wordfence'); ?>\" data-edit-title=\"<?php esc_attr_e('Edit Blocking Rule', 'wordfence'); ?>\"><?php esc_html_e('Create a Blocking Rule', 'wordfence'); ?><\/strong>\n\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t<\/div>\n\t\t\t<div class=\"wf-block-content\">\n\t\t\t\t<?php\n\t\t\t\techo wfView::create('blocking\/blocking-create', array(\n\t\t\t\t))->render();\n\t\t\t\t?>\n\t\t\t<\/div>\n\t\t<\/div>\n\t<\/div>\n<\/div> <!-- end firewall status -->\n<?php\necho wfView::create('blocking\/block-list', array(\n))->render();\n?>\n<div id=\"wf-overlay-wrapper\" style=\"display: none\">\n\t<div class=\"wf-overlay\">\n\t\t<div class=\"wf-overlay-header\"><\/div>\n\t\t<div class=\"wf-overlay-body\"><\/div>\n\t\t<span class=\"wf-overlay-close wf-ion-android-close\"><\/span>\n\t<\/div>\n<\/div>\n<script type=\"application\/javascript\">\n\t(function($) {\n\t\t$(function() {\n\t\t\t$('#wf-blocking-enable').on('click', function(e) {\n\t\t\t\te.preventDefault();\n\t\t\t\te.stopPropagation();\n\n\t\t\t\tWFAD.setOption('firewallEnabled', 1, function() {\n\t\t\t\t\twindow.location.reload(true);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t})(jQuery);\n<\/script>\n<?php if (wfOnboardingController::willShowNewTour(wfOnboardingController::TOUR_BLOCKING)): ?>\n\t<script type=\"application\/javascript\">\n\t\t(function($) {\n\t\t\t$(function() {\n\t\t\t\tWFAD.setUpBlockingTour = function() {\n\t\t\t\t\tWFAD.tour1 = function () {\n\t\t\t\t\t\tWFAD.tour('wfBlockingNewTour1', 'wf-section-blocking', 'top', 'left', null, WFAD.tour2);\n\t\t\t\t\t};\n\t\t\t\t\tWFAD.tour2 = function () {\n\t\t\t\t\t\tWFAD.tour('wfBlockingNewTour2', 'wf-create-block', 'top', 'top', WFAD.tour1, WFAD.tour3);\n\t\t\t\t\t};\n\t\t\t\t\tWFAD.tour3 = function () {\n\t\t\t\t\t\tWFAD.tour('wfBlockingNewTour3', 'wf-blocks-wrapper', 'bottom', 'bottom', WFAD.tour2, WFAD.tourComplete);\n\t\t\t\t\t};\n\t\t\t\t\tWFAD.tourComplete = function () {\n\t\t\t\t\t\tWFAD.tourFinish('<?php echo esc_attr(wfOnboardingController::TOUR_BLOCKING); ?>');\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tWFAD.blockingTourShown = false;\n\t\t\t\t<?php if (wfOnboardingController::shouldShowNewTour(wfOnboardingController::TOUR_BLOCKING)): ?>\n\t\t\t\t$(window).on('wfTabChange', function(e, tab) {\n\t\t\t\t\tif (tab == 'blocking' && !WFAD.blockingTourShown) {\n\t\t\t\t\t\tWFAD.blockingTourShown = true;\n\t\t\t\t\t\tWFAD.setUpBlockingTour();\n\t\t\t\t\t\tif (!WFAD.isSmallScreen) { WFAD.tour1(); }\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif ($('#blocking').hasClass('wf-active')) {\n\t\t\t\t\tWFAD.blockingTourShown = true;\n\t\t\t\t\tWFAD.setUpBlockingTour();\n\t\t\t\t\tif (!WFAD.isSmallScreen) { WFAD.tour1(); }\n\t\t\t\t}\n\t\t\t\t<?php endif; ?>\n\t\t\t});\n\t\t})(jQuery);\n\t<\/script>\n\n\t<script type=\"text\/x-jquery-template\" id=\"wfBlockingNewTour1\">\n\t\t<div>\n\t\t\t<h3><?php esc_html_e('Blocking', 'wordfence'); ?><\/h3>\n\t\t\t<p><?php esc_html_e('Wordfence lets you take control of protecting your site with powerful blocking features. Block traffic based on IP, IP range, hostname, browser, or referrer. Country blocking is available for Premium customers.', 'wordfence'); ?><\/p>\n\t\t\t<div class=\"wf-pointer-footer\">\n\t\t\t\t<ul class=\"wf-tour-pagination\">\n\t\t\t\t\t<li class=\"wf-active\">&bullet;<\/li>\n\t\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t<\/ul>\n\t\t\t\t<div id=\"wf-tour-continue\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-primary\" role=\"button\"><?php esc_html_e('Next', 'wordfence'); ?><\/a><\/div>\n\t\t\t<\/div>\n\t\t\t<div id=\"wf-tour-close\"><a href=\"#\" role=\"button\"><i class=\"wf-fa wf-fa-times-circle\" aria-hidden=\"true\"><\/i><\/a><\/div>\n\t\t<\/div>\n\t<\/script>\n\t<script type=\"text\/x-jquery-template\" id=\"wfBlockingNewTour2\">\n\t\t<div>\n\t\t\t<h3><?php esc_html_e('Blocking Builder', 'wordfence'); ?><\/h3>\n\t\t\t<p><?php esc_html_e('All of your blocking rules are in one central location. Choose the Block Type, then enter the details for the rule. Once it has been added, you\\'ll see it saved as a rule for your site.', 'wordfence'); ?><\/p>\n\t\t\t<div class=\"wf-pointer-footer\">\n\t\t\t\t<ul class=\"wf-tour-pagination\">\n\t\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t\t<li class=\"wf-active\">&bullet;<\/li>\n\t\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t<\/ul>\n\t\t\t\t<div id=\"wf-tour-previous\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-default\" role=\"button\"><?php esc_html_e('Previous', 'wordfence'); ?><\/a><\/div>\n\t\t\t\t<div id=\"wf-tour-continue\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-primary\" role=\"button\"><?php esc_html_e('Next', 'wordfence'); ?><\/a><\/div>\n\t\t\t<\/div>\n\t\t\t<div id=\"wf-tour-close\"><a href=\"#\" role=\"button\"><i class=\"wf-fa wf-fa-times-circle\" aria-hidden=\"true\"><\/i><\/a><\/div>\n\t\t<\/div>\n\t<\/script>\n\t<script type=\"text\/x-jquery-template\" id=\"wfBlockingNewTour3\">\n\t\t<div>\n\t\t\t<h3><?php esc_html_e('Manage Blocking Rules', 'wordfence'); ?><\/h3>\n\t\t\t<p><?php esc_html_e('Here\\'s where you\\'ll see all the blocking rules you\\'ve created. You can also manage them as well as remove or modify them from this table.', 'wordfence'); ?><\/p>\n\t\t\t<div class=\"wf-pointer-footer\">\n\t\t\t\t<ul class=\"wf-tour-pagination\">\n\t\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t\t<li class=\"wf-active\">&bullet;<\/li>\n\t\t\t\t<\/ul>\n\t\t\t\t<div id=\"wf-tour-previous\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-default\" role=\"button\"><?php esc_html_e('Previous', 'wordfence'); ?><\/a><\/div>\n\t\t\t\t<div id=\"wf-tour-continue\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-primary\" role=\"button\"><?php esc_html_e('Got it', 'wordfence'); ?><\/a><\/div>\n\t\t\t<\/div>\n\t\t\t<div id=\"wf-tour-close\"><a href=\"#\" role=\"button\"><i class=\"wf-fa wf-fa-times-circle\" aria-hidden=\"true\"><\/i><\/a><\/div>\n\t\t<\/div>\n\t<\/script>\n<?php endif; ?>\n\n<?php if (wfOnboardingController::willShowUpgradeTour(wfOnboardingController::TOUR_BLOCKING)): ?>\n\t<script type=\"application\/javascript\">\n\t\t(function($) {\n\t\t\t$(function() {\n\t\t\t\tWFAD.setUpBlockingTour = function() {\n\t\t\t\t\tWFAD.tour1 = function () {\n\t\t\t\t\t\tWFAD.tour('wfBlockingUpgradeTour1', 'wf-create-block', 'top', 'top', null, WFAD.tour2);\n\t\t\t\t\t};\n\t\t\t\t\tWFAD.tour2 = function () {\n\t\t\t\t\t\tWFAD.tour('wfBlockingUpgradeTour2', 'wf-blocks-wrapper', 'bottom', 'bottom', WFAD.tour1, WFAD.tourComplete);\n\t\t\t\t\t};\n\t\t\t\t\tWFAD.tourComplete = function () {\n\t\t\t\t\t\tWFAD.tourFinish('<?php echo esc_attr(wfOnboardingController::TOUR_BLOCKING); ?>');\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\tWFAD.blockingTourShown = false;\n\t\t\t\t<?php if (wfOnboardingController::shouldShowUpgradeTour(wfOnboardingController::TOUR_BLOCKING)): ?>\n\t\t\t\t$(window).on('wfTabChange', function(e, tab) {\n\t\t\t\t\tif (tab == 'blocking' && !WFAD.blockingTourShown) {\n\t\t\t\t\t\tWFAD.blockingTourShown = true;\n\t\t\t\t\t\tWFAD.setUpBlockingTour();\n\t\t\t\t\t\tif (!WFAD.isSmallScreen) { WFAD.tour1(); }\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif ($('#blocking').hasClass('wf-active')) {\n\t\t\t\t\tWFAD.blockingTourShown = true;\n\t\t\t\t\tWFAD.setUpBlockingTour();\n\t\t\t\t\tif (!WFAD.isSmallScreen) { WFAD.tour1(); }\n\t\t\t\t}\n\t\t\t\t<?php endif; ?>\n\t\t\t});\n\t\t})(jQuery);\n\t<\/script>\n\n\t<script type=\"text\/x-jquery-template\" id=\"wfBlockingUpgradeTour1\">\n\t\t<div>\n\t\t\t<h3><?php esc_html_e('Blocking Builder', 'wordfence'); ?><\/h3>\n\t\t\t<p><?php echo wp_kses(__('All of the blocking rules you create are now in one central location. Simply choose the block type and enter the details for the rule you want to create. Premium users have access to advanced country blocking options, found via the <strong>Options<\/strong> link.', 'wordfence'), array('strong'=>array())); ?><\/p>\n\t\t\t<div class=\"wf-pointer-footer\">\n\t\t\t\t<ul class=\"wf-tour-pagination\">\n\t\t\t\t\t<li class=\"wf-active\">&bullet;<\/li>\n\t\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t<\/ul>\n\t\t\t\t<div id=\"wf-tour-continue\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-primary\" role=\"button\"><?php esc_html_e('Next', 'wordfence'); ?><\/a><\/div>\n\t\t\t<\/div>\n\t\t\t<div id=\"wf-tour-close\"><a href=\"#\" role=\"button\"><i class=\"wf-fa wf-fa-times-circle\" aria-hidden=\"true\"><\/i><\/a><\/div>\n\t\t<\/div>\n\t<\/script>\n\t<script type=\"text\/x-jquery-template\" id=\"wfBlockingUpgradeTour2\">\n\t\t<div>\n\t\t\t<h3><?php esc_html_e('Manage Blocking Rules', 'wordfence'); ?><\/h3>\n\t\t\t<p><?php esc_html_e('All blocking rules you create will show here. You can manage them as well as remove or modify them from the same location.', 'wordfence'); ?><\/p>\n\t\t\t<div class=\"wf-pointer-footer\">\n\t\t\t\t<ul class=\"wf-tour-pagination\">\n\t\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t\t<li class=\"wf-active\">&bullet;<\/li>\n\t\t\t\t<\/ul>\n\t\t\t\t<div id=\"wf-tour-previous\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-default\" role=\"button\"><?php esc_html_e('Previous', 'wordfence'); ?><\/a><\/div>\n\t\t\t\t<div id=\"wf-tour-continue\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-primary\" role=\"button\"><?php esc_html_e('Got it', 'wordfence'); ?><\/a><\/div>\n\t\t\t<\/div>\n\t\t\t<div id=\"wf-tour-close\"><a href=\"#\" role=\"button\"><i class=\"wf-fa wf-fa-times-circle\" aria-hidden=\"true\"><\/i><\/a><\/div>\n\t\t<\/div>\n\t<\/script>\n<?php endif; ?>"},{"base":"plugins","rel":"wordfence\/lib\/menu_dashboard_options.php","ext":"php","size":15739,"mtime":1757312769,"type":"text","content":"<?php\nif (!defined('WORDFENCE_VERSION')) { exit; }\n$dashboardURL = network_admin_url('admin.php?page=Wordfence');\n$firewall = new wfFirewall();\n$scanner = wfScanner::shared();\n$d = new wfDashboard();\n?>\n<script type=\"application\/javascript\">\n\t(function($) {\n\t\t$(function() {\n\t\t\tdocument.title = \"<?php esc_attr_e('Wordfence Global Options', 'wordfence'); ?>\" + \" \\u2039 \" + WFAD.basePageName;\n\n\t\t\t\/\/Hash-based option block linking\n\t\t\tif (window.location.hash) {\n\t\t\t\tvar hashes = WFAD.parseHashes();\n\t\t\t\tvar hash = hashes[hashes.length - 1];\n\t\t\t\tvar block = $('.wf-block[data-persistence-key=\"' + hash + '\"]');\n\t\t\t\tif (block) {\n\t\t\t\t\tif (!block.hasClass('wf-active')) {\n\t\t\t\t\t\tblock.find('.wf-block-content').slideDown({\n\t\t\t\t\t\t\talways: function() {\n\t\t\t\t\t\t\t\tblock.addClass('wf-active');\n\t\t\t\t\t\t\t\t$('html, body').animate({\n\t\t\t\t\t\t\t\t\tscrollTop: block.offset().top - 100\n\t\t\t\t\t\t\t\t}, 1000);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tWFAD.ajax('wordfence_saveDisclosureState', {name: block.data('persistenceKey'), state: true}, function() {});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t$('html, body').animate({\n\t\t\t\t\t\t\tscrollTop: block.offset().top - 100\n\t\t\t\t\t\t}, 1000);\n\t\t\t\t\t}\n\t\t\t\t\thistory.replaceState('', document.title, window.location.pathname + window.location.search);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t})(jQuery);\n<\/script>\n<div class=\"wf-options-controls\">\n\t<div class=\"wf-row\">\n\t\t<div class=\"wf-col-xs-12\">\n\t\t\t<?php\n\t\t\techo wfView::create('options\/block-controls', array(\n\t\t\t\t'backLink' => $dashboardURL,\n\t\t\t\t'backLabelHTML' => wp_kses(__('Back<span class=\"wf-hidden-xs\"> to Dashboard<\/span>', 'wordfence'), array('span'=>array('class'=>array()))),\n\t\t\t\t'restoreDefaultsSection' => wfConfig::OPTIONS_TYPE_GLOBAL,\n\t\t\t\t'restoreDefaultsMessage' => __('Are you sure you want to restore the default global settings? This will undo any custom changes you have made to the options on this page. Your configured license key and alert emails will not be changed.', 'wordfence'),\n\t\t\t))->render();\n\t\t\t?>\n\t\t<\/div>\n\t<\/div>\n<\/div>\n<div class=\"wf-options-controls-spacer\"><\/div>\n<?php\nif (!wfOnboardingController::shouldShowAttempt3() && wfConfig::get('touppPromptNeeded')) {\n\techo wfView::create('gdpr\/disabled-overlay')->render();\n\techo wfView::create('gdpr\/banner')->render();\n}\n?>\n<div class=\"wrap wordfence\" id=\"wf-global-options\">\n\t<div class=\"wf-container-fluid\">\n\t\t<div class=\"wf-row\">\n\t\t\t<div class=\"wf-col-xs-12\">\n\t\t\t\t<div class=\"wp-header-end\"><\/div>\n\t\t\t<\/div>\n\t\t<\/div>\n\t\t<div class=\"wf-row\">\n\t\t\t<div class=\"<?php echo wfStyle::contentClasses(); ?>\">\n\t\t\t\t<div id=\"waf-options\" class=\"wf-fixed-tab-content\">\n\t\t\t\t\t<?php\n\t\t\t\t\techo wfView::create('common\/section-title', array(\n\t\t\t\t\t\t'title' => __('Wordfence Global Options', 'wordfence'),\n\t\t\t\t\t\t'helpLink' => wfSupportController::supportURL(wfSupportController::ITEM_DASHBOARD_OPTIONS),\n\t\t\t\t\t\t'helpLabelHTML' => wp_kses(__('Learn more<span class=\"wf-hidden-xs\"> about Global Options<\/span>', 'wordfence'), array('span'=>array('class'=>array()))),\n\t\t\t\t\t\t'showIcon' => true,\n\t\t\t\t\t))->render();\n\t\t\t\t\t?>\n\t\t\t\t\t<div class=\"wf-row\">\n\t\t\t\t\t\t<div class=\"wf-col-xs-12\">\n\t\t\t\t\t\t\t<div class=\"wf-block wf-active\">\n\t\t\t\t\t\t\t\t<div class=\"wf-block-content\">\n\t\t\t\t\t\t\t\t\t<ul class=\"wf-block-list\">\n\t\t\t\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t\t\t\t<ul class=\"wf-block-list wf-block-list-horizontal wf-block-list-nowrap wf-waf-coverage\">\n\t\t\t\t\t\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\t\t\t\t\techo wfView::create('common\/status-detail', array(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t'id' => 'waf-coverage',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t'percentage' => $firewall->overallStatus(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t'activeColor' => ($firewall->firewallMode() == wfFirewall::FIREWALL_MODE_LEARNING ? '#ececec' : null \/* automatic *\/),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t'title' => __('Firewall', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t'subtitle' => ($firewall->firewallMode() == wfFirewall::FIREWALL_MODE_LEARNING ? __('WAF Currently in Learning Mode', 'wordfence') : __('Protection from known and emerging threats', 'wordfence')),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t'link' => wfPage::pageURL(wfPage::PAGE_FIREWALL_OPTIONS, wfPage::PAGE_DASHBOARD_OPTIONS),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t'linkLabel' => __('Manage Firewall', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t'statusTitle' => __('Firewall Status', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t'statusList' => $firewall->statusList(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t'statusExtra' => ($firewall->firewallMode() == wfFirewall::FIREWALL_MODE_LEARNING ? wfView::create('waf\/status-tooltip-learning-mode')->render() : ''),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t'helpLink' => __('https:\/\/www.wordfence.com\/help\/dashboard\/#dashboard-status', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\t\t\t\t\techo wfView::create('common\/status-detail', array(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t'id' => 'wf-scanner-type',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t'percentage' => $scanner->scanTypeStatus(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t'activeColor' => (!$scanner->isEnabled() ? '#ececec' : null \/* automatic *\/),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t'title' => __('Scan', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t'subtitle' => __('Detection of security issues', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t'link' => wfPage::pageURL(wfPage::PAGE_SCAN_OPTIONS, wfPage::PAGE_DASHBOARD_OPTIONS),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t'linkLabel' => __('Manage Scan', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t'statusTitle' => __('Scan Status', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t'statusList' => $scanner->scanTypeStatusList(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t'helpLink' => __('https:\/\/www.wordfence.com\/help\/dashboard\/#dashboard-status', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<?php if (wfConfig::get('hasKeyConflict')): ?>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\t\t\t\t\t\techo wfView::create('common\/status-critical', array(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'id' => 'wf-premium-alert',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'title' => __('Premium License Conflict', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'subtitle' => __('License already in use', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'link' => 'https:\/\/www.wordfence.com\/gnl1manageConflict\/manage-wordfence-api-keys\/',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'linkLabel' => __('Reset License', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'linkNewWindow' => true,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<?php elseif (wfConfig::get('keyType') == wfLicense::KEY_TYPE_PAID_EXPIRED): ?>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\t\t\t\t\t\techo wfView::create('common\/status-critical', array(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'id' => 'wf-premium-alert',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'title' => __('Premium Protection Disabled', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'subtitle' => __('License is expired', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'link' => 'https:\/\/www.wordfence.com\/gnl1renewExpired\/manage-wordfence-api-keys\/',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'linkLabel' => __('Renew License', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'linkNewWindow' => true,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<?php elseif (wfConfig::get('keyType') == wfLicense::KEY_TYPE_PAID_DELETED): ?>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\t\t\t\t\t\techo wfView::create('common\/status-critical', array(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'id' => 'wf-premium-alert',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'title' => __('Premium Protection Disabled', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'subtitleHtml' => wp_kses(__('The license you were using has been removed from your account. Please reach out to <a href=\"mailto:billing@wordfence.com\">billing@wordfence.com<\/a> or create a Premium support case at <a href=\"https:\/\/support.wordfence.com\/support\/tickets\" target=\"_blank\">https:\/\/support.wordfence.com\/support\/tickets<span class=\"screen-reader-text\"> (opens in new tab)<\/span><\/a> for more information. Our staff is happy to help.', 'wordfence'), array('a'=>array('href'=>array(), 'target'=>array()), 'span'=>array('class'=>array()))),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'link' => null,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'linkLabel' => null\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<?php elseif (wfConfig::get('keyType') == wfLicense::KEY_TYPE_FREE || wfConfig::get('keyType') === false): ?>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<p><h3><?php esc_html_e('Premium Protection Disabled', 'wordfence'); ?><\/h3><\/p>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<p><?php esc_html_e('As a free Wordfence user, you are currently using the Community version of the Threat Defense Feed. Premium users are protected by additional firewall rules and malware signatures. Upgrade to Premium today to improve your protection.', 'wordfence'); ?><\/p>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<p><a class=\"wf-btn wf-btn-primary wf-btn-callout-subtle\" href=\"https:\/\/www.wordfence.com\/gnl1dashboardOptionsUpgrade\/products\/wordfence-premium\/\" target=\"_blank\" rel=\"noopener noreferrer\"><?php esc_html_e('Upgrade to Premium', 'wordfence'); ?><\/a>&nbsp;&nbsp;<a class=\"wf-btn wf-btn-callout-subtle wf-btn-default\" href=\"https:\/\/www.wordfence.com\/gnl1dashboardOptionsLearn\/products\/pricing\/\" target=\"_blank\" rel=\"noopener noreferrer\"><?php esc_html_e('Learn More', 'wordfence'); ?><span class=\"screen-reader-text\"> (<?php esc_html_e('opens in new tab', 'wordfence') ?>)<\/span><\/a><\/p>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<?php elseif (wfConfig::get('keyExpDays') < 30 && (wfConfig::get('premiumAutoRenew', null) === '0' || wfConfig::get('premiumAutoRenew', null) === 0)): ?>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\t\t\t\t\t\techo wfView::create('common\/status-critical', array(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'id' => 'wf-premium-alert',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'title' => sprintf(\/* translators: %s: License type *\/__('%s License Expiring', 'wordfence'), wfLicense::current()->getBaseTypeLabel()),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'subtitle' => __('Auto-renew is disabled', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'link' => 'https:\/\/www.wordfence.com\/gnl1renewExpiring\/manage-wordfence-api-keys\/',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'linkLabel' => __('Renew License', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'linkNewWindow' => true,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<?php elseif (wfConfig::get('keyExpDays') < 30): ?>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (wfConfig::get('premiumPaymentExpiring')) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t$title = __('Payment Method Expiring', 'wordfence');\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\telse if (wfConfig::get('premiumPaymentExpired')) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t$title = __('Payment Method Expired', 'wordfence');\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\telse if (wfConfig::get('premiumPaymentMissing')) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t$title = __('Payment Method Missing', 'wordfence');\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\telse if (wfConfig::get('premiumPaymentHold')) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t$title = __('Payment Method Invalid', 'wordfence');\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (isset($title)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t$days = floor(((int) wfConfig::get('premiumNextRenew') - time()) \/ 86400);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif ($days <= 0) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t$days = __('today', 'wordfence');\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse if ($days == 1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t$days = __('tomorrow', 'wordfence');\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t$days = sprintf(\/* translators: Number of days *\/ __('in %d days', 'wordfence'), $days);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\techo wfView::create('dashboard\/status-payment-expiring', array(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'id' => 'wf-premium-alert',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'title' => $title,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'subtitle' => sprintf(__('License renews %s', 'wordfence'), $days),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'link' => 'https:\/\/www.wordfence.com\/gnl1renewExpiring\/manage-wordfence-api-keys\/',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'linkLabel' => __('Update Payment Method', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'linkNewWindow' => true,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t$days = floor(((int) wfConfig::get('premiumNextRenew') - time()) \/ 86400);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif ($days == 0) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t$days = __('today', 'wordfence');\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse if ($days == 1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t$days = __('in 1 day', 'wordfence');\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t$days = sprintf(__('in %d days', 'wordfence'), $days);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\techo wfView::create('dashboard\/status-renewing', array(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'id' => 'wf-premium-alert',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'title' => sprintf(\/* translators: %s: License type *\/__('%s License Expiring', 'wordfence'), wfLicense::current()->getBaseTypeLabel()),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'subtitle' => sprintf(__('License renews %s', 'wordfence'), $days),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'link' => 'https:\/\/www.wordfence.com\/gnl1reviewExpiring\/manage-wordfence-api-keys\/',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'linkLabel' => __('Review Payment Method', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'linkNewWindow' => true,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<?php elseif (wfConfig::get('keyType') == wfLicense::KEY_TYPE_PAID_CURRENT): ?>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<div class=\"wf-block-labeled-value wf-protection-status wf-protection-status-<?php echo esc_attr($firewall->ruleMode()); ?>\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<div class=\"wf-block-labeled-value-value\"><i class=\"wf-fa wf-fa-check\" aria-hidden=\"true\"><\/i><\/div>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<div class=\"wf-block-labeled-value-label\"><?php echo esc_html(sprintf(__('%s Enabled', 'wordfence'), wfLicense::current()->getPrefixedTypeLabel())); ?><\/div>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<?php if (wfLicense::current()->isBelowResponse()): ?>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<p>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<?php if (wfLicense::current()->isBelowCare()): ?>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<a href=\"https:\/\/www.wordfence.com\/gnl1dashboardLearnCareResponse\/products\/pricing\/\"><?php esc_html_e('Learn about Wordfence Care and Wordfence Response', 'wordfence') ?><\/a>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<?php else: ?>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<a href=\"https:\/\/www.wordfence.com\/gnl1dashboardLearnResponse\/products\/wordfence-response\/\"><?php esc_html_e('Learn about Wordfence Response', 'wordfence') ?><\/a>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<?php endif ?>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/p>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<?php endif ?>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<?php endif; ?>\n\t\t\t\t\t\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t\t\t\t\t<\/ul>\n\t\t\t\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t\t\t<\/ul>\n\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t\t<\/div>\n\t\t\t\t\t<?php\n\t\t\t\t\techo wfView::create('dashboard\/options-group-license', array(\n\t\t\t\t\t\t'stateKey' => 'global-options-license',\n\t\t\t\t\t))->render();\n\t\t\t\t\t\n\t\t\t\t\techo wfView::create('dashboard\/options-group-view-customization', array(\n\t\t\t\t\t\t'stateKey' => 'global-options-view-customization',\n\t\t\t\t\t))->render();\n\t\t\t\t\t\n\t\t\t\t\techo wfView::create('dashboard\/options-group-general', array(\n\t\t\t\t\t\t'stateKey' => 'global-options-general',\n\t\t\t\t\t))->render();\n\t\t\t\t\t\n\t\t\t\t\techo wfView::create('dashboard\/options-group-dashboard', array(\n\t\t\t\t\t\t'stateKey' => 'global-options-dashboard',\n\t\t\t\t\t))->render();\n\t\t\t\t\t\n\t\t\t\t\techo wfView::create('dashboard\/options-group-alert', array(\n\t\t\t\t\t\t'stateKey' => 'global-options-alert',\n\t\t\t\t\t))->render();\n\t\t\t\t\t\n\t\t\t\t\techo wfView::create('dashboard\/options-group-email-summary', array(\n\t\t\t\t\t\t'stateKey' => 'global-options-email-summary',\n\t\t\t\t\t))->render();\n\t\t\t\t\t?>\n\t\t\t\t\t<div class=\"wf-row\">\n\t\t\t\t\t\t<div class=\"wf-col-xs-12\">\n\t\t\t\t\t\t\t<div class=\"wf-block wf-always-active\">\n\t\t\t\t\t\t\t\t<div class=\"wf-block-header\">\n\t\t\t\t\t\t\t\t\t<div class=\"wf-block-header-content\">\n\t\t\t\t\t\t\t\t\t\t<div class=\"wf-block-title\">\n\t\t\t\t\t\t\t\t\t\t\t<strong><?php esc_html_e('Import\/Export Options', 'wordfence'); ?><\/strong>\n\t\t\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t\t<div class=\"wf-block-content\">\n\t\t\t\t\t\t\t\t\t<ul class=\"wf-block-list\">\n\t\t\t\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t\t\t\t<ul class=\"wf-flex-horizontal wf-flex-vertical-xs wf-flex-full-width wf-add-top wf-add-bottom\">\n\t\t\t\t\t\t\t\t\t\t\t\t<li><?php esc_html_e('Importing and exporting of options has moved to the Tools page', 'wordfence'); ?><\/li>\n\t\t\t\t\t\t\t\t\t\t\t\t<li class=\"wf-right wf-left-xs wf-padding-add-top-xs-small\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t<a href=\"<?php echo esc_url(network_admin_url('admin.php?page=WordfenceTools&subpage=importexport')); ?>\" class=\"wf-btn wf-btn-primary wf-btn-callout-subtle\" id=\"wf-export-options\"><?php esc_html_e('Import\/Export Options', 'wordfence'); ?><\/a>\n\t\t\t\t\t\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t\t\t\t\t<\/ul>\n\t\t\t\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t\t\t<\/ul>\n\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t\t<\/div> <!-- end import options -->\n\t\t\t\t<\/div> <!-- end options block -->\n\t\t\t<\/div> <!-- end content block -->\n\t\t<\/div> <!-- end row -->\n\t<\/div> <!-- end container -->\n<\/div>"},{"base":"plugins","rel":"wordfence\/lib\/wordfenceHash.php","ext":"php","size":43726,"mtime":1757312769,"type":"text","content":"<?php\nrequire_once(dirname(__FILE__) . '\/wordfenceClass.php');\nclass wordfenceHash {\n\n\tconst KNOWN_FILE_CORE = 'core';\n\tconst KNOWN_FILE_PLUGIN = 'plugins';\n\tconst KNOWN_FILE_THEME = 'themes';\n\tconst KNOWN_FILE_OTHER = 'other';\n\tconst MAX_QUEUED_RECORDS = 500;\n\n\tprivate static $KNOWN_FILE_TYPES = [\n\t\tself::KNOWN_FILE_CORE,\n\t\tself::KNOWN_FILE_PLUGIN,\n\t\tself::KNOWN_FILE_THEME\n\t];\n\n\tprivate $engine = false;\n\tprivate $db = false;\n\tprivate $startTime = false;\n\tprivate $currentFile = null;\n\tprivate $scanFileLogger;\n\tprivate $knownFileExclude;\n\tprivate $fileRecords = [];\n\tprivate $fileRecordCount = 0;\n\n\t\/\/Begin serialized vars\n\tpublic $totalFiles = 0;\n\tpublic $totalDirs = 0;\n\tpublic $totalData = 0; \/\/To do a sanity check, don't use 'du' because it gets sparse files wrong and reports blocks used on disk. Use : find . -type f -ls | awk '{total += $7} END {print total}'\n\tpublic $stoppedOnFile = false;\n\tprivate $coreEnabled = false;\n\tprivate $pluginsEnabled = false;\n\tprivate $themesEnabled = false;\n\tprivate $malwareEnabled = false;\n\tprivate $coreUnknownEnabled = false;\n\tprivate $knownFiles = false;\n\tprivate $malwareData = \"\";\n\tprivate $coreHashesData = '';\n\tprivate $haveIssues = array();\n\tprivate $status = array();\n\tprivate $possibleMalware = array();\n\tprivate $scannedFiles;\n\tprivate $totalForks = 0;\n\tprivate $alertedOnUnknownWordPressVersion = false;\n\tprivate $foldersEntered = array();\n\tprivate $foldersProcessed = array();\n\tprivate $suspectedFiles = array();\n\tprivate $indexed = false;\n\tprivate $indexSize = 0;\n\tprivate $currentIndex = 0;\n\tprivate $coalescingIssues = array();\n\tprivate $pathMap = array();\n\n\t\/**\n\t * @param string $path\n\t * @param array $only\n\t * @param array $themes\n\t * @param array $plugins\n\t * @param wfScanEngine $engine\n\t * @throws Exception\n\t *\/\n\tpublic function __construct($scannedFiles, $engine, $malwarePrefixesHash, $coreHashesHash, $scanMode) {\n\t\t$this->scannedFiles = $scannedFiles;\n\t\t$this->engine = $engine;\n\n\t\t$this->startTime = microtime(true);\n\n\t\t$options = $this->engine->scanController()->scanOptions();\n\t\tif ($options['scansEnabled_core']) { $this->coreEnabled = true; }\n\t\tif ($options['scansEnabled_plugins']) { $this->pluginsEnabled = true; }\n\t\tif ($options['scansEnabled_themes']) { $this->themesEnabled = true; }\n\t\tif ($options['scansEnabled_malware']) { $this->malwareEnabled = true; }\n\t\tif ($options['scansEnabled_coreUnknown']) { $this->coreUnknownEnabled = true; }\n\n\t\t$this->db = new wfDB();\n\n\t\t\/\/Doing a delete for now. Later we can optimize this to only scan modified files.\n\t\t\/\/$this->db->queryWrite(\"update \" . wfDB::networkTable('wfFileMods') . \" set oldMD5 = newMD5\");\n\t\t$this->db->truncate(wfDB::networkTable('wfFileMods'));\n\t\t$this->db->truncate(wfDB::networkTable('wfKnownFileList'));\n\t\t$this->db->truncate(wfDB::networkTable('wfPendingIssues'));\n\t\t$fetchCoreHashesStatus = wfIssues::statusStart(__(\"Fetching core, theme and plugin file signatures from Wordfence\", 'wordfence'));\n\t\ttry {\n\t\t\t$this->knownFiles = $this->engine->getKnownFilesLoader()->getKnownFiles();\n\t\t} catch (wfScanKnownFilesException $e) {\n\t\t\twfIssues::statusEndErr();\n\t\t\tthrow $e;\n\t\t}\n\t\twfIssues::statusEnd($fetchCoreHashesStatus, wfIssues::STATUS_SUCCESS);\n\t\tif ($this->malwareEnabled) {\n\t\t\t$malwarePrefixStatus = wfIssues::statusStart(__(\"Fetching list of known malware files from Wordfence\", 'wordfence'));\n\t\t\t\n\t\t\t$stored = wfConfig::get_ser('malwarePrefixes', array(), false);\n\t\t\tif (is_array($stored) && isset($stored['hash']) && $stored['hash'] == $malwarePrefixesHash && isset($stored['prefixes']) && wfWAFUtils::strlen($stored['prefixes']) % 4 == 0) {\n\t\t\t\twordfence::status(4, 'info', __(\"Using cached malware prefixes\", 'wordfence'));\n\t\t\t}\n\t\t\telse {\n\t\t\t\twordfence::status(4, 'info', __(\"Fetching fresh malware prefixes\", 'wordfence'));\n\t\t\t\t\n\t\t\t\t$malwareData = $engine->api->getStaticURL('\/malwarePrefixes.bin');\n\t\t\t\tif (!$malwareData) {\n\t\t\t\t\twfIssues::statusEndErr();\n\t\t\t\t\tthrow new Exception(__(\"Could not fetch malware signatures from Wordfence servers.\", 'wordfence'));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (wfWAFUtils::strlen($malwareData) % 4 != 0) {\n\t\t\t\t\twfIssues::statusEndErr();\n\t\t\t\t\tthrow new Exception(__(\"Malware data received from Wordfence servers was not valid.\", 'wordfence'));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t$stored = array('hash' => $malwarePrefixesHash, 'prefixes' => $malwareData);\n\t\t\t\twfConfig::set_ser('malwarePrefixes', $stored, true, wfConfig::DONT_AUTOLOAD);\n\t\t\t}\n\t\t\t\n\t\t\t$this->malwareData = $stored['prefixes'];\n\t\t\twfIssues::statusEnd($malwarePrefixStatus, wfIssues::STATUS_SUCCESS);\n\t\t}\n\t\t\n\t\tif ($this->coreUnknownEnabled) {\n\t\t\t$coreHashesStatus = wfIssues::statusStart(__(\"Fetching list of known core files from Wordfence\", 'wordfence'));\n\t\t\t\n\t\t\t$stored = wfConfig::get_ser('coreHashes', array(), false);\n\t\t\tif (is_array($stored) && isset($stored['hash']) && $stored['hash'] == $coreHashesHash && isset($stored['hashes']) && wfWAFUtils::strlen($stored['hashes']) > 0 && wfWAFUtils::strlen($stored['hashes']) % 32 == 0) {\n\t\t\t\twordfence::status(4, 'info', __(\"Using cached core hashes\", 'wordfence'));\n\t\t\t}\n\t\t\telse {\n\t\t\t\twordfence::status(4, 'info', __(\"Fetching fresh core hashes\", 'wordfence'));\n\t\t\t\t\n\t\t\t\t$coreHashesData = $engine->api->getStaticURL('\/coreHashes.bin');\n\t\t\t\tif (!$coreHashesData) {\n\t\t\t\t\twfIssues::statusEndErr();\n\t\t\t\t\tthrow new Exception(__(\"Could not fetch core hashes from Wordfence servers.\", 'wordfence'));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (wfWAFUtils::strlen($coreHashesData) % 32 != 0) {\n\t\t\t\t\twfIssues::statusEndErr();\n\t\t\t\t\tthrow new Exception(__(\"Core hashes data received from Wordfence servers was not valid.\", 'wordfence'));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t$stored = array('hash' => $coreHashesHash, 'hashes' => $coreHashesData);\n\t\t\t\twfConfig::set_ser('coreHashes', $stored, true, wfConfig::DONT_AUTOLOAD);\n\t\t\t}\n\t\t\t\n\t\t\t$this->coreHashesData = $stored['hashes'];\n\t\t\twfIssues::statusEnd($coreHashesStatus, wfIssues::STATUS_SUCCESS);\n\t\t}\n\n\t\t$this->haveIssues = array(\n\t\t\t'core' => wfIssues::STATUS_SECURE,\n\t\t\t'coreUnknown' => wfIssues::STATUS_SECURE,\n\t\t\t'themes' => wfIssues::STATUS_SECURE,\n\t\t\t'plugins' => wfIssues::STATUS_SECURE,\n\t\t\t'malware' => wfIssues::STATUS_SECURE,\n\t\t\t);\n\t\tif($this->coreEnabled){ $this->status['core'] = wfIssues::statusStart(__(\"Comparing core WordPress files against originals in repository\", 'wordfence')); $this->engine->scanController()->startStage(wfScanner::STAGE_FILE_CHANGES); } else { wfIssues::statusDisabled(__(\"Skipping core scan\", 'wordfence')); }\n\t\tif($this->themesEnabled){ $this->status['themes'] = wfIssues::statusStart(__(\"Comparing open source themes against WordPress.org originals\", 'wordfence')); $this->engine->scanController()->startStage(wfScanner::STAGE_FILE_CHANGES); } else { wfIssues::statusDisabled(__(\"Skipping theme scan\", 'wordfence')); }\n\t\tif($this->pluginsEnabled){ $this->status['plugins'] = wfIssues::statusStart(__(\"Comparing plugins against WordPress.org originals\", 'wordfence')); $this->engine->scanController()->startStage(wfScanner::STAGE_FILE_CHANGES); } else { wfIssues::statusDisabled(__(\"Skipping plugin scan\", 'wordfence')); }\n\t\tif($this->malwareEnabled){ $this->status['malware'] = wfIssues::statusStart(__(\"Scanning for known malware files\", 'wordfence')); $this->engine->scanController()->startStage(wfScanner::STAGE_MALWARE_SCAN); } else { wfIssues::statusDisabled(__(\"Skipping malware scan\", 'wordfence')); }\n\t\tif($this->coreUnknownEnabled){ $this->status['coreUnknown'] = wfIssues::statusStart(__(\"Scanning for unknown files in wp-admin and wp-includes\", 'wordfence')); $this->engine->scanController()->startStage(wfScanner::STAGE_FILE_CHANGES); } else { wfIssues::statusDisabled(__(\"Skipping unknown core file scan\", 'wordfence')); }\n\t\t\n\t\tif ($options['scansEnabled_fileContents']) { $this->engine->scanController()->startStage(wfScanner::STAGE_MALWARE_SCAN); }\n\t\tif ($options['scansEnabled_fileContentsGSB']) { $this->engine->scanController()->startStage(wfScanner::STAGE_CONTENT_SAFETY); }\n\t\t\n\t\tif ($this->coreUnknownEnabled && !$this->alertedOnUnknownWordPressVersion && empty($this->knownFiles['core'])) {\n\t\t\trequire(ABSPATH . 'wp-includes\/version.php'); \/* @var string $wp_version *\/\n\t\t\t$this->alertedOnUnknownWordPressVersion = true;\n\t\t\t$added = $this->engine->addIssue(\n\t\t\t\t'coreUnknown',\n\t\t\t\twfIssues::SEVERITY_MEDIUM,\n\t\t\t\t'coreUnknown' . $wp_version,\n\t\t\t\t'coreUnknown' . $wp_version,\n\t\t\t\tsprintf(\/* translators: WordPress version. *\/ __('Unknown WordPress core version: %s', 'wordfence'), $wp_version),\n\t\t\t\t__(\"The core files scan will not be run because this version of WordPress is not currently indexed by Wordfence. This may be due to using a prerelease version or because the servers are still indexing a new release. If you are using an official WordPress release, this issue will automatically dismiss once the version is indexed and another scan is run.\", 'wordfence'),\n\t\t\t\tarray()\n\t\t\t);\n\t\t\t\n\t\t\tif ($added == wfIssues::ISSUE_ADDED || $added == wfIssues::ISSUE_UPDATED) { $this->haveIssues['coreUnknown'] = wfIssues::STATUS_PROBLEM; }\n\t\t\telse if ($this->haveIssues['coreUnknown'] != wfIssues::STATUS_PROBLEM && ($added == wfIssues::ISSUE_IGNOREP || $added == wfIssues::ISSUE_IGNOREC)) { $this->haveIssues['coreUnknown'] = wfIssues::STATUS_IGNORED; }\n\t\t}\n\t\t$this->initializeProperties();\n\t}\n\tprivate function initializeProperties() {\n\t\t$this->scanFileLogger = $this->getScanFileLogger();\n\t\t$this->knownFileExclude = wordfenceScanner::getExcludeFilePattern(wordfenceScanner::EXCLUSION_PATTERNS_KNOWN_FILES);\n\t}\n\tpublic function __sleep(){\n\t\treturn array('totalFiles', 'totalDirs', 'totalData', 'stoppedOnFile', 'coreEnabled', 'pluginsEnabled', 'themesEnabled', 'malwareEnabled', 'coreUnknownEnabled', 'knownFiles', 'haveIssues', 'status', 'possibleMalware', 'scannedFiles', 'totalForks', 'alertedOnUnknownWordPressVersion', 'foldersProcessed', 'suspectedFiles', 'indexed', 'indexSize', 'currentIndex', 'coalescingIssues', 'pathMap');\n\t}\n\tpublic function __wakeup(){\n\t\t$this->db = new wfDB();\n\t\t$this->startTime = microtime(true);\n\t\t$this->totalForks++;\n\t\t\n\t\t$stored = wfConfig::get_ser('malwarePrefixes', array(), false);\n\t\tif (!isset($stored['prefixes'])) {\n\t\t\t$stored['prefixes'] = '';\n\t\t}\n\t\t$this->malwareData = $stored['prefixes'];\n\t\t\n\t\t$stored = wfConfig::get_ser('coreHashes', array(), false);\n\t\tif (!isset($stored['hashes'])) {\n\t\t\t$stored['hashes'] = '';\n\t\t}\n\t\t$this->coreHashesData = $stored['hashes'];\n\t\t$this->initializeProperties();\n\t}\n\tpublic function getSuspectedFiles() {\n\t\treturn array_keys($this->suspectedFiles);\n\t}\n\tpublic function run($engine) {\n\t\tif($this->totalForks > 1000){\n\t\t\tthrow new Exception(sprintf(\/* translators: File path. *\/ __(\"Wordfence file scanner detected a possible infinite loop. Exiting on file: %s\", 'wordfence'), $this->stoppedOnFile));\n\t\t}\n\t\t$this->engine = $engine;\n\t\tif (!$this->indexed) {\n\t\t\t$start = microtime(true);\n\t\t\t$indexedFiles = array();\n\t\t\tforeach ($this->scannedFiles as $file) {\n\t\t\t\t$this->_dirIndex($file, $indexedFiles);\n\t\t\t}\n\t\t\t$this->_serviceIndexQueue($indexedFiles, true);\n\t\t\t$this->indexed = true;\n\t\t\tunset($this->foldersEntered); $this->foldersEntered = array();\n\t\t\tunset($this->foldersProcessed); $this->foldersProcessed = array();\n\t\t\t$end = microtime(true);\n\t\t\twordfence::status(4, 'info', sprintf(\/* translators: Time in seconds. *\/ __(\"Index time: %s\", 'wordfence'), ($end - $start)));\n\t\t}\n\t\t\n\t\t$this->_checkForTimeout();\n\t\t\n\t\twordfence::status(4, 'info', __(\"Beginning file hashing\", 'wordfence'));\n\t\twhile ($file = $this->_nextFile()) {\n\t\t\t$this->processFile($file);\n\t\t\twfUtils::afterProcessingFile();\n\t\t\t$this->_checkForTimeout($file);\n\t\t}\n\n\t\t$this->processFileRecords(); \/\/ Ensure all file records have actually been inserted before processing pending issues\n\t\t\n\t\twordfence::status(4, 'info', __(\"Processing pending issues\", 'wordfence'));\n\t\t$this->_processPendingIssues();\n\t\t\n\t\twordfence::status(2, 'info', sprintf(\/* translators: 1. Number of files. 2. Data in bytes. *\/ __('Analyzed %1$d files containing %2$s of data.', 'wordfence'), $this->totalFiles, wfUtils::formatBytes($this->totalData)));\n\t\tif($this->coreEnabled){ wfIssues::statusEnd($this->status['core'], $this->haveIssues['core']); $this->engine->scanController()->completeStage(wfScanner::STAGE_FILE_CHANGES, $this->haveIssues['core']); }\n\t\tif($this->themesEnabled){ wfIssues::statusEnd($this->status['themes'], $this->haveIssues['themes']); $this->engine->scanController()->completeStage(wfScanner::STAGE_FILE_CHANGES, $this->haveIssues['themes']); }\n\t\tif($this->pluginsEnabled){ wfIssues::statusEnd($this->status['plugins'], $this->haveIssues['plugins']); $this->engine->scanController()->completeStage(wfScanner::STAGE_FILE_CHANGES, $this->haveIssues['plugins']); }\n\t\tif($this->coreUnknownEnabled){ wfIssues::statusEnd($this->status['coreUnknown'], $this->haveIssues['coreUnknown']); $this->engine->scanController()->completeStage(wfScanner::STAGE_FILE_CHANGES, $this->haveIssues['coreUnknown']); }\n\t\tif(sizeof($this->possibleMalware) > 0){\n\t\t\t$malwareResp = $engine->api->binCall('check_possible_malware', json_encode($this->possibleMalware));\n\t\t\tif($malwareResp['code'] != 200){\n\t\t\t\twfIssues::statusEndErr();\n\t\t\t\tthrow new Exception(__(\"Invalid response from Wordfence API during check_possible_malware\", 'wordfence'));\n\t\t\t}\n\t\t\t$malwareList = json_decode($malwareResp['data'], true);\n\t\t\tif(is_array($malwareList) && sizeof($malwareList) > 0){\n\t\t\t\tfor($i = 0; $i < sizeof($malwareList); $i++){ \n\t\t\t\t\t$file = $malwareList[$i][0];\n\t\t\t\t\t$md5 = $malwareList[$i][1];\n\t\t\t\t\t$name = $malwareList[$i][2];\n\t\t\t\t\t$added = $this->engine->addIssue(\n\t\t\t\t\t\t'file',\n\t\t\t\t\t\twfIssues::SEVERITY_CRITICAL,\n\t\t\t\t\t\t$file,\n\t\t\t\t\t\t$md5,\n\t\t\t\t\t\tsprintf(\/* translators: File path. *\/ __('This file is suspected malware: %s', 'wordfence'), $file),\n\t\t\t\t\t\tsprintf(\/* translators: Malware name\/title. *\/ __(\"This file's signature matches a known malware file. The title of the malware is '%s'. Immediately inspect this file using the 'View' option below and consider deleting it from your server.\", 'wordfence'), $name),\n\t\t\t\t\t\tarray(\n\t\t\t\t\t\t\t'file' => $file,\n\t\t\t\t\t\t\t'realFile' => array_key_exists($file, $this->pathMap) ? $this->pathMap[$file] : null,\n\t\t\t\t\t\t\t'cType' => 'unknown',\n\t\t\t\t\t\t\t'canDiff' => false,\n\t\t\t\t\t\t\t'canFix' => false,\n\t\t\t\t\t\t\t'canDelete' => true\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t\n\t\t\t\t\tif ($added == wfIssues::ISSUE_ADDED || $added == wfIssues::ISSUE_UPDATED) { $this->haveIssues['malware'] = wfIssues::STATUS_PROBLEM; }\n\t\t\t\t\telse if ($this->haveIssues['malware'] != wfIssues::STATUS_PROBLEM && ($added == wfIssues::ISSUE_IGNOREP || $added == wfIssues::ISSUE_IGNOREC)) { $this->haveIssues['malware'] = wfIssues::STATUS_IGNORED; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif($this->malwareEnabled){ wfIssues::statusEnd($this->status['malware'], $this->haveIssues['malware']); $this->engine->scanController()->completeStage(wfScanner::STAGE_MALWARE_SCAN, $this->haveIssues['malware']); }\n\t\tunset($this->knownFiles); $this->knownFiles = false;\n\t}\n\tprivate function _dirIndex($file, &$indexedFiles) {\n\t\t$realPath = $file->getRealPath();\n\t\t\/\/Applies to files and dirs\n\t\tif (!is_readable($realPath))\n\t\t\treturn;\n\t\tif (!$this->_shouldProcessFile($file))\n\t\t\treturn;\n\t\tif (is_dir($realPath)) {\n\t\t\tif (isset($this->foldersEntered[$realPath]))\n\t\t\t\treturn;\n\t\t\t\n\t\t\t$this->foldersEntered[$file->getRealPath()] = 1;\n\t\t\t\n\t\t\t$this->totalDirs++;\n\t\t\ttry {\n\t\t\t\tforeach (wfFileUtils::getContents($realPath) as $child) {\n\t\t\t\t\tif (wfFileUtils::isCurrentOrParentDirectory($child)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\t$child = $file->createChild($child);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (wfInvalidPathException $e) {\n\t\t\t\t\t\twordfence::status(4, 'info', sprintf(__(\"Ignoring invalid scan file child: %s\", 'wordfence'), $e->getPath()));\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (is_file($child->getRealPath())) {\n\t\t\t\t\t\t$relativeFile = $child->getWordpressPath();\n\t\t\t\t\t\tif ($this->stoppedOnFile && $child->getRealPath() != $this->stoppedOnFile) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (preg_match('\/\\.suspected$\/i', $relativeFile)) { \/\/Already iterating over all files in the search areas so generate this list here\n\t\t\t\t\t\t\twordfence::status(4, 'info', sprintf(\/* translators: File path. *\/ __(\"Found .suspected file: %s\", 'wordfence'), $relativeFile));\n\t\t\t\t\t\t\t$this->suspectedFiles[$relativeFile] = 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$this->_checkForTimeout($child, $indexedFiles);\n\t\t\t\t\t\tif ($this->_shouldHashFile($child)) {\n\t\t\t\t\t\t\t$indexedFiles[] = $child;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\twordfence::status(4, 'info', sprintf(\/* translators: File path. *\/ __(\"Skipping unneeded hash: %s\", 'wordfence'), (string) $child));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$this->_serviceIndexQueue($indexedFiles);\n\t\t\t\t\t}\n\t\t\t\t\telseif (is_dir($child->getRealPath())) {\n\t\t\t\t\t\t$this->_dirIndex($child, $indexedFiles);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (wfInaccessibleDirectoryException $e) {\n\t\t\t\twordfence::status(4, 'info', sprintf(\/* translators: File path. *\/ __(\"Skipping inaccessible directory: %s\", 'wordfence'), (string) $file));\n\t\t\t}\n\t\t\t\n\t\t\t$this->foldersProcessed[$realPath] = 1;\n\t\t\tunset($this->foldersEntered[$realPath]);\n\t\t}\n\t\telse {\n\t\t\tif (is_file($realPath)) {\n\t\t\t\t$relativeFile = $file->getWordpressPath();\n\t\t\t\tif ($this->stoppedOnFile && $realPath != $this->stoppedOnFile) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (preg_match('\/\\.suspected$\/i', $relativeFile)) { \/\/Already iterating over all files in the search areas so generate this list here\n\t\t\t\t\twordfence::status(4, 'info', sprintf(\/* translators: File path. *\/ __(\"Found .suspected file: %s\", 'wordfence'), $relativeFile));\n\t\t\t\t\t$this->suspectedFiles[$relativeFile] = 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t$this->_checkForTimeout($file, $indexedFiles);\n\t\t\t\tif ($this->_shouldHashFile($file)) {\n\t\t\t\t\t$indexedFiles[] = $file;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twordfence::status(4, 'info', sprintf(\/* translators: File path. *\/ __(\"Skipping unneeded hash: %s\", 'wordfence'), (string) $file));\n\t\t\t\t}\n\t\t\t\t$this->_serviceIndexQueue($indexedFiles);\n\t\t\t}\n\t\t}\n\t}\n\tprivate function _serviceIndexQueue(&$indexedFiles, $final = false) {\n\t\t$files = array();\n\t\tif (count($indexedFiles) > 500) {\n\t\t\t$files = array_splice($indexedFiles, 0, 500);\n\t\t}\n\t\telse if ($final) {\n\t\t\t$files = $indexedFiles;\n\t\t\t$indexedFiles = array();\n\t\t}\n\n\t\t$fileCount = count($files);\n\t\tif ($fileCount > 0) {\n\t\t\t$payload = array();\n\t\t\tforeach ($files as $file) {\n\t\t\t\t$payload[] = (string) $file;\n\t\t\t\t$payload[] = $file->getWordpressPath();\n\t\t\t}\n\t\t\tglobal $wpdb;\n\t\t\t$table_wfKnownFileList = wfDB::networkTable('wfKnownFileList');\n\t\t\t$query = substr(\"INSERT INTO {$table_wfKnownFileList} (path, wordpress_path) VALUES \" . str_repeat(\"('%s', '%s'), \", count($files)), 0, -2);\n\t\t\t$wpdb->query($wpdb->prepare($query, $payload));\n\t\t\t$this->indexSize += $fileCount;\n\t\t\twordfence::status(2, 'info', sprintf(\/* translators: Number of files. *\/ __(\"%d files indexed\", 'wordfence'), $this->indexSize));\n\t\t}\n\t}\n\tprivate function _loadFileBatch() {\n\t\tglobal $wpdb;\n\t\t$table_wfKnownFileList = wfDB::networkTable('wfKnownFileList');\n\t\t$rows = $wpdb->get_results($wpdb->prepare(\"SELECT id, path, wordpress_path FROM {$table_wfKnownFileList} WHERE id > %d ORDER BY id ASC LIMIT 500\", $this->currentIndex));\n\t\tend($rows);\n\t\twhile (($row = prev($rows)) !== false) {\n\t\t\t$this->currentFile = new wfScanFileListItem($row->id, $row->path, $row->wordpress_path, $this->currentFile);\n\t\t}\n\t}\n\tprivate function _nextFile() {\n\t\tif ($this->currentFile !== null)\n\t\t\t$this->currentFile = $this->currentFile->getNext();\n\t\tif ($this->currentFile === null) {\n\t\t\t$this->_loadFileBatch();\n\t\t}\n\t\tif ($this->currentFile !== null)\n\t\t\t$this->currentIndex = $this->currentFile->getId();\n\t\treturn $this->currentFile;\n\t}\n\tprivate function _checkForTimeout($file = null, $indexQueue = false) {\n\t\t$realPath = $file ? $file->getRealPath() : null;\n\t\tif (($this->stoppedOnFile !== $realPath) && $this->engine->shouldFork()) { \/\/max X seconds but don't allow fork if we're looking for the file we stopped on. Search mode is VERY fast.\n\t\t\t$this->processFileRecords(false);\n\t\t\tif ($indexQueue !== false) {\n\t\t\t\t$this->_serviceIndexQueue($indexQueue, true);\n\t\t\t\t$this->stoppedOnFile = $realPath;\n\t\t\t\twordfence::status(4, 'info', sprintf(\/* translators: File path. *\/ __(\"Forking during indexing: %s\", 'wordfence'), (string) $file));\n\t\t\t}\n\t\t\telse {\n\t\t\t\twordfence::status(4, 'info', sprintf(\/* translators: PHP max execution time. *\/ __(\"Calling fork() from wordfenceHash with maxExecTime: %s\", 'wordfence'), $this->engine->maxExecTime));\n\t\t\t}\n\t\t\t$this->engine->fork();\n\t\t\t\/\/exits\n\t\t}\n\t\t\n\t\tif ($this->stoppedOnFile && $realPath != $this->stoppedOnFile && $indexQueue !== false) {\n\t\t\treturn;\n\t\t}\n\t\telse if ($this->stoppedOnFile && $realPath == $this->stoppedOnFile) {\n\t\t\t$this->stoppedOnFile = false; \/\/Continue indexing\n\t\t}\n\t}\n\tprivate function _shouldProcessFile($file) {\n\t\t$excludePatterns = wordfenceScanner::getExcludeFilePattern(wordfenceScanner::EXCLUSION_PATTERNS_USER);\n\t\tif ($excludePatterns) {\n\t\t\tforeach ($excludePatterns as $pattern) {\n\t\t\t\tif (preg_match($pattern, $file->getWordpressPath())) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t$realPath = $file->getRealPath();\n\t\tif ($realPath === '\/') {\n\t\t\treturn false;\n\t\t}\n\t\tif (isset($this->foldersProcessed[$realPath])) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\tprivate function getScanFileLogger() {\n\t\tif (function_exists('memory_get_usage')) {\n\t\t\treturn function($realPath) {\n\t\t\t\twordfence::status(4, 'info', sprintf(\/* translators: 1. File path. 2. Memory in bytes. *\/ __('Scanning: %1$s (Mem:%2$s)', 'wordfence'), $realPath, sprintf('%.1fM', memory_get_usage(true) \/ (1024 * 1024))));\n\t\t\t};\n\t\t}\n\t\telse {\n\t\t\treturn function($realPath) {\n\t\t\t\twordfence::status(4, 'info', sprintf(\/* translators: File path. *\/ __(\"Scanning: %s\", 'wordfence'), $realPath));\n\t\t\t};\n\t\t}\n\t}\n\tprivate function isKnownFileScanAllowed($realPath) {\n\t\tif ($this->knownFileExclude) {\n\t\t\tforeach ($this->knownFileExclude as $pattern) {\n\t\t\t\tif (preg_match($pattern, $realPath)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate function getKnownFileType($properties) {\n\t\tif ($this->isKnownFileScanAllowed($properties->realPath)) {\n\t\t\tforeach (self::$KNOWN_FILE_TYPES as $type) {\n\t\t\t\tif (isset($this->knownFiles[$type][$properties->wordpressPath]))\n\t\t\t\t\treturn $type;\n\t\t\t}\n\t\t\tif ($this->coreUnknownEnabled && !$this->alertedOnUnknownWordPressVersion)\n\t\t\t\treturn self::KNOWN_FILE_OTHER;\n\t\t}\n\t\treturn null;\n\t}\n\tprivate function checkKnownCoreFile($properties) {\n\t\tif (strtoupper($this->knownFiles['core'][$properties->wordpressPath]) == $properties->shac) {\n\t\t\t$properties->freeContent();\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tif ($this->coreEnabled) {\n\t\t\t\tif ($properties->loadContent() && (!preg_match('\/<\\?' . 'php[\\r\\n\\s\\t]*\\\/\\\/[\\r\\n\\s\\t]*Silence is golden\\.[\\r\\n\\s\\t]*(?:\\?>)?[\\r\\n\\s\\t]*$\/s', $properties->content))) {\n\t\t\t\t\t$this->engine->addPendingIssue(\n\t\t\t\t\t\t'knownfile',\n\t\t\t\t\t\twfIssues::SEVERITY_HIGH,\n\t\t\t\t\t\t'coreModified' . $properties->wordpressPath,\n\t\t\t\t\t\t'coreModified' . $properties->wordpressPath . $properties->md5,\n\t\t\t\t\t\tsprintf(\/* translators: File path. *\/ __('WordPress core file modified: %s', 'wordfence'), $properties->wordpressPath),\n\t\t\t\t\t\t__(\"This WordPress core file has been modified and differs from the original file distributed with this version of WordPress.\", 'wordfence'),\n\t\t\t\t\t\tarray(\n\t\t\t\t\t\t\t'file' => $properties->wordpressPath,\n\t\t\t\t\t\t\t'realFile' => $properties->realPath,\n\t\t\t\t\t\t\t'cType' => 'core',\n\t\t\t\t\t\t\t'canDiff' => true,\n\t\t\t\t\t\t\t'canFix' => true,\n\t\t\t\t\t\t\t'canDelete' => false,\n\t\t\t\t\t\t\t'haveIssues' => 'core'\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\tprivate function checkKnownPluginFile($properties) {\n\t\tif (in_array($properties->shac, $this->knownFiles[self::KNOWN_FILE_PLUGIN][$properties->wordpressPath])) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tif ($this->pluginsEnabled) {\n\t\t\t\t$options = $this->engine->scanController()->scanOptions();\n\t\t\t\t$shouldGenerateIssue = true;\n\t\t\t\tif (!$options['scansEnabled_highSense'] && preg_match('~\/readme\\.(?:txt|md)$~i', $properties->wordpressPath)) { \/\/Don't generate issues for changed readme files unless high sensitivity is on\n\t\t\t\t\t$shouldGenerateIssue = false;\n\t\t\t\t}\n\n\t\t\t\tif ($shouldGenerateIssue) {\n\t\t\t\t\t$itemName = $this->knownFiles['plugins'][$properties->wordpressPath][0];\n\t\t\t\t\t$itemVersion = $this->knownFiles['plugins'][$properties->wordpressPath][1];\n\t\t\t\t\t$cKey = $this->knownFiles['plugins'][$properties->wordpressPath][2];\n\t\t\t\t\t$this->engine->addPendingIssue(\n\t\t\t\t\t\t'knownfile',\n\t\t\t\t\t\twfIssues::SEVERITY_MEDIUM,\n\t\t\t\t\t\t'modifiedplugin' . $properties->wordpressPath,\n\t\t\t\t\t\t'modifiedplugin' . $properties->wordpressPath . $properties->md5,\n\t\t\t\t\t\tsprintf(\/* translators: File path. *\/ __('Modified plugin file: %s', 'wordfence'), $properties->wordpressPath),\n\t\t\t\t\t\tsprintf(\n\t\t\t\t\t\t\t\/* translators: 1. Plugin name. 2. Plugin version. 3. Support URL. *\/\n\t\t\t\t\t\t\t__('This file belongs to plugin \"%1$s\" version \"%2$s\" and has been modified from the file that is distributed by WordPress.org for this version. Please use the link to see how the file has changed. If you have modified this file yourself, you can safely ignore this warning. If you see a lot of changed files in a plugin that have been made by the author, then try uninstalling and reinstalling the plugin to force an upgrade. Doing this is a workaround for plugin authors who don\\'t manage their code correctly. <a href=\"%3$s\" target=\"_blank\" rel=\"noopener noreferrer\">Learn More<span class=\"screen-reader-text\"> (' . esc_html__('opens in new tab', 'wordfence') . ')<\/span><\/a>', 'wordfence'),\n\t\t\t\t\t\t\t$itemName,\n\t\t\t\t\t\t\t$itemVersion,\n\t\t\t\t\t\t\twfSupportController::esc_supportURL(wfSupportController::ITEM_SCAN_RESULT_MODIFIED_PLUGIN)\n\t\t\t\t\t\t),\n\t\t\t\t\t\tarray(\n\t\t\t\t\t\t\t'file' => $properties->wordpressPath,\n\t\t\t\t\t\t\t'realFile' => $properties->realPath,\n\t\t\t\t\t\t\t'cType' => 'plugin',\n\t\t\t\t\t\t\t'canDiff' => true,\n\t\t\t\t\t\t\t'canFix' => true,\n\t\t\t\t\t\t\t'canDelete' => false,\n\t\t\t\t\t\t\t'cName' => $itemName,\n\t\t\t\t\t\t\t'cVersion' => $itemVersion,\n\t\t\t\t\t\t\t'cKey' => $cKey,\n\t\t\t\t\t\t\t'haveIssues' => 'plugins'\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\tprivate function checkKnownThemeFile($properties) {\n\t\tif (in_array($properties->shac, $this->knownFiles[self::KNOWN_FILE_THEME][$properties->wordpressPath])) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tif ($this->themesEnabled) {\n\t\t\t\t$options = $this->engine->scanController()->scanOptions();\n\t\t\t\t$shouldGenerateIssue = true;\n\t\t\t\tif (!$options['scansEnabled_highSense'] && preg_match('~\/readme\\.(?:txt|md)$~i', $properties->wordpressPath)) { \/\/Don't generate issues for changed readme files unless high sensitivity is on\n\t\t\t\t\t$shouldGenerateIssue = false;\n\t\t\t\t}\n\n\t\t\t\tif ($shouldGenerateIssue) {\n\t\t\t\t\t$itemName = $this->knownFiles['themes'][$properties->wordpressPath][0];\n\t\t\t\t\t$itemVersion = $this->knownFiles['themes'][$properties->wordpressPath][1];\n\t\t\t\t\t$cKey = $this->knownFiles['themes'][$properties->wordpressPath][2];\n\t\t\t\t\t$this->engine->addPendingIssue(\n\t\t\t\t\t\t'knownfile',\n\t\t\t\t\t\twfIssues::SEVERITY_MEDIUM,\n\t\t\t\t\t\t'modifiedtheme' . $properties->wordpressPath,\n\t\t\t\t\t\t'modifiedtheme' . $properties->wordpressPath . $properties->md5,\n\t\t\t\t\t\tsprintf(\/* translators: File path. *\/ __('Modified theme file: %s', 'wordfence'), $properties->wordpressPath),\n\t\t\t\t\t\tsprintf(\n\t\t\t\t\t\t\t\/* translators: 1. Plugin name. 2. Plugin version. 3. Support URL. *\/\n\t\t\t\t\t\t\t__('This file belongs to theme \"%1$s\" version \"%2$s\" and has been modified from the original distribution. It is common for site owners to modify their theme files, so if you have modified this file yourself you can safely ignore this warning. <a href=\"%3$s\" target=\"_blank\" rel=\"noopener noreferrer\">Learn More<span class=\"screen-reader-text\"> (' . esc_html__('opens in new tab', 'wordfence') . ')<\/span><\/a>', 'wordfence'),\n\t\t\t\t\t\t\t$itemName,\n\t\t\t\t\t\t\t$itemVersion,\n\t\t\t\t\t\t\twfSupportController::esc_supportURL(wfSupportController::ITEM_SCAN_RESULT_MODIFIED_THEME)\n\t\t\t\t\t\t),\n\t\t\t\t\t\tarray(\n\t\t\t\t\t\t\t'file' => $properties->wordpressPath,\n\t\t\t\t\t\t\t'realFile' => $properties->realPath,\n\t\t\t\t\t\t\t'cType' => 'theme',\n\t\t\t\t\t\t\t'canDiff' => true,\n\t\t\t\t\t\t\t'canFix' => true,\n\t\t\t\t\t\t\t'canDelete' => false,\n\t\t\t\t\t\t\t'cName' => $itemName,\n\t\t\t\t\t\t\t'cVersion' => $itemVersion,\n\t\t\t\t\t\t\t'cKey' => $cKey,\n\t\t\t\t\t\t\t'haveIssues' => 'themes'\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\tprivate function checkKnownFileOther($properties) {\n\t\t$restrictedWordPressFolders = array(ABSPATH . 'wp-admin\/', ABSPATH . WPINC . '\/');\n\t\t$added = false;\n\t\tforeach ($restrictedWordPressFolders as $path) {\n\t\t\tif (strpos($properties->realPath, $path) === 0) {\n\t\t\t\tif ($this->isPreviousCoreFile($properties->shac)) {\n\t\t\t\t\t$added = $this->engine->addIssue(\n\t\t\t\t\t\t'knownfile',\n\t\t\t\t\t\twfIssues::SEVERITY_LOW,\n\t\t\t\t\t\t'coreUnknown' . $properties->wordpressPath,\n\t\t\t\t\t\t'coreUnknown' . $properties->wordpressPath . $properties->md5,\n\t\t\t\t\t\tsprintf(\/* translators: File path. *\/ __('Old WordPress core file not removed during update: %s', 'wordfence'), $properties->wordpressPath),\n\t\t\t\t\t\t__('This file is in a WordPress core location but is from an older version of WordPress and not used with your current version. Hosting or permissions issues can cause these files to get left behind when WordPress is updated and they should be removed if possible.', 'wordfence'),\n\t\t\t\t\t\tarray(\n\t\t\t\t\t\t\t'file' => $properties->wordpressPath,\n\t\t\t\t\t\t\t'realFile' => $properties->realPath,\n\t\t\t\t\t\t\t'cType' => 'core',\n\t\t\t\t\t\t\t'canDiff' => false,\n\t\t\t\t\t\t\t'canFix' => false,\n\t\t\t\t\t\t\t'canDelete' => true,\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse if (preg_match('#\/php\\.ini$#', $properties->wordpressPath)) {\n\t\t\t\t\t$this->engine->addPendingIssue(\n\t\t\t\t\t\t'knownfile',\n\t\t\t\t\t\twfIssues::SEVERITY_HIGH,\n\t\t\t\t\t\t'coreUnknown' . $properties->wordpressPath,\n\t\t\t\t\t\t'coreUnknown' . $properties->wordpressPath . $properties->md5,\n\t\t\t\t\t\tsprintf(\/* translators: File path. *\/ __('Unknown file in WordPress core: %s', 'wordfence'), $properties->wordpressPath),\n\t\t\t\t\t\t__('This file is in a WordPress core location but is not distributed with this version of WordPress. This scan often includes files left over from a previous WordPress version, but it may also find files added by another plugin, files added by your host, or malicious files added by an attacker.', 'wordfence'),\n\t\t\t\t\t\tarray(\n\t\t\t\t\t\t\t'file' => $properties->wordpressPath,\n\t\t\t\t\t\t\t'realFile' => $properties->realPath,\n\t\t\t\t\t\t\t'cType' => 'core',\n\t\t\t\t\t\t\t'canDiff' => false,\n\t\t\t\t\t\t\t'canFix' => false,\n\t\t\t\t\t\t\t'canDelete' => true,\n\t\t\t\t\t\t\t'coalesce' => 'php.ini',\n\t\t\t\t\t\t\t'learnMore' => wfSupportController::supportURL(wfSupportController::ITEM_SCAN_RESULT_UNKNOWN_FILE_CORE),\n\t\t\t\t\t\t\t'haveIssues' => 'coreUnknown',\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$added = $this->engine->addIssue(\n\t\t\t\t\t\t'knownfile',\n\t\t\t\t\t\twfIssues::SEVERITY_HIGH,\n\t\t\t\t\t\t'coreUnknown' . $properties->wordpressPath,\n\t\t\t\t\t\t'coreUnknown' . $properties->wordpressPath . $properties->md5,\n\t\t\t\t\t\tsprintf(\/* translators: File path. *\/ __('Unknown file in WordPress core: %s', 'wordfence'), $properties->wordpressPath),\n\t\t\t\t\t\tsprintf(\/* translators: Support URL. *\/ __('This file is in a WordPress core location but is not distributed with this version of WordPress. This scan often includes files left over from a previous WordPress version, but it may also find files added by another plugin, files added by your host, or malicious files added by an attacker. <a href=\"%s\" target=\"_blank\" rel=\"noopener noreferrer\">Learn More<span class=\"screen-reader-text\"> (' . esc_html__('opens in new tab', 'wordfence') . ')<\/span><\/a>', 'wordfence'), wfSupportController::esc_supportURL(wfSupportController::ITEM_SCAN_RESULT_UNKNOWN_FILE_CORE)),\n\t\t\t\t\t\tarray(\n\t\t\t\t\t\t\t'file' => $properties->wordpressPath,\n\t\t\t\t\t\t\t'realFile' => $properties->realPath,\n\t\t\t\t\t\t\t'cType' => 'core',\n\t\t\t\t\t\t\t'canDiff' => false,\n\t\t\t\t\t\t\t'canFix' => false,\n\t\t\t\t\t\t\t'canDelete' => true,\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ($added == wfIssues::ISSUE_ADDED || $added == wfIssues::ISSUE_UPDATED) { $this->haveIssues['coreUnknown'] = wfIssues::STATUS_PROBLEM; }\n\t\telse if ($this->haveIssues['coreUnknown'] != wfIssues::STATUS_PROBLEM && ($added == wfIssues::ISSUE_IGNOREP || $added == wfIssues::ISSUE_IGNOREC)) { $this->haveIssues['coreUnknown'] = wfIssues::STATUS_IGNORED; }\n\t\treturn false;\n\t}\n\tprivate function checkKnownFile($properties, $type) {\n\t\tswitch ($type) {\n\t\tcase self::KNOWN_FILE_CORE:\n\t\t\treturn $this->checkKnownCoreFile($properties);\n\t\tcase self::KNOWN_FILE_PLUGIN:\n\t\t\treturn $this->checkKnownPluginFile($properties);\n\t\tcase self::KNOWN_FILE_THEME:\n\t\t\treturn $this->checkKnownThemeFile($properties);\n\t\tcase self::KNOWN_FILE_OTHER:\n\t\t\treturn $this->checkKnownFileOther($properties);\n\t\t}\n\t}\n\tprivate function recordFile($properties) {\n\t\t$this->fileRecords[$properties->wordpressPathMd5] = $properties;\n\t\t$this->fileRecordCount++;\n\t\tif ($this->fileRecordCount >= self::MAX_QUEUED_RECORDS)\n\t\t\t$this->processFileRecords();\n\t}\n\tprivate function processFileRecords($check = true) {\n\t\tif ($this->fileRecordCount == 0)\n\t\t\treturn;\n\t\t$this->db->insert(\n\t\t\twfDB::networkTable('wfFileMods'),\n\t\t\t[\n\t\t\t\t'filename' => '%s',\n\t\t\t\t'real_path' => '%s',\n\t\t\t\t'filenameMD5' => 'UNHEX(%s)',\n\t\t\t\t'knownFile' => '%d',\n\t\t\t\t'newMD5' => 'UNHEX(%s)',\n\t\t\t\t'SHAC' => 'UNHEX(%s)',\n\t\t\t],\n\t\t\tarray_map(function($properties) {\n\t\t\t\treturn [\n\t\t\t\t\t$properties->wordpressPath,\n\t\t\t\t\t$properties->realPath,\n\t\t\t\t\t$properties->wordpressPathMd5,\n\t\t\t\t\t(int) $properties->known,\n\t\t\t\t\t$properties->md5,\n\t\t\t\t\t$properties->shac,\n\t\t\t\t];\n\t\t\t}, $this->fileRecords),\n\t\t\t[\n\t\t\t\t'newMD5',\n\t\t\t\t'SHAC',\n\t\t\t\t'knownFile'\n\t\t\t]\n\t\t);\n\t\t$this->fileRecords = [];\n\t\t$this->fileRecordCount = 0;\n\t}\n\tprivate function processFile($file) {\n\t\t$properties = $file->initializeProperties();\n\t\ttry {\n\t\t\t$properties->realPath = $file->getRealPath();\n\t\t\t$wordpressPath = $file->getWordpressPath();\n\t\t\tif (wfUtils::fileTooBig($properties->realPath, $fileSize, $properties->handle)) {\n\t\t\t\twordfence::status(4, 'info', sprintf(\/* translators: File path. *\/ __(\"Skipping file larger than max size: %s\", 'wordfence'), $properties->realPath));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcall_user_func($this->scanFileLogger, $properties->realPath);\n\n\t\t\t$knownFileType = $this->getKnownFileType($properties);\n\t\t\t$allowKnownFileScan = $knownFileType !== null;\n\n\t\t\t$hashed = self::hashFile($properties->realPath, $properties);\n\t\t\t$this->engine->scanController()->incrementSummaryItem(wfScanner::SUMMARY_SCANNED_FILES);\n\t\t\tif (!$hashed) {\n\t\t\t\t\/\/wordfence::status(2, 'error', \"Could not gen hash for file (probably because we don't have permission to access the file): $properties->realPath\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t$properties->known = $allowKnownFileScan && $this->checkKnownFile($properties, $knownFileType);\n\n\t\t\tif($this->malwareEnabled && $this->isMalwarePrefix($properties->md5)){\n\t\t\t\t$this->possibleMalware[] = array($properties->wordpressPath, $properties->md5);\n\t\t\t\t$this->pathMap[$properties->wordpressPath] = $properties->realPath;\n\t\t\t}\n\n\t\t\t$this->recordFile($properties);\n\n\t\t\t$this->totalFiles++;\n\t\t\t$this->totalData += $fileSize;\n\t\t\tif($this->totalFiles % 100 === 0){\n\t\t\t\twordfence::status(2, 'info', sprintf(\n\t\t\t\t\t\/* translators: 1. Number of files. 2. Data in bytes. *\/\n\t\t\t\t\t__('Analyzed %1$d files containing %2$s of data so far', 'wordfence'),\n\t\t\t\t\t$this->totalFiles,\n\t\t\t\t\twfUtils::formatBytes($this->totalData)\n\t\t\t\t));\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\t$properties->releaseHandle();\n\t\t}\n\t}\n\tprivate function flagSafeFiles($filenames) {\n\t\t$fileModsTable = wfDB::networkTable('wfFileMods');\n\t\t$allSafeFiles = [];\n\t\t$existingSafeFiles = $this->db->selectAll(\n\t\t\t$fileModsTable,\n\t\t\t[\n\t\t\t\t'filename'\n\t\t\t],\n\t\t\t[\n\t\t\t\t'filename' => $filenames,\n\t\t\t\t'isSafeFile' => '1'\n\t\t\t]\n\t\t);\n\t\tforeach ($existingSafeFiles as $row) {\n\t\t\t$allSafeFiles[$row[0]] = true;\n\t\t}\n\t\t$remainingFilenames = [];\n\t\tforeach ($filenames as $filename) {\n\t\t\tif (!array_key_exists($filename, $allSafeFiles))\n\t\t\t\t$remainingFilenames[] = $filename;\n\t\t}\n\t\t$filenames = $remainingFilenames;\n\t\tdo {\n\t\t\t$results = $this->db->select(\n\t\t\t\t$fileModsTable,\n\t\t\t\t[\n\t\t\t\t\t'HEX(filenameMD5)',\n\t\t\t\t\t'UPPER(HEX(SHAC))',\n\t\t\t\t\t'filename'\n\t\t\t\t],\n\t\t\t\t[\n\t\t\t\t\t'filename' => $filenames,\n\t\t\t\t\t'isSafeFile' => '?'\n\t\t\t\t]\n\t\t\t);\n\t\t\t$hashes = array_column($results, 1);\n\t\t\t$safeHashes = array_flip($this->engine->isSafeFile($hashes));\n\t\t\t$safeFiles = [];\n\t\t\t$unsafeFiles = [];\n\t\t\tforeach ($results as $row) {\n\t\t\t\t$filenameMD5Hex = $row[0];\n\t\t\t\tif (array_key_exists($row[1], $safeHashes)) {\n\t\t\t\t\t$safeFiles[] = $filenameMD5Hex;\n\t\t\t\t\t$allSafeFiles[$row[2]] = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$unsafeFiles[] = $filenameMD5Hex;\n\t\t\t\t}\n\t\t\t}\n\t\t\tforeach (['1' => $safeFiles, '0' => $unsafeFiles] as $safe => $files) {\n\t\t\t\tif (count($files) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\t$this->db->update(\n\t\t\t\t\t$fileModsTable,\n\t\t\t\t\t[\n\t\t\t\t\t\t'isSafeFile' => [ '%s', $safe ]\n\t\t\t\t\t],\n\t\t\t\t\t[\n\t\t\t\t\t\t'filenameMD5' => $files\n\t\t\t\t\t],\n\t\t\t\t\t[\n\t\t\t\t\t\t'filenameMD5' => 'UNHEX(%s)'\n\t\t\t\t\t]\n\t\t\t\t);\n\t\t\t}\n\t\t} while (!empty($results));\n\t\treturn $allSafeFiles;\n\t}\n\tprivate function _processPendingIssues() {\n\t\t$count = $this->engine->getPendingIssueCount();\n\t\t$offset = 0;\n\t\twhile ($offset < $count) {\n\t\t\t$issues = $this->engine->getPendingIssues($offset);\n\t\t\tif (count($issues) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t$safeFiles = $this->flagSafeFiles(array_map(function($i) { return $i['data']['file']; }, $issues));\n\t\t\t\n\t\t\t\/\/Migrate non-safe file issues to official issues and begin coalescing tagged issues\n\t\t\tforeach ($issues as &$i) {\n\t\t\t\tif (!array_key_exists($i['data']['file'], $safeFiles)) {\n\t\t\t\t\t$haveIssuesType = $i['data']['haveIssues'];\n\t\t\t\t\tif (isset($i['data']['coalesce'])) {\n\t\t\t\t\t\t$key = $i['data']['coalesce'];\n\t\t\t\t\t\tif (!isset($this->coalescingIssues[$key])) { $this->coalescingIssues[$key] = array('count' => 0, 'issue' => $i); }\n\t\t\t\t\t\t$this->coalescingIssues[$key]['count']++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t$added = $this->engine->addIssue(\n\t\t\t\t\t\t\t$i['type'],\n\t\t\t\t\t\t\t$i['severity'],\n\t\t\t\t\t\t\t$i['ignoreP'],\n\t\t\t\t\t\t\t$i['ignoreC'],\n\t\t\t\t\t\t\t$i['shortMsg'],\n\t\t\t\t\t\t\t$i['longMsg'],\n\t\t\t\t\t\t\t$i['data'],\n\t\t\t\t\t\t\ttrue \/\/Prevent ignoreP and ignoreC from being hashed again\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif ($added == wfIssues::ISSUE_ADDED || $added == wfIssues::ISSUE_UPDATED) { $this->haveIssues[$haveIssuesType] = wfIssues::STATUS_PROBLEM; }\n\t\t\t\t\t\telse if ($this->haveIssues[$haveIssuesType] != wfIssues::STATUS_PROBLEM && ($added == wfIssues::ISSUE_IGNOREP || $added == wfIssues::ISSUE_IGNOREC)) { $this->haveIssues[$haveIssuesType] = wfIssues::STATUS_IGNORED; }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t$offset += count($issues);\n\t\t\t$this->engine->checkForKill();\n\t\t}\n\t\t\n\t\t\/\/Insert the coalesced issues (currently just multiple php.ini in system directories)\n\t\tforeach ($this->coalescingIssues as $c) {\n\t\t\t$count = $c['count'];\n\t\t\t$i = $c['issue'];\n\t\t\t$haveIssuesType = $i['data']['haveIssues'];\n\t\t\t$added = $this->engine->addIssue(\n\t\t\t\t$i['type'],\n\t\t\t\t$i['severity'],\n\t\t\t\t$i['ignoreP'],\n\t\t\t\t$i['ignoreC'],\n\t\t\t\t$i['shortMsg'] . ($count > 1 ? ' ' . sprintf(\/* translators: Number of scan results. *\/ __('(+ %d more)', 'wordfence'), $count - 1) : ''),\n\t\t\t\t$i['longMsg'] . ($count > 1 ? ' ' . ($count > 2 ? sprintf(\/* translators: Number of files. *\/ __('%d more similar files were found.', 'wordfence'), $count - 1) : __('1 more similar file was found.', 'wordfence')) : '') . (isset($i['data']['learnMore']) ? ' ' . sprintf(__('<a href=\"%s\" target=\"_blank\" rel=\"noopener noreferrer\">Learn More<span class=\"screen-reader-text\"> (' . esc_html__('opens in new tab', 'wordfence') . ')<\/span><\/a>', 'wordfence'), esc_attr($i['data']['learnMore'])) : ''),\n\t\t\t\t$i['data'],\n\t\t\t\ttrue \/\/Prevent ignoreP and ignoreC from being hashed again\n\t\t\t);\n\t\t\tif ($added == wfIssues::ISSUE_ADDED || $added == wfIssues::ISSUE_UPDATED) { $this->haveIssues[$haveIssuesType] = wfIssues::STATUS_PROBLEM; }\n\t\t\telse if ($this->haveIssues[$haveIssuesType] != wfIssues::STATUS_PROBLEM && ($added == wfIssues::ISSUE_IGNOREP || $added == wfIssues::ISSUE_IGNOREC)) { $this->haveIssues[$haveIssuesType] = wfIssues::STATUS_IGNORED; }\n\t\t}\n\t}\n\tpublic static function hashFile($file, &$properties) {\n\t\tif (!$properties->resetHandle()) {\n\t\t\treturn false;\n\t\t}\n\t\t$md5Context = hash_init('md5');\n\t\t$sha256Context = hash_init('sha256');\n\t\twhile (!feof($properties->handle)) {\n\t\t\t$data = fread($properties->handle, 65536);\n\t\t\tif ($data === false) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\thash_update($md5Context, $data);\n\t\t\thash_update($sha256Context, str_replace(array(\"\\n\",\"\\r\",\"\\t\",\" \"),\"\", $data));\n\t\t}\n\t\t$properties->md5 = strtoupper(hash_final($md5Context, false));\n\t\t$properties->shac = strtoupper(hash_final($sha256Context, false));\n\t\treturn true;\n\t}\n\tprivate function _shouldHashFile($file) {\n\t\t$wordpressPath = $file->getWordpressPath();\n\n\t\t\/\/Core File, return true\n\t\tif ((isset($this->knownFiles['core']) && isset($this->knownFiles['core'][$wordpressPath])) ||\n\t\t\t(isset($this->knownFiles['plugins']) && isset($this->knownFiles['plugins'][$wordpressPath])) ||\n\t\t\t(isset($this->knownFiles['themes']) && isset($this->knownFiles['themes'][$wordpressPath]))) {\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\t\/\/Excluded file, return false\n\t\t$excludePatterns = wordfenceScanner::getExcludeFilePattern(wordfenceScanner::EXCLUSION_PATTERNS_USER | wordfenceScanner::EXCLUSION_PATTERNS_MALWARE); \n\t\tif ($excludePatterns) {\n\t\t\tforeach ($excludePatterns as $pattern) {\n\t\t\t\tif (preg_match($pattern, $wordpressPath)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\/\/Unknown file in a core location\n\t\tif ($this->coreUnknownEnabled && !$this->alertedOnUnknownWordPressVersion) {\n\t\t\t$restrictedWordPressFolders = array(ABSPATH . 'wp-admin\/', ABSPATH . WPINC . '\/');\n\t\t\tforeach ($restrictedWordPressFolders as $path) {\n\t\t\t\tif (strpos($file->getRealPath(), $path) === 0) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\/\/Determine treatment\n\t\t$fileExt = '';\n\t\tif (preg_match('\/\\.([a-zA-Z\\d\\-]{1,7})$\/', $wordpressPath, $matches)) {\n\t\t\t$fileExt = strtolower($matches[1]);\n\t\t}\n\t\t$isPHP = false;\n\t\tif (preg_match('\/\\.(?:php(?:\\d+)?|phtml)(\\.|$)\/i', $wordpressPath)) {\n\t\t\t$isPHP = true;\n\t\t}\n\t\t$isHTML = false;\n\t\tif (preg_match('\/\\.(?:html?)(\\.|$)\/i', $wordpressPath)) {\n\t\t\t$isHTML = true;\n\t\t}\n\t\t$isJS = false;\n\t\tif (preg_match('\/\\.(?:js|svg)(\\.|$)\/i', $wordpressPath)) {\n\t\t\t$isJS = true;\n\t\t}\n\t\t\n\t\t$options = $this->engine->scanController()->scanOptions();\n\t\t\n\t\t\/\/If scan images is disabled, only allow .js through\n\t\tif (!$isPHP && preg_match('\/^(?:jpg|jpeg|mp3|avi|m4v|mov|mp4|gif|png|tiff?|svg|sql|js|tbz2?|bz2?|xz|zip|tgz|gz|tar|log|err\\d+)$\/', $fileExt)) {\n\t\t\tif (!$options['scansEnabled_scanImages'] && !$isJS) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\/\/If high sensitivity is disabled, don't allow .sql\n\t\tif (strtolower($fileExt) == 'sql') {\n\t\t\tif (!$options['scansEnabled_highSense']) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\/\/Treating as binary, return true\n\t\t$treatAsBinary = ($isPHP || $isHTML || $options['scansEnabled_scanImages']);\n\t\tif ($treatAsBinary) {\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\t\/\/Will be malware scanned, return true\n\t\tif ($isJS) {\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\tprivate function isMalwarePrefix($hexMD5){\n\t\t$hasPrefix = $this->_binaryListContains($this->malwareData, wfUtils::hex2bin($hexMD5), 4);\n\t\treturn $hasPrefix !== false;\n\t}\n\tprivate function isPreviousCoreFile($hexContentsSHAC) {\n\t\t$hasPrefix = $this->_binaryListContains($this->coreHashesData, wfUtils::hex2bin($hexContentsSHAC), 32);\n\t\treturn $hasPrefix !== false;\n\t}\n\t\n\t\/**\n\t * @param $binaryList The binary list to search, sorted as a binary string.\n\t * @param $needle The binary needle to search for.\n\t * @param int $size The byte size of each item in the list.\n\t * @return bool|int false if not found, otherwise the index in the list\n\t *\/\n\tprivate function _binaryListContains($binaryList, $needle, $size \/* bytes *\/) {\n\t\t$p = substr($needle, 0, $size);\n\t\t\n\t\t$count = ceil(wfWAFUtils::strlen($binaryList) \/ $size);\n\t\t$low = 0;\n\t\t$high = $count - 1;\n\t\t\n\t\twhile ($low <= $high) {\n\t\t\t$mid = (int) (($high + $low) \/ 2);\n\t\t\t$val = wfWAFUtils::substr($binaryList, $mid * $size, $size);\n\t\t\t$cmp = strcmp($val, $p);\n\t\t\tif ($cmp < 0) {\n\t\t\t\t$low = $mid + 1;\n\t\t\t}\n\t\t\telse if ($cmp > 0) {\n\t\t\t\t$high = $mid - 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn $mid;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n}"},{"base":"plugins","rel":"wordfence\/lib\/menu_tools_whois.php","ext":"php","size":4722,"mtime":1757312769,"type":"text","content":"<?php\nif (!defined('WORDFENCE_VERSION')) { exit; }\n?>\n<script type=\"application\/javascript\">\n\t(function($) {\n\t\t$(function() {\n\t\t\tdocument.title = \"<?php esc_attr_e('Whois Lookup', 'wordfence'); ?>\" + \" \\u2039 \" + WFAD.basePageName;\n\t\t});\n\t})(jQuery);\n<\/script>\n\n<div class=\"wordfenceModeElem\" id=\"wordfenceMode_whois\"><\/div>\n\n<div id=\"wf-tools-whois\">\n\t<div class=\"wf-section-title\">\n\t\t<h2><?php esc_html_e('Whois Lookup', 'wordfence') ?><\/h2>\n\t\t<span><?php echo wp_kses(sprintf(\n\t\t\t\t\/* translators: URL to support page. *\/\n\t\t\t\t__('<a href=\"%s\" target=\"_blank\" rel=\"noopener noreferrer\" class=\"wf-help-link\">Learn more<span class=\"wf-hidden-xs\"> about Whois Lookup<\/span><span class=\"screen-reader-text\"> (opens in new tab)<\/span><\/a>', 'wordfence'), wfSupportController::esc_supportURL(wfSupportController::ITEM_TOOLS_WHOIS_LOOKUP)), array('a'=>array('href'=>array(), 'target'=>array(), 'rel'=>array(), 'class'=>array()), 'span'=>array('class'=>array()))); ?>\n\t\t\t<i class=\"wf-fa wf-fa-external-link\" aria-hidden=\"true\"><\/i><\/span>\n\t<\/div>\n\n\t<p><?php esc_html_e(\"The whois service gives you a way to look up who owns an IP address or domain name that is visiting your website or is engaging in malicious activity on your website.\", 'wordfence') ?><\/p>\n\n\t<div>\n\n\t\t<div class=\"wf-form wf-flex-row\">\n\t\t\t<div class=\"wf-flex-row-1\">\n\t\t\t\t<input type=\"text\" class=\"wf-form-control\" name=\"whois\" id=\"wfwhois\" value=\"\" maxlength=\"255\" onkeydown=\"if(event.keyCode == 13){ whois(jQuery('#wfwhois').val()) }\"\/>\n\t\t\t<\/div>\n\t\t\t<div class=\"wf-flex-row-0 wf-padding-add-left\">\n\t\t\t\t<input type=\"button\" name=\"whoisbutton\" id=\"whoisbutton\" class=\"wf-btn wf-btn-primary\" value=\"Look up IP or Domain\" onclick=\"whois(jQuery('#wfwhois').val());\">\n\t\t\t<\/div>\n\t\t<\/div>\n\t\t<?php if (isset($_GET['wfnetworkblock']) && $_GET['wfnetworkblock']) { ?>\n\t\t\t<h2><?php esc_html_e('How to block a network', 'wordfence') ?><\/h2>\n\t\t\t<p style=\"width: 600px;\">\n\t\t\t\t<?php echo wp_kses(sprintf(\n\t\t\t\t\/* translators: Hostname or IP address. *\/\n\t\t\t\t\t\t__(\"You've chosen to block the network that <span style=\\\"color: #F00;\\\">%s<\/span> is part of. We've marked the networks we found that this IP address belongs to in red below. Make sure you read all the WHOIS information so that you see all networks this IP belongs to. We recommend blocking the network with the lowest number of addresses. You may find this is listed at the end as part of the 'rWHOIS' query which contacts the local WHOIS server that is run by the network administrator.\", 'wordfence'), esc_html($_GET['whoisval'])), array('span'=>array('style'=>array()))); ?>\n\t\t\t<\/p>\n\t\t<?php } ?>\n\t\t<div id=\"wfrawhtml\" class=\"wf-padding-add-top\"><\/div>\n\t<\/div>\n\t<script type=\"text\/x-jquery-template\" id=\"wfBlockedRangesTmpl\">\n\t\t<div>\n\t\t\t<div style=\"border-bottom: 1px solid #CCC; padding-bottom: 10px; margin-bottom: 10px;\">\n\t\t\t\t<table border=\"0\" style=\"width: 100%\">\n\t\t\t\t\t{{each(idx, elem) results}}\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td><\/td>\n\t\t\t\t\t<\/tr>\n\t\t\t\t\t{{\/each}}\n\t\t\t\t<\/table>\n\t\t\t<\/div>\n\t\t<\/div>\n\t<\/script>\n\t<script type=\"text\/javascript\">\n\t\tvar whoisval = \"<?php if (isset($_GET['whoisval'])) {\n\t\t\techo esc_js($_GET['whoisval']);\n\t\t} ?>\";\n\t\tif (whoisval) {\n\t\t\tjQuery(function() {\n\t\t\t\tjQuery('#wfwhois').val(whoisval);\n\t\t\t\twhois(whoisval);\n\t\t\t});\n\t\t}\n\t<\/script>\n\n\t<script type=\"text\/x-jquery-template\" id=\"wfWhoisBlock\">\n\t\t<div class=\"wf-block wf-active\">\n\t\t\t<div class=\"wf-block-header\">\n\t\t\t\t<div class=\"wf-block-header-content\">\n\t\t\t\t\t<div class=\"wf-block-title\">\n\t\t\t\t\t\t<strong><?php esc_html_e('Whois Lookup', 'wordfence') ?> <a>${ip}<\/a><\/strong>\n\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t<\/div>\n\t\t\t<div class=\"wf-block-content wf-clearfix\">\n\t\t\t\t<ul class=\"wf-block-list\">\n\t\t\t\t\t<li>\n\t\t\t\t\t\t<div class=\"wf-padding-add-top\">{{html whois}}<\/div>\n\t\t\t\t\t<\/li>\n\t\t\t\t<\/ul>\n\t\t\t<\/div>\n\t\t<\/div>\n\t<\/script>\n\n<\/div>\n\n<script type=\"text\/javascript\">\n\tfunction whois(ip) {\n\t\tvar val = ip.replace(' ', '');\n\t\tif (!\/\\w+\/.test(val)) {\n\t\t\tWFAD.colorboxModal('300px', <?php echo json_encode(__(\"Enter a valid IP or domain\", 'wordfence')) ?>, <?php echo json_encode(__(\"Please enter a valid IP address or domain name for your whois lookup.\", 'wordfence')) ?>);\n\t\t\treturn;\n\t\t}\n\t\tvar whoisButton = jQuery('#whoisbutton').attr('disabled', 'disabled')\n\t\t\t.attr('value', <?php echo json_encode(__('Loading...', 'wordfence')) ?>);\n\t\tWFAD.ajax('wordfence_whois', {\n\t\t\tval: val\n\t\t}, function(res) {\n\t\t\twhoisButton.removeAttr('disabled')\n\t\t\t\t.attr('value', <?php echo json_encode(__('Look up IP or Domain', 'wordfence')) ?>);\n\t\t\tvar whoisHTML = WFAD.completeWhois(res, true);\n\t\t\tvar content = jQuery('#wfWhoisBlock').tmpl({\n\t\t\t\tip: val,\n\t\t\t\twhois: whoisHTML\n\t\t\t});\n\t\t\tif (!res.ok)\n\t\t\t\tcontent.addClass('failed');\n\t\t\tjQuery('#wfrawhtml').html(content);\n\t\t});\n\t}\n<\/script>"},{"base":"plugins","rel":"wordfence\/lib\/email_newIssues.php","ext":"php","size":9035,"mtime":1757312769,"type":"text","content":"<?php if (!defined('WORDFENCE_VERSION')) { exit; } ?>\n<?php $scanOptions = $scanController->scanOptions(); ?>\n<p><?php echo esc_html(sprintf(\n\t\/* translators: URL to the site's homepage. *\/\n\t\t__('This email was sent from your website \"%s\" by the Wordfence plugin.', 'wordfence'), get_bloginfo('name', 'raw'))); ?><\/p>\n\n<p><?php\n\n\tif (count($previousIssues) > 0) {\n\t\tprintf(\n\t\t\t\/* translators: 1. URL to the site's homepage. 2. Number of scan results. *\/\n\t\t\t_n('Wordfence found the following new issues on \"%1$s\" (%2$d existing issue was also found again).',\n\t\t\t'Wordfence found the following new issues on \"%1$s\" (%2$d existing issues were also found again).',\n\t\t\tcount($previousIssues),\n\t\t\t'wordfence'),\n\t\t\tesc_html(get_bloginfo('name', 'raw')),\n\t\t\tcount($previousIssues)\n\t\t);\n\t} else {\n\t\techo esc_html(sprintf(\n\t\t\/* translators: 1. URL to the site's homepage. *\/\n\t\t\t__('Wordfence found the following new issues on \"%1$s\".', 'wordfence'),\n\t\t\tget_bloginfo('name', 'raw')\n\t\t));\n\t}\n\n\n\t?><\/p>\n\n<p><?php echo esc_html(sprintf(\n\t\t\/* translators: Localized date. *\/\n\t\t__('Alert generated at %s', 'wordfence'), wfUtils::localHumanDate())); ?><\/p>\n\n<br>\n\n<p><?php echo esc_html(sprintf(\n\t\/* translators: URL to WordPress admin panel. *\/\n\t\t__('See the details of these scan results on your site at: %s', 'wordfence'), wfUtils::wpAdminURL('admin.php?page=WordfenceScan'))); ?><\/p>\n\n<?php if ($scanOptions['scansEnabled_highSense']): ?>\n\t<div style=\"margin: 12px 0;padding: 8px; background-color: #ffffe0; border: 1px solid #ffd975; border-width: 1px 1px 1px 10px;\">\n\t\t<em><?php esc_html_e('HIGH SENSITIVITY scanning is enabled, it may produce false positives', 'wordfence'); ?><\/em>\n\t<\/div>\n<?php endif ?>\n\n<?php if ($timeLimitReached): ?>\n\t<div style=\"margin: 12px 0;padding: 8px; background-color: #ffffe0; border: 1px solid #ffd975; border-width: 1px 1px 1px 10px;\">\n\t\t<em><?php echo wp_kses(sprintf(\n\t\t\t\/* translators: 1. URL to WordPress admin panel. 2. URL to WordPress admin panel. 3. URL to Wordfence support page. 4. URL to Wordfence support page. *\/\n\t\t\t\t__('The scan was terminated early because it reached the time limit for scans. If you would like to allow your scans to run longer, you can customize the limit on the options page: <a href=\"%1$s\">%2$s<\/a> or read more about scan options to improve scan speed here: <a href=\"%3$s\">%4$s<\/a>', 'wordfence'), esc_attr(wfUtils::wpAdminURL('admin.php?page=WordfenceScan&subpage=scan_options#wf-scanner-options-performance')), esc_attr(wfUtils::wpAdminURL('admin.php?page=WordfenceScan&subpage=scan_options')), wfSupportController::esc_supportURL(wfSupportController::ITEM_SCAN_TIME_LIMIT), esc_html(wfSupportController::supportURL(wfSupportController::ITEM_SCAN_TIME_LIMIT))), array('a'=>array('href'=>array()))); ?><\/em>\n\t<\/div>\n<?php endif ?>\n\n<?php\n$severitySections = array(\n\twfIssues::SEVERITY_CRITICAL => __('Critical Problems:', 'wordfence'),\n\twfIssues::SEVERITY_HIGH => __('High Severity Problems:', 'wordfence'),\n\twfIssues::SEVERITY_MEDIUM => __('Medium Severity Problems:', 'wordfence'),\n\twfIssues::SEVERITY_LOW => __('Low Severity Problems:', 'wordfence'),\n);\n?>\n\n<?php\nforeach ($severitySections as $severityLevel => $severityLabel):\n\tif ($severityLevel < $level) {\n\t\tcontinue;\n\t}\n\t$hasIssuesAtSeverity = false;\n\n\tforeach($issues as $i){ if($i['severity'] == $severityLevel){ ?>\n<?php if (!$hasIssuesAtSeverity): $hasIssuesAtSeverity = true; ?>\n<p><?php echo esc_html($severityLabel) ?><\/p>\n<?php endif ?>\n<p>* <?php echo htmlspecialchars($i['shortMsg']) ?><\/p>\n<?php\n\tif ((isset($i['tmplData']['wpRemoved']) && $i['tmplData']['wpRemoved']) || (isset($i['tmplData']['abandoned']) && $i['tmplData']['abandoned'])) {\n\t\tif (isset($i['tmplData']['vulnerable']) && $i['tmplData']['vulnerable']) {\n\t\t\techo '<p><strong>' . esc_html__('Plugin contains an unpatched security vulnerability.', 'wordfence') . '<\/strong>';\n\t\t\tif (isset($i['tmplData']['cvssScore'])) {\n\t\t\t\techo ' <br>' . esc_html__('Vulnerability Severity', 'wordfence') . ': ' . number_format($i['tmplData']['cvssScore'], 1) . '\/10.0 (<span style=\"color:' . wfUpdateCheck::cvssScoreSeverityHexColor($i['tmplData']['cvssScore']) . '\">' . wfUpdateCheck::cvssScoreSeverityLabel($i['tmplData']['cvssScore']) . '<\/span>)';\n\t\t\t}\n\t\t\tif (isset($i['tmplData']['vulnerabilityLink'])) {\n\t\t\t\techo ' <br><a href=\"' . $i['tmplData']['vulnerabilityLink'] . '\" target=\"_blank\" rel=\"nofollow noreferrer noopener\">' . esc_html__('Vulnerability Information', 'wordfence') . '<\/a>';\n\t\t\t}\n\t\t\techo '<\/p>';\n\t\t}\n\t}\n\tif ($i['type'] == 'coreUnknown') {\n\t\techo '<p>' . esc_html__('The core files scan has not run because this version is not currently indexed by Wordfence. New WordPress versions may take up to a day to be indexed.', 'wordfence') . '<\/p>';\n\t}\n\telse if ($i['type'] == 'wafStatus') {\n\t\techo '<p>' . esc_html__('Firewall issues may be caused by file permission changes or other technical problems.', 'wordfence') . ' <a href=\"' . wfSupportController::esc_supportURL(wfSupportController::ITEM_SCAN_RESULT_WAF_DISABLED) . '\" target=\"_blank\" rel=\"nofollow noreferrer noopener\">' . esc_html__('More Details and Instructions', 'wordfence') . '<\/a><\/p>';\n    }\n\telse if ($i['type'] == 'skippedPaths') {\n\t\techo '<p>' . esc_html__('Scanning additional paths is optional and is not always necessary.', 'wordfence') . ' <a href=\"' . wfSupportController::esc_supportURL(wfSupportController::ITEM_SCAN_RESULT_SKIPPED_PATHS) . '\" target=\"_blank\" rel=\"nofollow noreferrer noopener\">' . esc_html__('Learn More', 'wordfence') . '<\/a><\/p>';\n\t}\n\n\t$showWPParagraph = !empty($i['tmplData']['vulnerable']) || isset($i['tmplData']['wpURL']);\n\tif ($showWPParagraph) {\n\t\techo '<p>';\n\t}\n\tif (!empty($i['tmplData']['vulnerable'])) {\n\t\tif (isset($i['tmplData']['updateAvailable']) && $i['tmplData']['updateAvailable'] !== false)\n\t\t\techo '<strong>' . esc_html__('Update includes security-related fixes.', 'wordfence') . '<\/strong>';\n\t\tif (isset($i['tmplData']['cvssScore'])) {\n\t\t\techo ' <br>' . esc_html__('Vulnerability Severity', 'wordfence') . ': ' . number_format($i['tmplData']['cvssScore'], 1) . '\/10.0 (<span style=\"color:' . wfUpdateCheck::cvssScoreSeverityHexColor($i['tmplData']['cvssScore']) . '\">' . wfUpdateCheck::cvssScoreSeverityLabel($i['tmplData']['cvssScore']) . '<\/span>)';\n\t\t}\n\t\tif (isset($i['tmplData']['vulnerabilityLink'])) {\n\t\t\techo ' <a href=\"' . $i['tmplData']['vulnerabilityLink'] . '\" target=\"_blank\" rel=\"nofollow noreferrer noopener\">' . esc_html__('Vulnerability Information', 'wordfence') . '<\/a>';\n\t\t}\n\t}\n\tif (isset($i['tmplData']['wpURL'])) {\n\t\tif(!empty($i['tmplData']['vulnerable']))\n\t\t\techo '<br>';\n\t\techo $i['tmplData']['wpURL'] . '\/#developers';\n\t}\n\tif ($showWPParagraph) {\n\t\techo '<\/p>';\n\t}\n\t?>\n\n<?php\nif (!empty($i['tmplData']['badURL'])):\n\t$api = new wfAPI(wfConfig::get('apiKey'), wfUtils::getWPVersion());\n\t$url = set_url_scheme($api->getTextImageURL($i['tmplData']['badURL']), 'https');\n?>\n<p><img src=\"<?php echo esc_url($url) ?>\" alt=\"<?php esc_html_e('The malicious URL matched', 'wordfence') ?>\" \/><\/p>\n<?php endif ?>\n\n<?php } } ?>\n<?php endforeach; ?>\n\n<?php\n$sentences = array();\nif (count($previousIssues)) {\n\t$sentences[] = sprintf(\/* translators: Number of scan results *\/_n('%d existing issue was found again and is not shown.', '%d existing issues were found again and are not shown.', count($previousIssues), 'wordfence'), count($previousIssues));\n}\nif ($issuesNotShown > 0) {\n\t$sentences[] = sprintf(\/* translators: Number of scan results *\/ _n('%d issue was omitted from this email due to length limits.', '%d issues were omitted from this email due to length limits.', $issuesNotShown, 'wordfence'), $issuesNotShown);\n\t$sentences[] = esc_html__('View every issue:', 'wordfence') . sprintf(' <a href=\"%s\">%s<\/a>', esc_attr(wfUtils::wpAdminURL('admin.php?page=WordfenceScan')), esc_html(wfUtils::wpAdminURL('admin.php?page=WordfenceScan')));\n}\n\nif (count($sentences)) {\n\tprintf('<p>%s<\/p>', implode(' ', $sentences));\n}\n?>\n\n<?php if(! $isPaid){ ?>\n\t<p><?php esc_html_e('NOTE: You are using the free version of Wordfence. Upgrade today:', 'wordfence'); ?><\/p>\n\t\n\t<ul>\n\t\t<li><?php esc_html_e('Receive real-time Firewall and Scan engine rule updates for protection as threats emerge', 'wordfence'); ?><\/li>\n\t\t<li><?php esc_html_e('Real-time IP Blocklist blocks the most malicious IPs from accessing your site', 'wordfence'); ?><\/li>\n\t\t<li><?php esc_html_e('Country blocking', 'wordfence'); ?><\/li>\n\t\t<li><?php esc_html_e('IP reputation monitoring', 'wordfence'); ?><\/li>\n\t\t<li><?php esc_html_e('Schedule scans to run more frequently and at optimal times', 'wordfence'); ?><\/li>\n\t\t<li><?php esc_html_e('Access to Premium Support', 'wordfence'); ?><\/li>\n\t\t<li><?php esc_html_e('Discounts for multi-year and multi-license purchases', 'wordfence'); ?><\/li>\n\t<\/ul>\n\n\t<p><?php esc_html_e('Click here to upgrade to Wordfence Premium:', 'wordfence'); ?><br><a href=\"https:\/\/www.wordfence.com\/zz2\/wordfence-signup\/\">https:\/\/www.wordfence.com\/zz2\/wordfence-signup\/<\/a><\/p>\n<?php } ?>\n\n<p><!-- ##UNSUBSCRIBE## --><\/p>"},{"base":"plugins","rel":"wordfence\/lib\/wfDB.php","ext":"php","size":11764,"mtime":1757312769,"type":"text","content":"<?php\nclass wfDB {\n\tpublic $errorMsg = false;\n\t\n\tpublic static function shared() {\n\t\tstatic $_shared = null;\n\t\tif ($_shared === null) {\n\t\t\t$_shared = new wfDB();\n\t\t}\n\t\treturn $_shared;\n\t}\n  \n  \/**\n   * Returns the table prefix for the main site on multisites and the site itself on single site installations.\n   *\n   * @return string\n   *\/\n\tpublic static function networkPrefix() {\n\t\tglobal $wpdb;\n\t\treturn $wpdb->base_prefix;\n\t}\n  \n  \/**\n   * Returns the table with the site (single site installations) or network (multisite) prefix added.\n   *\n   * @param string $table\n   * @param bool $applyCaseConversion Whether or not to convert the table case to what is actually in use.\n   * @return string\n   *\/\n\tpublic static function networkTable($table, $applyCaseConversion = true) {\n\t\tif (wfSchema::usingLowercase() && $applyCaseConversion) {\n\t\t\t$table = strtolower($table);\n\t\t}\n\t\treturn self::networkPrefix() . $table;\n\t}\n  \n  \/**\n   * Returns the table prefix for the given blog ID. On single site installations, this will be equivalent to wfDB::networkPrefix().\n   *\n   * @param int $blogID\n   * @return string\n   *\/\n\tpublic static function blogPrefix($blogID) {\n\t  global $wpdb;\n\t  return $wpdb->get_blog_prefix($blogID);\n\t}\n  \n  \/**\n   * Returns the table with the site (single site installations) or blog-specific (multisite) prefix added.\n   *\n   * @param string $table\n   * @param bool $applyCaseConversion Whether or not to convert the table case to what is actually in use.\n   * @return string\n   *\/\n\tpublic static function blogTable($table, $blogID, $applyCaseConversion = true) {\n\t\tif (wfSchema::usingLowercase() && $applyCaseConversion) {\n\t\t\t$table = strtolower($table);\n\t\t}\n\t  \treturn self::blogPrefix($blogID) . $table;\n\t}\n\t\n\t\/**\n\t * Converts the given value into a MySQL hex string. This is needed because WordPress will run an unnecessary `SHOW\n\t * FULL COLUMNS` on every hit where we use non-ASCII data (e.g., packed binary-encoded IP addresses) in queries.\n\t * \n\t * @param string $binary\n\t * @return string\n\t *\/\n\tpublic static function binaryValueToSQLHex($binary) {\n\t\treturn sprintf(\"X'%s'\", bin2hex($binary));\n\t}\n\t\n\tpublic function querySingle(){\n\t\tglobal $wpdb;\n\t\tif(func_num_args() > 1){\n\t\t\t$args = func_get_args();\n\t\t\treturn $wpdb->get_var(call_user_func_array(array($wpdb, 'prepare'), $args));\n\t\t} else {\n\t\t\treturn $wpdb->get_var(func_get_arg(0));\n\t\t}\n\t}\n\tpublic function querySingleRec(){ \/\/queryInSprintfFormat, arg1, arg2, ... :: Returns a single assoc-array or null if nothing found.\n\t\tglobal $wpdb;\n\t\tif(func_num_args() > 1){\n\t\t\t$args = func_get_args();\n\t\t\treturn $wpdb->get_row(call_user_func_array(array($wpdb, 'prepare'), $args), ARRAY_A);\n\t\t} else {\n\t\t\treturn $wpdb->get_row(func_get_arg(0), ARRAY_A);\n\t\t}\n\t}\n\tpublic function queryWrite(){\n\t\tglobal $wpdb;\n\t\tif(func_num_args() > 1){\n\t\t\t$args = func_get_args();\n\t\t\treturn $wpdb->query(call_user_func_array(array($wpdb, 'prepare'), $args));\n\t\t} else {\n\t\t\treturn $wpdb->query(func_get_arg(0));\n\t\t}\n\t}\n\tpublic function queryWriteArray($query, $array) {\n\t\tglobal $wpdb;\n\t\treturn $wpdb->query($wpdb->prepare($query, $array));\n\t}\n\tpublic function flush(){ \/\/Clear cache\n\t\tglobal $wpdb;\n\t\t$wpdb->flush();\n\t}\n\tpublic function querySelect(){ \/\/sprintfString, arguments :: always returns array() and will be empty if no results.\n\t\tglobal $wpdb;\n\t\tif(func_num_args() > 1){\n\t\t\t$args = func_get_args();\n\t\t\treturn $wpdb->get_results(call_user_func_array(array($wpdb, 'prepare'), $args), ARRAY_A);\n\t\t} else {\n\t\t\treturn $wpdb->get_results(func_get_arg(0), ARRAY_A);\n\t\t}\n\t}\n\tpublic function queryWriteIgnoreError(){ \/\/sprintfString, arguments\n\t\tglobal $wpdb;\n\t\t$oldSuppress = $wpdb->suppress_errors(true);\n\t\t$args = func_get_args();\n\t\tcall_user_func_array(array($this, 'queryWrite'), $args);\n\t\t$wpdb->suppress_errors($oldSuppress);\n\t}\n\tpublic function columnExists($table, $col){\n\t\t$table = wfDB::networkTable($table);\n\t\t$q = $this->querySelect(\"desc $table\");\n\t\tforeach($q as $row){\n\t\t\tif($row['Field'] == $col){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tpublic function dropColumn($table, $col){\n\t\t$table = wfDB::networkTable($table);\n\t\t$this->queryWrite(\"alter table $table drop column $col\");\n\t}\n\tpublic function createKeyIfNotExists($table, $col, $keyName){\n\t\t$table = wfDB::networkTable($table);\n\t\t\n\t\t$exists = $this->querySingle(<<<SQL\nSELECT TABLE_NAME FROM information_schema.TABLES\nWHERE TABLE_SCHEMA=DATABASE()\nAND TABLE_NAME='%s'\nSQL\n\t\t\t, $table);\n\t\t$keyFound = false;\n\t\tif($exists){\n\t\t\t$q = $this->querySelect(\"show keys from $table\");\n\t\t\tforeach($q as $row){\n\t\t\t\tif($row['Key_name'] == $keyName){\n\t\t\t\t\t$keyFound = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(! $keyFound){\n\t\t\t$this->queryWrite(\"alter table $table add KEY $keyName($col)\");\n\t\t}\n\t}\n\tpublic function getMaxAllowedPacketBytes(){\n\t\t$rec = $this->querySingleRec(\"show variables like 'max_allowed_packet'\");\n\t\treturn intval($rec['Value']);\n\t}\n\tpublic function getMaxLongDataSizeBytes() {\n\t\t$rec = $this->querySingleRec(\"show variables like 'max_long_data_size'\");\n\t\treturn $rec['Value'];\n\t}\n\tpublic function truncate($table){ \/\/Ensures everything is deleted if user is using MySQL >= 5.1.16 and does not have \"drop\" privileges\n\t\t$this->queryWrite(\"truncate table $table\");\n\t\t$this->queryWrite(\"delete from $table\");\n\t}\n\tpublic function getLastError(){\n\t\tglobal $wpdb;\n\t\treturn $wpdb->last_error;\n\t}\n\tpublic function realEscape($str){\n\t\tglobal $wpdb;\n\t\treturn $wpdb->_real_escape($str);\n\t}\n\tpublic function insert($table, $columns, $rows, $updateOnDuplicate) {\n\t\tglobal $wpdb;\n\t\t$rowCount = count($rows);\n\t\tif ($rowCount === 0)\n\t\t\treturn;\n\t\t$columnClause = implode(',', array_keys($columns));\n\t\t$valuesClause = ltrim(str_repeat(',(' . implode(',', $columns) . ')', $rowCount), ',');\n\t\tif ($updateOnDuplicate) {\n\t\t\t$duplicateClause = ' ON DUPLICATE KEY UPDATE ' . implode(',', array_map(function($column) {\n\t\t\t\treturn \"{$column} = VALUES({$column})\";\n\t\t\t}, $updateOnDuplicate));\n\t\t}\n\t\telse {\n\t\t\t$duplicateClause = null;\n\t\t}\n\t\t$parameters = [];\n\t\tforeach ($rows as $row) {\n\t\t\tforeach ($row as $value) {\n\t\t\t\t$parameters[] = $value;\n\t\t\t}\n\t\t}\n\t\t$query = $wpdb->prepare(\"INSERT INTO {$table} ({$columnClause}) VALUES {$valuesClause}{$duplicateClause}\", $parameters);\n\t\t$result = $wpdb->query($query);\n\t\tif ($result === false)\n\t\t\tthrow new RuntimeException(\"Insert query failed: {$query}\");\n\t}\n\tprivate static function getBindingType($value, $override = null) {\n\t\tif ($override !== null)\n\t\t\treturn $override;\n\t\tif (is_int($value)) {\n\t\t\treturn '%d';\n\t\t}\n\t\telse {\n\t\t\treturn '%s';\n\t\t}\n\t}\n\tprivate static function buildWhereClause($conditions, $bindingOverrides, &$parameters) {\n\t\t$whereExpressions = [];\n\t\tforeach ($conditions as $column => $value) {\n\t\t\t$override = array_key_exists($column, $bindingOverrides) ? $bindingOverrides[$column] : null;\n\t\t\tif ($override === null) {\n\t\t\t\t$getBinding = [self::class, 'getBindingType'];\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$getBinding = function($value) use ($override) { return $override; };\n\t\t\t}\n\t\t\tif (is_array($value)) {\n\t\t\t\t$whereExpressions[] = \"{$column} IN (\" . implode(',', array_map($getBinding, $value)) . ')';\n\t\t\t\t$parameters = array_merge($parameters, $value);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$whereExpressions[] = \"{$column} = \" . $getBinding($value);\n\t\t\t\t$parameters[] = $value;\n\t\t\t}\n\t\t}\n\t\treturn implode(' AND ', $whereExpressions);\n\t}\n\tpublic function update($table, $set, $conditions, $bindingOverrides = []) {\n\t\tglobal $wpdb;\n\t\t$setExpressions = [];\n\t\t$parameters = [];\n\t\tforeach ($set as $column => $value) {\n\t\t\tif (is_array($value)) {\n\t\t\t\t$parameters[] = $value[1];\n\t\t\t\t$value = $value[0];\n\t\t\t}\n\t\t\t$setExpressions[] = \"{$column} = {$value}\";\n\t\t}\n\t\t$whereClause = self::buildWhereClause($conditions, $bindingOverrides, $parameters);\n\t\t$setClause = implode(',', $setExpressions);\n\t\t$query = $wpdb->prepare(\"UPDATE {$table} SET {$setClause} WHERE {$whereClause}\", $parameters);\n\t\t$result = $wpdb->query($query);\n\t\tif ($result === false)\n\t\t\tthrow new RuntimeException(\"UPDATE query failed: {$query}\");\n\t}\n\tpublic function select($table, $columns, $conditions, $bindingOverrides = [], $limit = 500) {\n\t\tglobal $wpdb;\n\t\t$parameters = [];\n\t\t$selectClause = implode(',', $columns);\n\t\t$whereClause = Self::buildWhereClause($conditions, $bindingOverrides, $parameters);\n\t\t$limitClause = $limit === null ? '' : \" LIMIT {$limit}\";\n\t\t$query = $wpdb->prepare(\"SELECT {$selectClause} FROM {$table} WHERE {$whereClause}{$limitClause}\", $parameters);\n\t\tif (count($columns) == 1) {\n\t\t\t$result = $wpdb->get_col($query);\n\t\t}\n\t\telse {\n\t\t\t$result = $wpdb->get_results($query, ARRAY_N);\n\t\t}\n\t\tif (!is_array($result))\n\t\t\tthrow new RuntimeException(\"SELECT query failed: {$query}\");\n\t\treturn $result;\n\t}\n\tpublic function selectAll($table, $columns, $conditions, $bindingOverrides = []) {\n\t\treturn $this->select($table, $columns, $conditions, $bindingOverrides, null);\n\t}\n}\n\nabstract class wfModel {\n\n\tprivate $data;\n\tprivate $db;\n\tprivate $dirty = false;\n\n\t\/**\n\t * Column name of the primary key field.\n\t *\n\t * @return string\n\t *\/\n\tabstract public function getIDColumn();\n\n\t\/**\n\t * Table name.\n\t *\n\t * @return mixed\n\t *\/\n\tabstract public function getTable();\n\n\t\/**\n\t * Checks if this is a valid column in the table before setting data on the model.\n\t *\n\t * @param string $column\n\t * @return boolean\n\t *\/\n\tabstract public function hasColumn($column);\n\n\t\/**\n\t * wfModel constructor.\n\t * @param array|int|string $data\n\t *\/\n\tpublic function __construct($data = array()) {\n\t\tif (is_array($data) || is_object($data)) {\n\t\t\t$this->setData($data);\n\t\t} else if (is_numeric($data)) {\n\t\t\t$this->fetchByID($data);\n\t\t}\n\t}\n\n\tpublic function fetchByID($id) {\n\t\t$id = absint($id);\n\t\t$data = $this->getDB()->get_row($this->getDB()->prepare('SELECT * FROM ' . $this->getTable() .\n\t\t\t\t' WHERE ' . $this->getIDColumn() . ' = %d', $id));\n\t\tif ($data) {\n\t\t\t$this->setData($data);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t\/**\n\t * @return bool\n\t *\/\n\tpublic function save() {\n\t\tif (!$this->dirty) {\n\t\t\treturn false;\n\t\t}\n\t\t$this->dirty = ($this->getPrimaryKey() ? $this->update() : $this->insert()) === false;\n\t\treturn !$this->dirty;\n\t}\n\n\t\/**\n\t * @return false|int\n\t *\/\n\tpublic function insert() {\n\t\t$data = $this->getData();\n\t\tunset($data[$this->getPrimaryKey()]);\n\t\t$rowsAffected = $this->getDB()->insert($this->getTable(), $data);\n\t\t$this->setPrimaryKey($this->getDB()->insert_id);\n\t\treturn $rowsAffected;\n\t}\n\n\t\/**\n\t * @return false|int\n\t *\/\n\tpublic function update() {\n\t\treturn $this->getDB()->update($this->getTable(), $this->getData(), array(\n\t\t\t$this->getIDColumn() => $this->getPrimaryKey(),\n\t\t));\n\t}\n\n\t\/**\n\t * @param $name string\n\t * @return mixed\n\t *\/\n\tpublic function __get($name) {\n\t\tif (!$this->hasColumn($name)) {\n\t\t\treturn null;\n\t\t}\n\t\treturn array_key_exists($name, $this->data) ? $this->data[$name] : null;\n\t}\n\n\t\/**\n\t * @param $name string\n\t * @param $value mixed\n\t *\/\n\tpublic function __set($name, $value) {\n\t\tif (!$this->hasColumn($name)) {\n\t\t\treturn;\n\t\t}\n\t\t$this->data[$name] = $value;\n\t\t$this->dirty = true;\n\t}\n\n\t\/**\n\t * @return array\n\t *\/\n\tpublic function getData() {\n\t\treturn $this->data;\n\t}\n\n\t\/**\n\t * @param array $data\n\t * @param bool $flagDirty\n\t *\/\n\tpublic function setData($data, $flagDirty = true) {\n\t\t$this->data = array();\n\t\tforeach ($data as $column => $value) {\n\t\t\tif ($this->hasColumn($column)) {\n\t\t\t\t$this->data[$column] = $value;\n\t\t\t\t$this->dirty = (bool) $flagDirty;\n\t\t\t}\n\t\t}\n\t}\n\n\t\/**\n\t * @return wpdb\n\t *\/\n\tpublic function getDB() {\n\t\tif ($this->db === null) {\n\t\t\tglobal $wpdb;\n\t\t\t$this->db = $wpdb;\n\t\t}\n\t\treturn $this->db;\n\t}\n\n\t\/**\n\t * @param wpdb $db\n\t *\/\n\tpublic function setDB($db) {\n\t\t$this->db = $db;\n\t}\n\n\t\/**\n\t * @return int\n\t *\/\n\tpublic function getPrimaryKey() {\n\t\treturn $this->{$this->getIDColumn()};\n\t}\n\n\t\/**\n\t * @param int $value\n\t *\/\n\tpublic function setPrimaryKey($value) {\n\t\t$this->{$this->getIDColumn()} = $value;\n\t}\n}"},{"base":"plugins","rel":"wordfence\/lib\/sodium_compat_fast.php","ext":"php","size":185,"mtime":1757312769,"type":"text","content":"<?php\n\nif (!class_exists('ParagonIE_Sodium_Compat')) {\n\trequire_once WORDFENCE_PATH . '\/crypto\/vendor\/paragonie\/sodium_compat\/autoload.php';\n}\nParagonIE_Sodium_Compat::$fastMult = true;"},{"base":"plugins","rel":"wordfence\/lib\/wfBrowscapCache.php","ext":"php","size":262994,"mtime":1757312769},{"base":"plugins","rel":"wordfence\/lib\/flags.php","ext":"php","size":6779,"mtime":1757312769,"type":"text","content":"<?php\n$flags = array (\n  '__' => '-0px -0px',\n  'ad' => '-16px -0px',\n  'ae' => '-32px -0px',\n  'af' => '-48px -0px',\n  'ag' => '-64px -0px',\n  'ai' => '-80px -0px',\n  'al' => '-96px -0px',\n  'am' => '-112px -0px',\n  'an' => '-128px -0px',\n  'ao' => '-144px -0px',\n  'ap' => '-160px -0px',\n  'aq' => '-176px -0px',\n  'ar' => '-0px -11px',\n  'as' => '-16px -11px',\n  'at' => '-32px -11px',\n  'au' => '-48px -11px',\n  'aw' => '-64px -11px',\n  'ax' => '-80px -11px',\n  'az' => '-96px -11px',\n  'ba' => '-112px -11px',\n  'bb' => '-128px -11px',\n  'bd' => '-144px -11px',\n  'be' => '-160px -11px',\n  'bf' => '-176px -11px',\n  'bg' => '-0px -22px',\n  'bh' => '-16px -22px',\n  'bi' => '-32px -22px',\n  'bj' => '-48px -22px',\n  'bl' => '-64px -22px',\n  'bm' => '-80px -22px',\n  'bn' => '-96px -22px',\n  'bo' => '-112px -22px',\n  'bq' => '-128px -22px',\n  'br' => '-144px -22px',\n  'bs' => '-160px -22px',\n  'bt' => '-176px -22px',\n  'bv' => '-0px -33px',\n  'bw' => '-16px -33px',\n  'by' => '-32px -33px',\n  'bz' => '-48px -33px',\n  'ca' => '-64px -33px',\n  'cc' => '-80px -33px',\n  'cd' => '-96px -33px',\n  'cf' => '-112px -33px',\n  'cg' => '-128px -33px',\n  'ch' => '-144px -33px',\n  'ci' => '-160px -33px',\n  'ck' => '-176px -33px',\n  'cl' => '-0px -44px',\n  'cm' => '-16px -44px',\n  'cn' => '-32px -44px',\n  'co' => '-48px -44px',\n  'cr' => '-64px -44px',\n  'cs' => '-80px -44px',\n  'cu' => '-96px -44px',\n  'cv' => '-112px -44px',\n  'cw' => '-128px -44px',\n  'cx' => '-144px -44px',\n  'cy' => '-160px -44px',\n  'cz' => '-176px -44px',\n  'de' => '-0px -55px',\n  'dj' => '-16px -55px',\n  'dk' => '-32px -55px',\n  'dm' => '-48px -55px',\n  'do' => '-64px -55px',\n  'dz' => '-80px -55px',\n  'ec' => '-96px -55px',\n  'ee' => '-112px -55px',\n  'eg' => '-128px -55px',\n  'eh' => '-144px -55px',\n  'england' => '-160px -55px',\n  'er' => '-176px -55px',\n  'es' => '-0px -66px',\n  'et' => '-16px -66px',\n  'eu' => '-32px -66px',\n  'fam' => '-48px -66px',\n  'fi' => '-64px -66px',\n  'fj' => '-80px -66px',\n  'fk' => '-96px -66px',\n  'fm' => '-112px -66px',\n  'fo' => '-128px -66px',\n  'fr' => '-144px -66px',\n  'ga' => '-160px -66px',\n  'gb' => '-176px -66px',\n  'gd' => '-0px -77px',\n  'ge' => '-16px -77px',\n  'gf' => '-32px -77px',\n  'gg' => '-48px -77px',\n  'gh' => '-64px -77px',\n  'gi' => '-80px -77px',\n  'gl' => '-96px -77px',\n  'gm' => '-112px -77px',\n  'gn' => '-128px -77px',\n  'gp' => '-144px -77px',\n  'gq' => '-160px -77px',\n  'gr' => '-176px -77px',\n  'gs' => '-0px -88px',\n  'gt' => '-16px -88px',\n  'gu' => '-32px -88px',\n  'gw' => '-48px -88px',\n  'gy' => '-64px -88px',\n  'hk' => '-80px -88px',\n  'hm' => '-96px -88px',\n  'hn' => '-112px -88px',\n  'hr' => '-128px -88px',\n  'ht' => '-144px -88px',\n  'hu' => '-160px -88px',\n  'id' => '-176px -88px',\n  'ie' => '-0px -99px',\n  'il' => '-16px -99px',\n  'im' => '-32px -99px',\n  'in' => '-48px -99px',\n  'io' => '-64px -99px',\n  'iq' => '-80px -99px',\n  'ir' => '-96px -99px',\n  'is' => '-112px -99px',\n  'it' => '-128px -99px',\n  'je' => '-144px -99px',\n  'jm' => '-160px -99px',\n  'jo' => '-176px -99px',\n  'jp' => '-0px -110px',\n  'ke' => '-16px -110px',\n  'kg' => '-32px -110px',\n  'kh' => '-48px -110px',\n  'ki' => '-64px -110px',\n  'km' => '-80px -110px',\n  'kn' => '-96px -110px',\n  'kp' => '-112px -110px',\n  'kr' => '-128px -110px',\n  'kw' => '-144px -110px',\n  'ky' => '-160px -110px',\n  'kz' => '-176px -110px',\n  'la' => '-0px -121px',\n  'lb' => '-16px -121px',\n  'lc' => '-32px -121px',\n  'li' => '-48px -121px',\n  'lk' => '-64px -121px',\n  'lr' => '-80px -121px',\n  'ls' => '-96px -121px',\n  'lt' => '-112px -121px',\n  'lu' => '-128px -121px',\n  'lv' => '-144px -121px',\n  'ly' => '-160px -121px',\n  'ma' => '-176px -121px',\n  'mc' => '-0px -132px',\n  'md' => '-16px -132px',\n  'me' => '-32px -132px',\n  'mf' => '-48px -132px',\n  'mg' => '-64px -132px',\n  'mh' => '-80px -132px',\n  'mk' => '-96px -132px',\n  'ml' => '-112px -132px',\n  'mm' => '-128px -132px',\n  'mn' => '-144px -132px',\n  'mo' => '-160px -132px',\n  'mp' => '-176px -132px',\n  'mq' => '-0px -143px',\n  'mr' => '-16px -143px',\n  'ms' => '-32px -143px',\n  'mt' => '-48px -143px',\n  'mu' => '-64px -143px',\n  'mv' => '-80px -143px',\n  'mw' => '-96px -143px',\n  'mx' => '-112px -143px',\n  'my' => '-128px -143px',\n  'mz' => '-144px -143px',\n  'na' => '-160px -143px',\n  'nc' => '-176px -143px',\n  'ne' => '-0px -154px',\n  'nf' => '-16px -154px',\n  'ng' => '-32px -154px',\n  'ni' => '-48px -154px',\n  'nl' => '-64px -154px',\n  'no' => '-80px -154px',\n  'np' => '-96px -154px',\n  'nr' => '-112px -154px',\n  'nu' => '-128px -154px',\n  'nz' => '-144px -154px',\n  'om' => '-160px -154px',\n  'pa' => '-176px -154px',\n  'pe' => '-0px -165px',\n  'pf' => '-16px -165px',\n  'pg' => '-32px -165px',\n  'ph' => '-48px -165px',\n  'pk' => '-64px -165px',\n  'pl' => '-80px -165px',\n  'pm' => '-96px -165px',\n  'pn' => '-112px -165px',\n  'pr' => '-128px -165px',\n  'ps' => '-144px -165px',\n  'pt' => '-160px -165px',\n  'pw' => '-176px -165px',\n  'py' => '-0px -176px',\n  'qa' => '-16px -176px',\n  're' => '-32px -176px',\n  'ro' => '-48px -176px',\n  'rs' => '-64px -176px',\n  'ru' => '-80px -176px',\n  'rw' => '-96px -176px',\n  'sa' => '-112px -176px',\n  'sb' => '-128px -176px',\n  'sc' => '-144px -176px',\n  'scotland' => '-160px -176px',\n  'sd' => '-176px -176px',\n  'se' => '-0px -187px',\n  'sg' => '-16px -187px',\n  'sh' => '-32px -187px',\n  'si' => '-48px -187px',\n  'sj' => '-64px -187px',\n  'sk' => '-80px -187px',\n  'sl' => '-96px -187px',\n  'sm' => '-112px -187px',\n  'sn' => '-128px -187px',\n  'so' => '-144px -187px',\n  'sr' => '-160px -187px',\n  'ss' => '-176px -187px',\n  'st' => '-0px -198px',\n  'sv' => '-16px -198px',\n  'sx' => '-32px -198px',\n  'sy' => '-48px -198px',\n  'sz' => '-64px -198px',\n  'tc' => '-80px -198px',\n  'td' => '-96px -198px',\n  'tf' => '-112px -198px',\n  'tg' => '-128px -198px',\n  'th' => '-144px -198px',\n  'tj' => '-160px -198px',\n  'tk' => '-176px -198px',\n  'tl' => '-0px -209px',\n  'tm' => '-16px -209px',\n  'tn' => '-32px -209px',\n  'to' => '-48px -209px',\n  'tr' => '-64px -209px',\n  'tt' => '-80px -209px',\n  'tv' => '-96px -209px',\n  'tw' => '-112px -209px',\n  'tz' => '-128px -209px',\n  'ua' => '-144px -209px',\n  'ug' => '-160px -209px',\n  'uk' => '-176px -209px',\n  'um' => '-0px -220px',\n  'un' => '-16px -220px',\n  'us' => '-32px -220px',\n  'uy' => '-48px -220px',\n  'uz' => '-64px -220px',\n  'va' => '-80px -220px',\n  'vc' => '-96px -220px',\n  've' => '-112px -220px',\n  'vg' => '-128px -220px',\n  'vi' => '-144px -220px',\n  'vn' => '-160px -220px',\n  'vu' => '-176px -220px',\n  'wales' => '-0px -231px',\n  'wf' => '-16px -231px',\n  'ws' => '-32px -231px',\n  'xk' => '-48px -231px',\n  'ye' => '-64px -231px',\n  'yt' => '-80px -231px',\n  'za' => '-96px -231px',\n  'zm' => '-112px -231px',\n  'zw' => '-128px -231px',\n);"},{"base":"plugins","rel":"wordfence\/lib\/wfActivityReport.php","ext":"php","size":20945,"mtime":1757312769,"type":"text","content":"<?php\nif (defined('WORDFENCE_VERSION')) {\n\nclass wfActivityReport {\n\tconst BLOCK_TYPE_COMPLEX = 'complex';\n\tconst BLOCK_TYPE_BRUTE_FORCE = 'bruteforce';\n\tconst BLOCK_TYPE_BLACKLIST = 'blacklist';\n\n\t\/**\n\t * @var int\n\t *\/\n\tprivate $limit = 10;\n\n\t\/**\n\t * @var wpdb\n\t *\/\n\tprivate $db;\n\n\t\/**\n\t * @param int $limit\n\t *\/\n\tpublic function __construct($limit = 10) {\n\t\tglobal $wpdb;\n\t\t$this->db = $wpdb;\n\t\t$this->limit = $limit;\n\t}\n\n\t\/**\n\t * Schedule the activity report cron job.\n\t *\/\n\tpublic static function scheduleCronJob() {\n\t\tself::clearCronJobs();\n\n\t\tif (!wfConfig::get('email_summary_enabled', 1)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (is_main_site()) {\n\t\t\tlist(, $end_time) = wfActivityReport::getReportDateRange();\n\t\t\twp_schedule_single_event($end_time, 'wordfence_email_activity_report');\n\t\t}\n\t}\n\n\t\/**\n\t * Remove the activity report cron job.\n\t *\/\n\tpublic static function disableCronJob() {\n\t\tself::clearCronJobs();\n\t}\n\n\tpublic static function clearCronJobs() {\n\t\twp_clear_scheduled_hook('wordfence_email_activity_report');\n\t}\n\n\t\/**\n\t * Send out the report and reschedule the next report's cron job.\n\t *\/\n\tpublic static function executeCronJob() {\n\t\tif (!wfConfig::get('email_summary_enabled', 1)) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t$emails = wfConfig::getAlertEmails();\n\t\tif (count($emails)) {\n\t\t\t$report = new self();\n\t\t\t$report->sendReportViaEmail($emails);\n\t\t}\n\t\tself::scheduleCronJob();\n\t}\n\n\t\/**\n\t * Output a compact version of the email for the WP dashboard.\n\t *\/\n\tpublic static function outputDashboardWidget() {\n\t\t$report = new self(5);\n\t\techo $report->toWidgetView();\n\t}\n\n\t\/**\n\t * @return array\n\t *\/\n\tpublic static function getReportDateRange() {\n\t\t$interval = wfConfig::get('email_summary_interval', 'weekly');\n\t\t$offset = get_option('gmt_offset');\n\t\treturn self::_getReportDateRange($interval, $offset);\n\t}\n\n\t\/**\n\t * Testable code.\n\t *\n\t * @param string $interval\n\t * @param int    $offset\n\t * @param null   $time\n\t * @return array\n\t *\/\n\tpublic static function _getReportDateRange($interval = 'weekly', $offset = 0, $time = null) {\n\t\tif ($time === null) {\n\t\t\t$time = time();\n\t\t}\n\n\t\t$day = (int) gmdate('w', $time);\n\t\t$month = (int) gmdate(\"n\", $time);\n\t\t$day_of_month = (int) gmdate(\"j\", $time);\n\t\t$year = (int) gmdate(\"Y\", $time);\n\n\t\t$start_time = 0;\n\t\t$end_time = 0;\n\n\t\tswitch ($interval) {\n\t\t\t\/\/ Send a report 4pm every day\n\t\t\tcase 'daily':\n\t\t\t\t$start_time = gmmktime(16, 0, 0, $month, $day_of_month, $year) + (-$offset * 60 * 60);\n\t\t\t\t$end_time = $start_time + 86400;\n\t\t\t\tbreak;\n\t\t\t\n\t\t\t\/\/ Send a report 4pm every Monday\n\t\t\tcase 'weekly':\n\t\t\t\t$start_time = gmmktime(16, 0, 0, $month, $day_of_month - $day + 1, $year) + (-$offset * 60 * 60);\n\t\t\t\t$end_time = $start_time + (86400 * 7);\n\t\t\t\tbreak;\n\n\t\t\t\/\/ Send a report at 4pm the first of every month\n\t\t\tcase 'monthly':\n\t\t\t\t$start_time = gmmktime(16, 0, 0, $month, 1, $year) + (-$offset * 60 * 60);\n\t\t\t\t$end_time = gmmktime(16, 0, 0, $month + 1, 1, $year) + (-$offset * 60 * 60);\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn array($start_time, $end_time);\n\t}\n\n\t\/**\n\t * @return int\n\t *\/\n\tpublic static function getReportDateFrom() {\n\t\t$interval = wfConfig::get('email_summary_interval', 'weekly');\n\t\treturn self::_getReportDateFrom($interval);\n\t}\n\n\t\/**\n\t * @param string $interval\n\t * @param null   $time\n\t * @return int\n\t *\/\n\tpublic static function _getReportDateFrom($interval = 'weekly', $time = null) {\n\t\tif ($time === null) {\n\t\t\t$time = time();\n\t\t}\n\n\t\t\/\/ weekly\n\t\t$from = $time - (86400 * 7);\n\t\tswitch ($interval) {\n\t\t\tcase 'daily':\n\t\t\t\t$from = $time - 86400;\n\t\t\t\tbreak;\n\n\t\t\t\/\/ Send a report at 4pm the first of every month\n\t\t\tcase 'monthly':\n\t\t\t\t$from = strtotime('-1 month', $time);\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn $from;\n\t}\n\n\t\/**\n\t * @return array\n\t *\/\n\tpublic function getFullReport() {\n\t\t$start_time = microtime(true);\n\t\t$remainder = 0;\n\t\t$recent_firewall_activity = $this->getRecentFirewallActivity($this->limit, $remainder);\n\t\treturn array(\n\t\t\t'top_ips_blocked'          => $this->getTopIPsBlocked($this->limit),\n\t\t\t'top_countries_blocked'    => $this->getTopCountriesBlocked($this->limit),\n\t\t\t'top_failed_logins'        => $this->getTopFailedLogins($this->limit),\n\t\t\t'recent_firewall_activity' => $recent_firewall_activity,\n\t\t\t'omitted_firewall_activity'=> $remainder,\n\t\t\t'recently_modified_files'  => $this->getRecentFilesModified($this->limit),\n\t\t\t'updates_needed'           => $this->getUpdatesNeeded(),\n\t\t\t'microseconds'             => microtime(true) - $start_time,\n\t\t);\n\t}\n\n\t\/**\n\t * @return array\n\t *\/\n\tpublic function getWidgetReport() {\n\t\t$start_time = microtime(true);\n\t\treturn array(\n\t\t\t'top_ips_blocked'       => $this->getTopIPsBlocked($this->limit),\n\t\t\t'top_countries_blocked' => $this->getTopCountriesBlocked($this->limit),\n\t\t\t'top_failed_logins'     => $this->getTopFailedLogins($this->limit),\n\t\t\t'updates_needed'        => $this->getUpdatesNeeded(),\n\t\t\t'microseconds'          => microtime(true) - $start_time,\n\t\t);\n\t}\n\t\n\tpublic function getBlockedCount($maxAgeDays = null, $grouping = null) {\n\t\t$maxAgeDays = (int) $maxAgeDays;\n\t\tif ($maxAgeDays <= 0) {\n\t\t\t$interval = 'FLOOR(UNIX_TIMESTAMP(DATE_SUB(NOW(), interval 7 day)) \/ 86400)';\n\t\t\tswitch (wfConfig::get('email_summary_interval', 'weekly')) {\n\t\t\t\tcase 'daily':\n\t\t\t\t\t$interval = 'FLOOR(UNIX_TIMESTAMP(DATE_SUB(NOW(), interval 1 day)) \/ 86400)';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'monthly':\n\t\t\t\t\t$interval = 'FLOOR(UNIX_TIMESTAMP(DATE_SUB(NOW(), interval 1 month)) \/ 86400)';\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t$interval = 'FLOOR(UNIX_TIMESTAMP(DATE_SUB(NOW(), interval ' . $maxAgeDays . ' day)) \/ 86400)';\n\t\t}\n\t\t\n\t\t\/\/Possible values for blockType: throttle, manual, brute, fakegoogle, badpost, country, advanced, blacklist, waf\n\t\t$groupingWHERE = '';\n\t\tswitch ($grouping) {\n\t\t\tcase self::BLOCK_TYPE_COMPLEX:\n\t\t\t\t$groupingWHERE = ' AND blockType IN (\"fakegoogle\", \"badpost\", \"country\", \"advanced\", \"waf\")';\n\t\t\t\tbreak;\n\t\t\tcase self::BLOCK_TYPE_BRUTE_FORCE:\n\t\t\t\t$groupingWHERE = ' AND blockType IN (\"throttle\", \"brute\")';\n\t\t\t\tbreak;\n\t\t\tcase self::BLOCK_TYPE_BLACKLIST:\n\t\t\t\t$groupingWHERE = ' AND blockType IN (\"blacklist\", \"manual\")';\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\t$table_wfBlockedIPLog = wfDB::networkTable('wfBlockedIPLog');\n\t\t$count = $this->db->get_var(<<<SQL\nSELECT SUM(blockCount) as blockCount\nFROM {$table_wfBlockedIPLog}\nWHERE unixday >= {$interval}{$groupingWHERE}\nSQL\n\t\t\t);\n\t\treturn $count;\n\t}\n\n\t\/**\n\t * @param int $limit\n\t * @return mixed\n\t *\/\n\tpublic function getTopIPsBlocked($limit = 10, $maxAgeDays = null) {\n\t\t$maxAgeDays = (int) $maxAgeDays;\n\t\tif ($maxAgeDays <= 0) {\n\t\t\t$interval = 'FLOOR(UNIX_TIMESTAMP(DATE_SUB(NOW(), interval 7 day)) \/ 86400)';\n\t\t\tswitch (wfConfig::get('email_summary_interval', 'weekly')) {\n\t\t\t\tcase 'daily':\n\t\t\t\t\t$interval = 'FLOOR(UNIX_TIMESTAMP(DATE_SUB(NOW(), interval 1 day)) \/ 86400)';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'monthly':\n\t\t\t\t\t$interval = 'FLOOR(UNIX_TIMESTAMP(DATE_SUB(NOW(), interval 1 month)) \/ 86400)';\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t$interval = 'FLOOR(UNIX_TIMESTAMP(DATE_SUB(NOW(), interval ' . $maxAgeDays . ' day)) \/ 86400)';\n\t\t}\n\t\t\n\t\t$table_wfBlockedIPLog = wfDB::networkTable('wfBlockedIPLog');\n\t\t$query=<<<SQL\nSELECT IP, countryCode, unixday, blockType,\nSUM(blockCount) as blockCount\nFROM {$table_wfBlockedIPLog}\nWHERE unixday >= {$interval}\nGROUP BY IP\nORDER BY blockCount DESC\nLIMIT %d\nSQL;\n\t\t$results = $this->db->get_results($this->db->prepare($query, $limit));\n\t\tif ($results) {\n\t\t\tforeach ($results as &$row) {\n\t\t\t\t$row->countryName = $this->getCountryNameByCode($row->countryCode);\n\t\t\t}\n\t\t}\n\t\treturn $results;\n\t}\n\n\t\/**\n\t * @param int $limit\n\t * @return array\n\t *\/\n\tpublic function getTopCountriesBlocked($limit = 10, $maxAgeDays = null) {\n\t\t$maxAgeDays = (int) $maxAgeDays;\n\t\tif ($maxAgeDays <= 0) {\n\t\t\t$interval = 'FLOOR(UNIX_TIMESTAMP(DATE_SUB(NOW(), interval 7 day)) \/ 86400)';\n\t\t\tswitch (wfConfig::get('email_summary_interval', 'weekly')) {\n\t\t\t\tcase 'daily':\n\t\t\t\t\t$interval = 'FLOOR(UNIX_TIMESTAMP(DATE_SUB(NOW(), interval 1 day)) \/ 86400)';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'monthly':\n\t\t\t\t\t$interval = 'FLOOR(UNIX_TIMESTAMP(DATE_SUB(NOW(), interval 1 month)) \/ 86400)';\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t$interval = 'FLOOR(UNIX_TIMESTAMP(DATE_SUB(NOW(), interval ' . $maxAgeDays . ' day)) \/ 86400)';\n\t\t}\n\t  \t\n\t\t$table_wfBlockedIPLog = wfDB::networkTable('wfBlockedIPLog');\n\t\t$query=<<<SQL\nSELECT *, COUNT(IP) as totalIPs, SUM(ipBlockCount) as totalBlockCount\nFROM (SELECT *, SUM(blockCount) AS ipBlockCount FROM {$table_wfBlockedIPLog} WHERE unixday >= {$interval} GROUP BY IP) t\nGROUP BY countryCode\nORDER BY totalBlockCount DESC\nLIMIT %d\nSQL;\n\t\t$results = $this->db->get_results($this->db->prepare($query, $limit));\n\t\tif ($results) {\n\t\t\tforeach ($results as &$row) {\n\t\t\t\t$row->countryName = $this->getCountryNameByCode($row->countryCode);\n\t\t\t}\n\t\t}\n\t\treturn $results;\n\t}\n\n\t\/**\n\t * @param int $limit\n\t * @return mixed\n\t *\/\n\tpublic function getTopFailedLogins($limit = 10) {\n\t\t$interval = 'UNIX_TIMESTAMP(DATE_SUB(NOW(), interval 7 day))';\n\t\tswitch (wfConfig::get('email_summary_interval', 'weekly')) {\n\t\t\tcase 'daily':\n\t\t\t\t$interval = 'UNIX_TIMESTAMP(DATE_SUB(NOW(), interval 1 day))';\n\t\t\t\tbreak;\n\t\t\tcase 'monthly':\n\t\t\t\t$interval = 'UNIX_TIMESTAMP(DATE_SUB(NOW(), interval 1 month))';\n\t\t\t\tbreak;\n\t\t}\n\t  \n\t\t$table_wfLogins = wfDB::networkTable('wfLogins');\n\t\t$failedLogins = $this->db->get_results($this->db->prepare(<<<SQL\nSELECT wfl.*,\nsum(wfl.fail) as fail_count\nFROM {$table_wfLogins} wfl\nWHERE wfl.fail = 1\nAND wfl.ctime > $interval\nGROUP BY wfl.username\nORDER BY fail_count DESC\nLIMIT %d\nSQL\n\t\t\t, $limit));\n\t\t\n\t\tforeach ($failedLogins as &$login) {\n\t\t\t$exists = $this->db->get_var($this->db->prepare(<<<SQL\nSELECT !ISNULL(ID) FROM {$this->db->users} WHERE user_login = '%s' OR user_email = '%s'\nSQL\n\t\t\t, $login->username, $login->username));\n\t\t\t$login->is_valid_user = $exists;\n\t\t}\n\t\t\n\t\treturn $failedLogins;\n\t}\n\n\t\/**\n\t * Returns any updates needs or false if everything is up to date.\n\t *\n\t * @return array|bool\n\t *\/\n\tpublic function getUpdatesNeeded($useCachedValued = true) {\n\t\t$update_check = new wfUpdateCheck();\n\t\t$needs_update = $update_check->checkAllUpdates($useCachedValued)\n\t\t\t->needsAnyUpdates();\n\t\tif ($needs_update) {\n\t\t\treturn array(\n\t\t\t\t'core'    => $update_check->getCoreUpdateVersion(),\n\t\t\t\t'plugins' => $update_check->getPluginUpdates(),\n\t\t\t\t'themes'  => $update_check->getThemeUpdates(),\n\t\t\t);\n\t\t}\n\t\treturn false;\n\t}\n\n\t\/**\n\t * Returns list of firewall activity up to $limit number of entries.\n\t *\n\t * @param int $limit Max events to return in results\n\t * @param int $remainder\n\t * @return array\n\t *\/\n\tpublic function getRecentFirewallActivity($limit, &$remainder) {\n\t\t$dateRange = wfActivityReport::getReportDateRange();\n\t\t$recent_firewall_activity = new wfRecentFirewallActivity(null, max(604800, $dateRange[1] - $dateRange[0]));\n\t\t$recent_firewall_activity->run();\n\t\treturn $recent_firewall_activity->mostRecentActivity($limit, $remainder);\n\t}\n\n\t\/**\n\t * Returns list of files modified within given timeframe.\n\t *\n\t * @todo Add option to configure the regex used to filter files allowed in this list.\n\t * @todo Add option to exclude directories (such as cache directories).\n\t *\n\t * @param string $directory Search for files within this directory\n\t * @param int    $time_range One week\n\t * @param int    $limit Max files to return in results\n\t * @param int    $directory_limit Hard limit for number of files to search within a directory.\n\t * @return array\n\t *\/\n\tpublic function getRecentFilesModified($limit = 300, $directory = ABSPATH, $time_range = 604800, $directory_limit = 20000) {\n\t\t$recently_modified = new wfRecentlyModifiedFiles($directory);\n\t\t$recently_modified->run();\n\t\treturn $recently_modified->mostRecentFiles($limit);\n\t}\n\n\t\/**\n\t * Remove entries older than a month in the IP log.\n\t *\/\n\tpublic function rotateIPLog() {\n\t\t$table_wfBlockedIPLog = wfDB::networkTable('wfBlockedIPLog');\n\t\t$this->db->query(<<<SQL\nDELETE FROM {$table_wfBlockedIPLog}\nWHERE unixday < FLOOR(UNIX_TIMESTAMP(DATE_SUB(NOW(), interval 1 month)) \/ 86400)\nSQL\n\t\t);\n\t}\n\n\t\/**\n\t * @param mixed $ip_address\n\t * @param int|null $unixday\n\t *\/\n\tpublic static function logBlockedIP($ip_address, $unixday = null, $type = null) {\n\t\t\/** @var wpdb $wpdb *\/\n\t\tglobal $wpdb;\n\t\t\n\t\t\/\/Possible values for $type: throttle, manual, brute, fakegoogle, badpost, country, advanced, blacklist, waf\n\n\t\tif (wfUtils::isValidIP($ip_address)) {\n\t\t\t$ip_bin = wfUtils::inet_pton($ip_address);\n\t\t} else {\n\t\t\t$ip_bin = $ip_address;\n\t\t\t$ip_address = wfUtils::inet_ntop($ip_bin);\n\t\t}\n\t\t\n\t\t$blocked_table = wfDB::networkTable('wfBlockedIPLog');\n\n\t\t$unixday_insert = 'FLOOR(UNIX_TIMESTAMP() \/ 86400)';\n\t\tif (is_int($unixday)) {\n\t\t\t$unixday_insert = absint($unixday);\n\t\t}\n\t\t\n\t\tif ($type === null) {\n\t\t\t$type = 'generic';\n\t\t}\n\n\t\t$country = wfUtils::IP2Country($ip_address);\n\t\t\n\t\t$ipHex = wfDB::binaryValueToSQLHex($ip_bin);\n\t\t$wpdb->query($wpdb->prepare(<<<SQL\nINSERT INTO $blocked_table (IP, countryCode, blockCount, unixday, blockType)\nVALUES ({$ipHex}, %s, 1, $unixday_insert, %s)\nON DUPLICATE KEY UPDATE blockCount = blockCount + 1\nSQL\n\t\t\t, $country, $type));\n\t}\n\n\t\/**\n\t * @param $code\n\t * @return string\n\t *\/\n\tpublic function getCountryNameByCode($code) {\n\t\tstatic $wfBulkCountries;\n\t\tif (!isset($wfBulkCountries)) {\n\t\t\tinclude(dirname(__FILE__) . '\/wfBulkCountries.php');\n\t\t}\n\t\treturn array_key_exists($code, $wfBulkCountries) ? $wfBulkCountries[$code] : \"\";\n\t}\n\n\t\/**\n\t * @return wfActivityReportView\n\t *\/\n\tpublic function toView() {\n\t\treturn new wfActivityReportView('reports\/activity-report', $this->getFullReport() + array(\n\t\t\t\t'limit' => $this->getLimit(),\n\t\t\t));\n\t}\n\n\t\/**\n\t * @return wfActivityReportView\n\t *\/\n\tpublic function toWidgetView() {\n\t\treturn new wfActivityReportView('reports\/activity-report', $this->getWidgetReport() + array(\n\t\t\t\t'limit' => $this->getLimit(),\n\t\t\t));\n\t}\n\n\t\/**\n\t * @return wfActivityReportView\n\t *\/\n\tpublic function toEmailView() {\n\t\treturn new wfActivityReportView('reports\/activity-report-email-inline', $this->getFullReport());\n\t}\n\n\t\/**\n\t * @param $email_addresses string|array\n\t * @return bool\n\t *\/\n\tpublic function sendReportViaEmail($email_addresses) {\n\t\t$shortSiteURL = preg_replace('\/^https?:\\\/\\\/\/i', '', site_url());\n\t\t\n\t\t$content = $this->toEmailView()->__toString();\n\t\t\n\t\t$success = true;\n\t\tif (is_string($email_addresses)) { $email_addresses = explode(',', $email_addresses); }\n\t\tforeach ($email_addresses as $email) {\n\t\t\t$uniqueContent = str_replace('<!-- ##UNSUBSCRIBE## -->', wp_kses(sprintf(\/* translators: URL to the WordPress admin panel. *\/ __('No longer an administrator for this site? <a href=\"%s\" target=\"_blank\">Click here<\/a> to stop receiving security alerts.', 'wordfence'), wfUtils::getSiteBaseURL() . '?_wfsf=removeAlertEmail&jwt=' . wfUtils::generateJWT(array('email' => $email))), array('a'=>array('href'=>array(), 'target'=>array()))), $content);\n\t\t\tif (!wp_mail($email, sprintf(\/* translators: 1. Site URL. 2. Localized date. *\/ __('Wordfence activity for %1$s on %2$s', 'wordfence'), date_i18n(get_option('date_format')), $shortSiteURL), $uniqueContent, 'Content-Type: text\/html')) {\n\t\t\t\t$success = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $success;\n\t}\n\n\t\/**\n\t * @return string\n\t * @throws wfViewNotFoundException\n\t *\/\n\tpublic function render() {\n\t\treturn $this->toView()\n\t\t\t->render();\n\t}\n\n\t\/**\n\t * @return string\n\t *\/\n\tpublic function __toString() {\n\t\treturn $this->toView()\n\t\t\t->__toString();\n\t}\n\n\t\/**\n\t * @return int\n\t *\/\n\tpublic function getLimit() {\n\t\treturn $this->limit;\n\t}\n\n\t\/**\n\t * @param int $limit\n\t *\/\n\tpublic function setLimit($limit) {\n\t\t$this->limit = $limit;\n\t}\n}\n\nclass wfRecentFirewallActivity {\n\tprivate $activity = array();\n\t\n\tprivate $max_fetch = 2000;\n\tprivate $time_range = 604800;\n\t\n\tpublic function __construct($max_fetch = null, $time_range = null) {\n\t\tif ($max_fetch !== null) {\n\t\t\t$this->max_fetch = $max_fetch;\n\t\t}\n\t\t\n\t\tif ($time_range !== null) {\n\t\t\t$this->time_range = $time_range;\n\t\t}\n\t}\n\t\n\tpublic function run() {\n\t\tglobal $wpdb;\n\t\t\n\t\t$table_wfHits = wfDB::networkTable('wfHits');\n\t\t$results = $wpdb->get_results($wpdb->prepare(<<<SQL\nSELECT attackLogTime, IP, URL, UA, actionDescription, actionData\nFROM {$table_wfHits}\nWHERE action = 'blocked:waf' AND attackLogTime > (UNIX_TIMESTAMP() - %d)\nORDER BY attackLogTime DESC\nLIMIT %d\nSQL\n\t\t\t, $this->time_range, $this->max_fetch));\n\t\tif ($results) {\n\t\t\tforeach ($results as &$row) {\n\t\t\t\t$actionData = json_decode($row->actionData, true);\n\t\t\t\tif (!is_array($actionData) || !isset($actionData['paramKey']) || !isset($actionData['paramValue'])) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (isset($actionData['failedRules']) && $actionData['failedRules'] == 'blocked') {\n\t\t\t\t\t$row->longDescription = __(\"Blocked because the IP is blocklisted\", 'wordfence');\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$row->longDescription = sprintf(__(\"Blocked for %s\", 'wordfence'), $row->actionDescription);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t$paramKey = base64_decode($actionData['paramKey']);\n\t\t\t\t$paramValue = base64_decode($actionData['paramValue']);\n\t\t\t\tif (strlen($paramValue) > 100) {\n\t\t\t\t\t$paramValue = substr($paramValue, 0, 100) . '...';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (preg_match('\/([a-z0-9_]+\\.[a-z0-9_]+)(?:\\[(.+?)\\](.*))?\/i', $paramKey, $matches)) {\n\t\t\t\t\tswitch ($matches[1]) {\n\t\t\t\t\t\tcase 'request.queryString':\n\t\t\t\t\t\t\t$row->longDescription = sprintf(__('Blocked for %1$s in query string: %2$s = %3$s', 'wordfence'), $row->actionDescription, $matches[2], $paramValue);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'request.body':\n\t\t\t\t\t\t\t$row->longDescription = sprintf(__('Blocked for %1$s in POST body: %2$s = %3$s', 'wordfence'), $row->actionDescription, $matches[2], $paramValue);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'request.cookie':\n\t\t\t\t\t\t\t$row->longDescription = sprintf(__('Blocked for %1$s in cookie: %2$s = %3$s', 'wordfence'), $row->actionDescription, $matches[2], $paramValue);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'request.fileNames':\n\t\t\t\t\t\t\t$row->longDescription = sprintf(__('Blocked for %1$s in file: %2$s = %3$s', 'wordfence'), $row->actionDescription, $matches[2], $paramValue);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t$this->activity = $results;\n\t}\n\t\n\tpublic function mostRecentActivity($limit, &$remainder = null) {\n\t\tif ($remainder !== null) {\n\t\t\t$remainder = count($this->activity) - $limit;\n\t\t}\n\t\treturn array_slice($this->activity, 0, $limit);\n\t}\n}\n\nclass wfRecentlyModifiedFiles extends wfDirectoryIterator {\n\n\t\/**\n\t * @var int\n\t *\/\n\tprivate $time_range = 604800;\n\n\t\/**\n\t * @var array\n\t *\/\n\tprivate $files = array();\n\tprivate $excluded_directories;\n\n\t\/**\n\t * @param string $directory\n\t * @param int    $max_files_per_directory\n\t * @param int    $max_iterations\n\t * @param int    $time_range\n\t *\/\n\tpublic function __construct($directory = ABSPATH, $max_files_per_directory = 20000, $max_iterations = 250000, $time_range = 604800) {\n\t\tparent::__construct($directory, $max_files_per_directory, $max_iterations);\n\t\t$this->time_range = $time_range;\n\t\t$excluded_directories = explode(\"\\n\", wfUtils::cleanupOneEntryPerLine(wfConfig::get('email_summary_excluded_directories', '')));\n\t\t$this->excluded_directories = array();\n\t\tforeach ($excluded_directories  as $index => $path) {\n\t\t\tif (($dir = realpath(ABSPATH . $path)) !== false) {\n\t\t\t\t$this->excluded_directories[$dir] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t\/**\n\t * @param $dir\n\t * @return bool\n\t *\/\n\tprotected function scan($dir) {\n\t\tif (!array_key_exists(realpath($dir), $this->excluded_directories)) {\n\t\t\treturn parent::scan($dir);\n\t\t}\n\t\treturn true;\n\t}\n\n\n\t\/**\n\t * @param string $file\n\t *\/\n\tpublic function file($file) {\n\t\t$mtime = filemtime($file);\n\t\tif (time() - $mtime < $this->time_range) {\n\t\t\t$this->files[] = array($file, $mtime);\n\t\t}\n\t}\n\n\t\/**\n\t * @param int $limit\n\t * @return array\n\t *\/\n\tpublic function mostRecentFiles($limit = 300) {\n\t\tusort($this->files, array(\n\t\t\t$this,\n\t\t\t'_sortMostRecentFiles',\n\t\t));\n\t\treturn array_slice($this->files, 0, $limit);\n\t}\n\n\t\/**\n\t * Sort in descending order.\n\t *\n\t * @param $a\n\t * @param $b\n\t * @return int\n\t *\/\n\tprivate function _sortMostRecentFiles($a, $b) {\n\t\tif ($a[1] > $b[1]) {\n\t\t\treturn -1;\n\t\t}\n\t\tif ($a[1] < $b[1]) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t\/**\n\t * @return mixed\n\t *\/\n\tpublic function getFiles() {\n\t\treturn $this->files;\n\t}\n}\n\n\nclass wfActivityReportView extends wfView {\n\n\t\/**\n\t * @param $file\n\t * @return string\n\t *\/\n\tpublic function displayFile($file) {\n\t\t$realPath = realpath($file);\n\t\tif (stripos($realPath, ABSPATH) === 0) {\n\t\t\treturn substr($realPath, strlen(ABSPATH));\n\t\t}\n\t\treturn $realPath;\n\t}\n\n\t\/**\n\t * @param null $unix_time\n\t * @return string\n\t *\/\n\tpublic function modTime($unix_time = null) {\n\t\tif ($unix_time === null) {\n\t\t\t$unix_time = time();\n\t\t}\n\t\treturn wfUtils::formatLocalTime('F j, Y g:ia', $unix_time);\n\t}\n\t\n\tpublic function attackTime($unix_time = null) {\n\t\tif ($unix_time === null) {\n\t\t\t$unix_time = time();\n\t\t}\n\t\treturn wfUtils::formatLocalTime('F j, Y', $unix_time) . \"<br>\" . wfUtils::formatLocalTime('g:ia', $unix_time);\n\t}\n\t\n\tpublic function displayIP($binaryIP) {\n\t\t$readableIP = wfUtils::inet_ntop($binaryIP);\n\t\t$country = wfUtils::countryCode2Name(wfUtils::IP2Country($readableIP));\n\t\treturn \"{$readableIP} (\" . ($country ? $country : __('Unknown', 'wordfence')) . \")\";\n\t}\n}\n}"},{"base":"plugins","rel":"wordfence\/lib\/wfHelperBin.php","ext":"php","size":2015,"mtime":1757312769,"type":"text","content":"<?php\n\nclass wfHelperBin {\n\n\t\/**\n\t * @param string $bin1\n\t * @param string $bin2\n\t * @return mixed\n\t *\/\n\tpublic static function addbin2bin($bin1, $bin2) {\n\t\tif (strlen($bin1) % 4 != 0) {\n\t\t\t$bin1 = str_repeat(\"\\0\", 4 - (strlen($bin1) % 4)) . $bin1;\n\t\t}\n\t\tif (strlen($bin2) % 4 != 0) {\n\t\t\t$bin2 = str_repeat(\"\\0\", 4 - (strlen($bin2) % 4)) . $bin2;\n\t\t}\n\n\t\t$bin1_ints = array_reverse(array_values(unpack('N*', $bin1)));\n\t\t$bin2_ints = array_reverse(array_values(unpack('N*', $bin2)));\n\t\t$return = array();\n\t\t$carries = 0;\n\t\tfor ($i=0; $i < max(count($bin1_ints), count($bin2_ints)); $i++) {\n\t\t\t$int1 = array_key_exists($i, $bin1_ints) ? $bin1_ints[$i] : 0;\n\t\t\t$int2 = array_key_exists($i, $bin2_ints) ? $bin2_ints[$i] : 0;\n\t\t\t$val = $int1 + $int2 + $carries;\n\t\t\tif ($carries > 0) {\n\t\t\t\t$carries = 0;\n\t\t\t}\n\t\t\tif ($val >= 0x100000000) {\n\t\t\t\t$val -= 0x100000000;\n\t\t\t\t$carries++;\n\t\t\t}\n\t\t\t$return[] = $val;\n\t\t}\n\t\tif ($carries) {\n\t\t\t$return[] += $carries;\n\t\t}\n\t\t$return = array_reverse($return);\n\t\tarray_unshift($return, 'N*');\n\t\t$return = call_user_func_array('pack', $return);\n\t\t$return = ltrim($return, \"\\x00\");\n\t\treturn strlen($return) == 0 ? \"\\x00\" : $return;\n\t}\n\n\t\/**\n\t * Convert binary string to the 10101's representation.\n\t *\n\t * @param string $string\n\t * @return string\n\t *\/\n\tpublic static function bin2str($string) {\n\t\t$return = '';\n\t\tfor ($i = 0; $i < strlen($string); $i++) {\n\t\t\t$return .= str_pad(decbin(ord($string[$i])), 8, '0', STR_PAD_LEFT);\n\t\t}\n\t\t$return = ltrim($return, '0');\n\t\treturn strlen($return) == 0 ? '0' : $return;\n\t}\n\n\t\/**\n\t * Convert 10101's representation back to the binary data.\n\t *\n\t * @param string $string\n\t * @return string\n\t *\/\n\tpublic static function str2bin($string) {\n\t\tif (strlen($string) % 32 > 0) {\n\t\t\t$string = str_repeat('0', 32 - (strlen($string) % 32)) . $string;\n\t\t}\n\t\t$ints = str_split($string, 32);\n\t\t$return = '';\n\t\tforeach ($ints as $int) {\n\t\t\t$return .= pack('N', bindec($int));\n\t\t}\n\t\t$return = ltrim($return, \"\\0\");\n\t\treturn strlen($return) == 0 ? \"\\0\" : $return;\n\t}\n}"},{"base":"plugins","rel":"wordfence\/lib\/Diff\/Renderer\/Html\/Array.php","ext":"php","size":7740,"mtime":1757312769,"type":"text","content":"<?php\n\/**\n * Base renderer for rendering HTML based diffs for PHP DiffLib.\n *\n * PHP version 5\n *\n * Copyright (c) 2009 Chris Boulton <chris.boulton@interspire.com>\n * \n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without \n * modification, are permitted provided that the following conditions are met:\n *\n *  - Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *  - Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and\/or other materials provided with the distribution.\n *  - Neither the name of the Chris Boulton nor the names of its contributors \n *    may be used to endorse or promote products derived from this software \n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n * POSSIBILITY OF SUCH DAMAGE.\n *\n * @package DiffLib\n * @author Chris Boulton <chris.boulton@interspire.com>\n * @copyright (c) 2009 Chris Boulton\n * @license New BSD License http:\/\/www.opensource.org\/licenses\/bsd-license.php\n * @version 1.1\n * @link http:\/\/github.com\/chrisboulton\/php-diff\n *\/\n\nrequire_once(dirname(__FILE__) . '\/..\/Abstract.php');\n\nclass Diff_Renderer_Html_Array extends Diff_Renderer_Abstract\n{\n\t\/**\n\t * @var array Array of the default options that apply to this renderer.\n\t *\/\n\tprotected $defaultOptions = array(\n\t\t'tabSize' => 4\n\t);\n\n\t\/**\n\t * Render and return an array structure suitable for generating HTML\n\t * based differences. Generally called by subclasses that generate a\n\t * HTML based diff and return an array of the changes to show in the diff.\n\t *\n\t * @return array An array of the generated chances, suitable for presentation in HTML.\n\t *\/\n\tpublic function render()\n\t{\n\t\t\/\/ As we'll be modifying a & b to include our change markers,\n\t\t\/\/ we need to get the contents and store them here. That way\n\t\t\/\/ we're not going to destroy the original data\n\t\t$a = $this->diff->getA();\n\t\t$b = $this->diff->getB();\n\n\t\t$changes = array();\n\t\t$opCodes = $this->diff->getGroupedOpcodes();\n\t\tforeach($opCodes as $group) {\n\t\t\t$blocks = array();\n\t\t\t$lastTag = null;\n\t\t\t$lastBlock = 0;\n\t\t\tforeach($group as $code) {\n\t\t\t\tlist($tag, $i1, $i2, $j1, $j2) = $code;\n\n\t\t\t\tif($tag == 'replace' && $i2 - $i1 == $j2 - $j1) {\n\t\t\t\t\tfor($i = 0; $i < ($i2 - $i1); ++$i) {\n\t\t\t\t\t\t$fromLine = $a[$i1 + $i];\n\t\t\t\t\t\t$toLine = $b[$j1 + $i];\n\n\t\t\t\t\t\tlist($start, $end) = $this->getChangeExtent($fromLine, $toLine);\n\t\t\t\t\t\tif($start != 0 || $end != 0) {\n\t\t\t\t\t\t\t$last = $end + strlen($fromLine);\n\t\t\t\t\t\t\t$fromLine = substr_replace($fromLine, \"\\0\", $start, 0);\n\t\t\t\t\t\t\t$fromLine = substr_replace($fromLine, \"\\1\", $last + 1, 0);\n\t\t\t\t\t\t\t$last = $end + strlen($toLine);\n\t\t\t\t\t\t\t$toLine = substr_replace($toLine, \"\\0\", $start, 0);\n\t\t\t\t\t\t\t$toLine = substr_replace($toLine, \"\\1\", $last + 1, 0);\n\t\t\t\t\t\t\t$a[$i1 + $i] = $fromLine;\n\t\t\t\t\t\t\t$b[$j1 + $i] = $toLine;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif($tag != $lastTag) {\n\t\t\t\t\t$blocks[] = array(\n\t\t\t\t\t\t'tag' => $tag,\n\t\t\t\t\t\t'base' => array(\n\t\t\t\t\t\t\t'offset' => $i1,\n\t\t\t\t\t\t\t'lines' => array()\n\t\t\t\t\t\t),\n\t\t\t\t\t\t'changed' => array(\n\t\t\t\t\t\t\t'offset' => $j1,\n\t\t\t\t\t\t\t'lines' => array()\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\t$lastBlock = count($blocks)-1;\n\t\t\t\t}\n\n\t\t\t\t$lastTag = $tag;\n\n\t\t\t\tif($tag == 'equal') {\n\t\t\t\t\t$lines = array_slice($a, $i1, ($i2 - $i1));\n\t\t\t\t\t$blocks[$lastBlock]['base']['lines'] += $this->formatLines($lines);\n\t\t\t\t\t$lines = array_slice($b, $j1, ($j2 - $j1));\n\t\t\t\t\t$blocks[$lastBlock]['changed']['lines'] +=  $this->formatLines($lines);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif($tag == 'replace' || $tag == 'delete') {\n\t\t\t\t\t\t$lines = array_slice($a, $i1, ($i2 - $i1));\n\t\t\t\t\t\t$lines = $this->formatLines($lines);\n\t\t\t\t\t\t$lines = str_replace(array(\"\\0\", \"\\1\"), array('<del>', '<\/del>'), $lines);\n\t\t\t\t\t\t$blocks[$lastBlock]['base']['lines'] += $lines;\n\t\t\t\t\t}\n\n\t\t\t\t\tif($tag == 'replace' || $tag == 'insert') {\n\t\t\t\t\t\t$lines = array_slice($b, $j1, ($j2 - $j1));\n\t\t\t\t\t\t$lines =  $this->formatLines($lines);\n\t\t\t\t\t\t$lines = str_replace(array(\"\\0\", \"\\1\"), array('<ins>', '<\/ins>'), $lines);\n\t\t\t\t\t\t$blocks[$lastBlock]['changed']['lines'] += $lines;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t$changes[] = $blocks;\n\t\t}\n\t\treturn $changes;\n\t}\n\n\t\/**\n\t * Given two strings, determine where the changes in the two strings\n\t * begin, and where the changes in the two strings end.\n\t *\n\t * @param string $fromLine The first string.\n\t * @param string $toLine The second string.\n\t * @return array Array containing the starting position (0 by default) and the ending position (-1 by default)\n\t *\/\n\tprivate function getChangeExtent($fromLine, $toLine)\n\t{\n\t\t$start = 0;\n\t\t$limit = min(strlen($fromLine), strlen($toLine));\n\t\twhile($start < $limit && $fromLine[$start] == $toLine[$start]) {\n\t\t\t++$start;\n\t\t}\n\t\t$end = -1;\n\t\t$limit = $limit - $start;\n\t\twhile(-$end <= $limit && substr($fromLine, $end, 1) == substr($toLine, $end, 1)) {\n\t\t\t--$end;\n\t\t}\n\t\treturn array(\n\t\t\t$start,\n\t\t\t$end + 1\n\t\t);\n\t}\n\n\t\/**\n\t * Format a series of lines suitable for output in a HTML rendered diff.\n\t * This involves replacing tab characters with spaces, making the HTML safe\n\t * for output, ensuring that double spaces are replaced with &nbsp; etc.\n\t *\n\t * @param array $lines Array of lines to format.\n\t * @return array Array of the formatted lines.\n\t *\/\n\tprivate function formatLines($lines)\n\t{\n\t\t$lines = array_map(array($this, 'ExpandTabs'), $lines);\n\t\t$lines = array_map(array($this, 'HtmlSafe'), $lines);\n\t\tforeach($lines as &$line) {\n\t\t\t$line = preg_replace_callback('# ( +)|^ #', array($this, 'fixSpacesCallback'), $line);\n\t\t}\n\t\treturn $lines;\n\t}\n\n\t\/**\n\t * Using a callback here instead of the \/e modifier in preg_replace (now deprecated).\n\t *\n\t * @param $matches\n\t * @return string\n\t *\/\n\tprivate function fixSpacesCallback($matches)\n\t{\n\t\t$spaces = (isset($matches[1]) ? $matches[1] : '');\n\t\treturn $this->fixSpaces($spaces);\n\t}\n\n\t\/**\n\t * Replace a string containing spaces with a HTML representation using &nbsp;.\n\t *\n\t * @param string $spaces The string of spaces.\n\t * @return string The HTML representation of the string.\n\t *\/\n\tfunction fixSpaces($spaces='')\n\t{\n\t\t$count = strlen($spaces);\n\t\tif($count == 0) {\n\t\t\treturn '';\n\t\t}\n\n\t\t$div = floor($count \/ 2);\n\t\t$mod = $count % 2;\n\t\treturn str_repeat('&nbsp; ', $div).str_repeat('&nbsp;', $mod);\n\t}\n\n\t\/**\n\t * Replace tabs in a single line with a number of spaces as defined by the tabSize option.\n\t *\n\t * @param string $line The containing tabs to convert.\n\t * @return string The line with the tabs converted to spaces.\n\t *\/\n\tprivate function expandTabs($line)\n\t{\n\t\treturn str_replace(\"\\t\", str_repeat(' ', $this->options['tabSize']), $line);\n\t}\n\n\t\/**\n\t * Make a string containing HTML safe for output on a page.\n\t *\n\t * @param string $string The string.\n\t * @return string The string with the HTML characters replaced by entities.\n\t *\/\n\tprivate function htmlSafe($string)\n\t{\n\t\tif (!is_string($string)) { return ''; }\n\t\treturn htmlspecialchars($string, ENT_NOQUOTES, 'UTF-8');\n\t}\n}\n"},{"base":"plugins","rel":"wordfence\/lib\/Diff\/Renderer\/Html\/SideBySide.php","ext":"php","size":6064,"mtime":1757312769,"type":"text","content":"<?php\n\/**\n * Side by Side HTML diff generator for PHP DiffLib.\n *\n * PHP version 5\n *\n * Copyright (c) 2009 Chris Boulton <chris.boulton@interspire.com>\n * \n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without \n * modification, are permitted provided that the following conditions are met:\n *\n *  - Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *  - Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and\/or other materials provided with the distribution.\n *  - Neither the name of the Chris Boulton nor the names of its contributors \n *    may be used to endorse or promote products derived from this software \n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n * POSSIBILITY OF SUCH DAMAGE.\n *\n * @package DiffLib\n * @author Chris Boulton <chris.boulton@interspire.com>\n * @copyright (c) 2009 Chris Boulton\n * @license New BSD License http:\/\/www.opensource.org\/licenses\/bsd-license.php\n * @version 1.1\n * @link http:\/\/github.com\/chrisboulton\/php-diff\n *\/\n\nrequire_once(dirname(__FILE__) . '\/Array.php');\n\nclass Diff_Renderer_Html_SideBySide extends Diff_Renderer_Html_Array\n{\n\t\/**\n\t * Render a and return diff with changes between the two sequences\n\t * displayed side by side.\n\t *\n\t * @return string The generated side by side diff.\n\t *\/\n\tpublic function render()\n\t{\n\t\t$changes = parent::render();\n\n\t\t$html = '';\n\t\tif(empty($changes)) {\n\t\t\treturn $html;\n\t\t}\n\n\t\t$html .= '<table class=\"Differences DifferencesSideBySide\">';\n\t\t$html .= '<thead>';\n\t\t$html .= '<tr>';\n\t\t$html .= '<th colspan=\"2\" width=\"50%\">The Original Version of the file<\/th>';\n\t\t$html .= '<th colspan=\"2\" width=\"50%\">The Modified Version on your WordPress system<\/th>';\n\t\t$html .= '<\/tr>';\n\t\t$html .= '<\/thead>';\n\t\tforeach($changes as $i => $blocks) {\n\t\t\tif($i > 0) {\n\t\t\t\t$html .= '<tbody class=\"Skipped\">';\n\t\t\t\t$html .= '<th>&hellip;<\/th><td>&nbsp;<\/td>';\n\t\t\t\t$html .= '<th>&hellip;<\/th><td>&nbsp;<\/td>';\n\t\t\t\t$html .= '<\/tbody>';\n\t\t\t}\n\n\t\t\tforeach($blocks as $change) {\n\t\t\t\t$html .= '<tbody class=\"Change'.ucfirst($change['tag']).'\">';\n\t\t\t\t\/\/ Equal changes should be shown on both sides of the diff\n\t\t\t\tif($change['tag'] == 'equal') {\n\t\t\t\t\tforeach($change['base']['lines'] as $no => $line) {\n\t\t\t\t\t\t$fromLine = $change['base']['offset'] + $no + 1;\n\t\t\t\t\t\t$toLine = $change['changed']['offset'] + $no + 1;\n\t\t\t\t\t\t$html .= '<tr>';\n\t\t\t\t\t\t$html .= '<th>'.$fromLine.'<\/th>';\n\t\t\t\t\t\t$html .= '<td class=\"Left\"><span>'.$line.'<\/span>&nbsp;<\/span><\/td>';\n\t\t\t\t\t\t$html .= '<th>'.$toLine.'<\/th>';\n\t\t\t\t\t\t$html .= '<td class=\"Right\"><span>'.$line.'<\/span>&nbsp;<\/span><\/td>';\n\t\t\t\t\t\t$html .= '<\/tr>';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\/\/ Added lines only on the right side\n\t\t\t\telse if($change['tag'] == 'insert') {\n\t\t\t\t\tforeach($change['changed']['lines'] as $no => $line) {\n\t\t\t\t\t\t$toLine = $change['changed']['offset'] + $no + 1;\n\t\t\t\t\t\t$html .= '<tr>';\n\t\t\t\t\t\t$html .= '<th>&nbsp;<\/th>';\n\t\t\t\t\t\t$html .= '<td class=\"Left\">&nbsp;<\/td>';\n\t\t\t\t\t\t$html .= '<th>'.$toLine.'<\/th>';\n\t\t\t\t\t\t$html .= '<td class=\"Right\"><ins>'.$line.'<\/ins>&nbsp;<\/td>';\n\t\t\t\t\t\t$html .= '<\/tr>';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\/\/ Show deleted lines only on the left side\n\t\t\t\telse if($change['tag'] == 'delete') {\n\t\t\t\t\tforeach($change['base']['lines'] as $no => $line) {\n\t\t\t\t\t\t$fromLine = $change['base']['offset'] + $no + 1;\n\t\t\t\t\t\t$html .= '<tr>';\n\t\t\t\t\t\t$html .= '<th>'.$fromLine.'<\/th>';\n\t\t\t\t\t\t$html .= '<td class=\"Left\"><del>'.$line.'<\/del>&nbsp;<\/td>';\n\t\t\t\t\t\t$html .= '<th>&nbsp;<\/th>';\n\t\t\t\t\t\t$html .= '<td class=\"Right\">&nbsp;<\/td>';\n\t\t\t\t\t\t$html .= '<\/tr>';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\/\/ Show modified lines on both sides\n\t\t\t\telse if($change['tag'] == 'replace') {\n\t\t\t\t\tif(count($change['base']['lines']) >= count($change['changed']['lines'])) {\n\t\t\t\t\t\tforeach($change['base']['lines'] as $no => $line) {\n\t\t\t\t\t\t\t$fromLine = $change['base']['offset'] + $no + 1;\n\t\t\t\t\t\t\t$html .= '<tr>';\n\t\t\t\t\t\t\t$html .= '<th>'.$fromLine.'<\/th>';\n\t\t\t\t\t\t\t$html .= '<td class=\"Left\"><span>'.$line.'<\/span>&nbsp;<\/td>';\n\t\t\t\t\t\t\tif(!isset($change['changed']['lines'][$no])) {\n\t\t\t\t\t\t\t\t$toLine = '&nbsp;';\n\t\t\t\t\t\t\t\t$changedLine = '&nbsp;';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t$toLine = $change['base']['offset'] + $no + 1;\n\t\t\t\t\t\t\t\t$changedLine = '<span>'.$change['changed']['lines'][$no].'<\/span>';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$html .= '<th>'.$toLine.'<\/th>';\n\t\t\t\t\t\t\t$html .= '<td class=\"Right\">'.$changedLine.'<\/td>';\n\t\t\t\t\t\t\t$html .= '<\/tr>';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tforeach($change['changed']['lines'] as $no => $changedLine) {\n\t\t\t\t\t\t\tif(!isset($change['base']['lines'][$no])) {\n\t\t\t\t\t\t\t\t$fromLine = '&nbsp;';\n\t\t\t\t\t\t\t\t$line = '&nbsp;';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t$fromLine = $change['base']['offset'] + $no + 1;\n\t\t\t\t\t\t\t\t$line = '<span>'.$change['base']['lines'][$no].'<\/span>';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$html .= '<tr>';\n\t\t\t\t\t\t\t$html .= '<th>'.$fromLine.'<\/th>';\n\t\t\t\t\t\t\t$html .= '<td class=\"Left\"><span>'.$line.'<\/span>&nbsp;<\/td>';\n\t\t\t\t\t\t\t$toLine = $change['changed']['offset'] + $no + 1;\n\t\t\t\t\t\t\t$html .= '<th>'.$toLine.'<\/th>';\n\t\t\t\t\t\t\t$html .= '<td class=\"Right\">'.$changedLine.'<\/td>';\n\t\t\t\t\t\t\t$html .= '<\/tr>';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$html .= '<\/tbody>';\n\t\t\t}\n\t\t}\n\t\t$html .= '<\/table>';\n\t\treturn $html;\n\t}\n}\n"},{"base":"plugins","rel":"wordfence\/lib\/Diff\/Renderer\/Abstract.php","ext":"php","size":3050,"mtime":1757312769,"type":"text","content":"<?php\n\/**\n * Abstract class for diff renderers in PHP DiffLib.\n *\n * PHP version 5\n *\n * Copyright (c) 2009 Chris Boulton <chris.boulton@interspire.com>\n * \n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without \n * modification, are permitted provided that the following conditions are met:\n *\n *  - Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *  - Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and\/or other materials provided with the distribution.\n *  - Neither the name of the Chris Boulton nor the names of its contributors \n *    may be used to endorse or promote products derived from this software \n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n * POSSIBILITY OF SUCH DAMAGE.\n *\n * @package DiffLib\n * @author Chris Boulton <chris.boulton@interspire.com>\n * @copyright (c) 2009 Chris Boulton\n * @license New BSD License http:\/\/www.opensource.org\/licenses\/bsd-license.php\n * @version 1.1\n * @link http:\/\/github.com\/chrisboulton\/php-diff\n *\/\n\nabstract class Diff_Renderer_Abstract\n{\n\t\/**\n\t * @var object Instance of the diff class that this renderer is generating the rendered diff for.\n\t *\/\n\tpublic $diff;\n\n\t\/**\n\t * @var array Array of the default options that apply to this renderer.\n\t *\/\n\tprotected $defaultOptions = array();\n\n\t\/**\n\t * @var array Array containing the user applied and merged default options for the renderer.\n\t *\/\n\tprotected $options = array();\n\n\t\/**\n\t * The constructor. Instantiates the rendering engine and if options are passed,\n\t * sets the options for the renderer.\n\t *\n\t * @param array $options Optionally, an array of the options for the renderer.\n\t *\/\n\tpublic function __construct(array $options = array())\n\t{\n\t\t$this->setOptions($options);\n\t}\n\n\t\/**\n\t * Set the options of the renderer to those supplied in the passed in array.\n\t * Options are merged with the default to ensure that there aren't any missing\n\t * options.\n\t *\n\t * @param array $options Array of options to set.\n\t *\/\n\tpublic function setOptions(array $options)\n\t{\n\t\t$this->options = array_merge($this->defaultOptions, $options);\n\t}\n}"},{"base":"plugins","rel":"wordfence\/lib\/Diff\/SequenceMatcher.php","ext":"php","size":17872,"mtime":1757312769,"type":"text","content":"<?php\n\/**\n * Sequence matcher for Diff\n *\n * PHP version 5\n *\n * Copyright (c) 2009 Chris Boulton <chris.boulton@interspire.com>\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  - Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *  - Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and\/or other materials provided with the distribution.\n *  - Neither the name of the Chris Boulton nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n * @package Diff\n * @author Chris Boulton <chris.boulton@interspire.com>\n * @copyright (c) 2009 Chris Boulton\n * @license New BSD License http:\/\/www.opensource.org\/licenses\/bsd-license.php\n * @version 1.1\n * @link http:\/\/github.com\/chrisboulton\/php-diff\n *\/\n\nclass Diff_SequenceMatcher\n{\n\t\/**\n\t * @var string|array Either a string or an array containing a callback function to determine if a line is \"junk\" or not.\n\t *\/\n\tprivate $junkCallback = null;\n\n\t\/**\n\t * @var array The first sequence to compare against.\n\t *\/\n\tprivate $a = null;\n\n\t\/**\n\t * @var array The second sequence.\n\t *\/\n\tprivate $b = null;\n\n\t\/**\n\t * @var array Array of characters that are considered junk from the second sequence. Characters are the array key.\n\t *\/\n\tprivate $junkDict = array();\n\n\t\/**\n\t * @var array Array of indices that do not contain junk elements.\n\t *\/\n\tprivate $b2j = array();\n\n\tprivate $options = array();\n\n\tprivate $defaultOptions = array(\n\t\t'ignoreNewLines' => false,\n\t\t'ignoreWhitespace' => false,\n\t\t'ignoreCase' => false\n\t);\n\t\n\tprivate $matchingBlocks = null;\n\tprivate $opCodes = null;\n\tprivate $fullBCount = null;\n\n\t\/**\n\t * The constructor. With the sequences being passed, they'll be set for the\n\t * sequence matcher and it will perform a basic cleanup & calculate junk\n\t * elements.\n\t *\n\t * @param string|array $a A string or array containing the lines to compare against.\n\t * @param string|array $b A string or array containing the lines to compare.\n\t * @param string|array $junkCallback Either an array or string that references a callback function (if there is one) to determine 'junk' characters.\n\t *\/\n\tpublic function __construct($a, $b, $junkCallback=null, $options=array())\n\t{\n\t\t$this->a = null;\n\t\t$this->b = null;\n\t\t$this->junkCallback = $junkCallback;\n\t\t$this->setOptions($options);\n\t\t$this->setSequences($a, $b);\n\t}\n\n\tpublic function setOptions($options)\n\t{\n\t\t$this->options = array_merge($this->defaultOptions, $options);\n\t}\n\n\t\/**\n\t * Set the first and second sequences to use with the sequence matcher.\n\t *\n\t * @param string|array $a A string or array containing the lines to compare against.\n\t * @param string|array $b A string or array containing the lines to compare.\n\t *\/\n\tpublic function setSequences($a, $b)\n\t{\n\t\t$this->setSeq1($a);\n\t\t$this->setSeq2($b);\n\t}\n\n\t\/**\n\t * Set the first sequence ($a) and reset any internal caches to indicate that\n\t * when calling the calculation methods, we need to recalculate them.\n\t *\n\t * @param string|array $a The sequence to set as the first sequence.\n\t *\/\n\tpublic function setSeq1($a)\n\t{\n\t\tif(!is_array($a)) {\n\t\t\t$a = str_split($a);\n\t\t}\n\t\tif($a == $this->a) {\n\t\t\treturn;\n\t\t}\n\n\t\t$this->a= $a;\n\t\t$this->matchingBlocks = null;\n\t\t$this->opCodes = null;\n\t}\n\n\t\/**\n\t * Set the second sequence ($b) and reset any internal caches to indicate that\n\t * when calling the calculation methods, we need to recalculate them.\n\t *\n\t * @param string|array $b The sequence to set as the second sequence.\n\t *\/\n\tpublic function setSeq2($b)\n\t{\n\t\tif(!is_array($b)) {\n\t\t\t$b = str_split($b);\n\t\t}\n\t\tif($b == $this->b) {\n\t\t\treturn;\n\t\t}\n\n\t\t$this->b = $b;\n\t\t$this->matchingBlocks = null;\n\t\t$this->opCodes = null;\n\t\t$this->fullBCount = null;\n\t\t$this->chainB();\n\t}\n\n\t\/**\n\t * Generate the internal arrays containing the list of junk and non-junk\n\t * characters for the second ($b) sequence.\n\t *\/\n\tprivate function chainB()\n\t{\n\t\t$length = count ($this->b);\n\t\t$this->b2j = array();\n\t\t$popularDict = array();\n\n\t\tfor($i = 0; $i < $length; ++$i) {\n\t\t\t$char = $this->b[$i];\n\t\t\tif(isset($this->b2j[$char])) {\n\t\t\t\tif($length >= 200 && count($this->b2j[$char]) * 100 > $length) {\n\t\t\t\t\t$popularDict[$char] = 1;\n\t\t\t\t\tunset($this->b2j[$char]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$this->b2j[$char][] = $i;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$this->b2j[$char] = array(\n\t\t\t\t\t$i\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t\/\/ Remove leftovers\n\t\tforeach(array_keys($popularDict) as $char) {\n\t\t\tunset($this->b2j[$char]);\n\t\t}\n\n\t\t$this->junkDict = array();\n\t\tif(is_callable($this->junkCallback)) {\n\t\t\tforeach(array_keys($popularDict) as $char) {\n\t\t\t\tif(call_user_func($this->junkCallback, $char)) {\n\t\t\t\t\t$this->junkDict[$char] = 1;\n\t\t\t\t\tunset($popularDict[$char]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tforeach(array_keys($this->b2j) as $char) {\n\t\t\t\tif(call_user_func($this->junkCallback, $char)) {\n\t\t\t\t\t$this->junkDict[$char] = 1;\n\t\t\t\t\tunset($this->b2j[$char]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t\/**\n\t * Checks if a particular character is in the junk dictionary\n\t * for the list of junk characters.\n\t *\n\t * @return boolean $b True if the character is considered junk. False if not.\n\t *\/\n\tprivate function isBJunk($b)\n\t{\n\t\tif(isset($this->juncDict[$b])) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t\/**\n\t * Find the longest matching block in the two sequences, as defined by the\n\t * lower and upper constraints for each sequence. (for the first sequence,\n\t * $alo - $ahi and for the second sequence, $blo - $bhi)\n\t *\n\t * Essentially, of all of the maximal matching blocks, return the one that\n\t * startest earliest in $a, and all of those maximal matching blocks that\n\t * start earliest in $a, return the one that starts earliest in $b.\n\t *\n\t * If the junk callback is defined, do the above but with the restriction\n\t * that the junk element appears in the block. Extend it as far as possible\n\t * by matching only junk elements in both $a and $b.\n\t *\n\t * @param int $alo The lower constraint for the first sequence.\n\t * @param int $ahi The upper constraint for the first sequence.\n\t * @param int $blo The lower constraint for the second sequence.\n\t * @param int $bhi The upper constraint for the second sequence.\n\t * @return array Array containing the longest match that includes the starting position in $a, start in $b and the length\/size.\n\t *\/\n\tpublic function findLongestMatch($alo, $ahi, $blo, $bhi)\n\t{\n\t\t$a = $this->a;\n\t\t$b = $this->b;\n\n\t\t$bestI = $alo;\n\t\t$bestJ = $blo;\n\t\t$bestSize = 0;\n\n\t\t$j2Len = array();\n\t\t$nothing = array();\n\n\t\tfor($i = $alo; $i < $ahi; ++$i) {\n\t\t\t$newJ2Len = array();\n\t\t\t$jDict = $this->arrayGetDefault($this->b2j, $a[$i], $nothing);\n\t\t\tforeach($jDict as $jKey => $j) {\n\t\t\t\tif($j < $blo) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if($j >= $bhi) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t$k = $this->arrayGetDefault($j2Len, $j -1, 0) + 1;\n\t\t\t\t$newJ2Len[$j] = $k;\n\t\t\t\tif($k > $bestSize) {\n\t\t\t\t\t$bestI = $i - $k + 1;\n\t\t\t\t\t$bestJ = $j - $k + 1;\n\t\t\t\t\t$bestSize = $k;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$j2Len = $newJ2Len;\n\t\t}\n\n\t\twhile($bestI > $alo && $bestJ > $blo && !$this->isBJunk($b[$bestJ - 1]) &&\n\t\t\t!$this->linesAreDifferent($bestI - 1, $bestJ - 1)) {\n\t\t\t\t--$bestI;\n\t\t\t\t--$bestJ;\n\t\t\t\t++$bestSize;\n\t\t}\n\n\t\twhile($bestI + $bestSize < $ahi && ($bestJ + $bestSize) < $bhi &&\n\t\t\t!$this->isBJunk($b[$bestJ + $bestSize]) && !$this->linesAreDifferent($bestI + $bestSize, $bestJ + $bestSize)) {\n\t\t\t\t++$bestSize;\n\t\t}\n\n\t\twhile($bestI > $alo && $bestJ > $blo && $this->isBJunk($b[$bestJ - 1]) &&\n\t\t\t!$this->isLineDifferent($bestI - 1, $bestJ - 1)) {\n\t\t\t\t--$bestI;\n\t\t\t\t--$bestJ;\n\t\t\t\t++$bestSize;\n\t\t}\n\n\t\twhile($bestI + $bestSize < $ahi && $bestJ + $bestSize < $bhi &&\n\t\t\t$this->isBJunk($b[$bestJ + $bestSize]) && !$this->linesAreDifferent($bestI + $bestSize, $bestJ + $bestSize)) {\n\t\t\t\t\t++$bestSize;\n\t\t}\n\n\t\treturn array(\n\t\t\t$bestI,\n\t\t\t$bestJ,\n\t\t\t$bestSize\n\t\t);\n\t}\n\n\t\/**\n\t * Check if the two lines at the given indexes are different or not.\n\t *\n\t * @param int $aIndex Line number to check against in a.\n\t * @param int $bIndex Line number to check against in b.\n\t * @return boolean True if the lines are different and false if not.\n\t *\/\n\tpublic function linesAreDifferent($aIndex, $bIndex)\n\t{\n\t\t$lineA = $this->a[$aIndex];\n\t\t$lineB = $this->b[$bIndex];\n\n\t\tif($this->options['ignoreWhitespace']) {\n\t\t\t$replace = array(\"\\t\", ' ');\n\t\t\t$lineA = str_replace($replace, '', $lineA);\n\t\t\t$lineB = str_replace($replace, '', $lineB);\n\t\t}\n\n\t\tif($this->options['ignoreCase']) {\n\t\t\t$lineA = strtolower($lineA);\n\t\t\t$lineB = strtolower($lineB);\n\t\t}\n\n\t\tif($lineA != $lineB) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t\/**\n\t * Return a nested set of arrays for all of the matching sub-sequences\n\t * in the strings $a and $b.\n\t *\n\t * Each block contains the lower constraint of the block in $a, the lower\n\t * constraint of the block in $b and finally the number of lines that the\n\t * block continues for.\n\t *\n\t * @return array Nested array of the matching blocks, as described by the function.\n\t *\/\n\tpublic function getMatchingBlocks()\n\t{\n\t\tif(!empty($this->matchingBlocks)) {\n\t\t\treturn $this->matchingBlocks;\n\t\t}\n\n\t\t$aLength = count($this->a);\n\t\t$bLength = count($this->b);\n\n\t\t$queue = array(\n\t\t\tarray(\n\t\t\t\t0,\n\t\t\t\t$aLength,\n\t\t\t\t0,\n\t\t\t\t$bLength\n\t\t\t)\n\t\t);\n\n\t\t$matchingBlocks = array();\n\t\twhile(!empty($queue)) {\n\t\t\tlist($alo, $ahi, $blo, $bhi) = array_pop($queue);\n\t\t\t$x = $this->findLongestMatch($alo, $ahi, $blo, $bhi);\n\t\t\tlist($i, $j, $k) = $x;\n\t\t\tif($k) {\n\t\t\t\t$matchingBlocks[] = $x;\n\t\t\t\tif($alo < $i && $blo < $j) {\n\t\t\t\t\t$queue[] = array(\n\t\t\t\t\t\t$alo,\n\t\t\t\t\t\t$i,\n\t\t\t\t\t\t$blo,\n\t\t\t\t\t\t$j\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif($i + $k < $ahi && $j + $k < $bhi) {\n\t\t\t\t\t$queue[] = array(\n\t\t\t\t\t\t$i + $k,\n\t\t\t\t\t\t$ahi,\n\t\t\t\t\t\t$j + $k,\n\t\t\t\t\t\t$bhi\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tusort($matchingBlocks, array($this, 'tupleSort'));\n\n\t\t$i1 = 0;\n\t\t$j1 = 0;\n\t\t$k1 = 0;\n\t\t$nonAdjacent = array();\n\t\tforeach($matchingBlocks as $block) {\n\t\t\tlist($i2, $j2, $k2) = $block;\n\t\t\tif($i1 + $k1 == $i2 && $j1 + $k1 == $j2) {\n\t\t\t\t$k1 += $k2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif($k1) {\n\t\t\t\t\t$nonAdjacent[] = array(\n\t\t\t\t\t\t$i1,\n\t\t\t\t\t\t$j1,\n\t\t\t\t\t\t$k1\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t$i1 = $i2;\n\t\t\t\t$j1 = $j2;\n\t\t\t\t$k1 = $k2;\n\t\t\t}\n\t\t}\n\n\t\tif($k1) {\n\t\t\t$nonAdjacent[] = array(\n\t\t\t\t$i1,\n\t\t\t\t$j1,\n\t\t\t\t$k1\n\t\t\t);\n\t\t}\n\n\t\t$nonAdjacent[] = array(\n\t\t\t$aLength,\n\t\t\t$bLength,\n\t\t\t0\n\t\t);\n\n\t\t$this->matchingBlocks = $nonAdjacent;\n\t\treturn $this->matchingBlocks;\n\t}\n\n\t\/**\n\t * Return a list of all of the opcodes for the differences between the\n\t * two strings.\n\t *\n\t * The nested array returned contains an array describing the opcode\n\t * which includes:\n\t * 0 - The type of tag (as described below) for the opcode.\n\t * 1 - The beginning line in the first sequence.\n\t * 2 - The end line in the first sequence.\n\t * 3 - The beginning line in the second sequence.\n\t * 4 - The end line in the second sequence.\n\t *\n\t * The different types of tags include:\n\t * replace - The string from $i1 to $i2 in $a should be replaced by\n\t *           the string in $b from $j1 to $j2.\n\t * delete -  The string in $a from $i1 to $j2 should be deleted.\n\t * insert -  The string in $b from $j1 to $j2 should be inserted at\n\t *           $i1 in $a.\n\t * equal  -  The two strings with the specified ranges are equal.\n\t *\n\t * @return array Array of the opcodes describing the differences between the strings.\n\t *\/\n\tpublic function getOpCodes()\n\t{\n\t\tif(!empty($this->opCodes)) {\n\t\t\treturn $this->opCodes;\n\t\t}\n\n\t\t$i = 0;\n\t\t$j = 0;\n\t\t$this->opCodes = array();\n\n\t\t$blocks = $this->getMatchingBlocks();\n\t\tforeach($blocks as $block) {\n\t\t\tlist($ai, $bj, $size) = $block;\n\t\t\t$tag = '';\n\t\t\tif($i < $ai && $j < $bj) {\n\t\t\t\t$tag = 'replace';\n\t\t\t}\n\t\t\telse if($i < $ai) {\n\t\t\t\t$tag = 'delete';\n\t\t\t}\n\t\t\telse if($j < $bj) {\n\t\t\t\t$tag = 'insert';\n\t\t\t}\n\n\t\t\tif($tag) {\n\t\t\t\t$this->opCodes[] = array(\n\t\t\t\t\t$tag,\n\t\t\t\t\t$i,\n\t\t\t\t\t$ai,\n\t\t\t\t\t$j,\n\t\t\t\t\t$bj\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t$i = $ai + $size;\n\t\t\t$j = $bj + $size;\n\n\t\t\tif($size) {\n\t\t\t\t$this->opCodes[] = array(\n\t\t\t\t\t'equal',\n\t\t\t\t\t$ai,\n\t\t\t\t\t$i,\n\t\t\t\t\t$bj,\n\t\t\t\t\t$j\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn $this->opCodes;\n\t}\n\n\t\/**\n\t * Return a series of nested arrays containing different groups of generated\n\t * opcodes for the differences between the strings with up to $context lines\n\t * of surrounding content.\n\t *\n\t * Essentially what happens here is any big equal blocks of strings are stripped\n\t * out, the smaller subsets of changes are then arranged in to their groups.\n\t * This means that the sequence matcher and diffs do not need to include the full\n\t * content of the different files but can still provide context as to where the\n\t * changes are.\n\t *\n\t * @param int $context The number of lines of context to provide around the groups.\n\t * @return array Nested array of all of the grouped opcodes.\n\t *\/\n\tpublic function getGroupedOpcodes($context=3)\n\t{\n\t\t$opCodes = $this->getOpCodes();\n\t\tif(empty($opCodes)) {\n\t\t\t$opCodes = array(\n\t\t\t\tarray(\n\t\t\t\t\t'equal',\n\t\t\t\t\t0,\n\t\t\t\t\t1,\n\t\t\t\t\t0,\n\t\t\t\t\t1\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tif($opCodes[0][0] == 'equal') {\n\t\t\t$opCodes[0] = array(\n\t\t\t\t$opCodes[0][0],\n\t\t\t\tmax($opCodes[0][1], $opCodes[0][2] - $context),\n\t\t\t\t$opCodes[0][2],\n\t\t\t\tmax($opCodes[0][3], $opCodes[0][4] - $context),\n\t\t\t\t$opCodes[0][4]\n\t\t\t);\n\t\t}\n\n\t\t$lastItem = count($opCodes) - 1;\n\t\tif($opCodes[$lastItem][0] == 'equal') {\n\t\t\tlist($tag, $i1, $i2, $j1, $j2) = $opCodes[$lastItem];\n\t\t\t$opCodes[$lastItem] = array(\n\t\t\t\t$tag,\n\t\t\t\t$i1,\n\t\t\t\tmin($i2, $i1 + $context),\n\t\t\t\t$j1,\n\t\t\t\tmin($j2, $j1 + $context)\n\t\t\t);\n\t\t}\n\n\t\t$maxRange = $context * 2;\n\t\t$groups = array();\n\t\t$group = array();\n\t\tforeach($opCodes as $code) {\n\t\t\tlist($tag, $i1, $i2, $j1, $j2) = $code;\n\t\t\tif($tag == 'equal' && $i2 - $i1 > $maxRange) {\n\t\t\t\t$group[] = array(\n\t\t\t\t\t$tag,\n\t\t\t\t\t$i1,\n\t\t\t\t\tmin($i2, $i1 + $context),\n\t\t\t\t\t$j1,\n\t\t\t\t\tmin($j2, $j1 + $context)\n\t\t\t\t);\n\t\t\t\t$groups[] = $group;\n\t\t\t\t$group = array();\n\t\t\t\t$i1 = max($i1, $i2 - $context);\n\t\t\t\t$j1 = max($j1, $j2 - $context);\n\t\t\t}\n\t\t\t$group[] = array(\n\t\t\t\t$tag,\n\t\t\t\t$i1,\n\t\t\t\t$i2,\n\t\t\t\t$j1,\n\t\t\t\t$j2\n\t\t\t);\n\t\t}\n\n\t\tif(!empty($group) && !(count($group) == 1 && $group[0][0] == 'equal')) {\n\t\t\t$groups[] = $group;\n\t\t}\n\n\t\treturn $groups;\n\t}\n\n\t\/**\n\t * Return a measure of the similarity between the two sequences.\n\t * This will be a float value between 0 and 1.\n\t *\n\t * Out of all of the ratio calculation functions, this is the most\n\t * expensive to call if getMatchingBlocks or getOpCodes is yet to be\n\t * called. The other calculation methods (quickRatio and realquickRatio)\n\t * can be used to perform quicker calculations but may be less accurate.\n\t *\n\t * The ratio is calculated as (2 * number of matches) \/ total number of\n\t * elements in both sequences.\n\t *\n\t * @return float The calculated ratio.\n\t *\/\n\tpublic function Ratio()\n\t{\n\t\t$matches = array_reduce($this->getMatchingBlocks(), array($this, 'ratioReduce'), 0);\n\t\treturn $this->calculateRatio($matches, count ($this->a) + count ($this->b));\n\t}\n\n\t\/**\n\t * Helper function to calculate the number of matches for Ratio().\n\t *\n\t * @param int $sum The running total for the number of matches.\n\t * @param array $triple Array containing the matching block triple to add to the running total.\n\t * @return int The new running total for the number of matches.\n\t *\/\n\tprivate function ratioReduce($sum, $triple)\n\t{\n\t\treturn $sum + ($triple[count($triple) - 1]);\n\t}\n\n\n\t\/**\n\t * Helper function for calculating the ratio to measure similarity for the strings.\n\t * The ratio is defined as being 2 * (number of matches \/ total length)\n\t *\n\t * @param int $matches The number of matches in the two strings.\n\t * @param int $length The length of the two strings.\n\t * @return float The calculated ratio.\n\t *\/\n\tprivate function calculateRatio($matches, $length=0)\n\t{\n\t\tif($length) {\n\t\t\treturn 2 * ($matches \/ $length);\n\t\t}\n\t\telse {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t\/**\n\t * Helper function that provides the ability to return the value for a key\n\t * in an array of it exists, or if it doesn't then return a default value.\n\t * Essentially cleaner than doing a series of if(isset()) {} else {} calls.\n\t *\n\t * @param array $array The array to search.\n\t * @param string $key The key to check that exists.\n\t * @param mixed $default The value to return as the default value if the key doesn't exist.\n\t * @return mixed The value from the array if the key exists or otherwise the default.\n\t *\/\n\tprivate function arrayGetDefault($array, $key, $default)\n\t{\n\t\tif(isset($array[$key])) {\n\t\t\treturn $array[$key];\n\t\t}\n\t\telse {\n\t\t\treturn $default;\n\t\t}\n\t}\n\n\t\/**\n\t * Sort an array by the nested arrays it contains. Helper function for getMatchingBlocks\n\t *\n\t * @param array $a First array to compare.\n\t * @param array $b Second array to compare.\n\t * @return int -1, 0 or 1, as expected by the usort function.\n\t *\/\n\tprivate function tupleSort($a, $b)\n\t{\n\t\t$max = max(count($a), count($b));\n\t\tfor($i = 0; $i < $max; ++$i) {\n\t\t\tif($a[$i] < $b[$i]) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse if($a[$i] > $b[$i]) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tif(count($a) == count($b)) {\n\t\t\treturn 0;\n\t\t}\n\t\telse if(count($a) < count($b)) {\n\t\t\treturn -1;\n\t\t}\n\t\telse {\n\t\t\treturn 1;\n\t\t}\n\t}\n}\n"},{"base":"plugins","rel":"wordfence\/lib\/wfUtils.php","ext":"php","size":127523,"mtime":1757312769,"type":"text","content":"<?php\nrequire_once(dirname(__FILE__) . '\/wfConfig.php');\nclass wfUtils {\n\tconst DEFAULT_MAX_SERIALIZED_INPUT_LENGTH = 65536;\n\tconst DEFAULT_MAX_SERIALIZED_ARRAY_LENGTH = 1024;\n\tconst DEFAULT_MAX_SERIALIZED_ARRAY_DEPTH = 5;\n\t\n\t\/\/Flags for wfUtils::parse_version\n\tconst VERSION_MAJOR = 'major';\n\tconst VERSION_MINOR = 'minor';\n\tconst VERSION_PATCH = 'patch';\n\tconst VERSION_PRE_RELEASE = 'pre-release';\n\tconst VERSION_BUILD = 'build';\n\t\n\t\/\/Flags for array_diff_assoc\n\tconst ARRAY_DIFF_ORDERED_ARRAYS = 1; \/\/When specified, non-associative arrays are treated as if the ordering matters. The default is to ignore the ordering and only care about the content\n\t\n\tprivate static $isWindows = false;\n\tpublic static $scanLockFH = false;\n\tprivate static $lastErrorReporting = false;\n\tprivate static $lastDisplayErrors = false;\n\tpublic static function patternToRegex($pattern, $mod = 'i', $sep = '\/') {\n\t\t$pattern = preg_quote(trim($pattern), $sep);\n\t\t$pattern = str_replace(' ', '\\s', $pattern);\n\t\treturn $sep . '^' . str_replace('\\*', '.*', $pattern) . '$' . $sep . $mod;\n\t}\n\tpublic static function versionedAsset($subpath) {\n\t\t$version = WORDFENCE_BUILD_NUMBER;\n\t\tif ($version != 'WORDFENCE_BUILD_NUMBER' && preg_match('\/^(.+?)(\\.[^\\.]+)$\/', $subpath, $matches)) {\n\t\t\t$prefix = $matches[1];\n\t\t\t$suffix = $matches[2];\n\t\t\treturn $prefix . '.' . $version . $suffix;\n\t\t}\n\t\t\n\t\treturn $subpath;\n\t}\n\tpublic static function makeTimeAgo($secs, $noSeconds = false) {\n\t\tif($secs < 1){\n\t\t\treturn __(\"a moment\", 'wordfence');\n\t\t}\n\t\t\n\t\tif (function_exists('date_diff')) {\n\t\t\t$now = new DateTime();\n\t\t\t$utc = new DateTimeZone('UTC');\n\t\t\t$dtStr = gmdate(\"c\", (int) ($now->getTimestamp() + $secs)); \/\/Have to do it this way because of PHP 5.2\n\t\t\t$then = new DateTime($dtStr, $utc);\n\t\t\t\n\t\t\t$diff = $then->diff($now);\n\t\t\t$years = $diff->y;\n\t\t\t$months = $diff->m;\n\t\t\t$days = $diff->d;\n\t\t\t$hours = $diff->h;\n\t\t\t$minutes = $diff->i;\n\t\t}\n\t\telse {\n\t\t\t$years = 0;\n\t\t\t$months = floor($secs \/ (86400 * 30));\n\t\t\t$days = floor($secs \/ 86400);\n\t\t\t$hours = floor($secs \/ 3600);\n\t\t\t$minutes = floor($secs \/ 60);\n\t\t\t\n\t\t\tif ($months) {\n\t\t\t\t$days -= $months * 30;\n\t\t\t}\n\t\t\telse if ($days) {\n\t\t\t\t$hours -= $days * 24;\n\t\t\t}\n\t\t\telse if ($hours) {\n\t\t\t\t$minutes -= $hours * 60;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif ($years) {\n\t\t\treturn $years . ' ' . _n('year', 'years', $years, 'wordfence') .\n\t\t\t\t(is_numeric($months) ? ' ' . $months . ' ' . _n('month', 'months', $months, 'wordfence') : '');\n\t\t}\n\t\telse if ($months) {\n\t\t\treturn $months . ' ' . _n('month', 'months', $months, 'wordfence') .\n\t\t\t\t(is_numeric($days) ? ' ' . $days . ' ' . _n('day', 'days', $days, 'wordfence') : '');\n\t\t}\n\t\telse if ($days) {\n\t\t\treturn $days . ' ' . _n('day', 'days', $days, 'wordfence') .\n\t\t\t\t(is_numeric($hours) ? ' ' . $hours . ' ' . _n('hour', 'hours', $hours, 'wordfence') : '');\n\t\t}\n\t\telse if ($hours) {\n\t\t\treturn $hours . ' ' . _n('hour', 'hours', $hours, 'wordfence') .\n\t\t\t\t(is_numeric($minutes) ? ' ' . $minutes . ' ' . _n('minute', 'minutes', $minutes, 'wordfence') : '');\n\t\t}\n\t\telse if ($minutes) {\n\t\t\treturn $minutes . ' ' . _n('minute', 'minutes', $minutes, 'wordfence');\n\t\t}\n\t\telse {\n\t\t\tif($noSeconds){\n\t\t\t\treturn __(\"less than a minute\", 'wordfence');\n\t\t\t} else {\n\t\t\t\treturn sprintf(\/* translators: Number of seconds. *\/ __(\"%d seconds\", 'wordfence'), floor($secs));\n\t\t\t}\n\t\t}\n\t}\n\tpublic static function makeDuration($secs, $createExact = false) {\n\t\t$components = array();\n\t\t\n\t\t$months = floor($secs \/ (86400 * 30)); $secs -= $months * 86400 * 30;\n\t\t$days = floor($secs \/ 86400); $secs -= $days * 86400;\n\t\t$hours = floor($secs \/ 3600); $secs -= $hours * 3600;\n\t\t$minutes = floor($secs \/ 60); $secs -= $minutes * 60;\n\t\t\n\t\tif ($months) {\n\t\t\t$components[] = $months . ' ' . _n('month', 'months', $months, 'wordfence');\n\t\t\tif (!$createExact) {\n\t\t\t\t$hours = $minutes = $secs = 0;\n\t\t\t}\n\t\t}\n\t\tif ($days) {\n\t\t\t$components[] = $days . ' ' . _n('day', 'days', $days, 'wordfence');\n\t\t\tif (!$createExact) {\n\t\t\t\t$minutes = $secs = 0;\n\t\t\t}\n\t\t}\n\t\tif ($hours) {\n\t\t\t$components[] = $hours . ' ' . _n('hour', 'hours', $hours, 'wordfence');\n\t\t\tif (!$createExact) {\n\t\t\t\t$secs = 0;\n\t\t\t}\n\t\t}\n\t\tif ($minutes) {\n\t\t\t$components[] = $minutes . ' ' . _n('minute', 'minutes', $minutes, 'wordfence');\n\t\t}\n\t\tif ($secs && $secs >= 1) {\n\t\t\t$components[] = $secs . ' ' . _n('second', 'seconds', $secs, 'wordfence');\n\t\t}\n\t\t\n\t\tif (empty($components)) {\n\t\t\t$components[] = __('less than 1 second', 'wordfence');\n\t\t}\n\t\t\n\t\treturn implode(' ', $components);\n\t}\n\tpublic static function pluralize($m1, $m1Singular, $m1Plural, $m2 = false, $m2Singular = false, $m2Plural = false) {\n\t\t$m1Text = _n($m1Singular, $m1Plural, $m1, 'wordfence');\n\t\tif (is_numeric($m2)) {\n\t\t\t$m2Text = _n($m2Singular, $m2Plural, $m2, 'wordfence');\n\t\t\treturn \"$m1 $m1Text $m2 $m2Text\";\n\t\t} else {\n\t\t\treturn \"$m1 $m1Text\";\n\t\t}\n\t}\n\tpublic static function formatBytes($bytes, $precision = 2) {\n\t\t$units = array('B', 'KB', 'MB', 'GB', 'TB');\n\n\t\t$bytes = max($bytes, 0);\n\t\t$pow = floor(($bytes ? log($bytes) : 0) \/ log(1024));\n\t\t$pow = min($pow, count($units) - 1);\n\n\t\t\/\/ Uncomment one of the following alternatives\n\t\t$bytes \/= pow(1024, $pow);\n\t\t\/\/ $bytes \/= (1 << (10 * $pow)); \n\n\t\treturn round($bytes, $precision) . ' ' . $units[$pow];\n\t}\n\t\n\t\/**\n\t * Returns the PHP version formatted for display, stripping off the build information when present.\n\t * \n\t * @return string\n\t *\/\n\tpublic static function cleanPHPVersion() {\n\t\t$version = phpversion();\n\t\tif (preg_match('\/^(\\d+\\.\\d+\\.\\d+)\/', $version, $matches)) {\n\t\t\treturn $matches[1];\n\t\t}\n\t\treturn $version;\n\t}\n\t\n\t\/**\n\t * Safe unserialize() replacement\n\t * - accepts a strict subset of PHP's native serialized representation\n\t * - does not unserialize objects\n\t *\n\t * @param string $str\n\t * @return mixed\n\t *\/\n\tpublic static function _safe_unserialize($str, $limit_input_length = self::DEFAULT_MAX_SERIALIZED_INPUT_LENGTH, $limit_array_length = self::DEFAULT_MAX_SERIALIZED_ARRAY_LENGTH, $limit_array_depth = self::DEFAULT_MAX_SERIALIZED_ARRAY_DEPTH) {\n\t\tif (empty($str) || !is_string($str)) { return false; }\n\t\tif (strlen($str) > $limit_input_length) { return false; }\n\t\tif (!is_serialized($str)) { return false; }\n\t\t\n\t\t$stack = array();\n\t\t$expected = array();\n\t\t\n\t\t\/*\n\t\t * states:\n\t\t *   0 - initial state, expecting a single value or array\n\t\t *   1 - terminal state\n\t\t *   2 - in array, expecting end of array or a key\n\t\t *   3 - in array, expecting value or another array\n\t\t *\/\n\t\t$state = 0;\n\t\twhile ($state != 1) {\n\t\t\t$type = isset($str[0]) ? $str[0] : '';\n\t\t\tif ($type == '}') {\n\t\t\t\t$str = substr($str, 1);\n\t\t\t} else if ($type == 'N' && $str[1] == ';') {\n\t\t\t\t$value = null;\n\t\t\t\t$str = substr($str, 2);\n\t\t\t} else if ($type == 'b' && preg_match('\/^b:([01]);\/', $str, $matches)) {\n\t\t\t\t$value = $matches[1] == '1' ? true : false;\n\t\t\t\t$str = substr($str, 4);\n\t\t\t} else if ($type == 'i' && preg_match('\/^i:(-?[0-9]+);(.*)\/s', $str, $matches)) {\n\t\t\t\t$value = (int) $matches[1];\n\t\t\t\t$str = $matches[2];\n\t\t\t} else if ($type == 'd' && preg_match('\/^d:(-?[0-9]+\\.?[0-9]*(E[+-][0-9]+)?);(.*)\/s', $str, $matches)) {\n\t\t\t\t$value = (float) $matches[1];\n\t\t\t\t$str = $matches[3];\n\t\t\t} else if ($type == 's' && preg_match('\/^s:([0-9]+):\"(.*)\/s', $str, $matches) && substr($matches[2], (int) $matches[1], 2) == '\";') {\n\t\t\t\t$value = substr($matches[2], 0, (int) $matches[1]);\n\t\t\t\t$str = substr($matches[2], (int) $matches[1] + 2);\n\t\t\t} else if ($type == 'a' && preg_match('\/^a:([0-9]+):{(.*)\/s', $str, $matches) && $matches[1] < $limit_array_length) {\n\t\t\t\t$expectedLength = (int) $matches[1];\n\t\t\t\t$str = $matches[2];\n\t\t\t} else {\n\t\t\t\t\/\/ object or unknown\/malformed type\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tswitch ($state) {\n\t\t\t\tcase 3: \/\/ in array, expecting value or another array\n\t\t\t\t\tif ($type == 'a') {\n\t\t\t\t\t\tif (count($stack) >= $limit_array_depth) { return false; }\n\t\t\t\t\t\t\n\t\t\t\t\t\t$stack[] = &$list;\n\t\t\t\t\t\t$list[$key] = array(); \/\/$key is set in state 2\n\t\t\t\t\t\t$list = &$list[$key];\n\t\t\t\t\t\t$expected[] = $expectedLength;\n\t\t\t\t\t\t$state = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ($type != '}') {\n\t\t\t\t\t\t$list[$key] = $value;\n\t\t\t\t\t\t$state = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\/\/ missing array value\n\t\t\t\t\treturn false;\n\t\t\t\t\n\t\t\t\tcase 2: \/\/ in array, expecting end of array or a key\n\t\t\t\t\tif ($type == '}') {\n\t\t\t\t\t\tif (count($list) < end($expected)) {\n\t\t\t\t\t\t\t\/\/ array size less than expected\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tunset($list);\n\t\t\t\t\t\t$list = &$stack[count($stack) - 1];\n\t\t\t\t\t\tarray_pop($stack);\n\t\t\t\t\t\t\n\t\t\t\t\t\t\/\/ go to terminal state if we're at the end of the root array\n\t\t\t\t\t\tarray_pop($expected);\n\t\t\t\t\t\tif (count($expected) == 0) {\n\t\t\t\t\t\t\t$state = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ($type == 'i' || $type == 's') {\n\t\t\t\t\t\tif (count($list) >= $limit_array_length) { return false; }\n\t\t\t\t\t\tif (count($list) >= end($expected)) { return false; }\n\t\t\t\t\t\t\n\t\t\t\t\t\t$key = $value;\n\t\t\t\t\t\t$state = 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\/\/ illegal array index type\n\t\t\t\t\treturn false;\n\t\t\t\t\n\t\t\t\tcase 0: \/\/ expecting array or value\n\t\t\t\t\tif ($type == 'a') {\n\t\t\t\t\t\tif (count($stack) >= $limit_array_depth) { return false; }\n\t\t\t\t\t\t\n\t\t\t\t\t\t$data = array();\n\t\t\t\t\t\t$list = &$data;\n\t\t\t\t\t\t$expected[] = $expectedLength;\n\t\t\t\t\t\t$state = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ($type != '}') {\n\t\t\t\t\t\t$data = $value;\n\t\t\t\t\t\t$state = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\/\/ not in array\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!empty($str)) { return false; } \/\/ trailing data in input\n\t\treturn $data;\n\t}\n\t\n\t\/**\n\t * Wrapper for _safe_unserialize() that handles multibyte encoding issues\n\t *\n\t * @param string $str\n\t * @return mixed\n\t *\/\n\tpublic static function safe_unserialize($str) {\n\t\t\/\/ ensure we use the byte count for strings even when strlen() is overloaded by mb_strlen()\n\t\tif (function_exists('mb_internal_encoding') && (((int) ini_get('mbstring.func_overload')) & 2)) { \/\/ phpcs:ignore PHPCompatibility.IniDirectives.RemovedIniDirectives.mbstring_func_overloadDeprecated\n\t\t\t$mbIntEnc = mb_internal_encoding();\n\t\t\tmb_internal_encoding('ASCII');\n\t\t}\n\t\t\n\t\t$out = self::_safe_unserialize($str);\n\t\t\n\t\tif (isset($mbIntEnc)) {\n\t\t\tmb_internal_encoding($mbIntEnc);\n\t\t}\n\t\treturn $out;\n\t}\n\t\n\t\/**\n\t * If $value is not null, this returns $value unchanged. Otherwise it returns one of two values:\n\t * 1. If $orCallable is a valid callable, it returns the result\n\t * 2. Otherwise it returns $default \n\t * \n\t * @param mixed $value\n\t * @param mixed $default\n\t * @param callable|null $orCallable\n\t * @return mixed\n\t *\/\n\tpublic static function ifnull($value, $default = '', $orCallable = null) {\n\t\tif (is_null($value)) {\n\t\t\tif (is_callable($orCallable)) {\n\t\t\t\treturn $orCallable();\n\t\t\t}\n\t\t\treturn $default;\n\t\t}\n\t\treturn $value;\n\t}\n\t\n\t\/**\n\t * Returns a diff on the passed arrays. The behavior varies based on the content of the arrays themselves and any\n\t * flags passed. The resulting structure will be some variant of:\n\t * \n\t * ['added' => [...], 'removed' => [...]]\n\t * \n\t * 1. If both $a and $b are non-associative arrays, the result will not include keys in `added` and `removed`.\n\t * 2. If either or both of $a and $b are associative arrays, the result will include keys that are also factored\n\t *    into the comparison.\n\t * \n\t * @param array $a\n\t * @param array $b\n\t * @param int $flags\n\t * @return array\n\t *\/\n\tpublic static function array_diff($a, $b, $flags = 0) {\n\t\t$result = array();\n\t\tif (!self::is_assoc($a) && !self::is_assoc($b)) {\n\t\t\t$result['added'] = array_diff($b, $a);\n\t\t\t$result['removed'] = array_diff($a, $b);\n\t\t}\n\t\telse {\n\t\t\t$result['added'] = self::array_diff_assoc($b, $a);\n\t\t\t$result['removed'] = self::array_diff_assoc($a, $b);\n\t\t}\n\t\treturn $result;\n\t}\n\t\n\t\/**\n\t * Improved version of array_diff_assoc that handles multidimensional arrays. The resulting array will contain all \n\t * key\/values from $a that are not present in $b.\n\t * \n\t * For nested arrays, the behavior for inequality is this:\n\t * \t- If $a[key] contains values $b[key] does not, an array of those missing values is set for `key` in the result\n\t * \t- If $b[key] contains values $a[key] does not, `key` is not present in the result\n\t * \n\t * @param array $a\n\t * @param array $b\n\t * @param int $flags\n\t * @return array\n\t *\/\n\tpublic static function array_diff_assoc($a, $b, $flags = 0) {\n\t\tif (!($flags & self::ARRAY_DIFF_ORDERED_ARRAYS)) { \/\/Treat $a and $b as unordered if they're non-associative\n\t\t\tif (!self::is_assoc($a) && !self::is_assoc($b)) {\n\t\t\t\tsort($a);\n\t\t\t\tsort($b);\n\t\t\t}\n\t\t}\n\t\t\n\t\t$result = array();\n\t\tforeach ($a as $k => $v) {\n\t\t\tif (array_key_exists($k, $b)) {\n\t\t\t\tif ($a[$k] == $b[$k]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (is_array($a[$k]) && is_array($b[$k])) {\n\t\t\t\t\t$diff = self::array_diff($a[$k], $b[$k]);\n\t\t\t\t\tif (!empty($diff['removed'])) {\n\t\t\t\t\t\t$result[$k] = $diff['removed'];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t$result[$k] = $v;\n\t\t}\n\t\treturn $result;\n\t}\n\t\n\t\/**\n\t * Returns the items from $array whose keys are in $keys.\n\t * \n\t * @param array $array\n\t * @param array|string $keys\n\t * @param bool $single Return single-value as-is instead of a one-element array.\n\t * @param mixed|null $default Value to return when $single is true and nothing is found.\n\t * @return array|mixed\n\t *\/\n\tpublic static function array_choose($array, $keys, $single = false, $default = null) {\n\t\tif (!is_array($keys)) {\n\t\t\t$keys = array($keys);\n\t\t}\n\t\t\n\t\tif (is_object($array) && (\n\t\t\t$array instanceof ArrayAccess ||\n\t\t\t\t$array instanceof Traversable ||\n\t\t\t\t$array instanceof Serializable ||\n\t\t\t\t$array instanceof Countable)) {\n\t\t\t$array = (array) $array;\n\t\t}\n\t\t\n\t\t$matches = array_filter($array, function($k) use ($keys) {\n\t\t\treturn in_array($k, $keys);\n\t\t}, ARRAY_FILTER_USE_KEY);\n\t\tif ($single) {\n\t\t\t$key = self::array_first($keys);\n\t\t\tif ($key !== null && isset($matches[$key])) {\n\t\t\t\treturn $matches[$key];\n\t\t\t}\n\t\t\t\n\t\t\treturn $default;\n\t\t}\n\t\treturn $matches;\n\t}\n\t\n\t\/**\n\t * Convenience function for `array_choose` in its single return value mode for better code readability.\n\t * \n\t * @param array $array\n\t * @param string $key\n\t * @param mixed|null $default\n\t * @return mixed\n\t *\/\n\tpublic static function array_get($array, $key, $default = null) {\n\t\treturn self::array_choose($array, $key, true, $default);\n\t}\n\t\n\t\/**\n\t * Polyfill for array_key_first.\n\t * \n\t * @param array $array\n\t * @return mixed|null\n\t *\/\n\tpublic static function array_key_first($array) {\n\t\tif (function_exists('array_key_first')) {\n\t\t\treturn array_key_first($array);\n\t\t}\n\t\t\n\t\tif (!count($array)) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t$keys = array_keys($array);\n\t\treturn $keys[0];\n\t}\n\t\n\t\/**\n\t * Polyfill for array_key_last.\n\t *\n\t * @param array $array\n\t * @return mixed|null\n\t *\/\n\tpublic static function array_key_last($array) {\n\t\tif (function_exists('array_key_last')) {\n\t\t\treturn array_key_last($array);\n\t\t}\n\t\t\n\t\tif (!count($array)) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t$keys = array_keys($array);\n\t\treturn $keys[count($keys) - 1];\n\t}\n\t\n\t\/**\n\t * Performs an array_map but then converts the response into an associative array. $callable is expected to return\n\t * [$key => $value] rather than just $value as a normal array_map call would. The resulting array will be as if each\n\t * were merged in, preserving the $value under $key. Each $key _should_ generally be unique, but if there are \n\t * duplicates, the last key\/value pair mapped for a given $key will be the final value in the array.\n\t * \n\t * @param callable $callable\n\t * @param array $array\n\t * @return array\n\t *\/\n\tpublic static function array_kmap($callable, $array) {\n\t\t$intermediate = array_map($callable, $array);\n\t\t$result = array();\n\t\tforeach ($intermediate as $i) { \/\/Can't use array_merge because it discards numerical keys\n\t\t\t$k = self::array_key_first($i);\n\t\t\t$v = $i[$k];\n\t\t\t$result[$k] = $v;\n\t\t}\n\t\treturn $result;\n\t}\n\t\n\t\n\t\/**\n\t * Returns whether or not $a is an associative-array. It is considered associative only when the array keys are not\n\t * sequential integers starting at 0.\n\t * \n\t * @param array $a\n\t * @return bool\n\t *\/\n\tpublic static function is_assoc($a) {\n\t\tif (!is_array($a)) { return false; }\n\t\tfor ($i = 0; $i < count($a); $i++) {\n\t\t\tif (!isset($a[$i])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\/**\n\t * Returns the raw HTTP POST body if possible. This is functionally identical to the implementation in wfWAFUtils \n\t * but present here to avoid complications with nested install WAF optimization. \n\t * \n\t * @return string\n\t *\/\n\tpublic static function rawPOSTBody() {\n\t\t\/\/ phpcs:ignore PHPCompatibility.Variables.RemovedPredefinedGlobalVariables.http_raw_post_dataDeprecatedRemoved\n\t\tglobal $HTTP_RAW_POST_DATA;\n\t\t\/\/ phpcs:ignore PHPCompatibility.Variables.RemovedPredefinedGlobalVariables.http_raw_post_dataDeprecatedRemoved\n\t\tif (empty($HTTP_RAW_POST_DATA)) { \/\/Defined if always_populate_raw_post_data is on, PHP < 7, and the encoding type is not multipart\/form-data\n\t\t\t$avoidPHPInput = wfWAFConfig::get('avoid_php_input', false);\n\t\t\tif ($avoidPHPInput) { \/\/Some custom PHP builds break reading from php:\/\/input\n\t\t\t\t\/\/Reconstruct the best possible approximation of it from $_POST if populated -- won't help JSON or other raw payloads\n\t\t\t\t$data = http_build_query($_POST, '', '&');\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$data = file_get_contents('php:\/\/input'); \/\/Available if the encoding type is not multipart\/form-data; it can only be read once prior to PHP 5.6 so we save it in $HTTP_RAW_POST_DATA for WP Core and others\n\t\t\t\t\n\t\t\t\t\/\/For our purposes, we don't currently need the raw POST body if it's multipart\/form-data since the data will be in $_POST\/$_FILES. If we did, we could reconstruct the body here.\n\t\t\t\t\n\t\t\t\t\/\/ phpcs:ignore PHPCompatibility.Variables.RemovedPredefinedGlobalVariables.http_raw_post_dataDeprecatedRemoved\n\t\t\t\t$HTTP_RAW_POST_DATA = $data;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t\/\/ phpcs:ignore PHPCompatibility.Variables.RemovedPredefinedGlobalVariables.http_raw_post_dataDeprecatedRemoved\n\t\t\t$data =& $HTTP_RAW_POST_DATA;\n\t\t}\n\t\treturn $data;\n\t}\n\t\n\t\/**\n\t * Check if an IP address is in a network block\n\t *\n\t * @param string\t$subnet\tSingle IP or subnet in CIDR notation (e.g. '192.168.100.0' or '192.168.100.0\/22')\n\t * @param string\t$ip\t\tIPv4 or IPv6 address in dot or colon notation\n\t * @return boolean\n\t *\/\n\tpublic static function subnetContainsIP($subnet, $ip) {\n\t\tstatic $_network_cache = array();\n\t\tstatic $_ip_cache = array();\n\t\tstatic $_masks = array(\n\t\t\t0 => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t1 => \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t2 => \"\\xc0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t3 => \"\\xe0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t4 => \"\\xf0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t5 => \"\\xf8\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t6 => \"\\xfc\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t7 => \"\\xfe\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t8 => \"\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t9 => \"\\xff\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t10 => \"\\xff\\xc0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t11 => \"\\xff\\xe0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t12 => \"\\xff\\xf0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t13 => \"\\xff\\xf8\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t14 => \"\\xff\\xfc\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t15 => \"\\xff\\xfe\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t16 => \"\\xff\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t17 => \"\\xff\\xff\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t18 => \"\\xff\\xff\\xc0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t19 => \"\\xff\\xff\\xe0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t20 => \"\\xff\\xff\\xf0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t21 => \"\\xff\\xff\\xf8\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t22 => \"\\xff\\xff\\xfc\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t23 => \"\\xff\\xff\\xfe\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t24 => \"\\xff\\xff\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t25 => \"\\xff\\xff\\xff\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t26 => \"\\xff\\xff\\xff\\xc0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t27 => \"\\xff\\xff\\xff\\xe0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t28 => \"\\xff\\xff\\xff\\xf0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t29 => \"\\xff\\xff\\xff\\xf8\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t30 => \"\\xff\\xff\\xff\\xfc\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t31 => \"\\xff\\xff\\xff\\xfe\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t32 => \"\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t33 => \"\\xff\\xff\\xff\\xff\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t34 => \"\\xff\\xff\\xff\\xff\\xc0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t35 => \"\\xff\\xff\\xff\\xff\\xe0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t36 => \"\\xff\\xff\\xff\\xff\\xf0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t37 => \"\\xff\\xff\\xff\\xff\\xf8\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t38 => \"\\xff\\xff\\xff\\xff\\xfc\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t39 => \"\\xff\\xff\\xff\\xff\\xfe\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t40 => \"\\xff\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t41 => \"\\xff\\xff\\xff\\xff\\xff\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t42 => \"\\xff\\xff\\xff\\xff\\xff\\xc0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t43 => \"\\xff\\xff\\xff\\xff\\xff\\xe0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t44 => \"\\xff\\xff\\xff\\xff\\xff\\xf0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t45 => \"\\xff\\xff\\xff\\xff\\xff\\xf8\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t46 => \"\\xff\\xff\\xff\\xff\\xff\\xfc\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t47 => \"\\xff\\xff\\xff\\xff\\xff\\xfe\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t48 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t49 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t50 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xc0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t51 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xe0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t52 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xf0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t53 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xf8\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t54 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xfc\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t55 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xfe\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t56 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t57 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t58 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xc0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t59 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xe0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t60 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xf0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t61 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xf8\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t62 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfc\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t63 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfe\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t64 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t65 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t66 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xc0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t67 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xe0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t68 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xf0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t69 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xf8\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t70 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfc\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t71 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfe\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t72 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t73 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x80\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t74 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xc0\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t75 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xe0\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t76 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xf0\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t77 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xf8\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t78 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfc\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t79 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfe\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t80 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t81 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x80\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t82 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xc0\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t83 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xe0\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t84 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xf0\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t85 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xf8\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t86 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfc\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t87 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfe\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t88 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00\\x00\",\n\t\t\t89 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x80\\x00\\x00\\x00\\x00\",\n\t\t\t90 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xc0\\x00\\x00\\x00\\x00\",\n\t\t\t91 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xe0\\x00\\x00\\x00\\x00\",\n\t\t\t92 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xf0\\x00\\x00\\x00\\x00\",\n\t\t\t93 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xf8\\x00\\x00\\x00\\x00\",\n\t\t\t94 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfc\\x00\\x00\\x00\\x00\",\n\t\t\t95 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfe\\x00\\x00\\x00\\x00\",\n\t\t\t96 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00\",\n\t\t\t97 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x80\\x00\\x00\\x00\",\n\t\t\t98 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xc0\\x00\\x00\\x00\",\n\t\t\t99 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xe0\\x00\\x00\\x00\",\n\t\t\t100 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xf0\\x00\\x00\\x00\",\n\t\t\t101 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xf8\\x00\\x00\\x00\",\n\t\t\t102 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfc\\x00\\x00\\x00\",\n\t\t\t103 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfe\\x00\\x00\\x00\",\n\t\t\t104 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\x00\\x00\",\n\t\t\t105 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x80\\x00\\x00\",\n\t\t\t106 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xc0\\x00\\x00\",\n\t\t\t107 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xe0\\x00\\x00\",\n\t\t\t108 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xf0\\x00\\x00\",\n\t\t\t109 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xf8\\x00\\x00\",\n\t\t\t110 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfc\\x00\\x00\",\n\t\t\t111 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfe\\x00\\x00\",\n\t\t\t112 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\x00\",\n\t\t\t113 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x80\\x00\",\n\t\t\t114 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xc0\\x00\",\n\t\t\t115 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xe0\\x00\",\n\t\t\t116 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xf0\\x00\",\n\t\t\t117 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xf8\\x00\",\n\t\t\t118 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfc\\x00\",\n\t\t\t119 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfe\\x00\",\n\t\t\t120 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\",\n\t\t\t121 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x80\",\n\t\t\t122 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xc0\",\n\t\t\t123 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xe0\",\n\t\t\t124 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xf0\",\n\t\t\t125 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xf8\",\n\t\t\t126 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfc\",\n\t\t\t127 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfe\",\n\t\t\t128 => \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\",\n\t\t);\n\t\t\/*\n\t\t * The above is generated by:\n\t\t * \n\t\t   function gen_mask($prefix, $size = 128) {\n\t\t\t\t\/\/Workaround to avoid overflow, split into four pieces\t\t\t\n\t\t\t\t$mask_1 = (pow(2, $size \/ 4) - 1) ^ (pow(2, min($size \/ 4, max(0, 1 * $size \/ 4 - $prefix))) - 1);\n\t\t\t\t$mask_2 = (pow(2, $size \/ 4) - 1) ^ (pow(2, min($size \/ 4, max(0, 2 * $size \/ 4 - $prefix))) - 1);\n\t\t\t\t$mask_3 = (pow(2, $size \/ 4) - 1) ^ (pow(2, min($size \/ 4, max(0, 3 * $size \/ 4 - $prefix))) - 1);\n\t\t\t\t$mask_4 = (pow(2, $size \/ 4) - 1) ^ (pow(2, min($size \/ 4, max(0, 4 * $size \/ 4 - $prefix))) - 1);\n\t\t\t\treturn ($mask_1 ? pack('N', $mask_1) : \"\\0\\0\\0\\0\") . ($mask_2 ? pack('N', $mask_2) : \"\\0\\0\\0\\0\") . ($mask_3 ? pack('N', $mask_3) : \"\\0\\0\\0\\0\") . ($mask_4 ? pack('N', $mask_4) : \"\\0\\0\\0\\0\");\n\t\t\t}\n\t\t\t\n\t\t\t$masks = array();\n\t\t\tfor ($i = 0; $i <= 128; $i++) {\n\t\t\t\t$mask = gen_mask($i);\n\t\t\t\t$chars = str_split($mask);\n\t\t\t\t$masks[] = implode('', array_map(function($c) { return '\\\\x' . bin2hex($c); }, $chars));\n\t\t\t}\n\t\t\t\n\t\t\techo 'array(' . \"\\n\";\n\t\t\tforeach ($masks as $index => $m) {\n\t\t\t\techo \"\\t{$index} => \\\"{$m}\\\",\\n\";\n\t\t\t}\n\t\t\techo ')';\n\t\t *\n\t\t *\/\n\t\t\n\t\tif (isset($_network_cache[$subnet])) {\n\t\t\tlist($bin_network, $prefix, $masked_network) = $_network_cache[$subnet];\n\t\t\t$mask = $_masks[$prefix];\n\t\t}\n\t\telse {\n\t\t\tlist($network, $prefix) = array_pad(explode('\/', $subnet, 2), 2, null);\n\t\t\tif (filter_var($network, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4)) {\n\t\t\t\t\/\/ If no prefix was supplied, 32 is implied for IPv4\n\t\t\t\tif ($prefix === null) {\n\t\t\t\t\t$prefix = 32;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\/\/ Validate the IPv4 network prefix\n\t\t\t\tif ($prefix < 0 || $prefix > 32) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\/\/ Increase the IPv4 network prefix to work in the IPv6 address space\n\t\t\t\t$prefix += 96;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t\/\/ If no prefix was supplied, 128 is implied for IPv6\n\t\t\t\tif ($prefix === null) {\n\t\t\t\t\t$prefix = 128;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\/\/ Validate the IPv6 network prefix\n\t\t\t\tif ($prefix < 1 || $prefix > 128) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t$mask = $_masks[$prefix];\n\t\t\t$bin_network = self::inet_pton($network);\n\t\t\t$masked_network = $bin_network & $mask;\n\t\t\t$_network_cache[$subnet] = array($bin_network, $prefix, $masked_network);\n\t\t}\n\t\t\n\t\tif (isset($_ip_cache[$ip]) && isset($_ip_cache[$ip][$prefix])) {\n\t\t\tlist($bin_ip, $masked_ip) = $_ip_cache[$ip][$prefix];\n\t\t}\n\t\telse {\n\t\t\t$bin_ip = self::inet_pton($ip);\n\t\t\t$masked_ip = $bin_ip & $mask;\n\t\t\tif (!isset($_ip_cache[$ip])) {\n\t\t\t\t$_ip_cache[$ip] = array();\n\t\t\t}\n\t\t\t$_ip_cache[$ip][$prefix] = array($bin_ip, $masked_ip);\n\t\t}\n\t\t\n\t\treturn ($masked_ip === $masked_network);\n\t}\n\n\t\/**\n\t * Convert CIDR notation to a wfUserIPRange object\n\t *\n\t * @param string $cidr\n\t * @return wfUserIPRange\n\t *\/\n\tpublic static function CIDR2wfUserIPRange($cidr) {\n\t\tlist($network, $prefix) = array_pad(explode('\/', $cidr, 2), 2, null);\n\t\t$ip_range = new wfUserIPRange();\n\n\t\tif (filter_var($network, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4)) {\n\t\t\t\/\/ If no prefix was supplied, 32 is implied for IPv4\n\t\t\tif ($prefix === null) {\n\t\t\t\t$prefix = 32;\n\t\t\t}\n\n\t\t\t\/\/ Validate the IPv4 network prefix\n\t\t\tif ($prefix < 0 || $prefix > 32) {\n\t\t\t\treturn $ip_range;\n\t\t\t}\n\n\t\t\t\/\/ Increase the IPv4 network prefix to work in the IPv6 address space\n\t\t\t$prefix += 96;\n\t\t} else {\n\t\t\t\/\/ If no prefix was supplied, 128 is implied for IPv6\n\t\t\tif ($prefix === null) {\n\t\t\t\t$prefix = 128;\n\t\t\t}\n\n\t\t\t\/\/ Validate the IPv6 network prefix\n\t\t\tif ($prefix < 1 || $prefix > 128) {\n\t\t\t\treturn $ip_range;\n\t\t\t}\n\t\t}\n\n\t\t\/\/ Convert human readable address to 128 bit (IPv6) binary string\n\t\t\/\/ Note: self::inet_pton converts IPv4 addresses to IPv6 compatible versions\n\t\t$binary_network = self::inet_pton($network);\n\t\t$binary_mask = wfHelperBin::str2bin(str_pad(str_repeat('1', $prefix), 128, '0', STR_PAD_RIGHT));\n\n\t\t\/\/ Calculate first and last address\n\t\t$binary_first = $binary_network & $binary_mask;\n\t\t$binary_last = $binary_network | ~ $binary_mask;\n\n\t\t\/\/ Convert binary addresses back to human readable strings\n\t\t$first = self::inet_ntop($binary_first);\n\t\t$last = self::inet_ntop($binary_last);\n\n\t\tif (filter_var($network, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6)) {\n\t\t\t$first = self::expandIPv6Address($first);\n\t\t\t$last = self::expandIPv6Address($last);\n\t\t}\n\n\t\t\/\/ Split addresses into segments\n\t\t$first_array = preg_split('\/[\\.\\:]\/', $first);\n\t\t$last_array = preg_split('\/[\\.\\:]\/', $last);\n\n\t\t\/\/ Make sure arrays are the same size. IPv6 '::' could cause problems otherwise.\n\t\t\/\/ The strlen filter should leave zeros in place\n\t\t$first_array = array_pad(array_filter($first_array, 'strlen'), count($last_array), '0');\n\n\t\t$range_segments = array();\n\n\t\tforeach ($first_array as $index => $segment) {\n\t\t\tif ($segment === $last_array[$index]) {\n\t\t\t\t$range_segments[] = str_pad(ltrim($segment, '0'), 1, '0');\n\t\t\t} else if ($segment === '' || $last_array[$index] === '') {\n\t\t\t\t$range_segments[] = '';\n\t\t\t} else {\n\t\t\t\t$range_segments[] = \"[\". str_pad(ltrim($segment, '0'), 1, '0') . \"-\" .\n\t\t\t\t\tstr_pad(ltrim($last_array[$index], '0'), 1, '0') . \"]\";\n\t\t\t}\n\t\t}\n\n\t\t$delimiter = filter_var($network, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4) ? '.' : ':';\n\n\t\t$ip_range->setIPString(implode($delimiter, $range_segments));\n\n\t\treturn $ip_range;\n\t}\n\n\t\/**\n\t * Return dot notation of IPv4 address.\n\t *\n\t * @param int $ip\n\t * @return string|bool\n\t *\/\n\tpublic static function inet_ntoa($ip) {\n\t\t$long = 4294967295 - ($ip - 1);\n\t\treturn long2ip(-$long);\n\t}\n\n\t\/**\n\t * Return string representation of 32 bit int of the IP address.\n\t *\n\t * @param string $ip\n\t * @return string\n\t *\/\n\tpublic static function inet_aton($ip) {\n\t\t$ip = preg_replace('\/(?<=^|\\.)0+([1-9])\/', '$1', $ip);\n\t\treturn sprintf(\"%u\", ip2long($ip));\n\t}\n\n\t\/**\n\t * Return dot or colon notation of IPv4 or IPv6 address.\n\t *\n\t * @param string $ip\n\t * @return string|bool\n\t *\/\n\tpublic static function inet_ntop($ip) {\n\t\t\/\/ trim this to the IPv4 equiv if it's in the mapped range\n\t\tif (strlen($ip) == 16 && substr($ip, 0, 12) == \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xff\") {\n\t\t\t$ip = substr($ip, 12, 4);\n\t\t}\n\t\treturn self::hasIPv6Support() ? @inet_ntop($ip) : self::_inet_ntop($ip);\n\t}\n\n\t\/**\n\t * Return the packed binary string of an IPv4 or IPv6 address.\n\t *\n\t * @param string $ip\n\t * @return string\n\t *\/\n\tpublic static function inet_pton($ip) {\n\t\t\/\/ convert the 4 char IPv4 to IPv6 mapped version.\n\t\t$pton = str_pad(self::hasIPv6Support() ? @inet_pton($ip) : self::_inet_pton($ip), 16,\n\t\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xff\\x00\\x00\\x00\\x00\", STR_PAD_LEFT);\n\t\treturn $pton;\n\t}\n\n\t\/**\n\t * Added compatibility for hosts that do not have inet_pton.\n\t *\n\t * @param $ip\n\t * @return bool|string\n\t *\/\n\tpublic static function _inet_pton($ip) {\n\t\t\/\/ IPv4\n\t\tif (preg_match('\/^(?:\\d{1,3}(?:\\.|$)){4}\/', $ip)) {\n\t\t\t$octets = explode('.', $ip);\n\t\t\t$bin = chr($octets[0]) . chr($octets[1]) . chr($octets[2]) . chr($octets[3]);\n\t\t\treturn $bin;\n\t\t}\n\n\t\t\/\/ IPv6\n\t\tif (preg_match('\/^((?:[\\da-f]{1,4}(?::|)){0,8})(::)?((?:[\\da-f]{1,4}(?::|)){0,8})$\/i', $ip)) {\n\t\t\tif ($ip === '::') {\n\t\t\t\treturn \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n\t\t\t}\n\t\t\t$colon_count = substr_count($ip, ':');\n\t\t\t$dbl_colon_pos = strpos($ip, '::');\n\t\t\tif ($dbl_colon_pos !== false) {\n\t\t\t\t$ip = str_replace('::', str_repeat(':0000',\n\t\t\t\t\t\t(($dbl_colon_pos === 0 || $dbl_colon_pos === strlen($ip) - 2) ? 9 : 8) - $colon_count) . ':', $ip);\n\t\t\t\t$ip = trim($ip, ':');\n\t\t\t}\n\n\t\t\t$ip_groups = explode(':', $ip);\n\t\t\t$ipv6_bin = '';\n\t\t\tforeach ($ip_groups as $ip_group) {\n\t\t\t\t$ipv6_bin .= pack('H*', str_pad($ip_group, 4, '0', STR_PAD_LEFT));\n\t\t\t}\n\n\t\t\treturn strlen($ipv6_bin) === 16 ? $ipv6_bin : false;\n\t\t}\n\n\t\t\/\/ IPv4 mapped IPv6\n\t\tif (preg_match('\/^(?:\\:(?:\\:0{1,4}){0,4}\\:|(?:0{1,4}\\:){5})ffff\\:(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})$\/i', $ip, $matches)) {\n\t\t\t$octets = explode('.', $matches[1]);\n\t\t\treturn \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xff\" . chr($octets[0]) . chr($octets[1]) . chr($octets[2]) . chr($octets[3]);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t\/**\n\t * Added compatibility for hosts that do not have inet_ntop.\n\t *\n\t * @param $ip\n\t * @return bool|string\n\t *\/\n\tpublic static function _inet_ntop($ip) {\n\t\t\/\/ IPv4\n\t\tif (strlen($ip) === 4) {\n\t\t\treturn ord($ip[0]) . '.' . ord($ip[1]) . '.' . ord($ip[2]) . '.' . ord($ip[3]);\n\t\t}\n\n\t\t\/\/ IPv6\n\t\tif (strlen($ip) === 16) {\n\n\t\t\t\/\/ IPv4 mapped IPv6\n\t\t\tif (substr($ip, 0, 12) == \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xff\") {\n\t\t\t\treturn \"::ffff:\" . ord($ip[12]) . '.' . ord($ip[13]) . '.' . ord($ip[14]) . '.' . ord($ip[15]);\n\t\t\t}\n\n\t\t\t$hex = bin2hex($ip);\n\t\t\t$groups = str_split($hex, 4);\n\t\t\t$in_collapse = false;\n\t\t\t$done_collapse = false;\n\t\t\tforeach ($groups as $index => $group) {\n\t\t\t\tif ($group == '0000' && !$done_collapse) {\n\t\t\t\t\tif ($in_collapse) {\n\t\t\t\t\t\t$groups[$index] = '';\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t$groups[$index] = ':';\n\t\t\t\t\t$in_collapse = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ($in_collapse) {\n\t\t\t\t\t$done_collapse = true;\n\t\t\t\t}\n\t\t\t\t$groups[$index] = ltrim($groups[$index], '0');\n\t\t\t\tif (strlen($groups[$index]) === 0) {\n\t\t\t\t\t$groups[$index] = '0';\n\t\t\t\t}\n\t\t\t}\n\t\t\t$ip = join(':', array_filter($groups, 'strlen'));\n\t\t\t$ip = str_replace(':::', '::', $ip);\n\t\t\treturn $ip == ':' ? '::' : $ip;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t\/**\n\t * Verify PHP was compiled with IPv6 support.\n\t *\n\t * Some hosts appear to not have inet_ntop, and others appear to have inet_ntop but are unable to process IPv6 addresses.\n\t *\n\t * @return bool\n\t *\/\n\tpublic static function hasIPv6Support() {\n\t\tstatic $hasSupport = null;\n\t\tif ($hasSupport === null) {\n\t\t\t$hasSupport = defined('AF_INET6') && self::funcEnabled('inet_ntop') && self::funcEnabled('inet_pton');\n\t\t}\n\t\treturn $hasSupport;\n\t}\n\n\tpublic static function hasLoginCookie(){\n\t\tif(isset($_COOKIE)){\n\t\t\tif(is_array($_COOKIE)){\n\t\t\t\tforeach($_COOKIE as $key => $val){\n\t\t\t\t\tif(strpos($key, 'wordpress_logged_in') === 0){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tpublic static function getBaseURL(){\n\t\treturn plugins_url('', WORDFENCE_FCPATH) . '\/';\n\t}\n\tpublic static function getPluginBaseDir(){\n\t\tif(function_exists('wp_normalize_path')){ \/\/Older WP versions don't have this func and we had many complaints before this check.\n\t\t\tif(defined('WP_PLUGIN_DIR')) {\n\t\t\t\treturn wp_normalize_path(WP_PLUGIN_DIR . '\/');\n\t\t\t}\n\t\t\treturn wp_normalize_path(WP_CONTENT_DIR . '\/plugins\/');\n\t\t} else {\n\t\t\tif(defined('WP_PLUGIN_DIR')) {\n\t\t\t\treturn WP_PLUGIN_DIR . '\/';\n\t\t\t}\n\t\t\treturn WP_CONTENT_DIR . '\/plugins\/';\n\t\t}\n\t}\n\tpublic static function makeRandomIP(){\n\t\treturn rand(11,230) . '.' . rand(0,255) . '.' . rand(0,255) . '.' . rand(0,255);\n\t}\n\t\n\t\/**\n\t * Converts a truthy value to a boolean, checking in this order:\n\t * - already a boolean\n\t * - is null => false\n\t * - numeric (0 => false, otherwise true)\n\t * - 'false', 'f', 'no', 'n', or 'off' => false\n\t * - 'true', 't', 'yes', 'y', or 'on' => true\n\t * - empty value => false, otherwise true\n\t * \n\t * @param $value\n\t * @return bool\n\t *\/\n\tpublic static function truthyToBoolean($value) {\n\t\tif ($value === true || $value === false) {\n\t\t\treturn $value;\n\t\t}\n\t\t\n\t\tif (is_null($value)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (is_numeric($value)) {\n\t\t\treturn !!$value;\n\t\t}\n\t\t\n\t\tif (preg_match('\/^(?:f(?:alse)?|no?|off)$\/i', $value)) {\n\t\t\treturn false;\n\t\t}\n\t\telse if (preg_match('\/^(?:t(?:rue)?|y(?:es)?|on)$\/i', $value)) {\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn !empty($value);\n\t}\n\t\n\t\/**\n\t * Converts a truthy value to 1 or 0.\n\t * \n\t * @see wfUtils::truthyToBoolean\n\t * \n\t * @param $value\n\t * @return int\n\t *\/\n\tpublic static function truthyToInt($value) {\n\t\treturn self::truthyToBoolean($value) ? 1 : 0;\n\t}\n\t\n\t\/**\n\t * Returns the whitelist presets, which first grabs the bundled list and then merges the dynamic list into it.\n\t * \n\t * @return array\n\t *\/\n\tpublic static function whitelistPresets() {\n\t\tstatic $_cachedPresets = null;\n\t\tif ($_cachedPresets === null) {\n\t\t\tinclude(dirname(__FILE__) . '\/wfIPWhitelist.php'); \/** @var array $wfIPWhitelist *\/\n\t\t\t$currentPresets = wfConfig::getJSON('whitelistPresets', array());\n\t\t\tif (is_array($currentPresets)) {\n\t\t\t\t$_cachedPresets = array_merge($wfIPWhitelist, $currentPresets);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$_cachedPresets = $wfIPWhitelist;\n\t\t\t}\n\t\t}\n\t\treturn $_cachedPresets;\n\t}\n\t\n\t\/**\n\t * Returns an array containing all whitelisted service IPs\/ranges. The returned array is grouped by service\n\t * tag: array('service1' => array('range1', 'range2', range3', ...), ...)\n\t * \n\t * @param array|null $whitelistedServices If provided, use this service list for enabled\/disabled resolution\n\t * @return array\n\t *\/\n\tpublic static function whitelistedServiceIPs($whitelistedServices = null) {\n\t\t$result = array();\n\t\t$whitelistPresets = self::whitelistPresets();\n\t\tif ($whitelistedServices === null) {\n\t\t\t$whitelistedServices = wfConfig::getJSON('whitelistedServices', array());\n\t\t}\n\t\tforeach ($whitelistPresets as $tag => $preset) {\n\t\t\tif (!isset($preset['n'])) { \/\/Just an array of IPs\/ranges\n\t\t\t\t$result[$tag] = $preset;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif ((isset($preset['h']) && $preset['h']) || (isset($preset['f']) && $preset['f'])) { \/\/Forced\n\t\t\t\t$result[$tag] = $preset['r'];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif ((!isset($whitelistedServices[$tag]) && isset($preset['d']) && $preset['d']) || (isset($whitelistedServices[$tag]) && $whitelistedServices[$tag])) {\n\t\t\t\t$result[$tag] = $preset['r'];\n\t\t\t}\n\t\t}\n\t\treturn $result;\n\t}\n\n\t\/**\n\t * Get the list of whitelisted IPs and networks, which is a combination of preset IPs\/ranges and user-entered\n\t * IPs\/ranges.\n\t *\n\t * @param string\t$filter\tGroup name to filter whitelist by\n\t * @return array\n\t *\/\n\tpublic static function getIPWhitelist($filter = null) {\n\t\tstatic $wfIPWhitelist;\n\n\t\tif (!isset($wfIPWhitelist)) {\n\t\t\t$wfIPWhitelist = self::whitelistedServiceIPs();\n\t\t\t\n\t\t\t\/\/Append user ranges\n\t\t\t$wfIPWhitelist['user'] = array();\n\t\t\tforeach (array_filter(explode(',', wfConfig::get('whitelisted'))) as $ip) {\n\t\t\t\t$wfIPWhitelist['user'][] = new wfUserIPRange($ip);\n\t\t\t}\n\t\t}\n\n\t\t$whitelist = array();\n\t\tforeach ($wfIPWhitelist as $group => $values) {\n\t\t\tif ($filter === null || $group === $filter) {\n\t\t\t\t$whitelist = array_merge($whitelist, $values);\n\t\t\t}\n\t\t}\n\n\t\treturn $whitelist;\n\t}\n\n\t\/**\n\t * @param string $addr Should be in dot or colon notation (127.0.0.1 or ::1)\n\t * @return bool\n\t *\/\n\tpublic static function isPrivateAddress($addr) {\n\t\t\/\/ Run this through the preset list for IPv4 addresses.\n\t\tif (filter_var($addr, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4) !== false) {\n\t\t\tforeach (self::getIPWhitelist('private') as $a) {\n\t\t\t\tif (self::subnetContainsIP($a, $addr)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn filter_var($addr, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4 | FILTER_FLAG_IPV6) !== false\n\t\t\t&& filter_var($addr, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4 | FILTER_FLAG_IPV6 | FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE) === false;\n\t}\n\n\t\/**\n\t * Expects an array of items. The items are either IP's or IP's separated by comma, space or tab. Or an array of IP's.\n\t * We then examine all IP's looking for a public IP and storing private IP's in an array. If we find no public IPs we return the first private addr we found.\n\t *\n\t * @param array $arr\n\t * @return bool|mixed\n\t *\/\n\tprivate static function getCleanIP($arr){\n\t\t$privates = array(); \/\/Store private addrs until end as last resort.\n\t\tfor($i = 0; $i < count($arr); $i++){\n\t\t\t$item = $arr[$i];\n\t\t\tif(is_array($item)){\n\t\t\t\tforeach($item as $j){\n\t\t\t\t\t\/\/ try verifying the IP is valid before stripping the port off\n\t\t\t\t\tif (!self::isValidIP($j)) {\n\t\t\t\t\t\t$j = preg_replace('\/:\\d+$\/', '', $j); \/\/Strip off port\n\t\t\t\t\t}\n\t\t\t\t\tif (self::isValidIP($j)) {\n\t\t\t\t\t\tif (self::isPrivateAddress($j)) {\n\t\t\t\t\t\t\t$privates[] = $j;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn $j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue; \/\/This was an array so we can skip to the next item\n\t\t\t}\n\t\t\t$skipToNext = false;\n\t\t\tforeach(array(',', ' ', \"\\t\") as $char){\n\t\t\t\tif(strpos($item, $char) !== false){\n\t\t\t\t\t$sp = explode($char, $item);\n\t\t\t\t\t$sp = array_reverse($sp);\n\t\t\t\t\tforeach($sp as $j){\n\t\t\t\t\t\t$j = trim($j);\n\t\t\t\t\t\tif (!self::isValidIP($j)) {\n\t\t\t\t\t\t\t$j = preg_replace('\/:\\d+$\/', '', $j); \/\/Strip off port\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(self::isValidIP($j)){\n\t\t\t\t\t\t\tif(self::isPrivateAddress($j)){\n\t\t\t\t\t\t\t\t$privates[] = $j;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn $j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t$skipToNext = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif($skipToNext){ continue; } \/\/Skip to next item because this one had a comma, space or tab so was delimited and we didn't find anything.\n\n\t\t\tif (!self::isValidIP($item)) {\n\t\t\t\t$item = preg_replace('\/:\\d+$\/', '', $item); \/\/Strip off port\n\t\t\t}\n\t\t\tif(self::isValidIP($item)){\n\t\t\t\tif(self::isPrivateAddress($item)){\n\t\t\t\t\t$privates[] = $item;\n\t\t\t\t} else {\n\t\t\t\t\treturn $item;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(sizeof($privates) > 0){\n\t\t\treturn $privates[0]; \/\/Return the first private we found so that we respect the order the IP's were passed to this function.\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t\/**\n\t * Expects an array of items. The items are either IP's or IP's separated by comma, space or tab. Or an array of IP's.\n\t * We then examine all IP's looking for a public IP and storing private IP's in an array. If we find no public IPs we return the first private addr we found.\n\t *\n\t * @param array $arr\n\t * @return bool|mixed\n\t *\/\n\tprivate static function getCleanIPAndServerVar($arr, $trustedProxies = null) {\n\t\t$privates = array(); \/\/Store private addrs until end as last resort.\n\t\tfor($i = 0; $i < count($arr); $i++){\n\t\t\tlist($item, $var) = $arr[$i];\n\t\t\tif(is_array($item)){\n\t\t\t\tforeach($item as $j){\n\t\t\t\t\t\/\/ try verifying the IP is valid before stripping the port off\n\t\t\t\t\tif (!self::isValidIP($j)) {\n\t\t\t\t\t\t$j = preg_replace('\/:\\d+$\/', '', $j); \/\/Strip off port\n\t\t\t\t\t}\n\t\t\t\t\tif (self::isValidIP($j)) {\n\t\t\t\t\t\tif (self::isIPv6MappedIPv4($j)) {\n\t\t\t\t\t\t\t$j = self::inet_ntop(self::inet_pton($j));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (self::isPrivateAddress($j)) {\n\t\t\t\t\t\t\t$privates[] = array($j, $var);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn array($j, $var);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue; \/\/This was an array so we can skip to the next item\n\t\t\t}\n\t\t\t$skipToNext = false;\n\t\t\tif ($trustedProxies === null) {\n\t\t\t\t$trustedProxies = self::unifiedTrustedProxies();\n\t\t\t}\n\t\t\tforeach(array(',', ' ', \"\\t\") as $char){\n\t\t\t\tif(strpos($item, $char) !== false){\n\t\t\t\t\t$sp = explode($char, $item);\n\t\t\t\t\t$sp = array_reverse($sp);\n\t\t\t\t\tforeach($sp as $index => $j){\n\t\t\t\t\t\t$j = trim($j);\n\t\t\t\t\t\tif (!self::isValidIP($j)) {\n\t\t\t\t\t\t\t$j = preg_replace('\/:\\d+$\/', '', $j); \/\/Strip off port\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(self::isValidIP($j)){\n\t\t\t\t\t\t\tif (self::isIPv6MappedIPv4($j)) {\n\t\t\t\t\t\t\t\t$j = self::inet_ntop(self::inet_pton($j));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tforeach ($trustedProxies as $proxy) {\n\t\t\t\t\t\t\t\tif (!empty($proxy)) {\n\t\t\t\t\t\t\t\t\tif (self::subnetContainsIP($proxy, $j) && $index < count($sp) - 1) {\n\t\t\t\t\t\t\t\t\t\tcontinue 2;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(self::isPrivateAddress($j)){\n\t\t\t\t\t\t\t\t$privates[] = array($j, $var);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn array($j, $var);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t$skipToNext = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif($skipToNext){ continue; } \/\/Skip to next item because this one had a comma, space or tab so was delimited and we didn't find anything.\n\n\t\t\tif (!self::isValidIP($item)) {\n\t\t\t\t$item = preg_replace('\/:\\d+$\/', '', $item); \/\/Strip off port\n\t\t\t}\n\t\t\tif(self::isValidIP($item)){\n\t\t\t\tif (self::isIPv6MappedIPv4($item)) {\n\t\t\t\t\t$item = self::inet_ntop(self::inet_pton($item));\n\t\t\t\t}\n\n\t\t\t\tif(self::isPrivateAddress($item)){\n\t\t\t\t\t$privates[] = array($item, $var);\n\t\t\t\t} else {\n\t\t\t\t\treturn array($item, $var);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(sizeof($privates) > 0){\n\t\t\treturn $privates[0]; \/\/Return the first private we found so that we respect the order the IP's were passed to this function.\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\t\/**\n\t * Returns an array of all trusted proxies, combining both the user-entered ones and those from the selected preset.\n\t * \n\t * @return string[]\n\t *\/\n\tpublic static function unifiedTrustedProxies() {\n\t\t$trustedProxies = explode(\"\\n\", wfConfig::get('howGetIPs_trusted_proxies', ''));\n\t\t\n\t\t$preset = wfConfig::get('howGetIPs_trusted_proxy_preset');\n\t\t$presets = wfConfig::getJSON('ipResolutionList', array());\n\t\tif (is_array($presets) && isset($presets[$preset])) {\n\t\t\t$testIPs = array_merge($presets[$preset]['ipv4'], $presets[$preset]['ipv6']);\n\t\t\tforeach ($testIPs as $val) {\n\t\t\t\tif (strlen($val) > 0) {\n\t\t\t\t\tif (wfUtils::isValidIP($val) || wfUtils::isValidCIDRRange($val)) {\n\t\t\t\t\t\t$trustedProxies[] = $val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn $trustedProxies;\n\t}\n\n\t\/**\n\t * @param string $ip\n\t * @return bool\n\t *\/\n\tpublic static function isIPv6MappedIPv4($ip) {\n\t\treturn preg_match('\/^(?:\\:(?:\\:0{1,4}){0,4}\\:|(?:0{1,4}\\:){5})ffff\\:\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$\/i', $ip) > 0;\n\t}\n\n\tpublic static function extractHostname($str){\n\t\tif(preg_match('\/https?:\\\/\\\/([a-zA-Z0-9\\.\\-]+)(?:\\\/|$)\/i', $str, $matches)){\n\t\t\treturn strtolower($matches[1]);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\t\/**\n\t * Returns the known server IPs, ordered by those as the best match for outgoing requests.\n\t * \n\t * @param bool $refreshCache\n\t * @return string[]\n\t *\/\n\tpublic static function serverIPs($refreshCache = false) {\n\t\tstatic $cachedServerIPs = null;\n\t\tif (isset($cachedServerIPs) && !$refreshCache) {\n\t\t\treturn $cachedServerIPs;\n\t\t}\n\t\t\n\t\t$serverIPs = array();\n\t\t$storedIP = wfConfig::get('serverIP');\n\t\tif (preg_match('\/^(\\d+);(.+)$\/', $storedIP, $matches)) { \/\/Format is 'timestamp;ip'\n\t\t\t$serverIPs[] = $matches[2];\n\t\t}\n\t\t\n\t\tif (function_exists('dns_get_record')) {\n\t\t\t$storedDNS = wfConfig::get('serverDNS');\n\t\t\t$usingCache = false;\n\t\t\tif (preg_match('\/^(\\d+);(\\d+);(.+)$\/', $storedDNS, $matches)) { \/\/Format is 'timestamp;ttl;ip'\n\t\t\t\t$timestamp = $matches[1];\n\t\t\t\t$ttl = $matches[2];\n\t\t\t\tif ($timestamp + max($ttl, 86400) > time()) {\n\t\t\t\t\t$serverIPs[] = $matches[3];\n\t\t\t\t\t$usingCache = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (!$usingCache) {\n\t\t\t\t$home = get_home_url();\n\t\t\t\tif (preg_match('\/^https?:\\\/\\\/([^\\\/]+)\/i', $home, $matches)) {\n\t\t\t\t\t$host = strtolower($matches[1]);\n\t\t\t\t\t$cnameRaw = @dns_get_record($host, DNS_CNAME);\n\t\t\t\t\t$cnames = array();\n\t\t\t\t\t$cnamesTargets = array();\n\t\t\t\t\tif ($cnameRaw && is_array($cnameRaw)) {\n\t\t\t\t\t\tforeach ($cnameRaw as $elem) {\n\t\t\t\t\t\t\tif (is_array($elem) && \n\t\t\t\t\t\t\t\tarray_key_exists('host', $elem) && \n\t\t\t\t\t\t\t\tarray_key_exists('target', $elem) && \n\t\t\t\t\t\t\t\t$elem['host'] == $host\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t$cnames[] = $elem;\n\t\t\t\t\t\t\t\t$cnamesTargets[] = $elem['target'];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$aRaw = @dns_get_record($host, DNS_A);\n\t\t\t\t\t$a = array();\n\t\t\t\t\tif ($aRaw && is_array($aRaw)) {\n\t\t\t\t\t\tforeach ($aRaw as $elem) {\n\t\t\t\t\t\t\tif (is_array($elem) && \n\t\t\t\t\t\t\t\tarray_key_exists('host', $elem) &&\n\t\t\t\t\t\t\t\tarray_key_exists('ttl', $elem) &&\n\t\t\t\t\t\t\t\tarray_key_exists('ip', $elem) &&\n\t\t\t\t\t\t\t\t($elem['host'] == $host || in_array($elem['host'], $cnamesTargets))\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t$a[] = $elem;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$firstA = wfUtils::array_first($a);\n\t\t\t\t\tif ($firstA !== null) {\n\t\t\t\t\t\t$serverIPs[] = $firstA['ip'];\n\t\t\t\t\t\twfConfig::set('serverDNS', time() . ';' . $firstA['ttl'] . ';' . $firstA['ip']);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (isset($_SERVER['SERVER_ADDR']) && wfUtils::isValidIP($_SERVER['SERVER_ADDR'])) {\n\t\t\t$serverIPs[] = $_SERVER['SERVER_ADDR'];\n\t\t}\n\t\t\n\t\t$serverIPs = array_unique($serverIPs);\n\t\t$cachedServerIPs = $serverIPs;\n\t\treturn $serverIPs;\n\t}\n\t\n\tpublic static function getIP($refreshCache = false) {\n\t\tstatic $theIP = null;\n\t\tif (isset($theIP) && !$refreshCache) {\n\t\t\treturn $theIP;\n\t\t}\n\t\t\/\/For debugging. \n\t\t\/\/return '54.232.205.132';\n\t\t\/\/return self::makeRandomIP();\n\n\t\t\/\/ if no REMOTE_ADDR, it's probably running from the command line\n\t\t$ip = self::getIPAndServerVariable();\n\t\tif (is_array($ip)) {\n\t\t\tlist($IP, $variable) = $ip;\n\t\t\t$theIP = $IP;\n\t\t\treturn $IP;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic static function getIPForField($field, $trustedProxies = null) {\n\t\t$ip = self::getIPAndServerVariable($field, $trustedProxies);\n\t\tif (is_array($ip)) {\n\t\t\tlist($IP, $variable) = $ip;\n\t\t\treturn $IP;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static function getAllServerVariableIPs()\n\t{\n\t\t$variables = array('REMOTE_ADDR', 'HTTP_CF_CONNECTING_IP', 'HTTP_X_REAL_IP', 'HTTP_X_FORWARDED_FOR');\n\t\t$ips = array();\n\n\t\tforeach ($variables as $variable) {\n\t\t\t$ip = isset($_SERVER[$variable]) ? $_SERVER[$variable] : false;\n\n\t\t\tif ($ip && strpos($ip, ',') !== false) {\n\t\t\t\t$ips[$variable] = preg_replace('\/[\\s,]\/', '', explode(',', $ip));\n\t\t\t} else {\n\t\t\t\t$ips[$variable] = $ip;\n\t\t\t}\n\t\t}\n\n\t\treturn $ips;\n\t}\n\n\tpublic static function getIPAndServerVariable($howGet = null, $trustedProxies = null) {\n\t\t$connectionIP = array_key_exists('REMOTE_ADDR', $_SERVER) ? array($_SERVER['REMOTE_ADDR'], 'REMOTE_ADDR') : array('127.0.0.1', 'REMOTE_ADDR');\n\n\t\tif ($howGet === null) {\n\t\t\t$howGet = wfConfig::get('howGetIPs', false);\n\t\t}\n\t\t\n\t\tif($howGet){\n\t\t\tif($howGet == 'REMOTE_ADDR'){\n\t\t\t\treturn self::getCleanIPAndServerVar(array($connectionIP), $trustedProxies);\n\t\t\t} else {\n\t\t\t\t$ipsToCheck = array(\n\t\t\t\t\tarray((isset($_SERVER[$howGet]) ? $_SERVER[$howGet] : ''), $howGet),\n\t\t\t\t\t$connectionIP,\n\t\t\t\t);\n\t\t\t\treturn self::getCleanIPAndServerVar($ipsToCheck, $trustedProxies);\n\t\t\t}\n\t\t} else {\n\t\t\t$ipsToCheck = array();\n\t\t\t\n\t\t\t$recommendedField = wfConfig::get('detectProxyRecommendation', ''); \/\/Prioritize the result from our proxy check if done\n\t\t\tif (!empty($recommendedField) && $recommendedField != 'UNKNOWN' && $recommendedField != 'DEFERRED') {\n\t\t\t\tif (isset($_SERVER[$recommendedField])) {\n\t\t\t\t\t$ipsToCheck[] = array($_SERVER[$recommendedField], $recommendedField);\n\t\t\t\t}\n\t\t\t}\n\t\t\t$ipsToCheck[] = $connectionIP;\n\t\t\tif (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) {\n\t\t\t\t$ipsToCheck[] = array($_SERVER['HTTP_X_FORWARDED_FOR'], 'HTTP_X_FORWARDED_FOR');\n\t\t\t}\n\t\t\tif (isset($_SERVER['HTTP_X_REAL_IP'])) {\n\t\t\t\t$ipsToCheck[] = array($_SERVER['HTTP_X_REAL_IP'], 'HTTP_X_REAL_IP');\n\t\t\t}\n\t\t\treturn self::getCleanIPAndServerVar($ipsToCheck, $trustedProxies);\n\t\t}\n\t\treturn false; \/\/Returns an array with a valid IP and the server variable, or false.\n\t}\n\tpublic static function getIPPreview($howGet = null, $trustedProxies = null) {\n\t\t$ip = self::getIPAndServerVariable($howGet, $trustedProxies);\n\t\tif (is_array($ip)) {\n\t\t\tlist($IP, $variable) = $ip;\n\t\t\tif (isset($_SERVER[$variable]) && strpos($_SERVER[$variable], ',') !== false) {\n\t\t\t\t$items = preg_replace('\/[\\s,]\/', '', explode(',', $_SERVER[$variable]));\n\t\t\t\t$output = '';\n\t\t\t\tforeach ($items as $i) {\n\t\t\t\t\tif ($IP == $i) {\n\t\t\t\t\t\t$output .= ', <strong>' . esc_html($i) . '<\/strong>';\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t$output .= ', ' . esc_html($i); \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn substr($output, 2);\n\t\t\t}\n\t\t\treturn '<strong>' . esc_html($IP) . '<\/strong>';\n\t\t}\n\t\treturn false;\n\t}\n\tpublic static function isValidIP($IP){\n\t\treturn filter_var($IP, FILTER_VALIDATE_IP) !== false;\n\t}\n\tpublic static function isValidCIDRRange($range) {\n\t\t$components = explode('\/', $range);\n\t\tif (count($components) != 2) { return false; }\n\t\t\n\t\tlist($ip, $prefix) = $components;\n\t\tif (!self::isValidIP($ip)) { return false; }\n\t\t\n\t\tif (!preg_match('\/^\\d+$\/', $prefix)) { return false; }\n\t\t\n\t\tif (filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4)) {\n\t\t\tif ($prefix < 0 || $prefix > 32) { return false; }\n\t\t}\n\t\telse {\n\t\t\tif ($prefix < 1 || $prefix > 128) { return false; }\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\tpublic static function isValidEmail($email, $strict = false) {\n\t\tif (empty($email)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t\/\/We don't default to strict, full validation because poorly-configured servers can crash due to the regex PHP uses in filter_var($email, FILTER_VALIDATE_EMAIL)\n\t\tif ($strict) {\n\t\t\treturn (filter_var($email, FILTER_VALIDATE_EMAIL) !== false);\n\t\t}\n\t\t\n\t\treturn preg_match('\/^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$\/i', $email) === 1;\n\t}\n\tpublic static function getRequestedURL() {\n\t\tif (isset($_SERVER['HTTP_HOST']) && $_SERVER['HTTP_HOST']) {\n\t\t\t$host = $_SERVER['HTTP_HOST'];\n\t\t} else if (isset($_SERVER['SERVER_NAME']) && $_SERVER['SERVER_NAME']) {\n\t\t\t$host = $_SERVER['SERVER_NAME'];\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t\t$prefix = 'http';\n\t\tif (is_ssl()) {\n\t\t\t$prefix = 'https';\n\t\t}\n\t\treturn $prefix . ':\/\/' . $host . $_SERVER['REQUEST_URI'];\n\t}\n\n\tpublic static function editUserLink($userID){\n\t\treturn get_admin_url() . 'user-edit.php?user_id=' . $userID;\n\t}\n\tpublic static function tmpl($file, $data){\n\t\textract($data);\n\t\tob_start();\n\t\tinclude dirname(__FILE__) . DIRECTORY_SEPARATOR . $file;\n\t\treturn ob_get_contents() . (ob_end_clean() ? \"\" : \"\");\n\t}\n\tpublic static function bigRandomHex(){\n\t\treturn bin2hex(wfWAFUtils::random_bytes(16));\n\t}\n\tpublic static function encrypt($str){\n\t\t$key = wfConfig::get('encKey');\n\t\tif(! $key){\n\t\t\twordfence::status(1, 'error', __(\"Wordfence error: No encryption key found!\", 'wordfence'));\n\t\t\treturn false;\n\t\t}\n\t\t$db = new wfDB();\n\t\treturn $db->querySingle(\"select HEX(AES_ENCRYPT('%s', '%s')) as val\", $str, $key);\n\t}\n\tpublic static function decrypt($str){\n\t\t$key = wfConfig::get('encKey');\n\t\tif(! $key){\n\t\t\twordfence::status(1, 'error', __(\"Wordfence error: No encryption key found!\", 'wordfence'));\n\t\t\treturn false;\n\t\t}\n\t\t$db = new wfDB();\n\t\treturn $db->querySingle(\"select AES_DECRYPT(UNHEX('%s'), '%s') as val\", $str, $key);\n\t}\n\tpublic static function lcmem(){\n\t\t$trace=debug_backtrace();\n\t\t$caller=array_shift($trace);\n\t\t$mem = memory_get_usage(true);\n\t\terror_log(\"$mem at \" . $caller['file'] . \" line \" . $caller['line']);\n\t}\n\tpublic static function logCaller(){\n\t\t$trace=debug_backtrace();\n\t\t$caller=array_shift($trace);\n\t\t$c2 = array_shift($trace);\n\t\terror_log(\"Caller for \" . $caller['file'] . \" line \" . $caller['line'] . \" is \" . $c2['file'] . ' line ' . $c2['line']);\n\t}\n\tpublic static function getWPVersion($forceRecheck = false){\n\t\tif ($forceRecheck) {\n\t\t\trequire(ABSPATH . 'wp-includes\/version.php'); \/\/defines $wp_version\n\t\t\treturn $wp_version;\n\t\t}\n\t\t\n\t\tif(wordfence::$wordfence_wp_version){\n\t\t\treturn wordfence::$wordfence_wp_version;\n\t\t} else {\n\t\t\tglobal $wp_version;\n\t\t\treturn $wp_version;\n\t\t}\n\t}\n\t\n\tpublic static function parse_version($version, $component = null) {\n\t\t$major = 0;\n\t\t$minor = 0;\n\t\t$patch = 0;\n\t\t$prerelease = '';\n\t\t$build = '';\n\t\t\n\t\tif (preg_match('\/^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$\/', $version, $matches)) { \/\/semver\n\t\t\t$major = $matches[1];\n\t\t\t$minor = $matches[2];\n\t\t\t$patch = $matches[3];\n\t\t\t\n\t\t\tif (preg_match('\/^([^\\+]+)\\+(.*)$\/', $version, $matches)) {\n\t\t\t\t$version = $matches[1];\n\t\t\t\t$build = $matches[2];\n\t\t\t}\n\t\t\t\n\t\t\tif (preg_match('\/^([^\\-]+)\\-(.*)$\/', $version, $matches)) {\n\t\t\t\t$version = $matches[1];\n\t\t\t\t$prerelease = $matches[2];\n\t\t\t}\n\t\t}\n\t\telse { \/\/Parse as \"PHP-standardized\" (see version_compare docs: \"The function first replaces _, - and + with a dot . in the version strings and also inserts dots . before and after any non number so that for example '4.3.2RC1' becomes '4.3.2.RC.1'.\")\n\t\t\t$version = trim(preg_replace('\/\\.\\.+\/', '.', preg_replace('\/([^0-9\\.]+)\/', '.$1.', preg_replace('\/[_\\-\\+]+\/', '.', $version))), '.');\n\t\t\t$components = explode('.', $version);\n\t\t\t$i = 0;\n\t\t\tif (isset($components[$i]) && is_numeric($components[$i])) { $major = $components[$i]; $i++; }\n\t\t\tif (isset($components[$i]) && is_numeric($components[$i])) { $minor = $components[$i]; $i++; }\n\t\t\tif (isset($components[$i]) && is_numeric($components[$i])) { $patch = $components[$i]; $i++; }\n\t\t\twhile (isset($components[$i]) && is_numeric($components[$i])) {\n\t\t\t\tif (!empty($build)) {\n\t\t\t\t\t$build .= '.';\n\t\t\t\t}\n\t\t\t\t$build .= $components[$i];\n\t\t\t\t$i++;\n\t\t\t}\n\t\t\twhile (isset($components[$i])) {\n\t\t\t\tif (!empty($prerelease)) {\n\t\t\t\t\t$prerelease .= '.';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (preg_match('\/^(?:dev|alpha|a|beta|b|rc|#|pl|p)$\/i', $components[$i])) {\n\t\t\t\t\t$prerelease .= strtolower($components[$i]);\n\t\t\t\t\tif (isset($components[$i + 1])) {\n\t\t\t\t\t\tif (!preg_match('\/^(?:a|b|rc|#|pl|p)$\/i', $components[$i])) {\n\t\t\t\t\t\t\t$prerelease .= '-';\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$i++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t$prerelease .= $components[$i];\n\t\t\t\t$i++;\n\t\t\t}\n\t\t}\n\t\t\n\t\t$version = array(\n\t\t\tself::VERSION_MAJOR => $major,\n\t\t\tself::VERSION_MINOR => $minor,\n\t\t\tself::VERSION_PATCH => $patch,\n\t\t\tself::VERSION_PRE_RELEASE => $prerelease,\n\t\t\tself::VERSION_BUILD => $build,\n\t\t);\n\t\t\n\t\t$version = array_filter($version, function($v) {\n\t\t\treturn $v !== '';\n\t\t});\n\t\t\n\t\tif ($component === null) {\n\t\t\treturn $version;\n\t\t}\n\t\telse if (isset($version[$component])) {\n\t\t\treturn $version[$component];\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\tpublic static function isAdminPageMU(){\n\t\tif(preg_match('\/^[\\\/a-zA-Z0-9\\-\\_\\s\\+\\~\\!\\^\\.]*\\\/wp-admin\\\/network\\\/\/', $_SERVER['REQUEST_URI'])){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic static function getSiteBaseURL(){\n\t\treturn rtrim(site_url(), '\/') . '\/';\n\t}\n\tpublic static function longestLine($data){\n\t\t$lines = preg_split('\/[\\r\\n]+\/', $data);\n\t\t$max = 0;\n\t\tforeach($lines as $line){\n\t\t\t$len = strlen($line);\n\t\t\tif($len > $max){\n\t\t\t\t$max = $len;\n\t\t\t}\n\t\t}\n\t\treturn $max;\n\t}\n\tpublic static function longestNospace($data){\n\t\t$lines = preg_split('\/[\\r\\n\\s\\t]+\/', $data);\n\t\t$max = 0;\n\t\tforeach($lines as $line){\n\t\t\t$len = strlen($line);\n\t\t\tif($len > $max){\n\t\t\t\t$max = $len;\n\t\t\t}\n\t\t}\n\t\treturn $max;\n\t}\n\t\n\t\/**\n\t * Returns the current PHP memory limit in bytes.\n\t * \n\t * Note: This is duplicated in wordfence.php to avoid needing to include this class early.\n\t * \n\t * @return int\n\t *\/\n\tpublic static function memoryLimit() {\n\t\t$maxMemory = ini_get('memory_limit');\n\t\tif (!(is_string($maxMemory) || is_numeric($maxMemory)) || !preg_match('\/^\\s*\\d+[GMK]?\\s*$\/i', $maxMemory)) { $maxMemory = '128M'; } \/\/Invalid or unreadable value, default to our minimum\n\t\t$last = strtolower(substr($maxMemory, -1));\n\t\t$maxMemory = (int) $maxMemory;\n\t\t\n\t\tif ($last == 'g') { $maxMemory = $maxMemory * 1024 * 1024 * 1024; }\n\t\telse if ($last == 'm') { $maxMemory = $maxMemory * 1024 * 1024; }\n\t\telse if ($last == 'k') { $maxMemory = $maxMemory * 1024; }\n\t\treturn floor($maxMemory);\n\t}\n\t\n\tpublic static function requestMaxMemory() {\n\t\t$maxMem = wfConfig::getInt('maxMem', 256);\n\t\tif ($maxMem <= 0) {\n\t\t\t$maxMem = 256;\n\t\t}\n\t\t\n\t\tif (self::funcEnabled('memory_get_usage') && self::memoryLimit() < ($maxMem * 1024 * 1024)){\n\t\t\tself::iniSet('memory_limit', $maxMem . 'M');\n\t\t}\n\t}\n\t\n\tpublic static function isAdmin($user = false){\n\t\tif($user){\n\t\t\tif(is_multisite()){\n\t\t\t\tif(user_can($user, 'manage_network')){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(user_can($user, 'manage_options')){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif(is_multisite()){\n\t\t\t\tif(current_user_can('manage_network')){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(current_user_can('manage_options')){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tpublic static function hasTwoFactorEnabled($user = false) {\n\t\tif (!$user) {\n\t\t\t$user = get_user_by('ID', get_current_user_id());\n\t\t}\n\t\t\n\t\tif (!$user) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t$twoFactorUsers = wfConfig::get_ser('twoFactorUsers', array());\n\t\t$hasActivatedTwoFactorUser = false;\n\t\tforeach ($twoFactorUsers as &$t) {\n\t\t\tif ($t[3] == 'activated') {\n\t\t\t\t$userID = $t[0];\n\t\t\t\tif ($userID == $user->ID && wfUtils::isAdmin($user)) {\n\t\t\t\t\t$hasActivatedTwoFactorUser = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $hasActivatedTwoFactorUser;\n\t}\n\tpublic static function isWindows(){\n\t\tif(! self::$isWindows){\n\t\t\tif(preg_match('\/^win\/i', PHP_OS)){\n\t\t\t\tself::$isWindows = 'yes';\n\t\t\t} else {\n\t\t\t\tself::$isWindows = 'no';\n\t\t\t}\n\t\t}\n\t\treturn self::$isWindows == 'yes' ? true : false;\n\t}\n\tpublic static function cleanupOneEntryPerLine($string) {\n\t\t$string = !is_string($string) ? '' : $string;\n\t\t$string = str_replace(\",\", \"\\n\", $string); \/\/ fix old format\n\t\treturn implode(\"\\n\", array_unique(array_filter(array_map('trim', explode(\"\\n\", $string)))));\n\t}\n\n\tpublic static function afterProcessingFile() {\n\t\tif (wfScanner::shared()->useLowResourceScanning()) {\n\t\t\tusleep(10000); \/\/10 ms\n\t\t}\n\t}\n\n\tpublic static function getScanLock(){\n\t\t\/\/Windows does not support non-blocking flock, so we use time.\n\t\t$scanRunning = wfConfig::get('wf_scanRunning');\n\t\tif($scanRunning && time() - $scanRunning < WORDFENCE_MAX_SCAN_LOCK_TIME){\n\t\t\treturn false;\n\t\t}\n\t\twfConfig::set('wf_scanRunning', time());\n\t\treturn true;\n\t}\n\tpublic static function clearScanLock(){\n\t\tglobal $wpdb;\n\t\t$wfdb = new wfDB();\n\t\t$wfdb->truncate(wfDB::networkTable('wfHoover'));\n\n\t\twfConfig::set('wf_scanRunning', '');\n\t\twfIssues::updateScanStillRunning(false);\n\t\tif (wfCentral::isConnected()) {\n\t\t\twfCentral::updateScanStatus();\n\t\t}\n\t}\n\tpublic static function getIPGeo($IP){ \/\/Works with int or dotted\n\n\t\t$locs = self::getIPsGeo(array($IP));\n\t\tif(isset($locs[$IP])){\n\t\t\treturn $locs[$IP];\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\tpublic static function getIPsGeo($IPs){ \/\/works with int or dotted. Outputs same format it receives.\n\t\t$IPs = array_unique($IPs);\n\t\t$toResolve = array();\n\t\t$db = new wfDB();\n\t\t$locsTable = wfDB::networkTable('wfLocs');\n\t\t$IPLocs = array();\n\t\tforeach($IPs as $IP){\n\t\t\t$isBinaryIP = !self::isValidIP($IP);\n\t\t\tif ($isBinaryIP) {\n\t\t\t\t$ip_printable = wfUtils::inet_ntop($IP);\n\t\t\t\t$ip_bin = $IP;\n\t\t\t} else {\n\t\t\t\t$ip_printable = $IP;\n\t\t\t\t$ip_bin = wfUtils::inet_pton($IP);\n\t\t\t}\n\t\t\t\n\t\t\t$ipHex = wfDB::binaryValueToSQLHex($ip_bin);\n\t\t\t$row = $db->querySingleRec(\"select IP, ctime, failed, city, region, countryName, countryCode, lat, lon, unix_timestamp() - ctime as age from \" . $locsTable . \" where IP={$ipHex}\");\n\t\t\tif($row){\n\t\t\t\tif($row['age'] > WORDFENCE_MAX_IPLOC_AGE){\n\t\t\t\t\t$ipHex = wfDB::binaryValueToSQLHex($row['IP']);\n\t\t\t\t\t$db->queryWrite(\"delete from \" . $locsTable . \" where IP={$ipHex}\");\n\t\t\t\t} else {\n\t\t\t\t\tif($row['failed'] == 1){\n\t\t\t\t\t\t$IPLocs[$ip_printable] = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$row['IP'] = self::inet_ntop($row['IP']);\n\t\t\t\t\t\t$row['region'] = wfUtils::shouldDisplayRegion($row['countryName']) ? $row['region'] : '';\n\t\t\t\t\t\t$IPLocs[$ip_printable] = $row;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(! isset($IPLocs[$ip_printable])){\n\t\t\t\t$toResolve[] = $ip_printable;\n\t\t\t}\n\t\t}\n\t\tif(sizeof($toResolve) > 0){\n\t\t\tif (wfConfig::get('enableRemoteIpLookup', true)) {\n\t\t\t\t$api = new wfAPI(wfConfig::get('apiKey'), wfUtils::getWPVersion());\n\t\t\t\ttry {\n\t\t\t\t\t$freshIPs = $api->call('resolve_ips', array(), array(\n\t\t\t\t\t\t'ips' => implode(',', $toResolve)\n\t\t\t\t\t\t));\n\t\t\t\t} catch(Exception $e){\n\t\t\t\t\twordfence::status(2, 'error', sprintf(\/* translators: Error message. *\/ __(\"Call to Wordfence API to resolve IPs failed: %s\", 'wordfence'), $e->getMessage()));\n\t\t\t\t\treturn array();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\trequire_once(__DIR__ . '\/wfIpLocator.php');\n\t\t\t\t$locator = wfIpLocator::getInstance();\n\t\t\t\t$freshIPs = array();\n\t\t\t\t$locale = get_locale();\n\t\t\t\tforeach ($toResolve as $ip) {\n\t\t\t\t\t$record = $locator->locate($ip);\n\t\t\t\t\tif ($record !== null) {\n\t\t\t\t\t\t$countryCode = $record->getCountryCode();\n\t\t\t\t\t\tif ($countryCode !== null) {\n\t\t\t\t\t\t\t$countryName = $record->getCountryName($locale);\n\t\t\t\t\t\t\tif ($countryName === null)\n\t\t\t\t\t\t\t\t$countryName = $countryCode;\n\t\t\t\t\t\t\t$freshIPs[$ip] = array($countryCode, $countryName);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t$freshIPs[$ip] = 'failed';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(is_array($freshIPs)){\n\t\t\t\tforeach($freshIPs as $IP => $value){\n\t\t\t\t\t$IP_bin = wfUtils::inet_pton($IP);\n\t\t\t\t\t$ipHex = wfDB::binaryValueToSQLHex($IP_bin);\n\t\t\t\t\tif($value == 'failed'){\n\t\t\t\t\t\t$db->queryWrite(\"insert IGNORE into \" . $locsTable . \" (IP, ctime, failed) values ({$ipHex}, unix_timestamp(), 1)\");\n\t\t\t\t\t\t$IPLocs[$IP] = false;\n\t\t\t\t\t} else if(is_array($value)){\n\t\t\t\t\t\tfor($i = 0; $i <= 5; $i++){\n\t\t\t\t\t\t\t\/\/Prevent warnings in debug mode about uninitialized values\n\t\t\t\t\t\t\tif(! isset($value[$i])){ $value[$i] = ''; }\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$db->queryWrite(\"insert IGNORE into \" . $locsTable . \" (IP, ctime, failed, city, region, countryName, countryCode, lat, lon) values ({$ipHex}, unix_timestamp(), 0, '%s', '%s', '%s', '%s', %s, %s)\",\n\t\t\t\t\t\t\t$value[3], \/\/city\n\t\t\t\t\t\t\t$value[2], \/\/region\n\t\t\t\t\t\t\t$value[1], \/\/countryName\n\t\t\t\t\t\t\t$value[0],\/\/countryCode\n\t\t\t\t\t\t\t$value[4],\/\/lat\n\t\t\t\t\t\t\t$value[5]\/\/lon\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t$IPLocs[$IP] = array(\n\t\t\t\t\t\t\t'IP' => $IP,\n\t\t\t\t\t\t\t'city' => $value[3],\n\t\t\t\t\t\t\t'region' => wfUtils::shouldDisplayRegion($value[1]) ? $value[2] : '',\n\t\t\t\t\t\t\t'countryName' => $value[1],\n\t\t\t\t\t\t\t'countryCode' => $value[0],\n\t\t\t\t\t\t\t'lat' => $value[4],\n\t\t\t\t\t\t\t'lon' => $value[5]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn $IPLocs;\n\t}\n\n\tpublic static function reverseLookup($IP) {\n\t\tstatic $_memoryCache = array();\n\t\tif (isset($_memoryCache[$IP])) {\n\t\t\treturn $_memoryCache[$IP];\n\t\t}\n\t\t\n\t\t$db = new wfDB();\n\t\t$reverseTable = wfDB::networkTable('wfReverseCache');\n\t\t$IPn = wfUtils::inet_pton($IP);\n\t\t$ipHex = wfDB::binaryValueToSQLHex($IPn);\n\t\t$host = $db->querySingle(\"select host from \" . $reverseTable . \" where IP={$ipHex} and unix_timestamp() - lastUpdate < %d\", WORDFENCE_REVERSE_LOOKUP_CACHE_TIME);\n\t\tif (!$host) {\n\t\t\t\/\/ This function works for IPv4 or IPv6\n\t\t\tif (function_exists('gethostbyaddr')) {\n\t\t\t\t$host = @gethostbyaddr($IP);\n\t\t\t}\n\t\t\tif (!$host) {\n\t\t\t\t$ptr = false;\n\t\t\t\tif (filter_var($IP, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4) !== false) {\n\t\t\t\t\t$ptr = implode(\".\", array_reverse(explode(\".\", $IP))) . \".in-addr.arpa\";\n\t\t\t\t} else if (filter_var($IP, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6) !== false) {\n\t\t\t\t\t$ptr = implode(\".\", array_reverse(str_split(bin2hex($IPn)))) . \".ip6.arpa\";\n\t\t\t\t}\n\n\t\t\t\tif ($ptr && function_exists('dns_get_record')) {\n\t\t\t\t\t$host = @dns_get_record($ptr, DNS_PTR);\n\t\t\t\t\tif ($host && is_array($host) && count($host)) {\n\t\t\t\t\t\t$host = wfUtils::array_get($host[0], 'target');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t$_memoryCache[$IP] = $host;\n\t\t\tif (!$host) {\n\t\t\t\t$host = 'NONE';\n\t\t\t}\n\t\t\t$db->queryWrite(\"insert into \" . $reverseTable . \" (IP, host, lastUpdate) values ({$ipHex}, '%s', unix_timestamp()) ON DUPLICATE KEY UPDATE host='%s', lastUpdate=unix_timestamp()\", $host, $host);\n\t\t}\n\t\tif ($host == 'NONE') {\n\t\t\t$_memoryCache[$IP] = '';\n\t\t\treturn '';\n\t\t} else {\n\t\t\t$_memoryCache[$IP] = $host;\n\t\t\treturn $host;\n\t\t}\n\t}\n\tpublic static function errorsOff(){\n\t\tself::$lastErrorReporting = @ini_get('error_reporting');\n\t\t@error_reporting(0);\n\t\tself::$lastDisplayErrors = @ini_get('display_errors');\n\t\tself::iniSet('display_errors', 0);\n\t\tif(class_exists('wfScan')){ wfScan::$errorHandlingOn = false; }\n\t}\n\tpublic static function errorsOn(){\n\t\t@error_reporting(self::$lastErrorReporting);\n\t\tself::iniSet('display_errors', self::$lastDisplayErrors);\n\t\tif(class_exists('wfScan')){ wfScan::$errorHandlingOn = true; }\n\t}\n\t\/\/Note this function may report files that are too big which actually are not too big but are unseekable and throw an error on fseek(). But that's intentional\n\tpublic static function fileTooBig($file, &$size = false, &$handle = false){ \/\/Deals with files > 2 gigs on 32 bit systems which are reported with the wrong size due to integer overflow\n\t\tif (!@is_file($file) || !@is_readable($file)) { return false; } \/\/Only apply to readable files\n\t\twfUtils::errorsOff();\n\t\t$fh = @fopen($file, 'rb');\n\t\twfUtils::errorsOn();\n\t\tif(! $fh){ return false; }\n\t\ttry {\n\t\t\tif(@fseek($fh, WORDFENCE_MAX_FILE_SIZE_OFFSET, SEEK_SET) === 0 && !empty(fread($fh, 1))){\n\t\t\t\treturn true;\n\t\t\t} \/\/Otherwise we couldn't seek there so it must be smaller\n\t\t\tif ($size !== false && @fseek($fh, 0, SEEK_END) === 0) {\n\t\t\t\t$size = @ftell($fh);\n\t\t\t\tif ($size === false)\n\t\t\t\t\t$size = 0; \/\/ Assume 0 if unable to determine file size\n\t\t\t}\n\t\t\treturn false;\n\t\t} catch(Exception $e){\n\t\t\treturn true; \/\/If we get an error don't scan this file, report it's too big.\n\t\t} finally {\n\t\t\tif ($handle === false) {\n\t\t\t\tfclose($fh);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$handle = $fh;\n\t\t\t}\n\t\t}\n\t}\n\tpublic static function fileOver2Gigs($file){ \/\/Surround calls to this func with try\/catch because fseek may throw error.\n\t\t$fh = @fopen($file, 'rb');\n\t\tif(! $fh){ return false; }\n\t\t$offset = 2147483647;\n\t\t$tooBig = false;\n\t\t\/\/My throw an error so surround calls to this func with try\/catch\n\t\tif(@fseek($fh, $offset, SEEK_SET) === 0){\n\t\t\tif(strlen(fread($fh, 1)) === 1){\n\t\t\t\t$tooBig = true;\n\t\t\t}\n\t\t} \/\/Otherwise we couldn't seek there so it must be smaller\n\t\t@fclose($fh);\n\t\treturn $tooBig;\n\t}\n\tpublic static function countryCode2Name($code){\n\t\trequire(dirname(__FILE__) . '\/wfBulkCountries.php'); \/** @var array $wfBulkCountries *\/\n\t\tif(isset($wfBulkCountries[$code])){\n\t\t\treturn $wfBulkCountries[$code];\n\t\t} else {\n\t\t\treturn '';\n\t\t}\n\t}\n\tpublic static function shouldDisplayRegion($country) {\n\t\t$countries_to_show_for = array('united states', 'canada', 'australia');\n\t\treturn in_array(strtolower($country), $countries_to_show_for);\n\t}\n\tpublic static function extractBareURI($URL){\n\t\t$URL = preg_replace('\/^https?:\\\/\\\/[^\\\/]+\/i', '', $URL); \/\/strip of method and host\n\t\t$URL = preg_replace('\/\\#.*$\/', '', $URL); \/\/strip off fragment\n\t\t$URL = preg_replace('\/\\?.*$\/', '', $URL); \/\/strip off query string\n\t\treturn $URL;\n\t}\n\tpublic static function requireIpLocator() {\n\t\t\/**\n\t\t * This is also used in the WAF so in certain site setups (i.e. nested sites in subdirectories)\n\t\t * it's possible for this to already have been loaded from a different installation of the\n\t\t * plugin and hence require_once doesn't help as it's a different file path. There is no guarantee\n\t\t * that the two plugin installations are the same version, so should the wfIpLocator class or any\n\t\t * of its dependencies change in a manner that is not backwards compatible, this may need to be\n\t\t * handled differently.\n\t\t *\/\n\t\tif (!class_exists('wfIpLocator'))\n\t\t\trequire_once(__DIR__ . '\/wfIpLocator.php');\n\t}\n\tpublic static function IP2Country($ip){\n\t\tself::requireIpLocator();\n\t\treturn wfIpLocator::getInstance()->getCountryCode($ip);\n\t}\n\tpublic static function geoIPVersion() {\n\t\tself::requireIpLocator();\n\t\t$version = wfIpLocator::getInstance()->getDatabaseVersion();\n\t\treturn $version === null ? 0 : $version;\n\t}\n\tpublic static function siteURLRelative(){\n\t\tif(is_multisite()){\n\t\t\t$URL = network_site_url();\n\t\t} else {\n\t\t\t$URL = site_url();\n\t\t}\n\t\t$URL = preg_replace('\/^https?:\\\/\\\/[^\\\/]+\/i', '', $URL);\n\t\t$URL = rtrim($URL, '\/') . '\/';\n\t\treturn $URL;\n\t}\n\tpublic static function localHumanDate(){\n\t\treturn date('l jS \\of F Y \\a\\t h:i:s A', time() + (3600 * get_option('gmt_offset')));\n\t}\n\tpublic static function localHumanDateShort(){\n\t\treturn date('D jS F \\@ h:i:sA', time() + (3600 * get_option('gmt_offset')));\n\t}\n\tpublic static function funcEnabled($func){\n\t\tif (!function_exists($func)){ return false; }\n\t\tif (!is_callable($func)) { return false; }\n\t\t$disabled = explode(',', ini_get('disable_functions'));\n\t\tif (in_array($func, $disabled)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\tpublic static function iniSet($key, $val){\n\t\tif(self::funcEnabled('ini_set')){\n\t\t\t@ini_set($key, $val);\n\t\t}\n\t}\n\tpublic static function doNotCache(){\n\t\theader(\"Pragma: no-cache\");\n\t\theader(\"Cache-Control: no-cache, must-revalidate, private, max-age=0\");\n\t\theader(\"Expires: Sat, 26 Jul 1997 05:00:00 GMT\"); \/\/In the past\n\t\tif(! defined('DONOTCACHEPAGE')){ define('DONOTCACHEPAGE', true); }\n\t\tif(! defined('DONOTCACHEDB')){ define('DONOTCACHEDB', true); }\n\t\tif(! defined('DONOTCDN')){ define('DONOTCDN', true); }\n\t\tif(! defined('DONOTCACHEOBJECT')){ define('DONOTCACHEOBJECT', true); }\n\t\twfCache::doNotCache();\n\t}\n\tpublic static function isUABlocked($uaPattern){ \/\/ takes a pattern using asterisks as wildcards, turns it into regex and checks it against the visitor UA returning true if blocked\n\t\treturn fnmatch($uaPattern, !empty($_SERVER['HTTP_USER_AGENT']) ? $_SERVER['HTTP_USER_AGENT'] : '', FNM_CASEFOLD);\n\t}\n\tpublic static function isRefererBlocked($refPattern){\n\t\treturn fnmatch($refPattern, !empty($_SERVER['HTTP_REFERER']) ? $_SERVER['HTTP_REFERER'] : '', FNM_CASEFOLD);\n\t}\n\t\n\tpublic static function error_clear_last() {\n\t\tif (function_exists('error_clear_last')) {\n\t\t\terror_clear_last();\n\t\t}\n\t\telse {\n\t\t\t\/\/ set error_get_last() to defined state by forcing an undefined variable error\n\t\t\tset_error_handler('wfUtils::_resetErrorsHandler', 0);\n\t\t\t@$undefinedVariable;\n\t\t\trestore_error_handler();\n\t\t}\n\t}\n\t\n\t\/**\n\t * Logs the error given or the last PHP error to our log, rate limiting if needed.\n\t * \n\t * @param string $limiter_key\n\t * @param string $label\n\t * @param null|string $error The error to log. If null, it will be the result of error_get_last\n\t * @param int $rate Logging will only occur once per $rate seconds.\n\t *\/\n\tpublic static function check_and_log_last_error($limiter_key, $label, $error = null, $rate = 3600 \/* 1 hour *\/) {\n\t\tif ($error === null) {\n\t\t\t$error = error_get_last();\n\t\t\tif ($error === null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if ($error['file'] === __FILE__) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t$error = $error['message'];\n\t\t}\n\t\t\n\t\t$rateKey = 'lastError_rate_' . $limiter_key;\n\t\t$previousKey = 'lastError_prev_' . $limiter_key;\n\t\t$previousError = wfConfig::getJSON($previousKey, array(0, false));\n\t\tif ($previousError[1] != $error) {\n\t\t\tif (wfConfig::getInt($rateKey) < time() - $rate) {\n\t\t\t\twfConfig::set($rateKey, time());\n\t\t\t\twfConfig::setJSON($previousKey, array(time(), $error));\n\t\t\t\twordfence::status(2, 'error', $label . ' ' . $error);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static function last_error($limiter_key) {\n\t\t$previousKey = 'lastError_prev_' . $limiter_key;\n\t\t$previousError = wfConfig::getJSON($previousKey, array(0, false));\n\t\tif ($previousError[1]) {\n\t\t\treturn wfUtils::formatLocalTime(get_option('date_format') . ' ' . get_option('time_format'), $previousError[0]) . ': ' . $previousError[1];\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic static function _resetErrorsHandler($errno, $errstr, $errfile, $errline) {\n\t\t\/\/Do nothing\n\t}\n\n\t\/**\n\t * @param $startIP\n\t * @param $endIP\n\t * @return array\n\t *\/\n\tpublic static function rangeToCIDRs($startIP, $endIP){\n\t\t$start_ip_printable = wfUtils::inet_ntop($startIP);\n\t\tif (filter_var($start_ip_printable, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4)) {\n\t\t\treturn self::rangeToCIDRsIPv4(current(unpack('N', substr($startIP, 12, 4))), current(unpack('N', substr($endIP, 12, 4))));\n\t\t}\n\t\t$startIPBin = str_pad(wfHelperBin::bin2str($startIP), 128, '0', STR_PAD_LEFT);\n\t\t$endIPBin = str_pad(wfHelperBin::bin2str($endIP), 128, '0', STR_PAD_LEFT);\n\t\t$IPIncBin = $startIPBin;\n\t\t$CIDRs = array();\n\t\twhile (strcmp($IPIncBin, $endIPBin) <= 0) {\n\t\t\t$longNetwork = 128;\n\t\t\t$IPNetBin = $IPIncBin;\n\t\t\twhile (($IPIncBin[$longNetwork - 1] == '0') && (strcmp(substr_replace($IPNetBin, '1', $longNetwork - 1, 1), $endIPBin) <= 0)) {\n\t\t\t\t$IPNetBin[$longNetwork - 1] = '1';\n\t\t\t\t$longNetwork--;\n\t\t\t}\n\t\t\t$CIDRs[] = self::inet_ntop(str_pad(wfHelperBin::str2bin($IPIncBin), 16, \"\\x00\", STR_PAD_LEFT)) . ($longNetwork < 128 ? '\/' . $longNetwork : '');\n\t\t\t$IPIncBin = str_pad(wfHelperBin::bin2str(wfHelperBin::addbin2bin(chr(1), wfHelperBin::str2bin($IPNetBin))), 128, '0', STR_PAD_LEFT);\n\t\t}\n\t\treturn $CIDRs;\n\t}\n\n\tpublic static function rangeToCIDRsIPv4($startIP, $endIP){\n\t\t$startIPBin = sprintf('%032b', $startIP);\n\t\t$endIPBin = sprintf('%032b', $endIP);\n\t\t$IPIncBin = $startIPBin;\n\t\t$CIDRs = array();\n\t\twhile(strcmp($IPIncBin, $endIPBin) <= 0){\n\t\t\t$longNetwork = 32;\n\t\t\t$IPNetBin = $IPIncBin;\n\t\t\twhile(($IPIncBin[$longNetwork - 1] == '0') && (strcmp(substr_replace($IPNetBin, '1', $longNetwork - 1, 1), $endIPBin) <= 0)){\n\t\t\t\t$IPNetBin[$longNetwork - 1] = '1';\n\t\t\t\t$longNetwork--;\n\t\t\t}\n\t\t\t$CIDRs[] = long2ip(bindec($IPIncBin)) . ($longNetwork < 32 ? '\/' . $longNetwork : '');\n\t\t\t$IPIncBin = sprintf('%032b', bindec($IPNetBin) + 1);\n\t\t}\n\t\treturn $CIDRs;\n\t}\n\t\n\t\/**\n\t * This is a convenience function for sending a JSON response and ensuring that execution stops after sending\n\t * since wp_die() can be interrupted.\n\t * \n\t * @param $response\n\t * @param int|null $status_code\n\t *\/\n\tpublic static function send_json($response, $status_code = null) {\n\t\twp_send_json($response, $status_code);\n\t\tdie();\n\t}\n\n\tpublic static function setcookie($name, $value = '', $expire = 0, $path = '', $domain = '', $secure = false, $httpOnly = false) {\n\t\tif (empty($path)) { $path = COOKIEPATH; }\n\t\tif (empty($domain)) { $domain = COOKIE_DOMAIN; }\n\t\tif (version_compare(PHP_VERSION, '5.2.0') >= 0) {\n\t\t\tsetcookie($name, $value, $expire, $path, $domain, $secure, $httpOnly);\n\t\t}\n\t\telse {\n\t\t\tsetcookie($name, $value, $expire, $path);\n\t\t}\n\t}\n\tpublic static function isNginx(){\n\t\t$sapi = php_sapi_name();\n\t\t$serverSoft = $_SERVER['SERVER_SOFTWARE'];\n\t\tif($sapi == 'fpm-fcgi' && stripos($serverSoft, 'nginx') !== false){\n\t\t\treturn true;\n\t\t}\n\t}\n\tpublic static function getLastError(){\n\t\t$err = error_get_last();\n\t\tif(is_array($err)){\n\t\t\treturn $err['message'];\n\t\t}\n\t\treturn '';\n\t}\n\tpublic static function hostNotExcludedFromProxy($url){\n\t\tif(! defined('WP_PROXY_BYPASS_HOSTS')){\n\t\t\treturn true; \/\/No hosts are excluded\n\t\t}\n\t\t$hosts = explode(',', WP_PROXY_BYPASS_HOSTS);\n\t\t$url = preg_replace('\/^https?:\\\/\\\/\/i', '', $url);\n\t\t$url = preg_replace('\/\\\/.*$\/', '', $url);\n\t\t$url = strtolower($url);\n\t\tforeach($hosts as $h){\n\t\t\tif(strtolower(trim($h)) == $url){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tpublic static function hasXSS($URL){\n\t\tif(! preg_match('\/^https?:\\\/\\\/[a-z0-9\\.\\-]+\\\/[^\\':<>\\\"\\\\\\]*$\/i', $URL)){\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t\/**\n\t * @param string $host\n\t * @return array\n\t *\/\n\tpublic static function resolveDomainName($host, $ipVersion = null) {\n\t\tif (!function_exists('dns_get_record')) {\n\t\t\tif ($ipVersion === 4 || $ipVersion === null) {\n\t\t\t\t$ips = gethostbynamel($host);\n\t\t\t\tif ($ips !== false)\n\t\t\t\t\treturn $ips;\n\t\t\t}\n\t\t\treturn array();\n\t\t}\n\t\t$recordTypes = array();\n\t\tif ($ipVersion === 4 || $ipVersion === null)\n\t\t\t$recordTypes[DNS_A] = 'ip';\n\t\tif ($ipVersion === 6 || $ipVersion === null)\n\t\t\t$recordTypes[DNS_AAAA] = 'ipv6';\n\t\t$ips = array();\n\t\tforeach ($recordTypes as $type => $key) {\n\t\t\t$records = @dns_get_record($host, $type);\n\t\t\tif ($records !== false && is_array($records)) {\n\t\t\t\tforeach ($records as $record) {\n\t\t\t\t\tif (array_key_exists($key, $record)) {\n\t\t\t\t\t\t$ips[] = $record[$key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn $ips;\n\t}\n\n\t\/**\n\t * Expand a compressed printable representation of an IPv6 address.\n\t *\n\t * @param string $ip\n\t * @return string\n\t *\/\n\tpublic static function expandIPv6Address($ip) {\n\t\t$hex = bin2hex(self::inet_pton($ip));\n\t\t$ip = substr(preg_replace(\"\/([a-f0-9]{4})\/i\", \"$1:\", $hex), 0, -1);\n\t\treturn $ip;\n\t}\n\n\tpublic static function set_html_content_type() {\n\t\treturn 'text\/html';\n\t}\n\n\tpublic static function htmlEmail($to, $subject, $body) {\n\t\tadd_filter( 'wp_mail_content_type', 'wfUtils::set_html_content_type' );\n\t\t$result = wp_mail($to, $subject, $body);\n\t\tremove_filter( 'wp_mail_content_type', 'wfUtils::set_html_content_type' );\n\t\treturn $result;\n\t}\n\n\t\/**\n\t * @param string $readmePath\n\t * @return bool\n\t *\/\n\tpublic static function hideReadme($readmePath = null) {\n\t\tif ($readmePath === null) {\n\t\t\t$readmePath = ABSPATH . 'readme.html';\n\t\t}\n\n\t\tif (file_exists($readmePath)) {\n\t\t\t$readmePathInfo = pathinfo($readmePath);\n\t\t\trequire_once(ABSPATH . WPINC . '\/pluggable.php');\n\t\t\t$hiddenReadmeFile = $readmePathInfo['filename'] . '.' . wp_hash('readme') . '.' . $readmePathInfo['extension'];\n\t\t\treturn @rename($readmePath, $readmePathInfo['dirname'] . '\/' . $hiddenReadmeFile);\n\t\t}\n\t\treturn false;\n\t}\n\n\t\/**\n\t * @param string $readmePath\n\t * @return bool\n\t *\/\n\tpublic static function showReadme($readmePath = null) {\n\t\tif ($readmePath === null) {\n\t\t\t$readmePath = ABSPATH . 'readme.html';\n\t\t}\n\t\t$readmePathInfo = pathinfo($readmePath);\n\t\trequire_once(ABSPATH . WPINC . '\/pluggable.php');\n\t\t$hiddenReadmeFile = $readmePathInfo['dirname'] . '\/' . $readmePathInfo['filename'] . '.' . wp_hash('readme') . '.' . $readmePathInfo['extension'];\n\t\tif (file_exists($hiddenReadmeFile)) {\n\t\t\treturn @rename($hiddenReadmeFile, $readmePath);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static function htaccessAppend($code)\n\t{\n\t\t$htaccess = wfCache::getHtaccessPath();\n\t\t$content  = self::htaccess();\n\t\tif (wfUtils::isNginx() || !is_writable($htaccess)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (strpos($content, $code) === false) {\n\t\t\t\/\/ make sure we write this once\n\t\t\tfile_put_contents($htaccess, $content . \"\\n\" . trim($code), LOCK_EX);\n\t\t}\n\n\t\treturn true;\n\t}\n\t\n\tpublic static function htaccessPrepend($code)\n\t{\n\t\t$htaccess = wfCache::getHtaccessPath();\n\t\t$content  = self::htaccess();\n\t\tif (wfUtils::isNginx() || !is_writable($htaccess)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (strpos($content, $code) === false) {\n\t\t\t\/\/ make sure we write this once\n\t\t\tfile_put_contents($htaccess, trim($code) . \"\\n\" . $content, LOCK_EX);\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\n\tpublic static function htaccess() {\n\t\t$htaccess = wfCache::getHtaccessPath();\n\t\tif (is_readable($htaccess) && !wfUtils::isNginx()) {\n\t\t\treturn file_get_contents($htaccess);\n\t\t}\n\t\treturn \"\";\n\t}\n\n\t\/**\n\t * @param array $array\n\t * @param mixed $oldKey\n\t * @param mixed $newKey\n\t * @return array\n\t * @throws Exception\n\t *\/\n\tpublic static function arrayReplaceKey($array, $oldKey, $newKey) {\n\t\t$keys = array_keys($array);\n\t\tif (($index = array_search($oldKey, $keys)) === false) {\n\t\t\tthrow new Exception(sprintf('Key \"%s\" does not exist', $oldKey));\n\t\t}\n\t\t$keys[$index] = $newKey;\n\t\treturn array_combine($keys, array_values($array));\n\t}\n\t\n\t\/**\n\t * Takes a string that may have characters that will be interpreted as invalid UTF-8 byte sequences and translates them into a string of the equivalent hex sequence.\n\t * \n\t * @param $string\n\t * @param bool $inline\n\t * @return string\n\t *\/\n\tpublic static function potentialBinaryStringToHTML($string, $inline = false, $allowmb4 = false) {\n\t\t$output = '';\n\t\t\n\t\tif (!defined('ENT_SUBSTITUTE')) {\n\t\t\tdefine('ENT_SUBSTITUTE', 0);\n\t\t}\n\t\t\n\t\t$span = '<span class=\"wf-hex-sequence\">';\n\t\tif ($inline) {\n\t\t\t$span = '<span style=\"color:#587ECB\">';\n\t\t}\n\t\t\n\t\tfor ($i = 0; $i < wfUtils::strlen($string); $i++) {\n\t\t\t$c = $string[$i];\n\t\t\t$b = ord($c);\n\t\t\tif ($b < 0x20) {\n\t\t\t\t$output .= $span . '\\x' . str_pad(dechex($b), 2, '0', STR_PAD_LEFT) . '<\/span>';\n\t\t\t}\n\t\t\telse if ($b < 0x80) {\n\t\t\t\t$output .= htmlspecialchars($c, ENT_QUOTES, 'ISO-8859-1');\n\t\t\t}\n\t\t\telse { \/\/Assume multi-byte UTF-8\n\t\t\t\t$bytes = 0;\n\t\t\t\t$test = $b;\n\t\t\t\t\n\t\t\t\twhile (($test & 0x80) > 0) {\n\t\t\t\t\t$bytes++;\n\t\t\t\t\t$test = (($test << 1) & 0xff);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t$brokenUTF8 = ($i + $bytes > wfUtils::strlen($string) || $bytes == 1);\n\t\t\t\tif (!$brokenUTF8) { \/\/Make sure we have all the bytes\n\t\t\t\t\tfor ($n = 1; $n < $bytes; $n++) {\n\t\t\t\t\t\t$c2 = $string[$i + $n];\n\t\t\t\t\t\t$b2 = ord($c2);\n\t\t\t\t\t\tif (($b2 & 0xc0) != 0x80) {\n\t\t\t\t\t\t\t$brokenUTF8 = true;\n\t\t\t\t\t\t\t$bytes = $n;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!$brokenUTF8) { \/\/Ensure the byte sequences are within the accepted ranges: https:\/\/tools.ietf.org\/html\/rfc3629\n\t\t\t\t\t\/*\n\t\t\t\t\t * UTF8-octets = *( UTF8-char )\n   \t\t\t\t\t * UTF8-char   = UTF8-1 \/ UTF8-2 \/ UTF8-3 \/ UTF8-4\n   \t\t\t\t\t * UTF8-1      = %x00-7F\n   \t\t\t\t\t * UTF8-2      = %xC2-DF UTF8-tail\n   \t\t\t\t\t * UTF8-3      = %xE0 %xA0-BF UTF8-tail \/ %xE1-EC 2( UTF8-tail ) \/\n   \t\t\t\t\t *               %xED %x80-9F UTF8-tail \/ %xEE-EF 2( UTF8-tail )\n   \t\t\t\t\t * UTF8-4      = %xF0 %x90-BF 2( UTF8-tail ) \/ %xF1-F3 3( UTF8-tail ) \/\n   \t\t\t\t\t *               %xF4 %x80-8F 2( UTF8-tail )\n   \t\t\t\t\t * UTF8-tail   = %x80-BF\n\t\t\t\t\t *\/\n\t\t\t\t\t\n\t\t\t\t\t$testString = wfUtils::substr($string, $i, $bytes);\n\t\t\t\t\t$regex = '\/^(?:' .\n\t\t\t\t\t\t'[\\xc2-\\xdf][\\x80-\\xbf]' . \/\/UTF8-2\n\t\t\t\t\t\t'|' . '\\xe0[\\xa0-\\xbf][\\x80-\\xbf]' . \/\/UTF8-3\n\t\t\t\t\t\t'|' . '[\\xe1-\\xec][\\x80-\\xbf]{2}' .\n\t\t\t\t\t\t'|' . '\\xed[\\x80-\\x9f][\\x80-\\xbf]' .\n\t\t\t\t\t\t'|' . '[\\xee-\\xef][\\x80-\\xbf]{2}';\n\t\t\t\t\tif ($allowmb4) {\n\t\t\t\t\t\t$regex .= '|' . '\\xf0[\\x90-\\xbf][\\x80-\\xbf]{2}' . \/\/UTF8-4\n\t\t\t\t\t\t\t'|' . '[\\xf1-\\xf3][\\x80-\\xbf]{3}' .\n\t\t\t\t\t\t\t'|' . '\\xf4[\\x80-\\x8f][\\x80-\\xbf]{2}';\n\t\t\t\t\t}\n\t\t\t\t\t$regex  .= ')$\/';\n\t\t\t\t\tif (!preg_match($regex, $testString)) {\n\t\t\t\t\t\t$brokenUTF8 = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ($brokenUTF8) {\n\t\t\t\t\t$bytes = min($bytes, strlen($string) - $i);\n\t\t\t\t\tfor ($n = 0; $n < $bytes; $n++) {\n\t\t\t\t\t\t$c2 = $string[$i + $n];\n\t\t\t\t\t\t$b2 = ord($c2);\n\t\t\t\t\t\t$output .= $span . '\\x' . str_pad(dechex($b2), 2, '0', STR_PAD_LEFT) . '<\/span>';\n\t\t\t\t\t}\n\t\t\t\t\t$i += ($bytes - 1);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$output .= htmlspecialchars(wfUtils::substr($string, $i, $bytes), ENT_QUOTES | ENT_SUBSTITUTE, 'ISO-8859-1');\n\t\t\t\t\t$i += ($bytes - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn $output;\n\t}\n\t\n\tpublic static function requestDetectProxyCallback($timeout = 2, $blocking = true, $forceCheck = false) {\n\t\t$currentRecommendation = wfConfig::get('detectProxyRecommendation', '');\n\t\tif (!$forceCheck) {\n\t\t\t$detectProxyNextCheck = wfConfig::get('detectProxyNextCheck', false);\n\t\t\tif ($detectProxyNextCheck !== false && time() < $detectProxyNextCheck) {\n\t\t\t\tif (empty($currentRecommendation)) {\n\t\t\t\t\twfConfig::set('detectProxyRecommendation', 'DEFERRED', wfConfig::DONT_AUTOLOAD);\n\t\t\t\t}\n\t\t\t\treturn; \/\/Let it pull the currently-stored value\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\t$waf = wfWAF::getInstance();\n\t\t\tif ($waf->getStorageEngine()->getConfig('attackDataKey', false) === false) {\n\t\t\t\t$waf->getStorageEngine()->setConfig('attackDataKey', mt_rand(0, 0xfff));\n\t\t\t}\n\t\t\t$response = wp_remote_get(sprintf(WFWAF_API_URL_SEC . \"proxy-check\/%d.txt\", $waf->getStorageEngine()->getConfig('attackDataKey')), array('headers' => array('Referer' => false)));\n\t\t\t\n\t\t\tif (!is_wp_error($response)) {\n\t\t\t\t$okToSendBody = wp_remote_retrieve_body($response);\n\t\t\t\tif (preg_match('\/^(ok|wait),\\s*(\\d+)$\/i', $okToSendBody, $matches)) {\n\t\t\t\t\t$command = $matches[1];\n\t\t\t\t\t$ttl = $matches[2];\n\t\t\t\t\tif ($command == 'wait') {\n\t\t\t\t\t\twfConfig::set('detectProxyNextCheck', time() + $ttl, wfConfig::DONT_AUTOLOAD);\n\t\t\t\t\t\tif (empty($currentRecommendation) || $currentRecommendation == 'UNKNOWN') {\n\t\t\t\t\t\t\twfConfig::set('detectProxyRecommendation', 'DEFERRED', wfConfig::DONT_AUTOLOAD);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\twfConfig::set('detectProxyNextCheck', time() + $ttl, wfConfig::DONT_AUTOLOAD);\n\t\t\t\t}\n\t\t\t\telse { \/\/Unknown response\n\t\t\t\t\twfConfig::set('detectProxyNextCheck', false, wfConfig::DONT_AUTOLOAD);\n\t\t\t\t\tif (empty($currentRecommendation) || $currentRecommendation == 'UNKNOWN') {\n\t\t\t\t\t\twfConfig::set('detectProxyRecommendation', 'DEFERRED', wfConfig::DONT_AUTOLOAD);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception $e) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t$nonce = bin2hex(wfWAFUtils::random_bytes(32));\n\t\t$callback = self::getSiteBaseURL() . '?_wfsf=detectProxy';\n\t\t\n\t\twfConfig::set('detectProxyNonce', $nonce, wfConfig::DONT_AUTOLOAD);\n\t\twfConfig::set('detectProxyRecommendation', '', wfConfig::DONT_AUTOLOAD);\n\t\t\n\t\t$payload = array(\n\t\t\t'nonce' => $nonce,\n\t\t\t'callback' => $callback,\n\t\t);\n\t\t\n\t\t$homeurl = wfUtils::wpHomeURL();\n\t\t$siteurl = wfUtils::wpSiteURL();\n\t\t\n\t\ttry {\n\t\t\t$response = wp_remote_post(WFWAF_API_URL_SEC . \"?\" . http_build_query(array(\n\t\t\t\t\t'action' => 'detect_proxy',\n\t\t\t\t\t'k'      => wfConfig::get('apiKey'),\n\t\t\t\t\t's'      => $siteurl,\n\t\t\t\t\t'h'\t\t => $homeurl,\n\t\t\t\t\t't'\t\t => microtime(true),\n\t\t\t\t\t'lang'   => get_site_option('WPLANG'),\n\t\t\t\t), '', '&'),\n\t\t\t\tarray(\n\t\t\t\t\t'body'    => json_encode($payload),\n\t\t\t\t\t'headers' => array(\n\t\t\t\t\t\t'Content-Type' => 'application\/json',\n\t\t\t\t\t\t'Referer' => false,\n\t\t\t\t\t),\n\t\t\t\t\t'timeout' => $timeout,\n\t\t\t\t\t'blocking' => $blocking,\n\t\t\t\t));\n\t\t\n\t\t\tif (!is_wp_error($response)) {\n\t\t\t\t$jsonResponse = wp_remote_retrieve_body($response);\n\t\t\t\t$decoded = @json_decode($jsonResponse, true);\n\t\t\t\tif (is_array($decoded) && isset($decoded['data']) && is_array($decoded['data']) && isset($decoded['data']['ip']) && wfUtils::isValidIP($decoded['data']['ip'])) {\n\t\t\t\t\twfConfig::set('serverIP', time() . ';' . $decoded['data']['ip']);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception $e) {\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\t\/**\n\t * @return bool Returns false if the payload is invalid, true if it processed the callback (even if the IP wasn't found).\n\t *\/\n\tpublic static function processDetectProxyCallback() {\n\t\t$nonce = wfConfig::get('detectProxyNonce', '');\n\t\t$testNonce = (isset($_POST['nonce']) ? $_POST['nonce'] : '');\n\t\tif (empty($nonce) || empty($testNonce)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!hash_equals($nonce, $testNonce)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t$ips = (isset($_POST['ips']) ? $_POST['ips'] : array());\n\t\tif (empty($ips)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t$expandedIPs = array();\n\t\tforeach ($ips as $ip) {\n\t\t\t$expandedIPs[] = self::inet_pton($ip);\n\t\t}\n\t\t\n\t\t$checks = array('HTTP_CF_CONNECTING_IP', 'HTTP_X_REAL_IP', 'REMOTE_ADDR', 'HTTP_X_FORWARDED_FOR');\n\t\tforeach ($checks as $key) {\n\t\t\tif (!isset($_SERVER[$key])) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t$testIP = self::getCleanIPAndServerVar(array(array($_SERVER[$key], $key)));\n\t\t\tif ($testIP === false) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t$testIP = self::inet_pton($testIP[0]);\n\t\t\tif (in_array($testIP, $expandedIPs)) {\n\t\t\t\twfConfig::set('detectProxyRecommendation', $key, wfConfig::DONT_AUTOLOAD);\n\t\t\t\twfConfig::set('detectProxyNonce', '', wfConfig::DONT_AUTOLOAD);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\twfConfig::set('detectProxyRecommendation', 'UNKNOWN', wfConfig::DONT_AUTOLOAD);\n\t\twfConfig::set('detectProxyNonce', '', wfConfig::DONT_AUTOLOAD);\n\t\treturn true;\n\t}\n\t\n\t\/**\n\t * Returns a v4 UUID.\n\t * \n\t * @return string\n\t *\/\n\tpublic static function uuid() {\n\t\treturn sprintf('%04x%04x-%04x-%04x-%04x-%04x%04x%04x',\n\t\t\t\/\/ 32 bits for \"time_low\"\n\t\t\twfWAFUtils::random_int(0, 0xffff), wfWAFUtils::random_int(0, 0xffff),\n\t\t\t\n\t\t\t\/\/ 16 bits for \"time_mid\"\n\t\t\twfWAFUtils::random_int(0, 0xffff),\n\t\t\t\n\t\t\t\/\/ 16 bits for \"time_hi_and_version\",\n\t\t\t\/\/ four most significant bits holds version number 4\n\t\t\twfWAFUtils::random_int(0, 0x0fff) | 0x4000,\n\t\t\t\n\t\t\t\/\/ 16 bits, 8 bits for \"clk_seq_hi_res\",\n\t\t\t\/\/ 8 bits for \"clk_seq_low\",\n\t\t\t\/\/ two most significant bits holds zero and one for variant DCE1.1\n\t\t\twfWAFUtils::random_int(0, 0x3fff) | 0x8000,\n\t\t\t\n\t\t\t\/\/ 48 bits for \"node\"\n\t\t\twfWAFUtils::random_int(0, 0xffff), wfWAFUtils::random_int(0, 0xffff), wfWAFUtils::random_int(0, 0xffff)\n\t\t);\n\t}\n\t\n\tpublic static function base32_encode($rawString, $rightPadFinalBits = false, $padFinalGroup = false, $padCharacter = '=') \/\/Adapted from https:\/\/github.com\/ademarre\/binary-to-text-php\n\t{\n\t\t\/\/ Unpack string into an array of bytes\n\t\t$bytes = unpack('C*', $rawString);\n\t\t$byteCount = count($bytes);\n\t\t\n\t\t$encodedString = '';\n\t\t$byte = array_shift($bytes);\n\t\t$bitsRead = 0;\n\t\t$oldBits = 0;\n\t\t\n\t\t$chars             = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';\n\t\t$bitsPerCharacter  = 5;\n\t\t\n\t\t$charsPerByte = 8 \/ $bitsPerCharacter;\n\t\t$encodedLength = $byteCount * $charsPerByte;\n\t\t\n\t\t\/\/ Generate encoded output; each loop produces one encoded character\n\t\tfor ($c = 0; $c < $encodedLength; $c++) {\n\t\t\t\n\t\t\t\/\/ Get the bits needed for this encoded character\n\t\t\tif ($bitsRead + $bitsPerCharacter > 8) {\n\t\t\t\t\/\/ Not enough bits remain in this byte for the current character\n\t\t\t\t\/\/ Save the remaining bits before getting the next byte\n\t\t\t\t$oldBitCount = 8 - $bitsRead;\n\t\t\t\t$oldBits = $byte ^ ($byte >> $oldBitCount << $oldBitCount);\n\t\t\t\t$newBitCount = $bitsPerCharacter - $oldBitCount;\n\t\t\t\t\n\t\t\t\tif (!$bytes) {\n\t\t\t\t\t\/\/ Last bits; match final character and exit loop\n\t\t\t\t\tif ($rightPadFinalBits) $oldBits <<= $newBitCount;\n\t\t\t\t\t$encodedString .= $chars[$oldBits];\n\t\t\t\t\t\n\t\t\t\t\tif ($padFinalGroup) {\n\t\t\t\t\t\t\/\/ Array of the lowest common multiples of $bitsPerCharacter and 8, divided by 8\n\t\t\t\t\t\t$lcmMap = array(1 => 1, 2 => 1, 3 => 3, 4 => 1, 5 => 5, 6 => 3, 7 => 7, 8 => 1);\n\t\t\t\t\t\t$bytesPerGroup = $lcmMap[$bitsPerCharacter];\n\t\t\t\t\t\t$pads = $bytesPerGroup * $charsPerByte - ceil((strlen($rawString) % $bytesPerGroup) * $charsPerByte);\n\t\t\t\t\t\t$encodedString .= str_repeat($padCharacter, $pads);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\/\/ Get next byte\n\t\t\t\t$byte = array_shift($bytes);\n\t\t\t\t$bitsRead = 0;\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t$oldBitCount = 0;\n\t\t\t\t$newBitCount = $bitsPerCharacter;\n\t\t\t}\n\t\t\t\n\t\t\t\/\/ Read only the needed bits from this byte\n\t\t\t$bits = $byte >> 8 - ($bitsRead + ($newBitCount));\n\t\t\t$bits ^= $bits >> $newBitCount << $newBitCount;\n\t\t\t$bitsRead += $newBitCount;\n\t\t\t\n\t\t\tif ($oldBitCount) {\n\t\t\t\t\/\/ Bits come from seperate bytes, add $oldBits to $bits\n\t\t\t\t$bits = ($oldBits << $newBitCount) | $bits;\n\t\t\t}\n\t\t\t\n\t\t\t$encodedString .= $chars[$bits];\n\t\t}\n\t\t\n\t\treturn $encodedString;\n\t}\n\t\n\tprivate static function _home_url_nofilter($path = '', $scheme = null) { \/\/A version of the native get_home_url and get_option without the filter calls\n\t\tglobal $pagenow, $wpdb, $blog_id;\n\t\t\n\t\tstatic $cached_url = null;\n\t\tif ($cached_url !== null) {\n\t\t\treturn $cached_url;\n\t\t}\n\t\t\n\t\tif (defined('WP_HOME') && WORDFENCE_PREFER_WP_HOME_FOR_WPML) {\n\t\t\t$cached_url = WP_HOME;\n\t\t\treturn $cached_url;\n\t\t}\n\t\t\n\t\tif ( empty( $blog_id ) || !is_multisite() ) {\n\t\t\t$url = $wpdb->get_var(\"SELECT option_value FROM {$wpdb->options} WHERE option_name = 'home' LIMIT 1\");\n\t\t\tif (empty($url)) { \/\/get_option uses siteurl instead if home is empty\n\t\t\t\t$url = $wpdb->get_var(\"SELECT option_value FROM {$wpdb->options} WHERE option_name = 'siteurl' LIMIT 1\");\n\t\t\t}\n\t\t}\n\t\telse if (is_multisite()) {\n\t\t\t$current_network = get_network();\n\t\t\tif ( 'relative' == $scheme )\n\t\t\t\t$url = rtrim($current_network->path, '\/');\n\t\t\telse\n\t\t\t\t$url = 'http:\/\/' . rtrim($current_network->domain, '\/') . '\/' . trim($current_network->path, '\/');\n\t\t}\n\t\t\n\t\tif ( ! in_array( $scheme, array( 'http', 'https', 'relative' ) ) ) {\n\t\t\tif ( is_ssl() && ! is_admin() && 'wp-login.php' !== $pagenow )\n\t\t\t\t$scheme = 'https';\n\t\t\telse\n\t\t\t\t$scheme = parse_url( $url, PHP_URL_SCHEME );\n\t\t}\n\t\t\n\t\t$url = set_url_scheme( $url, $scheme );\n\t\t\n\t\tif ( $path && is_string( $path ) )\n\t\t\t$url .= '\/' . ltrim( $path, '\/' );\n\t\t\n\t\t$cached_url = $url;\n\t\treturn $url;\n\t}\n\t\n\tpublic static function refreshCachedHomeURL() {\n\t\t$pullDirectly = class_exists('WPML_URL_Filters');\n\t\t$homeurl = '';\n\t\tif ($pullDirectly) {\n\t\t\t\/\/A version of the native get_home_url without the filter call\n\t\t\t$homeurl = self::_home_url_nofilter();\n\t\t}\n\t\t\n\t\tif (function_exists('get_bloginfo') && empty($homeurl)) {\n\t\t\tif (is_multisite()) {\n\t\t\t\t$homeurl = network_home_url();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$homeurl = home_url();\n\t\t\t}\n\t\t\t\n\t\t\t$homeurl = rtrim($homeurl, '\/'); \/\/Because previously we used get_bloginfo and it returns http:\/\/example.com without a '\/' char.\n\t\t}\n\t\t\n\t\tif (wfConfig::get('wp_home_url') !== $homeurl) {\n\t\t\twfConfig::set('wp_home_url', $homeurl);\n\t\t}\n\t}\n\t\n\tpublic static function wpHomeURL($path = '', $scheme = null) {\n\t\t$homeurl = wfConfig::get('wp_home_url', '');\n\t\tif (function_exists('get_bloginfo') && empty($homeurl)) {\n\t\t\tif (is_multisite()) {\n\t\t\t\t$homeurl = network_home_url($path, $scheme);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$homeurl = home_url($path, $scheme);\n\t\t\t}\n\t\t\t\n\t\t\t$homeurl = rtrim($homeurl, '\/'); \/\/Because previously we used get_bloginfo and it returns http:\/\/example.com without a '\/' char.\n\t\t}\n\t\telse {\n\t\t\t$homeurl = set_url_scheme($homeurl, $scheme);\n\t\t\tif ($path && is_string($path)) {\n\t\t\t\t$homeurl .= '\/' . ltrim($path, '\/');\n\t\t\t}\n\t\t}\n\t\treturn $homeurl;\n\t}\n\t\n\tprivate static function _site_url_nofilter($path = '', $scheme = null) { \/\/A version of the native get_site_url and get_option without the filter calls\n\t\tglobal $pagenow, $wpdb, $blog_id;\n\t\t\n\t\tstatic $cached_url = null;\n\t\tif ($cached_url !== null) {\n\t\t\treturn $cached_url;\n\t\t}\n\t\t\n\t\tif (defined('WP_SITEURL') && WORDFENCE_PREFER_WP_HOME_FOR_WPML) {\n\t\t\t$cached_url = WP_SITEURL;\n\t\t\treturn $cached_url;\n\t\t}\n\t\t\n\t\tif ( empty( $blog_id ) || !is_multisite() ) {\n\t\t\t$url = $wpdb->get_var(\"SELECT option_value FROM {$wpdb->options} WHERE option_name = 'siteurl' LIMIT 1\");\n\t\t}\n\t\telse if (is_multisite()) {\n\t\t\t$current_network = get_network();\n\t\t\tif ( 'relative' == $scheme )\n\t\t\t\t$url = rtrim($current_network->path, '\/');\n\t\t\telse\n\t\t\t\t$url = 'http:\/\/' . rtrim($current_network->domain, '\/') . '\/' . trim($current_network->path, '\/');\n\t\t}\n\t\t\n\t\tif ( ! in_array( $scheme, array( 'http', 'https', 'relative' ) ) ) {\n\t\t\tif ( is_ssl() && ! is_admin() && 'wp-login.php' !== $pagenow )\n\t\t\t\t$scheme = 'https';\n\t\t\telse\n\t\t\t\t$scheme = parse_url( $url, PHP_URL_SCHEME );\n\t\t}\n\t\t\n\t\t$url = set_url_scheme( $url, $scheme );\n\t\t\n\t\tif ( $path && is_string( $path ) )\n\t\t\t$url .= '\/' . ltrim( $path, '\/' );\n\t\t\n\t\t$cached_url = $url;\n\t\treturn $url;\n\t}\n\t\n\tpublic static function refreshCachedSiteURL() {\n\t\t$pullDirectly = class_exists('WPML_URL_Filters');\n\t\t$siteurl = '';\n\t\tif ($pullDirectly) {\n\t\t\t\/\/A version of the native get_home_url without the filter call\n\t\t\t$siteurl = self::_site_url_nofilter();\n\t\t}\n\t\t\n\t\tif (function_exists('get_bloginfo') && empty($siteurl)) {\n\t\t\tif (is_multisite()) {\n\t\t\t\t$siteurl = network_site_url();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$siteurl = site_url();\n\t\t\t}\n\t\t\t\n\t\t\t$siteurl = rtrim($siteurl, '\/'); \/\/Because previously we used get_bloginfo and it returns http:\/\/example.com without a '\/' char.\n\t\t}\n\t\t\n\t\tif (wfConfig::get('wp_site_url') !== $siteurl) {\n\t\t\twfConfig::set('wp_site_url', $siteurl);\n\t\t}\n\t}\n\t\n\t\/**\n\t * Equivalent to network_site_url but uses the cached value for the URL if we have it\n\t * to avoid breaking on sites that define it based on the requesting hostname.\n\t * \n\t * @param string $path\n\t * @param null|string $scheme\n\t * @return string\n\t *\/\n\tpublic static function wpSiteURL($path = '', $scheme = null) {\n\t\t$siteurl = wfConfig::get('wp_site_url', '');\n\t\tif (function_exists('get_bloginfo') && empty($siteurl)) {\n\t\t\tif (is_multisite()) {\n\t\t\t\t$siteurl = network_site_url($path, $scheme);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$siteurl = site_url($path, $scheme);\n\t\t\t}\n\t\t\t\n\t\t\t$siteurl = rtrim($siteurl, '\/'); \/\/Because previously we used get_bloginfo and it returns http:\/\/example.com without a '\/' char.\n\t\t}\n\t\telse {\n\t\t\t$siteurl = set_url_scheme($siteurl, $scheme);\n\t\t\tif ($path && is_string($path)) {\n\t\t\t\t$siteurl .= '\/' . ltrim($path, '\/');\n\t\t\t}\n\t\t}\n\t\treturn $siteurl;\n\t}\n\t\n\t\/**\n\t * Equivalent to network_admin_url but uses the cached value for the URL if we have it\n\t * to avoid breaking on sites that define it based on the requesting hostname.\n\t *\n\t * @param string $path\n\t * @param null|string $scheme\n\t * @return string\n\t *\/\n\tpublic static function wpAdminURL($path = '', $scheme = null) {\n\t\tif (!is_multisite()) {\n\t\t\t$adminURL = self::wpSiteURL('wp-admin\/', $scheme);\n\t\t}\n\t\telse {\n\t\t\t$adminURL = self::wpSiteURL('wp-admin\/network\/', $scheme);\n\t\t}\n\t\t\n\t\tif ($path && is_string($path)) {\n\t\t\t$adminURL .= ltrim($path, '\/');\n\t\t}\n\t\t\n\t\tif (!is_multisite()) {\n\t\t\treturn apply_filters('admin_url', $adminURL, $path, null);\n\t\t}\n\t\t\n\t\treturn apply_filters('network_admin_url', $adminURL, $path);\n\t}\n\t\n\tpublic static function wafInstallationType() {\n\t\t$storage = 'file';\n\t\tif (defined('WFWAF_STORAGE_ENGINE')) { $storage = WFWAF_STORAGE_ENGINE; }\n\t\t\n\t\ttry {\n\t\t\t$status = (defined('WFWAF_ENABLED') && !WFWAF_ENABLED) ? 'disabled' : wfWaf::getInstance()->getStorageEngine()->getConfig('wafStatus');\n\t\t\tif (defined('WFWAF_ENABLED') && !WFWAF_ENABLED) {\n\t\t\t\treturn \"{$status}|const|{$storage}\";\n\t\t\t}\n\t\t\telse if (defined('WFWAF_SUBDIRECTORY_INSTALL') && WFWAF_SUBDIRECTORY_INSTALL) {\n\t\t\t\treturn \"{$status}|subdir|{$storage}\";\n\t\t\t}\n\t\t\telse if (defined('WFWAF_AUTO_PREPEND') && WFWAF_AUTO_PREPEND) {\n\t\t\t\treturn \"{$status}|extended|{$storage}\";\n\t\t\t}\n\t\t\t\n\t\t\treturn \"{$status}|basic|{$storage}\";\n\t\t}\n\t\tcatch (Exception $e) {\n\t\t\t\/\/Do nothing\n\t\t}\n\t\t\n\t\treturn 'unknown';\n\t}\n\t\n\tpublic static function hex2bin($string) { \/\/Polyfill for PHP < 5.4\n\t\tif (!is_string($string)) { return false; }\n\t\tif (strlen($string) % 2 == 1) { return false; }\n\t\treturn pack('H*', $string);\n\t}\n\t\n\t\/**\n\t * Returns whether or not the site should be treated as if it's full-time SSL.\n\t * \n\t * @return bool\n\t *\/\n\tpublic static function isFullSSL() {\n\t\treturn is_ssl() && parse_url(self::wpHomeURL(), PHP_URL_SCHEME) === 'https'; \/\/It's possible for only wp-admin to be SSL so we check the home URL too\n\t}\n\n\t\/**\n\t * Identical to the same functions in wfWAFUtils.\n\t * \n\t * Set the mbstring internal encoding to a binary safe encoding when func_overload\n\t * is enabled.\n\t *\n\t * When mbstring.func_overload is in use for multi-byte encodings, the results from\n\t * strlen() and similar functions respect the utf8 characters, causing binary data\n\t * to return incorrect lengths.\n\t *\n\t * This function overrides the mbstring encoding to a binary-safe encoding, and\n\t * resets it to the users expected encoding afterwards through the\n\t * `reset_mbstring_encoding` function.\n\t *\n\t * It is safe to recursively call this function, however each\n\t * `mbstring_binary_safe_encoding()` call must be followed up with an equal number\n\t * of `reset_mbstring_encoding()` calls.\n\t *\n\t * @see wfWAFUtils::reset_mbstring_encoding\n\t *\n\t * @staticvar array $encodings\n\t * @staticvar bool  $overloaded\n\t *\n\t * @param bool $reset Optional. Whether to reset the encoding back to a previously-set encoding.\n\t *                    Default false.\n\t *\/\n\tpublic static function mbstring_binary_safe_encoding($reset = false) {\n\t\tstatic $encodings = array();\n\t\tstatic $overloaded = null;\n\t\t\n\t\tif (is_null($overloaded)) {\n\t\t\t\/\/ phpcs:ignore PHPCompatibility.IniDirectives.RemovedIniDirectives.mbstring_func_overloadDeprecated\n\t\t\t$overloaded = function_exists('mb_internal_encoding') && (ini_get('mbstring.func_overload') & 2);\n\t\t}\n\t\t\n\t\tif (false === $overloaded) { return; }\n\t\t\n\t\tif (!$reset) {\n\t\t\t$encoding = mb_internal_encoding();\n\t\t\tarray_push($encodings, $encoding);\n\t\t\tmb_internal_encoding('ISO-8859-1');\n\t\t}\n\t\t\n\t\tif ($reset && $encodings) {\n\t\t\t$encoding = array_pop($encodings);\n\t\t\tmb_internal_encoding($encoding);\n\t\t}\n\t}\n\t\n\t\/**\n\t * Reset the mbstring internal encoding to a users previously set encoding.\n\t *\n\t * @see wfWAFUtils::mbstring_binary_safe_encoding\n\t *\/\n\tpublic static function reset_mbstring_encoding() {\n\t\tself::mbstring_binary_safe_encoding(true);\n\t}\n\t\n\t\/**\n\t * @param callable $function\n\t * @param array $args\n\t * @return mixed\n\t *\/\n\tprotected static function callMBSafeStrFunction($function, $args) {\n\t\tself::mbstring_binary_safe_encoding();\n\t\t$return = call_user_func_array($function, $args);\n\t\tself::reset_mbstring_encoding();\n\t\treturn $return;\n\t}\n\t\n\t\/**\n\t * Multibyte safe strlen.\n\t *\n\t * @param $binary\n\t * @return int\n\t *\/\n\tpublic static function strlen($binary) {\n\t\t$args = func_get_args();\n\t\treturn self::callMBSafeStrFunction('strlen', $args);\n\t}\n\t\n\t\/**\n\t * @param $haystack\n\t * @param $needle\n\t * @param int $offset\n\t * @return int\n\t *\/\n\tpublic static function stripos($haystack, $needle, $offset = 0) {\n\t\t$args = func_get_args();\n\t\treturn self::callMBSafeStrFunction('stripos', $args);\n\t}\n\t\n\t\/**\n\t * @param $string\n\t * @return mixed\n\t *\/\n\tpublic static function strtolower($string) {\n\t\t$args = func_get_args();\n\t\treturn self::callMBSafeStrFunction('strtolower', $args);\n\t}\n\t\n\t\/**\n\t * @param $string\n\t * @param $start\n\t * @param $length\n\t * @return mixed\n\t *\/\n\tpublic static function substr($string, $start, $length = null) {\n\t\tif ($length === null) { $length = self::strlen($string); }\n\t\treturn self::callMBSafeStrFunction('substr', array(\n\t\t\t$string, $start, $length\n\t\t));\n\t}\n\t\n\t\/**\n\t * @param $haystack\n\t * @param $needle\n\t * @param int $offset\n\t * @return mixed\n\t *\/\n\tpublic static function strpos($haystack, $needle, $offset = 0) {\n\t\t$args = func_get_args();\n\t\treturn self::callMBSafeStrFunction('strpos', $args);\n\t}\n\t\n\t\/**\n\t * @param string $haystack\n\t * @param string $needle\n\t * @param int $offset\n\t * @param int $length\n\t * @return mixed\n\t *\/\n\tpublic static function substr_count($haystack, $needle, $offset = 0, $length = null) {\n\t\tif ($length === null) { $length = self::strlen($haystack); }\n\t\treturn self::callMBSafeStrFunction('substr_count', array(\n\t\t\t$haystack, $needle, $offset, $length\n\t\t));\n\t}\n\t\n\t\/**\n\t * @param $string\n\t * @return mixed\n\t *\/\n\tpublic static function strtoupper($string) {\n\t\t$args = func_get_args();\n\t\treturn self::callMBSafeStrFunction('strtoupper', $args);\n\t}\n\t\n\t\/**\n\t * @param string $haystack\n\t * @param string $needle\n\t * @param int $offset\n\t * @return mixed\n\t *\/\n\tpublic static function strrpos($haystack, $needle, $offset = 0) {\n\t\t$args = func_get_args();\n\t\treturn self::callMBSafeStrFunction('strrpos', $args);\n\t}\n\t\n\tpublic static function sets_equal($a1, $a2) {\n\t\tif (!is_array($a1) || !is_array($a2)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (count($a1) != count($a2)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tsort($a1, SORT_NUMERIC);\n\t\tsort($a2, SORT_NUMERIC);\n\t\treturn $a1 == $a2;\n\t}\n\t\n\tpublic static function array_first($array) {\n\t\tif (empty($array)) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t$values = array_values($array);\n\t\treturn $values[0];\n\t}\n\t\n\tpublic static function array_last($array) {\n\t\tif (empty($array)) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t$values = array_values($array);\n\t\treturn $values[count($values) - 1];\n\t}\n\t\n\tpublic static function array_strtolower($array) {\n\t\t$result = array();\n\t\tforeach ($array as $a) {\n\t\t\t$result[] = strtolower($a);\n\t\t}\n\t\treturn $result;\n\t}\n\t\n\tpublic static function array_column($input = null, $columnKey = null, $indexKey = null) { \/\/Polyfill from https:\/\/github.com\/ramsey\/array_column\/blob\/master\/src\/array_column.php\n\t\t$argc = func_num_args();\n\t\t$params = func_get_args();\n\t\tif ($argc < 2) {\n\t\t\ttrigger_error(\"array_column() expects at least 2 parameters, {$argc} given\", E_USER_WARNING);\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tif (!is_array($params[0])) {\n\t\t\ttrigger_error(\n\t\t\t\t'array_column() expects parameter 1 to be array, ' . gettype($params[0]) . ' given',\n\t\t\t\tE_USER_WARNING\n\t\t\t);\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tif (!is_int($params[1]) && !is_float($params[1]) && !is_string($params[1]) && $params[1] !== null && !(is_object($params[1]) && method_exists($params[1], '__toString'))) {\n\t\t\ttrigger_error('array_column(): The column key should be either a string or an integer', E_USER_WARNING);\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (isset($params[2]) && !is_int($params[2]) && !is_float($params[2]) && !is_string($params[2]) && !(is_object($params[2]) && method_exists($params[2], '__toString'))) {\n\t\t\ttrigger_error('array_column(): The index key should be either a string or an integer', E_USER_WARNING);\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t$paramsInput = $params[0];\n\t\t$paramsColumnKey = ($params[1] !== null) ? (string) $params[1] : null;\n\t\t$paramsIndexKey = null;\n\t\tif (isset($params[2])) {\n\t\t\tif (is_float($params[2]) || is_int($params[2])) {\n\t\t\t\t$paramsIndexKey = (int) $params[2];\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$paramsIndexKey = (string) $params[2];\n\t\t\t}\n\t\t}\n\t\t\n\t\t$resultArray = array();\n\t\tforeach ($paramsInput as $row) {\n\t\t\t$key = $value = null;\n\t\t\t$keySet = $valueSet = false;\n\t\t\tif ($paramsIndexKey !== null && array_key_exists($paramsIndexKey, $row)) {\n\t\t\t\t$keySet = true;\n\t\t\t\t$key = (string) $row[$paramsIndexKey];\n\t\t\t}\n\t\t\t\n\t\t\tif ($paramsColumnKey === null) {\n\t\t\t\t$valueSet = true;\n\t\t\t\t$value = $row;\n\t\t\t}\n\t\t\telseif (is_array($row) && array_key_exists($paramsColumnKey, $row)) {\n\t\t\t\t$valueSet = true;\n\t\t\t\t$value = $row[$paramsColumnKey];\n\t\t\t}\n\t\t\t\n\t\t\tif ($valueSet) {\n\t\t\t\tif ($keySet) {\n\t\t\t\t\t$resultArray[$key] = $value;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$resultArray[] = $value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $resultArray;\n\t}\n\t\n\t\/**\n\t * Returns $string if it isn't empty, $ifEmpty if it is.\n\t * \n\t * @param string $string\n\t * @param string $ifEmpty\n\t * @return string\n\t *\/\n\tpublic static function string_empty($string, $ifEmpty) {\n\t\tif (empty($string)) {\n\t\t\treturn $ifEmpty;\n\t\t}\n\t\treturn $string;\n\t}\n\t\n\t\/**\n\t * Returns the current timestamp, adjusted as needed to get close to what we consider a true timestamp. We use this\n\t * because a significant number of servers are using a drastically incorrect time.\n\t *\n\t * @return int\n\t *\/\n\tpublic static function normalizedTime($base = false) {\n\t\tif ($base === false) {\n\t\t\t$base = time();\n\t\t}\n\t\t\n\t\t$offset = (int) wfConfig::get('timeoffset_wf', 0);\n\t\treturn $base + $offset;\n\t}\n\t\n\t\/**\n\t * Returns what we consider a true timestamp, adjusted as needed to match the local server's drift. We use this\n\t * because a significant number of servers are using a drastically incorrect time.\n\t *\n\t * @return int\n\t *\/\n\tpublic static function denormalizedTime($base) {\n\t\t$offset = (int) wfConfig::get('timeoffset_wf', 0);\n\t\treturn $base - $offset;\n\t}\n\t\n\t\/**\n\t * Returns the number of minutes for the time zone offset from UTC. If $timestamp and using a named time zone, \n\t * it will be adjusted automatically to match whether or not the server's time zone is in Daylight Savings Time.\n\t * \n\t * @param bool|int $timestamp Assumed to be in UTC. If false, defaults to the current timestamp.\n\t * @return int\n\t *\/\n\tpublic static function timeZoneMinutes($timestamp = false) {\n\t\tif ($timestamp === false) {\n\t\t\t$timestamp = time();\n\t\t}\n\t\t\n\t\t$tz = get_option('timezone_string');\n\t\tif (!empty($tz)) {\n\t\t\t$timezone = new DateTimeZone($tz);\n\t\t\t$dtStr = gmdate(\"c\", (int) $timestamp); \/\/Have to do it this way because of PHP 5.2\n\t\t\t$dt = new DateTime($dtStr, $timezone);\n\t\t\treturn (int) ($timezone->getOffset($dt) \/ 60);\n\t\t}\n\t\telse {\n\t\t\t$gmt = get_option('gmt_offset');\n\t\t\tif (!empty($gmt)) {\n\t\t\t\treturn (int) ($gmt * 60);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn 0;\n\t}\n\t\n\t\/**\n\t * Formats and returns the given timestamp using the time zone set for the WordPress installation.\n\t * \n\t * @param string $format See the PHP docs on DateTime for the format options. \n\t * @param int|bool $timestamp Assumed to be in UTC. If false, defaults to the current timestamp.\n\t * @return string\n\t *\/\n\tpublic static function formatLocalTime($format, $timestamp = false) {\n\t\tif ($timestamp === false) {\n\t\t\t$timestamp = time();\n\t\t}\n\t\t\n\t\t$utc = new DateTimeZone('UTC');\n\t\t$dtStr = gmdate(\"c\", (int) $timestamp); \/\/Have to do it this way because of PHP 5.2\n\t\t$dt = new DateTime($dtStr, $utc);\n\t\t$tz = get_option('timezone_string');\n\t\tif (!empty($tz)) {\n\t\t\t$dt->setTimezone(new DateTimeZone($tz));\n\t\t}\n\t\telse {\n\t\t\t$gmt = get_option('gmt_offset');\n\t\t\tif (!empty($gmt)) {\n\t\t\t\tif (PHP_VERSION_ID < 50510) {\n\t\t\t\t\t$dtStr = gmdate(\"c\", (int) ($timestamp + $gmt * 3600)); \/\/Have to do it this way because of < PHP 5.5.10\n\t\t\t\t\t$dt = new DateTime($dtStr, $utc);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$direction = ($gmt > 0 ? '+' : '-');\n\t\t\t\t\t$gmt = abs($gmt);\n\t\t\t\t\t$h = (int) $gmt;\n\t\t\t\t\t$m = ($gmt - $h) * 60;\n\t\t\t\t\t$dt->setTimezone(new DateTimeZone($direction . str_pad($h, 2, '0', STR_PAD_LEFT) . str_pad($m, 2, '0', STR_PAD_LEFT)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn $dt->format($format);\n\t}\n\t\n\t\/**\n\t * Parses the given time string and returns its DateTime with the server's configured time zone.\n\t * \n\t * @param string $timestring\n\t * @return DateTime\n\t *\/\n\tpublic static function parseLocalTime($timestring) {\n\t\t$utc = new DateTimeZone('UTC');\n\t\t$tz = get_option('timezone_string');\n\t\tif (!empty($tz)) {\n\t\t\t$tz = new DateTimeZone($tz);\n\t\t\treturn new DateTime($timestring, $tz);\n\t\t}\n\t\telse {\n\t\t\t$gmt = get_option('gmt_offset');\n\t\t\tif (!empty($gmt)) {\n\t\t\t\tif (PHP_VERSION_ID < 50510) {\n\t\t\t\t\t$timestamp = strtotime($timestring);\n\t\t\t\t\t$dtStr = gmdate(\"c\", (int) ($timestamp + $gmt * 3600)); \/\/Have to do it this way because of < PHP 5.5.10\n\t\t\t\t\treturn new DateTime($dtStr, $utc);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$direction = ($gmt > 0 ? '+' : '-');\n\t\t\t\t\t$gmt = abs($gmt);\n\t\t\t\t\t$h = (int) $gmt;\n\t\t\t\t\t$m = ($gmt - $h) * 60;\n\t\t\t\t\t$tz = new DateTimeZone($direction . str_pad($h, 2, '0', STR_PAD_LEFT) . str_pad($m, 2, '0', STR_PAD_LEFT));\n\t\t\t\t\treturn new DateTime($timestring, $tz);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new DateTime($timestring);\n\t}\n\t\n\t\/**\n\t * Base64URL-encodes the given payload. This is identical to base64_encode except it substitutes characters\n\t * not safe for use in URLs.\n\t * \n\t * @param string $payload\n\t * @return string\n\t *\/\n\tpublic static function base64url_encode($payload) {\n\t\t$intermediate = base64_encode($payload);\n\t\t$intermediate = rtrim($intermediate, '=');\n\t\t$intermediate = str_replace('+', '-', $intermediate);\n\t\t$intermediate = str_replace('\/', '_', $intermediate);\n\t\treturn $intermediate;\n\t}\n\t\n\t\/**\n\t * Base64URL-decodes the given payload. This is identical to base64_encode except it allows for the characters\n\t * substituted by base64url_encode.\n\t * \n\t * @param string $payload\n\t * @return string\n\t *\/\n\tpublic static function base64url_decode($payload) {\n\t\t$intermediate = str_replace('_', '\/', $payload);\n\t\t$intermediate = str_replace('-', '+', $intermediate);\n\t\t$intermediate = base64_decode($intermediate);\n\t\treturn $intermediate;\n\t}\n\t\n\t\/**\n\t * Returns a signed JWT for the given payload. Payload is expected to be an array suitable for JSON-encoding.\n\t * \n\t * @param array $payload\n\t * @param int $maxAge How long the JWT will be considered valid.\n\t * @return string\n\t *\/\n\tpublic static function generateJWT($payload, $maxAge = 604800 \/* 7 days *\/) {\n\t\t$payload['_exp'] = time() + $maxAge;\n\t\t$key = wfConfig::get('longEncKey');\n\t\t$header = '{\"alg\":\"HS256\",\"typ\":\"JWT\"}';\n\t\t$body = self::base64url_encode($header) . '.' . self::base64url_encode(json_encode($payload));\n\t\t$signature = hash_hmac('sha256', $body, $key, true);\n\t\treturn $body . '.' . self::base64url_encode($signature);\n\t}\n\t\n\t\/**\n\t * Decodes and returns the payload of a JWT. This also validates the signature.\n\t * \n\t * @param string $token\n\t * @return array|bool The decoded payload or false if the token is invalid or fails validation.\n\t *\/\n\tpublic static function decodeJWT($token) {\n\t\t$components = explode('.', $token);\n\t\tif (count($components) != 3) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t$key = wfConfig::get('longEncKey');\n\t\t$body = $components[0] . '.' . $components[1];\n\t\t$signature = hash_hmac('sha256', $body, $key, true);\n\t\t$testSignature = self::base64url_decode($components[2]);\n\t\tif (!hash_equals($signature, $testSignature)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t$json = self::base64url_decode($components[1]);\n\t\t$payload = @json_decode($json, true);\n\t\tif (!is_array($payload) || (isset($payload['_exp']) && $payload['_exp'] < time())) {\n\t\t\treturn false;\n\t\t}\n\t\treturn $payload;\n\t}\n\n\t\/**\n\t * Split a path into its components\n\t * @param string $path\n\t *\/\n\tpublic static function splitPath($path) {\n\t\treturn preg_split('\/[\\\\\/\\\\\\\\]\/', $path, -1, PREG_SPLIT_NO_EMPTY);\n\t}\n\n\t\/**\n\t * Convert an absolute path to a path relative to $to\n\t * @param string $absolute the absolute path to convert\n\t * @param string $to the absolute path from which to derive the relative path\n\t * @param bool $leadingSlash if true, prepend the resultant URL with a slash\n\t *\/\n\tpublic static function relativePath($absolute, $to, $leadingSlash = false) {\n\t\t$trailingSlash = in_array(substr($absolute, -1), array('\/', '\\\\'));\n\t\t$absoluteComponents = self::splitPath($absolute);\n\t\t$toComponents = self::splitPath($to);\n\t\t$relativeComponents = array();\n\t\tdo {\n\t\t\t$currentAbsolute = array_shift($absoluteComponents);\n\t\t\t$currentTo = array_shift($toComponents);\n\t\t} while($currentAbsolute === $currentTo && $currentAbsolute !== null);\n\t\twhile ($currentTo !== null) {\n\t\t\tarray_push($relativeComponents, '..');\n\t\t\t$currentTo = array_shift($toComponents);\n\t\t}\n\t\twhile ($currentAbsolute !== null) {\n\t\t\tarray_push($relativeComponents, $currentAbsolute);\n\t\t\t$currentAbsolute = array_shift($absoluteComponents);\n\t\t}\n\t\treturn implode(array(\n\t\t\t$leadingSlash ? '\/' : '',\n\t\t\timplode('\/', $relativeComponents),\n\t\t\t($trailingSlash && (count($relativeComponents) > 0 || !$leadingSlash)) ? '\/' : ''\n\t\t));\n\t}\n\n\t\/**\n\t * Determine the effective port given the output of parse_url\n\t * @param array $urlComponents\n\t * @return int the resolved port number\n\t *\/\n\tprivate static function resolvePort($urlComponents) {\n\t\tif (array_key_exists('port', $urlComponents) && !empty($urlComponents['port'])) {\n\t\t\treturn $urlComponents['port'];\n\t\t}\n\t\tif (array_key_exists('scheme', $urlComponents) && $urlComponents['scheme'] === 'https') {\n\t\t\treturn 443;\n\t\t}\n\t\treturn 80;\n\t}\n\n\t\/**\n\t * Check if two site URLs identify the same site\n\t * @param string $a first url\n\t * @param string $b second url\n\t * @param array $ignoredSubdomains An array of subdomains to ignore when matching (e.g., www)\n\t * @return bool true if the URLs match, false otherwise\n\t *\/\n\tpublic static function compareSiteUrls($a, $b, $ignoredSubdomains = array()) {\n\t\t$patterns = array_map(function($p) { return '\/^' . preg_quote($p, '\/') . '\\\\.\/i'; }, $ignoredSubdomains);\n\t\t\n\t\t$componentsA = parse_url($a);\n\t\tif (isset($componentsA['host'])) { $componentsA['host'] = preg_replace($patterns, '', $componentsA['host']); }\n\t\t$componentsB = parse_url($b);\n\t\tif (isset($componentsB['host'])) { $componentsB['host'] = preg_replace($patterns, '', $componentsB['host']); }\n\t\tforeach (array('host', 'port', 'path') as $component) {\n\t\t\t$valueA = array_key_exists($component, $componentsA) ? $componentsA[$component] : null;\n\t\t\t$valueB = array_key_exists($component, $componentsB) ? $componentsB[$component] : null;\n\t\t\tif ($valueA !== $valueB) {\n\t\t\t\tif ($component === 'port') {\n\t\t\t\t\t$portA = self::resolvePort($componentsA);\n\t\t\t\t\t$portB = self::resolvePort($componentsB);\n\t\t\t\t\tif ($portA !== $portB)\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static function getHomePath() {\n\t\tif (!function_exists('get_home_path')) {\n\t\t\tinclude_once(ABSPATH . 'wp-admin\/includes\/file.php');\n\t\t}\n\t\tif (WF_IS_FLYWHEEL)\n\t\t\treturn trailingslashit($_SERVER['DOCUMENT_ROOT']);\n\t\treturn get_home_path();\n\t}\n\n\tpublic static function includeOnceIfPresent($path) {\n\t\tif (file_exists($path) && is_readable($path)) {\n\t\t\t@include_once($path);\n\t\t\treturn @include_once($path); \/\/Calling `include_once` for an already included file will return true\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static function isCurlSupported() {\n\t\tif (!function_exists('curl_init') || !function_exists('curl_exec')) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t$is_ssl = isset($args['ssl']) && $args['ssl'];\n\t\t\n\t\tif ($is_ssl) {\n\t\t\t$curl_version = curl_version();\n\t\t\t\/\/ Check whether this cURL version support SSL requests.\n\t\t\tif (!(CURL_VERSION_SSL & $curl_version['features'])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\n\tprivate static function isValidJsonValue($value) {\n\t\treturn json_encode($value) !== false;\n\t}\n\n\tprivate static function filterInvalidJsonValues($data, &$modified, &$valid = null) {\n\t\tif (is_array($data)) {\n\t\t\t$modified = array();\n\t\t\t$filtered = array();\n\t\t\t$valid = true;\n\t\t\tforeach ($data as $key => $value) {\n\t\t\t\t$value = self::filterInvalidJsonValues($value, $itemModified, $itemValid);\n\t\t\t\tif (($itemValid || $itemModified) && self::isValidJsonValue(array($key => $value))) {\n\t\t\t\t\t$filtered[$key] = $value;\n\t\t\t\t\tif ($itemModified)\n\t\t\t\t\t\t$modified[$key] = $itemModified;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$valid = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $filtered;\n\t\t}\n\t\telse {\n\t\t\t$modified = false;\n\t\t\t$valid = self::isValidJsonValue($data);\n\t\t\tif ($valid) {\n\t\t\t\treturn $data;\n\t\t\t}\n\t\t\telse if (is_string($data)) {\n\t\t\t\t$modified = true;\n\t\t\t\treturn base64_encode($data);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static function jsonEncodeSafely($data) {\n\t\t$encoded = json_encode($data);\n\t\tif ($encoded === false) {\n\t\t\t$data = self::filterInvalidJsonValues($data, $modified);\n\t\t\tif ($modified)\n\t\t\t\t$data['__modified__'] = $modified;\n\t\t\t$encoded = json_encode($data);\n\t\t}\n\t\treturn $encoded;\n\t}\n\t\n\t\/**\n\t * Convenience function to extract a matched pattern from a string. If $pattern has no matching groups, the entire\n\t * matched portion is returned. If it has at least one matching group, the first one is returned (others are \n\t * ignored). If there is no match, false is returned.\n\t * \n\t * @param string $pattern\n\t * @param string $subject\n\t * @param bool $expandToLine Whether or not to expand the captured value to include the entire line's contents\n\t * @return false|string\n\t *\/\n\tpublic static function pregExtract($pattern, $subject, $expandToLine = false) {\n\t\tif (preg_match($pattern, $subject, $matches, PREG_OFFSET_CAPTURE)) {\n\t\t\tif (count($matches) > 1) {\n\t\t\t\t$start = $matches[1][1];\n\t\t\t\t$text = $matches[1][0];\n\t\t\t\t$end = $start + strlen($text);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$start = $matches[0][1];\n\t\t\t\t$text = $matches[0][0];\n\t\t\t\t$end = $start + strlen($text);\n\t\t\t}\n\t\t\t\n\t\t\tif ($expandToLine) {\n\t\t\t\tif (preg_match_all('\/[\\r\\n]\/', substr($subject, 0, $start), $matches, PREG_OFFSET_CAPTURE)) {\n\t\t\t\t\t$start = $matches[0][count($matches[0]) - 1][1] + 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$start = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (preg_match('\/[\\r\\n]\/', $subject, $matches, PREG_OFFSET_CAPTURE, $end)) {\n\t\t\t\t\t$end = $matches[0][1];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$end = strlen($subject) - 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t$text = substr($subject, $start, $end - $start);\n\t\t\t}\n\t\t\t\n\t\t\treturn $text;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\/**\n\t * Returns whether or not MySQLi should be used directly when needed. Returns true if there's a valid DB handle,\n\t * our database test succeeded, our constant is not set to prevent it, and then either $wpdb indicates it's using\n\t * mysqli (older WordPress versions) or we're on PHP 7+ (only mysqli is ever used).\n\t * \n\t * @return bool\n\t *\/\n\tpublic static function useMySQLi() {\n\t\tglobal $wpdb;\n\t\t$dbh = $wpdb->dbh;\n\t\t$useMySQLi = (is_object($dbh) && (PHP_MAJOR_VERSION >= 7 || $wpdb->use_mysqli) && wfConfig::get('allowMySQLi', true) && WORDFENCE_ALLOW_DIRECT_MYSQLI);\n\t\treturn $useMySQLi;\n\t}\n}\n\n\/\/ GeoIP lib uses these as well\nif (!function_exists('inet_ntop')) {\n\tfunction inet_ntop($ip) {\n\t\treturn wfUtils::_inet_ntop($ip);\n\t}\n}\nif (!function_exists('inet_pton')) {\n\tfunction inet_pton($ip) {\n\t\treturn wfUtils::_inet_pton($ip);\n\t}\n}\n\n\nclass wfWebServerInfo {\n\n\tconst APACHE = 1;\n\tconst NGINX = 2;\n\tconst LITESPEED = 4;\n\tconst IIS = 8;\n\n\tprivate $handler;\n\tprivate $software;\n\tprivate $softwareName;\n\n\t\/**\n\t *\n\t *\/\n\tpublic static function createFromEnvironment() {\n\t\t$serverInfo = new self;\n\t\t$sapi = php_sapi_name();\n\t\tif (WF_IS_FLYWHEEL) {\n\t\t\t$serverInfo->setSoftware(self::NGINX);\n\t\t\t$serverInfo->setSoftwareName('Flywheel');\n\t\t}\n\t\telse if (strpos($_SERVER['SERVER_SOFTWARE'], 'Microsoft-IIS') !== false || strpos($_SERVER['SERVER_SOFTWARE'], 'ExpressionDevServer') !== false) {\n\t\t\t$serverInfo->setSoftware(self::IIS);\n\t\t\t$serverInfo->setSoftwareName('iis');\n\t\t}\n\t\telse if (strpos($_SERVER['SERVER_SOFTWARE'], 'nginx') !== false) {\n\t\t\t$serverInfo->setSoftware(self::NGINX);\n\t\t\t$serverInfo->setSoftwareName('nginx');\n\t\t}\n\t\telse if (stripos($_SERVER['SERVER_SOFTWARE'], 'litespeed') !== false || $sapi == 'litespeed') {\n\t\t\t$serverInfo->setSoftware(self::LITESPEED);\n\t\t\t$serverInfo->setSoftwareName('litespeed');\n\t\t}\n\t\telse if (stripos($_SERVER['SERVER_SOFTWARE'], 'apache') !== false) {\n\t\t\t$serverInfo->setSoftware(self::APACHE);\n\t\t\t$serverInfo->setSoftwareName('apache');\n\t\t}\n\t\telse if (stripos($_SERVER['SERVER_SOFTWARE'], 'unit') !== false) {\n\t\t\t$serverInfo->setSoftware(self::NGINX);\n\t\t\t$serverInfo->setSoftwareName('unit');\n\t\t}\n\n\t\t$serverInfo->setHandler($sapi);\n\n\t\treturn $serverInfo;\n\t}\n\n\t\/**\n\t * @return bool\n\t *\/\n\tpublic function isApache() {\n\t\treturn $this->getSoftware() === self::APACHE;\n\t}\n\n\t\/**\n\t * @return bool\n\t *\/\n\tpublic function isNginx() {\n\t\treturn $this->getSoftware() === self::NGINX;\n\t}\n\n\t\/**\n\t * @return bool\n\t *\/\n\tpublic function isLiteSpeed() {\n\t\treturn $this->getSoftware() === self::LITESPEED;\n\t}\n\n\t\/**\n\t * @return bool\n\t *\/\n\tpublic function isIIS() {\n\t\treturn $this->getSoftware() === self::IIS;\n\t}\n\n\t\/**\n\t * @return bool\n\t *\/\n\tpublic function isApacheModPHP() {\n\t\treturn $this->isApache() && function_exists('apache_get_modules');\n\t}\n\n\t\/**\n\t * Not sure if this can be implemented at the PHP level.\n\t * @return bool\n\t *\/\n\tpublic function isApacheSuPHP() {\n\t\treturn $this->isApache() && $this->isCGI() &&\n\t\t\tfunction_exists('posix_getuid') &&\n\t\t\tfunction_exists('getmyuid') &&\n\t\t\tgetmyuid() === posix_getuid();\n\t}\n\n\tprivate function isUnit() {\n\t\treturn $this->softwareName == \"unit\";\n\t}\n\n\tpublic function isNginxStandard() {\n\t\treturn $this->isNginx() && !$this->isUnit();\n\t}\n\n\tpublic function isNginxUnit() {\n\t\treturn $this->isNginx() && $this->isUnit();\n\t}\n\n\t\/**\n\t * @return bool\n\t *\/\n\tpublic function isCGI() {\n\t\treturn !$this->isFastCGI() && stripos($this->getHandler(), 'cgi') !== false;\n\t}\n\n\t\/**\n\t * @return bool\n\t *\/\n\tpublic function isFastCGI() {\n\t\treturn stripos($this->getHandler(), 'fastcgi') !== false || stripos($this->getHandler(), 'fpm-fcgi') !== false;\n\t}\n\n\t\/**\n\t * @return mixed\n\t *\/\n\tpublic function getHandler() {\n\t\treturn $this->handler;\n\t}\n\n\t\/**\n\t * @param mixed $handler\n\t *\/\n\tpublic function setHandler($handler) {\n\t\t$this->handler = $handler;\n\t}\n\n\t\/**\n\t * @return mixed\n\t *\/\n\tpublic function getSoftware() {\n\t\treturn $this->software;\n\t}\n\n\t\/**\n\t * @param mixed $software\n\t *\/\n\tpublic function setSoftware($software) {\n\t\t$this->software = $software;\n\t}\n\n\t\/**\n\t * @return mixed\n\t *\/\n\tpublic function getSoftwareName() {\n\t\treturn $this->softwareName;\n\t}\n\n\t\/**\n\t * @param mixed $softwareName\n\t *\/\n\tpublic function setSoftwareName($softwareName) {\n\t\t$this->softwareName = $softwareName;\n\t}\n}"},{"base":"plugins","rel":"wordfence\/lib\/wfLog.php","ext":"php","size":58545,"mtime":1757312769,"type":"text","content":"<?php\nrequire_once(dirname(__FILE__) . '\/wfDB.php');\nrequire_once(dirname(__FILE__) . '\/wfUtils.php');\nrequire_once(dirname(__FILE__) . '\/wfBrowscap.php');\nclass wfLog {\n\tpublic $canLogHit = true;\n\tprivate $effectiveUserID = 0;\n\tprivate $hitsTable = '';\n\tprivate $apiKey = '';\n\tprivate $wp_version = '';\n\tprivate $db = false;\n\tprivate $googlePattern = '\/\\.(?:googlebot\\.com|google\\.[a-z]{2,3}|google\\.[a-z]{2}\\.[a-z]{2}|1e100\\.net)$\/i';\n\tprivate $loginsTable, $statusTable;\n\tprivate static $gbSafeCache = array();\n\n\t\/**\n\t * @var wfRequestModel\n\t *\/\n\tprivate $currentRequest;\n\t\n\tpublic static function shared() {\n\t\tstatic $_shared = null;\n\t\tif ($_shared === null) {\n\t\t\t$_shared = new wfLog(wfConfig::get('apiKey'), wfUtils::getWPVersion());\n\t\t}\n\t\treturn $_shared;\n\t}\n\t\n\t\/**\n\t * Returns whether or not we have a cached record identifying the visitor as human. This is used both by certain\n\t * rate limiting features and by Live Traffic.\n\t * \n\t * @param bool|string $IP\n\t * @param bool|string $UA\n\t * @return bool\n\t *\/\n\tpublic static function isHumanRequest($IP = false, $UA = false) {\n\t\tglobal $wpdb;\n\t\t\n\t\tif ($IP === false) {\n\t\t\t$IP = wfUtils::getIP();\n\t\t}\n\t\t\n\t\tif ($UA === false || $UA === null) {\n\t\t\t$UA = (isset($_SERVER['HTTP_USER_AGENT']) ? $_SERVER['HTTP_USER_AGENT'] : '');\n\t\t}\n\t\t\n\t\t$ipHex = wfDB::binaryValueToSQLHex(wfUtils::inet_pton($IP));\n\t\t$table = wfDB::networkTable('wfLiveTrafficHuman');\n\t\tif ($wpdb->get_var($wpdb->prepare(\"SELECT COUNT(*) FROM {$table} WHERE IP = {$ipHex} AND identifier = %s AND expiration >= UNIX_TIMESTAMP()\", hash('sha256', $UA, true)))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\/**\n\t * Creates a cache record for the requester to tag it as human.\n\t * \n\t * @param bool|string $IP\n\t * @param bool|string $UA\n\t * @return bool\n\t *\/\n\tpublic static function cacheHumanRequester($IP = false, $UA = false) {\n\t\tglobal $wpdb;\n\t\t\n\t\tif ($IP === false) {\n\t\t\t$IP = wfUtils::getIP();\n\t\t}\n\t\t\n\t\tif ($UA === false) {\n\t\t\t$UA = (isset($_SERVER['HTTP_USER_AGENT']) ? $_SERVER['HTTP_USER_AGENT'] : '');\n\t\t}\n\t\t\n\t\t$ipHex = wfDB::binaryValueToSQLHex(wfUtils::inet_pton($IP));\n\t\t$table = wfDB::networkTable('wfLiveTrafficHuman');\n\t\tif ($wpdb->get_var($wpdb->prepare(\"INSERT IGNORE INTO {$table} (IP, identifier, expiration) VALUES ({$ipHex}, %s, UNIX_TIMESTAMP() + 86400)\", hash('sha256', $UA, true)))) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\t\/**\n\t * Prunes any expired records from the human cache.\n\t *\/\n\tpublic static function trimHumanCache() {\n\t\tglobal $wpdb;\n\t\t$table = wfDB::networkTable('wfLiveTrafficHuman');\n\t\t$wpdb->query(\"DELETE FROM {$table} WHERE `expiration` < UNIX_TIMESTAMP()\");\n\t}\n\n\tpublic function __construct($apiKey, $wp_version){\n\t\t$this->apiKey = $apiKey;\n\t\t$this->wp_version = $wp_version;\n\t\t$this->hitsTable = wfDB::networkTable('wfHits');\n\t\t$this->loginsTable = wfDB::networkTable('wfLogins');\n\t\t$this->statusTable = wfDB::networkTable('wfStatus');\n\t\t\n\t\tadd_filter('determine_current_user', array($this, '_userIDDetermined'), 99, 1);\n\t}\n\t\n\tpublic function _userIDDetermined($userID) {\n\t\t\/\/Needed because the REST API will clear the authenticated user if it fails a nonce check on the request\n\t\t$this->effectiveUserID = (int) $userID;\n\t\treturn $userID;\n\t}\n\n\tpublic function initLogRequest() {\n\t\tif ($this->currentRequest === null) {\n\t\t\t$this->currentRequest = new wfRequestModel();\n\n\t\t\t$this->currentRequest->ctime = sprintf('%.6f', microtime(true));\n\t\t\t$this->currentRequest->statusCode = 200;\n\t\t\t$this->currentRequest->isGoogle = (wfCrawl::isGoogleCrawler() ? 1 : 0);\n\t\t\t$this->currentRequest->IP = wfUtils::inet_pton(wfUtils::getIP());\n\t\t\t$this->currentRequest->userID = $this->getCurrentUserID();\n\t\t\t$this->currentRequest->URL = wfUtils::getRequestedURL();\n\t\t\t$this->currentRequest->referer = (isset($_SERVER['HTTP_REFERER']) ? $_SERVER['HTTP_REFERER'] : '');\n\t\t\t$this->currentRequest->UA = (isset($_SERVER['HTTP_USER_AGENT']) ? $_SERVER['HTTP_USER_AGENT'] : '');\n\t\t\t$this->currentRequest->jsRun = 0;\n\t\t\t\n\t\t\tadd_action('wp_loaded', array($this, 'actionSetRequestJSEnabled'));\n\t\t\tadd_action('init', array($this, 'actionSetRequestOnInit'), 9999);\n\n\t\t\tif (function_exists('register_shutdown_function')) {\n\t\t\t\tregister_shutdown_function(array($this, 'logHit'));\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic function actionSetRequestJSEnabled() {\n\t\tif (get_current_user_id() > 0) {\n\t\t\t$this->currentRequest->jsRun = true;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t$IP = wfUtils::getIP();\n\t\t$UA = $this->currentRequest->UA;\n\t\t$this->currentRequest->jsRun = wfLog::isHumanRequest($IP, $UA);\n\t}\n\n\t\/**\n\t * CloudFlare's plugin changes $_SERVER['REMOTE_ADDR'] on init.\n\t *\/\n\tpublic function actionSetRequestOnInit() {\n\t\t$this->currentRequest->IP = wfUtils::inet_pton(wfUtils::getIP());\n\t\t$this->currentRequest->userID = $this->getCurrentUserID();\n\t}\n\n\t\/**\n\t * @return wfRequestModel\n\t *\/\n\tpublic function getCurrentRequest() {\n\t\treturn $this->currentRequest;\n\t}\n\t\n\tpublic function logLogin($action, $fail, $username){\n\t\tif(! $username){\n\t\t\treturn;\n\t\t}\n\t\t$user = get_user_by('login', $username);\n\t\t$userID = 0;\n\t\tif($user){\n\t\t\t$userID = $user->ID;\n\t\t\tif(! $userID){\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t$user = get_user_by('email', $username);\n\t\t\tif ($user) {\n\t\t\t\t$userID = $user->ID;\n\t\t\t\tif (!$userID) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\/\/ change the action flag here if the user does not exist.\n\t\tif ($action == 'loginFailValidUsername' && $userID == 0) {\n\t\t\t$action = 'loginFailInvalidUsername';\n\t\t}\n\n\t\t$hitID = 0;\n\t\tif ($this->currentRequest !== null) {\n\t\t\t$this->currentRequest->userID = $userID;\n\t\t\t$this->currentRequest->action = $action;\n\t\t\t$this->currentRequest->save();\n\t\t\t$hitID = $this->currentRequest->getPrimaryKey();\n\t\t}\n\n\t\t\/\/Else userID stays 0 but we do log this even though the user doesn't exist.\n\t\t$ipHex = wfDB::binaryValueToSQLHex(wfUtils::inet_pton(wfUtils::getIP()));\n\t\t$this->getDB()->queryWrite(\"insert into \" . $this->loginsTable . \" (hitID, ctime, fail, action, username, userID, IP, UA) values (%d, %f, %d, '%s', '%s', %s, {$ipHex}, '%s')\",\n\t\t\t$hitID,\n\t\t\tsprintf('%.6f', microtime(true)),\n\t\t\t$fail,\n\t\t\t$action,\n\t\t\t$username,\n\t\t\t$userID,\n\t\t\t(isset($_SERVER['HTTP_USER_AGENT']) ? $_SERVER['HTTP_USER_AGENT'] : '')\n\t\t\t);\n\t}\n\tprivate function getCurrentUserID(){\n\t\tif (!function_exists('get_current_user_id') || !defined('AUTH_COOKIE')) { \/\/If pluggable.php is loaded early by some other plugin on a multisite installation, it leads to an error because AUTH_COOKIE is undefined and WP doesn't check for it first\n\t\t\treturn 0;\n\t\t}\n\t\t$id = get_current_user_id();\n\t\treturn $id ? $id : 0;\n\t}\n\tpublic function logLeechAndBlock($type) { \/\/404 or hit\n\t\tif (!wfRateLimit::mightRateLimit($type)) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\twfRateLimit::countHit($type, wfUtils::getIP());\n\t\t\n\t\tif (wfRateLimit::globalRateLimit()->shouldEnforce($type)) {\n\t\t\t$this->takeBlockingAction('maxGlobalRequests', wfI18n::__(\"Exceeded the maximum global requests per minute for crawlers or humans.\", 'wordfence'));\n\t\t}\n\t\telse if (wfRateLimit::crawlerViewsRateLimit()->shouldEnforce($type)) {\n\t\t\t$this->takeBlockingAction('maxRequestsCrawlers', wfI18n::__(\"Exceeded the maximum number of requests per minute for crawlers.\", 'wordfence')); \/\/may not exit\n\t\t}\n\t\telse if (wfRateLimit::crawler404sRateLimit()->shouldEnforce($type)) {\n\t\t\t$this->takeBlockingAction('max404Crawlers', wfI18n::__(\"Exceeded the maximum number of page not found errors per minute for a crawler.\", 'wordfence'));\n\t\t}\n\t\telse if (wfRateLimit::humanViewsRateLimit()->shouldEnforce($type)) {\n\t\t\t$this->takeBlockingAction('maxRequestsHumans', wfI18n::__(\"Exceeded the maximum number of page requests per minute for humans.\", 'wordfence'));\n\t\t}\n\t\telse if (wfRateLimit::human404sRateLimit()->shouldEnforce($type)) {\n\t\t\t$this->takeBlockingAction('max404Humans', wfI18n::__(\"Exceeded the maximum number of page not found errors per minute for humans.\", 'wordfence'));\n\t\t}\n\t}\n\t\n\tpublic function tagRequestForBlock($reason, $wfsn = false) {\n\t\tif ($this->currentRequest !== null) {\n\t\t\t$this->currentRequest->statusCode = 403;\n\t\t\t$this->currentRequest->action = 'blocked:' . ($wfsn ? 'wfsn' : 'wordfence');\n\t\t\t$this->currentRequest->actionDescription = $reason;\n\t\t}\n\t}\n\t\n\tpublic function tagRequestForLockout($reason) {\n\t\tif ($this->currentRequest !== null) {\n\t\t\t$this->currentRequest->statusCode = 503;\n\t\t\t$this->currentRequest->action = 'lockedOut';\n\t\t\t$this->currentRequest->actionDescription = $reason;\n\t\t}\n\t}\n\n\t\/**\n\t * @return bool|int\n\t *\/\n\tpublic function logHit() {\n\t\t$liveTrafficEnabled = wfConfig::liveTrafficEnabled();\n\t\t$action = $this->currentRequest->action;\n\t\t$logHitOK = $this->logHitOK();\n\t\tif (!$logHitOK) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!$liveTrafficEnabled && !$action) {\n\t\t\treturn false;\n\t\t}\n\t\tif ($this->currentRequest !== null) {\n\t\t\tif ($this->currentRequest->save()) {\n\t\t\t\treturn $this->currentRequest->getPrimaryKey();\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic function getHits($hitType \/* 'hits' or 'logins' *\/, $type, $afterTime, $limit = 50, $IP = false){\n\t\tglobal $wpdb;\n\t\t$IPSQL = \"\";\n\t\tif($IP){\n\t\t\t$ipHex = wfDB::binaryValueToSQLHex(wfUtils::inet_pton($IP));\n\t\t\t$IPSQL = \" and IP={$ipHex} \";\n\t\t\t$sqlArgs = array($afterTime, $limit);\n\t\t} else {\n\t\t\t$sqlArgs = array($afterTime, $limit);\n\t\t}\n\t\tif($hitType == 'hits'){\n\t\t\t$securityOnly = !wfConfig::liveTrafficEnabled();\n\t\t\t$delayedHumanBotFiltering = false;\n\t\t\t\n\t\t\tif($type == 'hit'){\n\t\t\t\t$typeSQL = \" \";\n\t\t\t} else if($type == 'crawler'){\n\t\t\t\tif ($securityOnly) {\n\t\t\t\t\t$typeSQL = \" \";\n\t\t\t\t\t$delayedHumanBotFiltering = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$now = time();\n\t\t\t\t\t$typeSQL = \" and jsRun = 0 and {$now} - ctime > 30 \";\n\t\t\t\t}\n\t\t\t} else if($type == 'gCrawler'){\n\t\t\t\t$typeSQL = \" and isGoogle = 1 \";\n\t\t\t} else if($type == '404'){\n\t\t\t\t$typeSQL = \" and statusCode = 404 \";\n\t\t\t} else if($type == 'human'){\n\t\t\t\tif ($securityOnly) {\n\t\t\t\t\t$typeSQL = \" \";\n\t\t\t\t\t$delayedHumanBotFiltering = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$typeSQL = \" and jsRun = 1 \";\n\t\t\t\t}\n\t\t\t} else if($type == 'ruser'){\n\t\t\t\t$typeSQL = \" and userID > 0 \";\n\t\t\t} else {\n\t\t\t\twordfence::status(1, 'error', sprintf(\/* translators: Error message. *\/ __(\"Invalid log type to wfLog: %s\", 'wordfence'), $type));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tarray_unshift($sqlArgs, \"select h.*, u.display_name from {$this->hitsTable} h\n\t\t\t\tLEFT JOIN {$wpdb->users} u on h.userID = u.ID\n\t\t\t\twhere ctime > %f $IPSQL $typeSQL order by ctime desc limit %d\");\n\t\t\t$results = call_user_func_array(array($this->getDB(), 'querySelect'), $sqlArgs);\n\t\t\t\n\t\t\tif ($delayedHumanBotFiltering) {\n\t\t\t\t$browscap = wfBrowscap::shared();\n\t\t\t\tforeach ($results as $index => $res) {\n\t\t\t\t\tif ($res['UA']) {\n\t\t\t\t\t\t$b = $browscap->getBrowser($res['UA']);\n\t\t\t\t\t\tif ($b && $b['Parent'] != 'DefaultProperties') {\n\t\t\t\t\t\t\t$jsRun = wfUtils::truthyToBoolean($res['jsRun']);\n\t\t\t\t\t\t\tif (!wfConfig::liveTrafficEnabled() && !$jsRun) {\n\t\t\t\t\t\t\t\t$jsRun = !(isset($b['Crawler']) && $b['Crawler']);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif ($type == 'crawler' && $jsRun || $type == 'human' && !$jsRun) {\n\t\t\t\t\t\t\t\tunset($results[$index]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else if($hitType == 'logins'){\n\t\t\tarray_unshift($sqlArgs, \"select l.*, u.display_name from {$this->loginsTable} l\n\t\t\t\tLEFT JOIN {$wpdb->users} u on l.userID = u.ID\n\t\t\t\twhere ctime > %f $IPSQL order by ctime desc limit %d\");\n\t\t\t$results = call_user_func_array(array($this->getDB(), 'querySelect'), $sqlArgs ); \n\n\t\t} else {\n\t\t\twordfence::status(1, 'error', sprintf(\/* translators: Error message. *\/ __(\"getHits got invalid hitType: %s\", 'wordfence'), $hitType));\n\t\t\treturn false;\n\t\t}\n\t\t$this->processGetHitsResults($type, $results);\n\t\treturn $results;\n\t}\n\n\tprivate function processActionDescription($description) {\n\t\tswitch ($description) {\n\t\tcase wfWAFIPBlocksController::WFWAF_BLOCK_UAREFIPRANGE:\n\t\t\treturn __('UA\/Hostname\/Referrer\/IP Range not allowed', 'wordfence');\n\t\tdefault:\n\t\t\treturn $description;\n\t\t}\n\t}\n\n\t\/**\n\t * @param string $type\n\t * @param array $results\n\t * @throws Exception\n\t *\/\n\tpublic function processGetHitsResults($type, &$results) {\n\t\t$serverTime = $this->getDB()->querySingle(\"select unix_timestamp()\");\n\n\t\t$this->resolveIPs($results);\n\t\t$ourURL = parse_url(site_url());\n\t\t$ourHost = strtolower($ourURL['host']);\n\t\t$ourHost = preg_replace('\/^www\\.\/i', '', $ourHost);\n\t\t$browscap = wfBrowscap::shared();\n\n\t\t$patternBlocks = wfBlock::patternBlocks(true);\n\n\t\tforeach($results as &$res){\n\t\t\t$res['type'] = $type;\n\t\t\t$res['IP'] = wfUtils::inet_ntop($res['IP']);\n\t\t\t$res['timeAgo'] = wfUtils::makeTimeAgo($serverTime - $res['ctime']);\n\t\t\t$res['blocked'] = false;\n\t\t\t$res['rangeBlocked'] = false;\n\t\t\t$res['ipRangeID'] = -1;\n\t\t\tif (array_key_exists('actionDescription', $res))\n\t\t\t\t$res['actionDescription'] = $this->processActionDescription($res['actionDescription']);\n\t\t\t\n\t\t\t$ipBlock = wfBlock::findIPBlock($res['IP']);\n\t\t\tif ($ipBlock !== false) {\n\t\t\t\t$res['blocked'] = true;\n\t\t\t\t$res['blockID'] = $ipBlock->id;\n\t\t\t}\n\t\t\t\n\t\t\tforeach ($patternBlocks as $b) {\n\t\t\t\tif (empty($b->ipRange)) { continue; }\n\t\t\t\t$range = new wfUserIPRange($b->ipRange);\n\t\t\t\tif ($range->isIPInRange($res['IP'])) {\n\t\t\t\t\t$res['rangeBlocked'] = true;\n\t\t\t\t\t$res['ipRangeID'] = $b->id;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t$res['extReferer'] = false;\n\t\t\tif(isset( $res['referer'] ) && $res['referer']){\n\t\t\t\tif(wfUtils::hasXSS($res['referer'] )){ \/\/filtering out XSS\n\t\t\t\t\t$res['referer'] = '';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( isset( $res['referer'] ) && $res['referer']){\n\t\t\t\t$refURL = parse_url($res['referer']);\n\t\t\t\tif(is_array($refURL) && isset($refURL['host']) && $refURL['host']){\n\t\t\t\t\t$refHost = strtolower(preg_replace('\/^www\\.\/i', '', $refURL['host']));\n\t\t\t\t\tif($refHost != $ourHost){\n\t\t\t\t\t\t$res['extReferer'] = true;\n\t\t\t\t\t\t\/\/now extract search terms\n\t\t\t\t\t\t$q = false;\n\t\t\t\t\t\tif(preg_match('\/(?:google|bing|alltheweb|aol|ask)\\.\/i', $refURL['host'])){\n\t\t\t\t\t\t\t$q = 'q';\n\t\t\t\t\t\t} else if(stristr($refURL['host'], 'yahoo.')){\n\t\t\t\t\t\t\t$q = 'p';\n\t\t\t\t\t\t} else if(stristr($refURL['host'], 'baidu.')){\n\t\t\t\t\t\t\t$q = 'wd';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif($q){\n\t\t\t\t\t\t\t$queryVars = array();\n\t\t\t\t\t\t\tif( isset( $refURL['query'] ) ) {\n\t\t\t\t\t\t\t\tparse_str($refURL['query'], $queryVars);\n\t\t\t\t\t\t\t\tif(isset($queryVars[$q])){\n\t\t\t\t\t\t\t\t\t$res['searchTerms'] = urlencode($queryVars[$q]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif($res['extReferer']){\n\t\t\t\t\tif ( isset( $referringPage ) && stristr( $referringPage['host'], 'google.' ) )\n\t\t\t\t\t{\n\t\t\t\t\t\tparse_str( $referringPage['query'], $queryVars );\n\t\t\t\t\t\t\/\/ echo $queryVars['q']; \/\/ This is the search term used\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t$res['browser'] = false;\n\t\t\tif($res['UA']){\n\t\t\t\t$b = $browscap->getBrowser($res['UA']);\n\t\t\t\tif($b && $b['Parent'] != 'DefaultProperties'){\n\t\t\t\t\t$res['browser'] = array(\n\t\t\t\t\t\t'browser'   => !empty($b['Browser']) ? $b['Browser'] : \"\",\n\t\t\t\t\t\t'version'   => !empty($b['Version']) ? $b['Version'] : \"\",\n\t\t\t\t\t\t'platform'  => !empty($b['Platform']) ? $b['Platform'] : \"\",\n\t\t\t\t\t\t'isMobile'  => !empty($b['isMobileDevice']) ? $b['isMobileDevice'] : \"\",\n\t\t\t\t\t\t'isCrawler' => !empty($b['Crawler']) ? $b['Crawler'] : \"\",\n\t\t\t\t\t);\n\t\t\t\t\t\n\t\t\t\t\tif (isset($res['jsRun']) && !wfConfig::liveTrafficEnabled() && !wfUtils::truthyToBoolean($res['jsRun'])) {\n\t\t\t\t\t\t$res['jsRun'] = !(isset($b['Crawler']) && $b['Crawler']) ? '1' : '0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$IP = wfUtils::getIP();\n\t\t\t\t\t$res['browser'] = array(\n\t\t\t\t\t\t'isCrawler' => !wfLog::isHumanRequest($IP, $res['UA']) ? 'true' : ''\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tif($res['userID']){\n\t\t\t\t$ud = get_userdata($res['userID']);\n\t\t\t\tif($ud){\n\t\t\t\t\t$res['user'] = array(\n\t\t\t\t\t\t'editLink' => wfUtils::editUserLink($res['userID']),\n\t\t\t\t\t\t'display_name' => $res['display_name'],\n\t\t\t\t\t\t'ID' => $res['userID']\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$res['user'] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic function resolveIPs(&$results){\n\t\tif(sizeof($results) < 1){ return; }\n\t\t$IPs = array();\n\t\tforeach($results as &$res){\n\t\t\tif($res['IP']){ \/\/Can also be zero in case of non IP events\n\t\t\t\t$IPs[] = $res['IP'];\n\t\t\t}\n\t\t}\n\t\t$IPLocs = wfUtils::getIPsGeo($IPs); \/\/Creates an array with IP as key and data as value\n\n\t\tforeach($results as &$res){\n\t\t\t$ip_printable = wfUtils::inet_ntop($res['IP']);\n\t\t\tif(isset($IPLocs[$ip_printable])){\n\t\t\t\t$res['loc'] = $IPLocs[$ip_printable];\n\t\t\t} else {\n\t\t\t\t$res['loc'] = false;\n\t\t\t}\n\t\t}\n\t}\n\tpublic function logHitOK(){\n\t\tif (!$this->canLogHit) {\n\t\t\treturn false;\n\t\t}\n\t\tif (is_admin()) { return false; } \/\/Don't log admin pageviews\n\t\tif (isset($_SERVER['HTTP_USER_AGENT'])) {\n\t\t\tif (preg_match('\/WordPress\\\/' . $this->wp_version . '\/i', $_SERVER['HTTP_USER_AGENT'])) { return false; } \/\/Ignore regular requests generated by WP UA.\n\t\t}\n\t\t$userID = get_current_user_id();\n\t\tif (!$userID) {\n\t\t\t$userID = $this->effectiveUserID;\n\t\t}\n\t\tif ($userID) {\n\t\t\t$user = new WP_User($userID);\n\t\t\tif ($user && $user->exists()) {\n\t\t\t\tif (wfConfig::get('liveTraf_ignorePublishers') && ($user->has_cap('publish_posts') || $user->has_cap('publish_pages'))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (wfConfig::get('liveTraf_ignoreUsers')) {\n\t\t\t\t\t$ignored = explode(',', wfConfig::get('liveTraf_ignoreUsers'));\n\t\t\t\t\tforeach ($ignored as $entry) {\n\t\t\t\t\t\tif($user->user_login == $entry){\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(wfConfig::get('liveTraf_ignoreIPs')){\n\t\t\t$IPs = explode(',', wfConfig::get('liveTraf_ignoreIPs'));\n\t\t\t$IP = wfUtils::getIP();\n\t\t\tforeach($IPs as $ignoreIP){\n\t\t\t\tif($ignoreIP == $IP){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( isset($_SERVER['HTTP_USER_AGENT']) && wfConfig::get('liveTraf_ignoreUA') ){\n\t\t\tif($_SERVER['HTTP_USER_AGENT'] == wfConfig::get('liveTraf_ignoreUA')){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\tprivate function getDB(){\n\t\tif(! $this->db){\n\t\t\t$this->db = new wfDB();\n\t\t}\n\t\treturn $this->db;\n\t}\n\tpublic function firewallBadIPs() {\n\t\t$IP = wfUtils::getIP();\n\t\tif (wfBlock::isWhitelisted($IP)) {\n\t\t\treturn;\n\t\t}\n\n\t\t\/\/Range and UA pattern blocking\n\t\t$patternBlocks = wfBlock::patternBlocks(true);\n\t\t$userAgent = !empty($_SERVER['HTTP_USER_AGENT']) ? $_SERVER['HTTP_USER_AGENT'] : '';\n\t\t$referrer = !empty($_SERVER['HTTP_REFERER']) ? $_SERVER['HTTP_REFERER'] : '';\n\t\tforeach ($patternBlocks as $b) {\n\t\t\tif ($b->matchRequest($IP, $userAgent, $referrer) !== wfBlock::MATCH_NONE) {\n\t\t\t\t$b->recordBlock();\n\t\t\t\twfActivityReport::logBlockedIP($IP, null, 'advanced');\n\t\t\t\t$this->currentRequest->actionDescription = wfI18n::__('UA\/Referrer\/IP Range not allowed', 'wordfence');\n\t\t\t\t$this->do503(3600, wfI18n::__(\"Advanced blocking in effect.\", 'wordfence')); \/\/exits\n\t\t\t}\n\t\t}\n\n\t\t\/\/ Country blocking\n\t\t$countryBlocks = wfBlock::countryBlocks(true);\n\t\tforeach ($countryBlocks as $b) {\n\t\t\t$match = $b->matchRequest($IP, false, false);\n\t\t\tif ($match === wfBlock::MATCH_COUNTRY_REDIR_BYPASS) {\n\t\t\t\t$bypassRedirDest = wfConfig::get('cbl_bypassRedirDest', '');\n\t\t\t\t\n\t\t\t\t$this->initLogRequest();\n\t\t\t\t$this->getCurrentRequest()->actionDescription = __('redirected to bypass URL', 'wordfence');\n\t\t\t\t$this->getCurrentRequest()->statusCode = 302;\n\t\t\t\t$this->currentRequest->action = 'cbl:redirect';\n\t\t\t\t$this->logHit();\n\t\t\t\t\n\t\t\t\twfUtils::doNotCache();\n\t\t\t\twp_redirect($bypassRedirDest, 302);\n\t\t\t\texit();\n\t\t\t}\n\t\t\telse if ($match === wfBlock::MATCH_COUNTRY_REDIR) {\n\t\t\t\t$b->recordBlock();\n\t\t\t\twfConfig::inc('totalCountryBlocked');\n\t\t\t\t\n\t\t\t\t$this->initLogRequest();\n\t\t\t\t$this->getCurrentRequest()->actionDescription = sprintf(\/* translators: URL *\/ __('blocked access via country blocking and redirected to URL (%s)', 'wordfence'), wfConfig::get('cbl_redirURL'));\n\t\t\t\t$this->getCurrentRequest()->statusCode = 503;\n\t\t\t\tif (!$this->getCurrentRequest()->action) {\n\t\t\t\t\t$this->currentRequest->action = 'blocked:wordfence';\n\t\t\t\t}\n\t\t\t\t$this->logHit();\n\t\t\t\t\n\t\t\t\twfActivityReport::logBlockedIP($IP, null, 'country');\n\t\t\t\t\n\t\t\t\twfUtils::doNotCache();\n\t\t\t\twp_redirect(wfConfig::get('cbl_redirURL'), 302);\n\t\t\t\texit();\n\t\t\t}\n\t\t\telse if ($match !== wfBlock::MATCH_NONE) {\n\t\t\t\t$b->recordBlock();\n\t\t\t\t$this->currentRequest->actionDescription = __('blocked access via country blocking', 'wordfence');\n\t\t\t\twfConfig::inc('totalCountryBlocked');\n\t\t\t\twfActivityReport::logBlockedIP($IP, null, 'country');\n\t\t\t\t$this->do503(3600, wfI18n::__('Access from your area has been temporarily limited for security reasons', 'wordfence'));\n\t\t\t}\n\t\t}\n\n\t\t\/\/Specific IP blocks\n\t\t$ipBlock = wfBlock::findIPBlock($IP);\n\t\tif ($ipBlock !== false) {\n\t\t\t$ipBlock->recordBlock();\n\t\t\t$secsToGo = max(0, $ipBlock->expiration - time());\n\t\t\tif (wfConfig::get('other_WFNet') && self::isAuthRequest()) { \/\/It's an auth request and this IP has been blocked\n\t\t\t\t$this->getCurrentRequest()->action = 'blocked:wfsnrepeat';\n\t\t\t\twordfence::wfsnReportBlockedAttempt($IP, 'login');\n\t\t\t}\n\t\t\t$reason = $ipBlock->reason;\n\t\t\tif ($ipBlock->type == wfBlock::TYPE_IP_MANUAL || $ipBlock->type == wfBlock::TYPE_IP_AUTOMATIC_PERMANENT) {\n\t\t\t\t$reason = wfI18n::__('Manual block by administrator', 'wordfence');\n\t\t\t}\n\t\t\t$this->do503($secsToGo, $reason); \/\/exits\n\t\t}\n\t}\n\n\tprivate function takeBlockingAction($configVar, $reason) {\n\t\tif ($this->googleSafetyCheckOK()) {\n\t\t\t$action = wfConfig::get($configVar . '_action');\n\t\t\tif (!$action) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t$IP = wfUtils::getIP();\n\t\t\t$secsToGo = 0;\n\t\t\tif ($action == 'block') { \/\/Rate limited - block temporarily\n\t\t\t\t$secsToGo = wfBlock::blockDuration();\n\t\t\t\twfBlock::createRateBlock($reason, $IP, $secsToGo);\n\t\t\t\twfActivityReport::logBlockedIP($IP, null, 'throttle');\n\t\t\t\t$this->tagRequestForBlock($reason);\n\n\t\t\t\t$alertCallback = array(new wfBlockAlert($IP, $reason, $secsToGo), 'send');\n\n\t\t\t\tdo_action('wordfence_security_event', 'block', array(\n\t\t\t\t\t'ip' => $IP,\n\t\t\t\t\t'reason' => $reason,\n\t\t\t\t\t'duration' => $secsToGo,\n\t\t\t\t), $alertCallback);\n\t\t\t\twordfence::status(2, 'info', sprintf(\/* translators: 1. IP address. 2. Description of firewall action. *\/ __('Blocking IP %1$s. %2$s', 'wordfence'), $IP, $reason));\n\t\t\t}\n\t\t\telse if ($action == 'throttle') { \/\/Rate limited - throttle\n\t\t\t\t$secsToGo = wfBlock::rateLimitThrottleDuration();\n\t\t\t\twfBlock::createRateThrottle($reason, $IP, $secsToGo);\n\t\t\t\twfActivityReport::logBlockedIP($IP, null, 'throttle');\n\n\t\t\t\tdo_action('wordfence_security_event', 'throttle', array(\n\t\t\t\t\t'ip' => $IP,\n\t\t\t\t\t'reason' => $reason,\n\t\t\t\t\t'duration' => $secsToGo,\n\t\t\t\t));\n\t\t\t\twordfence::status(2, 'info', sprintf(\/* translators: 1. IP address. 2. Description of firewall action. *\/ __('Throttling IP %1$s. %2$s', 'wordfence'), $IP, $reason));\n\t\t\t\twfConfig::inc('totalIPsThrottled');\n\t\t\t}\n\t\t\t$this->do503($secsToGo, $reason, false);\n\t\t}\n\t\t\n\t\treturn;\n\t}\n\t\n\t\/**\n\t * Test if the current request is for wp-login.php or xmlrpc.php\n\t *\n\t * @return boolean\n\t *\/\n\tprivate static function isAuthRequest() {\n\t\tif ((strpos($_SERVER['REQUEST_URI'], '\/wp-login.php') !== false)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic function do503($secsToGo, $reason, $sendEventToCentral = true){\n\t\t$this->initLogRequest();\n\n\t\tif ($sendEventToCentral) {\n\t\t\tdo_action('wordfence_security_event', 'block', array(\n\t\t\t\t'ip' => wfUtils::inet_ntop($this->currentRequest->IP),\n\t\t\t\t'reason' => $this->currentRequest->actionDescription ? $this->currentRequest->actionDescription : $reason,\n\t\t\t\t'duration' => $secsToGo,\n\t\t\t));\n\t\t}\n\n\t\t$this->currentRequest->statusCode = 503;\n\t\tif (!$this->currentRequest->action) {\n\t\t\t$this->currentRequest->action = 'blocked:wordfence';\n\t\t}\n\t\tif (!$this->currentRequest->actionDescription) {\n\t\t\t$this->currentRequest->actionDescription = \"blocked: \" . $reason;\n\t\t}\n\t\t\n\t\t$this->logHit();\n\n\t\twfConfig::inc('total503s');\n\t\twfUtils::doNotCache();\n\t\theader('HTTP\/1.1 503 Service Temporarily Unavailable');\n\t\theader('Status: 503 Service Temporarily Unavailable');\n\t\tif($secsToGo){\n\t\t\theader('Retry-After: ' . $secsToGo);\n\t\t}\n\t\t$customText = wpautop(wp_strip_all_tags(wfConfig::get('blockCustomText', '')));\n\t\trequire_once(dirname(__FILE__) . '\/wf503.php');\n\t\texit();\n\t}\n\tprivate function redirect($URL){\n\t\twfUtils::doNotCache();\n\t\twp_redirect($URL, 302);\n\t\texit();\n\t}\n\tprivate function googleSafetyCheckOK(){ \/\/returns true if OK to block. Returns false if we must not block.\n\t\t$cacheKey = md5( (isset($_SERVER['HTTP_USER_AGENT']) ? $_SERVER['HTTP_USER_AGENT'] : '') . ' ' . wfUtils::getIP());\n\t\t\/\/Cache so we can call this multiple times in one request\n\t\tif(! isset(self::$gbSafeCache[$cacheKey])){\n\t\t\t$nb = wfConfig::get('neverBlockBG');\n\t\t\tif($nb == 'treatAsOtherCrawlers'){\n\t\t\t\tself::$gbSafeCache[$cacheKey] = true; \/\/OK to block because we're treating google like everyone else\n\t\t\t} else if($nb == 'neverBlockUA' || $nb == 'neverBlockVerified'){\n\t\t\t\tif(wfCrawl::isGoogleCrawler()){ \/\/Check the UA using regex\n\t\t\t\t\tif($nb == 'neverBlockVerified'){\n\t\t\t\t\t\tif(wfCrawl::isVerifiedGoogleCrawler(wfUtils::getIP())){ \/\/UA check passed, now verify using PTR if configured to\n\t\t\t\t\t\t\tself::$gbSafeCache[$cacheKey] = false; \/\/This is a verified Google crawler, so no we can't block it\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tself::$gbSafeCache[$cacheKey] = true; \/\/This is a crawler claiming to be Google but it did not verify\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { \/\/neverBlockUA\n\t\t\t\t\t\tself::$gbSafeCache[$cacheKey] = false; \/\/User configured us to only do a UA check and this claims to be google so don't block\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tself::$gbSafeCache[$cacheKey] = true; \/\/This isn't a Google UA, so it's OK to block\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t\/\/error_log(\"Wordfence error: neverBlockBG option is not set.\");\n\t\t\t\tself::$gbSafeCache[$cacheKey] = false; \/\/Oops the config option is not set. This should never happen because it's set on install. So we return false to indicate it's not OK to block just for safety.\n\t\t\t}\n\t\t}\n\t\tif(! isset(self::$gbSafeCache[$cacheKey])){\n\t\t\t\/\/error_log(\"Wordfence assertion fail in googleSafetyCheckOK: cached value is not set.\");\n\t\t\treturn false; \/\/for safety\n\t\t}\n\t\treturn self::$gbSafeCache[$cacheKey]; \/\/return cached value\n\t}\n\tpublic function addStatus($level, $type, $msg){\n\t\t\/\/$msg = '[' . sprintf('%.2f', memory_get_usage(true) \/ (1024 * 1024)) . '] ' . $msg;\n\t\t$this->getDB()->queryWrite(\"insert into \" . $this->statusTable . \" (ctime, level, type, msg) values (%s, %d, '%s', '%s')\", sprintf('%.6f', microtime(true)), $level, $type, $msg);\n\t}\n\tpublic function getStatusEvents($lastCtime){\n\t\tif($lastCtime < 1){\n\t\t\t$lastCtime = $this->getDB()->querySingle(\"select ctime from \" . $this->statusTable . \" order by ctime desc limit 1000,1\");\n\t\t\tif(! $lastCtime){\n\t\t\t\t$lastCtime = 0;\n\t\t\t}\n\t\t}\n\t\t$results = $this->getDB()->querySelect(\"select ctime, level, type, msg from \" . $this->statusTable . \" where ctime > %f order by ctime asc\", $lastCtime);\n\t\t$timeOffset = 3600 * get_option('gmt_offset');\n\t\tforeach($results as &$rec){\n\t\t\t\/\/$rec['timeAgo'] = wfUtils::makeTimeAgo(time() - $rec['ctime']);\n\t\t\t$rec['date'] = date('M d H:i:s', (int) $rec['ctime'] + $timeOffset);\n\t\t\t$rec['msg'] = wp_kses_data( (string) $rec['msg']);\n\t\t}\n\t\treturn $results;\n\t}\n\tpublic function getSummaryEvents(){\n\t\t$results = $this->getDB()->querySelect(\"select ctime, level, type, msg from \" . $this->statusTable . \" where level = 10 order by ctime desc limit 100\");\n\t\t$timeOffset = 3600 * get_option('gmt_offset');\n\t\tforeach($results as &$rec){\n\t\t\t$rec['date'] = date('M d H:i:s', (int) $rec['ctime'] + $timeOffset);\n\t\t\tif(strpos($rec['msg'], 'SUM_PREP:') === 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn array_reverse($results);\n\t}\n\n\t\/**\n\t * @return string\n\t *\/\n\tpublic function getGooglePattern() {\n\t\treturn $this->googlePattern;\n\t}\n\n}\n\n\/**\n *\n *\/\nclass wfUserIPRange {\n\n\t\/**\n\t * @var string|null\n\t *\/\n\tprivate $ip_string;\n\n\t\/**\n\t * @param string|null $ip_string\n\t *\/\n\tpublic function __construct($ip_string = null) {\n\t\t$this->setIPString($ip_string);\n\t}\n\n\t\/**\n\t * Check if the supplied IP address is within the user supplied range.\n\t *\n\t * @param string $ip\n\t * @return bool\n\t *\/\n\tpublic function isIPInRange($ip) {\n\t\t$ip_string = $this->getIPString();\n\t\t\n\t\tif (strpos($ip_string, '\/') !== false) { \/\/CIDR range -- 127.0.0.1\/24\n\t\t\treturn wfUtils::subnetContainsIP($ip_string, $ip);\n\t\t}\n\t\telse if (strpos($ip_string, '[') !== false) \/\/Bracketed range -- 127.0.0.[1-100]\n\t\t{\n\t\t\t\/\/ IPv4 range\n\t\t\tif (strpos($ip_string, '.') !== false && strpos($ip, '.') !== false) {\n\t\t\t\t\/\/ IPv4-mapped-IPv6\n\t\t\t\tif (preg_match('\/:ffff:([^:]+)$\/i', $ip_string, $matches)) {\n\t\t\t\t\t$ip_string = $matches[1];\n\t\t\t\t}\n\t\t\t\tif (preg_match('\/:ffff:([^:]+)$\/i', $ip, $matches)) {\n\t\t\t\t\t$ip = $matches[1];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\/\/ Range check\n\t\t\t\tif (preg_match('\/\\[\\d+\\-\\d+\\]\/', $ip_string)) {\n\t\t\t\t\t$IPparts = explode('.', $ip);\n\t\t\t\t\t$whiteParts = explode('.', $ip_string);\n\t\t\t\t\t$mismatch = false;\n\t\t\t\t\tif (count($whiteParts) != 4 || count($IPparts) != 4) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor ($i = 0; $i <= 3; $i++) {\n\t\t\t\t\t\tif (preg_match('\/^\\[(\\d+)\\-(\\d+)\\]$\/', $whiteParts[$i], $m)) {\n\t\t\t\t\t\t\tif ($IPparts[$i] < $m[1] || $IPparts[$i] > $m[2]) {\n\t\t\t\t\t\t\t\t$mismatch = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ($whiteParts[$i] != $IPparts[$i]) {\n\t\t\t\t\t\t\t$mismatch = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ($mismatch === false) {\n\t\t\t\t\t\treturn true; \/\/ Is whitelisted because we did not get a mismatch\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ($ip_string == $ip) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\/\/ IPv6 range\n\t\t\t}\n\t\t\telse if (strpos($ip_string, ':') !== false && strpos($ip, ':') !== false) {\n\t\t\t\t$ip = strtolower(wfUtils::expandIPv6Address($ip));\n\t\t\t\t$ip_string = strtolower(self::expandIPv6Range($ip_string));\n\t\t\t\tif (preg_match('\/\\[[a-f0-9]+\\-[a-f0-9]+\\]\/i', $ip_string)) {\n\t\t\t\t\t$IPparts = explode(':', $ip);\n\t\t\t\t\t$whiteParts = explode(':', $ip_string);\n\t\t\t\t\t$mismatch = false;\n\t\t\t\t\tif (count($whiteParts) != 8 || count($IPparts) != 8) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor ($i = 0; $i <= 7; $i++) {\n\t\t\t\t\t\tif (preg_match('\/^\\[([a-f0-9]+)\\-([a-f0-9]+)\\]$\/i', $whiteParts[$i], $m)) {\n\t\t\t\t\t\t\t$ip_group = hexdec($IPparts[$i]);\n\t\t\t\t\t\t\t$range_group_from = hexdec($m[1]);\n\t\t\t\t\t\t\t$range_group_to = hexdec($m[2]);\n\t\t\t\t\t\t\tif ($ip_group < $range_group_from || $ip_group > $range_group_to) {\n\t\t\t\t\t\t\t\t$mismatch = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ($whiteParts[$i] != $IPparts[$i]) {\n\t\t\t\t\t\t\t$mismatch = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ($mismatch === false) {\n\t\t\t\t\t\treturn true; \/\/ Is whitelisted because we did not get a mismatch\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ($ip_string == $ip) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (strpos($ip_string, '-') !== false) { \/\/Linear range -- 127.0.0.1 - 127.0.1.100\n\t\t\tlist($ip1, $ip2) = explode('-', $ip_string);\n\t\t\t$ip1N = wfUtils::inet_pton($ip1);\n\t\t\t$ip2N = wfUtils::inet_pton($ip2);\n\t\t\t$ipN = wfUtils::inet_pton($ip);\n\t\t\treturn (strcmp($ip1N, $ipN) <= 0 && strcmp($ip2N, $ipN) >= 0);\n\t\t}\n\t\telse { \/\/Treat as a literal IP\n\t\t\t$ip1 = wfUtils::inet_pton($ip_string);\n\t\t\t$ip2 = wfUtils::inet_pton($ip);\n\t\t\tif ($ip1 !== false && $ip1 == $ip2) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\n\tprivate static function repeatString($string, $count) {\n\t\tif ($count <= 0)\n\t\t\treturn '';\n\t\treturn str_repeat($string, $count);\n\t}\n\n\t\/**\n\t * Expand a compressed printable range representation of an IPv6 address.\n\t *\n\t * @todo Hook up exceptions for better error handling.\n\t * @todo Allow IPv4 mapped IPv6 addresses (::ffff:192.168.1.1).\n\t * @param string $ip_range\n\t * @return string\n\t *\/\n\tpublic static function expandIPv6Range($ip_range) {\n\t\t$colon_count = substr_count($ip_range, ':');\n\t\t$dbl_colon_count = substr_count($ip_range, '::');\n\t\tif ($dbl_colon_count > 1) {\n\t\t\treturn false;\n\t\t}\n\t\t$dbl_colon_pos = strpos($ip_range, '::');\n\t\tif ($dbl_colon_pos !== false) {\n\t\t\t$ip_range = str_replace('::', self::repeatString(':0000',\n\t\t\t\t\t(($dbl_colon_pos === 0 || $dbl_colon_pos === strlen($ip_range) - 2) ? 9 : 8) - $colon_count) . ':', $ip_range);\n\t\t\t$ip_range = trim($ip_range, ':');\n\t\t}\n\t\t$colon_count = substr_count($ip_range, ':');\n\t\tif ($colon_count != 7) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$groups = explode(':', $ip_range);\n\t\t$expanded = '';\n\t\tforeach ($groups as $group) {\n\t\t\tif (preg_match('\/\\[([a-f0-9]{1,4})\\-([a-f0-9]{1,4})\\]\/i', $group, $matches)) {\n\t\t\t\t$expanded .= sprintf('[%s-%s]', str_pad(strtolower($matches[1]), 4, '0', STR_PAD_LEFT), str_pad(strtolower($matches[2]), 4, '0', STR_PAD_LEFT)) . ':';\n\t\t\t} else if (preg_match('\/[a-f0-9]{1,4}\/i', $group)) {\n\t\t\t\t$expanded .= str_pad(strtolower($group), 4, '0', STR_PAD_LEFT) . ':';\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn trim($expanded, ':');\n\t}\n\n\t\/**\n\t * @return bool\n\t *\/\n\tpublic function isValidRange() {\n\t\treturn $this->isValidCIDRRange() || $this->isValidBracketedRange() || $this->isValidLinearRange() || wfUtils::isValidIP($this->getIPString());\n\t}\n\t\n\tpublic function isValidCIDRRange() { \/\/e.g., 192.0.2.1\/24\n\t\t$ip_string = $this->getIPString();\n\t\tif (preg_match('\/[^0-9a-f:\\\/\\.]\/i', $ip_string)) { return false; }\n\t\treturn wfUtils::isValidCIDRRange($ip_string);\n\t}\n\t\n\tpublic function isValidBracketedRange() { \/\/e.g., 192.0.2.[1-10]\n\t\t$ip_string = $this->getIPString();\n\t\tif (preg_match('\/[^0-9a-f:\\.\\[\\]\\-]\/i', $ip_string)) { return false; }\n\t\tif (strpos($ip_string, '.') !== false) { \/\/IPv4\n\t\t\tif (preg_match_all('\/(\\d+)\/', $ip_string, $matches) > 0) {\n\t\t\t\tforeach ($matches[1] as $match) {\n\t\t\t\t\t$group = (int) $match;\n\t\t\t\t\tif ($group > 255 || $group < 0) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t$group_regex = '([0-9]{1,3}|\\[[0-9]{1,3}\\-[0-9]{1,3}\\])';\n\t\t\treturn preg_match('\/^' . str_repeat(\"{$group_regex}\\\\.\", 3) . $group_regex . '$\/i', $ip_string) > 0;\n\t\t}\n\t\t\n\t\t\/\/IPv6\n\t\tif (strpos($ip_string, '::') !== false) {\n\t\t\t$ip_string = self::expandIPv6Range($ip_string);\n\t\t}\n\t\tif (!$ip_string) {\n\t\t\treturn false;\n\t\t}\n\t\t$group_regex = '([a-f0-9]{1,4}|\\[[a-f0-9]{1,4}\\-[a-f0-9]{1,4}\\])';\n\t\treturn preg_match('\/^' . str_repeat(\"$group_regex:\", 7) . $group_regex . '$\/i', $ip_string) > 0;\n\t}\n\t\n\tpublic function isValidLinearRange() { \/\/e.g., 192.0.2.1-192.0.2.100\n\t\t$ip_string = $this->getIPString();\n\t\tif (preg_match('\/[^0-9a-f:\\.\\-]\/i', $ip_string)) { return false; }\n\t\tlist($ip1, $ip2) = explode(\"-\", $ip_string);\n\t\t\n\t\tif (!wfUtils::isValidIP($ip1) || !wfUtils::isValidIP($ip2)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t$ip1N = wfUtils::inet_pton($ip1);\n\t\t$ip2N = wfUtils::inet_pton($ip2);\n\t\t\n\t\tif ($ip1N === false || $ip2N === false) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn strcmp($ip1N, $ip2N) <= 0;\n\t}\n\t\n\tpublic function isMixedRange() { \/\/e.g., 192.0.2.1-2001:db8::ffff\n\t\t$ip_string = $this->getIPString();\n\t\tif (preg_match('\/[^0-9a-f:\\.\\-]\/i', $ip_string)) { return false; }\n\t\tlist($ip1, $ip2) = explode(\"-\", $ip_string);\n\t\t\n\t\t$ipv4Count = 0;\n\t\t$ipv4Count += filter_var($ip1, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4) !== false ? 1 : 0;\n\t\t$ipv4Count += filter_var($ip2, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4) !== false ? 1 : 0;\n\t\t\n\t\t$ipv6Count = 0;\n\t\t$ipv6Count += filter_var($ip1, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6) !== false ? 1 : 0;\n\t\t$ipv6Count += filter_var($ip2, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6) !== false ? 1 : 0;\n\t\t\n\t\tif ($ipv4Count != 2 && $ipv6Count != 2) { \n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\n\tprotected function _sanitizeIPRange($ip_string) {\n\t\tif (!is_string($ip_string))\n\t\t\treturn null;\n\t\t$ip_string = preg_replace('\/\\s\/', '', $ip_string); \/\/Strip whitespace\n\t\t$ip_string = preg_replace('\/[\\\\x{2013}-\\\\x{2015}]\/u', '-', $ip_string); \/\/Non-hyphen dashes to hyphen\n\t\t$ip_string = strtolower($ip_string);\n\t\t\n\t\tif (preg_match('\/^\\d+-\\d+$\/', $ip_string)) { \/\/v5 32 bit int style format\n\t\t\tlist($start, $end) = explode('-', $ip_string);\n\t\t\t$start = long2ip($start);\n\t\t\t$end = long2ip($end);\n\t\t\t$ip_string = \"{$start}-{$end}\";\n\t\t}\n\t\t\n\t\treturn $ip_string;\n\t}\n\n\t\/**\n\t * @return string|null\n\t *\/\n\tpublic function getIPString() {\n\t\treturn $this->ip_string;\n\t}\n\n\t\/**\n\t * @param string|null $ip_string\n\t *\/\n\tpublic function setIPString($ip_string) {\n\t\t$this->ip_string = $this->_sanitizeIPRange($ip_string);\n\t}\n}\n\n\/**\n * The function of this class is to detect admin users created via direct access to the database (in other words, not\n * through WordPress).\n *\/\nclass wfAdminUserMonitor {\n\n\tprotected $currentAdminList = array();\n\n\tpublic function isEnabled() {\n\t\t$options = wfScanner::shared()->scanOptions();\n\t\t$enabled = $options['scansEnabled_suspiciousAdminUsers'];\n\t\tif ($enabled && is_multisite()) {\n\t\t\tif (!function_exists('wp_is_large_network')) {\n\t\t\t\trequire_once(ABSPATH . WPINC . '\/ms-functions.php');\n\t\t\t}\n\t\t\t$enabled = !wp_is_large_network('sites') && !wp_is_large_network('users');\n\t\t}\n\t\treturn $enabled;\n\t}\n\n\t\/**\n\t *\n\t *\/\n\tpublic function createInitialList() {\n\t\t$admins = $this->getCurrentAdmins();\n\t\t$adminUserList = array();\n\t\tforeach ($admins as $id => $user) {\n\t\t\t$adminUserList[$id] = 1;\n\t\t}\n\t\twfConfig::set_ser('adminUserList', $adminUserList);\n\t}\n\n\t\/**\n\t * @param int $userID\n\t *\/\n\tpublic function grantSuperAdmin($userID = null) {\n\t\tif ($userID) {\n\t\t\t$this->addAdmin($userID);\n\t\t}\n\t}\n\n\t\/**\n\t * @param int $userID\n\t *\/\n\tpublic function revokeSuperAdmin($userID = null) {\n\t\tif ($userID) {\n\t\t\t$this->removeAdmin($userID);\n\t\t}\n\t}\n\n\t\/**\n\t * @param int $ID\n\t * @param mixed $role\n\t * @param mixed $old_roles\n\t *\/\n\tpublic function updateToUserRole($ID = null, $role = null, $old_roles = null) {\n\t\t$admins = $this->getLoggedAdmins();\n\t\tif ($role !== 'administrator' && array_key_exists($ID, $admins)) {\n\t\t\t$this->removeAdmin($ID);\n\t\t} else if ($role === 'administrator') {\n\t\t\t$this->addAdmin($ID);\n\t\t}\n\t}\n\n\t\/**\n\t * @return array|bool\n\t *\/\n\tpublic function checkNewAdmins() {\n\t\t$loggedAdmins = $this->getLoggedAdmins();\n\t\t$admins = $this->getCurrentAdmins();\n\t\t$suspiciousAdmins = array();\n\t\tforeach ($admins as $adminID => $v) {\n\t\t\tif (!array_key_exists($adminID, $loggedAdmins)) {\n\t\t\t\t$suspiciousAdmins[] = $adminID;\n\t\t\t}\n\t\t}\n\t\treturn $suspiciousAdmins ? $suspiciousAdmins : false;\n\t}\n\n\t\/**\n\t * Checks if the supplied user ID is suspicious.\n\t *\n\t * @param int $userID\n\t * @return bool\n\t *\/\n\tpublic function isAdminUserLogged($userID) {\n\t\t$loggedAdmins = $this->getLoggedAdmins();\n\t\treturn array_key_exists($userID, $loggedAdmins);\n\t}\n\n\t\/**\n\t * @param bool $forceReload\n\t * @return array\n\t *\/\n\tpublic function getCurrentAdmins($forceReload = false) {\n\t\tif (empty($this->currentAdminList) || $forceReload) {\n\t\t\trequire_once(ABSPATH . WPINC . '\/user.php');\n\t\t\tif (is_multisite()) {\n\t\t\t\tif (function_exists(\"get_sites\")) {\n\t\t\t\t\t$sites = get_sites(array(\n\t\t\t\t\t\t'network_id' => null,\n\t\t\t\t\t));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$sites = wp_get_sites(array(\n\t\t\t\t\t\t'network_id' => null,\n\t\t\t\t\t));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$sites = array(array(\n\t\t\t\t\t'blog_id' => get_current_blog_id(),\n\t\t\t\t));\n\t\t\t}\n\n\t\t\t\/\/ not very efficient, but the WordPress API doesn't provide a good way to do this.\n\t\t\t$this->currentAdminList = array();\n\t\t\tforeach ($sites as $siteRow) {\n\t\t\t\t$siteRowArray = (array) $siteRow;\n\t\t\t\t$user_query = new WP_User_Query(array(\n\t\t\t\t\t'blog_id' => $siteRowArray['blog_id'],\n\t\t\t\t\t'role'    => 'administrator',\n\t\t\t\t));\n\t\t\t\t$users = $user_query->get_results();\n\t\t\t\tif (is_array($users)) {\n\t\t\t\t\t\/** @var WP_User $user *\/\n\t\t\t\t\tforeach ($users as $user) {\n\t\t\t\t\t\t$this->currentAdminList[$user->ID] = $user;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\/\/ Add any super admins that aren't also admins on a network\n\t\t\t$superAdmins = get_super_admins();\n\t\t\tforeach ($superAdmins as $userLogin) {\n\t\t\t\t$user = get_user_by('login', $userLogin);\n\t\t\t\tif ($user) {\n\t\t\t\t\t$this->currentAdminList[$user->ID] = $user;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn $this->currentAdminList;\n\t}\n\n\tpublic function getLoggedAdmins() {\n\t\t$loggedAdmins = wfConfig::get_ser('adminUserList', false);\n\t\tif (!is_array($loggedAdmins)) {\n\t\t\t$this->createInitialList();\n\t\t\t$loggedAdmins = wfConfig::get_ser('adminUserList', false);\n\t\t}\n\t\tif (!is_array($loggedAdmins)) {\n\t\t\t$loggedAdmins = array();\n\t\t}\n\t\treturn $loggedAdmins;\n\t}\n\n\t\/**\n\t * @param int $userID\n\t *\/\n\tpublic function addAdmin($userID) {\n\t\t$loggedAdmins = $this->getLoggedAdmins();\n\t\tif (!array_key_exists($userID, $loggedAdmins)) {\n\t\t\t$loggedAdmins[$userID] = 1;\n\t\t\twfConfig::set_ser('adminUserList', $loggedAdmins);\n\t\t}\n\t}\n\n\t\/**\n\t * @param int $userID\n\t *\/\n\tpublic function removeAdmin($userID) {\n\t\t$loggedAdmins = $this->getLoggedAdmins();\n\t\tif (array_key_exists($userID, $loggedAdmins) && !array_key_exists($userID, $this->getCurrentAdmins())) {\n\t\t\tunset($loggedAdmins[$userID]);\n\t\t\twfConfig::set_ser('adminUserList', $loggedAdmins);\n\t\t}\n\t}\n}\n\n\/**\n * Represents a request record\n * \n * @property int $id\n * @property float $attackLogTime\n * @property float $ctime\n * @property string $IP\n * @property bool $jsRun\n * @property int $statusCode\n * @property bool $isGoogle\n * @property int $userID\n * @property string $URL\n * @property string $referer\n * @property string $UA\n * @property string $action\n * @property string $actionDescription\n * @property string $actionData\n *\/\nclass wfRequestModel extends wfModel {\n\n\tprivate static $actionDataEncodedParams = array(\n\t\t'paramKey',\n\t\t'paramValue',\n\t\t'path',\n\t);\n\n\t\/**\n\t * @param $actionData\n\t * @return mixed|string|void\n\t *\/\n\tpublic static function serializeActionData($actionData, $optionalKeys = array(), $maxLength = 65535) {\n\t\tif (is_array($actionData)) {\n\t\t\tforeach (self::$actionDataEncodedParams as $key) {\n\t\t\t\tif (array_key_exists($key, $actionData)) {\n\t\t\t\t\t$actionData[$key] = base64_encode($actionData[$key]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\t$serialized = json_encode($actionData, JSON_UNESCAPED_SLASHES);\n\t\t\t$length = strlen($serialized);\n\t\t\tif ($length <= $maxLength)\n\t\t\t\treturn $serialized;\n\t\t\t$excess = $length - $maxLength;\n\t\t\t$truncated = false;\n\t\t\tforeach ($optionalKeys as $key) {\n\t\t\t\tif (array_key_exists($key, $actionData)) {\n\t\t\t\t\t$fieldValue = $actionData[$key];\n\t\t\t\t\t$fieldLength = strlen($fieldValue);\n\t\t\t\t\t$truncatedLength = min($fieldLength, $excess);\n\t\t\t\t\t$truncated = true;\n\t\t\t\t\tif ($truncatedLength > 0) {\n\t\t\t\t\t\t$actionData[$key] = substr($fieldValue, 0, -$truncatedLength);\n\t\t\t\t\t\t$excess -= $truncatedLength;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tunset($actionData[$key]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} while ($truncated);\n\t\treturn null;\n\t}\n\n\t\/**\n\t * @param $actionDataJSON\n\t * @return mixed|string|void\n\t *\/\n\tpublic static function unserializeActionData($actionDataJSON) {\n\t\t$actionData = json_decode($actionDataJSON, true);\n\t\tif (is_array($actionData)) {\n\t\t\tforeach (self::$actionDataEncodedParams as $key) {\n\t\t\t\tif (array_key_exists($key, $actionData)) {\n\t\t\t\t\t$actionData[$key] = base64_decode($actionData[$key]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t$actionData = array();\n\t\t}\n\t\treturn $actionData;\n\t}\n\n\tprivate $columns = array(\n\t\t'id',\n\t\t'attackLogTime',\n\t\t'ctime',\n\t\t'IP',\n\t\t'jsRun',\n\t\t'statusCode',\n\t\t'isGoogle',\n\t\t'userID',\n\t\t'URL',\n\t\t'referer',\n\t\t'UA',\n\t\t'action',\n\t\t'actionDescription',\n\t\t'actionData',\n\t);\n\n\tpublic function getIDColumn() {\n\t\treturn 'id';\n\t}\n\n\tpublic function getTable() {\n\t\treturn wfDB::networkTable('wfHits');\n\t}\n\n\tpublic function hasColumn($column) {\n\t\treturn in_array($column, $this->columns);\n\t}\n\t\n\tpublic function save() {\n\t\t$sapi = @php_sapi_name();\n\t\tif ($sapi == \"cli\") {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn parent::save();\n\t}\n}\n\n\nclass wfLiveTrafficQuery {\n\n\tprotected $validParams = array(\n\t\t'id' => 'h.id',\n\t\t'ctime' => 'h.ctime',\n\t\t'ip' => 'h.ip',\n\t\t'jsrun' => 'h.jsrun',\n\t\t'statuscode' => 'h.statuscode',\n\t\t'isgoogle' => 'h.isgoogle',\n\t\t'userid' => 'h.userid',\n\t\t'url' => 'h.url',\n\t\t'referer' => 'h.referer',\n\t\t'ua' => 'h.ua',\n\t\t'action' => 'h.action',\n\t\t'actiondescription' => 'h.actiondescription',\n\t\t'actiondata' => 'h.actiondata',\n\n\t\t\/\/ wfLogins\n\t\t'user_login' => 'u.user_login',\n\t\t'username' => 'l.username',\n\t);\n\n\t\/** @var wfLiveTrafficQueryFilterCollection *\/\n\tprivate $filters = array();\n\n\t\/** @var wfLiveTrafficQueryGroupBy *\/\n\tprivate $groupBy;\n\t\/**\n\t * @var float|null\n\t *\/\n\tprivate $startDate;\n\t\/**\n\t * @var float|null\n\t *\/\n\tprivate $endDate;\n\t\/**\n\t * @var int\n\t *\/\n\tprivate $limit;\n\t\/**\n\t * @var int\n\t *\/\n\tprivate $offset;\n\n\tprivate $tableName;\n\n\t\/** @var wfLog *\/\n\tprivate $wfLog;\n\n\t\/**\n\t * wfLiveTrafficQuery constructor.\n\t *\n\t * @param wfLog $wfLog\n\t * @param wfLiveTrafficQueryFilterCollection $filters\n\t * @param wfLiveTrafficQueryGroupBy $groupBy\n\t * @param float $startDate\n\t * @param float $endDate\n\t * @param int $limit\n\t * @param int $offset\n\t *\/\n\tpublic function __construct($wfLog, $filters = null, $groupBy = null, $startDate = null, $endDate = null, $limit = 20, $offset = 0) {\n\t\t$this->wfLog = $wfLog;\n\t\t$this->filters = $filters;\n\t\t$this->groupBy = $groupBy;\n\t\t$this->startDate = $startDate;\n\t\t$this->endDate = $endDate;\n\t\t$this->limit = $limit;\n\t\t$this->offset = $offset;\n\t}\n\n\t\/**\n\t * @return array|null|object\n\t *\/\n\tpublic function execute() {\n\t\tglobal $wpdb;\n\t\t$delayedHumanBotFiltering = false;\n\t\t$humanOnly = false;\n\t\t$sql = $this->buildQuery($delayedHumanBotFiltering, $humanOnly);\n\t\t$results = $wpdb->get_results($sql, ARRAY_A);\n\t\t\n\t\tif ($delayedHumanBotFiltering) {\n\t\t\t$browscap = wfBrowscap::shared();\n\t\t\tforeach ($results as $index => $res) {\n\t\t\t\tif ($res['UA']) {\n\t\t\t\t\t$b = $browscap->getBrowser($res['UA']);\n\t\t\t\t\t$jsRun = wfUtils::truthyToBoolean($res['jsRun']);\n\t\t\t\t\tif ($b && $b['Parent'] != 'DefaultProperties') {\n\t\t\t\t\t\t$jsRun = wfUtils::truthyToBoolean($res['jsRun']);\n\t\t\t\t\t\tif (!wfConfig::liveTrafficEnabled() && !$jsRun) {\n\t\t\t\t\t\t\t$jsRun = !(isset($b['Crawler']) && $b['Crawler']);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (!$humanOnly && $jsRun || $humanOnly && !$jsRun) {\n\t\t\t\t\t\tunset($results[$index]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t$this->getWFLog()->processGetHitsResults('', $results);\n\t\t\n\t\t$verifyCrawlers = false;\n\t\tif ($this->filters !== null && count($this->filters->getFilters()) > 0) {\n\t\t\t$filters = $this->filters->getFilters();\n\t\t\tforeach ($filters as $f) {\n\t\t\t\tif (strtolower($f->getParam()) == \"isgoogle\") {\n\t\t\t\t\t$verifyCrawlers = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tforeach ($results as $key => &$row) {\n\t\t\tif ($row['isGoogle'] && $verifyCrawlers) {\n\t\t\t\tif (!wfCrawl::isVerifiedGoogleCrawler($row['IP'], $row['UA'])) {\n\t\t\t\t\tunset($results[$key]); \/\/foreach copies $results and iterates on the copy, so it is safe to mutate $results within the loop\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$row['actionData'] = $row['actionData'] === null ? array() : (array) json_decode($row['actionData'], true);\n\t\t}\n\t\treturn array_values($results);\n\t}\n\n\t\/**\n\t * @param mixed $delayedHumanBotFiltering Whether or not human\/bot filtering should be applied in PHP rather than SQL.\n\t * @param mixed $humanOnly When using delayed filtering, whether to show only humans or only bots.\n\t * \n\t * @return string\n\t * @throws wfLiveTrafficQueryException\n\t *\/\n\tpublic function buildQuery(&$delayedHumanBotFiltering, &$humanOnly) {\n\t\tglobal $wpdb;\n\t\t$filters = $this->getFilters();\n\t\t$groupBy = $this->getGroupBy();\n\t\t$startDate = $this->getStartDate();\n\t\t$endDate = $this->getEndDate();\n\t\t$limit = absint($this->getLimit());\n\t\t$offset = absint($this->getOffset());\n\n\t\t$wheres = array(\"h.action != 'logged:waf'\", \"h.action != 'scan:detectproxy'\");\n\t\tif ($startDate) {\n\t\t\t$wheres[] = $wpdb->prepare('h.ctime > %f', $startDate);\n\t\t}\n\t\tif ($endDate) {\n\t\t\t$wheres[] = $wpdb->prepare('h.ctime < %f', $endDate);\n\t\t}\n\n\t\tif ($filters instanceof wfLiveTrafficQueryFilterCollection) {\n\t\t\tif (!wfConfig::liveTrafficEnabled()) {\n\t\t\t\t$individualFilters = $filters->getFilters();\n\t\t\t\tforeach ($individualFilters as $index => $f) {\n\t\t\t\t\tif ($f->getParam() == 'jsRun' && $delayedHumanBotFiltering !== null && $humanOnly !== null) {\n\t\t\t\t\t\t$humanOnly = wfUtils::truthyToBoolean($f->getValue());\n\t\t\t\t\t\tif ($f->getOperator() == '!=') {\n\t\t\t\t\t\t\t$humanOnly = !$humanOnly;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$delayedHumanBotFiltering = true;\n\t\t\t\t\t\tunset($individualFilters[$index]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$filters->setFilters($individualFilters);\n\t\t\t}\n\t\t\t\n\t\t\t$filtersSQL = $filters->toSQL();\n\t\t\tif ($filtersSQL) {\n\t\t\t\t$wheres[] = $filtersSQL;\n\t\t\t}\n\t\t}\n\n\t\t$orderBy = 'ORDER BY h.ctime DESC';\n\t\t$select = ', l.username';\n\t\t$groupBySQL = '';\n\t\tif ($groupBy && $groupBy->validate()) {\n\t\t\t$groupBySQL = \"GROUP BY {$groupBy->getParam()}\";\n\t\t\t$orderBy = 'ORDER BY hitCount DESC';\n\t\t\t$select .= ', COUNT(h.id) as hitCount, MAX(h.ctime) AS lastHit, u.user_login AS username';\n\t\t\t\n\t\t\tif ($groupBy->getParam() == 'user_login') {\n\t\t\t\t$wheres[] = 'user_login IS NOT NULL';\n\t\t\t}\n\t\t\telse if ($groupBy->getParam() == 'action') {\n\t\t\t\t$wheres[] = '(statusCode = 403 OR statusCode = 503)';\n\t\t\t}\n\t\t}\n\t\t\n\t\t$where = join(' AND ', $wheres);\n\t\tif ($where) {\n\t\t\t$where = 'WHERE ' . $where;\n\t\t}\n\t\tif (!$limit || $limit > 1000) {\n\t\t\t$limit = 20;\n\t\t}\n\t\t$limitSQL = $wpdb->prepare('LIMIT %d, %d', $offset, $limit);\n\t\t\n\t\t$table_wfLogins = wfDB::networkTable('wfLogins');\n\t\t$sql = <<<SQL\nSELECT h.*, u.display_name{$select} FROM {$this->getTableName()} h\nLEFT JOIN {$wpdb->users} u on h.userID = u.ID\nLEFT JOIN {$table_wfLogins} l on h.id = l.hitID\n$where\n$groupBySQL\n$orderBy\n$limitSQL\nSQL;\n\n\t\treturn $sql;\n\t}\n\n\t\/**\n\t * @param $param\n\t * @return bool\n\t *\/\n\tpublic function isValidParam($param) {\n\t\treturn array_key_exists(strtolower($param), $this->validParams);\n\t}\n\n\t\/**\n\t * @param $getParam\n\t * @return bool|string\n\t *\/\n\tpublic function getColumnFromParam($getParam) {\n\t\t$getParam = strtolower($getParam);\n\t\tif (array_key_exists($getParam, $this->validParams)) {\n\t\t\treturn $this->validParams[$getParam];\n\t\t}\n\t\treturn false;\n\t}\n\n\t\/**\n\t * @return wfLiveTrafficQueryFilterCollection\n\t *\/\n\tpublic function getFilters() {\n\t\treturn $this->filters;\n\t}\n\n\t\/**\n\t * @param wfLiveTrafficQueryFilterCollection $filters\n\t *\/\n\tpublic function setFilters($filters) {\n\t\t$this->filters = $filters;\n\t}\n\n\t\/**\n\t * @return float|null\n\t *\/\n\tpublic function getStartDate() {\n\t\treturn $this->startDate;\n\t}\n\n\t\/**\n\t * @param float|null $startDate\n\t *\/\n\tpublic function setStartDate($startDate) {\n\t\t$this->startDate = $startDate;\n\t}\n\n\t\/**\n\t * @return float|null\n\t *\/\n\tpublic function getEndDate() {\n\t\treturn $this->endDate;\n\t}\n\n\t\/**\n\t * @param float|null $endDate\n\t *\/\n\tpublic function setEndDate($endDate) {\n\t\t$this->endDate = $endDate;\n\t}\n\n\t\/**\n\t * @return wfLiveTrafficQueryGroupBy\n\t *\/\n\tpublic function getGroupBy() {\n\t\treturn $this->groupBy;\n\t}\n\n\t\/**\n\t * @param wfLiveTrafficQueryGroupBy $groupBy\n\t *\/\n\tpublic function setGroupBy($groupBy) {\n\t\t$this->groupBy = $groupBy;\n\t}\n\n\t\/**\n\t * @return int\n\t *\/\n\tpublic function getLimit() {\n\t\treturn $this->limit;\n\t}\n\n\t\/**\n\t * @param int $limit\n\t *\/\n\tpublic function setLimit($limit) {\n\t\t$this->limit = $limit;\n\t}\n\n\t\/**\n\t * @return int\n\t *\/\n\tpublic function getOffset() {\n\t\treturn $this->offset;\n\t}\n\n\t\/**\n\t * @param int $offset\n\t *\/\n\tpublic function setOffset($offset) {\n\t\t$this->offset = $offset;\n\t}\n\n\t\/**\n\t * @return string\n\t *\/\n\tpublic function getTableName() {\n\t\tif ($this->tableName === null) {\n\t\t\t$this->tableName = wfDB::networkTable('wfHits');\n\t\t}\n\t\treturn $this->tableName;\n\t}\n\n\t\/**\n\t * @param string $tableName\n\t *\/\n\tpublic function setTableName($tableName) {\n\t\t$this->tableName = $tableName;\n\t}\n\n\t\/**\n\t * @return wfLog\n\t *\/\n\tpublic function getWFLog() {\n\t\treturn $this->wfLog;\n\t}\n\n\t\/**\n\t * @param wfLog $wfLog\n\t *\/\n\tpublic function setWFLog($wfLog) {\n\t\t$this->wfLog = $wfLog;\n\t}\n}\n\nclass wfLiveTrafficQueryFilterCollection {\n\n\tprivate $filters = array();\n\n\t\/**\n\t * wfLiveTrafficQueryFilterCollection constructor.\n\t *\n\t * @param array $filters\n\t *\/\n\tpublic function __construct($filters = array()) {\n\t\t$this->filters = $filters;\n\t}\n\n\tpublic function toSQL() {\n\t\t$params = array();\n\t\t$sql = '';\n\t\t$filters = $this->getFilters();\n\t\tif ($filters) {\n\t\t\t\/** @var wfLiveTrafficQueryFilter $filter *\/\n\t\t\tforeach ($filters as $filter) {\n\t\t\t\t$params[$filter->getParam()][] = $filter;\n\t\t\t}\n\t\t}\n\n\t\tforeach ($params as $param => $filters) {\n\t\t\t\/\/ $sql .= '(';\n\t\t\t$filtersSQL = '';\n\t\t\tforeach ($filters as $filter) {\n\t\t\t\t$filterSQL = $filter->toSQL();\n\t\t\t\tif ($filterSQL) {\n\t\t\t\t\t$filtersSQL .= $filterSQL . ' OR ';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ($filtersSQL) {\n\t\t\t\t$sql .= '(' . substr($filtersSQL, 0, -4) . ') AND ';\n\t\t\t}\n\t\t}\n\t\tif ($sql) {\n\t\t\t$sql = substr($sql, 0, -5);\n\t\t}\n\t\treturn $sql;\n\t}\n\n\tpublic function addFilter($filter) {\n\t\t$this->filters[] = $filter;\n\t}\n\n\t\/**\n\t * @return array\n\t *\/\n\tpublic function getFilters() {\n\t\treturn $this->filters;\n\t}\n\n\t\/**\n\t * @param array $filters\n\t *\/\n\tpublic function setFilters($filters) {\n\t\t$this->filters = $filters;\n\t}\n}\n\nclass wfLiveTrafficQueryFilter {\n\n\tprivate $param;\n\tprivate $operator;\n\tprivate $value;\n\n\tprotected $validOperators = array(\n\t\t'=',\n\t\t'!=',\n\t\t'contains',\n\t\t'match',\n\t\t'hregexp',\n\t\t'hnotregexp',\n\t);\n\n\t\/**\n\t * @var wfLiveTrafficQuery\n\t *\/\n\tprivate $query;\n\n\t\/**\n\t * wfLiveTrafficQueryFilter constructor.\n\t *\n\t * @param wfLiveTrafficQuery $query\n\t * @param string $param\n\t * @param string $operator\n\t * @param string $value\n\t *\/\n\tpublic function __construct($query, $param, $operator, $value) {\n\t\t$this->query = $query;\n\t\t$this->param = $param;\n\t\t$this->operator = $operator;\n\t\t$this->value = $value;\n\t}\n\n\t\/**\n\t * @return string|void\n\t *\/\n\tpublic function toSQL() {\n\t\t$sql = '';\n\t\tif ($this->validate()) {\n\t\t\t\/** @var wpdb $wpdb *\/\n\t\t\tglobal $wpdb;\n\t\t\t$operator = $this->getOperator();\n\t\t\t$param = $this->getQuery()->getColumnFromParam($this->getParam());\n\t\t\tif (!$param) {\n\t\t\t\treturn $sql;\n\t\t\t}\n\t\t\t$value = $this->getValue();\n\t\t\tswitch ($operator) {\n\t\t\t\tcase 'contains':\n\t\t\t\t\t$like = addcslashes($value, '_%\\\\');\n\t\t\t\t\t$sql = $wpdb->prepare(\"$param LIKE %s\", \"%$like%\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'match':\n\t\t\t\t\t$sql = $wpdb->prepare(\"$param LIKE %s\", $value);\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tcase 'hregexp':\n\t\t\t\t\t$sql = $wpdb->prepare(\"HEX($param) REGEXP %s\", $value);\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tcase 'hnotregexp':\n\t\t\t\t\t$sql = $wpdb->prepare(\"HEX($param) NOT REGEXP %s\", $value);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t$sql = $wpdb->prepare(\"$param $operator %s\", $value);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn $sql;\n\t}\n\n\t\/**\n\t * @return bool\n\t *\/\n\tpublic function validate() {\n\t\t$valid = $this->isValidParam($this->getParam()) && $this->isValidOperator($this->getOperator());\n\t\tif (defined('WP_DEBUG') && WP_DEBUG) {\n\t\t\tif (!$valid) {\n\t\t\t\tthrow new wfLiveTrafficQueryException(\"Invalid param\/operator [{$this->getParam()}]\/[{$this->getOperator()}] passed to \" . get_class($this));\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn $valid;\n\t}\n\n\t\/**\n\t * @param string $param\n\t * @return bool\n\t *\/\n\tpublic function isValidParam($param) {\n\t\treturn $this->getQuery() && $this->getQuery()->isValidParam($param);\n\t}\n\n\t\/**\n\t * @param string $operator\n\t * @return bool\n\t *\/\n\tpublic function isValidOperator($operator) {\n\t\treturn in_array($operator, $this->validOperators);\n\t}\n\n\t\/**\n\t * @return mixed\n\t *\/\n\tpublic function getParam() {\n\t\treturn $this->param;\n\t}\n\n\t\/**\n\t * @param mixed $param\n\t *\/\n\tpublic function setParam($param) {\n\t\t$this->param = $param;\n\t}\n\n\t\/**\n\t * @return mixed\n\t *\/\n\tpublic function getOperator() {\n\t\treturn $this->operator;\n\t}\n\n\t\/**\n\t * @param mixed $operator\n\t *\/\n\tpublic function setOperator($operator) {\n\t\t$this->operator = $operator;\n\t}\n\n\t\/**\n\t * @return mixed\n\t *\/\n\tpublic function getValue() {\n\t\treturn $this->value;\n\t}\n\n\t\/**\n\t * @param mixed $value\n\t *\/\n\tpublic function setValue($value) {\n\t\t$this->value = $value;\n\t}\n\n\t\/**\n\t * @return wfLiveTrafficQuery\n\t *\/\n\tpublic function getQuery() {\n\t\treturn $this->query;\n\t}\n\n\t\/**\n\t * @param wfLiveTrafficQuery $query\n\t *\/\n\tpublic function setQuery($query) {\n\t\t$this->query = $query;\n\t}\n}\n\nclass wfLiveTrafficQueryGroupBy {\n\n\tprivate $param;\n\n\t\/**\n\t * @var wfLiveTrafficQuery\n\t *\/\n\tprivate $query;\n\n\t\/**\n\t * wfLiveTrafficQueryGroupBy constructor.\n\t *\n\t * @param wfLiveTrafficQuery $query\n\t * @param string $param\n\t *\/\n\tpublic function __construct($query, $param) {\n\t\t$this->query = $query;\n\t\t$this->param = $param;\n\t}\n\n\t\/**\n\t * @return bool\n\t * @throws wfLiveTrafficQueryException\n\t *\/\n\tpublic function validate() {\n\t\t$valid = $this->isValidParam($this->getParam());\n\t\tif (defined('WP_DEBUG') && WP_DEBUG) {\n\t\t\tif (!$valid) {\n\t\t\t\tthrow new wfLiveTrafficQueryException(\"Invalid param [{$this->getParam()}] passed to \" . get_class($this));\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn $valid;\n\t}\n\n\t\/**\n\t * @param string $param\n\t * @return bool\n\t *\/\n\tpublic function isValidParam($param) {\n\t\treturn $this->getQuery() && $this->getQuery()->isValidParam($param);\n\t}\n\n\t\/**\n\t * @return wfLiveTrafficQuery\n\t *\/\n\tpublic function getQuery() {\n\t\treturn $this->query;\n\t}\n\n\t\/**\n\t * @param wfLiveTrafficQuery $query\n\t *\/\n\tpublic function setQuery($query) {\n\t\t$this->query = $query;\n\t}\n\n\t\/**\n\t * @return mixed\n\t *\/\n\tpublic function getParam() {\n\t\treturn $this->param;\n\t}\n\n\t\/**\n\t * @param mixed $param\n\t *\/\n\tpublic function setParam($param) {\n\t\t$this->param = $param;\n\t}\n\n}\n\n\nclass wfLiveTrafficQueryException extends Exception {\n\n}\n\nclass wfErrorLogHandler {\n\tpublic static function getErrorLogs($deepSearch = false) {\n\t\tstatic $errorLogs = null;\n\t\t\n\t\tif ($errorLogs === null) {\n\t\t\t$searchPaths = array(ABSPATH, ABSPATH . 'wp-admin', ABSPATH . 'wp-content');\n\t\t\t\n\t\t\t$homePath = wfUtils::getHomePath();\n\t\t\tif (!in_array($homePath, $searchPaths)) {\n\t\t\t\t$searchPaths[] = $homePath;\n\t\t\t}\n\t\t\t\n\t\t\t$errorLogPath = ini_get('error_log');\n\t\t\tif (!empty($errorLogPath) && !in_array($errorLogPath, $searchPaths)) {\n\t\t\t\t$searchPaths[] = $errorLogPath;\n\t\t\t}\n\t\t\t\n\t\t\t$errorLogs = array();\n\t\t\tforeach ($searchPaths as $s) {\n\t\t\t\t$errorLogs = array_merge($errorLogs, self::_scanForLogs($s, $deepSearch));\n\t\t\t}\n\t\t}\n\t\treturn $errorLogs;\n\t}\n\t\n\tprivate static function _scanForLogs($path, $deepSearch = false) {\n\t\tstatic $processedFolders = array(); \/\/Protection for endless loops caused by symlinks\n\t\tif (is_file($path)) {\n\t\t\t$file = basename($path);\n\t\t\tif (preg_match('#(?:^php_errorlog$|error_log(\\-\\d+)?$|\\.log$)#i', $file)) {\n\t\t\t\treturn array($path => is_readable($path));\n\t\t\t}\n\t\t\treturn array();\n\t\t}\n\t\t\n\t\t$path = untrailingslashit($path);\n\t\tif (empty($path)) {\n\t\t\treturn array();\n\t\t}\n\t\t\n\t\t$contents = @scandir($path);\n\t\tif (!is_array($contents)) {\n\t\t\treturn array();\n\t\t}\n\t\t\n\t\t$processedFolders[$path] = true;\n\t\t$errorLogs = array();\n\t\tforeach ($contents as $name) {\n\t\t\tif ($name == '.' || $name == '..') { continue; }\n\t\t\t$testPath = $path . DIRECTORY_SEPARATOR . $name;\n\t\t\tif (!array_key_exists($testPath, $processedFolders)) {\n\t\t\t\tif ((is_dir($testPath) && $deepSearch) || !is_dir($testPath)) {\n\t\t\t\t\t$errorLogs = array_merge($errorLogs, self::_scanForLogs($testPath, $deepSearch));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn $errorLogs;\n\t}\n\t\n\tpublic static function outputErrorLog($path) {\n\t\t$errorLogs = self::getErrorLogs();\n\t\tif (!isset($errorLogs[$path])) { \/\/Only allow error logs we've identified\n\t\t\tglobal $wp_query;\n\t\t\t$wp_query->set_404();\n\t\t\tstatus_header(404);\n\t\t\tnocache_headers();\n\t\t\t\n\t\t\t$template = get_404_template();\n\t\t\tif ($template && file_exists($template)) {\n\t\t\t\tinclude($template);\n\t\t\t}\n\t\t\texit;\n\t\t}\n\t\t\n\t\t$fh = @fopen($path, 'r');\n\t\tif (!$fh) {\n\t\t\tstatus_header(503);\n\t\t\tnocache_headers();\n\t\t\techo \"503 Service Unavailable\";\n\t\t\texit;\n\t\t}\n\t\t\n\t\t$headersOutputted = false;\n\t\twhile (!feof($fh)) {\n\t\t\t$data = fread($fh, 1 * 1024 * 1024); \/\/read 1 megs max per chunk\n\t\t\tif ($data === false) { \/\/Handle the error where the file was reported readable but we can't actually read it\n\t\t\t\tstatus_header(503);\n\t\t\t\tnocache_headers();\n\t\t\t\techo \"503 Service Unavailable\";\n\t\t\t\texit;\n\t\t\t}\n\t\t\n\t\t\tif (!$headersOutputted) {\n\t\t\t\theader('Content-Type: text\/plain');\n\t\t\t\theader('Content-Disposition: attachment; filename=\"' . basename($path));\n\t\t\t\t$headersOutputted = true;\n\t\t\t}\n\t\t\techo $data;\n\t\t}\n\t\texit;\n\t}\n}"},{"base":"plugins","rel":"wordfence\/lib\/wfDateLocalization.php","ext":"php","size":360582,"mtime":1757312769},{"base":"plugins","rel":"wordfence\/lib\/menu_scanner_credentials.php","ext":"php","size":2838,"mtime":1757312769,"type":"text","content":"<?php\nif (!defined('WORDFENCE_VERSION')) { exit; }\n$scanner = wfScanner::shared();\n$scanURL = network_admin_url('admin.php?page=WordfenceScan');\n\n$action = wfUtils::array_get($_GET, 'action');\nif (!is_string($action) || !in_array($action, array('restoreFile', 'deleteFile'))) { $action = ''; }\n$filesystemCredentialsAdminURL = network_admin_url('admin.php?' . http_build_query(array(\n\t\t'page'               => 'WordfenceScan',\n\t\t'subpage'       \t => 'scan_credentials',\n\t\t'action' \t\t\t => $action,\n\t\t'issueID'            => (int) wfUtils::array_get($_GET, 'issueID', 0),\n\t\t'nonce'              => wp_create_nonce('wp-ajax'),\n\t)));\n\nswitch ($action) {\n\tcase 'restoreFile':\n\t\t$callback = array('wordfence', 'fsActionRestoreFileCallback');\n\t\tbreak;\n\tcase 'deleteFile':\n\t\t$callback = array('wordfence', 'fsActionDeleteFileCallback');\n\t\tbreak;\n}\n?>\n<div class=\"wf-options-controls\">\n\t<div class=\"wf-row\">\n\t\t<div class=\"wf-col-xs-12\">\n\t\t\t<?php\n\t\t\techo wfView::create('options\/block-controls', array(\n\t\t\t\t'backLink' => $scanURL,\n\t\t\t\t'backLabel' => __('Back to Scan', 'wordfence'),\n\t\t\t\t'suppressControls' => true,\n\t\t\t))->render();\n\t\t\t?>\n\t\t<\/div>\n\t<\/div>\n<\/div>\n<div class=\"wf-options-controls-spacer\"><\/div>\n<div class=\"wrap wordfence\">\n\t<div class=\"wf-container-fluid\">\n\t\t<div class=\"wf-row\">\n\t\t\t<div class=\"wf-col-xs-12\">\n\t\t\t\t<div class=\"wp-header-end\"><\/div>\n\t\t\t<\/div>\n\t\t<\/div>\n\t\t<div class=\"wf-row\">\n\t\t\t<div class=\"<?php echo wfStyle::contentClasses(); ?>\">\n\t\t\t\t<div id=\"wf-scan-permissions-prompt\" class=\"wf-fixed-tab-content\">\n\t\t\t\t\t<?php\n\t\t\t\t\techo wfView::create('common\/section-title', array(\n\t\t\t\t\t\t'title' => __('File System Credentials Required', 'wordfence'),\n\t\t\t\t\t))->render();\n\t\t\t\t\t?>\n\t\t\t\t\t<div class=\"wf-row\">\n\t\t\t\t\t\t<div class=\"wf-col-xs-12\">\n\t\t\t\t\t\t\t<div class=\"wf-block wf-active\">\n\t\t\t\t\t\t\t\t<div class=\"wf-block-content wf-padding-add-top wf-padding-add-bottom\">\n\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\tif (isset($_GET['nonce']) && wp_verify_nonce($_GET['nonce'], 'wp-ajax')) {\n\t\t\t\t\t\t\t\t\t\tif (wordfence::requestFilesystemCredentials($filesystemCredentialsAdminURL, wfUtils::getHomePath(), true, true)) {\n\t\t\t\t\t\t\t\t\t\t\tcall_user_func_array($callback, isset($callbackArgs) && is_array($callbackArgs) ? $callbackArgs : array());\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\/\/else - outputs credentials form\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\techo '<p>' . wp_kses(sprintf(\n\t\t\t\t\t\t\t\t\t\t\t\/* translators: URL to the WordPress admin panel. *\/\n\t\t\t\t\t\t\t\t\t\t\t\t__('Security token has expired. Click <a href=\"%s\">here<\/a> to return to the scan page.', 'wordfence'), esc_url($scanURL)), array('a'=>array('href'=>array()))) . '<\/p>';\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t\t<\/div> <!-- end permissions -->\n\t\t\t\t<\/div> <!-- end wf-scan-permissions-prompt block -->\n\t\t\t<\/div> <!-- end content block -->\n\t\t<\/div> <!-- end row -->\n\t<\/div> <!-- end container -->\n<\/div>"},{"base":"plugins","rel":"wordfence\/lib\/wfScan.php","ext":"php","size":16300,"mtime":1757312769,"type":"text","content":"<?php\nclass wfScan {\n\tpublic static $debugMode = false;\n\tpublic static $errorHandlingOn = true;\n\tpublic static $peakMemAtStart = 0;\n\t\n\t\/**\n\t * Returns the stored cronkey or false if not set. If $expired is provided, will set to <timestamp>\/false based\n\t * on whether or not the cronkey is expired.\n\t * \n\t * @param null $expired\n\t * @return bool|string\n\t *\/\n\tprivate static function storedCronKey(&$expired = null) {\n\t\t$currentCronKey = wfConfig::get('currentCronKey', false);\n\t\tif (empty($currentCronKey))\n\t\t{\n\t\t\tif ($expired !== null) {\n\t\t\t\t$expired = false;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t$savedKey = explode(',',$currentCronKey);\n\t\tif (time() - $savedKey[0] > 86400) {\n\t\t\tif ($expired !== null) {\n\t\t\t\t$expired = $savedKey[0];\n\t\t\t}\n\t\t\treturn $savedKey[1];\n\t\t}\n\t\t\n\t\tif ($expired !== null) {\n\t\t\t$expired = false;\n\t\t}\n\t\treturn $savedKey[1];\n\t}\n\t\n\tpublic static function wfScanMain(){\n\t\tself::$peakMemAtStart = memory_get_peak_usage(true);\n\t\t$db = new wfDB();\n\t\tif($db->errorMsg){\n\t\t\tself::errorExit(sprintf(\/* translators: Error message. *\/ __(\"Could not connect to database to start scan: %s\", 'wordfence'), $db->errorMsg));\n\t\t}\n\t\tif(! wordfence::wfSchemaExists()){\n\t\t\tself::errorExit(__(\"Looks like the Wordfence database tables have been deleted. You can fix this by de-activating and re-activating the Wordfence plugin from your Plugins menu.\", 'wordfence'));\n\t\t}\n\t\tif( isset( $_GET['test'] ) && $_GET['test'] == '1'){\n\t\t\techo \"WFCRONTESTOK:\" . wfConfig::get('cronTestID');\n\t\t\tself::status(4, 'info', __(\"Cron test received and message printed\", 'wordfence'));\n\t\t\texit();\n\t\t}\n\t\t\n\t\tself::status(4, 'info', __(\"Scan engine received request.\", 'wordfence'));\n\t\t\n\t\t\/* ----------Starting signature check -------- *\/\n\t\tself::status(4, 'info', __(\"Verifying start request signature.\", 'wordfence'));\n\t\tif (!isset($_GET['signature']) || !wfScanEngine::verifyStartSignature($_GET['signature'], isset($_GET['isFork']) ? wfUtils::truthyToBoolean($_GET['isFork']) : false, isset($_GET['scanMode']) ? $_GET['scanMode'] : '', isset($_GET['cronKey']) ? $_GET['cronKey'] : '', isset($_GET['remote']) ? wfUtils::truthyToBoolean($_GET['remote']) : false)) {\n\t\t\tself::errorExit(__('The signature on the request to start a scan is invalid. Please try again.', 'wordfence'));\n\t\t}\n\t\t\n\t\t\/* ----------Starting cronkey check -------- *\/\n\t\tself::status(4, 'info', __(\"Fetching stored cronkey for comparison.\", 'wordfence'));\n\t\t$expired = false;\n\t\t$storedCronKey = self::storedCronKey($expired);\n\t\t$displayCronKey_received = (isset($_GET['cronKey']) ? (preg_match('\/^[a-f0-9]+$\/i', $_GET['cronKey']) && strlen($_GET['cronKey']) == 32 ? $_GET['cronKey'] : __('[invalid]', 'wordfence')) : __('[none]', 'wordfence'));\n\t\t$displayCronKey_stored = (!empty($storedCronKey) && !$expired ? $storedCronKey : __('[none]', 'wordfence'));\n\t\tself::status(4, 'info', sprintf(\/* translators: 1. WordPress nonce. 2. WordPress nonce. *\/ __('Checking cronkey: %1$s (expecting %2$s)', 'wordfence'), $displayCronKey_received, $displayCronKey_stored));\n\t\tif (empty($_GET['cronKey'])) { \n\t\t\tself::status(4, 'error', __(\"Wordfence scan script accessed directly, or WF did not receive a cronkey.\", 'wordfence'));\n\t\t\techo \"If you see this message it means Wordfence is working correctly. You should not access this URL directly. It is part of the Wordfence security plugin and is designed for internal use only.\";\n\t\t\texit();\n\t\t}\n\t\t\n\t\tif ($expired) {\n\t\t\tself::errorExit(sprintf(\n\t\t\t\/* translators: 1. Unix timestamp. 2. WordPress nonce. 3. Unix timestamp. *\/\n\t\t\t\t__('The key used to start a scan expired. The value is: %1$s and split is: %2$s and time is: %3$d', 'wordfence'), $expired, $storedCronKey, time()));\n\t\t} \/\/keys only last 60 seconds and are used within milliseconds of creation\n\t\t\n\t\tif (!$storedCronKey) {\n\t\t\twordfence::status(4, 'error', __(\"Wordfence could not find a saved cron key to start the scan so assuming it started and exiting.\", 'wordfence'));\n\t\t\texit();\n\t\t} \n\t\t\n\t\tself::status(4, 'info', __(\"Checking saved cronkey against cronkey param\", 'wordfence'));\n\t\tif (!hash_equals($storedCronKey, $_GET['cronKey'])) { \n\t\t\tself::errorExit(\n\t\t\t\tsprintf(\n\t\t\t\t\/* translators: 1. WordPress nonce (used for debugging). 2. WordPress nonce (used for debugging). 3. WordPress nonce (used for debugging). *\/\n\t\t\t\t\t__('Wordfence could not start a scan because the cron key does not match the saved key. Saved: %1$s Sent: %2$s Current unexploded: %3$s', 'wordfence'),\n\t\t\t\t\t$storedCronKey,\n\t\t\t\t\t$_GET['cronKey'],\n\t\t\t\t\twfConfig::get('currentCronKey', false)\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\twfConfig::set('currentCronKey', '');\n\t\t\/* --------- end cronkey check ---------- *\/\n\n\t\twfScanMonitor::logLastSuccess();\n\n\t\t$scanMode = wfScanner::SCAN_TYPE_STANDARD;\n\t\tif (isset($_GET['scanMode']) && wfScanner::isValidScanType($_GET['scanMode'])) {\n\t\t\t$scanMode = $_GET['scanMode'];\n\t\t}\n\t\t$scanController = new wfScanner($scanMode);\n\n\t\twfConfig::remove('scanStartAttempt');\n\t\t$isFork = ($_GET['isFork'] == '1' ? true : false);\n\n\t\twfScanMonitor::handleStageStart($isFork);\n\n\t\tif(! $isFork){\n\t\t\tself::status(4, 'info', __(\"Checking if scan is already running\", 'wordfence'));\n\t\t\tif(! wfUtils::getScanLock()){\n\t\t\t\tself::errorExit(__(\"There is already a scan running.\", 'wordfence'));\n\t\t\t}\n\t\t\t\n\t\t\twfIssues::updateScanStillRunning();\n\t\t\twfConfig::set('wfPeakMemory', 0, wfConfig::DONT_AUTOLOAD);\n\t\t\twfConfig::set('wfScanStartVersion', wfUtils::getWPVersion());\n\t\t\twfConfig::set('lowResourceScanWaitStep', false);\n\t\t\t\n\t\t\tif ($scanController->useLowResourceScanning()) {\n\t\t\t\tself::status(1, 'info', __(\"Using low resource scanning\", 'wordfence'));\n\t\t\t}\n\t\t}\n\t\tself::status(4, 'info', __(\"Requesting max memory\", 'wordfence'));\n\t\twfUtils::requestMaxMemory();\n\t\tself::status(4, 'info', __(\"Setting up error handling environment\", 'wordfence'));\n\t\tset_error_handler('wfScan::error_handler', E_ALL);\n\t\tregister_shutdown_function('wfScan::shutdown');\n\t\tif(! self::$debugMode){\n\t\t\tob_start('wfScan::obHandler');\n\t\t}\n\t\t@error_reporting(E_ALL);\n\t\twfUtils::iniSet('display_errors','On');\n\t\tself::status(4, 'info', __(\"Setting up scanRunning and starting scan\", 'wordfence'));\n\t\ttry {\n\t\t\tif ($isFork) {\n\t\t\t\t$scan = wfConfig::get_ser('wfsd_engine', false, false);\n\t\t\t\tif ($scan) {\n\t\t\t\t\tself::status(4, 'info', sprintf(\/* translators: Error message (used for debugging). *\/ __(\"Got a true deserialized value back from 'wfsd_engine' with type: %s\", 'wordfence'), gettype($scan)));\n\t\t\t\t\twfConfig::set('wfsd_engine', '', wfConfig::DONT_AUTOLOAD);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tself::status(2, 'error', sprintf(\/* translators: Error message (used for debugging). *\/ __(\"Scan can't continue - stored data not found after a fork. Got type: %s\", 'wordfence'), gettype($scan)));\n\t\t\t\t\twfConfig::set('wfsd_engine', '', wfConfig::DONT_AUTOLOAD);\n\t\t\t\t\twfConfig::set('lastScanCompleted', __('Scan can\\'t continue - stored data not found after a fork.', 'wordfence'));\n\t\t\t\t\twfConfig::set('lastScanFailureType', wfIssues::SCAN_FAILED_FORK_FAILED);\n\t\t\t\t\twfUtils::clearScanLock();\n\t\t\t\t\tself::status(2, 'error', \"Scan terminated with error: \" . __('Scan can\\'t continue - stored data not found after a fork.', 'wordfence'));\n\t\t\t\t\tself::status(10, 'info', \"SUM_KILLED:\" . __('Previous scan terminated with an error. See below.', 'wordfence'));\n\t\t\t\t\texit();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$delay = -1;\n\t\t\t\t$isScheduled = false;\n\t\t\t\t$originalScanStart = wfConfig::get('originalScheduledScanStart', 0);\n\t\t\t\t$lastScanStart = wfConfig::get('lastScheduledScanStart', 0);\n\t\t\t\t$minimumFrequency = ($scanController->schedulingMode() == wfScanner::SCAN_SCHEDULING_MODE_MANUAL ? 1800 : 43200);\n\t\t\t\tif ($lastScanStart && (time() - $lastScanStart) < $minimumFrequency) {\n\t\t\t\t\t$isScheduled = true;\n\t\t\t\t\t\n\t\t\t\t\tif ($originalScanStart > 0) {\n\t\t\t\t\t\t$delay = max($lastScanStart - $originalScanStart, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\twfIssues::statusPrep(); \/\/Re-initializes all status counters\n\t\t\t\t$scanController->resetStages();\n\t\t\t\t$scanController->resetSummaryItems();\n\t\t\t\t\n\t\t\t\tif ($scanMode != wfScanner::SCAN_TYPE_QUICK) {\n\t\t\t\t\twordfence::status(1, 'info', __(\"Contacting Wordfence to initiate scan\", 'wordfence'));\n\t\t\t\t\t$wp_version = wfUtils::getWPVersion();\n\t\t\t\t\t$apiKey = wfConfig::get('apiKey');\n\t\t\t\t\t$api = new wfAPI($apiKey, $wp_version);\n\t\t\t\t\t$response = $api->call('log_scan', array(), array('delay' => $delay, 'scheduled' => (int) $isScheduled, 'mode' => wfConfig::get('schedMode')\/*, 'forcedefer' => 1*\/));\n\t\t\t\t\t\n\t\t\t\t\tif ($scanController->schedulingMode() == wfScanner::SCAN_SCHEDULING_MODE_AUTOMATIC && $isScheduled) {\n\t\t\t\t\t\tif (isset($response['defer'])) {\n\t\t\t\t\t\t\t$defer = (int) $response['defer'];\n\t\t\t\t\t\t\twordfence::status(2, 'info', sprintf(\/* translators: Time until. *\/ __(\"Deferring scheduled scan by %s\", 'wordfence'), wfUtils::makeDuration($defer)));\n\t\t\t\t\t\t\twfConfig::set('lastScheduledScanStart', 0);\n\t\t\t\t\t\t\twfConfig::set('lastScanCompleted', 'ok');\n\t\t\t\t\t\t\twfConfig::set('lastScanFailureType', false);\n\t\t\t\t\t\t\twfConfig::set_ser('wfStatusStartMsgs', array());\n\t\t\t\t\t\t\t$scanController->recordLastScanTime();\n\t\t\t\t\t\t\t$i = new wfIssues();\n\t\t\t\t\t\t\twfScanEngine::refreshScanNotification($i);\n\t\t\t\t\t\t\twfScanner::shared()->scheduleSingleScan(time() + $defer, $originalScanStart);\n\t\t\t\t\t\t\twfUtils::clearScanLock();\n\t\t\t\t\t\t\texit();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$malwarePrefixesHash = (isset($response['malwarePrefixes']) ? $response['malwarePrefixes'] : '');\n\t\t\t\t\t$coreHashesHash = (isset($response['coreHashes']) ? $response['coreHashes'] : '');\n\t\t\t\t\t\n\t\t\t\t\t$scan = new wfScanEngine($malwarePrefixesHash, $coreHashesHash, $scanMode);\n\t\t\t\t\t$scan->deleteNewIssues();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twordfence::status(1, 'info', __(\"Initiating quick scan\", 'wordfence'));\n\t\t\t\t\t$scan = new wfScanEngine('', '', $scanMode);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t$scan->go();\n\t\t}\n\t\tcatch (wfScanEngineDurationLimitException $e) { \/\/User error set in wfScanEngine\n\t\t\twfUtils::clearScanLock();\n\t\t\t$peakMemory = self::logPeakMemory();\n\t\t\tself::status(2, 'info', sprintf(\n\t\t\t\t__('Wordfence used %1$s of memory for scan. Server peak memory usage was: %2$s', 'wordfence'),\n\t\t\t\twfUtils::formatBytes($peakMemory - self::$peakMemAtStart),\n\t\t\t\twfUtils::formatBytes($peakMemory)\n\t\t\t));\n\t\t\tself::status(2, 'error', sprintf(__(\"Scan terminated with error: %s\", 'wordfence'), $e->getMessage()));\n\t\t\texit();\n\t\t}\n\t\tcatch (wfScanEngineCoreVersionChangeException $e) { \/\/User error set in wfScanEngine\n\t\t\twfUtils::clearScanLock();\n\t\t\t$peakMemory = self::logPeakMemory();\n\t\t\tself::status(2, 'info', sprintf(\n\t\t\t\t\/* translators: 1. Bytes of memory. 2. Bytes of memory. *\/\n\t\t\t\t__('Wordfence used %1$s of memory for scan. Server peak memory usage was: %2$s', 'wordfence'),\n\t\t\t\twfUtils::formatBytes($peakMemory - self::$peakMemAtStart),\n\t\t\t\twfUtils::formatBytes($peakMemory)\n\t\t\t));\n\t\t\tself::status(2, 'error', sprintf(\/* translators: Error message. *\/ __(\"Scan terminated with error: %s\", 'wordfence'), $e->getMessage()));\n\t\t\t\n\t\t\t$nextScheduledScan = wfScanner::shared()->nextScheduledScanTime();\n\t\t\tif ($nextScheduledScan !== false && $nextScheduledScan - time() > 21600 \/* 6 hours *\/) {\n\t\t\t\t$nextScheduledScan = time() + 3600;\n\t\t\t\twfScanner::shared()->scheduleSingleScan($nextScheduledScan);\n\t\t\t}\n\t\t\tself::status(2, 'error', wordfence::getNextScanStartTime($nextScheduledScan));\n\t\t\t\n\t\t\texit();\n\t\t}\n\t\tcatch (wfAPICallSSLUnavailableException $e) {\n\t\t\twfConfig::set('lastScanCompleted', $e->getMessage());\n\t\t\twfConfig::set('lastScanFailureType', wfIssues::SCAN_FAILED_API_SSL_UNAVAILABLE);\n\t\t\t\n\t\t\twfUtils::clearScanLock();\n\t\t\t$peakMemory = self::logPeakMemory();\n\t\t\tself::status(2, 'info', sprintf(\n\t\t\t\t\/* translators: 1. Bytes of memory. 2. Bytes of memory. *\/\n\t\t\t\t__('Wordfence used %1$s of memory for scan. Server peak memory usage was: %2$s', 'wordfence'),\n\t\t\t\twfUtils::formatBytes($peakMemory - self::$peakMemAtStart),\n\t\t\t\twfUtils::formatBytes($peakMemory)\n\t\t\t));\n\t\t\tself::status(2, 'error', sprintf(\/* translators: Error message. *\/__(\"Scan terminated with error: %s\", 'wordfence'), $e->getMessage()));\n\t\t\texit();\n\t\t}\n\t\tcatch (wfAPICallFailedException $e) {\n\t\t\twfConfig::set('lastScanCompleted', $e->getMessage());\n\t\t\twfConfig::set('lastScanFailureType', wfIssues::SCAN_FAILED_API_CALL_FAILED);\n\t\t\t\n\t\t\twfUtils::clearScanLock();\n\t\t\t$peakMemory = self::logPeakMemory();\n\t\t\tself::status(2, 'info', sprintf(\n\t\t\t\t\/* translators: 1. Bytes of memory. 2. Bytes of memory. *\/\n\t\t\t\t__('Wordfence used %1$s of memory for scan. Server peak memory usage was: %2$s', 'wordfence'),\n\t\t\t\twfUtils::formatBytes($peakMemory - self::$peakMemAtStart),\n\t\t\t\twfUtils::formatBytes($peakMemory)\n\t\t\t));\n\t\t\tself::status(2, 'error', sprintf(\/* translators: Error message. *\/ __(\"Scan terminated with error: %s\", 'wordfence'), $e->getMessage()));\n\t\t\texit();\n\t\t}\n\t\tcatch (wfAPICallInvalidResponseException $e) {\n\t\t\twfConfig::set('lastScanCompleted', $e->getMessage());\n\t\t\twfConfig::set('lastScanFailureType', wfIssues::SCAN_FAILED_API_INVALID_RESPONSE);\n\t\t\t\n\t\t\twfUtils::clearScanLock();\n\t\t\t$peakMemory = self::logPeakMemory();\n\t\t\tself::status(2, 'info', sprintf(\n\t\t\t\t\/* translators: 1. Bytes of memory. 2. Bytes of memory. *\/\n\t\t\t\t__('Wordfence used %1$s of memory for scan. Server peak memory usage was: %2$s', 'wordfence'),\n\t\t\t\twfUtils::formatBytes($peakMemory - self::$peakMemAtStart),\n\t\t\t\twfUtils::formatBytes($peakMemory)\n\t\t\t));\n\t\t\tself::status(2, 'error', sprintf(\/* translators: Error message. *\/ __(\"Scan terminated with error: %s\", 'wordfence'), $e->getMessage()));\n\t\t\texit();\n\t\t}\n\t\tcatch (wfAPICallErrorResponseException $e) {\n\t\t\twfConfig::set('lastScanCompleted', $e->getMessage());\n\t\t\twfConfig::set('lastScanFailureType', wfIssues::SCAN_FAILED_API_ERROR_RESPONSE);\n\t\t\t\n\t\t\twfUtils::clearScanLock();\n\t\t\t$peakMemory = self::logPeakMemory();\n\t\t\tself::status(2, 'info', sprintf(\n\t\t\t\t\/* translators: 1. Bytes of memory. 2. Bytes of memory. *\/\n\t\t\t\t__('Wordfence used %1$s of memory for scan. Server peak memory usage was: %2$s', 'wordfence'),\n\t\t\t\twfUtils::formatBytes($peakMemory - self::$peakMemAtStart),\n\t\t\t\twfUtils::formatBytes($peakMemory)\n\t\t\t));\n\t\t\tself::status(2, 'error', sprintf(\/* translators: Error message. *\/ __(\"Scan terminated with error: %s\", 'wordfence'), $e->getMessage()));\n\n\t\t\tif (preg_match('\/The Wordfence API key you\\'re using is already being used by: (\\S*?) \/', $e->getMessage(), $matches)) {\n\t\t\t\twordfence::alert(__('Wordfence scan failed because of license site URL conflict', 'wordfence'), sprintf(\n\t\t\t\t\/* translators: Site URL. *\/\n\t\t\t\t\t__(<<<MSG\nThe Wordfence scan has failed because the Wordfence API key you're using is already being used by: %s\n\nIf you have changed your blog URL, please sign-in to Wordfence, purchase a new key or reset an existing key, and then enter that key on this site's Wordfence Options page.\nMSG\n\t\t\t\t\t, 'wordfence'), $matches[1]), false);\n\t\t\t}\n\n\t\t\texit();\n\t\t}\n\t\tcatch (Exception $e) {\n\t\t\twfUtils::clearScanLock();\n\t\t\tself::status(2, 'error', sprintf(\/* translators: Error message. *\/ __(\"Scan terminated with error: %s\", 'wordfence'), $e->getMessage()));\n\t\t\tself::status(10, 'info', \"SUM_KILLED:\" . __('Previous scan terminated with an error. See below.', 'wordfence'));\n\t\t\texit();\n\t\t}\n\t\twfUtils::clearScanLock();\n\t}\n\tpublic static function logPeakMemory(){\n\t\t$oldPeak = wfConfig::get('wfPeakMemory', 0, false);\n\t\t$peak = memory_get_peak_usage(true);\n\t\tif ($peak > $oldPeak) {\n\t\t\twfConfig::set('wfPeakMemory', $peak, wfConfig::DONT_AUTOLOAD);\n\t\t\treturn $peak;\n\t\t}\n\t\treturn $oldPeak;\n\t}\n\tpublic static function obHandler($buf){\n\t\tif(strlen($buf) > 1000){\n\t\t\t$buf = substr($buf, 0, 255);\n\t\t}\n\t\tif(empty($buf) === false && preg_match('\/[a-zA-Z0-9]+\/', $buf)){\n\t\t\tself::status(1, 'error', $buf);\n\t\t}\n\t}\n\tpublic static function error_handler($errno, $errstr, $errfile, $errline){\n\t\tif(self::$errorHandlingOn && error_reporting() > 0){\n\t\t\tif(preg_match('\/wordfence\\\/\/', $errfile)){\n\t\t\t\t$level = 1; \/\/It's one of our files, so level 1\n\t\t\t} else {\n\t\t\t\t$level = 4; \/\/It's someone elses plugin so only show if debug is enabled\n\t\t\t}\n\t\t\tself::status($level, 'error', \"$errstr ($errno) File: $errfile Line: $errline\");\n\t\t}\n\t\treturn false;\n\t}\n\tpublic static function shutdown(){\n\t\tself::logPeakMemory();\n\t}\n\tprivate static function errorExit($msg){\n\t\twordfence::status(1, 'error', sprintf(\/* translators: Error message. *\/ __('Scan Engine Error: %s', 'wordfence'), $msg));\n\t\texit();\t\n\t}\n\tprivate static function status($level, $type, $msg){\n\t\twordfence::status($level, $type, $msg);\n\t}\n}"},{"base":"plugins","rel":"wordfence\/lib\/menu_scanner_options.php","ext":"php","size":8615,"mtime":1757312769,"type":"text","content":"<?php\nif (!defined('WORDFENCE_VERSION')) { exit; }\n$scanner = wfScanner::shared();\n$scanOptions = $scanner->scanOptions();\n\n$backPage = new wfPage(wfPage::PAGE_SCAN);\nif (isset($_GET['source']) && wfPage::isValidPage($_GET['source'])) {\n\t$backPage = new wfPage($_GET['source']);\n}\n?>\n<script type=\"application\/javascript\">\n\t(function($) {\n\t\t$(function() {\n\t\t\tdocument.title = \"<?php esc_attr_e('Scanner Options', 'wordfence'); ?>\" + \" \\u2039 \" + WFAD.basePageName;\n\t\t\t\n\t\t\t\/\/Hash-based option block linking\n\t\t\tif (window.location.hash) {\n\t\t\t\tvar hashes = WFAD.parseHashes();\n\t\t\t\tvar hash = hashes[hashes.length - 1];\n\t\t\t\tvar block = $('.wf-block[data-persistence-key=\"' + hash + '\"]');\n\t\t\t\tif (block && block.length) {\n\t\t\t\t\tif (!block.hasClass('wf-active')) {\n\t\t\t\t\t\tblock.find('.wf-block-content').slideDown({\n\t\t\t\t\t\t\talways: function() {\n\t\t\t\t\t\t\t\tblock.addClass('wf-active');\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (hashes.length > 1 && $('#' + hashes[hashes.length - 2]).hasClass('wf-option')) {\n\t\t\t\t\t\t\t\t\t$('html, body').animate({\n\t\t\t\t\t\t\t\t\t\tscrollTop: $('#' + hashes[hashes.length - 2]).offset().top - 100\n\t\t\t\t\t\t\t\t\t}, 1000);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t$('html, body').animate({\n\t\t\t\t\t\t\t\t\t\tscrollTop: block.offset().top - 100\n\t\t\t\t\t\t\t\t\t}, 1000);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tWFAD.ajax('wordfence_saveDisclosureState', {name: block.data('persistenceKey'), state: true}, function() {});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (hashes.length > 1 && $('#' + hashes[hashes.length - 2]).hasClass('wf-option')) {\n\t\t\t\t\t\t\t$('html, body').animate({\n\t\t\t\t\t\t\t\tscrollTop: $('#' + hashes[hashes.length - 2]).offset().top - 100\n\t\t\t\t\t\t\t}, 1000);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t$('html, body').animate({\n\t\t\t\t\t\t\t\tscrollTop: block.offset().top - 100\n\t\t\t\t\t\t\t}, 1000);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\thistory.replaceState('', document.title, window.location.pathname + window.location.search);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t})(jQuery);\n<\/script>\n<div class=\"wf-options-controls\">\n\t<div class=\"wf-row\">\n\t\t<div class=\"wf-col-xs-12\">\n\t\t\t<?php\n\t\t\techo wfView::create('options\/block-controls', array(\n\t\t\t\t'backLink' => $backPage->url(),\n\t\t\t\t'backLabelHTML' => wp_kses(sprintf(__('<span class=\"wf-hidden-xs\">Back to <\/span>%s', 'wordfence'), $backPage->label()), array('span'=>array('class'=>array()))),\n\t\t\t\t'restoreDefaultsSection' => wfConfig::OPTIONS_TYPE_SCANNER,\n\t\t\t\t'restoreDefaultsMessage' => __('Are you sure you want to restore the default Scan settings? This will undo any custom changes you have made to the options on this page.', 'wordfence'),\n\t\t\t))->render();\n\t\t\t?>\n\t\t<\/div>\n\t<\/div>\n<\/div>\n<div class=\"wf-options-controls-spacer\"><\/div>\n<?php\nif (!wfOnboardingController::shouldShowAttempt3() && wfConfig::get('touppPromptNeeded')) {\n\techo wfView::create('gdpr\/disabled-overlay')->render();\n\techo wfView::create('gdpr\/banner')->render();\n}\n?>\n<div class=\"wrap wordfence\">\n\t<div class=\"wf-container-fluid\">\n\t\t<div class=\"wf-row\">\n\t\t\t<div class=\"wf-col-xs-12\">\n\t\t\t\t<div class=\"wp-header-end\"><\/div>\n\t\t\t<\/div>\n\t\t<\/div>\n\t\t<div class=\"wf-row\">\n\t\t\t<div class=\"<?php echo wfStyle::contentClasses(); ?>\">\n\t\t\t\t<div id=\"wf-scan-options\" class=\"wf-fixed-tab-content\">\n\t\t\t\t\t<?php\n\t\t\t\t\techo wfView::create('common\/section-title', array(\n\t\t\t\t\t\t'title' => __('Scan Options and Scheduling', 'wordfence'),\n\t\t\t\t\t\t'helpLink' => wfSupportController::supportURL(wfSupportController::ITEM_SCAN),\n\t\t\t\t\t\t'helpLabelHTML' => wp_kses(__('Learn more<span class=\"wf-hidden-xs\"> about Scanning<\/span>', 'wordfence'), array('span'=>array('classes'=>array()))),\n\t\t\t\t\t\t'showIcon' => true,\n\t\t\t\t\t))->render();\n\t\t\t\t\t?>\n\t\t\t\t\t<div class=\"wf-row\">\n\t\t\t\t\t\t<div class=\"wf-col-xs-12\">\n\t\t\t\t\t\t\t<div class=\"wf-block wf-active\">\n\t\t\t\t\t\t\t\t<div class=\"wf-block-content\">\n\t\t\t\t\t\t\t\t\t<ul class=\"wf-block-list wf-block-list-horizontal wf-block-list-nowrap wf-scanner-coverage\">\n\t\t\t\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\t\t\tif (function_exists('network_admin_url') && is_multisite()) { $optionsURL = network_admin_url('admin.php?page=WordfenceScan&subpage=scan_options'); }\n\t\t\t\t\t\t\t\t\t\t\telse { $optionsURL = admin_url('admin.php?page=WordfenceScan&subpage=scan_options'); }\n\t\t\t\t\t\t\t\t\t\t\techo wfView::create('common\/status-detail', array(\n\t\t\t\t\t\t\t\t\t\t\t\t'id' => 'wf-scanner-type',\n\t\t\t\t\t\t\t\t\t\t\t\t'percentage' => $scanner->scanTypeStatus(),\n\t\t\t\t\t\t\t\t\t\t\t\t'activeColor' => (!$scanner->isEnabled() ? '#ececec' : null \/* automatic *\/),\n\t\t\t\t\t\t\t\t\t\t\t\t'title' => __('Scan Type: ', 'wordfence') . wfScanner::displayScanType($scanner->scanType()),\n\t\t\t\t\t\t\t\t\t\t\t\t'subtitle' => wfScanner::displayScanTypeDetail($scanner->scanType()),\n\t\t\t\t\t\t\t\t\t\t\t\t'link' => $optionsURL,\n\t\t\t\t\t\t\t\t\t\t\t\t'linkLabel' => null,\n\t\t\t\t\t\t\t\t\t\t\t\t'statusTitle' => __('Scan Status', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t'statusList' => $scanner->scanTypeStatusList(),\n\t\t\t\t\t\t\t\t\t\t\t\t'helpLink' => wfSupportController::supportURL(wfSupportController::ITEM_SCAN_STATUS_OVERALL),\n\t\t\t\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\t\t\techo wfView::create('common\/status-detail', array(\n\t\t\t\t\t\t\t\t\t\t\t\t'id' => 'wf-scanner-malware-type',\n\t\t\t\t\t\t\t\t\t\t\t\t'percentage' => $scanner->signatureMode() == wfScanner::SIGNATURE_MODE_PREMIUM ? 1.0 : 0.7,\n\t\t\t\t\t\t\t\t\t\t\t\t'activeColor' => (!$scanner->isEnabled() ? '#ececec' : null \/* automatic *\/),\n\t\t\t\t\t\t\t\t\t\t\t\t'title' => __('Malware Signatures: ', 'wordfence') . ($scanner->signatureMode() == wfScanner::SIGNATURE_MODE_PREMIUM ? __('Premium', 'wordfence') : __('Community', 'wordfence')),\n\t\t\t\t\t\t\t\t\t\t\t\t'subtitle' => ($scanner->signatureMode() == wfScanner::SIGNATURE_MODE_PREMIUM ? __('Signatures updated in real-time', 'wordfence') : __('Signature updates delayed by 30 days', 'wordfence')),\n\t\t\t\t\t\t\t\t\t\t\t\t'link' => 'https:\/\/www.wordfence.com\/gnl1scanUpgrade\/wordfence-signup\/',\n\t\t\t\t\t\t\t\t\t\t\t\t'linkLabel' => null,\n\t\t\t\t\t\t\t\t\t\t\t\t'statusTitle' => __('Malware Signatures Status', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t'statusList' => $scanner->signatureMode() == wfScanner::SIGNATURE_MODE_PREMIUM ? array() : array(array(\n\t\t\t\t\t\t\t\t\t\t\t\t\t'percentage' => 0.30,\n\t\t\t\t\t\t\t\t\t\t\t\t\t'title'      => __('Enable Premium Scan Signatures.', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t)),\n\t\t\t\t\t\t\t\t\t\t\t\t'helpLink' => wfSupportController::supportURL(wfSupportController::ITEM_SCAN_STATUS_MALWARE),\n\t\t\t\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\t\t\t\techo wfView::create('common\/status-detail', array(\n\t\t\t\t\t\t\t\t\t\t\t\t'id' => 'wf-scanner-reputation',\n\t\t\t\t\t\t\t\t\t\t\t\t'percentage' => $scanner->reputationStatus(),\n\t\t\t\t\t\t\t\t\t\t\t\t'activeColor' => (!$scanner->isEnabled() ? '#ececec' : null \/* automatic *\/),\n\t\t\t\t\t\t\t\t\t\t\t\t'title' => __('Reputation Checks', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t'subtitle' => __('Check spam &amp; spamvertising blocklists', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t'link' => $optionsURL . '#wf-scanner-options-general',\n\t\t\t\t\t\t\t\t\t\t\t\t'linkLabel' => null,\n\t\t\t\t\t\t\t\t\t\t\t\t'statusTitle' => __('Reputation Check Status', 'wordfence'),\n\t\t\t\t\t\t\t\t\t\t\t\t'statusList' => $scanner->reputationStatusList(),\n\t\t\t\t\t\t\t\t\t\t\t\t'helpLink' => wfSupportController::supportURL(wfSupportController::ITEM_SCAN_STATUS_REPUTATION),\n\t\t\t\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t\t\t<\/ul>\n\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t\t<\/div>\n\t\t\t\t\t<?php\n\t\t\t\t\techo wfView::create('scanner\/options-group-scan-schedule', array(\n\t\t\t\t\t\t'scanner' => $scanner,\n\t\t\t\t\t\t'stateKey' => 'wf-scanner-options-schedule',\n\t\t\t\t\t))->render();\n\t\t\t\t\t\n\t\t\t\t\techo wfView::create('scanner\/options-group-basic', array(\n\t\t\t\t\t\t'scanner' => $scanner,\n\t\t\t\t\t\t'stateKey' => 'wf-scanner-options-basic',\n\t\t\t\t\t\t'collapseable' => false,\n\t\t\t\t\t))->render();\n\t\t\t\t\t\n\t\t\t\t\techo wfView::create('scanner\/options-group-general', array(\n\t\t\t\t\t\t'scanner' => $scanner,\n\t\t\t\t\t\t'stateKey' => 'wf-scanner-options-general',\n\t\t\t\t\t))->render();\n\t\t\t\t\t\n\t\t\t\t\techo wfView::create('scanner\/options-group-performance', array(\n\t\t\t\t\t\t'scanner' => $scanner,\n\t\t\t\t\t\t'stateKey' => 'wf-scanner-options-performance',\n\t\t\t\t\t))->render();\n\t\t\t\t\t\n\t\t\t\t\techo wfView::create('scanner\/options-group-advanced', array(\n\t\t\t\t\t\t'scanner' => $scanner,\n\t\t\t\t\t\t'stateKey' => 'wf-scanner-options-custom',\n\t\t\t\t\t))->render();\n\t\t\t\t\t?>\n\t\t\t\t<\/div> <!-- end wf-scan-options block -->\n\t\t\t<\/div> <!-- end content block -->\n\t\t<\/div> <!-- end row -->\n\t<\/div> <!-- end container -->\n<\/div>\n<script type=\"application\/javascript\">\n\t(function($) {\n\t\t$(function() {\n\t\t\tvar updatePendingCircles = function() {\n\t\t\t\t$('#circle-wf-scanner-type, #circle-wf-scanner-reputation').wfCircularProgress({pendingOverlay: Object.keys(WFAD.pendingChanges).length > 0});\n\t\t\t};\n\t\t\tvar coalescingUpdateTimer = false;\n\n\t\t\t$('.wf-option').on('change', function() {\n\t\t\t\tclearTimeout(coalescingUpdateTimer);\n\t\t\t\tcoalescingUpdateTimer = setTimeout(updatePendingCircles, 100);\n\t\t\t});\n\t\t});\n\t})(jQuery);\n<\/script>"},{"base":"plugins","rel":"wordfence\/lib\/wfViewResult.php","ext":"php","size":1455,"mtime":1757312769,"type":"text","content":"<?php if (!defined('WORDFENCE_VERSION')) { exit; } ?>\n<?php if(! wfUtils::isAdmin()){ exit(); } ?><!DOCTYPE html PUBLIC \"-\/\/W3C\/\/DTD XHTML 1.0 Transitional\/\/EN\" \"http:\/\/www.w3.org\/TR\/xhtml1\/DTD\/xhtml1-transitional.dtd\">\n<html xmlns=\"http:\/\/www.w3.org\/1999\/xhtml\"  dir=\"ltr\" lang=\"en-US\">\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text\/html; charset=UTF-8\" \/>\n<link rel='stylesheet' id='wordfence-main-style-css'  href='<?php echo wfUtils::getBaseURL() . wfUtils::versionedAsset('css\/diff.css'); ?>?ver=<?php echo WORDFENCE_VERSION; ?>' type='text\/css' media='all' \/>\n<body>\n<h1><?php esc_html_e('Wordfence: File Viewer', 'wordfence') ?><\/h1>\n<table border=\"0\" style=\"margin: 0 0 20px 0;\" class=\"summary\">\n<tr><td><?php esc_html_e('Filename:', 'wordfence') ?><\/td><td><?php echo wp_kses($localFile, array()); ?><\/td><\/tr>\n<tr><td><?php esc_html_e('File Size:', 'wordfence') ?><\/td><td><?php echo $fileSize; ?><\/td><\/tr>\n<tr><td><?php esc_html_e('File last modified:', 'wordfence') ?><\/td><td><?php echo $fileMTime; ?><\/td><\/tr>\n<\/table>\n\n<?php \n\tif($isEmpty){\n\t\techo \"File is empty.\";\n\t} else {\n\t\thighlight_string($cont);\n\t}\n?>\n\n\n\n<div class=\"diffFooter\"><?php echo wp_kses(sprintf(__('&copy;&nbsp;%d to %d Wordfence &mdash; Visit <a href=\"https:\/\/www.wordfence.com\/\">Wordfence.com<\/a> for help, security updates and more.', 'wordfence'), date_i18n('Y', WORDFENCE_EPOCH), date_i18n('Y')), array('a'=>array('href'=>array()))); ?><\/div>\n<\/body>\n<\/html>"},{"base":"plugins","rel":"wordfence\/lib\/wfAlerts.php","ext":"php","size":7549,"mtime":1757312769,"type":"text","content":"<?php\n\nabstract class wfBaseAlert {\n\n\tpublic abstract function send();\n}\n\nclass wfBlockAlert extends wfBaseAlert {\n\n\tprivate $IP;\n\tprivate $reason;\n\tprivate $secsToGo;\n\n\n\t\/**\n\t * wfBlockAlert constructor.\n\t * @param $IP\n\t * @param $reason\n\t * @param $secsToGo\n\t *\/\n\tpublic function __construct($IP, $reason, $secsToGo) {\n\t\t$this->IP = $IP;\n\t\t$this->reason = $reason;\n\t\t$this->secsToGo = $secsToGo;\n\t}\n\n\tpublic function send() {\n\t\tif (wfConfig::get('alertOn_block')) {\n\t\t\t$message = sprintf(\/* translators: IP address. *\/ __('Wordfence has blocked IP address %s.', 'wordfence'), $this->IP) . \"\\n\";\n\t\t\t$message .= sprintf(\/* translators: Description of firewall action. *\/ __('The reason is: \"%s\".', 'wordfence'), $this->reason);\n\t\t\tif ($this->secsToGo > 0) {\n\t\t\t\t$message .= \"\\n\" . sprintf(\/* translators: Time until. *\/ __('The duration of the block is %s.', 'wordfence'), wfUtils::makeDuration($this->secsToGo, true));\n\t\t\t}\n\t\t\twordfence::alert(sprintf(\/* translators: IP address. *\/__('Blocking IP %s', 'wordfence'), $this->IP), $message, $this->IP);\n\t\t}\n\t}\n\n}\n\nclass wfAutoUpdatedAlert extends wfBaseAlert {\n\n\tprivate $version;\n\n\t\/**\n\t * @param $version\n\t *\/\n\tpublic function __construct($version) {\n\t\t$this->version = $version;\n\t}\n\n\tpublic function send() {\n\t\tif (wfConfig::get('alertOn_update') == '1' && $this->version) {\n\t\t\twordfence::alert(sprintf(\/* translators: Software version. *\/ __(\"Wordfence Upgraded to version %s\", 'wordfence'), $this->version), sprintf(\/* translators: Software version. *\/ __(\"Your Wordfence installation has been upgraded to version %s\", 'wordfence'), $this->version), false);\n\t\t}\n\t}\n\n}\n\nclass wfWafDeactivatedAlert extends wfBaseAlert {\n\n\tprivate $username;\n\tprivate $IP;\n\n\t\/**\n\t * @param $username\n\t * @param $IP\n\t *\/\n\tpublic function __construct($username, $IP) {\n\t\t$this->username = $username;\n\t\t$this->IP = $IP;\n\t}\n\n\tpublic function send() {\n\t\tif (wfConfig::get('alertOn_wafDeactivated')) {\n\t\t\twordfence::alert(__('Wordfence WAF Deactivated', 'wordfence'), sprintf(\/* translators: WP username. *\/__('A user with username \"%s\" deactivated the Wordfence Web Application Firewall on your WordPress site.', 'wordfence'), $this->username), $this->IP);\n\t\t}\n\t}\n\n}\n\nclass wfWordfenceDeactivatedAlert extends wfBaseAlert {\n\tprivate $username;\n\tprivate $IP;\n\n\t\/**\n\t * @param $username\n\t * @param $IP\n\t *\/\n\tpublic function __construct($username, $IP) {\n\t\t$this->username = $username;\n\t\t$this->IP = $IP;\n\t}\n\n\tpublic function send() {\n\t\tif (wfConfig::get('alertOn_wordfenceDeactivated')) {\n\t\t\twordfence::alert(__(\"Wordfence Deactivated\", 'wordfence'), sprintf(\/* translators: WP username. *\/ __(\"A user with username \\\"%s\\\" deactivated Wordfence on your WordPress site.\", 'wordfence'), $this->username), $this->IP);\n\t\t}\n\t}\n\n}\n\nclass wfLostPasswdFormAlert extends wfBaseAlert {\n\n\tprivate $user;\n\tprivate $IP;\n\n\t\/**\n\t * @param $user\n\t * @param $IP\n\t *\/\n\tpublic function __construct($user, $IP) {\n\t\t$this->user = $user;\n\t\t$this->IP = $IP;\n\t}\n\n\tpublic function send() {\n\t\tif (wfConfig::get('alertOn_lostPasswdForm')) {\n\t\t\twordfence::alert(__(\"Password recovery attempted\", 'wordfence'), sprintf(\/* translators: Email address. *\/__(\"Someone tried to recover the password for user with email address: %s\", 'wordfence'), wp_kses($this->user->user_email, array())), $this->IP);\n\t\t}\n\t}\n\n}\n\nclass wfLoginLockoutAlert extends wfBaseAlert {\n\n\tprivate $IP;\n\tprivate $reason;\n\n\t\/**\n\t * @param $IP\n\t * @param $reason\n\t *\/\n\tpublic function __construct($IP, $reason) {\n\t\t$this->IP = $IP;\n\t\t$this->reason = $reason;\n\t}\n\n\tpublic function send() {\n\t\tif (wfConfig::get('alertOn_loginLockout')) {\n\t\t\t$message = sprintf(\n\t\t\t\t\/* translators: 1. IP address. 2. Description of firewall action. *\/\n\t\t\t\t__('A user with IP address %1$s has been locked out from signing in or using the password recovery form for the following reason: %2$s.', 'wordfence'), $this->IP, $this->reason);\n\t\t\tif (wfBlock::lockoutDuration() > 0) {\n\t\t\t\t$message .= \"\\n\" . sprintf(\/* translators: Time until. *\/ __('The duration of the lockout is %s.', 'wordfence'), wfUtils::makeDuration(wfBlock::lockoutDuration(), true));\n\t\t\t}\n\t\t\twordfence::alert(__('User locked out from signing in', 'wordfence'), $message, $this->IP);\n\t\t}\n\t}\n}\n\nclass wfAdminLoginAlert extends wfBaseAlert {\n\n\tprivate $cookieName;\n\tprivate $username;\n\tprivate $IP;\n\tprivate $cookieValue;\n\n\t\/**\n\t * @param $cookieName\n\t * @param $cookieValue\n\t * @param $username\n\t * @param $IP\n\t *\/\n\tpublic function __construct($cookieName, $cookieValue, $username, $IP) {\n\t\t$this->cookieName = $cookieName;\n\t\t$this->cookieValue = $cookieValue;\n\t\t$this->username = $username;\n\t\t$this->IP = $IP;\n\t}\n\n\tpublic function send() {\n\t\tif (wfConfig::get('alertOn_adminLogin')) {\n\t\t\t$shouldAlert = true;\n\t\t\tif (wfConfig::get('alertOn_firstAdminLoginOnly') && isset($_COOKIE[$this->cookieName])) {\n\t\t\t\t$shouldAlert = !hash_equals($this->cookieValue, $_COOKIE[$this->cookieName]);\n\t\t\t}\n\n\t\t\tif ($shouldAlert) {\n\t\t\t\twordfence::alert(__(\"Admin Login\", 'wordfence'), sprintf(\/* translators: WP username. *\/ __(\"A user with username \\\"%s\\\" who has administrator access signed in to your WordPress site.\", 'wordfence'), $this->username), $this->IP);\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass wfNonAdminLoginAlert extends wfBaseAlert {\n\n\tprivate $cookieName;\n\tprivate $username;\n\tprivate $IP;\n\tprivate $cookieValue;\n\n\t\/**\n\t * @param $cookieName\n\t * @param $cookieValue\n\t * @param $username\n\t * @param $IP\n\t *\/\n\tpublic function __construct($cookieName, $cookieValue, $username, $IP) {\n\t\t$this->cookieName = $cookieName;\n\t\t$this->cookieValue = $cookieValue;\n\t\t$this->username = $username;\n\t\t$this->IP = $IP;\n\t}\n\n\tpublic function send() {\n\t\tif (wfConfig::get('alertOn_nonAdminLogin')) {\n\t\t\t$shouldAlert = true;\n\t\t\tif (wfConfig::get('alertOn_firstNonAdminLoginOnly') && isset($_COOKIE[$this->cookieName])) {\n\t\t\t\t$shouldAlert = !hash_equals($this->cookieValue, $_COOKIE[$this->cookieName]);\n\t\t\t}\n\n\t\t\tif ($shouldAlert) {\n\t\t\t\twordfence::alert(__(\"User login\", 'wordfence'), sprintf(\/* translators: WP username. *\/ __(\"A non-admin user with username \\\"%s\\\" signed in to your WordPress site.\", 'wordfence'), $this->username), $this->IP);\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass wfBreachLoginAlert extends wfBaseAlert {\n\n\tprivate $username;\n\tprivate $lostPasswordUrl;\n\tprivate $supportUrl;\n\tprivate $IP;\n\n\t\/**\n\t * @param $username\n\t * @param $lostPasswordUrl\n\t * @param $supportUrl\n\t * @param $IP\n\t *\/\n\tpublic function __construct($username, $lostPasswordUrl, $supportUrl, $IP) {\n\t\t$this->username = $username;\n\t\t$this->lostPasswordUrl = $lostPasswordUrl;\n\t\t$this->supportUrl = $supportUrl;\n\t\t$this->IP = $IP;\n\t}\n\n\tpublic function send() {\n\t\tif (wfConfig::get('alertOn_breachLogin')) {\n\t\t\twordfence::alert(__('User login blocked for insecure password', 'wordfence'), sprintf(\n\t\t\t\t\/* translators: 1. WP username. 2. Reset password URL. 3. Support URL. *\/\n\t\t\t\t__('A user with username \"%1$s\" tried to sign in to your WordPress site. Access was denied because the password being used exists on lists of passwords leaked in data breaches. Attackers use such lists to break into sites and install malicious code. Please change or reset the password (%2$s) to reactivate this account. Learn More: %3$s', 'wordfence'), $this->username, $this->lostPasswordUrl, $this->supportUrl), $this->IP);\n\t\t}\n\t}\n}\n\nclass wfIncreasedAttackRateAlert extends wfBaseAlert {\n\n\tprivate $message;\n\n\t\/**\n\t * @param $message\n\t *\/\n\tpublic function __construct($message) {\n\t\t$this->message = $message;\n\t}\n\n\tpublic function send() {\n\t\twordfence::alert(__('Increased Attack Rate', 'wordfence'), $this->message, false);\n\t}\n}\n"},{"base":"plugins","rel":"wordfence\/lib\/menu_options.php","ext":"php","size":25291,"mtime":1757312769,"type":"text","content":"<?php\nif (!defined('WORDFENCE_VERSION')) { exit; }\n$waf = wfWAF::getInstance();\n$d = new wfDashboard(); unset($d->countriesNetwork);\n$firewall = new wfFirewall();\n$scanner = wfScanner::shared();\n$config = $waf->getStorageEngine();\n$wafURL = wfPage::pageURL(wfPage::PAGE_FIREWALL);\n$wafConfigURL = network_admin_url('admin.php?page=WordfenceWAF&subpage=waf_options#configureAutoPrepend');\n$wafRemoveURL = network_admin_url('admin.php?page=WordfenceWAF&subpage=waf_options#removeAutoPrepend');\n\/** @var array $wafData *\/\n\n$backPage = new wfPage(wfPage::PAGE_FIREWALL);\nif (isset($_GET['source']) && wfPage::isValidPage($_GET['source'])) {\n\t$backPage = new wfPage($_GET['source']);\n}\n?>\n<script type=\"application\/javascript\">\n\t(function($) {\n\t\tWFAD.wafData = <?php echo json_encode($wafData); ?>;\n\t\tWFAD.restoreWAFData = JSON.parse(JSON.stringify(WFAD.wafData)); \/\/Copied into wafData when canceling changes\n\n\t\t$(function() {\n\t\t\tdocument.title = \"<?php esc_attr_e('All Options', 'wordfence'); ?>\" + \" \\u2039 \" + WFAD.basePageName;\n\t\t\t\n\t\t\tWFAD.wafConfigPageRender();\n\n\t\t\t\/\/Hash-based option block linking\n\t\t\tif (window.location.hash) {\n\t\t\t\tvar hashes = WFAD.parseHashes();\n\t\t\t\tvar hash = hashes[hashes.length - 1];\n\t\t\t\tvar block = $('.wf-block[data-persistence-key=\"' + hash + '\"]');\n\t\t\t\tif (block.length) {\n\t\t\t\t\tif (!block.hasClass('wf-active')) {\n\t\t\t\t\t\tblock.find('.wf-block-content').slideDown({\n\t\t\t\t\t\t\talways: function() {\n\t\t\t\t\t\t\t\tblock.addClass('wf-active');\n\t\t\t\t\t\t\t\t$('html, body').animate({\n\t\t\t\t\t\t\t\t\tscrollTop: block.offset().top - 100\n\t\t\t\t\t\t\t\t}, 1000);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tWFAD.ajax('wordfence_saveDisclosureState', {name: block.data('persistenceKey'), state: true}, function() {}, function() {}, true);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t$('html, body').animate({\n\t\t\t\t\t\t\tscrollTop: block.offset().top - 100\n\t\t\t\t\t\t}, 1000);\n\t\t\t\t\t}\n\n\t\t\t\t\thistory.replaceState('', document.title, window.location.pathname + window.location.search);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t$(window).on('wfOptionsReset', function() {\n\t\t\tWFAD.wafData = JSON.parse(JSON.stringify(WFAD.restoreWAFData));\n\t\t\tWFAD.wafConfigPageRender();\n\t\t});\n\t})(jQuery);\n<\/script>\n<div class=\"wf-options-controls\">\n\t<div class=\"wf-row\">\n\t\t<div class=\"wf-col-xs-12\">\n\t\t\t<?php\n\t\t\t$indexOptions = array(\n\t\t\t\t'wf-option-apiKey' => __('License Key', 'wordfence'),\n\t\t\t\t'wf-option-displayTopLevelOptions' => __('Display All Options menu item', 'wordfence'),\n\t\t\t\t'wf-option-displayTopLevelBlocking' => __('Display Blocking menu item', 'wordfence'),\n\t\t\t\t'wf-option-displayTopLevelLiveTraffic' => __('Display Live Traffic menu item', 'wordfence'),\n\t\t\t\t'wf-option-displayTopLevelAuditLog' => __('Display Audit Log menu item', 'wordfence'),\n\t\t\t\t'wf-option-autoUpdate' => __('Update Wordfence automatically when a new version is released?', 'wordfence'),\n\t\t\t\t'wf-option-alertEmails' => __('Where to email alerts', 'wordfence'),\n\t\t\t\t'wf-option-howGetIPs' => __('How does Wordfence get IPs', 'wordfence'),\n\t\t\t\t'wf-option-howGetIPs-trusted-proxies' => __('Trusted Proxies', 'wordfence'),\n\t\t\t\t'wf-option-enableRemoteIpLookup' => __('Look up visitor IP locations via Wordfence servers', 'wordfence'),\n\t\t\t\t'wf-option-other-hideWPVersion' => __('Hide WordPress version', 'wordfence'),\n\t\t\t\t'wf-option-disableCodeExecutionUploads' => __('Disable Code Execution for Uploads directory', 'wordfence'),\n\t\t\t\t'wf-option-liveActivityPauseEnabled' => __('Pause live updates when window loses focus', 'wordfence'),\n\t\t\t\t'wf-option-actUpdateInterval' => __('Update interval in seconds', 'wordfence'),\n\t\t\t\t'wf-option-other-bypassLitespeedNoabort' => __('Bypass the LiteSpeed \"noabort\" check', 'wordfence'),\n\t\t\t\t'wf-option-deleteTablesOnDeact' => __('Delete Wordfence tables and data on deactivation', 'wordfence'),\n\t\t\t\t'wf-option-notification-updatesNeeded' => __('Updates Needed (Plugin, Theme, or Core)', 'wordfence'),\n\t\t\t\t'wf-option-notification-securityAlerts' => __('Security Alerts', 'wordfence'),\n\t\t\t\t'wf-option-notification-promotions' => __('Promotions', 'wordfence'),\n\t\t\t\t'wf-option-notification-blogHighlights' => __('Blog Highlights', 'wordfence'),\n\t\t\t\t'wf-option-notification-productUpdates' => __('Product Updates', 'wordfence'),\n\t\t\t\t'wf-option-notification-scanStatus' => __('Scan Status', 'wordfence'),\n\t\t\t\t'wf-option-alertOn-update' => __('Email me when Wordfence is automatically updated', 'wordfence'),\n\t\t\t\t'wf-option-alertOn-wordfenceDeactivated' => __('Email me if Wordfence is deactivated', 'wordfence'),\n\t\t\t\t'wf-option-alertOn-wafDeactivated' => __('Email me if the Wordfence Web Application Firewall is turned off', 'wordfence'),\n\t\t\t\t'wf-option-alertOn-scanIssues' => __('Alert me with scan results of this severity level or greater', 'wordfence'),\n\t\t\t\t'wf-option-alertOn-block' => __('Alert when an IP address is blocked', 'wordfence'),\n\t\t\t\t'wf-option-alertOn-loginLockout' => __('Alert when someone is locked out from login', 'wordfence'),\n\t\t\t\t'wf-option-alertOn-lostPasswdForm' => __('Alert when the \"lost password\" form is used for a valid user', 'wordfence'),\n\t\t\t\t'wf-option-alertOn-adminLogin' => __('Alert me when someone with administrator access signs in', 'wordfence'),\n\t\t\t\t'wf-option-alertOn-firstAdminLoginOnly' => __('Only alert me when that administrator signs in from a new device', 'wordfence'),\n\t\t\t\t'wf-option-alertOn-nonAdminLogin' => __('Alert me when a non-admin user signs in', 'wordfence'),\n\t\t\t\t'wf-option-alertOn-firstNonAdminLoginOnly' => __('Only alert me when that user signs in from a new device', 'wordfence'),\n\t\t\t\t'wf-option-wafAlertOnAttacks' => __('Alert me when there\\'s a large increase in attacks detected on my site', 'wordfence'),\n\t\t\t\t'wf-option-alert-maxHourly' => __('Maximum email alerts to send per hour', 'wordfence'),\n\t\t\t\t'wf-option-email-summary-enabled' => __('Enable email summary', 'wordfence'),\n\t\t\t\t'wf-option-email-summary-excluded-directories' => __('List of directories to exclude from recently modified file list', 'wordfence'),\n\t\t\t\t'wf-option-email-summary-dashboard-widget-enabled' => __('Enable activity report widget on the WordPress dashboard', 'wordfence'),\n\t\t\t\t'wf-option-wafStatus' => __('Web Application Firewall Status', 'wordfence'),\n\t\t\t\t'wf-option-protectionMode' => __('Web Application Firewall Protection Level', 'wordfence'),\n\t\t\t\t'wf-option-disableWAFBlacklistBlocking' => __('Real-Time IP Blocklist', 'wordfence'),\n\t\t\t\t'wf-option-disableWAFIPBlocking' => __('Delay IP and Country blocking until after WordPress and plugins have loaded (only process firewall rules early)', 'wordfence'),\n\t\t\t\t'wf-option-whitelisted' => __('Allowlisted IP addresses that bypass all rules', 'wordfence'),\n\t\t\t\t'wf-option-whitelistedServices' => __('Allowlisted services', 'wordfence'),\n\t\t\t\t'wf-option-bannedURLs' => __('Immediately block IPs that access these URLs', 'wordfence'),\n\t\t\t\t'wf-option-wafAlertWhitelist' => __('Ignored IP addresses for Wordfence Web Application Firewall alerting', 'wordfence'),\n\t\t\t\t'wf-option-wafRules' => __('Web Application Firewall Rules', 'wordfence'),\n\t\t\t\t'wf-option-loginSecurityEnabled' => __('Enable brute force protection', 'wordfence'),\n\t\t\t\t'wf-option-loginSec-maxFailures' => __('Lock out after how many login failures', 'wordfence'),\n\t\t\t\t'wf-option-loginSec-maxForgotPasswd' => __('Lock out after how many forgot password attempts', 'wordfence'),\n\t\t\t\t'wf-option-loginSec-countFailMins' => __('Count failures over what time period', 'wordfence'),\n\t\t\t\t'wf-option-loginSec-lockoutMins' => __('Amount of time a user is locked out', 'wordfence'),\n\t\t\t\t'wf-option-loginSec-lockInvalidUsers' => __('Immediately lock out invalid usernames', 'wordfence'),\n\t\t\t\t'wf-option-loginSec-userBlacklist' => __('Immediately block the IP of users who try to sign in as these usernames', 'wordfence'),\n\t\t\t\t'wf-option-loginSec-strongPasswds-enabled' => __('Enforce strong passwords', 'wordfence'),\n\t\t\t\t'wf-option-loginSec-breachPasswds-enabled' => __('Prevent the use of passwords leaked in data breaches', 'wordfence'),\n\t\t\t\t'wf-option-loginSec-maskLoginErrors' => __('Don\\'t let WordPress reveal valid users in login errors', 'wordfence'),\n\t\t\t\t'wf-option-loginSec-blockAdminReg' => __('Prevent users registering \"admin\" username if it doesn\\'t exist', 'wordfence'),\n\t\t\t\t'wf-option-loginSec-disableAuthorScan' => __('Prevent discovery of usernames through \"\/?author=N\" scans, the oEmbed API, the WordPress REST API, and WordPress XML Sitemaps', 'wordfence'),\n\t\t\t\t'wf-option-loginSec-disableApplicationPasswords' => __('Disable WordPress application passwords', 'wordfence'),\n\t\t\t\t'wf-option-other-blockBadPOST' => __('Block IPs who send POST requests with blank User-Agent and Referer', 'wordfence'),\n\t\t\t\t'wf-option-blockCustomText' => __('Custom text shown on block pages', 'wordfence'),\n\t\t\t\t'wf-option-other-pwStrengthOnUpdate' => __('Check password strength on profile update', 'wordfence'),\n\t\t\t\t'wf-option-other-WFNet' => __('Participate in the Real-Time Wordfence Security Network', 'wordfence'),\n\t\t\t\t'wf-option-firewallEnabled' => __('Enable Rate Limiting and Advanced Blocking', 'wordfence'),\n\t\t\t\t'wf-option-neverBlockBG' => __('How should we treat Google\\'s crawlers', 'wordfence'),\n\t\t\t\t'wf-option-maxGlobalRequests' => __('If anyone\\'s requests exceed', 'wordfence'),\n\t\t\t\t'wf-option-maxRequestsCrawlers' => __('If a crawler\\'s page views exceed', 'wordfence'),\n\t\t\t\t'wf-option-max404Crawlers' => __('If a crawler\\'s pages not found (404s) exceed', 'wordfence'),\n\t\t\t\t'wf-option-maxRequestsHumans' => __('If a human\\'s page views exceed', 'wordfence'),\n\t\t\t\t'wf-option-max404Humans' => __('If a human\\'s pages not found (404s) exceed', 'wordfence'),\n\t\t\t\t'wf-option-blockedTime' => __('How long is an IP address blocked when it breaks a rule', 'wordfence'),\n\t\t\t\t'wf-option-allowed404s' => __('Allowlisted 404 URLs', 'wordfence'),\n\t\t\t\t'wf-option-wafWhitelist' => __('Web Application Firewall Allowlisted URLs', 'wordfence'),\n\t\t\t\t'wf-option-ajaxWatcherDisabled-front' => __('Monitor background requests from an administrator\\'s web browser for false positives (Front-end Website)', 'wordfence'),\n\t\t\t\t'wf-option-ajaxWatcherDisabled-admin' => __('Monitor background requests from an administrator\\'s web browser for false positives (Admin Panel)', 'wordfence'),\n\t\t\t\t'wf-option-cbl-action' => __('What to do when we block someone visiting from a blocked country', 'wordfence'),\n\t\t\t\t'wf-option-cbl-redirURL' => __('URL to redirect blocked countries to', 'wordfence'),\n\t\t\t\t'wf-option-cbl-loggedInBlocked' => __('Block countries even if they are logged in', 'wordfence'),\n\t\t\t\t'wf-option-cbl-bypassRedirURL' => __('If user from a blocked country hits the relative URL ____ then redirect that user to ____ and set a cookie that will bypass all country blocking', 'wordfence'),\n\t\t\t\t'wf-option-cbl-bypassViewURL' => __('If user who is allowed to access the site views the relative URL ____ then set a cookie that will bypass country blocking in future in case that user hits the site from a blocked country', 'wordfence'),\n\t\t\t\t'wf-option-scheduledScansEnabled' => __('Schedule Wordfence Scans', 'wordfence'),\n\t\t\t\t'wf-option-scanType' => __('Scan Type', 'wordfence'),\n\t\t\t\t'wf-option-scansEnabled-checkGSB' => __('Check if this website is on a domain blocklist', 'wordfence'),\n\t\t\t\t'wf-option-spamvertizeCheck' => __('Check if this website is being &quot;Spamvertised&quot;', 'wordfence'),\n\t\t\t\t'wf-option-checkSpamIP' => __('Check if this website IP is generating spam', 'wordfence'),\n\t\t\t\t'wf-option-scansEnabled-checkHowGetIPs' => __('Scan for misconfigured How does Wordfence get IPs', 'wordfence'),\n\t\t\t\t'wf-option-scansEnabled-checkReadableConfig' => __('Scan for publicly accessible configuration, backup, or log files', 'wordfence'),\n\t\t\t\t'wf-option-scansEnabled-suspectedFiles' => __('Scan for publicly accessible quarantined files', 'wordfence'),\n\t\t\t\t'wf-option-scansEnabled-core' => __('Scan core files against repository versions for changes', 'wordfence'),\n\t\t\t\t'wf-option-scansEnabled-themes' => __('Scan theme files against repository versions for changes', 'wordfence'),\n\t\t\t\t'wf-option-scansEnabled-plugins' => __('Scan plugin files against repository versions for changes', 'wordfence'),\n\t\t\t\t'wf-option-scansEnabled-coreUnknown' => __('Scan wp-admin and wp-includes for files not bundled with WordPress', 'wordfence'),\n\t\t\t\t'wf-option-scansEnabled-malware' => __('Scan for signatures of known malicious files', 'wordfence'),\n\t\t\t\t'wf-option-scansEnabled-fileContents' => __('Scan file contents for backdoors, trojans and suspicious code', 'wordfence'),\n\t\t\t\t'wf-option-scansEnabled-fileContentsGSB' => __('Scan file contents for malicious URLs', 'wordfence'),\n\t\t\t\t'wf-option-scansEnabled-posts' => __('Scan posts for known dangerous URLs and suspicious content', 'wordfence'),\n\t\t\t\t'wf-option-scansEnabled-comments' => __('Scan comments for known dangerous URLs and suspicious content', 'wordfence'),\n\t\t\t\t'wf-option-scansEnabled-suspiciousOptions' => __('Scan WordPress core, plugin, and theme options for known dangerous URLs and suspicious content', 'wordfence'),\n\t\t\t\t'wf-option-scansEnabled-oldVersions' => __('Scan for out of date, abandoned, and vulnerable plugins, themes, and WordPress versions', 'wordfence'),\n\t\t\t\t'wf-option-scansEnabled-suspiciousAdminUsers' => __('Scan for suspicious admin users created outside of WordPress', 'wordfence'),\n\t\t\t\t'wf-option-scansEnabled-passwds' => __('Check the strength of passwords', 'wordfence'),\n\t\t\t\t'wf-option-scansEnabled-diskSpace' => __('Monitor disk space', 'wordfence'),\n\t\t\t\t'wf-option-scansEnabled-wafStatus' => __('Monitor Web Application Firewall status', 'wordfence'),\n\t\t\t\t'wf-option-other-scanOutside' => __('Scan files outside your WordPress installation', 'wordfence'),\n\t\t\t\t'wf-option-scansEnabled-scanImages' => __('Scan images, binary, and other files as if they were executable', 'wordfence'),\n\t\t\t\t'wf-option-lowResourceScansEnabled' => __('Use low resource scanning (reduces server load by lengthening the scan duration)', 'wordfence'),\n\t\t\t\t'wf-option-scan-maxIssues' => __('Limit the number of issues sent in the scan results email', 'wordfence'),\n\t\t\t\t'wf-option-scan-maxDuration' => __('Time limit that a scan can run in seconds', 'wordfence'),\n\t\t\t\t'wf-option-maxMem' => __('How much memory should Wordfence request when scanning', 'wordfence'),\n\t\t\t\t'wf-option-maxExecutionTime' => __('Maximum execution time for each scan stage', 'wordfence'),\n\t\t\t\t'wf-option-scan-exclude' => __('Exclude files from scan that match these wildcard patterns', 'wordfence'),\n\t\t\t\t'wf-option-scan-include-extra' => __('Additional scan signatures', 'wordfence'),\n\t\t\t\t'wf-option-scan-force-ipv4-start' => __('Use only IPv4 to start scans', 'wordfence'),\n\t\t\t\t'wf-option-scan-max-resume-attempts' => __('Maximum number of attempts to resume each scan stage', 'wordfence'),\n\t\t\t\t'wf-option-liveTrafficEnabled' => __('Traffic logging mode (Live Traffic)', 'wordfence'),\n\t\t\t\t'wf-option-liveTraf-ignorePublishers' => __('Don\\'t log signed-in users with publishing access', 'wordfence'),\n\t\t\t\t'wf-option-liveTraf-ignoreUsers' => __('List of comma separated usernames to ignore', 'wordfence'),\n\t\t\t\t'wf-option-liveTraf-ignoreIPs' => __('List of comma separated IP addresses to ignore', 'wordfence'),\n\t\t\t\t'wf-option-liveTraf-ignoreUA' => __('Browser user-agent to ignore', 'wordfence'),\n\t\t\t\t'wf-option-liveTraf-maxRows' => __('Amount of Live Traffic data to store (number of rows)', 'wordfence'),\n\t\t\t\t'wf-option-liveTraf-maxAge' => __('Maximum days to keep Live Traffic data', 'wordfence'),\n\t\t\t\t'wf-option-auditLogMode' => __('Audit Log logging mode', 'wordfence'),\n\t\t\t\t'wf-option-exportOptions' => __('Export this site\\'s Wordfence options for import on another site', 'wordfence'),\n\t\t\t\t'wf-option-importOptions' => __('Import Wordfence options from another site using a token', 'wordfence'),\n\t\t\t);\n\t\t\t\n\t\t\tif (wfCredentialsController::useLegacy2FA()) {\n\t\t\t\t$indexOptions['wf-option-loginSec-requireAdminTwoFactor'] = __('Require Cellphone Sign-in for all Administrators', 'wordfence');\n\t\t\t\t$indexOptions['wf-option-loginSec-enableSeparateTwoFactor'] = __('Enable Separate Prompt for Two Factor Code', 'wordfence');\n\t\t\t}\n\t\t\t\n\t\t\t$indexOptions = array_merge($indexOptions, wfModuleController::shared()->optionIndexes);\n\t\t\t\n\t\t\techo wfView::create('options\/block-all-options-controls', array(\n\t\t\t\t'showIcon' => false,\n\t\t\t\t'indexOptions' => $indexOptions,\n\t\t\t\t'restoreDefaultsSection' => wfConfig::OPTIONS_TYPE_ALL,\n\t\t\t\t'restoreDefaultsMessage' => __('Are you sure you want to restore the default settings? This will undo any custom changes you have made to the options on this page. If you have manually disabled any rules or added any custom allowlisted URLs, those changes will not be overwritten.', 'wordfence'),\n\t\t\t))->render();\n\t\t\t?>\n\t\t<\/div>\n\t<\/div>\n<\/div>\n<div class=\"wf-options-controls-spacer\"><\/div>\n<?php\nif (!wfOnboardingController::shouldShowAttempt3() && wfConfig::get('touppPromptNeeded')) {\n\techo wfView::create('gdpr\/disabled-overlay')->render();\n\techo wfView::create('gdpr\/banner')->render();\n}\n?>\n<div class=\"wrap wordfence\">\n\t<div class=\"wf-container-fluid\">\n\t\t<?php\n\t\tif (function_exists('network_admin_url') && is_multisite()) {\n\t\t\t$firewallURL = network_admin_url('admin.php?page=WordfenceWAF#top#waf');\n\t\t\t$blockingURL = network_admin_url('admin.php?page=WordfenceWAF#top#blocking');\n\t\t}\n\t\telse {\n\t\t\t$firewallURL = admin_url('admin.php?page=WordfenceWAF#top#waf');\n\t\t\t$blockingURL = admin_url('admin.php?page=WordfenceWAF#top#blocking');\n\t\t}\n\t\t?>\n\t\t<div class=\"wf-row\">\n\t\t\t<div class=\"wf-col-xs-12\">\n\t\t\t\t<div class=\"wp-header-end\"><\/div>\n\t\t\t<\/div>\n\t\t<\/div>\n\t\t<div class=\"wf-row\">\n\t\t\t<div class=\"<?php echo wfStyle::contentClasses(); ?>\">\n\t\t\t\t<div id=\"wf-all-options\" class=\"wf-fixed-tab-content\">\n\t\t\t\t\t<?php\n\t\t\t\t\t$stateKeys = array(\n\t\t\t\t\t\t'wf-unified-global-options-license',\n\t\t\t\t\t\t'wf-unified-global-options-view-customization',\n\t\t\t\t\t\t'wf-unified-global-options-general',\n\t\t\t\t\t\t'wf-unified-global-options-dashboard',\n\t\t\t\t\t\t'wf-unified-global-options-alert',\n\t\t\t\t\t\t'wf-unified-global-options-email-summary',\n\t\t\t\t\t\t'wf-unified-waf-options-basic',\n\t\t\t\t\t\t'wf-unified-waf-options-advanced',\n\t\t\t\t\t\t'wf-unified-waf-options-bruteforce',\n\t\t\t\t\t\t'wf-unified-waf-options-ratelimiting',\n\t\t\t\t\t\t'wf-unified-waf-options-whitelisted',\n\t\t\t\t\t\t'wf-unified-blocking-options-country',\n\t\t\t\t\t\t'wf-unified-scanner-options-schedule',\n\t\t\t\t\t\t'wf-unified-scanner-options-basic',\n\t\t\t\t\t\t'wf-unified-scanner-options-general',\n\t\t\t\t\t\t'wf-unified-scanner-options-performance',\n\t\t\t\t\t\t'wf-unified-scanner-options-custom',\n\t\t\t\t\t\t'wf-unified-2fa-options',\n\t\t\t\t\t\t'wf-unified-live-traffic-options',\n\t\t\t\t\t\t'wf-unified-audit-log-options',\n\t\t\t\t\t);\n\t\t\t\t\t\n\t\t\t\t\techo wfView::create('options\/options-title', array(\n\t\t\t\t\t\t'title' => __('All Options', 'wordfence'),\n\t\t\t\t\t\t'stateKeys' => $stateKeys,\n\t\t\t\t\t\t'showIcon' => true,\n\t\t\t\t\t))->render();\n\t\t\t\t\t?>\n\t\t\t\t\t\n\t\t\t\t\t<p><?php esc_html_e('These options are also available throughout the plugin pages, in the relevant sections. This page is provided for easier setup for experienced Wordfence users.', 'wordfence'); ?><\/p>\n\t\t\t\t\t\n\t\t\t\t\t<?php\n\t\t\t\t\techo wfView::create('common\/section-subtitle', array(\n\t\t\t\t\t\t'title' => __('Wordfence Global Options', 'wordfence'),\n\t\t\t\t\t\t'showIcon' => false,\n\t\t\t\t\t))->render();\n\t\t\t\t\t\n\t\t\t\t\techo wfView::create('dashboard\/options-group-license', array(\n\t\t\t\t\t\t'stateKey' => 'wf-unified-global-options-license',\n\t\t\t\t\t))->render();\n\t\t\t\t\t\n\t\t\t\t\techo wfView::create('dashboard\/options-group-view-customization', array(\n\t\t\t\t\t\t'stateKey' => 'wf-unified-global-options-view-customization',\n\t\t\t\t\t))->render();\n\t\t\t\t\t\n\t\t\t\t\techo wfView::create('dashboard\/options-group-general', array(\n\t\t\t\t\t\t'stateKey' => 'wf-unified-global-options-general',\n\t\t\t\t\t))->render();\n\t\t\t\t\t\n\t\t\t\t\techo wfView::create('dashboard\/options-group-dashboard', array(\n\t\t\t\t\t\t'stateKey' => 'wf-unified-global-options-dashboard',\n\t\t\t\t\t))->render();\n\t\t\t\t\t\n\t\t\t\t\techo wfView::create('dashboard\/options-group-alert', array(\n\t\t\t\t\t\t'stateKey' => 'wf-unified-global-options-alert',\n\t\t\t\t\t))->render();\n\t\t\t\t\t\n\t\t\t\t\techo wfView::create('dashboard\/options-group-email-summary', array(\n\t\t\t\t\t\t'stateKey' => 'wf-unified-global-options-email-summary',\n\t\t\t\t\t))->render();\n\t\t\t\t\t?>\n\t\t\t\t\t\n\t\t\t\t\t<?php\n\t\t\t\t\techo wfView::create('common\/section-subtitle', array(\n\t\t\t\t\t\t'title' => __('Firewall Options', 'wordfence'),\n\t\t\t\t\t\t'showIcon' => false,\n\t\t\t\t\t))->render();\n\t\t\t\t\t\n\t\t\t\t\techo wfView::create('waf\/options-group-basic-firewall', array(\n\t\t\t\t\t\t'firewall' => $firewall,\n\t\t\t\t\t\t'waf' => $waf,\n\t\t\t\t\t\t'stateKey' => 'wf-unified-waf-options-basic',\n\t\t\t\t\t))->render();\n\t\t\t\t\t\n\t\t\t\t\techo wfView::create('waf\/options-group-advanced-firewall', array(\n\t\t\t\t\t\t'firewall' => $firewall,\n\t\t\t\t\t\t'waf' => $waf,\n\t\t\t\t\t\t'stateKey' => 'wf-unified-waf-options-advanced',\n\t\t\t\t\t))->render();\n\t\t\t\t\t\n\t\t\t\t\techo wfView::create('waf\/options-group-brute-force', array(\n\t\t\t\t\t\t'firewall' => $firewall,\n\t\t\t\t\t\t'waf' => $waf,\n\t\t\t\t\t\t'stateKey' => 'wf-unified-waf-options-bruteforce',\n\t\t\t\t\t))->render();\n\t\t\t\t\t\n\t\t\t\t\techo wfView::create('waf\/options-group-rate-limiting', array(\n\t\t\t\t\t\t'firewall' => $firewall,\n\t\t\t\t\t\t'waf' => $waf,\n\t\t\t\t\t\t'stateKey' => 'wf-unified-waf-options-ratelimiting',\n\t\t\t\t\t))->render();\n\t\t\t\t\t\n\t\t\t\t\techo wfView::create('waf\/options-group-whitelisted', array(\n\t\t\t\t\t\t'firewall' => $firewall,\n\t\t\t\t\t\t'waf' => $waf,\n\t\t\t\t\t\t'stateKey' => 'wf-unified-waf-options-whitelisted',\n\t\t\t\t\t))->render();\n\t\t\t\t\t?>\n\n\t\t\t\t\t<?php\n\t\t\t\t\techo wfView::create('common\/section-subtitle', array(\n\t\t\t\t\t\t'title' => __('Blocking Options', 'wordfence'),\n\t\t\t\t\t\t'showIcon' => false,\n\t\t\t\t\t))->render();\n\t\t\t\t\t\n\t\t\t\t\techo wfView::create('blocking\/options-group-advanced-country', array(\n\t\t\t\t\t\t'stateKey' => 'wf-unified-blocking-options-country',\n\t\t\t\t\t))->render();\n\t\t\t\t\t?>\n\t\t\t\t\t\n\t\t\t\t\t<?php\n\t\t\t\t\techo wfView::create('common\/section-subtitle', array(\n\t\t\t\t\t\t'title' => __('Scan Options', 'wordfence'),\n\t\t\t\t\t\t'showIcon' => false,\n\t\t\t\t\t))->render();\n\t\t\t\t\t\n\t\t\t\t\techo wfView::create('scanner\/options-group-scan-schedule', array(\n\t\t\t\t\t\t'scanner' => $scanner,\n\t\t\t\t\t\t'stateKey' => 'wf-unified-scanner-options-schedule',\n\t\t\t\t\t))->render();\n\t\t\t\t\t\n\t\t\t\t\techo wfView::create('scanner\/options-group-basic', array(\n\t\t\t\t\t\t'scanner' => $scanner,\n\t\t\t\t\t\t'stateKey' => 'wf-unified-scanner-options-basic',\n\t\t\t\t\t))->render();\n\t\t\t\t\t\n\t\t\t\t\techo wfView::create('scanner\/options-group-general', array(\n\t\t\t\t\t\t'scanner' => $scanner,\n\t\t\t\t\t\t'stateKey' => 'wf-unified-scanner-options-general',\n\t\t\t\t\t))->render();\n\t\t\t\t\t\n\t\t\t\t\techo wfView::create('scanner\/options-group-performance', array(\n\t\t\t\t\t\t'scanner' => $scanner,\n\t\t\t\t\t\t'stateKey' => 'wf-unified-scanner-options-performance',\n\t\t\t\t\t))->render();\n\t\t\t\t\t\n\t\t\t\t\techo wfView::create('scanner\/options-group-advanced', array(\n\t\t\t\t\t\t'scanner' => $scanner,\n\t\t\t\t\t\t'stateKey' => 'wf-unified-scanner-options-custom',\n\t\t\t\t\t))->render();\n\t\t\t\t\t?>\n\n\t\t\t\t\t<?php\n\t\t\t\t\techo wfView::create('common\/section-subtitle', array(\n\t\t\t\t\t\t'title' => __('Tool Options', 'wordfence'),\n\t\t\t\t\t\t'showIcon' => false,\n\t\t\t\t\t))->render();\n\t\t\t\t\t\n\t\t\t\t\tif (wfCredentialsController::useLegacy2FA()) {\n\t\t\t\t\t\techo wfView::create('tools\/options-group-2fa', array(\n\t\t\t\t\t\t\t'stateKey' => 'wf-unified-2fa-options',\n\t\t\t\t\t\t))->render();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\techo wfView::create('tools\/options-group-live-traffic', array(\n\t\t\t\t\t\t'stateKey' => 'wf-unified-live-traffic-options',\n\t\t\t\t\t\t'hideShowMenuItem' => true,\n\t\t\t\t\t))->render();\n\t\t\t\t\t\n\t\t\t\t\trequire(__DIR__ . '\/wfVersionSupport.php'); \/** @var $wfFeatureWPVersionAuditLog *\/\n\t\t\t\t\trequire(ABSPATH . WPINC . '\/version.php'); \/** @var string $wp_version *\/\n\t\t\t\t\t$wpTooOld = version_compare($wp_version, $wfFeatureWPVersionAuditLog, '<');\n\t\t\t\t\techo wfView::create('tools\/options-group-audit-log', array(\n\t\t\t\t\t\t'stateKey' => 'wf-unified-audit-log-options',\n\t\t\t\t\t\t'hideShowMenuItem' => true,\n\t\t\t\t\t\t'wpTooOld' => $wpTooOld,\n\t\t\t\t\t))->render();\n\t\t\t\t\t?>\n\n\t\t\t\t\t<div class=\"wf-row\">\n\t\t\t\t\t\t<div class=\"wf-col-xs-12\">\n\t\t\t\t\t\t\t<div class=\"wf-block wf-always-active\" data-persistence-key=\"\">\n\t\t\t\t\t\t\t\t<div class=\"wf-block-header\">\n\t\t\t\t\t\t\t\t\t<div class=\"wf-block-header-content\">\n\t\t\t\t\t\t\t\t\t\t<div class=\"wf-block-title\">\n\t\t\t\t\t\t\t\t\t\t\t<strong><?php esc_html_e('Import\/Export Options', 'wordfence'); ?><\/strong>\n\t\t\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t\t<div class=\"wf-block-content\">\n\t\t\t\t\t\t\t\t\t<ul class=\"wf-block-list\">\n\t\t\t\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t\t\t\t<ul class=\"wf-flex-horizontal wf-flex-vertical-xs wf-flex-full-width wf-add-top wf-add-bottom\">\n\t\t\t\t\t\t\t\t\t\t\t\t<li><?php esc_html_e('Importing and exporting of options is available on the Tools page', 'wordfence'); ?><\/li>\n\t\t\t\t\t\t\t\t\t\t\t\t<li class=\"wf-right wf-left-xs wf-padding-add-top-xs-small\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t<a href=\"<?php echo esc_url(network_admin_url('admin.php?page=WordfenceTools&subpage=importexport')); ?>\" class=\"wf-btn wf-btn-primary wf-btn-callout-subtle\" id=\"wf-export-options\"><?php esc_html_e('Import\/Export Options', 'wordfence'); ?><\/a>\n\t\t\t\t\t\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t\t\t\t\t<\/ul>\n\t\t\t\t\t\t\t\t\t\t\t<input type=\"hidden\" id=\"wf-option-exportOptions\">\n\t\t\t\t\t\t\t\t\t\t\t<input type=\"hidden\" id=\"wf-option-importOptions\">\n\t\t\t\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t\t\t<\/ul>\n\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t\t<\/div> <!-- end import options -->\n\t\t\t\t\t<?php\n\t\t\t\t\t$moduleOptionBlocks = wfModuleController::shared()->optionBlocks;\n\t\t\t\t\tforeach ($moduleOptionBlocks as $b) {\n\t\t\t\t\t\techo $b;\n\t\t\t\t\t}\n\t\t\t\t\t?>\n\t\t\t\t<\/div> <!-- end options block -->\n\t\t\t<\/div> <!-- end content block -->\n\t\t<\/div> <!-- end row -->\n\t<\/div> <!-- end container -->\n<\/div>"},{"base":"plugins","rel":"wordfence\/lib\/wfScanFileProperties.php","ext":"php","size":1095,"mtime":1757312769,"type":"text","content":"<?php\n\nclass wfScanFileProperties {\n\n\tpublic $realPath;\n\tpublic $wordpressPath;\n\tpublic $wordpressPathMd5;\n\tpublic $md5;\n\tpublic $shac;\n\tpublic $content;\n\tpublic $known;\n\tpublic $handle;\n\tpublic $safe;\n\n\tpublic function __construct($realPath, $wordpressPath) {\n\t\t$this->realPath = $realPath;\n\t\t$this->wordpressPath = $wordpressPath;\n\t\t$this->wordpressPathMd5 = md5($wordpressPath);\n\t}\n\n\tpublic function freeContent() {\n\t\t$this->content = null;\n\t}\n\n\tpublic function resetHandle() {\n\t\tif (!$this->handle)\n\t\t\treturn false;\n\t\tif (fseek($this->handle, 0, SEEK_SET) !== 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic function releaseHandle() {\n\t\tif ($this->handle) {\n\t\t\tfclose($this->handle);\n\t\t\t$this->handle = null;\n\t\t}\n\t}\n\n\tpublic function loadContent() {\n\t\tif (!$this->resetHandle())\n\t\t\treturn false;\n\t\t$content = fread($this->handle, WORDFENCE_MAX_FILE_SIZE_TO_PROCESS);\n\t\tif ($content === false)\n\t\t\treturn false;\n\t\t$this->content = $content;\n\t\treturn true;\n\t}\n\n\tpublic function free() {\n\t\t$this->freeContent();\n\t\t$this->releaseHandle();\n\t}\n\n\tpublic function __destruct() {\n\t\t$this->free();\n\t}\n\n}"},{"base":"plugins","rel":"wordfence\/lib\/audit-log\/wfAuditLogObserversWordPressCoreSite.php","ext":"php","size":22926,"mtime":1757312769,"type":"text","content":"<?php\n\nabstract class wfAuditLogObserversWordPressCoreSite extends wfAuditLog {\n\tconst SITE_DATA_EXPORTED = 'site.data.exported';\n\tconst SITE_RECOVERY_MODE_KEY_GENERATED = 'site.recovery-mode.key-generated';\n\t\n\tconst SITE_MAIL_SEND_FAILED = 'site.mail.send-failed';\n\tconst SITE_MAIL_SENT = 'site.mail.sent';\n\t\n\tconst SITE_OPTION_ACTIVE_PLUGINS = 'site.option.active-plugins';\n\tconst SITE_OPTION_ADMIN_EMAIL = 'site.option.admin-email';\n\tconst SITE_OPTION_ANONYMOUS_COMMENTS = 'site.option.anonymous-comments';\n\tconst SITE_OPTION_COMMENT_MODERATION = 'site.option.comment-moderation';\n\tconst SITE_OPTION_DEFAULT_COMMENT_STATUS = 'site.option.default-comment-status';\n\tconst SITE_OPTION_DEFAULT_ROLE = 'site.option.default-role';\n\tconst SITE_OPTION_HOME_URL = 'site.option.home-url';\n\tconst SITE_OPTION_SITE_URL = 'site.option.site-url';\n\tconst SITE_OPTION_STYLESHEET = 'site.option.stylesheet';\n\tconst SITE_OPTION_TEMPLATE = 'site.option.template';\n\tconst SITE_OPTION_USER_REGISTRATION = 'site.option.user-registration';\n\t\n\tconst SITE_PERMISSIONS_ROLE_CAPABILITIES = 'site.permissions.role-capabilities';\n\tconst SITE_PERMISSIONS_ADMIN_PAGE_DENIED = 'site.permissions.admin-page.denied';\n\t\n\tconst SITE_PLUGIN_INSTALLED = 'site.plugin.installed';\n\tconst SITE_PLUGIN_DELETED = 'site.plugin.deleted';\n\tconst SITE_PLUGIN_ACTIVATED = 'site.plugin.activated';\n\tconst SITE_PLUGIN_DEACTIVATED = 'site.plugin.deactivated';\n\t\n\tconst SITE_THEME_INSTALLED = 'site.theme.installed';\n\tconst SITE_THEME_DELETED = 'site.theme.deleted';\n\tconst SITE_THEME_SWITCHED = 'site.theme.switched';\n\tconst SITE_THEME_CUSTOMIZED = 'site.theme.customized';\n\tconst SITE_THEME_SIDEBAR_UPDATED = 'site.theme.sidebar.updated';\n\t\n\tconst SITE_UPDATE_AUTOMATIC_COMPLETED = 'site.update.automatic-completed';\n\tconst SITE_UPDATE_CORE = 'site.update.core';\n\tconst SITE_UPDATE_PLUGIN = 'site.update.plugin';\n\tconst SITE_UPDATE_THEME = 'site.update.theme';\n\t\n\tpublic static function immediateSendEvents() {\n\t\treturn array(\n\t\t\tself::SITE_OPTION_ACTIVE_PLUGINS,\n\t\t\tself::SITE_OPTION_DEFAULT_ROLE,\n\t\t\tself::SITE_PERMISSIONS_ROLE_CAPABILITIES,\n\t\t\tself::SITE_PLUGIN_ACTIVATED,\n\t\t\tself::SITE_THEME_INSTALLED,\n\t\t);\n\t}\n\t\n\tpublic static function eventCategories() {\n\t\treturn array(\n\t\t\twfAuditLog::AUDIT_LOG_CATEGORY_SITE_SETTINGS => array(\n\t\t\t\tself::SITE_DATA_EXPORTED,\n\t\t\t\t\n\t\t\t\tself::SITE_OPTION_ADMIN_EMAIL,\n\t\t\t\tself::SITE_OPTION_ANONYMOUS_COMMENTS,\n\t\t\t\tself::SITE_OPTION_COMMENT_MODERATION,\n\t\t\t\tself::SITE_OPTION_DEFAULT_COMMENT_STATUS,\n\t\t\t\tself::SITE_OPTION_DEFAULT_ROLE,\n\t\t\t\tself::SITE_OPTION_HOME_URL,\n\t\t\t\tself::SITE_OPTION_SITE_URL,\n\t\t\t\tself::SITE_OPTION_USER_REGISTRATION,\n\t\t\t),\n\t\t\twfAuditLog::AUDIT_LOG_CATEGORY_AUTHENTICATION => array(\n\t\t\t\tself::SITE_RECOVERY_MODE_KEY_GENERATED,\n\t\t\t),\n\t\t\twfAuditLog::AUDIT_LOG_CATEGORY_CONTENT => array(\n\t\t\t\tself::SITE_MAIL_SEND_FAILED,\n\t\t\t\tself::SITE_MAIL_SENT,\n\t\t\t),\n\t\t\twfAuditLog::AUDIT_LOG_CATEGORY_USER_PERMISSIONS => array(\n\t\t\t\tself::SITE_PERMISSIONS_ROLE_CAPABILITIES,\n\t\t\t\tself::SITE_PERMISSIONS_ADMIN_PAGE_DENIED,\n\t\t\t),\n\t\t\twfAuditLog::AUDIT_LOG_CATEGORY_PLUGINS_THEMES_UPDATES => array(\n\t\t\t\tself::SITE_OPTION_ACTIVE_PLUGINS,\n\t\t\t\tself::SITE_OPTION_STYLESHEET,\n\t\t\t\tself::SITE_OPTION_TEMPLATE,\n\t\t\t\t\n\t\t\t\tself::SITE_PLUGIN_INSTALLED,\n\t\t\t\tself::SITE_PLUGIN_DELETED,\n\t\t\t\tself::SITE_PLUGIN_ACTIVATED,\n\t\t\t\tself::SITE_PLUGIN_DEACTIVATED,\n\t\t\t\t\n\t\t\t\tself::SITE_THEME_INSTALLED,\n\t\t\t\tself::SITE_THEME_DELETED,\n\t\t\t\tself::SITE_THEME_SWITCHED,\n\t\t\t\tself::SITE_THEME_CUSTOMIZED,\n\t\t\t\tself::SITE_THEME_SIDEBAR_UPDATED,\n\t\t\t\t\n\t\t\t\tself::SITE_UPDATE_AUTOMATIC_COMPLETED,\n\t\t\t\tself::SITE_UPDATE_CORE,\n\t\t\t\tself::SITE_UPDATE_PLUGIN,\n\t\t\t\tself::SITE_UPDATE_THEME,\n\t\t\t),\n\t\t);\n\t}\n\t\n\tpublic static function eventNames() {\n\t\treturn array(\n\t\t\tself::SITE_DATA_EXPORTED => __('Site Data Exported', 'wordfence'),\n\t\t\tself::SITE_RECOVERY_MODE_KEY_GENERATED => __('Recovery Key Generated', 'wordfence'),\n\t\t\t\n\t\t\tself::SITE_MAIL_SEND_FAILED => __('Mail Send Failed', 'wordfence'),\n\t\t\tself::SITE_MAIL_SENT => __('Mail Sent', 'wordfence'),\n\t\t\t\n\t\t\tself::SITE_OPTION_ACTIVE_PLUGINS => __('Active Plugins Option Changed', 'wordfence'),\n\t\t\tself::SITE_OPTION_ADMIN_EMAIL => __('Admin Email Option Changed', 'wordfence'),\n\t\t\tself::SITE_OPTION_ANONYMOUS_COMMENTS => __('Anonymous Comments Allowed Option Changed', 'wordfence'),\n\t\t\tself::SITE_OPTION_COMMENT_MODERATION => __('Comment Moderation Default Option Changed', 'wordfence'),\n\t\t\tself::SITE_OPTION_DEFAULT_COMMENT_STATUS => __('Default Comment Status Option Changed', 'wordfence'),\n\t\t\tself::SITE_OPTION_DEFAULT_ROLE => __('Default User Role Option Changed', 'wordfence'),\n\t\t\tself::SITE_OPTION_HOME_URL => __('Home URL Option Changed', 'wordfence'),\n\t\t\tself::SITE_OPTION_SITE_URL => __('Site URL Option Changed', 'wordfence'),\n\t\t\tself::SITE_OPTION_STYLESHEET => __('Child Theme Option Changed', 'wordfence'),\n\t\t\tself::SITE_OPTION_TEMPLATE => __('Parent Theme Option Changed', 'wordfence'),\n\t\t\tself::SITE_OPTION_USER_REGISTRATION => __('User Registration Permission Option Changed', 'wordfence'),\n\t\t\t\n\t\t\tself::SITE_PERMISSIONS_ROLE_CAPABILITIES => __('Role Capabilities Changed', 'wordfence'),\n\t\t\tself::SITE_PERMISSIONS_ADMIN_PAGE_DENIED => __('Admin Page View Denied', 'wordfence'),\n\t\t\t\n\t\t\tself::SITE_PLUGIN_INSTALLED => __('Plugin Installed', 'wordfence'),\n\t\t\tself::SITE_PLUGIN_DELETED => __('Plugin Deleted', 'wordfence'),\n\t\t\tself::SITE_PLUGIN_ACTIVATED => __('Plugin Activated', 'wordfence'),\n\t\t\tself::SITE_PLUGIN_DEACTIVATED => __('Plugin Deactivated', 'wordfence'),\n\t\t\t\n\t\t\tself::SITE_THEME_INSTALLED => __('Theme Installed', 'wordfence'),\n\t\t\tself::SITE_THEME_DELETED => __('Theme Deleted', 'wordfence'),\n\t\t\tself::SITE_THEME_SWITCHED => __('Theme Switched', 'wordfence'),\n\t\t\tself::SITE_THEME_CUSTOMIZED => __('Theme Customized', 'wordfence'),\n\t\t\tself::SITE_THEME_SIDEBAR_UPDATED => __('Theme Sidebar Updated', 'wordfence'),\n\t\t\t\n\t\t\tself::SITE_UPDATE_AUTOMATIC_COMPLETED => __('Automatic Updates Completed', 'wordfence'),\n\t\t\tself::SITE_UPDATE_CORE => __('Core Update Completed', 'wordfence'),\n\t\t\tself::SITE_UPDATE_PLUGIN => __('Plugin Update Completed', 'wordfence'),\n\t\t\tself::SITE_UPDATE_THEME => __('Theme Update Completed', 'wordfence'),\n\t\t);\n\t}\n\t\n\tpublic static function eventRateLimiters() {\n\t\treturn array(\n\t\t\tself::SITE_PERMISSIONS_ROLE_CAPABILITIES => function($auditLog, $payload) {\n\t\t\t\t$hash = self::_normalizedPayloadHash($payload);\n\t\t\t\tif (self::_rateLimiterCheck(self::SITE_PERMISSIONS_ROLE_CAPABILITIES, $hash)) {\n\t\t\t\t\tself::_rateLimiterConsume(self::SITE_PERMISSIONS_ROLE_CAPABILITIES, $hash);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t},\n\t\t);\n\t}\n\t\n\t\/**\n\t * Registers the observers for this class's chunk of functionality.\n\t * \n\t * @param wfAuditLog $auditLog\n\t *\/\n\tprotected static function _registerObservers($auditLog) {\n\t\t$auditLog->_addObserver('export_wp', function($args) use ($auditLog) { \/\/Exported WP data\n\t\t\t$auditLog->_recordAction(self::SITE_DATA_EXPORTED, array('settings' => $args));\n\t\t});\n\t\t\n\t\tif ($auditLog->mode() == self::AUDIT_LOG_MODE_ALL) {\n\t\t\t$auditLog->_addObserver('wp_mail_succeeded', function($args) use ($auditLog) { \/\/Mail sent\n\t\t\t\tif (isset($args['to']) && !is_array($args['to'])) { $args['to'] = array($args['to']); } \/\/$args['to'] is supposed to be an array per the docs, but some plugins call it incorrectly\n\t\t\t\t$payload = array(\n\t\t\t\t\t'to_count' => isset($args['to']) ? count($args['to']) : 0,\n\t\t\t\t\t'subject' => isset($args['subject']) ? $args['subject'] : null,\n\t\t\t\t\t'attachment_count' => isset($args['attachments']) ? count($args['attachments']) : 0,\n\t\t\t\t);\n\t\t\t\t$auditLog->_recordAction(self::SITE_MAIL_SENT, $payload);\n\t\t\t});\n\t\t\t\n\t\t\t$auditLog->_addObserver('wp_mail_failed', function($error \/** @var WP_Error $error *\/) use ($auditLog) { \/\/Mail failed sending\n\t\t\t\t$args = $error->get_error_data();\n\t\t\t\tif (isset($args['to']) && !is_array($args['to'])) { $args['to'] = array($args['to']); } \/\/$args['to'] is supposed to be an array per the docs, but some plugins call it incorrectly\n\t\t\t\t$payload = array(\n\t\t\t\t\t'to_count' => isset($args['to']) ? count($args['to']) : 0,\n\t\t\t\t\t'subject' => isset($args['subject']) ? $args['subject'] : null,\n\t\t\t\t\t'attachment_count' => isset($args['attachments']) ? count($args['attachments']) : 0,\n\t\t\t\t\t'error' => $error->get_error_message(),\n\t\t\t\t);\n\t\t\t\t$auditLog->_recordAction(self::SITE_MAIL_SEND_FAILED, $payload);\n\t\t\t});\n\t\t}\n\t\t\n\t\t$auditLog->_addObserver('update_option_comment_registration', function($old_value, $value, $option) use ($auditLog) { \/\/Comment registration required enabled\/disabled\n\t\t\t$auditLog->_recordAction(self::SITE_OPTION_ANONYMOUS_COMMENTS, array('state' => wfUtils::truthyToBoolean($value)));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('update_option_default_role', function($old_value, $value, $option) use ($auditLog) { \/\/Default role on user registration\n\t\t\t$auditLog->_recordAction(self::SITE_OPTION_DEFAULT_ROLE, array('state' => $value));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('update_option_users_can_register', function($old_value, $value, $option) use ($auditLog) { \/\/User registration allowed\n\t\t\t$auditLog->_recordAction(self::SITE_OPTION_USER_REGISTRATION, array('state' => wfUtils::truthyToBoolean($value)));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('update_option_siteurl', function($old_value, $value, $option) use ($auditLog) { \/\/Site URL\n\t\t\t$auditLog->_recordAction(self::SITE_OPTION_SITE_URL, array('url' => $value));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('update_option_home', function($old_value, $value, $option) use ($auditLog) { \/\/Home URL\n\t\t\t$auditLog->_recordAction(self::SITE_OPTION_HOME_URL, array('url' => $value));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('update_option_admin_email', function($old_value, $value, $option) use ($auditLog) { \/\/Admin email\n\t\t\t$auditLog->_recordAction(self::SITE_OPTION_ADMIN_EMAIL, array('email' => $value));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('update_option_default_comment_status', function($old_value, $value, $option) use ($auditLog) { \/\/Default comment status\n\t\t\t$auditLog->_recordAction(self::SITE_OPTION_DEFAULT_COMMENT_STATUS, array('status' => $value));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('update_option_comment_moderation', function($old_value, $value, $option) use ($auditLog) { \/\/Comment moderation enabled\/disabled\n\t\t\t$auditLog->_recordAction(self::SITE_OPTION_COMMENT_MODERATION, array('state' => wfUtils::truthyToBoolean($value)));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('update_option_template', function($old_value, $value, $option) use ($auditLog) { \/\/Theme selected, this is the parent theme value\n\t\t\t$auditLog->_recordAction(self::SITE_OPTION_TEMPLATE, array('theme' => $value));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('update_option_stylesheet', function($old_value, $value, $option) use ($auditLog) { \/\/Theme selected, this is the child theme value\n\t\t\t$auditLog->_recordAction(self::SITE_OPTION_STYLESHEET, array('theme' => $value));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('admin_page_access_denied', function() use ($auditLog) { \/\/Admin page view denied\n\t\t\t$auditLog->_recordAction(self::SITE_PERMISSIONS_ADMIN_PAGE_DENIED, array());\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('activated_plugin', function($relative_path, $network_wide) use ($auditLog) { \/\/Plugin activated\n\t\t\t$path = trailingslashit(WP_PLUGIN_DIR) . $relative_path;\n\t\t\tif (is_readable($path)) {\n\t\t\t\t$plugin = $auditLog->_getPlugin($path);\n\t\t\t\tif ($plugin) {\n\t\t\t\t\t$auditLog->_recordAction(self::SITE_PLUGIN_ACTIVATED, array('plugin' => $plugin, 'network' => $network_wide));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('deactivated_plugin', function($relative_path, $network_wide) use ($auditLog) { \/\/Plugin deactivated\n\t\t\t$path = trailingslashit(WP_PLUGIN_DIR) . $relative_path;\n\t\t\tif (is_readable($path)) {\n\t\t\t\t$plugin = $auditLog->_getPlugin($path);\n\t\t\t\tif ($plugin) {\n\t\t\t\t\t$auditLog->_recordAction(self::SITE_PLUGIN_DEACTIVATED, array('plugin' => $plugin, 'network' => $network_wide));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('deleted_plugin', function($relative_path, $deleted) use ($auditLog) { \/\/Plugin deleted\n\t\t\tif ($deleted && $auditLog->_hasState('delete_plugin.plugin')) {\n\t\t\t\t$auditLog->_recordAction(self::SITE_PLUGIN_DELETED, array('plugin' => $auditLog->_getState('delete_plugin.plugin')));\n\t\t\t}\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('switch_theme', function($new_name, $new_theme, $old_theme) use ($auditLog) { \/\/Theme switched\n\t\t\t$auditLog->_recordAction(self::SITE_THEME_SWITCHED, array('from' => $auditLog->_getTheme($old_theme), 'to' => $auditLog->_getTheme($new_theme)));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('deleted_theme', function($stylesheet, $deleted) use ($auditLog) { \/\/Theme deleted\n\t\t\tif ($deleted && $auditLog->_hasState('delete_theme.theme')) {\n\t\t\t\t$auditLog->_recordAction(self::SITE_THEME_DELETED, array('theme' => $auditLog->_getState('delete_theme.theme')));\n\t\t\t}\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('customize_save_after', function($manager \/** @var WP_Customize_Manager $manager *\/) use ($auditLog) { \/\/Theme customized\n\t\t\t$auditLog->_recordAction(self::SITE_THEME_CUSTOMIZED, array('theme' => $auditLog->_getTheme($manager->theme())));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('upgrader_process_complete', function($upgrader, $hook_extra) use ($auditLog) { \/\/Updates completed\n\t\t\t$afterVersions = $auditLog->_installedVersions();\n\t\t\t\n\t\t\t\/\/Core\n\t\t\tif (is_array($hook_extra) && isset($hook_extra['type']) && $hook_extra['type'] == 'core' && isset($hook_extra['action']) && $hook_extra['action'] == 'update') {\n\t\t\t\t$payload = array(\n\t\t\t\t\t'core' => $afterVersions['core'],\n\t\t\t\t);\n\t\t\t\t$payload['previous_version'] = self::$initialCoreVersion;\n\t\t\t\t$auditLog->_recordAction(self::SITE_UPDATE_CORE, $payload);\n\t\t\t}\n\t\t\t\n\t\t\t\/\/Plugins\/themes\n\t\t\tif ($auditLog->_hasState('upgrader_post_install.pending', 0)) {\n\t\t\t\t$pending = $auditLog->_getState('upgrader_post_install.pending', 0);\n\t\t\t\t\n\t\t\t\tforeach ($pending as $p) {\n\t\t\t\t\tif ($p['action'] == self::SITE_PLUGIN_INSTALLED || $p['action'] == self::SITE_UPDATE_PLUGIN) {\n\t\t\t\t\t\t$relativePath = preg_replace('\/^' . preg_quote(WP_PLUGIN_DIR, '\/') . '\/', '', $p['path']);\n\t\t\t\t\t\tif (!(validate_file($relativePath) === 0 \/\/this conditional matches the plugin loader's requirements\n\t\t\t\t\t\t\t&& preg_match('\/\\.php$\/i', $relativePath)\n\t\t\t\t\t\t\t&& file_exists(WP_PLUGIN_DIR . '\/' . $relativePath)\n\t\t\t\t\t\t\t&& is_readable($p['path']))) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t$plugin = $auditLog->_getPlugin($p['path']);\n\t\t\t\t\t\tif ($plugin) {\n\t\t\t\t\t\t\t$auditLog->_recordAction($p['action'], array('plugin' => $plugin));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ($p['action'] == self::SITE_THEME_INSTALLED || $p['action'] == self::SITE_UPDATE_THEME) {\n\t\t\t\t\t\tif (!is_readable($p['path'])) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t$theme = $auditLog->_getTheme($p['path']);\n\t\t\t\t\t\tif ($theme) {\n\t\t\t\t\t\t\t$auditLog->_recordAction($p['action'], array('theme' => $theme));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t$auditLog->_trackState('upgrader_post_install.pending', array(), 0);\n\t\t\t}\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('automatic_updates_complete', function($update_results) use ($auditLog) { \/\/Automatic updates complete\n\t\t\t$auditLog->_recordAction(self::SITE_UPDATE_AUTOMATIC_COMPLETED, array('results' => $update_results));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('generate_recovery_mode_key', function($token, $key) use ($auditLog) { \/\/Recovery key generated\n\t\t\t$auditLog->_recordAction(self::SITE_RECOVERY_MODE_KEY_GENERATED, array());\n\t\t});\n\t}\n\t\n\t\/**\n\t * Registers the data gatherers for this class's chunk of functionality.\n\t *\n\t * @param wfAuditLog $auditLog\n\t *\/\n\tprotected static function _registerDataGatherers($auditLog) {\n\t\t$auditLog->_addObserver('update_option', function($option, $old_value, $value) use ($auditLog) { \/\/User role capabilities changed\n\t\t\tif (preg_match('\/user_roles$\/i', $option)) { \/\/For some reason this option is stored prefixed inside a table that is already prefixed on multisite, so we have to treat it special\n\t\t\t\tif (!$auditLog->_hasState('update_option_wp_user_roles.old', $auditLog->_extractMultisiteID($option, 'user_roles'))) {\n\t\t\t\t\t$auditLog->_trackState('update_option_wp_user_roles.old', $old_value, $auditLog->_extractMultisiteID($option, 'user_roles'));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t$auditLog->_trackState('update_option_wp_user_roles.new', $value, $auditLog->_extractMultisiteID($option, 'user_roles'));\n\t\t\t\t\n\t\t\t\t$auditLog->_needsDestruct();\n\t\t\t}\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('update_option_active_plugins', function($old_value, $value, $option) use ($auditLog) { \/\/Active plugins changed\n\t\t\tif (!$auditLog->_hasState('update_option_active_plugins.old', get_current_blog_id())) {\n\t\t\t\t$auditLog->_trackState('update_option_active_plugins.old', $old_value, get_current_blog_id());\n\t\t\t}\n\t\t\t\n\t\t\t$auditLog->_trackState('update_option_active_plugins.new', $value, get_current_blog_id());\n\t\t\t\n\t\t\t$auditLog->_needsDestruct();\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('delete_plugin', function($relative_path) use ($auditLog) { \/\/Plugin will be deleted\n\t\t\t$path = trailingslashit(WP_PLUGIN_DIR) . $relative_path;\n\t\t\tif (is_readable($path)) {\n\t\t\t\t$plugin = $auditLog->_getPlugin($path);\n\t\t\t\tif ($plugin) {\n\t\t\t\t\t$auditLog->_trackState('delete_plugin.plugin', $plugin);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('delete_theme', function($stylesheet) use ($auditLog) { \/\/Theme will be deleted\n\t\t\t$theme = $auditLog->_getTheme(wp_get_theme($stylesheet));\n\t\t\tif ($theme) {\n\t\t\t\t$auditLog->_trackState('delete_theme.theme', $theme);\n\t\t\t}\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('upgrader_pre_install', function($response, $hook_extra) use ($auditLog) { \/\/Plugin\/theme\/core will be installed\/updated, capture initial versions\n\t\t\tif (!$auditLog->_hasState('upgrader_pre_install.versions', 0)) {\n\t\t\t\t$auditLog->_trackState('upgrader_pre_install.versions', $auditLog->_installedVersions(), 0);\n\t\t\t}\n\t\t}, 'filter');\n\t\t\n\t\t$auditLog->_addObserver('upgrader_post_install', function($response, $hook_extra, $result) use ($auditLog) { \/\/Plugin\/theme installed\/updated\n\t\t\tif ($response && !is_wp_error($result)) {\n\t\t\t\t$pending = array();\n\t\t\t\tif ($auditLog->_hasState('upgrader_post_install.pending', 0)) {\n\t\t\t\t\t$pending = $auditLog->_getState('upgrader_post_install.pending', 0);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\/*\n\t\t\t\t * $hook_extra install example:\n\t\t\t\t * \n\t\t\t\t * array (\n\t\t\t\t *\t  'type' => 'plugin',\n\t\t\t\t *\t  'action' => 'install',\n\t\t\t\t *\t)\n\t\t\t\t * \n\t\t\t\t * \n\t\t\t\t * $hook_extra update example:\n\t\t\t\t * \n\t\t\t\t * array (\n\t\t\t\t *\t  'plugin' => 'wordfence\/wordfence.php',\n\t\t\t\t *\t  'temp_backup' => \n\t\t\t\t *\t  array (\n\t\t\t\t *\t\t'slug' => 'wordfence',\n\t\t\t\t *\t\t'src' => '\/path\/to\/wp-content\/plugins',\n\t\t\t\t *\t\t'dir' => 'plugins',\n\t\t\t\t *\t  ),\n\t\t\t\t *\t)\n\t\t\t\t *\/\n\t\t\t\t\n\t\t\t\t\/*\n\t\t\t\t * $result example:\n\t\t\t\t * \n\t\t\t\t * array (\n\t\t\t\t *\t  'source' => '\/path\/to\/wp-content\/upgrade\/wordfence.8.0.0\/wordfence\/',\n\t\t\t\t *\t  'source_files' => \n\t\t\t\t *\t  array (\n\t\t\t\t *\t\t0 => 'LICENSE.txt',\n\t\t\t\t *\t\t1 => 'readme.txt',\n\t\t\t\t *\t\t2 => 'wordfence.php',\n\t\t\t\t *\t\t3 => ...\n\t\t\t\t *\t  ),\n\t\t\t\t *\t  'destination' => '\/path\/to\/wp-content\/plugins\/wordfence\/',\n\t\t\t\t *\t  'destination_name' => 'wordfence',\n\t\t\t\t *\t  'local_destination' => '\/path\/to\/wp-content\/plugins',\n\t\t\t\t *\t  'remote_destination' => '\/path\/to\/plugins\/wordfence\/',\n\t\t\t\t *\t  'clear_destination' => false,\n\t\t\t\t *\t)\n\t\t\t\t *\/\n\t\t\t\t\n\t\t\t\tif (isset($hook_extra['action']) && isset($hook_extra['type']) && isset($result['source']) && isset($result['destination'])) { \/\/Install\n\t\t\t\t\tif ($hook_extra['action'] == 'install') {\n\t\t\t\t\t\tif ($hook_extra['type'] == 'plugin') {\n\t\t\t\t\t\t\t$path = $auditLog->_resolvePlugin(untrailingslashit($result['destination']));\n\t\t\t\t\t\t\tif ($path) {\n\t\t\t\t\t\t\t\t$pending[] = array('action' => self::SITE_PLUGIN_INSTALLED, 'path' => $path);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ($hook_extra['type'] == 'theme') {\n\t\t\t\t\t\t\t$path = $result['destination'];\n\t\t\t\t\t\t\t$pending[] = array('action' => self::SITE_THEME_INSTALLED, 'path' => $path); \/\/Can't record here since version data hasn't refreshed yet\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (isset($hook_extra['plugin']) && isset($result['source']) && isset($result['destination'])) { \/\/Plugin update\n\t\t\t\t\t$path = $auditLog->_resolvePlugin(trailingslashit(WP_PLUGIN_DIR) . $hook_extra['plugin']);\n\t\t\t\t\tif ($path) {\n\t\t\t\t\t\t$pending[] = array('action' => self::SITE_UPDATE_PLUGIN, 'path' => $path);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (isset($hook_extra['theme']) && isset($result['source']) && isset($result['destination'])) { \/\/Theme update\n\t\t\t\t\t$path = trailingslashit(get_theme_root()) . $hook_extra['theme'];\n\t\t\t\t\t$pending[] = array('action' => self::SITE_UPDATE_THEME, 'path' => $path);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t$auditLog->_trackState('upgrader_post_install.pending', $pending, 0);\n\t\t\t}\n\t\t\t\n\t\t\treturn $response;\n\t\t}, 'filter');\n\t}\n\t\n\t\/**\n\t * Registers the coalescers for this class's chunk of functionality.\n\t *\n\t * @param wfAuditLog $auditLog\n\t *\/\n\tprotected static function _registerCoalescers($auditLog) {\n\t\t$auditLog->_addCoalescer(function() use ($auditLog) { \/\/Role capabilities changed\n\t\t\t$old = $auditLog->_getAllStates('update_option_wp_user_roles.old');\n\t\t\tif (!count($old)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (count($old) > 1) {\n\t\t\t\t$payload = array();\n\t\t\t\tforeach ($old as $blog_id => $o) {\n\t\t\t\t\t$new = $auditLog->_getState('update_option_wp_user_roles.new', $blog_id);\n\t\t\t\t\t$diff = wfUtils::array_diff($o, $new);\n\t\t\t\t\tif (!empty($diff['added']) || !empty($diff['removed'])) {\n\t\t\t\t\t\t$payload[] = array('capabilities' => $new, 'diff' => $diff, 'multisite_blog_id' => $blog_id);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count($payload)) {\n\t\t\t\t\t$auditLog->_recordAction(self::SITE_PERMISSIONS_ROLE_CAPABILITIES, array('changes' => $payload));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$blog_id = wfUtils::array_key_first($old);\n\t\t\t\t$old = $old[$blog_id];\n\t\t\t\t$new = $auditLog->_getState('update_option_wp_user_roles.new', $blog_id);\n\t\t\t\t$diff = wfUtils::array_diff($old, $new);\n\t\t\t\tif (!empty($diff['added']) || !empty($diff['removed'])) {\n\t\t\t\t\t$auditLog->_recordAction(self::SITE_PERMISSIONS_ROLE_CAPABILITIES, array('capabilities' => $new, 'diff' => $diff));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\t$auditLog->_addCoalescer(function() use ($auditLog) { \/\/Active plugins changed\n\t\t\t$old = $auditLog->_getAllStates('update_option_active_plugins.old');\n\t\t\tif (!count($old)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (count($old) > 1) {\n\t\t\t\t$payload = array();\n\t\t\t\tforeach ($old as $blog_id => $o) {\n\t\t\t\t\t$new = $auditLog->_getState('update_option_active_plugins.new', $blog_id);\n\t\t\t\t\t$diff = wfUtils::array_diff($o, $new);\n\t\t\t\t\tif (!empty($diff['added']) || !empty($diff['removed'])) {\n\t\t\t\t\t\t$payload[] = array('plugins' => $new, 'diff' => $diff, 'multisite_blog_id' => $blog_id);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count($payload)) {\n\t\t\t\t\t$auditLog->_recordAction(self::SITE_OPTION_ACTIVE_PLUGINS, array('changes' => $payload));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$blog_id = wfUtils::array_key_first($old);\n\t\t\t\t$old = $old[$blog_id];\n\t\t\t\t$new = $auditLog->_getState('update_option_active_plugins.new', $blog_id);\n\t\t\t\t$diff = wfUtils::array_diff($old, $new);\n\t\t\t\tif (!empty($diff['added']) || !empty($diff['removed'])) {\n\t\t\t\t\t$auditLog->_recordAction(self::SITE_OPTION_ACTIVE_PLUGINS, array('plugins' => $new, 'diff' => $diff));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}"},{"base":"plugins","rel":"wordfence\/lib\/audit-log\/wfAuditLogObserversWordPressCoreMultisite.php","ext":"php","size":13928,"mtime":1757312769,"type":"text","content":"<?php\n\nabstract class wfAuditLogObserversWordPressCoreMultisite extends wfAuditLog {\n\tconst MULTISITE_BLOG_CREATED = 'multisite.blog.created';\n\tconst MULTISITE_BLOG_DELETED = 'multisite.blog.deleted';\n\tconst MULTISITE_BLOG_UPDATED = 'multisite.blog.updated';\n\t\n\tconst MULTISITE_BLOG_ACTIVATED = 'multisite.blog.activated';\n\tconst MULTISITE_BLOG_DEACTIVATED = 'multisite.blog.deactivated';\n\tconst MULTISITE_BLOG_SIGNUP_SUBMITTED = 'multisite.blog.signup-submitted';\n\t\n\tconst MULTISITE_BLOG_MARK_ARCHIVED = 'multisite.blog.mark-archived';\n\tconst MULTISITE_BLOG_MARK_DELETED = 'multisite.blog.mark-deleted';\n\tconst MULTISITE_BLOG_MARK_PUBLIC = 'multisite.blog.mark-public';\n\tconst MULTISITE_BLOG_MARK_SPAM = 'multisite.blog.mark-spam';\n\tconst MULTISITE_BLOG_UNMARK_ARCHIVED = 'multisite.blog.unmark-archived';\n\tconst MULTISITE_BLOG_UNMARK_DELETED = 'multisite.blog.unmark-deleted';\n\tconst MULTISITE_BLOG_UNMARK_PUBLIC = 'multisite.blog.unmark-public';\n\tconst MULTISITE_BLOG_UNMARK_SPAM = 'multisite.blog.unmark-spam';\n\t\n\tconst MULTISITE_USER_CREATED = 'multisite.user.created'; \/\/User record itself created\n\tconst MULTISITE_USER_DELETED = 'multisite.user.deleted'; \/\/User record deleted\n\tconst MULTISITE_USER_ACTIVATED = 'multisite.user.activated';\n\tconst MULTISITE_USER_ADDED = 'multisite.user.added'; \/\/Existing user added to a blog\n\tconst MULTISITE_USER_REMOVED = 'multisite.user.removed'; \/\/Existing user removed from a blog\n\tconst MULTISITE_USER_INVITED = 'multisite.user.invited';\n\tconst MULTISITE_USER_SIGNED_UP = 'multisite.user.signed-up';\n\t\n\tconst MULTISITE_NETWORK_OPTION_ACTIVE_PLUGINS = 'multisite.plugin.network-activated';\n\t\n\tconst USER_SUPER_ADMIN_GRANTED = 'user.permissions.super-admin-granted';\n\tconst USER_SUPER_ADMIN_REVOKED = 'user.permissions.super-admin-revoked';\n\t\n\tpublic static function immediateSendEvents() {\n\t\treturn array(\n\t\t\tself::MULTISITE_NETWORK_OPTION_ACTIVE_PLUGINS,\n\t\t\tself::USER_SUPER_ADMIN_GRANTED,\n\t\t);\n\t}\n\t\n\tpublic static function eventCategories() {\n\t\treturn array(\n\t\t\twfAuditLog::AUDIT_LOG_CATEGORY_MULTISITE => array(\n\t\t\t\tself::MULTISITE_BLOG_CREATED,\n\t\t\t\tself::MULTISITE_BLOG_DELETED,\n\t\t\t\tself::MULTISITE_BLOG_UPDATED,\n\t\t\t\t\n\t\t\t\tself::MULTISITE_BLOG_ACTIVATED,\n\t\t\t\tself::MULTISITE_BLOG_DEACTIVATED,\n\t\t\t\tself::MULTISITE_BLOG_SIGNUP_SUBMITTED,\n\t\t\t\t\n\t\t\t\tself::MULTISITE_BLOG_MARK_ARCHIVED,\n\t\t\t\tself::MULTISITE_BLOG_MARK_DELETED,\n\t\t\t\tself::MULTISITE_BLOG_MARK_PUBLIC,\n\t\t\t\tself::MULTISITE_BLOG_MARK_SPAM,\n\t\t\t\tself::MULTISITE_BLOG_UNMARK_ARCHIVED,\n\t\t\t\tself::MULTISITE_BLOG_UNMARK_DELETED,\n\t\t\t\tself::MULTISITE_BLOG_UNMARK_PUBLIC,\n\t\t\t\tself::MULTISITE_BLOG_UNMARK_SPAM,\n\t\t\t),\n\t\t\twfAuditLog::AUDIT_LOG_CATEGORY_PLUGINS_THEMES_UPDATES => array(\n\t\t\t\tself::MULTISITE_NETWORK_OPTION_ACTIVE_PLUGINS,\n\t\t\t),\n\t\t\twfAuditLog::AUDIT_LOG_CATEGORY_USER_PERMISSIONS => array(\n\t\t\t\tself::MULTISITE_USER_CREATED,\n\t\t\t\tself::MULTISITE_USER_DELETED,\n\t\t\t\tself::MULTISITE_USER_ACTIVATED,\n\t\t\t\tself::MULTISITE_USER_ADDED,\n\t\t\t\tself::MULTISITE_USER_REMOVED,\n\t\t\t\tself::MULTISITE_USER_INVITED,\n\t\t\t\tself::MULTISITE_USER_SIGNED_UP,\n\t\t\t\t\n\t\t\t\tself::USER_SUPER_ADMIN_GRANTED,\n\t\t\t\tself::USER_SUPER_ADMIN_REVOKED,\n\t\t\t),\n\t\t);\n\t}\n\t\n\tpublic static function eventNames() {\n\t\treturn array(\n\t\t\tself::MULTISITE_BLOG_CREATED => __('Multisite Blog Created', 'wordfence'),\n\t\t\tself::MULTISITE_BLOG_DELETED => __('Multisite Blog Deleted', 'wordfence'),\n\t\t\tself::MULTISITE_BLOG_UPDATED => __('Multisite Blog Updated', 'wordfence'),\n\t\t\t\n\t\t\tself::MULTISITE_BLOG_ACTIVATED => __('Multisite Blog Activated', 'wordfence'),\n\t\t\tself::MULTISITE_BLOG_DEACTIVATED => __('Multisite Blog Deactivated', 'wordfence'),\n\t\t\tself::MULTISITE_BLOG_SIGNUP_SUBMITTED => __('Multisite Blog Signup Submitted', 'wordfence'),\n\t\t\t\n\t\t\tself::MULTISITE_BLOG_MARK_ARCHIVED => __('Multisite Blog Archived', 'wordfence'),\n\t\t\tself::MULTISITE_BLOG_MARK_DELETED => __('Multisite Blog Moved to Trash', 'wordfence'),\n\t\t\tself::MULTISITE_BLOG_MARK_PUBLIC => __('Multisite Blog Made Public', 'wordfence'),\n\t\t\tself::MULTISITE_BLOG_MARK_SPAM => __('Multisite Blog Marked as Spam', 'wordfence'),\n\t\t\tself::MULTISITE_BLOG_UNMARK_ARCHIVED => __('Multisite Blog Unarchived', 'wordfence'),\n\t\t\tself::MULTISITE_BLOG_UNMARK_DELETED => __('Multisite Blog Removed from Trash', 'wordfence'),\n\t\t\tself::MULTISITE_BLOG_UNMARK_PUBLIC => __('Multisite Blog Made Private', 'wordfence'),\n\t\t\tself::MULTISITE_BLOG_UNMARK_SPAM => __('Multisite Blog Unmarked as Spam', 'wordfence'),\n\t\t\t\n\t\t\tself::MULTISITE_USER_CREATED => __('Multisite User Created', 'wordfence'),\n\t\t\tself::MULTISITE_USER_DELETED => __('Multisite User Deleted', 'wordfence'),\n\t\t\tself::MULTISITE_USER_ACTIVATED => __('Multisite User Activated', 'wordfence'),\n\t\t\tself::MULTISITE_USER_ADDED => __('User Added to Multisite Blog', 'wordfence'),\n\t\t\tself::MULTISITE_USER_REMOVED => __('User Removed from Multisite Blog', 'wordfence'),\n\t\t\tself::MULTISITE_USER_INVITED => __('User Invited to Multisite Blog', 'wordfence'),\n\t\t\tself::MULTISITE_USER_SIGNED_UP => __('User Signed Up on Multisite Blog', 'wordfence'),\n\t\t\t\n\t\t\tself::MULTISITE_NETWORK_OPTION_ACTIVE_PLUGINS => __('Multisite Network Plugins Changed', 'wordfence'),\n\t\t\t\n\t\t\tself::USER_SUPER_ADMIN_GRANTED => __('Super Admin Granted to User', 'wordfence'),\n\t\t\tself::USER_SUPER_ADMIN_REVOKED => __('Super Admin Revoked from User', 'wordfence'),\n\t\t);\n\t}\n\t\n\tpublic static function eventRateLimiters() {\n\t\treturn array();\n\t}\n\t\n\t\/**\n\t * Registers the observers for this class's chunk of functionality.\n\t * \n\t * @param wfAuditLog $auditLog\n\t *\/\n\tprotected static function _registerObservers($auditLog) {\n\t\tif (!is_multisite()) { return; }\n\t\t\n\t\t$auditLog->_addObserver('activate_blog', function($id) use ($auditLog) { \/\/Multisite blog activated (from deactivated state -- WP uses trashed\/untrashed pattern internally for this)\n\t\t\t$blog = get_blog_details(array('blog_id' => $id));\n\t\t\t$auditLog->_recordAction(self::MULTISITE_BLOG_ACTIVATED, array('blog' => $auditLog->_sanitizeMultisiteData(false, $blog)));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wp_insert_site', function($blog) use ($auditLog) { \/\/Multisite blog created\n\t\t\t$auditLog->_recordAction(self::MULTISITE_BLOG_CREATED, array('blog' => $auditLog->_sanitizeMultisiteData(false, $blog)));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wp_delete_site', function($blog) use ($auditLog) { \/\/Multisite blog deleted\n\t\t\tif ($auditLog->_hasState('wp_validate_site_deletion.blog')) {\n\t\t\t\t$auditLog->_recordAction(self::MULTISITE_BLOG_DELETED, array('blog' => $auditLog->_getState('wp_validate_site_deletion.blog')));\n\t\t\t}\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wp_update_site', function($new_blog, $old_blog) use ($auditLog) { \/\/Multisite blog updated\n\t\t\t$before = $auditLog->_sanitizeMultisiteData(false, $old_blog);\n\t\t\t$after = $auditLog->_sanitizeMultisiteData(false, $new_blog);\n\t\t\t$changes = array_keys($auditLog->_multisiteDiff($before, $after));\n\t\t\t$auditLog->_recordAction(self::MULTISITE_BLOG_UPDATED, array('blog' => $after, 'changes' => $changes));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('archive_blog', function($blog_id) use ($auditLog) { \/\/Multisite blog archived\n\t\t\t$blog = get_blog_details(array('blog_id' => $blog_id));\n\t\t\t$auditLog->_recordAction(self::MULTISITE_BLOG_MARK_ARCHIVED, array('blog' => $auditLog->_sanitizeMultisiteData(false, $blog)));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('unarchive_blog', function($blog_id) use ($auditLog) { \/\/Multisite blog unarchived\n\t\t\t$blog = get_blog_details(array('blog_id' => $blog_id));\n\t\t\t$auditLog->_recordAction(self::MULTISITE_BLOG_UNMARK_ARCHIVED, array('blog' => $auditLog->_sanitizeMultisiteData(false, $blog)));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('make_delete_blog', function($blog_id) use ($auditLog) { \/\/Multisite blog trashed\n\t\t\t$blog = get_blog_details(array('blog_id' => $blog_id));\n\t\t\t$auditLog->_recordAction(self::MULTISITE_BLOG_MARK_DELETED, array('blog' => $auditLog->_sanitizeMultisiteData(false, $blog)));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('make_undelete_blog', function($blog_id) use ($auditLog) { \/\/Multisite blog untrashed\n\t\t\t$blog = get_blog_details(array('blog_id' => $blog_id));\n\t\t\t$auditLog->_recordAction(self::MULTISITE_BLOG_UNMARK_DELETED, array('blog' => $auditLog->_sanitizeMultisiteData(false, $blog)));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('update_blog_public', function($blog_id, $public) use ($auditLog) { \/\/Multisite blog made public\/private\n\t\t\t$blog = get_blog_details(array('blog_id' => $blog_id));\n\t\t\t$auditLog->_recordAction(wfUtils::truthyToBoolean($public) ? self::MULTISITE_BLOG_MARK_PUBLIC : self::MULTISITE_BLOG_UNMARK_PUBLIC, array('blog' => $auditLog->_sanitizeMultisiteData(false, $blog)));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('make_spam_blog', function($blog_id) use ($auditLog) { \/\/Multisite blog marked spam\n\t\t\t$blog = get_blog_details(array('blog_id' => $blog_id));\n\t\t\t$auditLog->_recordAction(self::MULTISITE_BLOG_MARK_SPAM, array('blog' => $auditLog->_sanitizeMultisiteData(false, $blog)));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('make_ham_blog', function($blog_id) use ($auditLog) { \/\/Multisite blog unmarked spam\n\t\t\t$blog = get_blog_details(array('blog_id' => $blog_id));\n\t\t\t$auditLog->_recordAction(self::MULTISITE_BLOG_UNMARK_SPAM, array('blog' => $auditLog->_sanitizeMultisiteData(false, $blog)));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('after_signup_site', function($domain, $path, $title, $user, $user_email, $key, $meta) use ($auditLog) { \/\/Multisite blog signup\n\t\t\t$auditLog->_recordAction(self::MULTISITE_BLOG_SIGNUP_SUBMITTED, array(\n\t\t\t\t'blog' => array(\n\t\t\t\t\t'blog_domain' => $domain,\n\t\t\t\t\t'blog_path' => $path,\n\t\t\t\t\t'blog_name' => $title,\n\t\t\t\t),\n\t\t\t\t'user' => array(\n\t\t\t\t\t'user_login' => $user,\n\t\t\t\t),\n\t\t\t));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('add_user_to_blog', function($user_id, $role, $blog_id) use ($auditLog) { \/\/User added to multisite blog\n\t\t\t$user = get_user_by('ID', $user_id);\n\t\t\t$blog = get_blog_details(array('blog_id' => $blog_id));\n\t\t\t$auditLog->_recordAction(self::MULTISITE_USER_ADDED, array('blog' => $auditLog->_sanitizeMultisiteData(false, $blog), 'user' => $auditLog->_sanitizeUserdata($user), 'role' => $role));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wpmu_new_user', function($user_id) use ($auditLog) { \/\/New unprivileged multisite user created\n\t\t\t$user = get_user_by('ID', $user_id);\n\t\t\t$auditLog->_recordAction(self::MULTISITE_USER_CREATED, array('user' => $auditLog->_sanitizeUserdata($user)));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wpmu_delete_user', function($id, $user) use ($auditLog) { \/\/Multisite user will be deleted\n\t\t\t$auditLog->_recordAction(self::MULTISITE_USER_DELETED, array('user' => $auditLog->_sanitizeUserdata($user)));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('invite_user', function($user_id, $role, $newuser_key) use ($auditLog) { \/\/Multisite user invited to blog\n\t\t\t$user = get_user_by('ID', $user_id);\n\t\t\t$blog = get_blog_details();\n\t\t\t$auditLog->_recordAction(self::MULTISITE_USER_INVITED, array('blog' => $auditLog->_sanitizeMultisiteData(false, $blog), 'user' => $auditLog->_sanitizeUserdata($user), 'role' => $role));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('remove_user_from_blog', function($user_id, $blog_id, $reassign_id) use ($auditLog) { \/\/Multisite user removed from blog\n\t\t\t$user = get_user_by('ID', $user_id);\n\t\t\t$blog = get_blog_details(array('blog_id' => $blog_id));\n\t\t\t$reassign = get_user_by('ID', $reassign_id);\n\t\t\t$auditLog->_recordAction(self::MULTISITE_USER_REMOVED, array('blog' => $auditLog->_sanitizeMultisiteData(false, $blog), 'user' => $auditLog->_sanitizeUserdata($user), 'reassign' => $auditLog->_sanitizeUserdata($reassign)));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('after_signup_user', function($user, $user_email, $key, $meta) use ($auditLog) { \/\/Multisite user signup\n\t\t\t$auditLog->_recordAction(self::MULTISITE_USER_SIGNED_UP, array(\n\t\t\t\t'user' => array(\n\t\t\t\t\t'user_login' => $user,\n\t\t\t\t),\n\t\t\t));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('granted_super_admin', function($user_id) use ($auditLog) { \/\/Super admin granted\n\t\t\t$user = get_user_by('ID', $user_id);\n\t\t\t$auditLog->_recordAction(self::USER_SUPER_ADMIN_GRANTED, $auditLog->_sanitizeUserdata($user));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('revoked_super_admin', function($user_id) use ($auditLog) { \/\/Super admin revoked\n\t\t\t$user = get_user_by('ID', $user_id);\n\t\t\t$auditLog->_recordAction(self::USER_SUPER_ADMIN_REVOKED, $auditLog->_sanitizeUserdata($user));\n\t\t});\n\t}\n\t\n\t\/**\n\t * Registers the data gatherers for this class's chunk of functionality.\n\t *\n\t * @param wfAuditLog $auditLog\n\t *\/\n\tprotected static function _registerDataGatherers($auditLog) {\n\t\tif (!is_multisite()) { return; }\n\t\t\n\t\t$auditLog->_addObserver('wp_validate_site_deletion', function($errors, $blog) use ($auditLog) { \/\/Multisite site will be deleted\n\t\t\t$auditLog->_trackState('wp_validate_site_deletion.blog', $auditLog->_sanitizeMultisiteData(false, $blog));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('update_site_option_active_sitewide_plugins', function($option, $value, $old_value, $network_id) use ($auditLog) { \/\/Network active plugins changed\n\t\t\tif (!$auditLog->_hasState('update_site_option_active_sitewide_plugins.old', 0)) {\n\t\t\t\t$auditLog->_trackState('update_site_option_active_sitewide_plugins.old', $old_value, 0);\n\t\t\t}\n\t\t\t\n\t\t\t$auditLog->_trackState('update_site_option_active_sitewide_plugins.new', $value, 0);\n\t\t\t\n\t\t\t$auditLog->_needsDestruct();\n\t\t});\n\t}\n\t\n\t\/**\n\t * Registers the coalescers for this class's chunk of functionality.\n\t *\n\t * @param wfAuditLog $auditLog\n\t *\/\n\tprotected static function _registerCoalescers($auditLog) {\n\t\tif (!is_multisite()) { return; }\n\t\t\n\t\t$auditLog->_addCoalescer(function() use ($auditLog) { \/\/Network active plugins changed\n\t\t\t$old = $auditLog->_getState('update_site_option_active_sitewide_plugins.old', 0);\n\t\t\tif (!is_array($old) || !count($old)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t$new = $auditLog->_getState('update_site_option_active_sitewide_plugins.new', 0);\n\t\t\t$diff = wfUtils::array_diff($old, $new);\n\t\t\t$auditLog->_recordAction(self::MULTISITE_NETWORK_OPTION_ACTIVE_PLUGINS, array('plugins' => $new, 'diff' => $diff));\n\t\t});\n\t}\n}"},{"base":"plugins","rel":"wordfence\/lib\/audit-log\/wfAuditLogObserversWordfence.php","ext":"php","size":33373,"mtime":1757312769,"type":"text","content":"<?php\n\nabstract class wfAuditLogObserversWordfence extends wfAuditLog {\n\tconst WORDFENCE_WAF_MODE_CHANGED = 'wordfence.waf.mode.changed';\n\tconst WORDFENCE_WAF_RULE_STATUS_CHANGED = 'wordfence.waf.rule-status.changed';\n\tconst WORDFENCE_WAF_PROTECTION_LEVEL_CHANGED = 'wordfence.waf.protection-level.changed';\n\tconst WORDFENCE_WAF_ALLOW_ENTRY_CREATED = 'wordfence.waf.allow-entry.created';\n\tconst WORDFENCE_WAF_ALLOW_ENTRY_DELETED = 'wordfence.waf.allow-entry.deleted';\n\tconst WORDFENCE_WAF_ALLOW_ENTRY_TOGGLED = 'wordfence.waf.allow-entry.toggled';\n\tconst WORDFENCE_WAF_BLOCKLIST_TOGGLED = 'wordfence.waf.blocklist.toggled';\n\t\n\tconst WORDFENCE_ALLOWED_IPS_UPDATED = 'wordfence.allowed-ips.updated';\n\tconst WORDFENCE_ALLOWED_SERVICES_UPDATED = 'wordfence.allowed-services.updated';\n\tconst WORDFENCE_ALLOWED_404S_UPDATED = 'wordfence.allowed-404.updated';\n\tconst WORDFENCE_IGNORED_ALERT_IPS_UPDATED = 'wordfence.ignored-alert-ips.updated';\n\t\n\tconst WORDFENCE_BANNED_URLS_UPDATED = 'wordfence.banned-urls.updated';\n\tconst WORDFENCE_BANNED_USERNAMES_UPDATED = 'wordfence.banned-usernames.updated';\n\t\n\tconst WORDFENCE_BRUTE_FORCE_TOGGLED = 'wordfence.brute-force.toggled';\n\tconst WORDFENCE_GENERAL_RATE_LIMITING_BLOCKING_TOGGLED = 'wordfence.general-rate-limiting-blocking.toggled';\n\tconst WORDFENCE_NEVER_BLOCK_CRAWLERS_CHANGED = 'wordfence.never-block-crawlers.changed';\n\tconst WORDFENCE_LOCKOUT_INVALID_TOGGLED = 'wordfence.lock-out-invalid.toggled';\n\tconst WORDFENCE_BREACHED_PASSWORDS_TOGGLED = 'wordfence.breached-passwords.toggled';\n\tconst WORDFENCE_ENFORCE_STRONG_PASSWORDS_TOGGLED = 'wordfence.enforce-strong-passwords.toggled';\n\tconst WORDFENCE_MASK_LOGIN_ERRORS_TOGGLED = 'wordfence.mask-login-errors.toggled';\n\tconst WORDFENCE_PREVENT_ADMIN_USERNAME_TOGGLED = 'wordfence.prevent-admin-username.toggled';\n\tconst WORDFENCE_BLOCK_AUTHOR_SCAN_TOGGLED = 'wordfence.block-author-scan.toggled';\n\tconst WORDFENCE_PREVENT_APPLICATION_PASSWORDS_TOGGLED = 'wordfence.prevent-application-passwords.toggled';\n\tconst WORDFENCE_BLOCK_BAD_POST_TOGGLED = 'wordfence.block-bad-post.toggled';\n\tconst WORDFENCE_CHANGE_PASSWORD_CHECK_STRENGTH_TOGGLED = 'wordfence.change-password-check-strength.toggled';\n\t\n\tconst WORDFENCE_LOGIN_FAILURE_COUNT_UPDATED = 'wordfence.login-failure-count.updated';\n\tconst WORDFENCE_FORGOT_PASSWORD_COUNT_UPDATED = 'wordfence.forgot-password-count.updated';\n\tconst WORDFENCE_LOGIN_SECURITY_PERIOD_UPDATED = 'wordfence.login-security-period.updated';\n\tconst WORDFENCE_LOGIN_SECURITY_DURATION_UPDATED = 'wordfence.login-security-duration.updated';\n\tconst WORDFENCE_BLOCK_DURATION_UPDATED = 'wordfence.block-duration.updated';\n\t\n\tconst WORDFENCE_CUSTOM_BLOCK_TEXT_UPDATED = 'wordfence.custom-block-text.updated';\n\t\n\tconst WORDFENCE_RATE_LIMITS_GLOBAL_UPDATED = 'wordfence.rate-limits.global.updated';\n\tconst WORDFENCE_RATE_LIMITS_CRAWLER_UPDATED = 'wordfence.rate-limits.crawler.updated';\n\tconst WORDFENCE_RATE_LIMITS_CRAWLER_404_UPDATED = 'wordfence.rate-limits.crawler-404.updated';\n\tconst WORDFENCE_RATE_LIMITS_HUMAN_UPDATED = 'wordfence.rate-limits.human.updated';\n\tconst WORDFENCE_RATE_LIMITS_HUMAN_404_UPDATED = 'wordfence.rate-limits.human-404.updated';\n\t\n\tconst WORDFENCE_SCAN_OPTIONS_UPDATED = 'wordfence.scan.options.updated';\n\tconst WORDFENCE_SCAN_SCHEDULE_UPDATED = 'wordfence.scan.schedule.updated';\n\t\n\tconst WORDFENCE_BLOCKING_COUNTRY_UPDATED = 'wordfence.blocking.country.updated';\n\tconst WORDFENCE_BLOCKING_IP_PATTERN_CREATED = 'wordfence.blocking.ip-pattern.created';\n\tconst WORDFENCE_BLOCKING_DELETED = 'wordfence.blocking.deleted';\n\t\n\tconst WORDFENCE_PARTICIPATE_SECURITY_NETWORK_TOGGLED = 'wordfence.participate-security-network.toggled';\n\tconst WORDFENCE_AUDIT_LOG_MODE_CHANGED = 'wordfence.audit-log.mode.changed';\n\tconst WORDFENCE_LICENSE_KEY_CHANGED = 'wordfence.license-key.changed';\n\t\n\tconst WORDFENCE_IP_SOURCE_CHANGED = 'wordfence.ip-source.changed';\n\tconst WORDFENCE_TRUSTED_PROXIES_UPDATED = 'wordfence.trusted-proxies.updated';\n\tconst WORDFENCE_TRUSTED_PROXY_PRESET_CHANGED = 'wordfence.trusted-proxies-preset.changed';\n\t\n\tconst WORDFENCE_LS_2FA_DEACTIVATED = 'wordfence.ls.2fa.deactivated';\n\tconst WORDFENCE_LS_2FA_ACTIVATED = 'wordfence.ls.2fa.activated';\n\tconst WORDFENCE_LS_XML_RPC_REQUIRES_2FA_TOGGLED = 'wordfence.ls.xml-rpc-2fa.toggled';\n\tconst WORDFENCE_LS_ALLOWED_IPS_UPDATED = 'wordfence.ls.allowed-ips.updated';\n\tconst WORDFENCE_LS_IP_SOURCE_CHANGED = 'wordfence.ls.ip-source.changed';\n\tconst WORDFENCE_LS_TRUSTED_PROXIES_UPDATED = 'wordfence.ls.trusted-proxies.updated';\n\tconst WORDFENCE_LS_2FA_REQUIRED_CHANGED = 'wordfence.ls.2fa-required.changed';\n\tconst WORDFENCE_LS_2FA_GRACE_PERIOD_CHANGED = 'wordfence.ls.2fa-grace-period.changed';\n\tconst WORDFENCE_LS_XML_RPC_TOGGLED = 'wordfence.ls.xml-rpc-enabled.toggled';\n\tconst WORDFENCE_LS_CAPTCHA_TOGGLED = 'wordfence.ls.captcha-enabled.toggled';\n\tconst WORDFENCE_LS_CAPTCHA_THRESHOLD_CHANGED = 'wordfence.ls.captcha-threshold.changed';\n\tconst WORDFENCE_LS_WOOCOMMERCE_INTEGRATION_TOGGLED = 'wordfence.ls.woocommerce-enabled.toggled';\n\tconst WORDFENCE_LS_CAPTCHA_TEST_MODE_TOGGLED = 'wordfence.ls.captcha-test-mode.toggled';\n\t\n\tpublic static function immediateSendEvents() {\n\t\treturn array(\n\t\t\tself::WORDFENCE_WAF_MODE_CHANGED,\n\t\t\tself::WORDFENCE_WAF_PROTECTION_LEVEL_CHANGED,\n\t\t\tself::WORDFENCE_WAF_BLOCKLIST_TOGGLED,\n\t\t\tself::WORDFENCE_PARTICIPATE_SECURITY_NETWORK_TOGGLED,\n\t\t\tself::WORDFENCE_AUDIT_LOG_MODE_CHANGED,\n\t\t\tself::WORDFENCE_LICENSE_KEY_CHANGED,\n\t\t);\n\t}\n\t\n\tpublic static function eventCategories() {\n\t\treturn array(\n\t\t\twfAuditLog::AUDIT_LOG_CATEGORY_SITE_SETTINGS => array(\n\t\t\t\tself::WORDFENCE_IGNORED_ALERT_IPS_UPDATED,\n\t\t\t\t\n\t\t\t\tself::WORDFENCE_PREVENT_ADMIN_USERNAME_TOGGLED,\n\t\t\t\t\n\t\t\t\tself::WORDFENCE_CUSTOM_BLOCK_TEXT_UPDATED,\n\t\t\t\t\n\t\t\t\tself::WORDFENCE_SCAN_OPTIONS_UPDATED,\n\t\t\t\tself::WORDFENCE_SCAN_SCHEDULE_UPDATED,\n\t\t\t\t\n\t\t\t\tself::WORDFENCE_PARTICIPATE_SECURITY_NETWORK_TOGGLED,\n\t\t\t\tself::WORDFENCE_AUDIT_LOG_MODE_CHANGED,\n\t\t\t\tself::WORDFENCE_LICENSE_KEY_CHANGED,\n\t\t\t\t\n\t\t\t\tself::WORDFENCE_IP_SOURCE_CHANGED,\n\t\t\t\tself::WORDFENCE_TRUSTED_PROXIES_UPDATED,\n\t\t\t\tself::WORDFENCE_TRUSTED_PROXY_PRESET_CHANGED,\n\t\t\t\t\n\t\t\t\tself::WORDFENCE_LS_IP_SOURCE_CHANGED,\n\t\t\t\tself::WORDFENCE_LS_TRUSTED_PROXIES_UPDATED,\n\t\t\t\tself::WORDFENCE_LS_WOOCOMMERCE_INTEGRATION_TOGGLED,\n\t\t\t),\n\t\t\twfAuditLog::AUDIT_LOG_CATEGORY_AUTHENTICATION => array(\n\t\t\t\tself::WORDFENCE_LS_2FA_DEACTIVATED,\n\t\t\t\tself::WORDFENCE_LS_2FA_ACTIVATED,\n\t\t\t\t\n\t\t\t\tself::WORDFENCE_ENFORCE_STRONG_PASSWORDS_TOGGLED,\n\t\t\t\tself::WORDFENCE_MASK_LOGIN_ERRORS_TOGGLED,\n\t\t\t\tself::WORDFENCE_PREVENT_APPLICATION_PASSWORDS_TOGGLED,\n\t\t\t\tself::WORDFENCE_CHANGE_PASSWORD_CHECK_STRENGTH_TOGGLED,\n\t\t\t\t\n\t\t\t\tself::WORDFENCE_LS_XML_RPC_REQUIRES_2FA_TOGGLED,\n\t\t\t\tself::WORDFENCE_LS_ALLOWED_IPS_UPDATED,\n\t\t\t\tself::WORDFENCE_LS_2FA_REQUIRED_CHANGED,\n\t\t\t\tself::WORDFENCE_LS_2FA_GRACE_PERIOD_CHANGED,\n\t\t\t),\n\t\t\twfAuditLog::AUDIT_LOG_CATEGORY_FIREWALL => array(\n\t\t\t\tself::WORDFENCE_WAF_MODE_CHANGED,\n\t\t\t\tself::WORDFENCE_WAF_RULE_STATUS_CHANGED,\n\t\t\t\tself::WORDFENCE_WAF_PROTECTION_LEVEL_CHANGED,\n\t\t\t\tself::WORDFENCE_WAF_ALLOW_ENTRY_CREATED,\n\t\t\t\tself::WORDFENCE_WAF_ALLOW_ENTRY_DELETED,\n\t\t\t\tself::WORDFENCE_WAF_ALLOW_ENTRY_TOGGLED,\n\t\t\t\tself::WORDFENCE_WAF_BLOCKLIST_TOGGLED,\n\t\t\t\t\n\t\t\t\tself::WORDFENCE_ALLOWED_IPS_UPDATED,\n\t\t\t\tself::WORDFENCE_ALLOWED_SERVICES_UPDATED,\n\t\t\t\tself::WORDFENCE_ALLOWED_404S_UPDATED,\n\t\t\t\t\n\t\t\t\tself::WORDFENCE_BANNED_URLS_UPDATED,\n\t\t\t\tself::WORDFENCE_BANNED_USERNAMES_UPDATED,\n\t\t\t\t\n\t\t\t\tself::WORDFENCE_BRUTE_FORCE_TOGGLED,\n\t\t\t\tself::WORDFENCE_GENERAL_RATE_LIMITING_BLOCKING_TOGGLED,\n\t\t\t\tself::WORDFENCE_NEVER_BLOCK_CRAWLERS_CHANGED,\n\t\t\t\tself::WORDFENCE_LOCKOUT_INVALID_TOGGLED,\n\t\t\t\tself::WORDFENCE_BREACHED_PASSWORDS_TOGGLED,\n\t\t\t\tself::WORDFENCE_BLOCK_AUTHOR_SCAN_TOGGLED,\n\t\t\t\tself::WORDFENCE_BLOCK_BAD_POST_TOGGLED,\n\t\t\t\t\n\t\t\t\tself::WORDFENCE_LOGIN_FAILURE_COUNT_UPDATED,\n\t\t\t\tself::WORDFENCE_FORGOT_PASSWORD_COUNT_UPDATED,\n\t\t\t\tself::WORDFENCE_LOGIN_SECURITY_PERIOD_UPDATED,\n\t\t\t\tself::WORDFENCE_LOGIN_SECURITY_DURATION_UPDATED,\n\t\t\t\tself::WORDFENCE_BLOCK_DURATION_UPDATED,\n\t\t\t\t\n\t\t\t\tself::WORDFENCE_RATE_LIMITS_GLOBAL_UPDATED,\n\t\t\t\tself::WORDFENCE_RATE_LIMITS_CRAWLER_UPDATED,\n\t\t\t\tself::WORDFENCE_RATE_LIMITS_CRAWLER_404_UPDATED,\n\t\t\t\tself::WORDFENCE_RATE_LIMITS_HUMAN_UPDATED,\n\t\t\t\tself::WORDFENCE_RATE_LIMITS_HUMAN_404_UPDATED,\n\t\t\t\t\n\t\t\t\tself::WORDFENCE_BLOCKING_COUNTRY_UPDATED,\n\t\t\t\tself::WORDFENCE_BLOCKING_IP_PATTERN_CREATED,\n\t\t\t\tself::WORDFENCE_BLOCKING_DELETED,\n\t\t\t\t\n\t\t\t\tself::WORDFENCE_LS_XML_RPC_TOGGLED,\n\t\t\t\tself::WORDFENCE_LS_CAPTCHA_TOGGLED,\n\t\t\t\tself::WORDFENCE_LS_CAPTCHA_THRESHOLD_CHANGED,\n\t\t\t\tself::WORDFENCE_LS_CAPTCHA_TEST_MODE_TOGGLED,\n\t\t\t),\n\t\t);\n\t}\n\t\n\tpublic static function eventNames() {\n\t\treturn array(\n\t\t\tself::WORDFENCE_WAF_MODE_CHANGED => __('Wordfence WAF Mode Changed', 'wordfence'),\n\t\t\tself::WORDFENCE_WAF_RULE_STATUS_CHANGED => __('Wordfence WAF Rule Status Changed', 'wordfence'),\n\t\t\tself::WORDFENCE_WAF_PROTECTION_LEVEL_CHANGED => __('Wordfence WAF Protection Level Changed', 'wordfence'),\n\t\t\tself::WORDFENCE_WAF_ALLOW_ENTRY_CREATED => __('Wordfence WAF Allow Entry Created', 'wordfence'),\n\t\t\tself::WORDFENCE_WAF_ALLOW_ENTRY_DELETED => __('Wordfence WAF Allow Entry Deleted', 'wordfence'),\n\t\t\tself::WORDFENCE_WAF_ALLOW_ENTRY_TOGGLED => __('Wordfence WAF Allow Entry Toggled', 'wordfence'),\n\t\t\tself::WORDFENCE_WAF_BLOCKLIST_TOGGLED => __('Wordfence WAF Blocklist Toggled', 'wordfence'),\n\t\t\t\n\t\t\tself::WORDFENCE_ALLOWED_IPS_UPDATED => __('Allowlisted IPs Updated', 'wordfence'),\n\t\t\tself::WORDFENCE_ALLOWED_SERVICES_UPDATED => __('Allowlisted Services Updated', 'wordfence'),\n\t\t\tself::WORDFENCE_ALLOWED_404S_UPDATED => __('Allowed 404s Updated', 'wordfence'),\n\t\t\tself::WORDFENCE_IGNORED_ALERT_IPS_UPDATED => __('Ignored Alert IPs Updated', 'wordfence'),\n\t\t\t\n\t\t\tself::WORDFENCE_BANNED_URLS_UPDATED => __('Banned URLs Updated', 'wordfence'),\n\t\t\tself::WORDFENCE_BANNED_USERNAMES_UPDATED => __('Banned Usernames Updated', 'wordfence'),\n\t\t\t\n\t\t\tself::WORDFENCE_BRUTE_FORCE_TOGGLED => __('Brute Force Protection Toggled', 'wordfence'),\n\t\t\tself::WORDFENCE_GENERAL_RATE_LIMITING_BLOCKING_TOGGLED => __('General Blocking and Rate Limiting Toggled', 'wordfence'),\n\t\t\tself::WORDFENCE_NEVER_BLOCK_CRAWLERS_CHANGED => __('Never Block Crawlers Toggled', 'wordfence'),\n\t\t\tself::WORDFENCE_LOCKOUT_INVALID_TOGGLED => __('Lockout Invalid Users Toggled', 'wordfence'),\n\t\t\tself::WORDFENCE_BREACHED_PASSWORDS_TOGGLED => __('Prevent Use of Breached Passwords Toggled', 'wordfence'),\n\t\t\tself::WORDFENCE_ENFORCE_STRONG_PASSWORDS_TOGGLED => __('Enforce Strong Passwords Toggled', 'wordfence'),\n\t\t\tself::WORDFENCE_MASK_LOGIN_ERRORS_TOGGLED => __('Mask Login Errors Toggled', 'wordfence'),\n\t\t\tself::WORDFENCE_PREVENT_ADMIN_USERNAME_TOGGLED => __('Prevent Using \"admin\" Username Toggled', 'wordfence'),\n\t\t\tself::WORDFENCE_BLOCK_AUTHOR_SCAN_TOGGLED => __('Block Author Scanning Toggled', 'wordfence'),\n\t\t\tself::WORDFENCE_PREVENT_APPLICATION_PASSWORDS_TOGGLED => __('Prevent Use of Application Passwords Toggled', 'wordfence'),\n\t\t\tself::WORDFENCE_BLOCK_BAD_POST_TOGGLED => __('Block Bad POST Requests Toggled', 'wordfence'),\n\t\t\tself::WORDFENCE_CHANGE_PASSWORD_CHECK_STRENGTH_TOGGLED => __('Check Password Strength on Reset Toggled', 'wordfence'),\n\t\t\t\n\t\t\tself::WORDFENCE_LOGIN_FAILURE_COUNT_UPDATED => __('Failed Login Failure Threshold Updated', 'wordfence'),\n\t\t\tself::WORDFENCE_FORGOT_PASSWORD_COUNT_UPDATED => __('Forgot Password Threshold Updated', 'wordfence'),\n\t\t\tself::WORDFENCE_LOGIN_SECURITY_PERIOD_UPDATED => __('Login Security Counting Period Updated', 'wordfence'),\n\t\t\tself::WORDFENCE_LOGIN_SECURITY_DURATION_UPDATED => __('Login Security Lockout Threshold Updated', 'wordfence'),\n\t\t\tself::WORDFENCE_BLOCK_DURATION_UPDATED => __('Automatic Block Duration Updated', 'wordfence'),\n\t\t\t\n\t\t\tself::WORDFENCE_CUSTOM_BLOCK_TEXT_UPDATED => __('Custom Block Text Updated', 'wordfence'),\n\t\t\t\n\t\t\tself::WORDFENCE_RATE_LIMITS_GLOBAL_UPDATED => __('Global Rate Limit Settings Updated', 'wordfence'),\n\t\t\tself::WORDFENCE_RATE_LIMITS_CRAWLER_UPDATED => __('Crawler Rate Limit Settings Updated', 'wordfence'),\n\t\t\tself::WORDFENCE_RATE_LIMITS_CRAWLER_404_UPDATED => __('Crawler 404 Rate Limit Settings Updated', 'wordfence'),\n\t\t\tself::WORDFENCE_RATE_LIMITS_HUMAN_UPDATED => __('Human Rate Limit Settings Updated', 'wordfence'),\n\t\t\tself::WORDFENCE_RATE_LIMITS_HUMAN_404_UPDATED => __('Human 404 Rate Limit Settings Updated', 'wordfence'),\n\t\t\t\n\t\t\tself::WORDFENCE_SCAN_OPTIONS_UPDATED => __('Scan Options Updated', 'wordfence'),\n\t\t\tself::WORDFENCE_SCAN_SCHEDULE_UPDATED => __('Scan Schedule Updated', 'wordfence'),\n\t\t\t\n\t\t\tself::WORDFENCE_BLOCKING_COUNTRY_UPDATED => __('Country Blocking Updated', 'wordfence'),\n\t\t\tself::WORDFENCE_BLOCKING_IP_PATTERN_CREATED => __('Manual Block Created', 'wordfence'),\n\t\t\tself::WORDFENCE_BLOCKING_DELETED => __('Block Deleted', 'wordfence'),\n\t\t\t\n\t\t\tself::WORDFENCE_PARTICIPATE_SECURITY_NETWORK_TOGGLED => __('Participate in the Wordfence Security Network Toggled', 'wordfence'),\n\t\t\tself::WORDFENCE_AUDIT_LOG_MODE_CHANGED => __('Audit Log Mode Changed', 'wordfence'),\n\t\t\tself::WORDFENCE_LICENSE_KEY_CHANGED => __('License Key Changed', 'wordfence'),\n\t\t\t\n\t\t\tself::WORDFENCE_IP_SOURCE_CHANGED => __('IP Source Changed', 'wordfence'),\n\t\t\tself::WORDFENCE_TRUSTED_PROXIES_UPDATED => __('Trusted Proxies Updated', 'wordfence'),\n\t\t\tself::WORDFENCE_TRUSTED_PROXY_PRESET_CHANGED => __('Trusted Proxy Preset Changed', 'wordfence'),\n\t\t\t\n\t\t\tself::WORDFENCE_LS_2FA_DEACTIVATED => __('2FA Deactivated on User', 'wordfence'),\n\t\t\tself::WORDFENCE_LS_2FA_ACTIVATED => __('2FA Activated on User', 'wordfence'),\n\t\t\tself::WORDFENCE_LS_XML_RPC_REQUIRES_2FA_TOGGLED => __('XML-RPC Requires 2FA Toggled', 'wordfence'),\n\t\t\tself::WORDFENCE_LS_ALLOWED_IPS_UPDATED => __('IPs Bypassing 2FA Updated', 'wordfence'),\n\t\t\tself::WORDFENCE_LS_IP_SOURCE_CHANGED => __('IP Source Changed', 'wordfence'),\n\t\t\tself::WORDFENCE_LS_TRUSTED_PROXIES_UPDATED => __('Trusted Proxies Updated', 'wordfence'),\n\t\t\tself::WORDFENCE_LS_2FA_REQUIRED_CHANGED => __('2FA Role Requirements Changed', 'wordfence'),\n\t\t\tself::WORDFENCE_LS_2FA_GRACE_PERIOD_CHANGED => __('2FA Grace Period Changed', 'wordfence'),\n\t\t\tself::WORDFENCE_LS_XML_RPC_TOGGLED => __('XML-RPC Interface Toggled', 'wordfence'),\n\t\t\tself::WORDFENCE_LS_CAPTCHA_TOGGLED => __('Login Captcha Toggled', 'wordfence'),\n\t\t\tself::WORDFENCE_LS_CAPTCHA_THRESHOLD_CHANGED => __('reCAPTCHA Threshold Changed', 'wordfence'),\n\t\t\tself::WORDFENCE_LS_WOOCOMMERCE_INTEGRATION_TOGGLED => __('WooCommerce 2FA Integration Toggled', 'wordfence'),\n\t\t\tself::WORDFENCE_LS_CAPTCHA_TEST_MODE_TOGGLED => __('Captcha Test Mode Toggled', 'wordfence'),\n\t\t);\n\t}\n\t\n\tpublic static function eventRateLimiters() {\n\t\treturn array();\n\t}\n\t\n\t\/**\n\t * Registers the observers for this class's chunk of functionality that should run regardless of other settings.\n\t * These observers are expected to do their own check and application of settings like the audit log's mode or\n\t * the `Participate in the Wordfence Security Network` setting.\n\t *\n\t * @param wfAuditLog $auditLog\n\t *\/\n\tprotected static function _registerForcedObservers($auditLog) {\n\t\tif (!wfLicense::current()->isAtLeastPremium()) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t$auditLog->_addObserver('wordfence_changed_audit_log_mode', function($before, $after) use ($auditLog) { \/\/Audit log mode changed, run in all modes\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_AUDIT_LOG_MODE_CHANGED, array('before' => $before, 'after' => $after));\n\t\t});\n\t\t\n\t\tif ($auditLog->mode() == wfAuditLog::AUDIT_LOG_MODE_DISABLED) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t$auditLog->_addObserver('wordfence_toggled_participate_security_network', function($before, $after) use ($auditLog) { \/\/Participate WFSN toggled, always send if audit log enabled\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_PARTICIPATE_SECURITY_NETWORK_TOGGLED, array('state' => $after));\n\t\t});\n\t}\n\t\n\t\/**\n\t * Registers the observers for this class's chunk of functionality.\n\t * \n\t * @param wfAuditLog $auditLog\n\t *\/\n\tprotected static function _registerObservers($auditLog) {\n\t\t\/\/WAF\n\t\t$auditLog->_addObserver('wordfence_waf_mode', function($before, $after) use ($auditLog) { \/\/WAF mode setting changed\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_WAF_MODE_CHANGED, array('before' => $before, 'after' => $after));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_waf_changed_rule_status', function($changes) use ($auditLog) { \/\/WAF rule mode(s) changed\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_WAF_RULE_STATUS_CHANGED, $changes);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_waf_changed_protection_level', function($before, $after) use ($auditLog) { \/\/WAF protection level changed\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_WAF_PROTECTION_LEVEL_CHANGED, array('before' => $before, 'after' => $after));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_waf_created_allow_entry', function($entries) use ($auditLog) { \/\/WAF allow entry created\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_WAF_ALLOW_ENTRY_CREATED, array('added' => $entries));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_waf_deleted_allow_entry', function($entries) use ($auditLog) { \/\/WAF allow entry deleted\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_WAF_ALLOW_ENTRY_DELETED, array('deleted' => $entries));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_waf_toggled_allow_entry', function($entries) use ($auditLog) { \/\/WAF allow entry toggled\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_WAF_ALLOW_ENTRY_TOGGLED, array('toggled' => $entries));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_waf_toggled_blocklist', function($before, $after) use ($auditLog) { \/\/WAF blocklist toggled on\/off\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_WAF_BLOCKLIST_TOGGLED, array('state' => $after));\n\t\t});\n\t\t\n\t\t\/\/Allowed\/ignored\n\t\t$auditLog->_addObserver('wordfence_updated_allowed_ips', function($before, $after) use ($auditLog) { \/\/Allowed IP list changed, only care about additions\n\t\t\t$changes = wfUtils::array_diff($before, $after);\n\t\t\tif (!empty($changes['added'])) {\n\t\t\t\t$auditLog->_recordAction(self::WORDFENCE_ALLOWED_IPS_UPDATED, array('added' => $changes['added']));\n\t\t\t}\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_updated_allowed_services', function($before, $after) use ($auditLog) { \/\/Allowed services list changed, only care about additions\n\t\t\t$resolvedBefore = wfUtils::whitelistedServiceIPs($before);\n\t\t\t$resolvedAfter = wfUtils::whitelistedServiceIPs($after);\n\t\t\t$changes = wfUtils::array_diff(array_keys($resolvedBefore), array_keys($resolvedAfter));\n\t\t\tif (!empty($changes['added'])) {\n\t\t\t\t$auditLog->_recordAction(self::WORDFENCE_ALLOWED_SERVICES_UPDATED, array('added' => $changes['added']));\n\t\t\t}\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_updated_allowed_404', function($before, $after) use ($auditLog) { \/\/Allowed 404 list changed, only care about additions\n\t\t\t$changes = wfUtils::array_diff($before, $after);\n\t\t\tif (!empty($changes['added'])) {\n\t\t\t\t$auditLog->_recordAction(self::WORDFENCE_ALLOWED_404S_UPDATED, array('added' => $changes['added']));\n\t\t\t}\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_updated_ignored_alert_ips', function($before, $after) use ($auditLog) { \/\/Ignored alert IP list changed, only care about additions\n\t\t\t$changes = wfUtils::array_diff($before, $after);\n\t\t\tif (!empty($changes['added'])) {\n\t\t\t\t$auditLog->_recordAction(self::WORDFENCE_IGNORED_ALERT_IPS_UPDATED, array('added' => $changes['added']));\n\t\t\t}\n\t\t});\n\t\t\n\t\t\/\/Banned\/prohibited\n\t\t$auditLog->_addObserver('wordfence_updated_banned_urls', function($before, $after) use ($auditLog) { \/\/Banned URL list changed, only care about removals\n\t\t\t$changes = wfUtils::array_diff($before, $after);\n\t\t\tif (!empty($changes['removed'])) {\n\t\t\t\t$auditLog->_recordAction(self::WORDFENCE_BANNED_URLS_UPDATED, array('removed' => $changes['removed']));\n\t\t\t}\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_updated_banned_usernames', function($before, $after) use ($auditLog) { \/\/Banned username list changed, only care about removals\n\t\t\t$changes = wfUtils::array_diff($before, $after);\n\t\t\tif (!empty($changes['removed'])) {\n\t\t\t\t$auditLog->_recordAction(self::WORDFENCE_BANNED_USERNAMES_UPDATED, array('removed' => $changes['removed']));\n\t\t\t}\n\t\t});\n\t\t\n\t\t\/\/General blocking\/brute force\n\t\t$auditLog->_addObserver('wordfence_toggled_brute_force_protection', function($before, $after) use ($auditLog) { \/\/Brute force protection toggled on\/off\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_BRUTE_FORCE_TOGGLED, array('state' => $after));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_toggled_general_rate_limiting_blocking', function($before, $after) use ($auditLog) { \/\/General rate limiting and blocking toggled on\/off\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_GENERAL_RATE_LIMITING_BLOCKING_TOGGLED, array('state' => $after));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_toggled_never_block_crawlers', function($before, $after) use ($auditLog) { \/\/Never block crawlers changed\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_NEVER_BLOCK_CRAWLERS_CHANGED, array('before' => $before, 'after' => $after));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_toggled_lock_out_invalid', function($before, $after) use ($auditLog) { \/\/Lock out invalid usernames toggled on\/off\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_LOCKOUT_INVALID_TOGGLED, array('state' => $after));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_toggled_breached_password_protection', function($before, $after) use ($auditLog) { \/\/Breached password protection toggled on\/off\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_BREACHED_PASSWORDS_TOGGLED, array('state' => $after));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_toggled_enforce_strong_passwords', function($before, $after) use ($auditLog) { \/\/Enforce strong passwords toggled on\/off\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_ENFORCE_STRONG_PASSWORDS_TOGGLED, array('state' => $after));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_toggled_mask_login_errors', function($before, $after) use ($auditLog) { \/\/Mask login errors toggled on\/off\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_MASK_LOGIN_ERRORS_TOGGLED, array('state' => $after));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_toggled_prevent_admin_username', function($before, $after) use ($auditLog) { \/\/Prevent using \"admin\" username toggled on\/off\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_PREVENT_ADMIN_USERNAME_TOGGLED, array('state' => $after));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_toggled_block_author_scan', function($before, $after) use ($auditLog) { \/\/Block author scan toggled on\/off\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_BLOCK_AUTHOR_SCAN_TOGGLED, array('state' => $after));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_toggled_prevent_application_passwords', function($before, $after) use ($auditLog) { \/\/Prevent use of application passwords toggled on\/off\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_PREVENT_APPLICATION_PASSWORDS_TOGGLED, array('state' => $after));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_toggled_block_bad_post', function($before, $after) use ($auditLog) { \/\/Block bad POST requests toggled on\/off\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_BLOCK_BAD_POST_TOGGLED, array('state' => $after));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_toggled_change_password_check_strength', function($before, $after) use ($auditLog) { \/\/Check strength on password change toggled on\/off\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_CHANGE_PASSWORD_CHECK_STRENGTH_TOGGLED, array('state' => $after));\n\t\t});\n\t\t\n\t\t\/\/Thresholds\/Durations\n\t\t$auditLog->_addObserver('wordfence_updated_login_failure_count', function($before, $after) use ($auditLog) { \/\/Login failure count before lockout\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_LOGIN_FAILURE_COUNT_UPDATED, array('before' => $before, 'after' => $after));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_updated_forgot_password_count', function($before, $after) use ($auditLog) { \/\/Forgot password request count before lockout\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_FORGOT_PASSWORD_COUNT_UPDATED, array('before' => $before, 'after' => $after));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_updated_login_security_period', function($before, $after) use ($auditLog) { \/\/Count failures over this period\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_LOGIN_SECURITY_PERIOD_UPDATED, array('before' => $before, 'after' => $after));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_updated_login_security_duration', function($before, $after) use ($auditLog) { \/\/Duration of lockout\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_LOGIN_SECURITY_DURATION_UPDATED, array('before' => $before, 'after' => $after));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_updated_block_duration', function($before, $after) use ($auditLog) { \/\/Rate limit block\/lockout duration\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_BLOCK_DURATION_UPDATED, array('before' => $before, 'after' => $after));\n\t\t});\n\t\t\n\t\t\/\/Custom text\n\t\t$auditLog->_addObserver('wordfence_updated_custom_block_text', function($before, $after) use ($auditLog) { \/\/Custom block text\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_CUSTOM_BLOCK_TEXT_UPDATED, array('before' => $before, 'after' => $after));\n\t\t});\n\t\t\n\t\t\/\/Rate limits\n\t\t$auditLog->_addObserver('wordfence_updated_max_global_requests', function($before, $after) use ($auditLog) { \/\/Global rate limit\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_RATE_LIMITS_GLOBAL_UPDATED, array('before' => $before, 'after' => $after));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_updated_max_crawler_requests', function($before, $after) use ($auditLog) { \/\/Crawler rate limit\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_RATE_LIMITS_CRAWLER_UPDATED, array('before' => $before, 'after' => $after));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_updated_max_crawler_404', function($before, $after) use ($auditLog) { \/\/Crawler 404 rate limit\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_RATE_LIMITS_CRAWLER_404_UPDATED, array('before' => $before, 'after' => $after));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_updated_max_human_requests', function($before, $after) use ($auditLog) { \/\/Human rate limit\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_RATE_LIMITS_HUMAN_UPDATED, array('before' => $before, 'after' => $after));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_updated_max_human_404', function($before, $after) use ($auditLog) { \/\/Human 404 rate limit\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_RATE_LIMITS_HUMAN_404_UPDATED, array('before' => $before, 'after' => $after));\n\t\t});\n\t\t\n\t\t\/\/Scan\n\t\t$auditLog->_addObserver('wordfence_updated_scan_options', function($before, $after) use ($auditLog) { \/\/Scan options\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_SCAN_OPTIONS_UPDATED, array('before' => $before, 'after' => $after));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_updated_scan_schedule', function($before, $after) use ($auditLog) { \/\/Scan schedule\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_SCAN_SCHEDULE_UPDATED, array('before' => $before, 'after' => $after));\n\t\t});\n\t\n\t\t\/\/Custom blocking\n\t\t$auditLog->_addObserver('wordfence_updated_country_blocking', function($before, $after) use ($auditLog) { \/\/Country block changed\n\t\t\t$diff = wfUtils::array_diff($before, $after);\n\t\t\tif (!empty($diff['added']) || !empty($diff['removed'])) {\n\t\t\t\t$auditLog->_recordAction(self::WORDFENCE_BLOCKING_COUNTRY_UPDATED, array('before' => $before, 'after' => $after));\n\t\t\t}\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_created_ip_pattern_block', function($type, $reason, $parameters) use ($auditLog) { \/\/IP or Pattern block created manually\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_BLOCKING_IP_PATTERN_CREATED, array('type' => $type, 'reason' => $reason, 'parameters' => $parameters));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_deleted_block', function($type, $reason, $parameters) use ($auditLog) { \/\/Block deleted manually\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_BLOCKING_DELETED, array('type' => $type, 'reason' => $reason, 'parameters' => $parameters));\n\t\t});\n\t\t\n\t\t\/\/Core functionality\n\t\t$auditLog->_addObserver('wordfence_changed_license_key', function($before, $after) use ($auditLog) { \/\/License key changed\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_LICENSE_KEY_CHANGED, array('before' => $before, 'after' => $after));\n\t\t});\n\t\t\n\t\t\/\/IP resolution\n\t\t$auditLog->_addObserver('wordfence_changed_ip_source', function($before, $after) use ($auditLog) { \/\/IP source changed\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_IP_SOURCE_CHANGED, array('before' => $before, 'after' => $after));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_updated_trusted_proxies', function($before, $after) use ($auditLog) { \/\/Trusted proxy list changed\n\t\t\t$changes = wfUtils::array_diff($before, $after);\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_TRUSTED_PROXIES_UPDATED, array('changes' => $changes));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_changed_trusted_proxy_preset', function($before, $after) use ($auditLog) { \/\/Trusted proxy preset selection changed\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_TRUSTED_PROXY_PRESET_CHANGED, array('before' => $before, 'after' => $after));\n\t\t});\n\t\t\n\t\t\/\/Login Security\n\t\t$auditLog->_addObserver('wordfence_ls_2fa_deactivated', function($user) use ($auditLog) { \/\/2FA deactivated on a user\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_LS_2FA_DEACTIVATED, $auditLog->_sanitizeUserdata($user));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_ls_2fa_activated', function($user) use ($auditLog) { \/\/2FA activated on a user\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_LS_2FA_ACTIVATED, $auditLog->_sanitizeUserdata($user));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_ls_xml_rpc_2fa_toggled', function($before, $after) use ($auditLog) { \/\/2FA required for XML-RPC calls\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_LS_XML_RPC_REQUIRES_2FA_TOGGLED, array('state' => $after));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_ls_updated_allowed_ips', function($before, $after) use ($auditLog) { \/\/Ignored 2FA IP list changed\n\t\t\t$changes = wfUtils::array_diff($before, $after);\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_LS_ALLOWED_IPS_UPDATED, array('changes' => $changes));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_ls_changed_ip_source', function($before, $after) use ($auditLog) { \/\/IP source changed (WFLS only)\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_LS_IP_SOURCE_CHANGED, array('before' => $before, 'after' => $after));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_ls_updated_trusted_proxies', function($before, $after) use ($auditLog) { \/\/Trusted proxy list changed (WFLS only)\n\t\t\t$changes = wfUtils::array_diff($before, $after);\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_LS_TRUSTED_PROXIES_UPDATED, array('changes' => $changes));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_ls_changed_grace_period', function($before, $after) use ($auditLog) { \/\/2FA grace period changed\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_LS_2FA_GRACE_PERIOD_CHANGED, array('before' => $before, 'after' => $after));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_ls_xml_rpc_enabled_toggled', function($before, $after) use ($auditLog) { \/\/XML-RPC enabled\/disabled\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_LS_XML_RPC_TOGGLED, array('state' => $after));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_ls_captcha_enabled_toggled', function($before, $after) use ($auditLog) { \/\/Captcha enabled\/disabled\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_LS_CAPTCHA_TOGGLED, array('state' => $after));\n\t\t});\n\n\t\t$auditLog->_addObserver('wordfence_ls_captcha_threshold_changed', function($before, $after) use ($auditLog) { \/\/Captcha threshold changed\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_LS_CAPTCHA_THRESHOLD_CHANGED, array('before' => $before, 'after' => $after));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_ls_woocommerce_enabled_toggled', function($before, $after) use ($auditLog) { \/\/WooCommerce integration enabled\/disabled\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_LS_WOOCOMMERCE_INTEGRATION_TOGGLED, array('state' => $after));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_ls_captcha_test_mode_toggled', function($before, $after) use ($auditLog) { \/\/Captcha test mode enabled\/disabled\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_LS_CAPTCHA_TEST_MODE_TOGGLED, array('state' => $after));\n\t\t});\n\t}\n\t\n\t\/**\n\t * Registers the data gatherers for this class's chunk of functionality.\n\t *\n\t * @param wfAuditLog $auditLog\n\t *\/\n\tprotected static function _registerDataGatherers($auditLog) {\n\t\t$auditLog->_addObserver('wordfence_ls_changed_2fa_required', function($role, $value) use ($auditLog) { \/\/2FA requirement changed on a role\n\t\t\tif (!$auditLog->_hasState('wordfence_ls_changed_2fa_required.changes', 0)) {\n\t\t\t\t$auditLog->_trackState('wordfence_ls_changed_2fa_required.changes', array(), 0);\n\t\t\t}\n\t\t\t\n\t\t\t$state = $auditLog->_getState('wordfence_ls_changed_2fa_required.changes', 0);\n\t\t\t$state[$role] = $value;\n\t\t\t$auditLog->_trackState('wordfence_ls_changed_2fa_required.changes', $state, 0);\n\t\t\t\n\t\t\t$auditLog->_needsDestruct();\n\t\t});\n\t}\n\t\n\t\/**\n\t * Registers the coalescers for this class's chunk of functionality.\n\t *\n\t * @param wfAuditLog $auditLog\n\t *\/\n\tprotected static function _registerCoalescers($auditLog) {\n\t\t$auditLog->_addCoalescer(function() use ($auditLog) { \/\/Network active plugins changed\n\t\t\t$changes = $auditLog->_getState('wordfence_ls_changed_2fa_required.changes', 0);\n\t\t\tif (!is_array($changes) || !count($changes)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t$auditLog->_recordAction(self::WORDFENCE_LS_2FA_REQUIRED_CHANGED, array('changes' => $changes));\n\t\t});\n\t}\n}"},{"base":"plugins","rel":"wordfence\/lib\/audit-log\/wfAuditLogObserversWordPressCoreContent.php","ext":"php","size":18212,"mtime":1757312769,"type":"text","content":"<?php\n\nabstract class wfAuditLogObserversWordPressCoreContent extends wfAuditLog {\n\t\/\/Attachments\n\tconst ATTACHMENT_CREATED = 'attachment.created';\n\tconst ATTACHMENT_DELETED = 'attachment.deleted';\n\tconst ATTACHMENT_UPDATED = 'attachment.updated';\n\t\n\t\/\/Pages\n\tconst PAGE_CREATED = 'page.created';\n\tconst PAGE_DELETED = 'page.deleted';\n\tconst PAGE_UPDATED = 'page.updated';\n\t\n\tconst PAGE_MARK_TRASHED = 'page.mark-trashed';\n\tconst PAGE_UNMARK_TRASHED = 'page.unmark-trashed';\n\t\n\t\/\/Posts\n\tconst POST_CREATED = 'post.created';\n\tconst POST_DELETED = 'post.deleted';\n\tconst POST_UPDATED = 'post.updated';\n\t\n\tconst POST_MARK_TRASHED = 'post.mark-trashed';\n\tconst POST_UNMARK_TRASHED = 'post.unmark-trashed';\n\t\n\t\n\tconst WP_POST_TYPE_POST = 'post';\n\tconst WP_POST_TYPE_PAGE = 'page';\n\tconst WP_POST_TYPE_REVISION = 'revision';\n\tconst WP_POST_TYPE_ATTACHMENT = 'attachment';\n\tconst WP_POST_TYPE_NAV_MENU_ITEM = 'nav_menu_item';\n\tconst WP_POST_TYPE_THEME_CUSTOMIZATION = 'customize_changeset';\n\t\n\tconst WP_POST_STATUS_AUTO_DRAFT = 'auto-draft';\n\t\n\t\n\tpublic static function immediateSendEvents() {\n\t\treturn array();\n\t}\n\t\n\tpublic static function eventCategories() {\n\t\treturn array(\n\t\t\twfAuditLog::AUDIT_LOG_CATEGORY_CONTENT => array(\n\t\t\t\tself::ATTACHMENT_CREATED,\n\t\t\t\tself::ATTACHMENT_DELETED,\n\t\t\t\tself::ATTACHMENT_UPDATED,\n\t\t\t\t\n\t\t\t\tself::PAGE_CREATED,\n\t\t\t\tself::PAGE_DELETED,\n\t\t\t\tself::PAGE_UPDATED,\n\t\t\t\t\n\t\t\t\tself::PAGE_MARK_TRASHED,\n\t\t\t\tself::PAGE_UNMARK_TRASHED,\n\t\t\t\t\n\t\t\t\tself::POST_CREATED,\n\t\t\t\tself::POST_DELETED,\n\t\t\t\tself::POST_UPDATED,\n\t\t\t\t\n\t\t\t\tself::POST_MARK_TRASHED,\n\t\t\t\tself::POST_UNMARK_TRASHED,\n\t\t\t),\n\t\t);\n\t}\n\t\n\tpublic static function eventNames() {\n\t\treturn array(\n\t\t\tself::ATTACHMENT_CREATED => __('Attachment Created', 'wordfence'),\n\t\t\tself::ATTACHMENT_DELETED => __('Attachment Deleted', 'wordfence'),\n\t\t\tself::ATTACHMENT_UPDATED => __('Attachment Updated', 'wordfence'),\n\t\t\t\n\t\t\t\/\/Pages\n\t\t\tself::PAGE_CREATED => __('Page Created', 'wordfence'),\n\t\t\tself::PAGE_DELETED => __('Page Deleted', 'wordfence'),\n\t\t\tself::PAGE_UPDATED => __('Page Updated', 'wordfence'),\n\t\t\t\n\t\t\tself::PAGE_MARK_TRASHED => __('Page Moved to Trash', 'wordfence'),\n\t\t\tself::PAGE_UNMARK_TRASHED => __('Page Removed from Trash', 'wordfence'),\n\t\t\t\n\t\t\t\/\/Posts\n\t\t\tself::POST_CREATED => __('Post Created', 'wordfence'),\n\t\t\tself::POST_DELETED => __('Post Deleted', 'wordfence'),\n\t\t\tself::POST_UPDATED => __('Post Updated', 'wordfence'),\n\t\t\t\n\t\t\tself::POST_MARK_TRASHED => __('Post Moved to Trash', 'wordfence'),\n\t\t\tself::POST_UNMARK_TRASHED => __('Post Removed from Trash', 'wordfence'),\n\t\t);\n\t}\n\t\n\tpublic static function eventRateLimiters() {\n\t\treturn array();\n\t}\n\t\n\t\/**\n\t * Registers the observers for this class's chunk of functionality.\n\t * \n\t * @param wfAuditLog $auditLog\n\t *\/\n\tprotected static function _registerObservers($auditLog) {\n\t\tif ($auditLog->mode() != self::AUDIT_LOG_MODE_ALL) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t\/\/Attachments\n\t\t$auditLog->_addObserver('add_attachment', function($post_id) use ($auditLog) { \/\/Attachment created\n\t\t\t$post = get_post($post_id);\n\t\t\t$auditLog->_recordAction(self::ATTACHMENT_CREATED, $auditLog->_sanitizePost($post));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('attachment_updated', function($post_id, $post_after, $post_before) use ($auditLog) { \/\/Attachment updated\n\t\t\t$changes = array_keys($auditLog->_postDiff($post_before, $post_after));\n\t\t\tif (!$auditLog->_shouldRecordPostChanges($changes)) { \/\/No meaningful changes to the record itself, skip this entry\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t$auditLog->_recordAction(self::ATTACHMENT_UPDATED, array_merge(array(\n\t\t\t\t'changes' => $changes,\n\t\t\t), $auditLog->_sanitizePost($post_after)));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('delete_attachment', function($post_id, $post = null \/* WP >= 5.5 *\/) use ($auditLog) { \/\/Attachment deleted\n\t\t\tif ($post === null) {\n\t\t\t\t$post = get_post($post_id);\n\t\t\t}\n\t\t\t$auditLog->_recordAction(self::ATTACHMENT_DELETED, $auditLog->_sanitizePost($post));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('rest_after_insert_attachment', function($attachment, $request, $creating) use ($auditLog) { \/\/Attachment added\/updated via REST API, data already populated\n\t\t\t$auditLog->_recordAction($creating ? self::ATTACHMENT_CREATED : self::ATTACHMENT_UPDATED, array(\n\t\t\t\t'source' => 'REST',\n\t\t\t), true);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('rest_insert_attachment', function($attachment, $request, $creating) use ($auditLog) { \/\/Attachment added\/updated via REST API, data already populated\n\t\t\t$auditLog->_recordAction($creating ? self::ATTACHMENT_CREATED : self::ATTACHMENT_UPDATED, array(\n\t\t\t\t'source' => 'REST',\n\t\t\t), true);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('xmlrpc_call_success_mw_newMediaObject', function($id) use ($auditLog) { \/\/Attachment added via XML-RPC API, data already populated\n\t\t\t$auditLog->_recordAction(self::ATTACHMENT_CREATED, array(\n\t\t\t\t'source' => 'XMLRPC',\n\t\t\t), true);\n\t\t});\n\t\t\n\t\t\/\/Post\/Page\n\t\t$auditLog->_addObserver('wp_insert_post', function($post_id, $post \/** @var WP_Post $post *\/, $update) use ($auditLog) { \/\/Post\/page created\n\t\t\tif (function_exists('wp_after_insert_post')) { \/\/WP >= 5.6, prefer that hook when present\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif ($post->post_type == self::WP_POST_TYPE_REVISION || $post->post_status == self::WP_POST_STATUS_AUTO_DRAFT || $post->post_type == self::WP_POST_TYPE_THEME_CUSTOMIZATION || $post->post_type == self::WP_POST_TYPE_NAV_MENU_ITEM) {\n\t\t\t\t\/\/Ignore -- covered by other actions\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif ($update) {\n\t\t\t\t$action = self::POST_UPDATED;\n\t\t\t\tif ($post->post_type == self::WP_POST_TYPE_PAGE) {\n\t\t\t\t\t$action = self::PAGE_UPDATED;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ($auditLog->_hasState('pre_post_update.post', $post_id)) {\n\t\t\t\t\t$before = $auditLog->_getState('pre_post_update.post', $post_id);\n\t\t\t\t\tif (isset($before->post_status) && $before->post_status == self::WP_POST_STATUS_AUTO_DRAFT) { \/\/Technically an update but really just converting the auto-draft into a populated post so call it a creation\n\t\t\t\t\t\t$action = self::POST_CREATED;\n\t\t\t\t\t\tif ($post->post_type == self::WP_POST_TYPE_PAGE) {\n\t\t\t\t\t\t\t$action = self::PAGE_CREATED;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$action = self::POST_CREATED;\n\t\t\t\tif ($post->post_type == self::WP_POST_TYPE_PAGE) {\n\t\t\t\t\t$action = self::PAGE_CREATED;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t$auditLog->_recordAction($action, $auditLog->_sanitizePost($post));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('post_updated', function($post_id, $post_after, $post_before) use ($auditLog) { \/\/Post\/page updated\n\t\t\tif (function_exists('wp_after_insert_post')) { \/\/WP >= 5.6, prefer that hook when present\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t$changes = array_keys($auditLog->_postDiff($post_before, $post_after));\n\t\t\tif (!$auditLog->_shouldRecordPostChanges($changes)) { \/\/No meaningful changes to the record itself, skip this entry\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif ($post_after->post_type == self::WP_POST_TYPE_REVISION || \/\/Ignore -- relevant revision changes will be captured when they're saved to the owning post record\n\t\t\t\t($post_before && $post_before->post_status == self::WP_POST_STATUS_AUTO_DRAFT) || $post_after->post_status == self::WP_POST_STATUS_AUTO_DRAFT || \/\/Not interested in these until they become a post \n\t\t\t\t$post_after->post_type == self::WP_POST_TYPE_THEME_CUSTOMIZATION || $post_after->post_type == self::WP_POST_TYPE_NAV_MENU_ITEM \/\/Not a type we care about\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t$auditLog->_recordAction($post_after->post_type == self::WP_POST_TYPE_PAGE ? self::PAGE_UPDATED : self::POST_UPDATED, array_merge(array(\n\t\t\t\t'changes' => $changes,\n\t\t\t), $auditLog->_sanitizePost($post_after)));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wp_after_insert_post' \/* WP >= 5.6 *\/, function($post_id, $_ignored, $update, $post_before \/** @var WP_Post $post_before *\/) use ($auditLog) { \/\/Post\/page created\n\t\t\t$post_after = get_post($post_id);\n\t\t\tif ($post_after->post_type == self::WP_POST_TYPE_REVISION || \/\/Ignore -- relevant revision changes will be captured when they're saved to the owning post record\n\t\t\t\t$post_after->post_status == self::WP_POST_STATUS_AUTO_DRAFT || \/\/Not interested in these until they become a permanent post \n\t\t\t\t$post_after->post_type == self::WP_POST_TYPE_THEME_CUSTOMIZATION || $post_after->post_type == self::WP_POST_TYPE_NAV_MENU_ITEM \/\/Not a type we care about\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t$changes = null;\n\t\t\tif ($post_before) {\n\t\t\t\t$changes = array_keys($auditLog->_postDiff($post_before, $post_after));\n\t\t\t\tif (!$auditLog->_shouldRecordPostChanges($changes)) { \/\/No meaningful changes to the record itself, skip this entry\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif ($update) {\n\t\t\t\t$action = self::POST_UPDATED;\n\t\t\t\tif ($post_after->post_type == self::WP_POST_TYPE_PAGE) {\n\t\t\t\t\t$action = self::PAGE_UPDATED;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ($auditLog->_hasState('pre_post_update.post', $post_id)) {\n\t\t\t\t\t$before = $auditLog->_getState('pre_post_update.post', $post_id);\n\t\t\t\t\tif (isset($before->post_status) && $before->post_status == self::WP_POST_STATUS_AUTO_DRAFT) { \/\/Technically an update but really just converting the auto-draft into a populated post so call it a creation\n\t\t\t\t\t\t$changes = null;\n\t\t\t\t\t\t$action = self::POST_CREATED;\n\t\t\t\t\t\tif ($post_after->post_type == self::WP_POST_TYPE_PAGE) {\n\t\t\t\t\t\t\t$action = self::PAGE_CREATED;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$action = self::POST_CREATED;\n\t\t\t\tif ($post_after->post_type == self::WP_POST_TYPE_PAGE) {\n\t\t\t\t\t$action = self::PAGE_CREATED;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t$payload = $auditLog->_sanitizePost($post_after);\n\t\t\tif ($changes) {\n\t\t\t\t$payload['changes'] = $changes;\n\t\t\t}\n\t\t\t\n\t\t\t$auditLog->_recordAction($action, $payload);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('rest_after_insert_page', function($page, $request, $creating) use ($auditLog) { \/\/Page created\/updated via REST API, data already populated\n\t\t\t$auditLog->_recordAction($creating ? self::PAGE_CREATED : self::PAGE_UPDATED, array(\n\t\t\t\t'source' => 'REST',\n\t\t\t), true);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('rest_after_insert_post', function($post, $request, $creating) use ($auditLog) { \/\/Post created\/updated via REST API, data already populated\n\t\t\t$auditLog->_recordAction($creating ? self::POST_CREATED : self::POST_UPDATED, array(\n\t\t\t\t'source' => 'REST',\n\t\t\t), true);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver(array('xmlrpc_call_success_blogger_newPost', 'xmlrpc_call_success_mw_newPost'), function($post_id) use ($auditLog) { \/\/Page\/Post added via XML-RPC API, data already populated\n\t\t\t$post = WP_Post::get_instance($post_id);\n\t\t\tif (!$post) { return; }\n\t\t\t$auditLog->_recordAction($post->post_type == self::WP_POST_TYPE_PAGE ? self::PAGE_CREATED : self::POST_CREATED, array(\n\t\t\t\t'source' => 'XMLRPC',\n\t\t\t), true);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('xmlrpc_call', function($action, $args = array() \/* WP >= 5.7 *\/) use ($auditLog) { \/\/Page\/Post action via XML-RPC API, data already populated\n\t\t\tswitch ($action) {\n\t\t\t\tcase 'wp.newPost':\n\t\t\t\t\tif (!empty($args)) { \/\/Not populated prior to WP 5.7 so omit this from the event (it will still record the rest, not not tagged as XML-RPC)\n\t\t\t\t\t\t$content_struct = $args[3];\n\t\t\t\t\t\tif (!isset($content_struct['post_type'])) { $content_struct['post_type'] = 'post'; } \/\/Apply the default\n\t\t\t\t\t\t$auditLog->_recordAction($content_struct['post_type'] == self::WP_POST_TYPE_PAGE ? self::PAGE_CREATED : self::POST_CREATED, array(\n\t\t\t\t\t\t\t'source' => 'XMLRPC',\n\t\t\t\t\t\t), true);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'wp.editPost':\n\t\t\t\t\tif (!empty($args)) { \/\/Not populated prior to WP 5.7 so omit this from the event (it will still record the rest, not not tagged as XML-RPC)\n\t\t\t\t\t\t$post_id = (int) $args[3];\n\t\t\t\t\t\t$post = WP_Post::get_instance($post_id);\n\t\t\t\t\t\tif (!$post) { return; }\n\t\t\t\t\t\t$auditLog->_recordAction($post->post_type == self::WP_POST_TYPE_PAGE ? self::PAGE_UPDATED : self::POST_UPDATED, array(\n\t\t\t\t\t\t\t'source' => 'XMLRPC',\n\t\t\t\t\t\t), true);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'wp.deletePost':\n\t\t\t\t\tif (!empty($args)) { \/\/Not populated prior to WP 5.7 so omit this from the event (it will still record the rest, not not tagged as XML-RPC)\n\t\t\t\t\t\t$post_id = (int) $args[3];\n\t\t\t\t\t\t$post = WP_Post::get_instance($post_id);\n\t\t\t\t\t\tif (!$post) { return; }\n\t\t\t\t\t\t$auditLog->_recordAction($post->post_type == self::WP_POST_TYPE_PAGE ? self::PAGE_DELETED : self::POST_DELETED, array(\n\t\t\t\t\t\t\t'source' => 'XMLRPC',\n\t\t\t\t\t\t), true);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'wp.newPage':\n\t\t\t\t\tif (!empty($args)) { \/\/Not populated prior to WP 5.7 so omit this from the event (it will still record the rest, not not tagged as XML-RPC)\n\t\t\t\t\t\t$content_struct = $args[3];\n\t\t\t\t\t\tif (!isset($content_struct['post_type'])) { $content_struct['post_type'] = 'post'; } \/\/Apply the default\n\t\t\t\t\t\t$auditLog->_recordAction($content_struct['post_type'] == self::WP_POST_TYPE_PAGE ? self::PAGE_CREATED : self::POST_CREATED, array(\n\t\t\t\t\t\t\t'source' => 'XMLRPC',\n\t\t\t\t\t\t), true);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'wp.editPage':\n\t\t\t\t\tif (!empty($args)) { \/\/Not populated prior to WP 5.7 so omit this from the event (it will still record the rest, not not tagged as XML-RPC)\n\t\t\t\t\t\t$post_id = (int) $args[1];\n\t\t\t\t\t\t$post = WP_Post::get_instance($post_id);\n\t\t\t\t\t\tif (!$post) { return; }\n\t\t\t\t\t\t$auditLog->_recordAction($post->post_type == self::WP_POST_TYPE_PAGE ? self::PAGE_UPDATED : self::POST_UPDATED, array(\n\t\t\t\t\t\t\t'source' => 'XMLRPC',\n\t\t\t\t\t\t), true);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'mt.publishPost':\n\t\t\t\t\tif (!empty($args)) { \/\/Not populated prior to WP 5.7 so omit this from the event (it will still record the rest, not not tagged as XML-RPC)\n\t\t\t\t\t\t$post_id = (int) $args[0];\n\t\t\t\t\t\t$post = WP_Post::get_instance($post_id);\n\t\t\t\t\t\tif (!$post) { return; }\n\t\t\t\t\t\t$auditLog->_recordAction($post->post_type == self::WP_POST_TYPE_PAGE ? self::PAGE_UPDATED : self::POST_UPDATED, array(\n\t\t\t\t\t\t\t'source' => 'XMLRPC',\n\t\t\t\t\t\t), true);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver(array('xmlrpc_call_success_blogger_editPost', 'xmlrpc_call_success_mw_editPost'), function($post_id) use ($auditLog) { \/\/Page\/Post updated via XML-RPC API, data already populated\n\t\t\t$post = WP_Post::get_instance($post_id);\n\t\t\tif (!$post) { return; }\n\t\t\t\n\t\t\t$auditLog->_recordAction($post->post_type == self::WP_POST_TYPE_PAGE ? self::PAGE_UPDATED : self::POST_UPDATED, array(\n\t\t\t\t'source' => 'XMLRPC',\n\t\t\t), true);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('deleted_post', function($post_id \/** @var WP_Post $post also passed in WP > 5.5 *\/) use ($auditLog) { \/\/Post\/page deleted -- WP wraps a lot of functionality under the post storage type, so there are multiple events covered here\n\t\t\tif (!$auditLog->_hasState('delete_post.post')) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t$action = self::POST_DELETED;\n\t\t\tif ($auditLog->_getState('delete_post.post')['type'] == self::WP_POST_TYPE_PAGE) {\n\t\t\t\t$action = self::PAGE_DELETED;\n\t\t\t}\n\t\t\t\n\t\t\t$auditLog->_recordAction($action, $auditLog->_getState('delete_post.post'));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver(array('xmlrpc_call_success_blogger_deletePost', 'xmlrpc_call_success_wp_deletePage'), function($post_id) use ($auditLog) { \/\/Page\/Post deleted via XML-RPC API, data already populated\n\t\t\tif (!$auditLog->_hasState('delete_post.post')) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t$auditLog->_recordAction($auditLog->_getState('delete_post.post')['type'] == self::WP_POST_TYPE_PAGE ? self::PAGE_CREATED : self::POST_CREATED, array(\n\t\t\t\t'source' => 'XMLRPC',\n\t\t\t), true);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('trashed_post', function($post_id) use ($auditLog) { \/\/Post\/page trashed\n\t\t\t$post = WP_Post::get_instance($post_id);\n\t\t\tif (!$post) { return; }\n\t\t\t\n\t\t\tif ($post->post_type == self::WP_POST_TYPE_REVISION || $post->post_type == self::WP_POST_TYPE_THEME_CUSTOMIZATION || $post->post_type == self::WP_POST_TYPE_NAV_MENU_ITEM) {\n\t\t\t\t\/\/Ignore -- relevant revision changes will be captured when they're saved to the owning post record\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t$action = self::POST_MARK_TRASHED;\n\t\t\tif ($post->post_type == self::WP_POST_TYPE_PAGE) {\n\t\t\t\t$action = self::PAGE_MARK_TRASHED;\n\t\t\t}\n\t\t\t\n\t\t\t$auditLog->_recordAction($action, $auditLog->_sanitizePost($post));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('untrashed_post', function($post_id) use ($auditLog) { \/\/Post\/page untrashed\n\t\t\t$post = WP_Post::get_instance($post_id);\n\t\t\tif (!$post) { return; }\n\t\t\t\n\t\t\tif ($post->post_type == self::WP_POST_TYPE_REVISION || $post->post_type == self::WP_POST_TYPE_THEME_CUSTOMIZATION || $post->post_type == self::WP_POST_TYPE_NAV_MENU_ITEM) {\n\t\t\t\t\/\/Ignore -- relevant revision changes will be captured when they're saved to the owning post record\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t$action = self::POST_UNMARK_TRASHED;\n\t\t\tif ($post->post_type == self::WP_POST_TYPE_PAGE) {\n\t\t\t\t$action = self::PAGE_UNMARK_TRASHED;\n\t\t\t}\n\t\t\t\n\t\t\t$auditLog->_recordAction($action, $auditLog->_sanitizePost($post));\n\t\t});\n\t}\n\t\n\t\/**\n\t * Registers the data gatherers for this class's chunk of functionality.\n\t *\n\t * @param wfAuditLog $auditLog\n\t *\/\n\tprotected static function _registerDataGatherers($auditLog) {\n\t\t$auditLog->_addObserver('delete_post', function($post_id \/** @var WP_Post $post also passed in WP > 5.5 *\/) use ($auditLog) { \/\/Post\/page will be deleted\n\t\t\t$post = WP_Post::get_instance($post_id);\n\t\t\tif ($post) {\n\t\t\t\tif ($post->post_type == self::WP_POST_TYPE_ATTACHMENT) {\n\t\t\t\t\t$auditLog->_trackState('delete_post.attachment', $auditLog->_sanitizePost($post));\n\t\t\t\t}\n\t\t\t\telse if ($post->post_type == self::WP_POST_TYPE_REVISION) {\n\t\t\t\t\t\/\/Ignore -- relevant revision changes will be captured when they're saved to the owning post record\n\t\t\t\t}\n\t\t\t\telse if ($post->post_type == self::WP_POST_TYPE_THEME_CUSTOMIZATION) {\n\t\t\t\t\t\/\/Ignore -- covered by a dedicated event\n\t\t\t\t}\n\t\t\t\telse if ($post->post_type == self::WP_POST_TYPE_NAV_MENU_ITEM) {\n\t\t\t\t\t\/\/Ignore\n\t\t\t\t}\n\t\t\t\telse if ($post->post_status != self::WP_POST_STATUS_AUTO_DRAFT) { \/\/Post, page, or a custom one that is not an auto-draft\n\t\t\t\t\t$auditLog->_trackState('delete_post.post', $auditLog->_sanitizePost($post)); \/\/We grab this here so it's available in `deleted_post` for WP < 5.5\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('pre_post_update', function($post_id, $data) use ($auditLog) { \/\/Post will be updated\n\t\t\t$auditLog->_trackState('pre_post_update.post', get_post($post_id), $post_id);\n\t\t});\n\t}\n\t\n\t\/**\n\t * Registers the coalescers for this class's chunk of functionality.\n\t *\n\t * @param wfAuditLog $auditLog\n\t *\/\n\tprotected static function _registerCoalescers($auditLog) {\n\t\t\n\t}\n}"},{"base":"plugins","rel":"wordfence\/lib\/audit-log\/wfAuditLogObserversWordPressCoreUser.php","ext":"php","size":12550,"mtime":1757312769,"type":"text","content":"<?php\n\nabstract class wfAuditLogObserversWordPressCoreUser extends wfAuditLog {\n\tconst USER_CREATED = 'user.account.created';\n\tconst USER_DELETED = 'user.account.deleted';\n\tconst USER_UPDATED = 'user.account.updated';\n\t\n\tconst USER_APP_PASSWORD_CREATED = 'user.permissions.app-password.created';\n\tconst USER_APP_PASSWORD_DELETED = 'user.permissions.app-password.deleted';\n\tconst USER_APP_PASSWORD_ACCEPTED = 'user.auth.app-password.accepted';\n\t\n\tconst USER_LOGGED_IN = 'user.auth.logged-in';\n\tconst USER_LOGGED_OUT = 'user.auth.logged-out';\n\tconst USER_AUTH_COOKIE_SET = 'user.auth.cookie-set';\n\tconst USER_PASSWORD_RESET = 'user.auth.password-reset';\n\t\n\tconst USER_ROLE_ADDED = 'user.permissions.role-added';\n\tconst USER_ROLE_REMOVED = 'user.permissions.role-removed';\n\tconst USER_META_CAPABILITIES = 'user.meta.capabilities';\n\tconst USER_META_LEVEL = 'user.meta.level';\n\t\n\tconst USER_STATUS_HAM = 'user.status.ham';\n\tconst USER_STATUS_SPAM = 'user.status.spam';\n\t\n\tprotected static $initialUserID = 0;\n\t\n\tpublic static function immediateSendEvents() {\n\t\treturn array();\n\t}\n\t\n\tpublic static function eventCategories() {\n\t\treturn array(\n\t\t\twfAuditLog::AUDIT_LOG_CATEGORY_USER_PERMISSIONS => array(\n\t\t\t\tself::USER_CREATED,\n\t\t\t\tself::USER_DELETED,\n\t\t\t\tself::USER_UPDATED,\n\t\t\t\t\n\t\t\t\tself::USER_ROLE_ADDED,\n\t\t\t\tself::USER_ROLE_REMOVED,\n\t\t\t\tself::USER_META_CAPABILITIES,\n\t\t\t\tself::USER_META_LEVEL,\n\t\t\t\t\n\t\t\t\tself::USER_STATUS_HAM,\n\t\t\t\tself::USER_STATUS_SPAM,\n\t\t\t),\n\t\t\twfAuditLog::AUDIT_LOG_CATEGORY_AUTHENTICATION => array(\n\t\t\t\tself::USER_APP_PASSWORD_CREATED,\n\t\t\t\tself::USER_APP_PASSWORD_DELETED,\n\t\t\t\tself::USER_APP_PASSWORD_ACCEPTED,\n\t\t\t\t\n\t\t\t\tself::USER_LOGGED_IN,\n\t\t\t\tself::USER_LOGGED_OUT,\n\t\t\t\tself::USER_AUTH_COOKIE_SET,\n\t\t\t\tself::USER_PASSWORD_RESET,\n\t\t\t),\n\t\t);\n\t}\n\t\n\tpublic static function eventNames() {\n\t\treturn array(\n\t\t\tself::USER_CREATED => __('User Created', 'wordfence'),\n\t\t\tself::USER_DELETED => __('User Deleted', 'wordfence'),\n\t\t\tself::USER_UPDATED => __('User Updated', 'wordfence'),\n\t\t\t\n\t\t\tself::USER_APP_PASSWORD_CREATED => __('App Password Created', 'wordfence'),\n\t\t\tself::USER_APP_PASSWORD_DELETED => __('App Password Deleted', 'wordfence'),\n\t\t\tself::USER_APP_PASSWORD_ACCEPTED => __('App Password Accepted', 'wordfence'),\n\t\t\t\n\t\t\tself::USER_LOGGED_IN => __('User Logged In', 'wordfence'),\n\t\t\tself::USER_LOGGED_OUT => __('User Logged Out', 'wordfence'),\n\t\t\tself::USER_AUTH_COOKIE_SET => __('Auth Cookie Set', 'wordfence'),\n\t\t\tself::USER_PASSWORD_RESET => __('Password Reset', 'wordfence'),\n\t\t\t\n\t\t\tself::USER_ROLE_ADDED => __('Role Added to User', 'wordfence'),\n\t\t\tself::USER_ROLE_REMOVED => __('Role Removed from User', 'wordfence'),\n\t\t\tself::USER_META_CAPABILITIES => __('User Capabilities Meta Value Changed', 'wordfence'),\n\t\t\tself::USER_META_LEVEL => __('User Level Meta Value Changed', 'wordfence'),\n\t\t\t\n\t\t\tself::USER_STATUS_HAM => __('User Unmarked as Spam', 'wordfence'),\n\t\t\tself::USER_STATUS_SPAM => __('User Marked as Spam', 'wordfence'),\n\t\t);\n\t}\n\t\n\tpublic static function eventRateLimiters() {\n\t\treturn array();\n\t}\n\t\n\t\/**\n\t * Registers the observers for this class's chunk of functionality.\n\t * \n\t * @param wfAuditLog $auditLog\n\t *\/\n\tprotected static function _registerObservers($auditLog) {\n\t\t$auditLog->_addObserver('init', function() use ($auditLog) {\n\t\t\tself::$initialUserID = get_current_user_id();\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('user_register', function($user_id, $userdata = null \/* added WP 5.8.0 *\/) use ($auditLog) { \/\/User created\n\t\t\t$auditLog->_recordAction(self::USER_CREATED, $auditLog->_sanitizeUserdata($userdata, $user_id));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('profile_update', function($user_id, $old_user_data, $userdata = null \/* added WP 5.8.0 *\/) use ($auditLog) { \/\/User edited\n\t\t\tif ($userdata === null && $user_id !== null) { \/\/May hit this on older WP versions where $userdata wasn't populated by the hook call\n\t\t\t\t$userdata = get_user_by('ID', $user_id);\n\t\t\t}\n\t\t\t\n\t\t\t$changes = array_keys($auditLog->_userdataDiff($old_user_data, $userdata));\n\t\t\tif (empty($changes)) { \/\/No actual changes to the record itself, just to usermeta so skip this entry\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t$auditLog->_recordAction(self::USER_UPDATED, array_merge(array(\n\t\t\t\t'changed' => $changes,\n\t\t\t), $auditLog->_sanitizeUserdata($userdata, $user_id)));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('rest_insert_user', function($user, $request, $creating) use ($auditLog) { \/\/User created\/updated via REST API, userdata already populated\n\t\t\t$auditLog->_recordAction($creating ? self::USER_CREATED : self::USER_UPDATED, array(\n\t\t\t\t'source' => 'REST',\n\t\t\t), true);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('deleted_user', function($user_id, $reassign_id) use ($auditLog) { \/\/User deleted\n\t\t\tif ($auditLog->_hasState('delete_user.user')) {\n\t\t\t\t$auditLog->_recordAction(self::USER_DELETED, array_merge(array(\n\t\t\t\t\t'reassigned' => $reassign_id,\n\t\t\t\t), $auditLog->_sanitizeUserdata($auditLog->_getState('delete_user.user'), $user_id)));\n\t\t\t}\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('rest_delete_user', function($user, $response, $request) use ($auditLog) { \/\/User deleted via REST API, userdata already populated\n\t\t\t$auditLog->_recordAction(self::USER_DELETED, array(\n\t\t\t\t'source' => 'REST',\n\t\t\t), true);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wp_login', function($user_login, $user) use ($auditLog) { \/\/User logged in\n\t\t\t$auditLog->_recordAction(self::USER_LOGGED_IN, $auditLog->_sanitizeUserdata($user));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wp_logout', function($user_id = 0) use ($auditLog) { \/\/User logged out\n\t\t\tif ($user_id == 0) {\n\t\t\t\t$user_id = self::$initialUserID;\n\t\t\t}\n\t\t\t\n\t\t\t$user = get_user_by('ID', $user_id);\n\t\t\t$auditLog->_recordAction(self::USER_LOGGED_OUT, $auditLog->_sanitizeUserdata($user));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('after_password_reset', function($user, $new_pass) use ($auditLog) { \/\/User password reset\n\t\t\t$auditLog->_recordAction(self::USER_PASSWORD_RESET, $auditLog->_sanitizeUserdata($user));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('set_auth_cookie', function($auth_cookie, $expire, $expiration, $user_id, $scheme) use ($auditLog) { \/\/Auth cookie set\n\t\t\t$user = get_user_by('ID', $user_id);\n\t\t\t$auditLog->_recordAction(self::USER_AUTH_COOKIE_SET, array(\n\t\t\t\t'grace_expiration' => $expire,\n\t\t\t\t'expiration' => $expiration,\n\t\t\t\t'scheme' => $scheme,\n\t\t\t\t'user' => $auditLog->_sanitizeUserdata($user),\n\t\t\t));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('add_user_role', function($user_id, $new_role) use ($auditLog) { \/\/User role assigned\n\t\t\t$user = get_user_by('ID', $user_id);\n\t\t\t$auditLog->_recordAction(self::USER_ROLE_ADDED, array_merge(array(\n\t\t\t\t'role_added' => $new_role,\n\t\t\t), $auditLog->_sanitizeUserdata($user)));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('remove_user_role', function($user_id, $removed_role) use ($auditLog) { \/\/User role assigned\n\t\t\t$user = get_user_by('ID', $user_id);\n\t\t\t$auditLog->_recordAction(self::USER_ROLE_REMOVED, array_merge(array(\n\t\t\t\t'role_removed' => $removed_role,\n\t\t\t), $auditLog->_sanitizeUserdata($user)));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('make_spam_user', function($user_id) use ($auditLog) { \/\/User marked as spam\n\t\t\t$user = get_user_by('ID', $user_id);\n\t\t\t$auditLog->_recordAction(self::USER_STATUS_SPAM, $auditLog->_sanitizeUserdata($user));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('make_ham_user', function($user_id) use ($auditLog) { \/\/User unmarked as spam\n\t\t\t$user = get_user_by('ID', $user_id);\n\t\t\t$auditLog->_recordAction(self::USER_STATUS_HAM, $auditLog->_sanitizeUserdata($user));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wp_create_application_password', function($user_id, $new_item, $new_password, $args) use ($auditLog) { \/\/User application password created\n\t\t\t$user = get_user_by('ID', $user_id);\n\t\t\t$auditLog->_recordAction(self::USER_APP_PASSWORD_CREATED, array_merge($auditLog->_sanitizeAppPassword($new_item), $auditLog->_sanitizeUserdata($user)));\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wp_delete_application_password', function($user_id, $item) use ($auditLog) { \/\/User application password deleted\n\t\t\t$user = get_user_by('ID', $user_id);\n\t\t\t$auditLog->_recordAction(self::USER_APP_PASSWORD_DELETED, array_merge($auditLog->_sanitizeAppPassword($item), $auditLog->_sanitizeUserdata($user)));\n\t\t});\n\t}\n\t\n\t\/**\n\t * Registers the data gatherers for this class's chunk of functionality.\n\t *\n\t * @param wfAuditLog $auditLog\n\t *\/\n\tprotected static function _registerDataGatherers($auditLog) {\n\t\t$auditLog->_addObserver('delete_user', function($user_id, $reassign_id) use ($auditLog) { \/\/About to delete user\n\t\t\t$user = get_user_by('ID', $user_id);\n\t\t\t$auditLog->_trackState('delete_user.user', $user);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('update_user_meta', function($meta_id, $object_id, $meta_key, $meta_value) use ($auditLog) { \/\/Update user meta\n\t\t\t$suffixes = array('capabilities', 'user_level'); \/\/will be <table prefix><suffix>, e.g., typically `wp_capabilities` but not always\n\t\t\t$match = false;\n\t\t\tforeach ($suffixes as $s) {\n\t\t\t\tif (preg_match('\/' . preg_quote($s) . '$\/i', $meta_key)) {\n\t\t\t\t\t$match = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!$match) { return; }\n\t\t\t\n\t\t\tif (!$auditLog->_hasState('update_user_meta.old', $object_id)) {\n\t\t\t\t$auditLog->_trackState('update_user_meta.old', array(), $object_id);\n\t\t\t}\n\t\t\t\n\t\t\t$old = array();\n\t\t\tif ($auditLog->_hasState('update_user_meta.old', $object_id)) {\n\t\t\t\t$old = $auditLog->_getState('update_user_meta.old', $object_id);\n\t\t\t}\n\t\t\t\n\t\t\tif (!isset($old[$meta_key])) {\n\t\t\t\t$old[$meta_key] = get_user_meta($object_id, $meta_key, true);\n\t\t\t\t$auditLog->_trackState('update_user_meta.old', $old, $object_id);\n\t\t\t}\n\t\t\t\n\t\t\tif (!$auditLog->_hasState('update_user_meta.new', $object_id)) {\n\t\t\t\t$auditLog->_trackState('update_user_meta.new', array(), $object_id);\n\t\t\t}\n\t\t\t\n\t\t\t$new = $auditLog->_getState('update_user_meta.new', $object_id);\n\t\t\t$new[$meta_key] = $meta_value;\n\t\t\t$auditLog->_trackState('update_user_meta.new', $new, $object_id);\n\t\t\t\n\t\t\t$auditLog->_needsDestruct();\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('application_password_did_authenticate', function($user, $item) use ($auditLog) { \/\/User application password authenticated\n\t\t\t\/\/We can't record this directly because wp_get_current_user re-authenticates everything when called later, causing an infinite loop\n\t\t\tif (!$auditLog->isFinalizing() && !empty($item['uuid'])) {\n\t\t\t\t$auditLog->_trackState('application_password_did_authenticate.items', array('user' => $user, 'item' => $item), $item['uuid']);\n\t\t\t\t$auditLog->_needsDestruct();\n\t\t\t}\n\t\t});\n\t}\n\t\n\t\/**\n\t * Registers the coalescers for this class's chunk of functionality.\n\t *\n\t * @param wfAuditLog $auditLog\n\t *\/\n\tprotected static function _registerCoalescers($auditLog) {\n\t\t$auditLog->_addCoalescer(function() use ($auditLog) { \/\/User meta changed, specific key patterns only\n\t\t\t$old = $auditLog->_getAllStates('update_user_meta.old');\n\t\t\tif (!is_array($old) || !count($old)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t$payload = array();\n\t\t\tforeach ($old as $user_id => $meta) {\n\t\t\t\t$user = get_user_by('ID', $user_id);\n\t\t\t\t$new = $auditLog->_getState('update_user_meta.new', $user_id);\n\t\t\t\tforeach ($meta as $key => $old_value) {\n\t\t\t\t\t$new_value = $new[$key];\n\t\t\t\t\t$event = null;\n\t\t\t\t\tif (preg_match('\/capabilities$\/i', $key)) {\n\t\t\t\t\t\t$event = self::USER_META_CAPABILITIES;\n\t\t\t\t\t}\n\t\t\t\t\telse if (preg_match('\/user_level$\/i', $key)) {\n\t\t\t\t\t\t$event = self::USER_META_LEVEL;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ($event) {\n\t\t\t\t\t\tif (!isset($payload[$event])) { $payload[$event] = array(); }\n\t\t\t\t\t\tif (!isset($payload[$event][$user_id])) { $payload[$event][$user_id] = array('user' => $auditLog->_sanitizeUserdata($user), 'changes' => array()); }\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (is_array($old_value) && is_array($new_value)) {\n\t\t\t\t\t\t\t$diff = wfUtils::array_diff($old_value, $new_value);\n\t\t\t\t\t\t\tif (empty($diff['added']) && empty($diff['removed'])) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t$diff = array('before' => $old_value, 'after' => $new_value);\n\t\t\t\t\t\t\tif ($diff['before'] == $diff['after']) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$payload[$event][$user_id]['changes'][] = array('key' => $key, 'diff' => $diff);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tforeach ($payload as $event => $data) {\n\t\t\t\t$auditLog->_recordAction($event, array_values($data));\n\t\t\t}\n\t\t});\n\t\t\n\t\t$auditLog->_addCoalescer(function() use ($auditLog) { \/\/App password authentications\n\t\t\t$items = $auditLog->_getAllStates('application_password_did_authenticate.items');\n\t\t\tforeach ($items as $uuid => $payload) {\n\t\t\t\t$auditLog->_recordAction(self::USER_APP_PASSWORD_ACCEPTED, array_merge($auditLog->_sanitizeAppPassword($payload['item']), $auditLog->_sanitizeUserdata($payload['user'])));\n\t\t\t}\n\t\t});\n\t}\n}"},{"base":"plugins","rel":"wordfence\/lib\/audit-log\/wfAuditLogObserversPreview.php","ext":"php","size":11025,"mtime":1757312769,"type":"text","content":"<?php\n\n\/**\n * wfAuditLogObserversPreview is a special subset of observers that is only registered when the audit log is in preview \n * mode. It does not actually record and send any events to Wordfence Central due to the audit log being disabled but \n * instead updates the local-only recent events list that is shown within the plugin UI. The data recorded is only a \n * low-overhead sampling of the possible events to provide a preview of the feature.\n *\/\nabstract class wfAuditLogObserversPreview extends wfAuditLog {\n\t\/**\n\t * Registers the observers for this class's chunk of functionality.\n\t * \n\t * @param wfAuditLog $auditLog\n\t *\/\n\tprotected static function _registerObservers($auditLog) {\n\t\t$auditLog->_addObserver('user_register', function() use ($auditLog) { \/\/User created\n\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordPressCoreUser::USER_CREATED);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('deleted_user', function() use ($auditLog) { \/\/User deleted\n\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordPressCoreUser::USER_DELETED);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wp_login', function() use ($auditLog) { \/\/User logged in\n\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordPressCoreUser::USER_LOGGED_IN);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('after_password_reset', function() use ($auditLog) { \/\/User password reset\n\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordPressCoreUser::USER_PASSWORD_RESET);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('set_auth_cookie', function() use ($auditLog) { \/\/Auth cookie set\n\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordPressCoreUser::USER_AUTH_COOKIE_SET);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('add_user_role', function() use ($auditLog) { \/\/User role assigned\n\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordPressCoreUser::USER_ROLE_ADDED);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wp_create_application_password', function() use ($auditLog) { \/\/User application password created\n\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordPressCoreUser::USER_APP_PASSWORD_CREATED);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('export_wp', function() use ($auditLog) { \/\/Exported WP data\n\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordPressCoreSite::SITE_DATA_EXPORTED);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('update_option_default_role', function() use ($auditLog) { \/\/Default role on user registration\n\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordPressCoreSite::SITE_OPTION_DEFAULT_ROLE);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('update_option_users_can_register', function() use ($auditLog) { \/\/User registration allowed\n\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordPressCoreSite::SITE_OPTION_USER_REGISTRATION);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('update_option_siteurl', function() use ($auditLog) { \/\/Site URL\n\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordPressCoreSite::SITE_OPTION_SITE_URL);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('update_option_home', function() use ($auditLog) { \/\/Home URL\n\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordPressCoreSite::SITE_OPTION_HOME_URL);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('update_option_admin_email', function() use ($auditLog) { \/\/Admin email\n\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordPressCoreSite::SITE_OPTION_ADMIN_EMAIL);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('update_option_default_comment_status', function() use ($auditLog) { \/\/Default comment status\n\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordPressCoreSite::SITE_OPTION_DEFAULT_COMMENT_STATUS);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('update_option_template', function() use ($auditLog) { \/\/Theme selected, this is the parent theme value\n\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordPressCoreSite::SITE_OPTION_TEMPLATE);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('update_option_stylesheet', function() use ($auditLog) { \/\/Theme selected, this is the child theme value\n\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordPressCoreSite::SITE_OPTION_STYLESHEET);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('upgrader_post_install', function($response, $hook_extra, $result) use ($auditLog) { \/\/Plugin\/theme installed\/updated\n\t\t\tif ($response && !is_wp_error($result)) {\n\t\t\t\t\/\/Same flow as wfAuditLogObserversWordPressCoreSite->upgrader_post_install handler, which contains a data structure reference\n\t\t\t\tif (isset($hook_extra['action']) && isset($hook_extra['type']) && isset($result['source']) && isset($result['destination'])) { \/\/Install\n\t\t\t\t\tif ($hook_extra['action'] == 'install') {\n\t\t\t\t\t\tif ($hook_extra['type'] == 'plugin') {\n\t\t\t\t\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordPressCoreSite::SITE_PLUGIN_INSTALLED);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ($hook_extra['type'] == 'theme') {\n\t\t\t\t\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordPressCoreSite::SITE_THEME_INSTALLED);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (isset($hook_extra['plugin']) && isset($result['source']) && isset($result['destination'])) { \/\/Plugin update\n\t\t\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordPressCoreSite::SITE_UPDATE_PLUGIN);\n\t\t\t\t}\n\t\t\t\telse if (isset($hook_extra['theme']) && isset($result['source']) && isset($result['destination'])) { \/\/Theme update\n\t\t\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordPressCoreSite::SITE_UPDATE_THEME);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn $response;\n\t\t}, 'filter');\n\t\t\n\t\t$auditLog->_addObserver('activated_plugin', function() use ($auditLog) { \/\/Plugin activated\n\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordPressCoreSite::SITE_PLUGIN_ACTIVATED);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('deactivated_plugin', function() use ($auditLog) { \/\/Plugin deactivated\n\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordPressCoreSite::SITE_PLUGIN_DEACTIVATED);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('deleted_plugin', function() use ($auditLog) { \/\/Plugin deleted\n\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordPressCoreSite::SITE_PLUGIN_DELETED);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('switch_theme', function() use ($auditLog) { \/\/Theme switched\n\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordPressCoreSite::SITE_THEME_SWITCHED);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('deleted_theme', function() use ($auditLog) { \/\/Theme deleted\n\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordPressCoreSite::SITE_THEME_DELETED);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('customize_save_after', function() use ($auditLog) { \/\/Theme customized\n\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordPressCoreSite::SITE_THEME_CUSTOMIZED);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('upgrader_process_complete', function($upgrader, $hook_extra) use ($auditLog) { \/\/Core updated\n\t\t\tif (is_array($hook_extra) && isset($hook_extra['type']) && $hook_extra['type'] == 'core' && isset($hook_extra['action']) && $hook_extra['action'] == 'update') {\n\t\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordPressCoreSite::SITE_UPDATE_CORE);\n\t\t\t}\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('automatic_updates_complete', function() use ($auditLog) { \/\/Automatic updates complete\n\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordPressCoreSite::SITE_UPDATE_AUTOMATIC_COMPLETED);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('generate_recovery_mode_key', function() use ($auditLog) { \/\/Recovery key generated\n\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordPressCoreSite::SITE_RECOVERY_MODE_KEY_GENERATED);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_ls_2fa_deactivated', function() use ($auditLog) { \/\/2FA deactivated on a user\n\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordfence::WORDFENCE_LS_2FA_DEACTIVATED);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_ls_2fa_activated', function() use ($auditLog) { \/\/2FA activated on a user\n\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordfence::WORDFENCE_LS_2FA_ACTIVATED);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_waf_mode', function() use ($auditLog) { \/\/WAF mode setting changed\n\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordfence::WORDFENCE_WAF_MODE_CHANGED);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_waf_changed_rule_status', function() use ($auditLog) { \/\/WAF rule mode(s) changed\n\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordfence::WORDFENCE_WAF_RULE_STATUS_CHANGED);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_waf_changed_protection_level', function() use ($auditLog) { \/\/WAF protection level changed\n\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordfence::WORDFENCE_WAF_PROTECTION_LEVEL_CHANGED);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_waf_toggled_blocklist', function() use ($auditLog) { \/\/WAF blocklist toggled on\/off\n\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordfence::WORDFENCE_WAF_BLOCKLIST_TOGGLED);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_updated_country_blocking', function() use ($auditLog) { \/\/Country block changed\n\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordfence::WORDFENCE_BLOCKING_COUNTRY_UPDATED);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_created_ip_pattern_block', function() use ($auditLog) { \/\/IP or Pattern block created manually\n\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordfence::WORDFENCE_BLOCKING_IP_PATTERN_CREATED);\n\t\t});\n\t\t\n\t\t$auditLog->_addObserver('wordfence_deleted_block', function() use ($auditLog) { \/\/Block deleted manually\n\t\t\tself::_recordLocalEvent($auditLog, wfAuditLogObserversWordfence::WORDFENCE_BLOCKING_DELETED);\n\t\t});\n\t}\n\t\n\t\/**\n\t * Queues an audit event for saving to the local audit log preview.\n\t * \n\t * @param wfAuditLog $auditLog\n\t * @param string $type\n\t * @param int|null $timestamp\n\t *\/\n\tprivate static function _recordLocalEvent($auditLog, $type, $timestamp = null) {\n\t\tif ($timestamp === null) {\n\t\t\t$timestamp = time();\n\t\t}\n\t\t\n\t\t$recentEvents = $auditLog->_getState('disabledAuditLogRecentEvents', 0);\n\t\tif (empty($recentEvents)) {\n\t\t\t$recentEvents = array();\n\t\t}\n\t\t\n\t\tarray_unshift($recentEvents, array($type, $timestamp));\n\t\t$auditLog->_trackState('disabledAuditLogRecentEvents', $recentEvents, 0);\n\t\t\n\t\tif (!$auditLog->_getState('disabledAuditLogDestructRegistered', 0)) {\n\t\t\tregister_shutdown_function(function($auditLog) { self::_recentEventsLastAction($auditLog); }, $auditLog); \/\/Wrapped in a closure because `register_shutdown_function` can't handle private static functions directly\n\t\t\t$auditLog->_trackState('disabledAuditLogDestructRegistered', true, 0);\n\t\t}\n\t}\n\t\n\t\/**\n\t * Performed as a shutdown handler to save the recent events list.\n\t * \n\t * @param wfAuditLog $auditLog\n\t *\/\n\tprivate static function _recentEventsLastAction($auditLog) {\n\t\tglobal $wpdb;\n\t\t$suppressed = $wpdb->suppress_errors(!(defined('WFWAF_DEBUG') && WFWAF_DEBUG));\n\t\t\n\t\t$recentEvents = $auditLog->_getState('disabledAuditLogRecentEvents', 0);\n\t\t$auditLog->_updateAuditPreview(array($recentEvents));\n\t\t$auditLog->_trackState('disabledAuditLogRecentEvents', array(), 0);\n\t\t\n\t\t$wpdb->suppress_errors($suppressed);\n\t}\n}"},{"base":"plugins","rel":"wordfence\/lib\/wfStyle.php","ext":"php","size":1244,"mtime":1757312769,"type":"text","content":"<?php\nclass wfStyle {\n\t\/**\n\t * Returns the classes for the main content body of the page, adjusting for the paid status.\n\t * \n\t * @return string\n\t *\/\n\tpublic static function contentClasses() {\n\t\tif (wfConfig::get('isPaid')) {\n\t\t\treturn 'wf-col-xs-12';\n\t\t}\n\t\treturn 'wf-col-xs-12';\n\t}\n\t\n\t\/**\n\t * Returns the class for an audit log event based on its type.\n\t * \n\t * @param string $type One of the wfAuditLog::AUDIT_LOG_CATEGORY_* constants\n\t * @return string\n\t *\/\n\tpublic static function auditEventTypeClass($type) {\n\t\tswitch ($type) {\n\t\t\tcase wfAuditLog::AUDIT_LOG_CATEGORY_AUTHENTICATION:\n\t\t\t\treturn 'wf-audit-type-authentication';\n\t\t\tcase wfAuditLog::AUDIT_LOG_CATEGORY_USER_PERMISSIONS:\n\t\t\t\treturn 'wf-audit-type-user-permissions';\n\t\t\tcase wfAuditLog::AUDIT_LOG_CATEGORY_PLUGINS_THEMES_UPDATES:\n\t\t\t\treturn 'wf-audit-type-plugins-themes-updates';\n\t\t\tcase wfAuditLog::AUDIT_LOG_CATEGORY_SITE_SETTINGS:\n\t\t\t\treturn 'wf-audit-type-site-settings';\n\t\t\tcase wfAuditLog::AUDIT_LOG_CATEGORY_MULTISITE:\n\t\t\t\treturn 'wf-audit-type-multisite';\n\t\t\tcase wfAuditLog::AUDIT_LOG_CATEGORY_CONTENT:\n\t\t\t\treturn 'wf-audit-type-content';\n\t\t\tcase wfAuditLog::AUDIT_LOG_CATEGORY_FIREWALL:\n\t\t\t\treturn 'wf-audit-type-firewall';\n\t\t}\n\t\treturn 'wf-audit-type-unknown';\n\t}\n}"},{"base":"plugins","rel":"wordfence\/lib\/wfOnboardingController.php","ext":"php","size":9443,"mtime":1757312769,"type":"text","content":"<?php\n\nclass wfOnboardingController {\n\tconst ONBOARDING_EMAILS = 'emails'; \/\/New install, part 1 completed\n\tconst ONBOARDING_LICENSE = 'license'; \/\/New install, part 2 completed\n\tconst ONBOARDING_SKIPPED = 'skipped'; \/\/New install, onboarding attempt was skipped\n\t\n\tconst TOUR_DASHBOARD = 'dashboard';\n\tconst TOUR_FIREWALL = 'firewall';\n\tconst TOUR_SCAN = 'scan';\n\tconst TOUR_BLOCKING = 'blocking';\n\tconst TOUR_LIVE_TRAFFIC = 'livetraffic';\n\tconst TOUR_AUDIT_LOG = 'auditlog';\n\tconst TOUR_LOGIN_SECURITY = 'loginsecurity';\n\t\n\t\/**\n\t * Sets the appropriate initial settings for an existing install so it's not forced through onboarding.\n\t *\/\n\tpublic static function migrateOnboarding() {\n\t\t$alertEmails = wfConfig::getAlertEmails();\n\t\t$onboardingAttempt1 = wfConfig::get('onboardingAttempt1');\n\t\t$lastOnboardingVersion = wfConfig::get('onboardingLastVersion');\n\t\tif (!empty($alertEmails) && empty($onboardingAttempt1)) { \/\/Wordfence 7.0 migration\n\t\t\twfConfig::set('onboardingAttempt1', self::ONBOARDING_LICENSE); \/\/Mark onboarding as done\n\t\t\t\n\t\t\t$keys = array(self::TOUR_DASHBOARD, self::TOUR_FIREWALL, self::TOUR_SCAN, self::TOUR_BLOCKING, self::TOUR_LIVE_TRAFFIC, self::TOUR_AUDIT_LOG);\n\t\t\tforeach ($keys as $k) {\n\t\t\t\twfConfig::set('needsNewTour_' . $k, 0);\n\t\t\t\twfConfig::set('needsUpgradeTour_' . $k, 1);\n\t\t\t}\n\t\t\twfConfig::set('onboardingLastVersion', WORDFENCE_VERSION);\n\t\t}\n\t\telse if (!empty($alertEmails) && !empty($onboardingAttempt1) && (empty($lastOnboardingVersion) || \n\t\t\t\tversion_compare('8.0', $lastOnboardingVersion) == 1)) { \/\/Future new tour steps can copy this block and extend\n\t\t\t$keys = array(self::TOUR_AUDIT_LOG);\n\t\t\tforeach ($keys as $k) {\n\t\t\t\twfConfig::set('needsNewTour_' . $k, 0);\n\t\t\t\twfConfig::set('needsUpgradeTour_' . $k, 1);\n\t\t\t}\n\t\t\twfConfig::set('onboardingLastVersion', WORDFENCE_VERSION);\n\t\t}\n\t}\n\t\n\t\/**\n\t * Initializes the onboarding hooks.\n\t * \n\t * Only called if (is_admin() && wfUtils::isAdmin()) is true.\n\t *\/\n\tpublic static function initialize() {\n\t\t$willShowAnyTour = (self::shouldShowNewTour(self::TOUR_DASHBOARD) || self::shouldShowUpgradeTour(self::TOUR_DASHBOARD) ||\n\t\t\t\t\t\t\tself::shouldShowNewTour(self::TOUR_FIREWALL) || self::shouldShowUpgradeTour(self::TOUR_FIREWALL) ||\n\t\t\t\t\t\t\tself::shouldShowNewTour(self::TOUR_SCAN) || self::shouldShowUpgradeTour(self::TOUR_SCAN) ||\n\t\t\t\t\t\t\tself::shouldShowNewTour(self::TOUR_BLOCKING) || self::shouldShowUpgradeTour(self::TOUR_BLOCKING) ||\n\t\t\t\t\t\t\tself::shouldShowNewTour(self::TOUR_LIVE_TRAFFIC) || self::shouldShowUpgradeTour(self::TOUR_LIVE_TRAFFIC) ||\n\t\t\t\t\t\t\tself::shouldShowNewTour(self::TOUR_AUDIT_LOG) || self::shouldShowUpgradeTour(self::TOUR_AUDIT_LOG) ||\n\t\t\t\t\t\t\tself::shouldShowNewTour(self::TOUR_LOGIN_SECURITY) || self::shouldShowUpgradeTour(self::TOUR_LOGIN_SECURITY));\n\t\tif (!self::shouldShowAnyAttempt() && !$willShowAnyTour) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tadd_action('in_admin_header', 'wfOnboardingController::_admin_header'); \/\/Called immediately after <div id=\"wpcontent\">\n\t\tadd_action('pre_current_active_plugins', 'wfOnboardingController::_pre_plugins'); \/\/Called immediately after <hr class=\"wp-header-end\">\n\t\tadd_action('admin_enqueue_scripts', 'wfOnboardingController::_enqueue_scripts');\n\t}\n\t\n\t\/**\n\t * Enqueues the scripts and styles we need globally on the backend for onboarding.\n\t *\/\n\tpublic static function _enqueue_scripts() {\n\t\t$willShowAnyPluginOnboarding = (self::shouldShowAttempt1() || self::shouldShowAttempt2());\n\t\t$willShowAnyTour = (self::shouldShowNewTour(self::TOUR_DASHBOARD) || self::shouldShowUpgradeTour(self::TOUR_DASHBOARD) ||\n\t\t\tself::shouldShowNewTour(self::TOUR_FIREWALL) || self::shouldShowUpgradeTour(self::TOUR_FIREWALL) ||\n\t\t\tself::shouldShowNewTour(self::TOUR_SCAN) || self::shouldShowUpgradeTour(self::TOUR_SCAN) ||\n\t\t\tself::shouldShowNewTour(self::TOUR_BLOCKING) || self::shouldShowUpgradeTour(self::TOUR_BLOCKING) ||\n\t\t\tself::shouldShowNewTour(self::TOUR_LIVE_TRAFFIC) || self::shouldShowUpgradeTour(self::TOUR_LIVE_TRAFFIC) ||\n\t\t\tself::shouldShowNewTour(self::TOUR_AUDIT_LOG) || self::shouldShowUpgradeTour(self::TOUR_AUDIT_LOG) ||\n\t\t\tself::shouldShowNewTour(self::TOUR_LOGIN_SECURITY) || self::shouldShowUpgradeTour(self::TOUR_LOGIN_SECURITY));\n\t\t\n\t\t$page = wfUtils::array_get($_GET, 'page', '');\n\t\tif (wfUtils::isAdmin() && \n\t\t\t(\n\t\t\t\t(\n\t\t\t\t\t$willShowAnyPluginOnboarding && preg_match('~(?:^|\/)wp-admin(?:\/network)?\/plugins\\.php~i', $_SERVER['REQUEST_URI'])\n\t\t\t\t) || \n\t\t\t\t(\n\t\t\t\t\t!empty($page) && (preg_match('\/^Wordfence\/', $page) || preg_match('\/^WFLS\/', $page))\n\t\t\t\t)\n\t\t\t)\n\t\t) {\n\t\t\tself::enqueue_assets();\n\t\t}\n\t}\n\n\tpublic static function enqueue_assets() {\n\t\twp_enqueue_style('wordfence-font', wfUtils::getBaseURL() . wfUtils::versionedAsset('css\/wf-roboto-font.css'), '', WORDFENCE_VERSION);\n\t\twp_enqueue_style('wordfence-ionicons-style', wfUtils::getBaseURL() . wfUtils::versionedAsset('css\/wf-ionicons.css'), '', WORDFENCE_VERSION);\n\t\twp_enqueue_style('wordfenceOnboardingCSS', wfUtils::getBaseURL() . wfUtils::versionedAsset('css\/wf-onboarding.css'), '', WORDFENCE_VERSION);\n\t\twp_enqueue_style('wordfence-colorbox-style', wfUtils::getBaseURL() . wfUtils::versionedAsset('css\/wf-colorbox.css'), '', WORDFENCE_VERSION);\n\t\twp_enqueue_script('jquery.wfcolorbox', wfUtils::getBaseURL() . wfUtils::versionedAsset('js\/jquery.colorbox-min.js'), array('jquery'), WORDFENCE_VERSION);\n\t}\n\t\n\t\/**\n\t * Outputs the onboarding overlay if it needs to be shown on the plugins page.\n\t *\/\n\tpublic static function _admin_header() {\n\t\t$willShowAnyTour = (self::shouldShowNewTour(self::TOUR_DASHBOARD) || self::shouldShowUpgradeTour(self::TOUR_DASHBOARD) ||\n\t\t\t\t\t\t\tself::shouldShowNewTour(self::TOUR_FIREWALL) || self::shouldShowUpgradeTour(self::TOUR_FIREWALL) ||\n\t\t\t\t\t\t\tself::shouldShowNewTour(self::TOUR_SCAN) || self::shouldShowUpgradeTour(self::TOUR_SCAN) ||\n\t\t\t\t\t\t\tself::shouldShowNewTour(self::TOUR_BLOCKING) || self::shouldShowUpgradeTour(self::TOUR_BLOCKING) ||\n\t\t\t\t\t\t\tself::shouldShowNewTour(self::TOUR_LIVE_TRAFFIC) || self::shouldShowUpgradeTour(self::TOUR_LIVE_TRAFFIC) ||\n\t\t\t\t\t\t\tself::shouldShowNewTour(self::TOUR_AUDIT_LOG) || self::shouldShowUpgradeTour(self::TOUR_AUDIT_LOG) ||\n\t\t\t\t\t\t\tself::shouldShowNewTour(self::TOUR_LOGIN_SECURITY) || self::shouldShowUpgradeTour(self::TOUR_LOGIN_SECURITY));\n\t\t\n\t\t$screen = get_current_screen();\n\t\tif ($screen->base == 'plugins' && self::shouldShowAttempt1()) {\n\t\t\tregister_shutdown_function('wfOnboardingController::_markAttempt1Shown');\n\t\t\t$freshInstall = wfView::create('onboarding\/fresh-install')->render(); \n\t\t\t\n\t\t\techo wfView::create('onboarding\/overlay', array(\n\t\t\t\t'contentHTML' => $freshInstall,\n\t\t\t))->render();\n\t\t}\n\t\telse if (preg_match('\/wordfence\/i', $screen->base) && $willShowAnyTour) {\n\t\t\techo wfView::create('onboarding\/tour-overlay')->render();\n\t\t}\n\t}\n\t\n\tpublic static function _markAttempt1Shown() {\n\t\twfConfig::set('onboardingAttempt1', self::ONBOARDING_SKIPPED); \/\/Only show it once, default to skipped after outputting the first time\n\t}\n\t\n\tpublic static function shouldShowAttempt1() { \/\/Overlay on plugin page\n\t\tif (wfConfig::get('onboardingAttempt3') == self::ONBOARDING_LICENSE) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tswitch (wfConfig::get('onboardingAttempt1')) {\n\t\t\tcase self::ONBOARDING_LICENSE:\n\t\t\tcase self::ONBOARDING_SKIPPED:\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static function _pre_plugins() {\n\t\tif (self::shouldShowAttempt2()) {\n\t\t\techo wfView::create('onboarding\/plugin-header')->render();\n\t\t}\n\t}\n\n\tprivate static function needsApiKey() {\n\t\t$key = wfConfig::get('apiKey');\n\t\treturn empty($key);\n\t}\n\t\n\tpublic static function shouldShowAttempt2() { \/\/Header on plugin page\n\t\tif (wfConfig::get('onboardingAttempt3') == self::ONBOARDING_LICENSE) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn !wfConfig::get('onboardingAttempt2') && self::needsApiKey();\n\t}\n\t\n\tpublic static function shouldShowAttempt3($dismissable = false) {\n\t\tif (self::needsApiKey()) {\n\t\t\tif (!$dismissable)\n\t\t\t\treturn true;\n\t\t\t$delayedAt = (int) wfConfig::get('onboardingDelayedAt', 0);\n\t\t\tif (time() - $delayedAt > 43200 \/*12 hours in seconds*\/)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\/**\n\t * Whether or not to pop up attempt 3 at page load or wait for user interaction.\n\t * \n\t * @return bool\n\t *\/\n\tpublic static function shouldShowAttempt3Automatically() {\n\t\tstatic $_shouldShowAttempt3Automatically = null;\n\t\tif ($_shouldShowAttempt3Automatically !== null) { \/\/We cache this so the answer remains the same for the whole request\n\t\t\treturn $_shouldShowAttempt3Automatically;\n\t\t}\n\t\t\n\t\tif (!self::shouldShowAttempt3()) {\n\t\t\t$_shouldShowAttempt3Automatically = false;\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn $_shouldShowAttempt3Automatically = self::shouldShowAttempt3();\n\t}\n\t\n\tpublic static function willShowNewTour($page) {\n\t\t$key = 'needsNewTour_' . $page;\n\t\treturn wfConfig::get($key);\n\t}\n\t\n\tpublic static function shouldShowNewTour($page) {\n\t\t$key = 'needsNewTour_' . $page;\n\t\treturn (!self::shouldShowAttempt3Automatically() && !wfConfig::get('touppPromptNeeded') && wfConfig::get($key));\n\t}\n\t\n\tpublic static function willShowUpgradeTour($page) {\n\t\t$key = 'needsUpgradeTour_' . $page;\n\t\treturn wfConfig::get($key);\n\t}\n\t\n\tpublic static function shouldShowUpgradeTour($page) {\n\t\t$key = 'needsUpgradeTour_' . $page;\n\t\treturn (!self::shouldShowAttempt3Automatically() && !wfConfig::get('touppPromptNeeded') && wfConfig::get($key));\n\t}\n\n\tpublic static function shouldShowAnyAttempt() {\n\t\treturn self::shouldShowAttempt1() || self::shouldShowAttempt2() || self::shouldShowAttempt3();\n\t}\n\n}"},{"base":"plugins","rel":"wordfence\/lib\/wfBrowscap.php","ext":"php","size":3996,"mtime":1757312769,"type":"text","content":"<?php\nclass wfBrowscap {\n\tprotected $_cacheLoaded = false;\n\tprotected $_userAgents = array();\n\tprotected $_browsers = array();\n\tprotected $_patterns = array();\n\tprotected $_properties = array();\n\tprotected $resultCache = array();\n\tconst COMPRESSION_PATTERN_START = '@';\n\tconst COMPRESSION_PATTERN_DELIMITER = '|';\n\tconst REGEX_DELIMITER = '@';\n\t\n\tpublic static function shared() {\n\t\tstatic $_browscap = null;\n\t\tif ($_browscap === null) {\n\t\t\t$_browscap = new wfBrowscap();\n\t\t}\n\t\treturn $_browscap;\n\t}\n\n    public function getBrowser($user_agent){\n        if (!$this->_cacheLoaded) {\n                if (!$this->_loadCache(dirname(__FILE__) . '\/wfBrowscapCache.php')) {\n                    throw new Exception('Cannot load this cache version - the cache format is not compatible.');\n                }\n            }\n\n        $browser = array();\n        foreach ($this->_patterns as $pattern => $pattern_data) {\n            if (preg_match($pattern . 'i', $user_agent, $matches)) {\n                if (1 == count($matches)) {\n                    $key = $pattern_data;\n\n                    $simple_match = true;\n                } else {\n                    $pattern_data = unserialize($pattern_data);\n\n                    array_shift($matches);\n\n                    $match_string = self::COMPRESSION_PATTERN_START\n                        . implode(self::COMPRESSION_PATTERN_DELIMITER, $matches);\n\n                    if (!isset($pattern_data[$match_string])) {\n                        continue;\n                    }\n\n                    $key = $pattern_data[$match_string];\n\n                    $simple_match = false;\n                }\n\n                $browser = array(\n                    $user_agent,\n                    trim(strtolower($pattern), self::REGEX_DELIMITER),\n                    $this->_pregUnQuote($pattern, $simple_match ? false : $matches)\n                );\n\n                $browser = $value = $browser + unserialize($this->_browsers[$key]);\n\n                while (array_key_exists(3, $value)) {\n                    $value = unserialize($this->_browsers[$value[3]]);\n                    $browser += $value;\n                }\n\n                if (!empty($browser[3])) {\n                    $browser[3] = $this->_userAgents[$browser[3]];\n                }\n\n                break;\n            }\n        }\n\n        $array = array();\n        foreach ($browser as $key => $value) {\n            if ($value === 'true') {\n                $value = true;\n            } elseif ($value === 'false') {\n                $value = false;\n            }\n            $array[$this->_properties[$key]] = $value;\n        }\n\n        return $array;\n    }\n    protected function _loadCache($cache_file){\n        $cache_version  = null;\n        $browsers       = array();\n        $userAgents     = array();\n        $patterns       = array();\n        $properties     = array();\n\n        $this->_cacheLoaded = false;\n\n        require $cache_file;\n\n        $this->_browsers       = $browsers;\n        $this->_userAgents     = $userAgents;\n        $this->_patterns       = $patterns;\n        $this->_properties     = $properties;\n\n        $this->_cacheLoaded = true;\n\n        return true;\n    }\n    protected function _pregUnQuote($pattern, $matches){\n        $search  = array(\n            '\\\\' . self::REGEX_DELIMITER, '\\\\.', '\\\\\\\\', '\\\\+', '\\\\[', '\\\\^', '\\\\]', '\\\\$', '\\\\(', '\\\\)', '\\\\{', '\\\\}',\n            '\\\\=', '\\\\!', '\\\\<', '\\\\>', '\\\\|', '\\\\:', '\\\\-', '.*', '.', '\\\\?'\n        );\n        $replace = array(\n            self::REGEX_DELIMITER, '\\\\?', '\\\\', '+', '[', '^', ']', '$', '(', ')', '{', '}', '=', '!', '<', '>', '|',\n            ':', '-', '*', '?', '.'\n        );\n\n        $result = substr(str_replace($search, $replace, $pattern), 2, -2);\n\n        if ($matches) {\n            foreach ($matches as $one_match) {\n                $num_pos = strpos($result, '(\\d)');\n                $result  = substr_replace($result, $one_match, $num_pos, 4);\n            }\n        }\n\n        return $result;\n    }\n}"},{"base":"plugins","rel":"wordfence\/lib\/wfRESTAPI.php","ext":"php","size":377,"mtime":1757312769,"type":"text","content":"<?php\nif (defined('ABSPATH')) {\nclass wfWP_REST_Users_Controller extends WP_REST_Users_Controller\n{\n\tpublic static function wfGetURLBase() {\n\t\t$controller = new wfWP_REST_Users_Controller();\n\t\treturn rtrim($controller->namespace . '\/' . $controller->rest_base, '\/');\n\t}\n\t\n\tpublic function _wfGetURLBase() {\n\t\treturn rtrim($this->namespace, '\/' . $this->rest_base, '\/');\n\t}\n}\n}\n"},{"base":"plugins","rel":"wordfence\/lib\/wfScanPath.php","ext":"php","size":1817,"mtime":1757312769,"type":"text","content":"<?php\n\nrequire_once __DIR__ . '\/wfFileUtils.php';\nrequire_once __DIR__ . '\/wfScanFile.php';\nrequire_once __DIR__ . '\/wfScanFileLink.php';\n\nclass wfScanPath {\n\n\tprivate $baseDirectory;\n\tprivate $path;\n\tprivate $realPath;\n\tprivate $wordpressPath;\n\tprivate $expectedFiles;\n\n\tpublic function __construct($baseDirectory, $path, $wordpressPath = null, $expectedFiles = null) {\n\t\t$this->baseDirectory = $baseDirectory;\n\t\t$this->path = $path;\n\t\t$this->realPath = wfFileUtils::realPath($path);\n\t\t$this->wordpressPath = $wordpressPath;\n\t\t$this->expectedFiles = is_array($expectedFiles) ? array_flip($expectedFiles) : null;\n\t}\n\n\tpublic function getPath() {\n\t\treturn $this->path;\n\t}\n\n\tpublic function getRealPath() {\n\t\treturn $this->realPath;\n\t}\n\n\tpublic function getWordpressPath() {\n\t\treturn $this->wordpressPath;\n\t}\n\n\tpublic function hasExpectedFiles() {\n\t\treturn $this->expectedFiles !== null && !empty($this->expectedFiles);\n\t}\n\n\tpublic function expectsFile($name) {\n\t\treturn array_key_exists($name, $this->expectedFiles);\n\t}\n\n\tpublic function isBaseDirectory() {\n\t\treturn $this->path === $this->baseDirectory;\n\t}\n\n\tpublic function isBelowBaseDirectory() {\n\t\treturn wfFileUtils::belongsTo($this->path, $this->baseDirectory);\n\t}\n\n\tpublic function getContents() {\n\t\treturn wfFileUtils::getContents($this->realPath);\n\t}\n\n\tpublic function createScanFile($relativePath) {\n\t\t$path = wfFileUtils::joinPaths($this->realPath, $relativePath);\n\t\t$realPath = wfFileUtils::realPath($path);\n\t\t$wordpressPath = wfFileUtils::trimSeparators(wfFileUtils::joinPaths($this->wordpressPath, $relativePath), true, false);\n\t\tif (is_link($path)) {\n\t\t\treturn new wfScanFileLink($path, $realPath, $wordpressPath);\n\t\t}\n\t\telse {\n\t\t\treturn new wfScanFile($realPath, $wordpressPath);\n\t\t}\n\t}\n\n\tpublic function __toString() {\n\t\treturn $this->realPath;\n\t}\n\n}"},{"base":"plugins","rel":"wordfence\/lib\/wfScanFileListItem.php","ext":"php","size":408,"mtime":1757312769,"type":"text","content":"<?php\n\nrequire_once __DIR__ . '\/wfScanFile.php';\n\nclass wfScanFileListItem extends wfScanFile {\n\n\tprivate $id;\n\tprivate $next;\n\n\tpublic function __construct($id, $realPath, $wordpressPath, $next = null) {\n\t\tparent::__construct($realPath, $wordpressPath);\n\t\t$this->id = $id;\n\t\t$this->next = $next;\n\t}\n\n\tpublic function getId() {\n\t\treturn $this->id;\n\t}\n\n\tpublic function getNext() {\n\t\treturn $this->next;\n\t}\n\n}"},{"base":"plugins","rel":"wordfence\/lib\/wfInaccessibleDirectoryException.php","ext":"php","size":303,"mtime":1757312769,"type":"text","content":"<?php\n\nclass wfInaccessibleDirectoryException extends RuntimeException {\n\n\tprivate $directory;\n\n\tpublic function __construct($message, $directory) {\n\t\tparent::__construct(\"{$message}: {$directory}\");\n\t\t$this->directory = $directory;\n\t}\n\n\tpublic function getDirectory() {\n\t\treturn $this->directory;\n\t}\n\n}"},{"base":"plugins","rel":"wordfence\/lib\/menu_firewall_waf.php","ext":"php","size":20443,"mtime":1757312769,"type":"text","content":"<?php\nif (!defined('WORDFENCE_VERSION')) { exit; }\n$waf = wfWAF::getInstance();\n$d = new wfDashboard(); unset($d->countriesNetwork);\n$firewall = new wfFirewall();\n$config = $waf->getStorageEngine();\n$wafConfigURL = network_admin_url('admin.php?page=WordfenceWAF&subpage=waf_options#configureAutoPrepend');\n$wafRemoveURL = network_admin_url('admin.php?page=WordfenceWAF&subpage=waf_options#removeAutoPrepend');\n\/** @var array $wafData *\/\n?>\n\n<div class=\"wf-row\">\n\t<div class=\"wf-col-xs-12\">\n\t\t<div class=\"wf-block wf-active\">\n\t\t\t<div class=\"wf-block-content\">\n\t\t\t\t<ul class=\"wf-block-list\">\n\t\t\t\t\t<li>\n\t\t\t\t\t\t<?php\n\t\t\t\t\t\techo wfView::create('waf\/firewall-status', array(\n\t\t\t\t\t\t\t'firewall' => $firewall,\n\t\t\t\t\t\t\t'dashboard' => $d,\n\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t?>\n\t\t\t\t\t<\/li>\n\t\t\t\t\t<li>\n\t\t\t\t\t\t<ul class=\"wf-block-list wf-block-list-horizontal wf-block-list-nowrap wf-waf-coverage\">\n\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\tif (function_exists('network_admin_url') && is_multisite()) { $optionsURL = network_admin_url('admin.php?page=WordfenceWAF&subpage=waf_options'); }\n\t\t\t\t\t\t\t\telse { $optionsURL = admin_url('admin.php?page=WordfenceWAF&subpage=waf_options'); }\n\t\t\t\t\t\t\t\techo wfView::create('common\/status-detail', array(\n\t\t\t\t\t\t\t\t\t'id' => 'waf-coverage',\n\t\t\t\t\t\t\t\t\t'percentage' => $firewall->wafStatus(),\n\t\t\t\t\t\t\t\t\t'activeColor' => ($firewall->firewallMode() == wfFirewall::FIREWALL_MODE_LEARNING ? '#ececec' : null \/* automatic *\/),\n\t\t\t\t\t\t\t\t\t'title' => __('Web Application Firewall', 'wordfence'),\n\t\t\t\t\t\t\t\t\t'subtitle' => ($firewall->firewallMode() == wfFirewall::FIREWALL_MODE_LEARNING ? __('Currently in Learning Mode', 'wordfence') : __('Stops Complex Attacks', 'wordfence')),\n\t\t\t\t\t\t\t\t\t'link' => $optionsURL,\n\t\t\t\t\t\t\t\t\t'linkLabel' => __('Manage WAF', 'wordfence'),\n\t\t\t\t\t\t\t\t\t'statusTitle' => __('Web Application Firewall Status', 'wordfence'),\n\t\t\t\t\t\t\t\t\t'statusList' => $firewall->wafStatusList(),\n\t\t\t\t\t\t\t\t\t'statusExtra' => ($firewall->firewallMode() == wfFirewall::FIREWALL_MODE_LEARNING ? wfView::create('waf\/status-tooltip-learning-mode')->render() : ''),\n\t\t\t\t\t\t\t\t\t'helpLink' => __('https:\/\/www.wordfence.com\/help\/firewall\/#firewall-status', 'wordfence'),\n\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\techo wfView::create('common\/status-detail', array(\n\t\t\t\t\t\t\t\t\t'id' => 'waf-rules',\n\t\t\t\t\t\t\t\t\t'percentage' => $firewall->ruleStatus(),\n\t\t\t\t\t\t\t\t\t'activeColor' => ($firewall->firewallMode() == wfFirewall::FIREWALL_MODE_LEARNING ? '#ececec' : null \/* automatic *\/),\n\t\t\t\t\t\t\t\t\t'title' => __('Firewall Rules: ', 'wordfence') . ($firewall->ruleMode() == wfFirewall::RULE_MODE_PREMIUM ? __('Premium', 'wordfence') : __('Community', 'wordfence')),\n\t\t\t\t\t\t\t\t\t'subtitle' => ($firewall->firewallMode() == wfFirewall::FIREWALL_MODE_LEARNING ? __('Currently in Learning Mode', 'wordfence') : ($firewall->ruleMode() == wfFirewall::RULE_MODE_PREMIUM ? __('Rules updated in real-time', 'wordfence') : __('Rule updates delayed by 30 days', 'wordfence'))),\n\t\t\t\t\t\t\t\t\t'link' => ($firewall->ruleMode() == wfFirewall::RULE_MODE_PREMIUM ? $optionsURL . '#waf-options-advanced' : 'https:\/\/www.wordfence.com\/gnl1wafUpgrade\/wordfence-signup\/'),\n\t\t\t\t\t\t\t\t\t'linkLabel' => ($firewall->ruleMode() == wfFirewall::RULE_MODE_PREMIUM ? __('Manage Firewall Rules', 'wordfence') : __('Upgrade to Premium', 'wordfence')),\n\t\t\t\t\t\t\t\t\t'linkNewWindow' => ($firewall->ruleMode() != wfFirewall::RULE_MODE_PREMIUM),\n\t\t\t\t\t\t\t\t\t'statusTitle' => __('Firewall Rules Status', 'wordfence'),\n\t\t\t\t\t\t\t\t\t'statusList' => $firewall->wafStatusList('rules'),\n\t\t\t\t\t\t\t\t\t'statusExtra' => ($firewall->firewallMode() == wfFirewall::FIREWALL_MODE_LEARNING ? wfView::create('waf\/status-tooltip-learning-mode')->render() : ''),\n\t\t\t\t\t\t\t\t\t'helpLink' => __('https:\/\/www.wordfence.com\/help\/firewall\/#firewall-status', 'wordfence'),\n\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\techo wfView::create('common\/status-detail', array(\n\t\t\t\t\t\t\t\t\t'id' => 'waf-blacklist',\n\t\t\t\t\t\t\t\t\t'percentage' => $firewall->blacklistStatus(),\n\t\t\t\t\t\t\t\t\t'title' => __('Real-Time IP Blocklist: ', 'wordfence') . ($firewall->blacklistMode() == wfFirewall::BLACKLIST_MODE_ENABLED ? __('Enabled', 'wordfence') : __('Disabled', 'wordfence')),\n\t\t\t\t\t\t\t\t\t'subtitle' => __('Blocks requests from known malicious IPs', 'wordfence'),\n\t\t\t\t\t\t\t\t\t'link' => (($firewall->ruleMode() == wfFirewall::RULE_MODE_PREMIUM) ? network_admin_url('admin.php?page=WordfenceWAF&subpage=waf_options') : 'https:\/\/www.wordfence.com\/gnl1wafUpgrade\/wordfence-signup\/'),\n\t\t\t\t\t\t\t\t\t'linkLabel' => $firewall->firewallMode() == wfFirewall::FIREWALL_MODE_DISABLED ? null : ($firewall->ruleMode() == wfFirewall::RULE_MODE_PREMIUM ? ($firewall->blacklistMode() == wfFirewall::BLACKLIST_MODE_ENABLED ? __('Manage Real-Time IP Blocklist', 'wordfence') : ($firewall->isSubDirectoryInstallation() ? null : __('Enable', 'wordfence'))) : __('Upgrade to Premium', 'wordfence')),\n\t\t\t\t\t\t\t\t\t'linkNewWindow' => ($firewall->ruleMode() != wfFirewall::RULE_MODE_PREMIUM),\n\t\t\t\t\t\t\t\t\t'statusTitle' => __('Blocklist Status', 'wordfence'),\n\t\t\t\t\t\t\t\t\t'statusList' => $firewall->wafStatusList('blacklist'),\n\t\t\t\t\t\t\t\t\t'helpLink' => __('https:\/\/www.wordfence.com\/help\/firewall\/#firewall-status', 'wordfence'),\n\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif ($firewall->ruleMode() == wfFirewall::RULE_MODE_PREMIUM && $firewall->blacklistMode() == wfFirewall::BLACKLIST_MODE_DISABLED):\n\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t\t<script type=\"application\/javascript\">\n\t\t\t\t\t\t\t\t\t(function($) {\n\t\t\t\t\t\t\t\t\t\t$(function() {\n\t\t\t\t\t\t\t\t\t\t\t$('#waf-blacklist a').on('click', function(e) {\n\t\t\t\t\t\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t\t\t\t\t\t\te.stopPropagation();\n\n\t\t\t\t\t\t\t\t\t\t\t\tWFAD.setOption('disableWAFBlacklistBlocking', 0, function() {\n\t\t\t\t\t\t\t\t\t\t\t\t\twindow.location.reload(true);\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t})(jQuery);\n\t\t\t\t\t\t\t\t<\/script>\n\t\t\t\t\t\t\t\t<?php endif; ?>\n\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\techo wfView::create('common\/status-detail', array(\n\t\t\t\t\t\t\t\t\t'id' => 'waf-brute',\n\t\t\t\t\t\t\t\t\t'percentage' => $firewall->bruteForceStatus(),\n\t\t\t\t\t\t\t\t\t'title' => __('Brute Force Protection', 'wordfence') . ($firewall->bruteForceStatus() == 0 ? __(': Disabled', 'wordfence') : ''),\n\t\t\t\t\t\t\t\t\t'subtitle' => __('Stops Password Guessing Attacks', 'wordfence'),\n\t\t\t\t\t\t\t\t\t'link' => network_admin_url('admin.php?page=WordfenceWAF&subpage=waf_options#waf-options-bruteforce'),\n\t\t\t\t\t\t\t\t\t'linkLabel' => __('Manage Brute Force Protection', 'wordfence'),\n\t\t\t\t\t\t\t\t\t'statusTitle' => __('Brute Force Protection Status', 'wordfence'),\n\t\t\t\t\t\t\t\t\t'statusList' => $firewall->bruteForceStatusList(),\n\t\t\t\t\t\t\t\t\t'helpLink' => __('https:\/\/www.wordfence.com\/help\/firewall\/#firewall-status', 'wordfence'),\n\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t<\/ul>\n\t\t\t\t\t<\/li>\n\t\t\t\t<\/ul>\n\t\t\t<\/div>\n\t\t<\/div>\n\t<\/div>\n<\/div>\n<div class=\"wf-row\">\n\t<div class=\"wf-col-xs-12\">\n\t\t<div class=\"wf-block wf-active\">\n\t\t\t<div class=\"wf-block-content\">\n\t\t\t\t<ul class=\"wf-block-list\">\n\t\t\t\t\t<li>\n\t\t\t\t\t\t<ul class=\"wf-block-list wf-block-list-horizontal wf-waf-navigation\">\n\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\techo wfView::create('common\/block-navigation-option', array(\n\t\t\t\t\t\t\t\t\t'id' => 'waf-option-rate-limiting',\n\t\t\t\t\t\t\t\t\t'img' => 'ratelimiting.svg',\n\t\t\t\t\t\t\t\t\t'title' => __('Rate Limiting', 'wordfence'),\n\t\t\t\t\t\t\t\t\t'subtitle' => __('Block crawlers that are using too many resources or stealing content', 'wordfence'),\n\t\t\t\t\t\t\t\t\t'link' => network_admin_url('admin.php?page=WordfenceWAF&subpage=waf_options#waf-options-ratelimiting'),\n\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\techo wfView::create('common\/block-navigation-option', array(\n\t\t\t\t\t\t\t\t\t'id' => 'waf-option-blocking',\n\t\t\t\t\t\t\t\t\t'img' => 'blocking.svg',\n\t\t\t\t\t\t\t\t\t'title' => __('Blocking', 'wordfence'),\n\t\t\t\t\t\t\t\t\t'subtitle' => __('Block traffic by country, IP, IP range, user agent, referrer, or hostname', 'wordfence'),\n\t\t\t\t\t\t\t\t\t'link' => '#top#blocking',\n\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t<\/ul>\n\t\t\t\t\t<\/li>\n\t\t\t\t\t<li>\n\t\t\t\t\t\t<ul class=\"wf-block-list wf-block-list-horizontal wf-waf-navigation\">\n\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\techo wfView::create('common\/block-navigation-option', array(\n\t\t\t\t\t\t\t\t\t'id' => 'waf-option-support',\n\t\t\t\t\t\t\t\t\t'img' => 'support.svg',\n\t\t\t\t\t\t\t\t\t'title' => __('Help', 'wordfence'),\n\t\t\t\t\t\t\t\t\t'subtitle' => __('Find the documentation and help you need', 'wordfence'),\n\t\t\t\t\t\t\t\t\t'link' => network_admin_url('admin.php?page=WordfenceSupport'),\n\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\t\techo wfView::create('common\/block-navigation-option', array(\n\t\t\t\t\t\t\t\t\t'id' => 'waf-option-all-options',\n\t\t\t\t\t\t\t\t\t'img' => 'options.svg',\n\t\t\t\t\t\t\t\t\t'title' => __('All Firewall Options', 'wordfence'),\n\t\t\t\t\t\t\t\t\t'subtitle' => __('Manage global and advanced firewall options', 'wordfence'),\n\t\t\t\t\t\t\t\t\t'link' => network_admin_url('admin.php?page=WordfenceWAF&subpage=waf_options'),\n\t\t\t\t\t\t\t\t))->render();\n\t\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t\t<\/li>\n\t\t\t\t\t\t<\/ul>\n\t\t\t\t\t<\/li>\n\t\t\t\t<\/ul>\n\t\t\t<\/div>\n\t\t<\/div>\n\t<\/div>\n<\/div>\n<div class=\"wf-row\">\n\t<div class=\"wf-col-xs-12 wf-col-lg-6 wf-col-lg-half-padding-right\">\n\t\t<!-- begin top ips blocked -->\n\t\t<?php include(dirname(__FILE__) . '\/dashboard\/widget_ips.php'); ?>\n\t\t<!-- end top ips blocked -->\n\t\t<!-- begin countries blocked -->\n\t\t<?php include(dirname(__FILE__) . '\/dashboard\/widget_countries.php'); ?>\n\t\t<!-- end countries blocked -->\n\t<\/div> <!-- end content block -->\n\t<div class=\"wf-col-xs-12 wf-col-lg-6 wf-col-lg-half-padding-left\">\n\t\t<!-- begin firewall summary site -->\n\t\t<?php include(dirname(__FILE__) . '\/dashboard\/widget_localattacks.php'); ?>\n\t\t<!-- end firewall summary site -->\n\t\t<!-- begin total attacks blocked network -->\n\t\t<?php include(dirname(__FILE__) . '\/dashboard\/widget_networkattacks.php'); ?>\n\t\t<!-- end total attacks blocked network -->\n\t\t<!-- begin recent logins -->\n\t\t<?php include(dirname(__FILE__) . '\/dashboard\/widget_logins.php'); ?>\n\t\t<!-- end recent logins -->\n\t<\/div> <!-- end content block -->\n<\/div> <!-- end row -->\n<?php if (wfOnboardingController::willShowNewTour(wfOnboardingController::TOUR_FIREWALL)): ?>\n\t<script type=\"application\/javascript\">\n\t\t(function($) {\n\t\t\t$(function() {\n\t\t\t\tWFAD.setUpFirewallTour = function() {\n\t\t\t\t\tWFAD.tour1 = function () {\n\t\t\t\t\t\tWFAD.tour('wfWAFNewTour1', 'wf-section-firewall', 'top', 'left', null, WFAD.tour2);\n\t\t\t\t\t};\n\t\t\t\t\tWFAD.tour2 = function () {\n\t\t\t\t\t\tWFAD.tour('wfWAFNewTour2', 'waf-coverage', 'top', 'left', WFAD.tour1, WFAD.tour3);\n\t\t\t\t\t};\n\t\t\t\t\tWFAD.tour3 = function () {\n\t\t\t\t\t\tWFAD.tour('wfWAFNewTour3', 'waf-brute', 'right', 'right', WFAD.tour2, WFAD.tour4);\n\t\t\t\t\t};\n\t\t\t\t\tWFAD.tour4 = function () {\n\t\t\t\t\t\tWFAD.tour('wfWAFNewTour4', 'waf-option-all-options', 'right', 'right', WFAD.tour3, WFAD.tourComplete);\n\t\t\t\t\t};\n\t\t\t\t\tWFAD.tourComplete = function () {\n\t\t\t\t\t\tWFAD.tourFinish('<?php echo esc_attr(wfOnboardingController::TOUR_FIREWALL); ?>');\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\tWFAD.wafTourShown = false;\n\t\t\t\t<?php if (wfOnboardingController::shouldShowNewTour(wfOnboardingController::TOUR_FIREWALL)): ?>\n\t\t\t\t$(window).on('wfTabChange', function(e, tab) {\n\t\t\t\t\tif (tab == 'waf' && !WFAD.wafTourShown) {\n\t\t\t\t\t\tWFAD.wafTourShown = true;\n\t\t\t\t\t\tWFAD.setUpFirewallTour();\n\t\t\t\t\t\tif (!WFAD.isSmallScreen) { WFAD.tour1(); }\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tif ($('#waf').hasClass('wf-active')) {\n\t\t\t\t\tWFAD.wafTourShown = true;\n\t\t\t\t\tWFAD.setUpFirewallTour();\n\t\t\t\t\tif (!WFAD.isSmallScreen) { WFAD.tour1(); }\n\t\t\t\t}\n\t\t\t\t<?php endif; ?>\n\t\t\t});\n\t\t})(jQuery);\n\t<\/script>\n\n\t<script type=\"text\/x-jquery-template\" id=\"wfWAFNewTour1\">\n\t\t<div>\n\t\t\t<h3><?php esc_html_e('The Wordfence firewall protects your sites from attackers', 'wordfence'); ?><\/h3>\n\t\t\t<p><?php esc_html_e('This is where you can monitor the work Wordfence is doing to protect your site and also where you can manage the options to optimize the firewall\\'s configuration.', 'wordfence'); ?><\/p>\n\t\t\t<div class=\"wf-pointer-footer\">\n\t\t\t\t<ul class=\"wf-tour-pagination\">\n\t\t\t\t\t<li class=\"wf-active\">&bullet;<\/li>\n\t\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t<\/ul>\n\t\t\t\t<div id=\"wf-tour-continue\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-primary\" role=\"button\"><?php esc_html_e('Next', 'wordfence'); ?><\/a><\/div>\n\t\t\t<\/div>\n\t\t\t<div id=\"wf-tour-close\"><a href=\"#\" role=\"button\"><i class=\"wf-fa wf-fa-times-circle\" aria-hidden=\"true\"><\/i><\/a><\/div>\n\t\t<\/div>\n\t<\/script>\n\t<script type=\"text\/x-jquery-template\" id=\"wfWAFNewTour2\">\n\t\t<div>\n\t\t\t<h3><?php esc_html_e('Web Application Firewall (WAF)', 'wordfence'); ?><\/h3>\n\t\t\t<p><?php esc_html_e('The Wordfence Web Application Firewall blocks known and emerging attacks using firewall rules. When you first install the WAF, it will be in learning mode. This allows Wordfence to learn about your site so that we can understand how to protect it and how to allow normal visitors through the firewall. We recommend you let Wordfence learn for a week before you enable the firewall.', 'wordfence'); ?><\/p>\n\t\t\t<div class=\"wf-pointer-footer\">\n\t\t\t\t<ul class=\"wf-tour-pagination\">\n\t\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t\t<li class=\"wf-active\">&bullet;<\/li>\n\t\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t<\/ul>\n\t\t\t\t<div id=\"wf-tour-previous\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-default\" role=\"button\"><?php esc_html_e('Previous', 'wordfence'); ?><\/a><\/div>\n\t\t\t\t<div id=\"wf-tour-continue\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-primary\" role=\"button\"><?php esc_html_e('Next', 'wordfence'); ?><\/a><\/div>\n\t\t\t<\/div>\n\t\t\t<div id=\"wf-tour-close\"><a href=\"#\" role=\"button\"><i class=\"wf-fa wf-fa-times-circle\" aria-hidden=\"true\"><\/i><\/a><\/div>\n\t\t<\/div>\n\t<\/script>\n\t<script type=\"text\/x-jquery-template\" id=\"wfWAFNewTour3\">\n\t\t<div>\n\t\t\t<h3><?php esc_html_e('Brute Force Protection', 'wordfence'); ?><\/h3>\n\t\t\t<p><?php esc_html_e('Wordfence protects your site from password-guessing attacks by locking out attackers and helping you avoid weak passwords.', 'wordfence'); ?><\/p>\n\t\t\t<div class=\"wf-pointer-footer\">\n\t\t\t\t<ul class=\"wf-tour-pagination\">\n\t\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t\t<li class=\"wf-active\">&bullet;<\/li>\n\t\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t<\/ul>\n\t\t\t\t<div id=\"wf-tour-previous\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-default\" role=\"button\"><?php esc_html_e('Previous', 'wordfence'); ?><\/a><\/div>\n\t\t\t\t<div id=\"wf-tour-continue\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-primary\" role=\"button\"><?php esc_html_e('Next', 'wordfence'); ?><\/a><\/div>\n\t\t\t<\/div>\n\t\t\t<div id=\"wf-tour-close\"><a href=\"#\" role=\"button\"><i class=\"wf-fa wf-fa-times-circle\" aria-hidden=\"true\"><\/i><\/a><\/div>\n\t\t<\/div>\n\t<\/script>\n\t<script type=\"text\/x-jquery-template\" id=\"wfWAFNewTour4\">\n\t\t<div>\n\t\t\t<h3><?php esc_html_e('Firewall Options', 'wordfence'); ?><\/h3>\n\t\t\t<p class=\"wf-center\"><svg viewBox=\"0 0 100.11 100.11\" class=\"wf-icon\"><path d=\"M99.59,41.42a2.06,2.06,0,0,0-1.37-.82L86.3,38.78a39.34,39.34,0,0,0-2.67-6.39q1.17-1.63,3.52-4.6t3.32-4.33A2.52,2.52,0,0,0,91,22a2.1,2.1,0,0,0-.46-1.43Q88.18,17.2,79.78,9.45a2.52,2.52,0,0,0-1.63-.65,2.12,2.12,0,0,0-1.57.59l-9.25,7a40.09,40.09,0,0,0-5.87-2.41L59.64,2a1.92,1.92,0,0,0-.75-1.4A2.46,2.46,0,0,0,57.29,0H42.82a2.19,2.19,0,0,0-2.34,1.82,106,106,0,0,0-1.89,12.12,37.62,37.62,0,0,0-5.93,2.48l-9-7A2.78,2.78,0,0,0,22,8.8q-1.44,0-6.16,4.66a64.88,64.88,0,0,0-6.42,7A2.75,2.75,0,0,0,8.8,22a2.44,2.44,0,0,0,.65,1.56q4.37,5.28,7,9a32.38,32.38,0,0,0-2.54,6L1.76,40.34a2,2,0,0,0-1.24.85A2.5,2.5,0,0,0,0,42.69V57.16a2.44,2.44,0,0,0,.52,1.53,2,2,0,0,0,1.37.82l11.93,1.76a31.91,31.91,0,0,0,2.67,6.45Q15.31,69.35,13,72.31T9.65,76.65a2.54,2.54,0,0,0-.07,3q2.54,3.52,10.75,11a2.25,2.25,0,0,0,1.63.71,2.35,2.35,0,0,0,1.63-.59l9.19-7a40.54,40.54,0,0,0,5.87,2.41l1.82,12a1.92,1.92,0,0,0,.75,1.4,2.45,2.45,0,0,0,1.6.55H57.29a2.2,2.2,0,0,0,2.35-1.82,107.41,107.41,0,0,0,1.89-12.12,37.19,37.19,0,0,0,5.93-2.48l9,7a3.18,3.18,0,0,0,1.69.59q1.43,0,6.13-4.62a65.86,65.86,0,0,0,6.45-7,2.16,2.16,0,0,0,.59-1.5,2.51,2.51,0,0,0-.65-1.63q-4.69-5.74-7-9a41.57,41.57,0,0,0,2.54-5.93l12.06-1.82a2,2,0,0,0,1.3-.85,2.52,2.52,0,0,0,.52-1.5V43a2.46,2.46,0,0,0-.52-1.53ZM61.85,61.86a16.08,16.08,0,0,1-11.8,4.89A16.69,16.69,0,0,1,33.37,50.06,16.69,16.69,0,0,1,50.06,33.37,16.69,16.69,0,0,1,66.74,50.06a16.08,16.08,0,0,1-4.89,11.8Zm0,0\"><\/path><\/svg><\/p>\n\t\t\t<p><?php esc_html_e('Set up the way you want the firewall to protect your site including the web application firewall, brute force protection, rate limiting, and blocking.', 'wordfence'); ?><\/p>\n\t\t\t<div class=\"wf-pointer-footer\">\n\t\t\t\t<ul class=\"wf-tour-pagination\">\n\t\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t\t<li>&bullet;<\/li>\n\t\t\t\t\t<li class=\"wf-active\">&bullet;<\/li>\n\t\t\t\t<\/ul>\n\t\t\t\t<div id=\"wf-tour-previous\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-default\" role=\"button\"><?php esc_html_e('Previous', 'wordfence'); ?><\/a><\/div>\n\t\t\t\t<div id=\"wf-tour-continue\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-primary\" role=\"button\"><?php esc_html_e('Got it', 'wordfence'); ?><\/a><\/div>\n\t\t\t<\/div>\n\t\t\t<div id=\"wf-tour-close\"><a href=\"#\" role=\"button\"><i class=\"wf-fa wf-fa-times-circle\" aria-hidden=\"true\"><\/i><\/a><\/div>\n\t\t<\/div>\n\t<\/script>\n<?php endif; ?>\n\n<?php if (wfOnboardingController::willShowUpgradeTour(wfOnboardingController::TOUR_FIREWALL)): ?>\n\t<script type=\"application\/javascript\">\n\t\t(function($) {\n\t\t\t$(function() {\n\t\t\t\tWFAD.setUpFirewallTour = function() {\n\t\t\t\t\tWFAD.tour1 = function() {\n\t\t\t\t\t\tWFAD.tour('wfWAFUpgradeTour1', 'waf-option-all-options', 'right', 'right', null, WFAD.tourComplete);\n\t\t\t\t\t};\n\t\t\t\t\tWFAD.tourComplete = function() { WFAD.tourFinish('<?php echo esc_attr(wfOnboardingController::TOUR_FIREWALL); ?>'); };\n\t\t\t\t};\n\n\t\t\t\tWFAD.wafTourShown = false;\n\t\t\t\t<?php if (wfOnboardingController::shouldShowUpgradeTour(wfOnboardingController::TOUR_FIREWALL)): ?>\n\t\t\t\t$(window).on('wfTabChange', function(e, tab) {\n\t\t\t\t\tif (tab == 'waf' && !WFAD.wafTourShown) {\n\t\t\t\t\t\tWFAD.wafTourShown = true;\n\t\t\t\t\t\tWFAD.setUpFirewallTour();\n\t\t\t\t\t\tif (!WFAD.isSmallScreen) { WFAD.tour1(); }\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif ($('#waf').hasClass('wf-active')) {\n\t\t\t\t\tWFAD.wafTourShown = true;\n\t\t\t\t\tWFAD.setUpFirewallTour();\n\t\t\t\t\tif (!WFAD.isSmallScreen) { WFAD.tour1(); }\n\t\t\t\t}\n\t\t\t\t<?php endif; ?>\n\t\t\t});\n\t\t})(jQuery);\n\t<\/script>\n\n\t<script type=\"text\/x-jquery-template\" id=\"wfWAFUpgradeTour1\">\n\t\t<div>\n\t\t\t<h3><?php esc_html_e('Firewall Options', 'wordfence'); ?><\/h3>\n\t\t\t<p class=\"wf-center\"><svg viewBox=\"0 0 100.11 100.11\" class=\"wf-icon\"><path d=\"M99.59,41.42a2.06,2.06,0,0,0-1.37-.82L86.3,38.78a39.34,39.34,0,0,0-2.67-6.39q1.17-1.63,3.52-4.6t3.32-4.33A2.52,2.52,0,0,0,91,22a2.1,2.1,0,0,0-.46-1.43Q88.18,17.2,79.78,9.45a2.52,2.52,0,0,0-1.63-.65,2.12,2.12,0,0,0-1.57.59l-9.25,7a40.09,40.09,0,0,0-5.87-2.41L59.64,2a1.92,1.92,0,0,0-.75-1.4A2.46,2.46,0,0,0,57.29,0H42.82a2.19,2.19,0,0,0-2.34,1.82,106,106,0,0,0-1.89,12.12,37.62,37.62,0,0,0-5.93,2.48l-9-7A2.78,2.78,0,0,0,22,8.8q-1.44,0-6.16,4.66a64.88,64.88,0,0,0-6.42,7A2.75,2.75,0,0,0,8.8,22a2.44,2.44,0,0,0,.65,1.56q4.37,5.28,7,9a32.38,32.38,0,0,0-2.54,6L1.76,40.34a2,2,0,0,0-1.24.85A2.5,2.5,0,0,0,0,42.69V57.16a2.44,2.44,0,0,0,.52,1.53,2,2,0,0,0,1.37.82l11.93,1.76a31.91,31.91,0,0,0,2.67,6.45Q15.31,69.35,13,72.31T9.65,76.65a2.54,2.54,0,0,0-.07,3q2.54,3.52,10.75,11a2.25,2.25,0,0,0,1.63.71,2.35,2.35,0,0,0,1.63-.59l9.19-7a40.54,40.54,0,0,0,5.87,2.41l1.82,12a1.92,1.92,0,0,0,.75,1.4,2.45,2.45,0,0,0,1.6.55H57.29a2.2,2.2,0,0,0,2.35-1.82,107.41,107.41,0,0,0,1.89-12.12,37.19,37.19,0,0,0,5.93-2.48l9,7a3.18,3.18,0,0,0,1.69.59q1.43,0,6.13-4.62a65.86,65.86,0,0,0,6.45-7,2.16,2.16,0,0,0,.59-1.5,2.51,2.51,0,0,0-.65-1.63q-4.69-5.74-7-9a41.57,41.57,0,0,0,2.54-5.93l12.06-1.82a2,2,0,0,0,1.3-.85,2.52,2.52,0,0,0,.52-1.5V43a2.46,2.46,0,0,0-.52-1.53ZM61.85,61.86a16.08,16.08,0,0,1-11.8,4.89A16.69,16.69,0,0,1,33.37,50.06,16.69,16.69,0,0,1,50.06,33.37,16.69,16.69,0,0,1,66.74,50.06a16.08,16.08,0,0,1-4.89,11.8Zm0,0\"><\/path><\/svg><\/p>\n\t\t\t<p><?php esc_html_e('All of the Firewall settings are now located here. This includes configuration options for the web application firewall, brute force protection, rate limiting, allowlisted URLs, and blocking.', 'wordfence'); ?><\/p>\n\t\t\t<div class=\"wf-pointer-footer\">\n\t\t\t\t<ul class=\"wf-tour-pagination\">\n\t\t\t\t\t<li class=\"wf-active\">&bullet;<\/li>\n\t\t\t\t<\/ul>\n\t\t\t\t<div id=\"wf-tour-continue\"><a href=\"#\" class=\"wf-onboarding-btn wf-onboarding-btn-primary\" role=\"button\"><?php esc_html_e('Got it', 'wordfence'); ?><\/a><\/div>\n\t\t\t<\/div>\n\t\t\t<div id=\"wf-tour-close\"><a href=\"#\" role=\"button\"><i class=\"wf-fa wf-fa-times-circle\" aria-hidden=\"true\"><\/i><\/a><\/div>\n\t\t<\/div>\n\t<\/script>\n<?php endif; ?>"},{"base":"plugins","rel":"wordfence\/waf\/wfWAFIPBlocksController.php","ext":"php","size":20146,"mtime":1757312769,"type":"text","content":"<?php\nif (!defined('WFWAF_RUN_COMPLETE')) {\n\nrequire_once __DIR__ . '\/..\/vendor\/wordfence\/wf-waf\/src\/lib\/shutdown.php';\n\nclass wfWAFIPBlocksController\n{\n\tconst WFWAF_BLOCK_UAREFIPRANGE = 'UA\/Referrer\/IP Range not allowed';\n\tconst WFWAF_BLOCK_COUNTRY = 'blocked access via country blocking';\n\tconst WFWAF_BLOCK_COUNTRY_REDIR = 'blocked access via country blocking and redirected to URL';\n\tconst WFWAF_BLOCK_COUNTRY_BYPASS_REDIR = 'redirected to bypass URL';\n\tconst WFWAF_BLOCK_WFSN = 'Blocked by Wordfence Security Network';\n\tconst WFWAF_BLOCK_BADPOST = 'POST received with blank user-agent and referer';\n\tconst WFWAF_BLOCK_BANNEDURL = 'Accessed a banned URL.';\n\tconst WFWAF_BLOCK_FAKEGOOGLE = 'Fake Google crawler automatically blocked';\n\tconst WFWAF_BLOCK_LOGINSEC = 'Blocked by login security setting.';\n\tconst WFWAF_BLOCK_LOGINSEC_FORGOTPASSWD = 'Exceeded the maximum number of tries to recover their password'; \/\/substring search\n\tconst WFWAF_BLOCK_LOGINSEC_FAILURES = 'Exceeded the maximum number of login failures'; \/\/substring search\n\tconst WFWAF_BLOCK_THROTTLEGLOBAL = 'Exceeded the maximum global requests per minute for crawlers or humans.';\n\tconst WFWAF_BLOCK_THROTTLESCAN = 'Exceeded the maximum number of 404 requests per minute for a known security vulnerability.';\n\tconst WFWAF_BLOCK_THROTTLECRAWLER = 'Exceeded the maximum number of requests per minute for crawlers.';\n\tconst WFWAF_BLOCK_THROTTLECRAWLERNOTFOUND = 'Exceeded the maximum number of page not found errors per minute for a crawler.';\n\tconst WFWAF_BLOCK_THROTTLEHUMAN = 'Exceeded the maximum number of page requests per minute for humans.';\n\tconst WFWAF_BLOCK_THROTTLEHUMANNOTFOUND = 'Exceeded the maximum number of page not found errors per minute for humans.';\n\t\n\tprotected static $_currentController = null;\n\n\tpublic static function currentController() {\n\t\tif (self::$_currentController === null) {\n\t\t\tself::$_currentController = new wfWAFIPBlocksController();\n\t\t}\n\t\treturn self::$_currentController;\n\t}\n\t\n\tpublic static function setCurrentController($currentController) {\n\t\tself::$_currentController = $currentController;\n\t}\n\t\n\t\/**\n\t * Schedules a config sync to happen at the end of the current process's execution.\n\t *\/\n\tpublic static function setNeedsSynchronizeConfigSettings() {\n\t\tstatic $willSynchronize = false;\n\t\tif (!$willSynchronize) {\n\t\t\t$willSynchronize = true;\n\t\t\twfShutdownRegistry::getDefaultInstance()->register('wfWAFIPBlocksController::synchronizeConfigSettings');\n\t\t}\n\t}\n\t\n\tpublic static function synchronizeConfigSettings() {\n\t\tif (!class_exists('wfConfig') || !wfConfig::tableExists() || !wfWAF::getInstance()) { \/\/ Ensure this is only called when WordPress and the plugin are fully loaded\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tstatic $isSynchronizing = false;\n\t\tif ($isSynchronizing) {\n\t\t\treturn;\n\t\t}\n\t\t$isSynchronizing = true;\n\t\t\n\t\tglobal $wpdb;\n\t\t$suppressed = $wpdb->suppress_errors(!(defined('WFWAF_DEBUG') && WFWAF_DEBUG));\n\t\t\n\t\t\/\/ Pattern Blocks\n\t\t$blocks = wfBlock::patternBlocks(true);\n\t\t$patternBlocks = array();\n\t\tforeach ($blocks as $b) {\n\t\t\t$patternBlocks[] = array('id' => $b->id, 'ipRange' => $b->ipRange, 'hostnamePattern' => $b->hostname, 'uaPattern' => $b->userAgent, 'refPattern' => $b->referrer, 'expiration' => $b->expiration);\n\t\t}\n\t\t\n\t\t\/\/ Country Blocks\n\t\t$countryBlocks = array();\n\t\t$countryBlockEntries = wfBlock::countryBlocks(true);\n\t\t$countryBlocks['blocks'] = array();\n\t\tforeach ($countryBlockEntries as $b) {\n\t\t\t$reason = wfI18n::__('Access from your area has been temporarily limited for security reasons', 'wordfence');\n\t\t\t\n\t\t\t$countryBlocks['blocks'][] = array(\n\t\t\t\t'id' => $b->id,\n\t\t\t\t'countries' => $b->countries,\n\t\t\t\t'blockLogin' => $b->blockLogin,\n\t\t\t\t'blockSite' => $b->blockSite,\n\t\t\t\t'reason' => $reason,\n\t\t\t\t'expiration' => $b->expiration,\n\t\t\t);\n\t\t}\n\t\t$countryBlocks['action'] = wfConfig::get('cbl_action', false);\n\t\t$countryBlocks['loggedInBlocked'] = wfConfig::get('cbl_loggedInBlocked', false);\n\t\t$countryBlocks['bypassRedirURL'] = wfConfig::get('cbl_bypassRedirURL', '');\n\t\t$countryBlocks['bypassRedirDest'] = wfConfig::get('cbl_bypassRedirDest', '');\n\t\t$countryBlocks['bypassViewURL'] = wfConfig::get('cbl_bypassViewURL', '');\n\t\t$countryBlocks['redirURL'] = wfConfig::get('cbl_redirURL', '');\n\t\t$countryBlocks['cookieVal'] = wfBlock::countryBlockingBypassCookieValue();\n\t\t\n\t\t\/\/Other Blocks\n\t\t$otherBlocks = array('blockedTime' => wfConfig::get('blockedTime', 0));\n\t\t$otherBlockEntries = wfBlock::ipBlocks(true);\n\t\t$otherBlocks['blocks'] = array();\n\t\tforeach ($otherBlockEntries as $b) {\n\t\t\t$reason = $b->reason;\n\t\t\tif ($b->type == wfBlock::TYPE_IP_MANUAL || $b->type == wfBlock::TYPE_IP_AUTOMATIC_PERMANENT) {\n\t\t\t\t$reason = wfI18n::__('Manual block by administrator', 'wordfence');\n\t\t\t}\n\t\t\t\n\t\t\t$otherBlocks['blocks'][] = array(\n\t\t\t\t'id' => $b->id,\n\t\t\t\t'IP' => base64_encode(wfUtils::inet_pton($b->ip)),\n\t\t\t\t'reason' => $reason,\n\t\t\t\t'expiration' => $b->expiration,\n\t\t\t);\n\t\t}\n\t\t\n\t\t\/\/Lockouts\n\t\t$lockoutEntries = wfBlock::lockouts(true);\n\t\t$lockoutSecs = wfConfig::get('loginSec_lockoutMins') * 60;\n\t\t$lockouts = array('lockedOutTime' => $lockoutSecs, 'lockouts' => array());\n\t\tforeach ($lockoutEntries as $l) {\n\t\t\t$lockouts['lockouts'][] = array(\n\t\t\t\t'id' => $l->id,\n\t\t\t\t'IP' => base64_encode(wfUtils::inet_pton($l->ip)),\n\t\t\t\t'reason' => $l->reason,\n\t\t\t\t'expiration' => $l->expiration,\n\t\t\t);\n\t\t}\n\t\t\n\t\t\/\/ Save it\n\t\ttry {\n\t\t\t$patternBlocksJSON = wfWAFUtils::json_encode($patternBlocks);\n\t\t\twfWAF::getInstance()->getStorageEngine()->setConfig('patternBlocks', $patternBlocksJSON, 'synced');\n\t\t\t$countryBlocksJSON = wfWAFUtils::json_encode($countryBlocks);\n\t\t\twfWAF::getInstance()->getStorageEngine()->setConfig('countryBlocks', $countryBlocksJSON, 'synced');\n\t\t\t$otherBlocksJSON = wfWAFUtils::json_encode($otherBlocks);\n\t\t\twfWAF::getInstance()->getStorageEngine()->setConfig('otherBlocks', $otherBlocksJSON, 'synced');\n\t\t\t$lockoutsJSON = wfWAFUtils::json_encode($lockouts);\n\t\t\twfWAF::getInstance()->getStorageEngine()->setConfig('lockouts', $lockoutsJSON, 'synced');\n\t\t\t\n\t\t\twfWAF::getInstance()->getStorageEngine()->setConfig('advancedBlockingEnabled', wfConfig::get('firewallEnabled'), 'synced');\n\t\t\twfWAF::getInstance()->getStorageEngine()->setConfig('disableWAFIPBlocking', wfConfig::get('disableWAFIPBlocking'), 'synced');\n\t\t}\n\t\tcatch (Exception $e) {\n\t\t\t\/\/ Do nothing\n\t\t}\n\t\t$isSynchronizing = false;\n\t\t\n\t\t$wpdb->suppress_errors($suppressed);\n\t}\n\t\n\t\/**\n\t * @param wfWAFRequest $request\n\t * @return bool|string If not blocked, returns false. Otherwise a string of the reason it was blocked or true. \n\t *\/\n\tpublic function shouldBlockRequest($request) {\n\t\t\/\/ Checking the user whitelist is done before reaching this call\n\t\t\n\t\t$ip = $request->getIP();\n\t\t\n\t\t\/\/Check the system whitelist\n\t\tif ($this->checkForWhitelisted($ip)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t\/\/Let the plugin handle these\n\t\t$wfFunc = $request->getQueryString('_wfsf');\n\t\tif ($wfFunc == 'unlockEmail' || $wfFunc == 'unlockAccess') { \/\/ Can't check validity here, let it pass through to plugin level where it can\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t$logHuman = $request->getQueryString('wordfence_lh');\n\t\tif ($logHuman !== null) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t\/\/Start block checks\n\t\t$ipNum = wfWAFUtils::inet_pton($ip);\n\t\t$hostname = null;\n\t\t$ua = $request->getHeaders('User-Agent'); if ($ua === null) { $ua = ''; }\n\t\t$referer = $request->getHeaders('Referer'); if ($referer === null) { $referer = ''; }\n\t\t\n\t\t$isPaid = false;\n\t\ttry {\n\t\t\t$isPaid = wfWAF::getInstance()->getStorageEngine()->getConfig('isPaid', null, 'synced');\n\t\t\t$pluginABSPATH = wfWAF::getInstance()->getStorageEngine()->getConfig('pluginABSPATH', null, 'synced');\n\t\t\t\n\t\t\t$patternBlocksJSON = wfWAF::getInstance()->getStorageEngine()->getConfig('patternBlocks', null, 'synced');\n\t\t\t$countryBlocksJSON = wfWAF::getInstance()->getStorageEngine()->getConfig('countryBlocks', null, 'synced');\n\t\t\t$otherBlocksJSON = wfWAF::getInstance()->getStorageEngine()->getConfig('otherBlocks', null, 'synced');\n\t\t\t$lockoutsJSON = wfWAF::getInstance()->getStorageEngine()->getConfig('lockouts', null, 'synced');\n\t\t}\n\t\tcatch (Exception $e) {\n\t\t\t\/\/ Do nothing\n\t\t}\n\t\t\n\t\tif (isset($_SERVER['SCRIPT_FILENAME']) && (strpos($_SERVER['SCRIPT_FILENAME'], $pluginABSPATH . \"wp-admin\/\") === 0 || strpos($_SERVER['SCRIPT_FILENAME'], $pluginABSPATH . \"wp-content\/\") === 0 || strpos($_SERVER['SCRIPT_FILENAME'], $pluginABSPATH . \"wp-includes\/\") === 0)) {\n\t\t\treturn false; \/\/Rely on WordPress's own access control and blocking at the plugin level\n\t\t}\n\t\t\n\t\t\/\/ Pattern Blocks from the Advanced Blocking page (IP Range, UA, Referer)\n\t\t$patternBlocks = @wfWAFUtils::json_decode($patternBlocksJSON, true);\n\t\tif (is_array($patternBlocks)) {\n\t\t\t\/\/ Instead of a long block of if\/else statements, using bitshifting to generate an expected value and a found value\n\t\t\t$ipRangeOffset = 1;\n\t\t\t$uaPatternOffset = 2;\n\t\t\t$refPatternOffset = 3;\n\t\t\t\n\t\t\tforeach ($patternBlocks as $b) {\n\t\t\t\t$expectedBits = 0;\n\t\t\t\t$foundBits = 0;\n\t\t\t\t\n\t\t\t\tif (isset($b['expiration']) && $b['expiration'] < time() && $b['expiration'] != 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!empty($b['ipRange'])) {\n\t\t\t\t\t$expectedBits |= (1 << $ipRangeOffset);\n\t\t\t\t\t\n\t\t\t\t\t$range = new wfWAFUserIPRange($b['ipRange']); \n\t\t\t\t\tif ($range->isIPInRange($ip)) {\n\t\t\t\t\t\t$foundBits |= (1 << $ipRangeOffset);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!empty($b['hostnamePattern'])) {\n\t\t\t\t\t$expectedBits |= (1 << $ipRangeOffset);\n\t\t\t\t\tif ($hostname === null) {\n\t\t\t\t\t\t$hostname = wfWAFUtils::reverseLookup($ip);\n\t\t\t\t\t}\n\t\t\t\t\tif (preg_match(wfWAFUtils::patternToRegex($b['hostnamePattern']), $hostname)) {\n\t\t\t\t\t\t$foundBits |= (1 << $ipRangeOffset);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!empty($b['uaPattern'])) {\n\t\t\t\t\t$expectedBits |= (1 << $uaPatternOffset);\n\t\t\t\t\tif (wfWAFUtils::isUABlocked($b['uaPattern'], $ua)) {\n\t\t\t\t\t\t$foundBits |= (1 << $uaPatternOffset);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!empty($b['refPattern'])) {\n\t\t\t\t\t$expectedBits |= (1 << $refPatternOffset);\n\t\t\t\t\tif (wfWAFUtils::isRefererBlocked($b['refPattern'], $referer)) {\n\t\t\t\t\t\t$foundBits |= (1 << $refPatternOffset);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ($foundBits === $expectedBits && $expectedBits > 0) {\n\t\t\t\t\treturn array('action' => self::WFWAF_BLOCK_UAREFIPRANGE, 'id' => $b['id']);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\/\/ End Pattern Blocks\n\t\t\n\t\t\/\/ Country Blocking\n\t\tif ($isPaid) {\n\t\t\t$countryBlocks = @wfWAFUtils::json_decode($countryBlocksJSON, true);\n\t\t\tif (is_array($countryBlocks) && isset($countryBlocks['blocks'])) {\n\t\t\t\t$blocks = $countryBlocks['blocks'];\n\t\t\t\tforeach ($blocks as $b) {\n\t\t\t\t\t$blockedCountries = $b['countries'];\n\t\t\t\t\t$bareRequestURI = wfWAFUtils::extractBareURI($request->getURI());\n\t\t\t\t\t$bareBypassRedirURI = wfWAFUtils::extractBareURI($countryBlocks['bypassRedirURL']);\n\t\t\t\t\t$skipCountryBlocking = false;\n\t\t\t\t\t\n\t\t\t\t\tif ($bareBypassRedirURI && $bareRequestURI == $bareBypassRedirURI) { \/\/ Run this before country blocking because even if the user isn't blocked we need to set the bypass cookie so they can bypass future blocks.\n\t\t\t\t\t\tif ($countryBlocks['bypassRedirDest']) {\n\t\t\t\t\t\t\tsetcookie('wfCBLBypass', $countryBlocks['cookieVal'], time() + (86400 * 365), '\/', null, $this->isFullSSL(), true);\n\t\t\t\t\t\t\treturn array('action' => self::WFWAF_BLOCK_COUNTRY_BYPASS_REDIR, 'id' => $b['id']);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$bareBypassViewURI = wfWAFUtils::extractBareURI($countryBlocks['bypassViewURL']);\n\t\t\t\t\tif ($bareBypassViewURI && $bareBypassViewURI == $bareRequestURI) {\n\t\t\t\t\t\tsetcookie('wfCBLBypass', $countryBlocks['cookieVal'], time() + (86400 * 365), '\/', null, $this->isFullSSL(), true);\n\t\t\t\t\t\t$skipCountryBlocking = true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$bypassCookieSet = false;\n\t\t\t\t\t$bypassCookie = $request->getCookies('wfCBLBypass');\n\t\t\t\t\tif (isset($bypassCookie) && $bypassCookie == $countryBlocks['cookieVal']) {\n\t\t\t\t\t\t$bypassCookieSet = true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (!$skipCountryBlocking && $blockedCountries && !$bypassCookieSet) {\n\t\t\t\t\t\t$isAuthRequest = (strpos($bareRequestURI, '\/wp-login.php') !== false);\n\t\t\t\t\t\t$isXMLRPC = (strpos($bareRequestURI, '\/xmlrpc.php') !== false);\n\t\t\t\t\t\t$isUserLoggedIn = wfWAF::getInstance()->parseAuthCookie() !== false;\n\t\t\t\t\t\t\n\t\t\t\t\t\t\/\/ If everything is checked, make sure this always runs.\n\t\t\t\t\t\tif ($countryBlocks['loggedInBlocked'] && $b['blockLogin'] && $b['blockSite']) {\n\t\t\t\t\t\t\tif ($blocked = $this->checkForBlockedCountry($countryBlocks, $ip, $bareRequestURI)) { $blocked['id'] = $b['id']; return $blocked; }\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\/\/ Block logged in users.\n\t\t\t\t\t\tif ($countryBlocks['loggedInBlocked'] && $isUserLoggedIn) {\n\t\t\t\t\t\t\tif ($blocked = $this->checkForBlockedCountry($countryBlocks, $ip, $bareRequestURI)) { $blocked['id'] = $b['id']; return $blocked; }\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\/\/ Block the login form itself and any attempt to authenticate.\n\t\t\t\t\t\tif ($b['blockLogin'] && $isAuthRequest) {\n\t\t\t\t\t\t\tif ($blocked = $this->checkForBlockedCountry($countryBlocks, $ip, $bareRequestURI)) { $blocked['id'] = $b['id']; return $blocked; }\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\/\/ Block requests that aren't to the login page, xmlrpc.php, or a user already logged in.\n\t\t\t\t\t\tif ($b['blockSite'] && !$isAuthRequest && !$isXMLRPC && !$isUserLoggedIn) {\n\t\t\t\t\t\t\tif ($blocked = $this->checkForBlockedCountry($countryBlocks, $ip, $bareRequestURI)) { $blocked['id'] = $b['id']; return $blocked; }\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\/\/ XMLRPC is inaccesible when public portion of the site and auth is disabled.\n\t\t\t\t\t\tif ($b['blockLogin'] && $b['blockSite'] && $isXMLRPC) {\n\t\t\t\t\t\t\tif ($blocked = $this->checkForBlockedCountry($countryBlocks, $ip, $bareRequestURI)) { $blocked['id'] = $b['id']; return $blocked; }\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t\/\/ Any bypasses and other block possibilities will be checked at the plugin level once WordPress loads\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\/\/ End Country Blocking\n\t\t\n\t\t\/\/ Other Blocks\n\t\t$otherBlocks = @wfWAFUtils::json_decode($otherBlocksJSON, true);\n\t\tif (is_array($otherBlocks)) {\n\t\t\t$blocks = $otherBlocks['blocks'];\n\t\t\t$bareRequestURI = wfWAFUtils::extractBareURI($request->getURI());\n\t\t\t$isAuthRequest = (stripos($bareRequestURI, '\/wp-login.php') !== false);\n\t\t\tforeach ($blocks as $b) {\n\t\t\t\tif (isset($b['expiration']) && $b['expiration'] < time() && $b['expiration'] != 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (base64_decode($b['IP']) != $ipNum) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ($isAuthRequest && isset($b['wfsn']) && $b['wfsn']) {\n\t\t\t\t\treturn array('action' => self::WFWAF_BLOCK_WFSN, 'id' => $b['id']);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn array('action' => (empty($b['reason']) ? '' : $b['reason']), 'id' => $b['id'], 'block' => true);\n\t\t\t}\n\t\t}\n\t\t\/\/ End Other Blocks\n\t\t\n\t\t\/\/ Lockouts\n\t\t$lockouts = @wfWAFUtils::json_decode($lockoutsJSON, true);\n\t\tif (is_array($lockouts)) {\n\t\t\t$lockouts = $lockouts['lockouts'];\n\t\t\t$isAuthRequest = (stripos($bareRequestURI, '\/wp-login.php') !== false) || (stripos($bareRequestURI, '\/xmlrpc.php') !== false);\n\t\t\tif ($isAuthRequest) {\n\t\t\t\tforeach ($lockouts as $l) {\n\t\t\t\t\tif (isset($l['expiration']) && $l['expiration'] < time()) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (base64_decode($l['IP']) != $ipNum) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn array('action' => (empty($l['reason']) ? '' : $l['reason']), 'id' => $l['id'], 'lockout' => true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\/\/ End Lockouts\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic function countryRedirURL($countryBlocks = null) {\n\t\tif (!isset($countryBlocks)) {\n\t\t\ttry {\n\t\t\t\t$countryBlocksJSON = wfWAF::getInstance()->getStorageEngine()->getConfig('countryBlocks', null, 'synced');\n\t\t\t}\n\t\t\tcatch (Exception $e) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\t$countryBlocks = @wfWAFUtils::json_decode($countryBlocksJSON, true);\n\t\tif (is_array($countryBlocks)) {\n\t\t\tif ($countryBlocks['action'] == 'redir') {\n\t\t\t\treturn $countryBlocks['redirURL'];\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic function countryBypassRedirURL($countryBlocks = null) {\n\t\tif (!isset($countryBlocks)) {\n\t\t\ttry {\n\t\t\t\t$countryBlocksJSON = wfWAF::getInstance()->getStorageEngine()->getConfig('countryBlocks', null, 'synced');\n\t\t\t}\n\t\t\tcatch (Exception $e) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\t$countryBlocks = @wfWAFUtils::json_decode($countryBlocksJSON, true);\n\t\tif (is_array($countryBlocks)) {\n\t\t\treturn $countryBlocks['bypassRedirDest'];\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tprotected function checkForBlockedCountry($countryBlock, $ip, $bareRequestURI) {\n\t\ttry {\n\t\t\t$homeURL = wfWAF::getInstance()->getStorageEngine()->getConfig('homeURL', null, 'synced');\n\t\t}\n\t\tcatch (Exception $e) {\n\t\t\t\/\/Do nothing\n\t\t}\n\t\t\n\t\t$bareRequestURI = rtrim($bareRequestURI, '\/\\\\');\n\t\tif ($country = $this->ip2Country($ip)) {\n\t\t\t$blocks = $countryBlock['blocks'];\n\t\t\tforeach ($blocks as $b) {\n\t\t\t\tforeach ($b['countries'] as $blocked) {\n\t\t\t\t\tif (strtoupper($blocked) == strtoupper($country)) {\n\t\t\t\t\t\tif ($countryBlock['action'] == 'redir') {\n\t\t\t\t\t\t\t$redirURL = $countryBlock['redirURL'];\n\t\t\t\t\t\t\t$eRedirHost = wfWAFUtils::extractHostname($redirURL);\n\t\t\t\t\t\t\t$isExternalRedir = false;\n\t\t\t\t\t\t\tif ($eRedirHost && $homeURL && $eRedirHost != wfWAFUtils::extractHostname($homeURL)) {\n\t\t\t\t\t\t\t\t$isExternalRedir = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif ((!$isExternalRedir) && rtrim(wfWAFUtils::extractBareURI($redirURL), '\/\\\\') == $bareRequestURI){ \/\/Is this the URI we want to redirect to, then don't block it\n\t\t\t\t\t\t\t\t\/\/Do nothing\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\treturn array('action' => self::WFWAF_BLOCK_COUNTRY_REDIR);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn array('action' => self::WFWAF_BLOCK_COUNTRY);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tprotected function checkForWhitelisted($ip) {\n\t\ttry {\n\t\t\t$pluginABSPATH = wfWAF::getInstance()->getStorageEngine()->getConfig('pluginABSPATH', null, 'synced');\n\t\t\t$serverIPsJSON = wfWAF::getInstance()->getStorageEngine()->getConfig('serverIPs', null, 'synced');\n\t\t\t$whitelistedServiceIPsJSON = wfWAF::getInstance()->getStorageEngine()->getConfig('whitelistedServiceIPs', null, 'synced');\n\t\t}\n\t\tcatch (Exception $e) {\n\t\t\t\/\/ Do nothing\n\t\t}\n\t\t\n\t\t$serverIPs = @wfWAFUtils::json_decode($serverIPsJSON, true);\n\t\tif (is_array($serverIPs)) {\n\t\t\tif (\n\t\t\t\t(isset($_SERVER['SCRIPT_FILENAME']) && $_SERVER['SCRIPT_FILENAME'] == realpath($pluginABSPATH . DIRECTORY_SEPARATOR . 'wp-cron.php')) || \/\/Safe -- plugin will do a final check to make sure the cron constant is defined\n\t\t\t\t(!empty($_GET['wordfence_syncAttackData'])) \/\/Safe but plugin will do a final check to make sure it runs\n\t\t\t) {\n\t\t\t\tforeach ($serverIPs as $testIP) {\n\t\t\t\t\tif (wfWAFUtils::inet_pton($ip) == wfWAFUtils::inet_pton($testIP)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t$whitelistedServiceIPs = @wfWAFUtils::json_decode($whitelistedServiceIPsJSON, true);\n\t\tif (is_array($whitelistedServiceIPs)) {\n\t\t\t$wfIPWhitelist = $whitelistedServiceIPs;\n\t\t}\n\t\telse {\n\t\t\t$wordfenceLib = realpath(dirname(__FILE__) . '\/..\/lib');\n\t\t\tinclude($wordfenceLib . '\/wfIPWhitelist.php'); \/** @var array $wfIPWhitelist *\/\n\t\t}\n\t\t\n\t\tforeach ($wfIPWhitelist as $group) {\n\t\t\tforeach ($group as $subnet) {\n\t\t\t\tif ($subnet instanceof wfWAFUserIPRange) { \/\/Not currently reached\n\t\t\t\t\tif ($subnet->isIPInRange($ip)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} elseif (wfWAFUtils::subnetContainsIP($subnet, $ip)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tprotected function ip2Country($ip) {\n\t\t\/**\n\t\t * It's possible this class is already loaded from a different installation of the plugin\n\t\t * by the time this is reached. See wfUtils::requireIpLocator for additional details.\n\t\t *\/\n\t\tif (!class_exists('wfIpLocator'))\n\t\t\trequire_once __DIR__ . '\/..\/lib\/wfIpLocator.php';\n\t\treturn wfIpLocator::getInstance()->getCountryCode($ip);\n\t}\n\t\n\t\/**\n\t * Returns whether or not the site should be treated as if it's full-time SSL.\n\t *\n\t * @return bool\n\t *\/\n\tprotected function isFullSSL() {\n\t\ttry {\n\t\t\t$is_ssl = false; \/\/This is the same code from WP modified so we can use it here\n\t\t\tif ( isset( $_SERVER['HTTPS'] ) ) {\n\t\t\t\tif ( 'on' == strtolower( $_SERVER['HTTPS'] ) ) {\n\t\t\t\t\t$is_ssl = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ( '1' == $_SERVER['HTTPS'] ) {\n\t\t\t\t\t$is_ssl = true;\n\t\t\t\t}\n\t\t\t} elseif ( isset($_SERVER['SERVER_PORT'] ) && ( '443' == $_SERVER['SERVER_PORT'] ) ) {\n\t\t\t\t$is_ssl = true;\n\t\t\t}\n\t\t\t\n\t\t\t$homeURL = wfWAF::getInstance()->getStorageEngine()->getConfig('homeURL', null, 'synced');\n\t\t\treturn $is_ssl && parse_url($homeURL, PHP_URL_SCHEME) === 'https';\n\t\t}\n\t\tcatch (Exception $e) {\n\t\t\t\/\/Do nothing\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n}\n}"},{"base":"plugins","rel":"wordfence\/waf\/bootstrap.php","ext":"php","size":34499,"mtime":1757312769,"type":"text","content":"<?php\n\n\/*\n\tphp_value auto_prepend_file ~\/wp-content\/plugins\/wordfence\/waf\/bootstrap.php\n*\/\n\nif (!defined('WFWAF_RUN_COMPLETE')) {\n\nif (!defined('WFWAF_AUTO_PREPEND')) {\n\tdefine('WFWAF_AUTO_PREPEND', true);\n}\nif (!defined('WF_IS_WP_ENGINE')) {\n\tdefine('WF_IS_WP_ENGINE', isset($_SERVER['IS_WPE']));\n}\nif (!defined('WF_IS_FLYWHEEL')) {\n\tdefine('WF_IS_FLYWHEEL', isset($_SERVER['SERVER_SOFTWARE']) && strpos($_SERVER['SERVER_SOFTWARE'], 'Flywheel\/') === 0);\n}\nif (!defined('WF_IS_PRESSABLE')) {\n\tdefine('WF_IS_PRESSABLE', (defined('IS_ATOMIC') && IS_ATOMIC) || (defined('IS_PRESSABLE') && IS_PRESSABLE));\n}\n\nrequire(dirname(__FILE__) . '\/..\/lib\/wfVersionSupport.php');\n\/**\n * @var string $wfPHPDeprecatingVersion\n * @var string $wfPHPMinimumVersion\n *\/\n\nif (!defined('WF_PHP_UNSUPPORTED')) {\n\tdefine('WF_PHP_UNSUPPORTED', version_compare(PHP_VERSION, $wfPHPMinimumVersion, '<'));\n}\n\nif (WF_PHP_UNSUPPORTED) {\n\treturn;\n}\n\n\n\nrequire_once(dirname(__FILE__) . '\/wfWAFUserIPRange.php');\nrequire_once(dirname(__FILE__) . '\/wfWAFIPBlocksController.php');\nrequire_once(dirname(__FILE__) . '\/..\/vendor\/wordfence\/wf-waf\/src\/init.php');\n\nclass wfWAFWordPressRequest extends wfWAFRequest {\n\t\n\t\/**\n\t * @param wfWAFRequest|null $request\n\t * @return wfWAFRequest\n\t *\/\n\tpublic static function createFromGlobals($request = null) {\n\t\tif (version_compare(phpversion(), '5.3.0') >= 0) {\n\t\t\t$class = get_called_class();\n\t\t\t$request = new $class();\n\t\t} else {\n\t\t\t$request = new self();\n\t\t}\n\t\treturn parent::createFromGlobals($request);\n\t}\n\n\tpublic function getIP() {\n\t\tstatic $theIP = null;\n\t\tif (isset($theIP)) {\n\t\t\treturn $theIP;\n\t\t}\n\t\t$ips = array();\n\t\t$howGet = wfWAF::getInstance()->getStorageEngine()->getConfig('howGetIPs', null, 'synced');\n\t\tif ($howGet) {\n\t\t\tif (is_string($howGet) && is_array($_SERVER) && array_key_exists($howGet, $_SERVER)) {\n\t\t\t\t$ips[] = array($_SERVER[$howGet], $howGet);\n\t\t\t}\n\t\t\t\n\t\t\tif ($howGet != 'REMOTE_ADDR') {\n\t\t\t\t$ips[] = array((is_array($_SERVER) && array_key_exists('REMOTE_ADDR', $_SERVER)) ? $_SERVER['REMOTE_ADDR'] : '127.0.0.1', 'REMOTE_ADDR');\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t$recommendedField = wfWAF::getInstance()->getStorageEngine()->getConfig('detectProxyRecommendation', null, 'synced');\n\t\t\tif (!empty($recommendedField) && $recommendedField != 'UNKNOWN' && $recommendedField != 'DEFERRED') {\n\t\t\t\tif (isset($_SERVER[$recommendedField])) {\n\t\t\t\t\t$ips[] = array($_SERVER[$recommendedField], $recommendedField);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t$ips[] = array((is_array($_SERVER) && array_key_exists('REMOTE_ADDR', $_SERVER)) ? $_SERVER['REMOTE_ADDR'] : '127.0.0.1', 'REMOTE_ADDR');\n\t\t\tif (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) {\n\t\t\t\t$ips[] = array($_SERVER['HTTP_X_FORWARDED_FOR'], 'HTTP_X_FORWARDED_FOR');\n\t\t\t}\n\t\t\tif (isset($_SERVER['HTTP_X_REAL_IP'])) {\n\t\t\t\t$ips[] = array($_SERVER['HTTP_X_REAL_IP'], 'HTTP_X_REAL_IP');\n\t\t\t}\n\t\t}\n\t\t\n\t\t$cleanedIP = $this->_getCleanIPAndServerVar($ips);\n\t\tif (is_array($cleanedIP)) {\n\t\t\tlist($ip, $variable) = $cleanedIP;\n\t\t\t$theIP = $ip;\n\t\t\treturn $ip;\n\t\t}\n\t\t$theIP = $cleanedIP;\n\t\treturn $cleanedIP;\n\t}\n\t\n\t\/**\n\t * Expects an array of items. The items are either IPs or IPs separated by comma, space or tab. Or an array of IP's.\n\t * We then examine all IP's looking for a public IP and storing private IP's in an array. If we find no public IPs we return the first private addr we found.\n\t *\n\t * @param array $arr\n\t * @return bool|mixed\n\t *\/\n\tprivate function _getCleanIPAndServerVar($arr) {\n\t\t$privates = array(); \/\/Store private addrs until end as last resort.\n\t\tforeach ($arr as $entry) {\n\t\t\tlist($item, $var) = $entry;\n\t\t\tif (is_array($item)) {\n\t\t\t\tforeach ($item as $j) {\n\t\t\t\t\t\/\/ try verifying the IP is valid before stripping the port off\n\t\t\t\t\tif (!$this->_isValidIP($j)) {\n\t\t\t\t\t\t$j = preg_replace('\/:\\d+$\/', '', $j); \/\/Strip off port\n\t\t\t\t\t}\n\t\t\t\t\tif ($this->_isValidIP($j)) {\n\t\t\t\t\t\tif ($this->_isIPv6MappedIPv4($j)) {\n\t\t\t\t\t\t\t$j = wfWAFUtils::inet_ntop(wfWAFUtils::inet_pton($j));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ($this->_isPrivateIP($j)) {\n\t\t\t\t\t\t\t$privates[] = array($j, $var);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn array($j, $var);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue; \/\/This was an array so we can skip to the next item\n\t\t\t}\n\t\t\t$skipToNext = false;\n\t\t\t$trustedProxyConfig = wfWAF::getInstance()->getStorageEngine()->getConfig('howGetIPs_trusted_proxies_unified', null, 'synced');\n\t\t\t$trustedProxies = $trustedProxyConfig === null ? array() : explode(\"\\n\", $trustedProxyConfig);\n\t\t\tforeach (array(',', ' ', \"\\t\") as $char) {\n\t\t\t\tif (strpos($item, $char) !== false) {\n\t\t\t\t\t$sp = explode($char, $item);\n\t\t\t\t\t$sp = array_reverse($sp);\n\t\t\t\t\tforeach ($sp as $index => $j) {\n\t\t\t\t\t\t$j = trim($j);\n\t\t\t\t\t\tif (!$this->_isValidIP($j)) {\n\t\t\t\t\t\t\t$j = preg_replace('\/:\\d+$\/', '', $j); \/\/Strip off port\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ($this->_isValidIP($j)) {\n\t\t\t\t\t\t\tif ($this->_isIPv6MappedIPv4($j)) {\n\t\t\t\t\t\t\t\t$j = wfWAFUtils::inet_ntop(wfWAFUtils::inet_pton($j));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tforeach ($trustedProxies as $proxy) {\n\t\t\t\t\t\t\t\tif (!empty($proxy)) {\n\t\t\t\t\t\t\t\t\tif (wfWAFUtils::subnetContainsIP($proxy, $j) && $index < count($sp) - 1) {\n\t\t\t\t\t\t\t\t\t\tcontinue 2;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif ($this->_isPrivateIP($j)) {\n\t\t\t\t\t\t\t\t$privates[] = array($j, $var);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\treturn array($j, $var);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t$skipToNext = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ($skipToNext){ continue; } \/\/Skip to next item because this one had a comma, space or tab so was delimited and we didn't find anything.\n\t\t\t\n\t\t\tif (!$this->_isValidIP($item)) {\n\t\t\t\t$item = preg_replace('\/:\\d+$\/', '', $item); \/\/Strip off port\n\t\t\t}\n\t\t\tif ($this->_isValidIP($item)) {\n\t\t\t\tif ($this->_isIPv6MappedIPv4($item)) {\n\t\t\t\t\t$item = wfWAFUtils::inet_ntop(wfWAFUtils::inet_pton($item));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ($this->_isPrivateIP($item)) {\n\t\t\t\t\t$privates[] = array($item, $var);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn array($item, $var);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (sizeof($privates) > 0) {\n\t\t\treturn $privates[0]; \/\/Return the first private we found so that we respect the order the IP's were passed to this function.\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\/**\n\t * @param string $ip\n\t * @return bool\n\t *\/\n\tprivate function _isValidIP($ip) {\n\t\treturn filter_var($ip, FILTER_VALIDATE_IP) !== false;\n\t}\n\t\n\t\/**\n\t * @param string $ip\n\t * @return bool\n\t *\/\n\tprivate function _isIPv6MappedIPv4($ip) {\n\t\treturn preg_match('\/^(?:\\:(?:\\:0{1,4}){0,4}\\:|(?:0{1,4}\\:){5})ffff\\:\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$\/i', $ip) > 0;\n\t}\n\t\n\t\/**\n\t * @param string $addr Should be in dot or colon notation (127.0.0.1 or ::1)\n\t * @return bool\n\t *\/\n\tprivate function _isPrivateIP($ip) {\n\t\t\/\/ Run this through the preset list for IPv4 addresses.\n\t\tif (filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4) !== false) {\n\t\t\t$wordfenceLib = realpath(dirname(__FILE__) . '\/..\/lib');\n\t\t\tinclude($wordfenceLib . '\/wfIPWhitelist.php'); \/\/ defines $wfIPWhitelist\n\t\t\t$private = $wfIPWhitelist['private'];\n\t\t\t\n\t\t\tforeach ($private as $a) {\n\t\t\t\tif (wfWAFUtils::subnetContainsIP($a, $ip)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4 | FILTER_FLAG_IPV6) !== false\n\t\t&& filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4 | FILTER_FLAG_IPV6 | FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE) === false;\n\t}\n}\n\nclass wfWAFWordPressObserver extends wfWAFBaseObserver {\n\n\tprivate $waf;\n\n\tpublic function __construct($waf){\n\t\t$this->waf=$waf;\n\t}\n\n\tpublic function beforeRunRules() {\n\t\t\/\/ Whitelisted URLs (in WAF config)\n\t\t$whitelistedURLs = wfWAF::getInstance()->getStorageEngine()->getConfig('whitelistedURLs', null, 'livewaf');\n\t\tif ($whitelistedURLs) {\n\t\t\t$whitelistPattern = \"\";\n\t\t\tforeach ($whitelistedURLs as $whitelistedURL) {\n\t\t\t\t$whitelistPattern .= preg_replace('\/\\\\\\\\\\*\/', '.*?', preg_quote($whitelistedURL, '\/')) . '|';\n\t\t\t}\n\t\t\t$whitelistPattern = '\/^(?:' . wfWAFUtils::substr($whitelistPattern, 0, -1) . ')$\/i';\n\n\t\t\twfWAFRule::create(wfWAF::getInstance(), 0x8000000, 'rule', 'whitelist', 0, 'User Supplied Allowlisted URL', 'allow',\n\t\t\t\tnew wfWAFRuleComparisonGroup(\n\t\t\t\t\tnew wfWAFRuleComparison(wfWAF::getInstance(), 'match', $whitelistPattern, array(\n\t\t\t\t\t\t'request.uri',\n\t\t\t\t\t))\n\t\t\t\t)\n\t\t\t)->evaluate();\n\t\t}\n\n\t\t\/\/ Whitelisted IPs (Wordfence config)\n\t\t$whitelistedIPs = wfWAF::getInstance()->getStorageEngine()->getConfig('whitelistedIPs', null, 'synced');\n\t\tif ($whitelistedIPs) {\n\t\t\tif (!is_array($whitelistedIPs)) {\n\t\t\t\t$whitelistedIPs = explode(',', $whitelistedIPs);\n\t\t\t}\n\t\t\tforeach ($whitelistedIPs as $whitelistedIP) {\n\t\t\t\t$ipRange = new wfWAFUserIPRange($whitelistedIP);\n\t\t\t\tif ($ipRange->isIPInRange(wfWAF::getInstance()->getRequest()->getIP())) {\n\t\t\t\t\tthrow new wfWAFAllowException('Wordfence allowlisted IP.');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\/\/ Check plugin blocking\n\t\tif ($result = wfWAF::getInstance()->willPerformFinalAction(wfWAF::getInstance()->getRequest())) {\n\t\t\tif ($result === true) { $result = 'Not available'; } \/\/ Should not happen but can if the reason in the blocks table is empty\n\t\t\twfWAF::getInstance()->getRequest()->setMetadata(array_merge(wfWAF::getInstance()->getRequest()->getMetadata(), array('finalAction' => $result)));\n\t\t}\n\t}\n\t\n\tpublic function afterRunRules()\n\t{\n\t\t\/\/Blacklist\n\t\tif (!wfWAF::getInstance()->getStorageEngine()->getConfig('disableWAFBlacklistBlocking')) {\n\t\t\t$blockedPrefixes = wfWAF::getInstance()->getStorageEngine()->getConfig('blockedPrefixes', null, 'transient');\n\t\t\tif ($blockedPrefixes && wfWAF::getInstance()->getStorageEngine()->getConfig('isPaid', null, 'synced')) {\n\t\t\t\t$blockedPrefixes = base64_decode($blockedPrefixes);\n\t\t\t\tif ($this->_prefixListContainsIP($blockedPrefixes, wfWAF::getInstance()->getRequest()->getIP()) !== false) {\n\t\t\t\t\t$allowedCacheJSON = wfWAF::getInstance()->getStorageEngine()->getConfig('blacklistAllowedCache', '', 'transient');\n\t\t\t\t\t$allowedCache = @json_decode($allowedCacheJSON, true);\n\t\t\t\t\tif (!is_array($allowedCache)) {\n\t\t\t\t\t\t$allowedCache = array();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$cacheTest = base64_encode(wfWAFUtils::inet_pton(wfWAF::getInstance()->getRequest()->getIP()));\n\t\t\t\t\tif (!in_array($cacheTest, $allowedCache)) {\n\t\t\t\t\t\t$guessSiteURL = sprintf('%s:\/\/%s\/', wfWAF::getInstance()->getRequest()->getProtocol(), wfWAF::getInstance()->getRequest()->getHost());\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t$request = new wfWAFHTTP();\n\t\t\t\t\t\t\t$response = wfWAFHTTP::get(WFWAF_API_URL_SEC . \"?\" . http_build_query(array(\n\t\t\t\t\t\t\t\t\t'action' => 'is_ip_blacklisted',\n\t\t\t\t\t\t\t\t\t'ip'\t => wfWAF::getInstance()->getRequest()->getIP(),\n\t\t\t\t\t\t\t\t\t'k'      => wfWAF::getInstance()->getStorageEngine()->getConfig('apiKey', null, 'synced'),\n\t\t\t\t\t\t\t\t\t's'      => wfWAF::getInstance()->getStorageEngine()->getConfig('siteURL', null, 'synced') ? wfWAF::getInstance()->getStorageEngine()->getConfig('siteURL', null, 'synced') : $guessSiteURL,\n\t\t\t\t\t\t\t\t\t'h'      => wfWAF::getInstance()->getStorageEngine()->getConfig('homeURL', null, 'synced') ? wfWAF::getInstance()->getStorageEngine()->getConfig('homeURL', null, 'synced') : $guessSiteURL,\n\t\t\t\t\t\t\t\t\t't'\t\t => microtime(true),\n\t\t\t\t\t\t\t\t\t'lang'   => wfWAF::getInstance()->getStorageEngine()->getConfig('WPLANG', null, 'synced'),\n\t\t\t\t\t\t\t\t), '', '&'), $request);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif ($response instanceof wfWAFHTTPResponse && $response->getBody()) {\n\t\t\t\t\t\t\t\t$jsonData = wfWAFUtils::json_decode($response->getBody(), true);\n\t\t\t\t\t\t\t\tif (is_array($jsonData) && array_key_exists('data', $jsonData)) {\n\t\t\t\t\t\t\t\t\tif (preg_match('\/^block:(\\d+)$\/i', $jsonData['data'], $matches)) {\n\t\t\t\t\t\t\t\t\t\twfWAF::getInstance()->getStorageEngine()->blockIP((int)$matches[1] + time(), wfWAF::getInstance()->getRequest()->getIP(), wfWAFStorageInterface::IP_BLOCKS_BLACKLIST);\n\t\t\t\t\t\t\t\t\t\t$e = new wfWAFBlockException();\n\t\t\t\t\t\t\t\t\t\t$e->setFailedRules(array('blocked'));\n\t\t\t\t\t\t\t\t\t\t$e->setRequest(wfWAF::getInstance()->getRequest());\n\t\t\t\t\t\t\t\t\t\tthrow $e;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse { \/\/Allowed, cache until the next prefix list refresh\n\t\t\t\t\t\t\t\t\t\t$allowedCache[] = $cacheTest;\n\t\t\t\t\t\t\t\t\t\twfWAF::getInstance()->getStorageEngine()->setConfig('blacklistAllowedCache', json_encode($allowedCache), 'transient');\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (wfWAFHTTPTransportException $e) {\n\t\t\t\t\t\t\terror_log($e->getMessage());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif ($reason = wfWAF::getInstance()->getRequest()->getMetadata('finalAction')) {\n\t\t\t$e = new wfWAFBlockException($reason['action']);\n\t\t\t$e->setRequest(wfWAF::getInstance()->getRequest());\n\t\t\tthrow $e;\n\t\t}\n\t}\n\t\n\tprivate function _prefixListContainsIP($prefixList, $ip) {\n\t\t$size = ord(wfWAFUtils::substr($prefixList, 0, 1));\n\t\t\n\t\t$sha256 = hash('sha256', wfWAFUtils::inet_pton($ip), true);\n\t\t$p = wfWAFUtils::substr($sha256, 0, $size);\n\t\t\n\t\t$count = ceil((wfWAFUtils::strlen($prefixList) - 1) \/ $size);\n\t\t$low = 0;\n\t\t$high = $count - 1;\n\t\t\n\t\twhile ($low <= $high) {\n\t\t\t$mid = (int) (($high + $low) \/ 2);\n\t\t\t$val = wfWAFUtils::substr($prefixList, 1 + $mid * $size, $size);\n\t\t\t$cmp = strcmp($val, $p);\n\t\t\tif ($cmp < 0) {\n\t\t\t\t$low = $mid + 1;\n\t\t\t}\n\t\t\telse if ($cmp > 0) {\n\t\t\t\t$high = $mid - 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn $mid;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n}\n\n\/**\n *\n *\/\nclass wfWAFWordPress extends wfWAF {\n\n\t\/** @var wfWAFRunException *\/\n\tprivate $learningModeAttackException;\n\n\t\/**\n\t * @param wfWAFBlockException $e\n\t * @param int $httpCode\n\t *\/\n\tpublic function blockAction($e, $httpCode = 403, $redirect = false, $template = null) {\n\t\t$failedRules = $e->getFailedRules();\n\t\tif (!is_array($failedRules)) {\n\t\t\t$failedRules = array();\n\t\t}\n\t\t\n\t\tif ($this->isInLearningMode() && !$e->getRequest()->getMetadata('finalAction') && !in_array('blocked', $failedRules)) {\n\t\t\tregister_shutdown_function(array(\n\t\t\t\t$this, 'whitelistFailedRulesIfNot404',\n\t\t\t));\n\t\t\t$this->getStorageEngine()->logAttack($e->getFailedRules(), $e->getParamKey(), $e->getParamValue(), $e->getRequest());\n\t\t\t$this->setLearningModeAttackException($e);\n\t\t} else {\n\t\t\tif (empty($failedRules)) {\n\t\t\t\t$finalAction = $e->getRequest()->getMetadata('finalAction');\n\t\t\t\tif (is_array($finalAction)) {\n\t\t\t\t\t$isLockedOut = isset($finalAction['lockout']) && $finalAction['lockout'];\n\t\t\t\t\t$finalAction = $finalAction['action'];\n\t\t\t\t\tif ($finalAction == wfWAFIPBlocksController::WFWAF_BLOCK_COUNTRY_REDIR) {\n\t\t\t\t\t\t$redirect = wfWAFIPBlocksController::currentController()->countryRedirURL();\n\t\t\t\t\t}\n\t\t\t\t\telse if ($finalAction == wfWAFIPBlocksController::WFWAF_BLOCK_COUNTRY_BYPASS_REDIR) {\n\t\t\t\t\t\t$redirect = wfWAFIPBlocksController::currentController()->countryBypassRedirURL();\n\t\t\t\t\t}\n\t\t\t\t\telse if ($finalAction == wfWAFIPBlocksController::WFWAF_BLOCK_UAREFIPRANGE) {\n\t\t\t\t\t\twfWAF::getInstance()->getRequest()->setMetadata(array_merge(wfWAF::getInstance()->getRequest()->getMetadata(), array('503Reason' => 'Advanced blocking in effect.', '503Time' => 3600)));\n\t\t\t\t\t\t$httpCode = 503;\n\t\t\t\t\t}\n\t\t\t\t\telse if ($finalAction == wfWAFIPBlocksController::WFWAF_BLOCK_COUNTRY) {\n\t\t\t\t\t\twfWAF::getInstance()->getRequest()->setMetadata(array_merge(wfWAF::getInstance()->getRequest()->getMetadata(), array('503Reason' => 'Access from your area has been temporarily limited for security reasons.', '503Time' => 3600)));\n\t\t\t\t\t\t$httpCode = 503;\n\t\t\t\t\t}\n\t\t\t\t\telse if (is_string($finalAction) && strlen($finalAction) > 0) {\n\t\t\t\t\t\twfWAF::getInstance()->getRequest()->setMetadata(array_merge(wfWAF::getInstance()->getRequest()->getMetadata(), array('503Reason' => $finalAction, '503Time' => 3600)));\n\t\t\t\t\t\t$httpCode = 503;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ($isLockedOut) {\n\t\t\t\t\t\t\tparent::blockAction($e, $httpCode, $redirect, '503-lockout'); \/\/exits\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (array_search('blocked', $failedRules) !== false) {\n\t\t\t\tparent::blockAction($e, $httpCode, $redirect, '403-blacklist'); \/\/exits\n\t\t\t}\n\t\t\t\n\t\t\tparent::blockAction($e, $httpCode, $redirect, $template);\n\t\t}\n\t}\n\n\t\/**\n\t * @param wfWAFBlockXSSException $e\n\t * @param int $httpCode\n\t *\/\n\tpublic function blockXSSAction($e, $httpCode = 403, $redirect = false) {\n\t\tif ($this->isInLearningMode() && !$e->getRequest()->getMetadata('finalAction')) {\n\t\t\tregister_shutdown_function(array(\n\t\t\t\t$this, 'whitelistFailedRulesIfNot404',\n\t\t\t));\n\t\t\t$this->getStorageEngine()->logAttack($e->getFailedRules(), $e->getParamKey(), $e->getParamValue(), $e->getRequest());\n\t\t\t$this->setLearningModeAttackException($e);\n\t\t} else {\n\t\t\t$failedRules = $e->getFailedRules();\n\t\t\tif (empty($failedRules)) {\n\t\t\t\t$finalAction = $e->getRequest()->getMetadata('finalAction');\n\t\t\t\tif (is_array($finalAction)) {\n\t\t\t\t\t$finalAction = $finalAction['action'];\n\t\t\t\t\tif ($finalAction == wfWAFIPBlocksController::WFWAF_BLOCK_COUNTRY_REDIR) {\n\t\t\t\t\t\t$redirect = wfWAFIPBlocksController::currentController()->countryRedirURL();\n\t\t\t\t\t}\n\t\t\t\t\telse if ($finalAction == wfWAFIPBlocksController::WFWAF_BLOCK_COUNTRY_BYPASS_REDIR) {\n\t\t\t\t\t\t$redirect = wfWAFIPBlocksController::currentController()->countryBypassRedirURL();\n\t\t\t\t\t}\n\t\t\t\t\telse if ($finalAction == wfWAFIPBlocksController::WFWAF_BLOCK_UAREFIPRANGE) {\n\t\t\t\t\t\twfWAF::getInstance()->getRequest()->setMetadata(array_merge(wfWAF::getInstance()->getRequest()->getMetadata(), array('503Reason' => 'Advanced blocking in effect.', '503Time' => 3600)));\n\t\t\t\t\t\t$httpCode = 503;\n\t\t\t\t\t}\n\t\t\t\t\telse if ($finalAction == wfWAFIPBlocksController::WFWAF_BLOCK_COUNTRY) {\n\t\t\t\t\t\twfWAF::getInstance()->getRequest()->setMetadata(array_merge(wfWAF::getInstance()->getRequest()->getMetadata(), array('503Reason' => 'Access from your area has been temporarily limited for security reasons.', '503Time' => 3600)));\n\t\t\t\t\t\t$httpCode = 503;\n\t\t\t\t\t}\n\t\t\t\t\telse if (is_string($finalAction) && strlen($finalAction) > 0) {\n\t\t\t\t\t\twfWAF::getInstance()->getRequest()->setMetadata(array_merge(wfWAF::getInstance()->getRequest()->getMetadata(), array('503Reason' => $finalAction, '503Time' => 3600)));\n\t\t\t\t\t\t$httpCode = 503;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tparent::blockXSSAction($e, $httpCode, $redirect);\n\t\t}\n\t}\n\n\tprivate function isCli() {\n\t\treturn (php_sapi_name()==='cli') || !array_key_exists('REQUEST_METHOD', $_SERVER);\n\t}\n\n\t\/**\n\t *\n\t *\/\n\tpublic function runCron() {\n\t\tif($this->isCli()){\n\t\t\treturn;\n\t\t}\n\t\t\/**\n\t\t * Removed sending attack data. Attack data is sent in @see wordfence::veryFirstAction\n\t\t *\/\n\t\t$storage = $this->getStorageEngine();\n\t\t$cron = (array) $storage->getConfig('cron', null, 'livewaf');\n\t\t$run = array();\n\t\t$updated = false;\n\t\tif (is_array($cron)) {\n\t\t\t\/** @var wfWAFCronEvent $event *\/\n\t\t\t$cronDeduplication = array();\n\t\t\tforeach ($cron as $index => $event) {\n\t\t\t\tif (is_object($event) && $event instanceof wfWAFCronEvent) {\n\t\t\t\t\t$event->setWaf($this);\n\t\t\t\t\tif ($event->isInPast()) {\n\t\t\t\t\t\t$run[$index] = $event;\n\t\t\t\t\t\t$newEvent = $event->reschedule();\n\t\t\t\t\t\t$className = is_object($newEvent) ? get_class($newEvent) : null;\n\t\t\t\t\t\tif ($newEvent && $newEvent instanceof wfWAFCronEvent && $newEvent !== $event && !in_array($className, $cronDeduplication)) {\n\t\t\t\t\t\t\t$cron[$index] = $newEvent;\n\t\t\t\t\t\t\t$cronDeduplication[] = $className;\n\t\t\t\t\t\t\t$updated = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tunset($cron[$index]);\n\t\t\t\t\t\t\t$updated = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t$className = get_class($event);\n\t\t\t\t\t\tif (in_array($className, $cronDeduplication)) {\n\t\t\t\t\t\t\tunset($cron[$index]);\n\t\t\t\t\t\t\t$updated = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t$cronDeduplication[] = $className;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse { \/\/Remove bad\/corrupt records\n\t\t\t\t\tunset($cron[$index]);\n\t\t\t\t\t$updated = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t$storage->setConfig('cron', $cron, 'livewaf');\n\t\t\n\t\tif ($updated && method_exists($storage, 'saveConfig')) {\n\t\t\t$storage->saveConfig('livewaf');\n\t\t}\n\t\t\n\t\tforeach ($run as $index => $event) {\n\t\t\t$event->fire();\n\t\t}\n\t}\n\n\t\/**\n\t *\n\t *\/\n\tpublic function whitelistFailedRulesIfNot404() {\n\t\t\/** @var WP_Query $wp_query *\/\n\t\tglobal $wp_query;\n\t\tif (defined('ABSPATH') &&\n\t\t\tisset($wp_query) && class_exists('WP_Query') && $wp_query instanceof WP_Query &&\n\t\t\tmethod_exists($wp_query, 'is_404') && $wp_query->is_404() &&\n\t\t\tfunction_exists('is_admin') && !is_admin()) {\n\t\t\treturn;\n\t\t}\n\t\t$this->whitelistFailedRules();\n\t}\n\n\t\/**\n\t * @param $ip\n\t * @return mixed\n\t *\/\n\tpublic function isIPBlocked($ip) {\n\t\treturn parent::isIPBlocked($ip);\n\t}\n\t\n\t\/**\n\t * @param wfWAFRequest $request\n\t * @return bool|string false if it should not be blocked, otherwise true or a reason for blocking \n\t *\/\n\tpublic function willPerformFinalAction($request) {\n\t\ttry {\n\t\t\t$disableWAFIPBlocking = $this->getStorageEngine()->getConfig('disableWAFIPBlocking', null, 'synced');\n\t\t\t$advancedBlockingEnabled = $this->getStorageEngine()->getConfig('advancedBlockingEnabled', null, 'synced');\n\t\t}\n\t\tcatch (Exception $e) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif ($disableWAFIPBlocking || !$advancedBlockingEnabled) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn wfWAFIPBlocksController::currentController()->shouldBlockRequest($request);\n\t}\n\t\n\tpublic function uninstall() {\n\t\tparent::uninstall();\n\t\t@unlink(rtrim(WFWAF_LOG_PATH, '\/') . '\/.htaccess');\n\t\t@unlink(rtrim(WFWAF_LOG_PATH, '\/') . '\/template.php');\n\t\t@unlink(rtrim(WFWAF_LOG_PATH, '\/') . '\/GeoLite2-Country.mmdb');\n\t\t\n\t\tself::_recursivelyRemoveWflogs(''); \/\/Removes any remaining files and the directory itself\n\t}\n\t\n\t\/**\n\t * Removes a path within wflogs, recursing as necessary.\n\t *\n\t * @param string $file\n\t * @param array $processedDirs\n\t * @return array The list of removed files\/folders.\n\t *\/\n\tprivate static function _recursivelyRemoveWflogs($file, $processedDirs = array()) {\n\t\tif (preg_match('~(?:^|\/|\\\\\\\\)\\.\\.(?:\/|\\\\\\\\|$)~', $file)) {\n\t\t\treturn array();\n\t\t}\n\t\t\n\t\tif (stripos(WFWAF_LOG_PATH, 'wflogs') === false) { \/\/Sanity check -- if not in a wflogs folder, user will have to do removal manually\n\t\t\treturn array();\n\t\t}\n\t\t\n\t\t$path = rtrim(WFWAF_LOG_PATH, '\/') . '\/' . $file;\n\t\tif (is_link($path)) {\n\t\t\tif (@unlink($path)) {\n\t\t\t\treturn array($file);\n\t\t\t}\n\t\t\treturn array();\n\t\t}\n\t\t\n\t\tif (is_dir($path)) {\n\t\t\t$real = realpath($file);\n\t\t\tif (in_array($real, $processedDirs)) {\n\t\t\t\treturn array();\n\t\t\t}\n\t\t\t$processedDirs[] = $real;\n\t\t\t\n\t\t\t$count = 0;\n\t\t\t$dir = opendir($path);\n\t\t\tif ($dir) {\n\t\t\t\t$contents = array();\n\t\t\t\twhile ($sub = readdir($dir)) {\n\t\t\t\t\tif ($sub == '.' || $sub == '..') { continue; }\n\t\t\t\t\t$contents[] = $sub;\n\t\t\t\t}\n\t\t\t\tclosedir($dir);\n\t\t\t\t\n\t\t\t\t$filesRemoved = array();\n\t\t\t\tforeach ($contents as $f) {\n\t\t\t\t\t$removed = self::_recursivelyRemoveWflogs($file . '\/' . $f, $processedDirs);\n\t\t\t\t\t$filesRemoved = array($filesRemoved, $removed);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (@rmdir($path)) {\n\t\t\t\t$filesRemoved[] = $file;\n\t\t\t}\n\t\t\treturn $filesRemoved;\n\t\t}\n\t\t\n\t\tif (@unlink($path)) {\n\t\t\treturn array($file);\n\t\t}\n\t\treturn array();\n\t}\n\t\n\tpublic function fileList() {\n\t\t$fileList = parent::fileList();\n\t\t$fileList[] = rtrim(WFWAF_LOG_PATH, '\/') . '\/.htaccess';\n\t\t$fileList[] = rtrim(WFWAF_LOG_PATH, '\/') . '\/template.php';\n\t\t$fileList[] = rtrim(WFWAF_LOG_PATH, '\/') . '\/GeoLite2-Country.mmdb';\n\t\treturn $fileList;\n\t}\n\n\t\/**\n\t * @return wfWAFRunException\n\t *\/\n\tpublic function getLearningModeAttackException() {\n\t\treturn $this->learningModeAttackException;\n\t}\n\n\t\/**\n\t * @param wfWAFRunException $learningModeAttackException\n\t *\/\n\tpublic function setLearningModeAttackException($learningModeAttackException) {\n\t\t$this->learningModeAttackException = $learningModeAttackException;\n\t}\n\t\n\tpublic static function permissions() {\n\t\tif (defined('WFWAF_LOG_FILE_MODE')) {\n\t\t\treturn WFWAF_LOG_FILE_MODE;\n\t\t}\n\t\t\n\t\tif (class_exists('wfWAFStorageFile') && method_exists('wfWAFStorageFile', 'permissions')) {\n\t\t\treturn wfWAFStorageFile::permissions();\n\t\t}\n\t\t\n\t\tstatic $_cachedPermissions = null;\n\t\tif ($_cachedPermissions === null) {\n\t\t\tif (defined('WFWAF_LOG_PATH')) {\n\t\t\t\t$template = rtrim(WFWAF_LOG_PATH . '\/') . '\/template.php';\n\t\t\t\tif (file_exists($template)) {\n\t\t\t\t\t$stat = @stat($template);\n\t\t\t\t\tif ($stat !== false) {\n\t\t\t\t\t\t$mode = $stat[2];\n\t\t\t\t\t\t$updatedMode = 0600;\n\t\t\t\t\t\tif (($mode & 0020) == 0020) {\n\t\t\t\t\t\t\t$updatedMode = $updatedMode | 0060;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$_cachedPermissions = $updatedMode;\n\t\t\t\t\t\treturn $updatedMode;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0660;\n\t\t}\n\t\treturn $_cachedPermissions;\n\t}\n\t\n\tpublic static function writeHtaccess() {\n\t\t@file_put_contents(rtrim(WFWAF_LOG_PATH, '\/') . '\/.htaccess', <<<APACHE\n<IfModule mod_authz_core.c>\n\tRequire all denied\n<\/IfModule>\n<IfModule !mod_authz_core.c>\n\tOrder deny,allow\n\tDeny from all\n<\/IfModule>\nAPACHE\n\t\t);\n\t\t@chmod(rtrim(WFWAF_LOG_PATH, '\/') . '\/.htaccess', (wfWAFWordPress::permissions() | 0444));\n\t}\n\n\tpublic function getGlobal($global) {\n\t\tif (wfWAFUtils::strpos($global, '.') === false) {\n\t\t\treturn null;\n\t\t}\n\t\tlist($prefix, $_global) = explode('.', $global);\n\t\tswitch ($prefix) {\n\t\t\tcase 'wordpress':\n\t\t\t\tif ($_global === 'core') {\n\t\t\t\t\treturn $this->getStorageEngine()->getConfig('wordpressVersion', null, 'synced');\n\t\t\t\t} else if ($_global === 'plugins') {\n\t\t\t\t\treturn $this->getStorageEngine()->getConfig('wordpressPluginVersions', null, 'synced');\n\t\t\t\t} else if ($_global === 'themes') {\n\t\t\t\t\treturn $this->getStorageEngine()->getConfig('wordpressThemeVersions', null, 'synced');\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\treturn parent::getGlobal($global);\n\t}\n}\n\nclass wfWAFWordPressStorageMySQL extends wfWAFStorageMySQL {\n\n\tpublic function getSerializedParams() {\n\t\t$params = parent::getSerializedParams();\n\t\t$params[] = 'wordpressPluginVersions';\n\t\t$params[] = 'wordpressThemeVersions';\n\t\treturn $params;\n\t}\n\n\tpublic function getAutoloadParams() {\n\t\t$params = parent::getAutoloadParams();\n\t\t$params['synced'][] = 'wordpressVersion';\n\t\t$params['synced'][] = 'wordpressPluginVersions';\n\t\t$params['synced'][] = 'wordpressThemeVersions';\n\t\treturn $params;\n\t}\n}\n\nclass wfWAFWordPressI18n implements wfWAFI18nEngine {\n\n\tprotected $translations;\n\n\t\/** @var wfWAFStorageInterface *\/\n\tprivate $storageEngine;\n\t\/**\n\t * @var wfMO\n\t *\/\n\tprivate $mo;\n\n\t\/**\n\t * @param wfWAFStorageInterface $storageEngine\n\t *\/\n\tpublic function __construct($storageEngine) {\n\t\t$this->storageEngine = $storageEngine;\n\t\t$this->loadTranslations();\n\t}\n\n\t\/**\n\t * @param string $text\n\t * @return string\n\t *\/\n\tpublic function __($text) {\n\t\tif (!$this->storageEngine->getConfig('wordfenceI18n', true, 'synced')) {\n\t\t\treturn $text;\n\t\t}\n\n\t\tif ($this->mo) {\n\t\t\t$translated = $this->mo->translate($text);\n\t\t\tif ($translated) {\n\t\t\t\treturn $translated;\n\t\t\t}\n\t\t}\n\n\t\treturn $text;\n\t}\n\n\tprivate function getPotentialDirectories() {\n\t\treturn array(\n\t\t\tdirname(__FILE__) . \"\/..\/languages\/\",\n\t\t\tdirname(WFWAF_LOG_PATH) . \"\/languages\/plugins\/\"\n\t\t);\n\t}\n\n\tprotected function loadTranslations() {\n\t\trequire_once dirname(__FILE__) . '\/pomo\/mo.php';\n\n\t\t$currentLocale = $this->storageEngine->getConfig('WPLANG', '', 'synced');\n\t\tif (!preg_match(\"\/^[a-zA-Z_]+$\/\", $currentLocale))\n\t\t\treturn false;\n\t\t$filename = \"wordfence-{$currentLocale}.mo\";\n\n\t\tforeach ($this->getPotentialDirectories() as $directory) {\n\t\t\t$path = \"{$directory}\/{$filename}\";\n\t\t\tif (file_exists($path)) {\n\t\t\t\t$this->mo = new wfMO();\n\t\t\t\treturn $this->mo->import_from_file($path);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n\ntry {\n\nif (!defined('WFWAF_LOG_PATH')) {\n\tif (!defined('WP_CONTENT_DIR')) { \/\/Loading before WordPress\n\t\texit();\n\t}\n\tdefine('WFWAF_LOG_PATH', WP_CONTENT_DIR . '\/wflogs\/');\n}\nif (!is_dir(WFWAF_LOG_PATH)) {\n\t@mkdir(WFWAF_LOG_PATH, (wfWAFWordPress::permissions() | 0755));\n\t@chmod(WFWAF_LOG_PATH, (wfWAFWordPress::permissions() | 0755));\n\twfWAFWordPress::writeHtaccess();\n}\n\n\ntry {\n\tif (!defined('WFWAF_STORAGE_ENGINE') && isset($_SERVER['WFWAF_STORAGE_ENGINE'])) {\n\t\tdefine('WFWAF_STORAGE_ENGINE', $_SERVER['WFWAF_STORAGE_ENGINE']);\n\t}\n\telse if (!defined('WFWAF_STORAGE_ENGINE') && (WF_IS_WP_ENGINE || WF_IS_FLYWHEEL)) {\n\t\tdefine('WFWAF_STORAGE_ENGINE', 'mysqli');\n\t}\n\n\t$specifiedStorageEngine = defined('WFWAF_STORAGE_ENGINE');\n\t$fallbackStorageEngine = false;\n\tif ($specifiedStorageEngine) {\n\t\tswitch (WFWAF_STORAGE_ENGINE) {\n\t\t\tcase 'mysqli':\n\t\t\t\t$wfWAFDBCredentials = array();\n\t\t\t\t$sslOptions = array();\n\t\t\t\t$overrideConstants = array(\n\t\t\t\t\t'wfWAFDBCredentials' => array(\n\t\t\t\t\t\t'WFWAF_DB_NAME' => 'database',\n\t\t\t\t\t\t'WFWAF_DB_USER' => 'user',\n\t\t\t\t\t\t'WFWAF_DB_PASSWORD' => 'pass',\n\t\t\t\t\t\t'WFWAF_DB_HOST' => 'host',\n\t\t\t\t\t\t'WFWAF_DB_CHARSET' => 'charset',\n\t\t\t\t\t\t'WFWAF_DB_COLLATE' => 'collation',\n\t\t\t\t\t\t'WFWAF_MYSQL_CLIENT_FLAGS' => 'flags',\n\t\t\t\t\t\t'WFWAF_TABLE_PREFIX' => 'tablePrefix'\n\t\t\t\t\t),\n\t\t\t\t\t'sslOptions' => array(\n\t\t\t\t\t\t'WFWAF_DB_SSL_KEY' => 'key',\n\t\t\t\t\t\t'WFWAF_DB_SSL_CERTIFICATE' => 'certificate',\n\t\t\t\t\t\t'WFWAF_DB_SSL_CA_CERTIFICATE' => 'ca_certificate',\n\t\t\t\t\t\t'WFWAF_DB_SSL_CA_PATH' => 'ca_path',\n\t\t\t\t\t\t'WFWAF_DB_SSL_CIPHER_ALGOS' => 'cipher_algos'\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t\tforeach ($overrideConstants as $variable => $constants) {\n\t\t\t\t\tforeach ($constants as $constant => $key) {\n\t\t\t\t\t\tif (defined($constant)) {\n\t\t\t\t\t\t\t${$variable}[$key] = constant($constant);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t\/\/ Find the wp-config.php\n\t\t\t\tif (is_dir(dirname(WFWAF_LOG_PATH))) {\n\t\t\t\t\tif (file_exists(dirname(WFWAF_LOG_PATH) . '\/..\/wp-config.php')) {\n\t\t\t\t\t\twfWAFUtils::extractCredentialsWPConfig(dirname(WFWAF_LOG_PATH) . '\/..\/wp-config.php', $wfWAFDBCredentials);\n\t\t\t\t\t} else if (file_exists(dirname(WFWAF_LOG_PATH) . '\/..\/..\/wp-config.php')) {\n\t\t\t\t\t\twfWAFUtils::extractCredentialsWPConfig(dirname(WFWAF_LOG_PATH) . '\/..\/..\/wp-config.php', $wfWAFDBCredentials);\n\t\t\t\t\t}\n\t\t\t\t} else if (!empty($_SERVER['DOCUMENT_ROOT'])) {\n\t\t\t\t\tif (file_exists($_SERVER['DOCUMENT_ROOT'] . '\/wp-config.php')) {\n\t\t\t\t\t\twfWAFUtils::extractCredentialsWPConfig($_SERVER['DOCUMENT_ROOT'] . '\/wp-config.php', $wfWAFDBCredentials);\n\t\t\t\t\t} else if (file_exists($_SERVER['DOCUMENT_ROOT'] . '\/..\/wp-config.php')) {\n\t\t\t\t\t\twfWAFUtils::extractCredentialsWPConfig($_SERVER['DOCUMENT_ROOT'] . '\/..\/wp-config.php', $wfWAFDBCredentials);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$wfWAFDBCredentials = false;\n\t\t\t\t}\n\n\t\t\t\tif (!empty($wfWAFDBCredentials)) {\n\t\t\t\t\t$wfWAFStorageEngine = new wfWAFWordPressStorageMySQL(new wfWAFStorageEngineMySQLi(), $wfWAFDBCredentials['tablePrefix'], wfShutdownRegistry::getDefaultInstance());\n\t\t\t\t\t$wfWAFStorageEngine->getDb()->connect(\n\t\t\t\t\t\t$wfWAFDBCredentials['user'],\n\t\t\t\t\t\t$wfWAFDBCredentials['pass'],\n\t\t\t\t\t\t$wfWAFDBCredentials['database'],\n\t\t\t\t\t\t!empty($wfWAFDBCredentials['ipv6']) ? '[' . $wfWAFDBCredentials['host'] . ']' : $wfWAFDBCredentials['host'],\n\t\t\t\t\t\t!empty($wfWAFDBCredentials['port']) ? $wfWAFDBCredentials['port'] : null,\n\t\t\t\t\t\t!empty($wfWAFDBCredentials['socket']) ? $wfWAFDBCredentials['socket'] : null,\n\t\t\t\t\t\tarray_key_exists('flags', $wfWAFDBCredentials) ? $wfWAFDBCredentials['flags'] : 0,\n\t\t\t\t\t\t$sslOptions\n\t\t\t\t\t);\n\t\t\t\t\tif (array_key_exists('charset', $wfWAFDBCredentials)) {\n\t\t\t\t\t\t$wfWAFStorageEngine->getDb()\n\t\t\t\t\t\t\t->setCharset($wfWAFDBCredentials['charset'],\n\t\t\t\t\t\t\t\t!empty($wfWAFDBCredentials['collation']) ? $wfWAFDBCredentials['collation'] : '');\n\t\t\t\t\t}\n\t\t\t\t\tif (defined('ABSPATH')) {\n\t\t\t\t\t\t$tableExists = false;\n\t\t\t\t\t\t$optionName = 'wordfence_installed'; \/\/Also exists in wfConfig.php\n\t\t\t\t\t\tif (is_multisite() && function_exists('get_network_option')) {\n\t\t\t\t\t\t\t$tableExists = get_network_option(null, $optionName, null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t$tableExists = get_option($optionName, null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t$wfWAFStorageEngine->installing = !$tableExists;\n\t\t\t\t\t\t$wfWAFStorageEngine->getDb()->installing = $wfWAFStorageEngine->installing;\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tunset($wfWAFDBCredentials);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (empty($wfWAFStorageEngine)) {\n\t\t$wfWAFStorageEngine = new wfWAFStorageFile(\n\t\t\tWFWAF_LOG_PATH . 'attack-data.php',\n\t\t\tWFWAF_LOG_PATH . 'ips.php',\n\t\t\tWFWAF_LOG_PATH . 'config.php',\n\t\t\tWFWAF_LOG_PATH . 'rules.php',\n\t\t\tWFWAF_LOG_PATH . 'wafRules.rules'\n\t\t);\n\t\tif ($specifiedStorageEngine)\n\t\t\t$fallbackStorageEngine = true;\n\t}\n\n\twfWAF::setSharedStorageEngine($wfWAFStorageEngine, $fallbackStorageEngine);\n\twfWAF::setInstance(new wfWAFWordPress(wfWAFWordPressRequest::createFromGlobals(), wfWAF::getSharedStorageEngine()));\n\twfWAF::getInstance()->getEventBus()->attach(new wfWAFWordPressObserver(wfWAF::getInstance()));\n\n\tif ($wfWAFStorageEngine instanceof wfWAFStorageFile) {\n\t\t$rulesFiles = array(\n\t\t\tWFWAF_LOG_PATH . 'rules.php',\n\t\t\t\/\/ WFWAF_PATH . 'rules.php',\n\t\t);\n\t\tforeach ($rulesFiles as $rulesFile) {\n\t\t\tif (!file_exists($rulesFile) && !wfWAF::getInstance()->isReadOnly()) {\n\t\t\t\t@touch($rulesFile);\n\t\t\t}\n\t\t\t@chmod($rulesFile, (wfWAFWordPress::permissions() | 0444));\n\t\t\tif (is_writable($rulesFile)) {\n\t\t\t\twfWAF::getInstance()->setCompiledRulesFile($rulesFile);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if ($wfWAFStorageEngine instanceof wfWAFStorageMySQL) {\n\t\t$wfWAFStorageEngine->runMigrations();\n\t\t$wfWAFStorageEngine->setDefaults();\n\t}\n\n\tif (!wfWAF::getInstance()->isReadOnly()) {\n\t\tif (wfWAF::getInstance()->getStorageEngine()->needsInitialRules()) {\n\t\t\ttry {\n\t\t\t\tif (wfWAF::getInstance()->getStorageEngine()->getConfig('apiKey', null, 'synced') !== null &&\n\t\t\t\t\twfWAF::getInstance()->getStorageEngine()->getConfig('createInitialRulesDelay', null, 'transient') < time()\n\t\t\t\t) {\n\t\t\t\t\t$event = new wfWAFCronFetchRulesEvent(time() - 60);\n\t\t\t\t\t$event->setWaf(wfWAF::getInstance());\n\t\t\t\t\t$event->fire();\n\t\t\t\t\twfWAF::getInstance()->getStorageEngine()->setConfig('createInitialRulesDelay', time() + (5 * 60), 'transient');\n\t\t\t\t}\n\t\t\t} catch (wfWAFBuildRulesException $e) {\n\t\t\t\t\/\/ Log this somewhere\n\t\t\t\terror_log($e->getMessage());\n\t\t\t} catch (Exception $e) {\n\t\t\t\t\/\/ Suppress this\n\t\t\t\terror_log($e->getMessage());\n\t\t\t}\n\t\t}\n\t}\n\n\tif (WFWAF_DEBUG && file_exists(wfWAF::getInstance()->getStorageEngine()->getRulesDSLCacheFile())) {\n\t\ttry {\n\t\t\twfWAF::getInstance()->updateRuleSet(file_get_contents(wfWAF::getInstance()->getStorageEngine()->getRulesDSLCacheFile()), false);\n\t\t} catch (wfWAFBuildRulesException $e) {\n\t\t\t$GLOBALS['wfWAFDebugBuildException'] = $e;\n\t\t} catch (Exception $e) {\n\t\t\t$GLOBALS['wfWAFDebugBuildException'] = $e;\n\t\t}\n\t}\n\n\twfWAFI18n::setInstance(new wfWAFI18n(new wfWAFWordPressI18n($wfWAFStorageEngine)));\n\n\ttry {\n\t\twfWAF::getInstance()->run();\n\t} catch (wfWAFBuildRulesException $e) {\n\t\t\/\/ Log this\n\t\terror_log($e->getMessage());\n\t}\n\n} catch (wfWAFStorageFileConfigException $e) {\n\t\/\/ Let this request through for now\n\terror_log($e->getMessage());\n\n} catch (wfWAFStorageEngineMySQLiException $e) {\n\t\/\/ Let this request through for now\n\terror_log($e->getMessage());\n\n} catch (wfWAFStorageFileException $e) {\n\t\/\/ We need to choose another storage engine here.\n}\n\n}\ncatch (Exception $e) { \/\/ In PHP 5, Throwable does not exist\n\terror_log(\"An unexpected exception occurred during WAF execution: {$e}\");\n\t$wf_waf_failure = array(\n\t\t'throwable' => $e\n\t);\n}\ncatch (Throwable $t) {\n\terror_log(\"An unexpected exception occurred during WAF execution: {$t}\");\n\tif (class_exists('ParseError') && $t instanceof ParseError) {\n\t\t\/\/Do nothing\n\t}\n\telse {\n\t\t$wf_waf_failure = array(\n\t\t\t'throwable' => $t\n\t\t);\n\t}\n}\nif (wfWAF::getInstance() === null) {\n\trequire_once __DIR__ . '\/dummy.php';\n\twfWAF::setInstance(new wfDummyWaf());\n}\ndefine('WFWAF_RUN_COMPLETE', true);\n}"},{"base":"plugins","rel":"wordfence\/waf\/dummy.php","ext":"php","size":2902,"mtime":1757312769,"type":"text","content":"<?php\n\n\/**\n * A dummy WAF implementation that can be used if initialization of the actual WAF failures\n *\/\n\nclass wfDummyWaf extends wfWAF {\n\n\tpublic function __construct() {\n\t\tparent::__construct(new wfDummyWafRequest(), new wfDummyWafStorageEngine());\n\t}\n\n}\n\nclass wfDummyWafRequest implements wfWAFRequestInterface {\n\n\tpublic function getBody() {\n\t\treturn null;\n\t}\n\n\tpublic function getRawBody() {\n\t\treturn null;\n\t}\n\n\tpublic function getMd5Body() {\n\t\treturn null;\n\t}\n\n\tpublic function getJsonBody() {\n\t\treturn null;\n\t}\n\n\tpublic function getQueryString() {\n\t\treturn null;\n\t}\n\n\tpublic function getMd5QueryString() {\n\t\treturn null;\n\t}\n\n\tpublic function getHeaders() {\n\t\treturn null;\n\t}\n\n\tpublic function getCookies() {\n\t\treturn null;\n\t}\n\n\tpublic function getFiles() {\n\t\treturn null;\n\t}\n\n\tpublic function getFileNames() {\n\t\treturn null;\n\t}\n\n\tpublic function getHost() {\n\t\treturn null;\n\t}\n\n\tpublic function getURI() {\n\t\treturn null;\n\t}\n\n\tpublic function setMetadata($metadata) {\n\t}\n\n\tpublic function getMetadata() {\n\t\treturn null;\n\t}\n\n\tpublic function getPath() {\n\t\treturn null;\n\t}\n\n\tpublic function getIP() {\n\t\treturn null;\n\t}\n\n\tpublic function getMethod() {\n\t\treturn null;\n\t}\n\n\tpublic function getProtocol() {\n\t\treturn null;\n\t}\n\n\tpublic function getAuth() {\n\t\treturn null;\n\t}\n\n\tpublic function getTimestamp() {\n\t\treturn null;\n\t}\n\n\tpublic function __toString() {\n\t\treturn '';\n\t}\n\n}\n\nclass wfDummyWafStorageEngine implements wfWAFStorageInterface {\n\n\tpublic function hasPreviousAttackData($olderThan) {\n\t\treturn false;\n\t}\n\n\tpublic function hasNewerAttackData($newerThan) {\n\t\treturn false;\n\t}\n\n\tpublic function getAttackData() {\n\t\treturn null;\n\t}\n\n\tpublic function getAttackDataArray() {\n\t\treturn array();\n\t}\n\n\tpublic function getNewestAttackDataArray($newerThan) {\n\t\treturn array();\n\t}\n\n\tpublic function truncateAttackData() {\n\t}\n\n\tpublic function logAttack($failedRules, $failedParamKey, $failedParamValue, $request, $_ = null) {\n\t}\n\n\tpublic function blockIP($timestamp, $ip) {\n\t}\n\n\tpublic function isIPBlocked($ip) {\n\t\treturn false;\n\t}\n\n\tpublic function purgeIPBlocks($types = wfWAFStorageInterface::IP_BLOCKS_ALL) {\n\t}\n\n\tpublic function getConfig($key, $default = null, $category = '') {\n\t\tif ($key === 'wafStatus')\n\t\t\treturn 'disabled';\n\t\treturn $default;\n\t}\n\n\tpublic function setConfig($key, $value, $category = '') {\n\t}\n\n\tpublic function unsetConfig($key, $category = '') {\n\t}\n\n\tpublic function uninstall() {\n\t}\n\n\tpublic function isInLearningMode() {\n\t\treturn false;\n\t}\n\n\tpublic function isDisabled() {\n\t\treturn true;\n\t}\n\n\tpublic function getRulesDSLCacheFile() {\n\t\treturn null;\n\t}\n\n\tpublic function isAttackDataFull() {\n\t\treturn false;\n\t}\n\n\tpublic function vacuum() {\n\t}\n\n\tpublic function getRules() {\n\t\treturn array();\n\t}\n\n\tpublic function setRules($rules) {\n\t}\n\n\tpublic function needsInitialRules() {\n\t\treturn false;\n\t}\n\n\tpublic function getDescription() {\n\t\treturn 'Dummy Storage Engine';\n\t}\n\n}"},{"base":"plugins","rel":"wordfence\/waf\/wfWAFUserIPRange.php","ext":"php","size":7924,"mtime":1757312769,"type":"text","content":"<?php\nif (!defined('WFWAF_RUN_COMPLETE')) {\n\n\/**\n *\n *\/\nclass wfWAFUserIPRange {\n\n\t\/**\n\t * @var string|null\n\t *\/\n\tprivate $ip_string;\n\n\t\/**\n\t * @param string|null $ip_string\n\t *\/\n\tpublic function __construct($ip_string = null) {\n\t\t$this->setIPString($ip_string);\n\t}\n\t\n\tpublic function isIPInRange($ip) {\n\t\t$ip_string = $this->getIPString();\n\t\t\n\t\tif (strpos($ip_string, '\/') !== false) { \/\/CIDR range -- 127.0.0.1\/24\n\t\t\treturn wfWAFUtils::subnetContainsIP($ip_string, $ip);\n\t\t}\n\t\telse if (strpos($ip_string, '[') !== false) \/\/Bracketed range -- 127.0.0.[1-100]\n\t\t{\n\t\t\t\/\/ IPv4 range\n\t\t\tif (strpos($ip_string, '.') !== false && strpos($ip, '.') !== false) {\n\t\t\t\t\/\/ IPv4-mapped-IPv6\n\t\t\t\tif (preg_match('\/:ffff:([^:]+)$\/i', $ip_string, $matches)) {\n\t\t\t\t\t$ip_string = $matches[1];\n\t\t\t\t}\n\t\t\t\tif (preg_match('\/:ffff:([^:]+)$\/i', $ip, $matches)) {\n\t\t\t\t\t$ip = $matches[1];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\/\/ Range check\n\t\t\t\tif (preg_match('\/\\[\\d+\\-\\d+\\]\/', $ip_string)) {\n\t\t\t\t\t$IPparts = explode('.', $ip);\n\t\t\t\t\t$whiteParts = explode('.', $ip_string);\n\t\t\t\t\t$mismatch = false;\n\t\t\t\t\tif (count($whiteParts) != 4 || count($IPparts) != 4) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor ($i = 0; $i <= 3; $i++) {\n\t\t\t\t\t\tif (preg_match('\/^\\[(\\d+)\\-(\\d+)\\]$\/', $whiteParts[$i], $m)) {\n\t\t\t\t\t\t\tif ($IPparts[$i] < $m[1] || $IPparts[$i] > $m[2]) {\n\t\t\t\t\t\t\t\t$mismatch = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ($whiteParts[$i] != $IPparts[$i]) {\n\t\t\t\t\t\t\t$mismatch = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ($mismatch === false) {\n\t\t\t\t\t\treturn true; \/\/ Is whitelisted because we did not get a mismatch\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ($ip_string == $ip) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\/\/ IPv6 range\n\t\t\t}\n\t\t\telse if (strpos($ip_string, ':') !== false && strpos($ip, ':') !== false) {\n\t\t\t\t$ip = strtolower(wfWAFUtils::expandIPv6Address($ip));\n\t\t\t\t$ip_string = strtolower(self::expandIPv6Range($ip_string));\n\t\t\t\tif (preg_match('\/\\[[a-f0-9]+\\-[a-f0-9]+\\]\/i', $ip_string)) {\n\t\t\t\t\t$IPparts = explode(':', $ip);\n\t\t\t\t\t$whiteParts = explode(':', $ip_string);\n\t\t\t\t\t$mismatch = false;\n\t\t\t\t\tif (count($whiteParts) != 8 || count($IPparts) != 8) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor ($i = 0; $i <= 7; $i++) {\n\t\t\t\t\t\tif (preg_match('\/^\\[([a-f0-9]+)\\-([a-f0-9]+)\\]$\/i', $whiteParts[$i], $m)) {\n\t\t\t\t\t\t\t$ip_group = hexdec($IPparts[$i]);\n\t\t\t\t\t\t\t$range_group_from = hexdec($m[1]);\n\t\t\t\t\t\t\t$range_group_to = hexdec($m[2]);\n\t\t\t\t\t\t\tif ($ip_group < $range_group_from || $ip_group > $range_group_to) {\n\t\t\t\t\t\t\t\t$mismatch = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ($whiteParts[$i] != $IPparts[$i]) {\n\t\t\t\t\t\t\t$mismatch = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ($mismatch === false) {\n\t\t\t\t\t\treturn true; \/\/ Is whitelisted because we did not get a mismatch\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ($ip_string == $ip) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (strpos($ip_string, '-') !== false) { \/\/Linear range -- 127.0.0.1 - 127.0.1.100\n\t\t\tlist($ip1, $ip2) = explode('-', $ip_string);\n\t\t\t$ip1N = wfWAFUtils::inet_pton($ip1);\n\t\t\t$ip2N = wfWAFUtils::inet_pton($ip2);\n\t\t\t$ipN = wfWAFUtils::inet_pton($ip);\n\t\t\treturn (strcmp($ip1N, $ipN) <= 0 && strcmp($ip2N, $ipN) >= 0);\n\t\t}\n\t\telse { \/\/Treat as a literal IP\n\t\t\t$ip1 = wfWAFUtils::inet_pton($ip_string);\n\t\t\t$ip2 = wfWAFUtils::inet_pton($ip);\n\t\t\tif ($ip1 !== false && $ip1 == $ip2) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\n\tprivate static function repeatString($string, $count) {\n\t\tif ($count <= 0)\n\t\t\treturn '';\n\t\treturn str_repeat($string, $count);\n\t}\n\n\t\/**\n\t * Expand a compressed printable range representation of an IPv6 address.\n\t *\n\t * @todo Hook up exceptions for better error handling.\n\t * @todo Allow IPv4 mapped IPv6 addresses (::ffff:192.168.1.1).\n\t * @param string $ip_range\n\t * @return string\n\t *\/\n\tpublic static function expandIPv6Range($ip_range) {\n\t\t$colon_count = substr_count($ip_range, ':');\n\t\t$dbl_colon_count = substr_count($ip_range, '::');\n\t\tif ($dbl_colon_count > 1) {\n\t\t\treturn false;\n\t\t}\n\t\t$dbl_colon_pos = strpos($ip_range, '::');\n\t\tif ($dbl_colon_pos !== false) {\n\t\t\t$ip_range = str_replace('::', self::repeatString(':0000',\n\t\t\t\t\t(($dbl_colon_pos === 0 || $dbl_colon_pos === strlen($ip_range) - 2) ? 9 : 8) - $colon_count) . ':', $ip_range);\n\t\t\t$ip_range = trim($ip_range, ':');\n\t\t}\n\t\t$colon_count = substr_count($ip_range, ':');\n\t\tif ($colon_count != 7) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$groups = explode(':', $ip_range);\n\t\t$expanded = '';\n\t\tforeach ($groups as $group) {\n\t\t\tif (preg_match('\/\\[([a-f0-9]{1,4})\\-([a-f0-9]{1,4})\\]\/i', $group, $matches)) {\n\t\t\t\t$expanded .= sprintf('[%s-%s]', str_pad(strtolower($matches[1]), 4, '0', STR_PAD_LEFT), str_pad(strtolower($matches[2]), 4, '0', STR_PAD_LEFT)) . ':';\n\t\t\t} else if (preg_match('\/[a-f0-9]{1,4}\/i', $group)) {\n\t\t\t\t$expanded .= str_pad(strtolower($group), 4, '0', STR_PAD_LEFT) . ':';\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn trim($expanded, ':');\n\t}\n\n\t\/**\n\t * @return bool\n\t *\/\n\tpublic function isValidRange() {\n\t\treturn $this->isValidCIDRRange() || $this->isValidBracketedRange() || $this->isValidLinearRange() || filter_var($this->getIPString(), FILTER_VALIDATE_IP) !== false;\n\t}\n\t\n\tpublic function isValidCIDRRange() { \/\/e.g., 192.0.2.1\/24\n\t\t$ip_string = $this->getIPString();\n\t\tif (preg_match('\/[^0-9a-f:\\\/\\.]\/i', $ip_string)) { return false; }\n\t\t$components = explode('\/', $ip_string);\n\t\tif (count($components) != 2) { return false; }\n\t\t\n\t\tlist($ip, $prefix) = $components;\n\t\tif (filter_var($ip, FILTER_VALIDATE_IP) === false) { return false; }\n\t\t\n\t\tif (!preg_match('\/^\\d+$\/', $prefix)) { return false; }\n\t\t\n\t\tif (filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4)) {\n\t\t\tif ($prefix < 0 || $prefix > 32) { return false; }\n\t\t}\n\t\telse {\n\t\t\tif ($prefix < 1 || $prefix > 128) { return false; }\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic function isValidBracketedRange() { \/\/e.g., 192.0.2.[1-10]\n\t\t$ip_string = $this->getIPString();\n\t\tif (preg_match('\/[^0-9a-f:\\.\\[\\]\\-]\/i', $ip_string)) { return false; }\n\t\tif (strpos($ip_string, '.') !== false) { \/\/IPv4\n\t\t\tif (preg_match_all('\/(\\d+)\/', $ip_string, $matches) > 0) {\n\t\t\t\tforeach ($matches[1] as $match) {\n\t\t\t\t\t$group = (int) $match;\n\t\t\t\t\tif ($group > 255 || $group < 0) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t$group_regex = '([0-9]{1,3}|\\[[0-9]{1,3}\\-[0-9]{1,3}\\])';\n\t\t\treturn preg_match('\/^' . str_repeat(\"{$group_regex}\\\\.\", 3) . $group_regex . '$\/i', $ip_string) > 0;\n\t\t}\n\t\t\n\t\t\/\/IPv6\n\t\tif (strpos($ip_string, '::') !== false) {\n\t\t\t$ip_string = self::expandIPv6Range($ip_string);\n\t\t}\n\t\tif (!$ip_string) {\n\t\t\treturn false;\n\t\t}\n\t\t$group_regex = '([a-f0-9]{1,4}|\\[[a-f0-9]{1,4}\\-[a-f0-9]{1,4}\\])';\n\t\treturn preg_match('\/^' . str_repeat(\"$group_regex:\", 7) . $group_regex . '$\/i', $ip_string) > 0;\n\t}\n\t\n\tpublic function isValidLinearRange() { \/\/e.g., 192.0.2.1-192.0.2.100\n\t\t$ip_string = $this->getIPString();\n\t\tif (preg_match('\/[^0-9a-f:\\.\\-]\/i', $ip_string)) { return false; }\n\t\tlist($ip1, $ip2) = explode(\"-\", $ip_string);\n\t\t\n\t\tif (filter_var($ip1, FILTER_VALIDATE_IP) === false || filter_var($ip2, FILTER_VALIDATE_IP) === false) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t$ip1N = wfWAFUtils::inet_pton($ip1);\n\t\t$ip2N = wfWAFUtils::inet_pton($ip2);\n\t\t\n\t\tif ($ip1N === false || $ip2N === false) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn strcmp($ip1N, $ip2N) <= 0;\n\t}\n\t\n\tprotected function _sanitizeIPRange($ip_string) {\n\t\t$ip_string = preg_replace('\/\\s\/', '', $ip_string); \/\/Strip whitespace\n\t\t$ip_string = preg_replace('\/[\\\\x{2013}-\\\\x{2015}]\/u', '-', $ip_string); \/\/Non-hyphen dashes to hyphen\n\t\t$ip_string = strtolower($ip_string);\n\t\t\n\t\tif (preg_match('\/^\\d+-\\d+$\/', $ip_string)) { \/\/v5 32 bit int style format\n\t\t\tlist($start, $end) = explode('-', $ip_string);\n\t\t\t$start = long2ip($start);\n\t\t\t$end = long2ip($end);\n\t\t\t$ip_string = \"{$start}-{$end}\";\n\t\t}\n\t\t\n\t\treturn $ip_string;\n\t}\n\n\n\t\/**\n\t * @return string|null\n\t *\/\n\tpublic function getIPString() {\n\t\treturn $this->ip_string;\n\t}\n\n\t\/**\n\t * @param string|null $ip_string\n\t *\/\n\tpublic function setIPString($ip_string) {\n\t\t$this->ip_string = $this->_sanitizeIPRange($ip_string);\n\t}\n}\n}"},{"base":"plugins","rel":"wordfence\/waf\/pomo\/translations.php","ext":"php","size":10984,"mtime":1757312769,"type":"text","content":"<?php\n\/**\n * This is a modified version of the POMO library included with WordPress. The WordPress copyright has been included\n * for attribution.\n *\/\n\n\/*\nWordPress - Web publishing software\n\nCopyright 2011-2020 by the contributors\n\nThis program is free software; you can redistribute it and\/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\nThis program incorporates work covered by the following copyright and\npermission notices:\n\n  b2 is (c) 2001, 2002 Michel Valdrighi - https:\/\/cafelog.com\n\n  Wherever third party code has been used, credit has been given in the code's\n  comments.\n\n  b2 is released under the GPL\n\nand\n\n  WordPress - Web publishing software\n\n  Copyright 2003-2010 by the contributors\n\n  WordPress is released under the GPL\n *\/\n\n\n\/**\n * Class for a set of entries for translation and their associated headers\n *\n * @version $Id: translations.php 1157 2015-11-20 04:30:11Z dd32 $\n * @package pomo\n * @subpackage translations\n *\/\n\nrequire_once __DIR__ . '\/plural-forms.php';\nrequire_once __DIR__ . '\/entry.php';\n\nif ( ! class_exists( 'wfTranslations', false ) ) :\n\tclass wfTranslations {\n\t\tvar $entries = array();\n\t\tvar $headers = array();\n\n\t\t\/**\n\t\t * Add entry to the PO structure\n\t\t *\n\t\t * @param array|wfTranslation_Entry $entry\n\t\t * @return bool true on success, false if the entry doesn't have a key\n\t\t *\/\n\t\tfunction add_entry( $entry ) {\n\t\t\tif ( is_array( $entry ) ) {\n\t\t\t\t$entry = new wfTranslation_Entry( $entry );\n\t\t\t}\n\t\t\t$key = $entry->key();\n\t\t\tif ( false === $key ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$this->entries[ $key ] = &$entry;\n\t\t\treturn true;\n\t\t}\n\n\t\t\/**\n\t\t * @param array|wfTranslation_Entry $entry\n\t\t * @return bool\n\t\t *\/\n\t\tfunction add_entry_or_merge( $entry ) {\n\t\t\tif ( is_array( $entry ) ) {\n\t\t\t\t$entry = new wfTranslation_Entry( $entry );\n\t\t\t}\n\t\t\t$key = $entry->key();\n\t\t\tif ( false === $key ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ( isset( $this->entries[ $key ] ) ) {\n\t\t\t\t$this->entries[ $key ]->merge_with( $entry );\n\t\t\t} else {\n\t\t\t\t$this->entries[ $key ] = &$entry;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t\/**\n\t\t * Sets $header PO header to $value\n\t\t *\n\t\t * If the header already exists, it will be overwritten\n\t\t *\n\t\t * TODO: this should be out of this class, it is gettext specific\n\t\t *\n\t\t * @param string $header header name, without trailing :\n\t\t * @param string $value header value, without trailing \\n\n\t\t *\/\n\t\tfunction set_header( $header, $value ) {\n\t\t\t$this->headers[ $header ] = $value;\n\t\t}\n\n\t\t\/**\n\t\t * @param array $headers\n\t\t *\/\n\t\tfunction set_headers( $headers ) {\n\t\t\tforeach ( $headers as $header => $value ) {\n\t\t\t\t$this->set_header( $header, $value );\n\t\t\t}\n\t\t}\n\n\t\t\/**\n\t\t * @param string $header\n\t\t *\/\n\t\tfunction get_header( $header ) {\n\t\t\treturn isset( $this->headers[ $header ] ) ? $this->headers[ $header ] : false;\n\t\t}\n\n\t\t\/**\n\t\t * @param wfTranslation_Entry $entry\n\t\t *\/\n\t\tfunction translate_entry( &$entry ) {\n\t\t\t$key = $entry->key();\n\t\t\treturn isset( $this->entries[ $key ] ) ? $this->entries[ $key ] : false;\n\t\t}\n\n\t\t\/**\n\t\t * @param string $singular\n\t\t * @param string $context\n\t\t * @return string\n\t\t *\/\n\t\tfunction translate( $singular, $context = null ) {\n\t\t\t$entry      = new wfTranslation_Entry(\n\t\t\t\tarray(\n\t\t\t\t\t'singular' => $singular,\n\t\t\t\t\t'context'  => $context,\n\t\t\t\t)\n\t\t\t);\n\t\t\t$translated = $this->translate_entry( $entry );\n\t\t\treturn ( $translated && ! empty( $translated->translations ) ) ? $translated->translations[0] : $singular;\n\t\t}\n\n\t\t\/**\n\t\t * Given the number of items, returns the 0-based index of the plural form to use\n\t\t *\n\t\t * Here, in the base Translations class, the common logic for English is implemented:\n\t\t *  0 if there is one element, 1 otherwise\n\t\t *\n\t\t * This function should be overridden by the subclasses. For example MO\/PO can derive the logic\n\t\t * from their headers.\n\t\t *\n\t\t * @param integer $count number of items\n\t\t *\/\n\t\tfunction select_plural_form( $count ) {\n\t\t\treturn 1 == $count ? 0 : 1;\n\t\t}\n\n\t\t\/**\n\t\t * @return int\n\t\t *\/\n\t\tfunction get_plural_forms_count() {\n\t\t\treturn 2;\n\t\t}\n\n\t\t\/**\n\t\t * @param string $singular\n\t\t * @param string $plural\n\t\t * @param int    $count\n\t\t * @param string $context\n\t\t *\/\n\t\tfunction translate_plural( $singular, $plural, $count, $context = null ) {\n\t\t\t$entry              = new wfTranslation_Entry(\n\t\t\t\tarray(\n\t\t\t\t\t'singular' => $singular,\n\t\t\t\t\t'plural'   => $plural,\n\t\t\t\t\t'context'  => $context,\n\t\t\t\t)\n\t\t\t);\n\t\t\t$translated         = $this->translate_entry( $entry );\n\t\t\t$index              = $this->select_plural_form( $count );\n\t\t\t$total_plural_forms = $this->get_plural_forms_count();\n\t\t\tif ( $translated && 0 <= $index && $index < $total_plural_forms &&\n\t\t\t\tis_array( $translated->translations ) &&\n\t\t\t\tisset( $translated->translations[ $index ] ) ) {\n\t\t\t\treturn $translated->translations[ $index ];\n\t\t\t} else {\n\t\t\t\treturn 1 == $count ? $singular : $plural;\n\t\t\t}\n\t\t}\n\n\t\t\/**\n\t\t * Merge $other in the current object.\n\t\t *\n\t\t * @param Object $other Another Translation object, whose translations will be merged in this one (passed by reference).\n\t\t * @return void\n\t\t *\/\n\t\tfunction merge_with( &$other ) {\n\t\t\tforeach ( $other->entries as $entry ) {\n\t\t\t\t$this->entries[ $entry->key() ] = $entry;\n\t\t\t}\n\t\t}\n\n\t\t\/**\n\t\t * @param object $other\n\t\t *\/\n\t\tfunction merge_originals_with( &$other ) {\n\t\t\tforeach ( $other->entries as $entry ) {\n\t\t\t\tif ( ! isset( $this->entries[ $entry->key() ] ) ) {\n\t\t\t\t\t$this->entries[ $entry->key() ] = $entry;\n\t\t\t\t} else {\n\t\t\t\t\t$this->entries[ $entry->key() ]->merge_with( $entry );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tclass wfGettext_Translations extends wfTranslations {\n\n\t\tprivate $_gettext_select_plural_form = null;\n\n\t\t\/**\n\t\t * The gettext implementation of select_plural_form.\n\t\t *\n\t\t * It lives in this class, because there are more than one descendand, which will use it and\n\t\t * they can't share it effectively.\n\t\t *\n\t\t * @param int $count\n\t\t *\/\n\t\tfunction gettext_select_plural_form( $count ) {\n\t\t\tif ( ! isset( $this->_gettext_select_plural_form ) || is_null( $this->_gettext_select_plural_form ) ) {\n\t\t\t\tlist( $nplurals, $expression )     = $this->nplurals_and_expression_from_header( $this->get_header( 'Plural-Forms' ) );\n\t\t\t\t$this->_nplurals                   = $nplurals;\n\t\t\t\t$this->_gettext_select_plural_form = $this->make_plural_form_function( $nplurals, $expression );\n\t\t\t}\n\t\t\treturn call_user_func( $this->_gettext_select_plural_form, $count );\n\t\t}\n\n\t\t\/**\n\t\t * @param string $header\n\t\t * @return array\n\t\t *\/\n\t\tfunction nplurals_and_expression_from_header( $header ) {\n\t\t\tif ( preg_match( '\/^\\s*nplurals\\s*=\\s*(\\d+)\\s*;\\s+plural\\s*=\\s*(.+)$\/', $header, $matches ) ) {\n\t\t\t\t$nplurals   = (int) $matches[1];\n\t\t\t\t$expression = trim( $matches[2] );\n\t\t\t\treturn array( $nplurals, $expression );\n\t\t\t} else {\n\t\t\t\treturn array( 2, 'n != 1' );\n\t\t\t}\n\t\t}\n\n\t\t\/**\n\t\t * Makes a function, which will return the right translation index, according to the\n\t\t * plural forms header\n\t\t *\n\t\t * @param int    $nplurals\n\t\t * @param string $expression\n\t\t *\/\n\t\tfunction make_plural_form_function( $nplurals, $expression ) {\n\t\t\ttry {\n\t\t\t\t$handler = new wfPlural_Forms( rtrim( $expression, ';' ) );\n\t\t\t\treturn array( $handler, 'get' );\n\t\t\t} catch ( Exception $e ) {\n\t\t\t\t\/\/ Fall back to default plural-form function.\n\t\t\t\treturn $this->make_plural_form_function( 2, 'n != 1' );\n\t\t\t}\n\t\t}\n\n\t\t\/**\n\t\t * Adds parentheses to the inner parts of ternary operators in\n\t\t * plural expressions, because PHP evaluates ternary oerators from left to right\n\t\t *\n\t\t * @param string $expression the expression without parentheses\n\t\t * @return string the expression with parentheses added\n\t\t *\/\n\t\tfunction parenthesize_plural_exression( $expression ) {\n\t\t\t$expression .= ';';\n\t\t\t$res         = '';\n\t\t\t$depth       = 0;\n\t\t\tfor ( $i = 0; $i < strlen( $expression ); ++$i ) {\n\t\t\t\t$char = $expression[ $i ];\n\t\t\t\tswitch ( $char ) {\n\t\t\t\t\tcase '?':\n\t\t\t\t\t\t$res .= ' ? (';\n\t\t\t\t\t\t$depth++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ':':\n\t\t\t\t\t\t$res .= ') : (';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ';':\n\t\t\t\t\t\t$res  .= str_repeat( ')', $depth ) . ';';\n\t\t\t\t\t\t$depth = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t$res .= $char;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn rtrim( $res, ';' );\n\t\t}\n\n\t\t\/**\n\t\t * @param string $translation\n\t\t * @return array\n\t\t *\/\n\t\tfunction make_headers( $translation ) {\n\t\t\t$headers = array();\n\t\t\t\/\/ Sometimes \\n's are used instead of real new lines.\n\t\t\t$translation = str_replace( '\\n', \"\\n\", $translation );\n\t\t\t$lines       = explode( \"\\n\", $translation );\n\t\t\tforeach ( $lines as $line ) {\n\t\t\t\t$parts = explode( ':', $line, 2 );\n\t\t\t\tif ( ! isset( $parts[1] ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t$headers[ trim( $parts[0] ) ] = trim( $parts[1] );\n\t\t\t}\n\t\t\treturn $headers;\n\t\t}\n\n\t\t\/**\n\t\t * @param string $header\n\t\t * @param string $value\n\t\t *\/\n\t\tfunction set_header( $header, $value ) {\n\t\t\tparent::set_header( $header, $value );\n\t\t\tif ( 'Plural-Forms' === $header ) {\n\t\t\t\tlist( $nplurals, $expression )     = $this->nplurals_and_expression_from_header( $this->get_header( 'Plural-Forms' ) );\n\t\t\t\t$this->_nplurals                   = $nplurals;\n\t\t\t\t$this->_gettext_select_plural_form = $this->make_plural_form_function( $nplurals, $expression );\n\t\t\t}\n\t\t}\n\t}\nendif;\n\nif ( ! class_exists( 'wfNOOP_Translations', false ) ) :\n\t\/**\n\t * Provides the same interface as Translations, but doesn't do anything\n\t *\/\n\tclass wfNOOP_Translations {\n\t\tvar $entries = array();\n\t\tvar $headers = array();\n\n\t\tfunction add_entry( $entry ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t\/**\n\t\t * @param string $header\n\t\t * @param string $value\n\t\t *\/\n\t\tfunction set_header( $header, $value ) {\n\t\t}\n\n\t\t\/**\n\t\t * @param array $headers\n\t\t *\/\n\t\tfunction set_headers( $headers ) {\n\t\t}\n\n\t\t\/**\n\t\t * @param string $header\n\t\t * @return false\n\t\t *\/\n\t\tfunction get_header( $header ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t\/**\n\t\t * @param wfTranslation_Entry $entry\n\t\t * @return false\n\t\t *\/\n\t\tfunction translate_entry( &$entry ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t\/**\n\t\t * @param string $singular\n\t\t * @param string $context\n\t\t *\/\n\t\tfunction translate( $singular, $context = null ) {\n\t\t\treturn $singular;\n\t\t}\n\n\t\t\/**\n\t\t * @param int $count\n\t\t * @return bool\n\t\t *\/\n\t\tfunction select_plural_form( $count ) {\n\t\t\treturn 1 == $count ? 0 : 1;\n\t\t}\n\n\t\t\/**\n\t\t * @return int\n\t\t *\/\n\t\tfunction get_plural_forms_count() {\n\t\t\treturn 2;\n\t\t}\n\n\t\t\/**\n\t\t * @param string $singular\n\t\t * @param string $plural\n\t\t * @param int    $count\n\t\t * @param string $context\n\t\t *\/\n\t\tfunction translate_plural( $singular, $plural, $count, $context = null ) {\n\t\t\treturn 1 == $count ? $singular : $plural;\n\t\t}\n\n\t\t\/**\n\t\t * @param object $other\n\t\t *\/\n\t\tfunction merge_with( &$other ) {\n\t\t}\n\t}\nendif;"},{"base":"plugins","rel":"wordfence\/waf\/pomo\/plural-forms.php","ext":"php","size":8424,"mtime":1757312769,"type":"text","content":"<?php\n\/**\n * This is a modified version of the POMO library included with WordPress. The WordPress copyright has been included\n * for attribution.\n *\/\n\n\/*\nWordPress - Web publishing software\n\nCopyright 2011-2020 by the contributors\n\nThis program is free software; you can redistribute it and\/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\nThis program incorporates work covered by the following copyright and\npermission notices:\n\n  b2 is (c) 2001, 2002 Michel Valdrighi - https:\/\/cafelog.com\n\n  Wherever third party code has been used, credit has been given in the code's\n  comments.\n\n  b2 is released under the GPL\n\nand\n\n  WordPress - Web publishing software\n\n  Copyright 2003-2010 by the contributors\n\n  WordPress is released under the GPL\n *\/\n\n\n\/**\n * A gettext Plural-Forms parser.\n *\n * @since 4.9.0\n *\/\nclass wfPlural_Forms {\n\t\/**\n\t * Operator characters.\n\t *\n\t * @since 4.9.0\n\t * @var string OP_CHARS Operator characters.\n\t *\/\n\tconst OP_CHARS = '|&><!=%?:';\n\n\t\/**\n\t * Valid number characters.\n\t *\n\t * @since 4.9.0\n\t * @var string NUM_CHARS Valid number characters.\n\t *\/\n\tconst NUM_CHARS = '0123456789';\n\n\t\/**\n\t * Operator precedence.\n\t *\n\t * Operator precedence from highest to lowest. Higher numbers indicate\n\t * higher precedence, and are executed first.\n\t *\n\t * @see https:\/\/en.wikipedia.org\/wiki\/Operators_in_C_and_C%2B%2B#Operator_precedence\n\t *\n\t * @since 4.9.0\n\t * @var array $op_precedence Operator precedence from highest to lowest.\n\t *\/\n\tprotected static $op_precedence = array(\n\t\t'%'  => 6,\n\n\t\t'<'  => 5,\n\t\t'<=' => 5,\n\t\t'>'  => 5,\n\t\t'>=' => 5,\n\n\t\t'==' => 4,\n\t\t'!=' => 4,\n\n\t\t'&&' => 3,\n\n\t\t'||' => 2,\n\n\t\t'?:' => 1,\n\t\t'?'  => 1,\n\n\t\t'('  => 0,\n\t\t')'  => 0,\n\t);\n\n\t\/**\n\t * Tokens generated from the string.\n\t *\n\t * @since 4.9.0\n\t * @var array $tokens List of tokens.\n\t *\/\n\tprotected $tokens = array();\n\n\t\/**\n\t * Cache for repeated calls to the function.\n\t *\n\t * @since 4.9.0\n\t * @var array $cache Map of $n => $result\n\t *\/\n\tprotected $cache = array();\n\n\t\/**\n\t * Constructor.\n\t *\n\t * @since 4.9.0\n\t *\n\t * @param string $str Plural function (just the bit after `plural=` from Plural-Forms)\n\t *\/\n\tpublic function __construct( $str ) {\n\t\t$this->parse( $str );\n\t}\n\n\t\/**\n\t * Parse a Plural-Forms string into tokens.\n\t *\n\t * Uses the shunting-yard algorithm to convert the string to Reverse Polish\n\t * Notation tokens.\n\t *\n\t * @since 4.9.0\n\t *\n\t * @param string $str String to parse.\n\t *\/\n\tprotected function parse( $str ) {\n\t\t$pos = 0;\n\t\t$len = strlen( $str );\n\n\t\t\/\/ Convert infix operators to postfix using the shunting-yard algorithm.\n\t\t$output = array();\n\t\t$stack  = array();\n\t\twhile ( $pos < $len ) {\n\t\t\t$next = substr( $str, $pos, 1 );\n\n\t\t\tswitch ( $next ) {\n\t\t\t\t\/\/ Ignore whitespace.\n\t\t\t\tcase ' ':\n\t\t\t\tcase \"\\t\":\n\t\t\t\t\t$pos++;\n\t\t\t\t\tbreak;\n\n\t\t\t\t\/\/ Variable (n).\n\t\t\t\tcase 'n':\n\t\t\t\t\t$output[] = array( 'var' );\n\t\t\t\t\t$pos++;\n\t\t\t\t\tbreak;\n\n\t\t\t\t\/\/ Parentheses.\n\t\t\t\tcase '(':\n\t\t\t\t\t$stack[] = $next;\n\t\t\t\t\t$pos++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ')':\n\t\t\t\t\t$found = false;\n\t\t\t\t\twhile ( ! empty( $stack ) ) {\n\t\t\t\t\t\t$o2 = $stack[ count( $stack ) - 1 ];\n\t\t\t\t\t\tif ( '(' !== $o2 ) {\n\t\t\t\t\t\t\t$output[] = array( 'op', array_pop( $stack ) );\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\/\/ Discard open paren.\n\t\t\t\t\t\tarray_pop( $stack );\n\t\t\t\t\t\t$found = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! $found ) {\n\t\t\t\t\t\tthrow new Exception( 'Mismatched parentheses' );\n\t\t\t\t\t}\n\n\t\t\t\t\t$pos++;\n\t\t\t\t\tbreak;\n\n\t\t\t\t\/\/ Operators.\n\t\t\t\tcase '|':\n\t\t\t\tcase '&':\n\t\t\t\tcase '>':\n\t\t\t\tcase '<':\n\t\t\t\tcase '!':\n\t\t\t\tcase '=':\n\t\t\t\tcase '%':\n\t\t\t\tcase '?':\n\t\t\t\t\t$end_operator = strspn( $str, self::OP_CHARS, $pos );\n\t\t\t\t\t$operator     = substr( $str, $pos, $end_operator );\n\t\t\t\t\tif ( ! array_key_exists( $operator, self::$op_precedence ) ) {\n\t\t\t\t\t\tthrow new Exception( sprintf( 'Unknown operator \"%s\"', $operator ) );\n\t\t\t\t\t}\n\n\t\t\t\t\twhile ( ! empty( $stack ) ) {\n\t\t\t\t\t\t$o2 = $stack[ count( $stack ) - 1 ];\n\n\t\t\t\t\t\t\/\/ Ternary is right-associative in C.\n\t\t\t\t\t\tif ( '?:' === $operator || '?' === $operator ) {\n\t\t\t\t\t\t\tif ( self::$op_precedence[ $operator ] >= self::$op_precedence[ $o2 ] ) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} elseif ( self::$op_precedence[ $operator ] > self::$op_precedence[ $o2 ] ) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$output[] = array( 'op', array_pop( $stack ) );\n\t\t\t\t\t}\n\t\t\t\t\t$stack[] = $operator;\n\n\t\t\t\t\t$pos += $end_operator;\n\t\t\t\t\tbreak;\n\n\t\t\t\t\/\/ Ternary \"else\".\n\t\t\t\tcase ':':\n\t\t\t\t\t$found = false;\n\t\t\t\t\t$s_pos = count( $stack ) - 1;\n\t\t\t\t\twhile ( $s_pos >= 0 ) {\n\t\t\t\t\t\t$o2 = $stack[ $s_pos ];\n\t\t\t\t\t\tif ( '?' !== $o2 ) {\n\t\t\t\t\t\t\t$output[] = array( 'op', array_pop( $stack ) );\n\t\t\t\t\t\t\t$s_pos--;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\/\/ Replace.\n\t\t\t\t\t\t$stack[ $s_pos ] = '?:';\n\t\t\t\t\t\t$found           = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! $found ) {\n\t\t\t\t\t\tthrow new Exception( 'Missing starting \"?\" ternary operator' );\n\t\t\t\t\t}\n\t\t\t\t\t$pos++;\n\t\t\t\t\tbreak;\n\n\t\t\t\t\/\/ Default - number or invalid.\n\t\t\t\tdefault:\n\t\t\t\t\tif ( $next >= '0' && $next <= '9' ) {\n\t\t\t\t\t\t$span     = strspn( $str, self::NUM_CHARS, $pos );\n\t\t\t\t\t\t$output[] = array( 'value', intval( substr( $str, $pos, $span ) ) );\n\t\t\t\t\t\t$pos     += $span;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new Exception( sprintf( 'Unknown symbol \"%s\"', $next ) );\n\t\t\t}\n\t\t}\n\n\t\twhile ( ! empty( $stack ) ) {\n\t\t\t$o2 = array_pop( $stack );\n\t\t\tif ( '(' === $o2 || ')' === $o2 ) {\n\t\t\t\tthrow new Exception( 'Mismatched parentheses' );\n\t\t\t}\n\n\t\t\t$output[] = array( 'op', $o2 );\n\t\t}\n\n\t\t$this->tokens = $output;\n\t}\n\n\t\/**\n\t * Get the plural form for a number.\n\t *\n\t * Caches the value for repeated calls.\n\t *\n\t * @since 4.9.0\n\t *\n\t * @param int $num Number to get plural form for.\n\t * @return int Plural form value.\n\t *\/\n\tpublic function get( $num ) {\n\t\tif ( isset( $this->cache[ $num ] ) ) {\n\t\t\treturn $this->cache[ $num ];\n\t\t}\n\t\t$this->cache[ $num ] = $this->execute( $num );\n\t\treturn $this->cache[ $num ];\n\t}\n\n\t\/**\n\t * Execute the plural form function.\n\t *\n\t * @since 4.9.0\n\t *\n\t * @param int $n Variable \"n\" to substitute.\n\t * @return int Plural form value.\n\t *\/\n\tpublic function execute( $n ) {\n\t\t$stack = array();\n\t\t$i     = 0;\n\t\t$total = count( $this->tokens );\n\t\twhile ( $i < $total ) {\n\t\t\t$next = $this->tokens[ $i ];\n\t\t\t$i++;\n\t\t\tif ( 'var' === $next[0] ) {\n\t\t\t\t$stack[] = $n;\n\t\t\t\tcontinue;\n\t\t\t} elseif ( 'value' === $next[0] ) {\n\t\t\t\t$stack[] = $next[1];\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t\/\/ Only operators left.\n\t\t\tswitch ( $next[1] ) {\n\t\t\t\tcase '%':\n\t\t\t\t\t$v2      = array_pop( $stack );\n\t\t\t\t\t$v1      = array_pop( $stack );\n\t\t\t\t\t$stack[] = $v1 % $v2;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '||':\n\t\t\t\t\t$v2      = array_pop( $stack );\n\t\t\t\t\t$v1      = array_pop( $stack );\n\t\t\t\t\t$stack[] = $v1 || $v2;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '&&':\n\t\t\t\t\t$v2      = array_pop( $stack );\n\t\t\t\t\t$v1      = array_pop( $stack );\n\t\t\t\t\t$stack[] = $v1 && $v2;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '<':\n\t\t\t\t\t$v2      = array_pop( $stack );\n\t\t\t\t\t$v1      = array_pop( $stack );\n\t\t\t\t\t$stack[] = $v1 < $v2;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '<=':\n\t\t\t\t\t$v2      = array_pop( $stack );\n\t\t\t\t\t$v1      = array_pop( $stack );\n\t\t\t\t\t$stack[] = $v1 <= $v2;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '>':\n\t\t\t\t\t$v2      = array_pop( $stack );\n\t\t\t\t\t$v1      = array_pop( $stack );\n\t\t\t\t\t$stack[] = $v1 > $v2;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '>=':\n\t\t\t\t\t$v2      = array_pop( $stack );\n\t\t\t\t\t$v1      = array_pop( $stack );\n\t\t\t\t\t$stack[] = $v1 >= $v2;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '!=':\n\t\t\t\t\t$v2      = array_pop( $stack );\n\t\t\t\t\t$v1      = array_pop( $stack );\n\t\t\t\t\t$stack[] = $v1 != $v2;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '==':\n\t\t\t\t\t$v2      = array_pop( $stack );\n\t\t\t\t\t$v1      = array_pop( $stack );\n\t\t\t\t\t$stack[] = $v1 == $v2;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '?:':\n\t\t\t\t\t$v3      = array_pop( $stack );\n\t\t\t\t\t$v2      = array_pop( $stack );\n\t\t\t\t\t$v1      = array_pop( $stack );\n\t\t\t\t\t$stack[] = $v1 ? $v2 : $v3;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Exception( sprintf( 'Unknown operator \"%s\"', $next[1] ) );\n\t\t\t}\n\t\t}\n\n\t\tif ( count( $stack ) !== 1 ) {\n\t\t\tthrow new Exception( 'Too many values remaining on the stack' );\n\t\t}\n\n\t\treturn (int) $stack[0];\n\t}\n}\n"},{"base":"plugins","rel":"wordfence\/waf\/pomo\/po.php","ext":"php","size":16162,"mtime":1757312769,"type":"text","content":"<?php\n\/**\n * This is a modified version of the POMO library included with WordPress. The WordPress copyright has been included\n * for attribution.\n *\/\n\n\/*\nWordPress - Web publishing software\n\nCopyright 2011-2020 by the contributors\n\nThis program is free software; you can redistribute it and\/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\nThis program incorporates work covered by the following copyright and\npermission notices:\n\n  b2 is (c) 2001, 2002 Michel Valdrighi - https:\/\/cafelog.com\n\n  Wherever third party code has been used, credit has been given in the code's\n  comments.\n\n  b2 is released under the GPL\n\nand\n\n  WordPress - Web publishing software\n\n  Copyright 2003-2010 by the contributors\n\n  WordPress is released under the GPL\n *\/\n\n\n\/**\n * Class for working with PO files\n *\n * @version $Id: po.php 1158 2015-11-20 04:31:23Z dd32 $\n * @package pomo\n * @subpackage po\n *\/\n\nrequire_once __DIR__ . '\/translations.php';\n\nif ( ! defined( 'WF_PO_MAX_LINE_LEN' ) ) {\n\tdefine( 'WF_PO_MAX_LINE_LEN', 79 );\n}\n\nini_set( 'auto_detect_line_endings', 1 );\n\n\/**\n * Routines for working with PO files\n *\/\nif ( ! class_exists( 'wfPO', false ) ) :\n\tclass wfPO extends wfGettext_Translations {\n\n\t\tvar $comments_before_headers = '';\n\n\t\t\/**\n\t\t * Exports headers to a PO entry\n\t\t *\n\t\t * @return string msgid\/msgstr PO entry for this PO file headers, doesn't contain newline at the end\n\t\t *\/\n\t\tfunction export_headers() {\n\t\t\t$header_string = '';\n\t\t\tforeach ( $this->headers as $header => $value ) {\n\t\t\t\t$header_string .= \"$header: $value\\n\";\n\t\t\t}\n\t\t\t$poified = wfPO::poify( $header_string );\n\t\t\tif ( $this->comments_before_headers ) {\n\t\t\t\t$before_headers = $this->prepend_each_line( rtrim( $this->comments_before_headers ) . \"\\n\", '# ' );\n\t\t\t} else {\n\t\t\t\t$before_headers = '';\n\t\t\t}\n\t\t\treturn rtrim( \"{$before_headers}msgid \\\"\\\"\\nmsgstr $poified\" );\n\t\t}\n\n\t\t\/**\n\t\t * Exports all entries to PO format\n\t\t *\n\t\t * @return string sequence of mgsgid\/msgstr PO strings, doesn't containt newline at the end\n\t\t *\/\n\t\tfunction export_entries() {\n\t\t\t\/\/ TODO: Sorting.\n\t\t\treturn implode( \"\\n\\n\", array_map( array('wfPO', 'export_entry' ), $this->entries ) );\n\t\t}\n\n\t\t\/**\n\t\t * Exports the whole PO file as a string\n\t\t *\n\t\t * @param bool $include_headers whether to include the headers in the export\n\t\t * @return string ready for inclusion in PO file string for headers and all the enrtries\n\t\t *\/\n\t\tfunction export( $include_headers = true ) {\n\t\t\t$res = '';\n\t\t\tif ( $include_headers ) {\n\t\t\t\t$res .= $this->export_headers();\n\t\t\t\t$res .= \"\\n\\n\";\n\t\t\t}\n\t\t\t$res .= $this->export_entries();\n\t\t\treturn $res;\n\t\t}\n\n\t\t\/**\n\t\t * Same as {@link export}, but writes the result to a file\n\t\t *\n\t\t * @param string $filename        Where to write the PO string.\n\t\t * @param bool   $include_headers Whether to include the headers in the export.\n\t\t * @return bool true on success, false on error\n\t\t *\/\n\t\tfunction export_to_file( $filename, $include_headers = true ) {\n\t\t\t$fh = fopen( $filename, 'w' );\n\t\t\tif ( false === $fh ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$export = $this->export( $include_headers );\n\t\t\t$res    = fwrite( $fh, $export );\n\t\t\tif ( false === $res ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn fclose( $fh );\n\t\t}\n\n\t\t\/**\n\t\t * Text to include as a comment before the start of the PO contents\n\t\t *\n\t\t * Doesn't need to include # in the beginning of lines, these are added automatically\n\t\t *\n\t\t * @param string $text Text to include as a comment.\n\t\t *\/\n\t\tfunction set_comment_before_headers( $text ) {\n\t\t\t$this->comments_before_headers = $text;\n\t\t}\n\n\t\t\/**\n\t\t * Formats a string in PO-style\n\t\t *\n\t\t * @param string $string the string to format\n\t\t * @return string the poified string\n\t\t *\/\n\t\tpublic static function poify( $string ) {\n\t\t\t$quote   = '\"';\n\t\t\t$slash   = '\\\\';\n\t\t\t$newline = \"\\n\";\n\n\t\t\t$replaces = array(\n\t\t\t\t\"$slash\" => \"{$slash}{$slash}\",\n\t\t\t\t\"$quote\" => \"{$slash}{$quote}\",\n\t\t\t\t\"\\t\"     => '\\t',\n\t\t\t);\n\n\t\t\t$string = str_replace( array_keys( $replaces ), array_values( $replaces ), $string );\n\n\t\t\t$po = $quote . implode( \"{$slash}n{$quote}{$newline}{$quote}\", explode( $newline, $string ) ) . $quote;\n\t\t\t\/\/ Add empty string on first line for readbility.\n\t\t\tif ( false !== strpos( $string, $newline ) &&\n\t\t\t\t( substr_count( $string, $newline ) > 1 || substr( $string, -strlen( $newline ) ) !== $newline ) ) {\n\t\t\t\t$po = \"{$quote}{$quote}{$newline}{$po}\";\n\t\t\t}\n\t\t\t\/\/ Remove empty strings.\n\t\t\t$po = str_replace( \"{$newline}{$quote}{$quote}\", '', $po );\n\t\t\treturn $po;\n\t\t}\n\n\t\t\/**\n\t\t * Gives back the original string from a PO-formatted string\n\t\t *\n\t\t * @param string $string PO-formatted string\n\t\t * @return string enascaped string\n\t\t *\/\n\t\tpublic static function unpoify( $string ) {\n\t\t\t$escapes               = array(\n\t\t\t\t't'  => \"\\t\",\n\t\t\t\t'n'  => \"\\n\",\n\t\t\t\t'r'  => \"\\r\",\n\t\t\t\t'\\\\' => '\\\\',\n\t\t\t);\n\t\t\t$lines                 = array_map( 'trim', explode( \"\\n\", $string ) );\n\t\t\t$lines                 = array_map( array('wfPO', 'trim_quotes' ), $lines );\n\t\t\t$unpoified             = '';\n\t\t\t$previous_is_backslash = false;\n\t\t\tforeach ( $lines as $line ) {\n\t\t\t\tpreg_match_all( '\/.\/u', $line, $chars );\n\t\t\t\t$chars = $chars[0];\n\t\t\t\tforeach ( $chars as $char ) {\n\t\t\t\t\tif ( ! $previous_is_backslash ) {\n\t\t\t\t\t\tif ( '\\\\' === $char ) {\n\t\t\t\t\t\t\t$previous_is_backslash = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$unpoified .= $char;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$previous_is_backslash = false;\n\t\t\t\t\t\t$unpoified            .= isset( $escapes[ $char ] ) ? $escapes[ $char ] : $char;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\/\/ Standardise the line endings on imported content, technically PO files shouldn't contain \\r.\n\t\t\t$unpoified = str_replace( array( \"\\r\\n\", \"\\r\" ), \"\\n\", $unpoified );\n\n\t\t\treturn $unpoified;\n\t\t}\n\n\t\t\/**\n\t\t * Inserts $with in the beginning of every new line of $string and\n\t\t * returns the modified string\n\t\t *\n\t\t * @param string $string prepend lines in this string\n\t\t * @param string $with prepend lines with this string\n\t\t *\/\n\t\tpublic static function prepend_each_line( $string, $with ) {\n\t\t\t$lines  = explode( \"\\n\", $string );\n\t\t\t$append = '';\n\t\t\tif ( \"\\n\" === substr( $string, -1 ) && '' === end( $lines ) ) {\n\t\t\t\t\/*\n\t\t\t\t * Last line might be empty because $string was terminated\n\t\t\t\t * with a newline, remove it from the $lines array,\n\t\t\t\t * we'll restore state by re-terminating the string at the end.\n\t\t\t\t *\/\n\t\t\t\tarray_pop( $lines );\n\t\t\t\t$append = \"\\n\";\n\t\t\t}\n\t\t\tforeach ( $lines as &$line ) {\n\t\t\t\t$line = $with . $line;\n\t\t\t}\n\t\t\tunset( $line );\n\t\t\treturn implode( \"\\n\", $lines ) . $append;\n\t\t}\n\n\t\t\/**\n\t\t * Prepare a text as a comment -- wraps the lines and prepends #\n\t\t * and a special character to each line\n\t\t *\n\t\t * @access private\n\t\t * @param string $text the comment text\n\t\t * @param string $char character to denote a special PO comment,\n\t\t *  like :, default is a space\n\t\t *\/\n\t\tpublic static function comment_block( $text, $char = ' ' ) {\n\t\t\t$text = wordwrap( $text, WF_PO_MAX_LINE_LEN - 3 );\n\t\t\treturn wfPO::prepend_each_line( $text, \"#$char \" );\n\t\t}\n\n\t\t\/**\n\t\t * Builds a string from the entry for inclusion in PO file\n\t\t *\n\t\t * @param wfTranslation_Entry $entry the entry to convert to po string (passed by reference).\n\t\t * @return string|false PO-style formatted string for the entry or\n\t\t *  false if the entry is empty\n\t\t *\/\n\t\tpublic static function export_entry( &$entry ) {\n\t\t\tif ( null === $entry->singular || '' === $entry->singular ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$po = array();\n\t\t\tif ( ! empty( $entry->translator_comments ) ) {\n\t\t\t\t$po[] = wfPO::comment_block( $entry->translator_comments );\n\t\t\t}\n\t\t\tif ( ! empty( $entry->extracted_comments ) ) {\n\t\t\t\t$po[] = wfPO::comment_block( $entry->extracted_comments, '.' );\n\t\t\t}\n\t\t\tif ( ! empty( $entry->references ) ) {\n\t\t\t\t$po[] = wfPO::comment_block( implode( ' ', $entry->references ), ':' );\n\t\t\t}\n\t\t\tif ( ! empty( $entry->flags ) ) {\n\t\t\t\t$po[] = wfPO::comment_block( implode( ', ', $entry->flags ), ',' );\n\t\t\t}\n\t\t\tif ( $entry->context ) {\n\t\t\t\t$po[] = 'msgctxt ' . wfPO::poify( $entry->context );\n\t\t\t}\n\t\t\t$po[] = 'msgid ' . wfPO::poify( $entry->singular );\n\t\t\tif ( ! $entry->is_plural ) {\n\t\t\t\t$translation = empty( $entry->translations ) ? '' : $entry->translations[0];\n\t\t\t\t$translation = wfPO::match_begin_and_end_newlines( $translation, $entry->singular );\n\t\t\t\t$po[]        = 'msgstr ' . wfPO::poify( $translation );\n\t\t\t} else {\n\t\t\t\t$po[]         = 'msgid_plural ' . wfPO::poify( $entry->plural );\n\t\t\t\t$translations = empty( $entry->translations ) ? array( '', '' ) : $entry->translations;\n\t\t\t\tforeach ( $translations as $i => $translation ) {\n\t\t\t\t\t$translation = wfPO::match_begin_and_end_newlines( $translation, $entry->plural );\n\t\t\t\t\t$po[]        = \"msgstr[$i] \" . wfPO::poify( $translation );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn implode( \"\\n\", $po );\n\t\t}\n\n\t\tpublic static function match_begin_and_end_newlines( $translation, $original ) {\n\t\t\tif ( '' === $translation ) {\n\t\t\t\treturn $translation;\n\t\t\t}\n\n\t\t\t$original_begin    = \"\\n\" === substr( $original, 0, 1 );\n\t\t\t$original_end      = \"\\n\" === substr( $original, -1 );\n\t\t\t$translation_begin = \"\\n\" === substr( $translation, 0, 1 );\n\t\t\t$translation_end   = \"\\n\" === substr( $translation, -1 );\n\n\t\t\tif ( $original_begin ) {\n\t\t\t\tif ( ! $translation_begin ) {\n\t\t\t\t\t$translation = \"\\n\" . $translation;\n\t\t\t\t}\n\t\t\t} elseif ( $translation_begin ) {\n\t\t\t\t$translation = ltrim( $translation, \"\\n\" );\n\t\t\t}\n\n\t\t\tif ( $original_end ) {\n\t\t\t\tif ( ! $translation_end ) {\n\t\t\t\t\t$translation .= \"\\n\";\n\t\t\t\t}\n\t\t\t} elseif ( $translation_end ) {\n\t\t\t\t$translation = rtrim( $translation, \"\\n\" );\n\t\t\t}\n\n\t\t\treturn $translation;\n\t\t}\n\n\t\t\/**\n\t\t * @param string $filename\n\t\t * @return boolean\n\t\t *\/\n\t\tfunction import_from_file( $filename ) {\n\t\t\t$f = fopen( $filename, 'r' );\n\t\t\tif ( ! $f ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$lineno = 0;\n\t\t\twhile ( true ) {\n\t\t\t\t$res = $this->read_entry( $f, $lineno );\n\t\t\t\tif ( ! $res ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ( '' === $res['entry']->singular ) {\n\t\t\t\t\t$this->set_headers( $this->make_headers( $res['entry']->translations[0] ) );\n\t\t\t\t} else {\n\t\t\t\t\t$this->add_entry( $res['entry'] );\n\t\t\t\t}\n\t\t\t}\n\t\t\twfPO::read_line( $f, 'clear' );\n\t\t\tif ( false === $res ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ( ! $this->headers && ! $this->entries ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t\/**\n\t\t * Helper function for read_entry\n\t\t *\n\t\t * @param string $context\n\t\t * @return bool\n\t\t *\/\n\t\tprotected static function is_final( $context ) {\n\t\t\treturn ( 'msgstr' === $context ) || ( 'msgstr_plural' === $context );\n\t\t}\n\n\t\t\/**\n\t\t * @param resource $f\n\t\t * @param int      $lineno\n\t\t * @return null|false|array\n\t\t *\/\n\t\tfunction read_entry( $f, $lineno = 0 ) {\n\t\t\t$entry = new wfTranslation_Entry();\n\t\t\t\/\/ Where were we in the last step.\n\t\t\t\/\/ Can be: comment, msgctxt, msgid, msgid_plural, msgstr, msgstr_plural.\n\t\t\t$context      = '';\n\t\t\t$msgstr_index = 0;\n\t\t\twhile ( true ) {\n\t\t\t\t$lineno++;\n\t\t\t\t$line = wfPO::read_line( $f );\n\t\t\t\tif ( ! $line ) {\n\t\t\t\t\tif ( feof( $f ) ) {\n\t\t\t\t\t\tif ( self::is_final( $context ) ) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} elseif ( ! $context ) { \/\/ We haven't read a line and EOF came.\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( \"\\n\" === $line ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t$line = trim( $line );\n\t\t\t\tif ( preg_match( '\/^#\/', $line, $m ) ) {\n\t\t\t\t\t\/\/ The comment is the start of a new entry.\n\t\t\t\t\tif ( self::is_final( $context ) ) {\n\t\t\t\t\t\twfPO::read_line( $f, 'put-back' );\n\t\t\t\t\t\t$lineno--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\/\/ Comments have to be at the beginning.\n\t\t\t\t\tif ( $context && 'comment' !== $context ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t\/\/ Add comment.\n\t\t\t\t\t$this->add_comment_to_entry( $entry, $line );\n\t\t\t\t} elseif ( preg_match( '\/^msgctxt\\s+(\".*\")\/', $line, $m ) ) {\n\t\t\t\t\tif ( self::is_final( $context ) ) {\n\t\t\t\t\t\twfPO::read_line( $f, 'put-back' );\n\t\t\t\t\t\t$lineno--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ( $context && 'comment' !== $context ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t$context         = 'msgctxt';\n\t\t\t\t\t$entry->context .= wfPO::unpoify( $m[1] );\n\t\t\t\t} elseif ( preg_match( '\/^msgid\\s+(\".*\")\/', $line, $m ) ) {\n\t\t\t\t\tif ( self::is_final( $context ) ) {\n\t\t\t\t\t\twfPO::read_line( $f, 'put-back' );\n\t\t\t\t\t\t$lineno--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ( $context && 'msgctxt' !== $context && 'comment' !== $context ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t$context          = 'msgid';\n\t\t\t\t\t$entry->singular .= wfPO::unpoify( $m[1] );\n\t\t\t\t} elseif ( preg_match( '\/^msgid_plural\\s+(\".*\")\/', $line, $m ) ) {\n\t\t\t\t\tif ( 'msgid' !== $context ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t$context          = 'msgid_plural';\n\t\t\t\t\t$entry->is_plural = true;\n\t\t\t\t\t$entry->plural   .= wfPO::unpoify( $m[1] );\n\t\t\t\t} elseif ( preg_match( '\/^msgstr\\s+(\".*\")\/', $line, $m ) ) {\n\t\t\t\t\tif ( 'msgid' !== $context ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t$context             = 'msgstr';\n\t\t\t\t\t$entry->translations = array( wfPO::unpoify( $m[1] ) );\n\t\t\t\t} elseif ( preg_match( '\/^msgstr\\[(\\d+)\\]\\s+(\".*\")\/', $line, $m ) ) {\n\t\t\t\t\tif ( 'msgid_plural' !== $context && 'msgstr_plural' !== $context ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t$context                      = 'msgstr_plural';\n\t\t\t\t\t$msgstr_index                 = $m[1];\n\t\t\t\t\t$entry->translations[ $m[1] ] = wfPO::unpoify( $m[2] );\n\t\t\t\t} elseif ( preg_match( '\/^\".*\"$\/', $line ) ) {\n\t\t\t\t\t$unpoified = wfPO::unpoify( $line );\n\t\t\t\t\tswitch ( $context ) {\n\t\t\t\t\t\tcase 'msgid':\n\t\t\t\t\t\t\t$entry->singular .= $unpoified;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'msgctxt':\n\t\t\t\t\t\t\t$entry->context .= $unpoified;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'msgid_plural':\n\t\t\t\t\t\t\t$entry->plural .= $unpoified;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'msgstr':\n\t\t\t\t\t\t\t$entry->translations[0] .= $unpoified;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'msgstr_plural':\n\t\t\t\t\t\t\t$entry->translations[ $msgstr_index ] .= $unpoified;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$have_translations = false;\n\t\t\tforeach ( $entry->translations as $t ) {\n\t\t\t\tif ( $t || ( '0' === $t ) ) {\n\t\t\t\t\t$have_translations = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( false === $have_translations ) {\n\t\t\t\t$entry->translations = array();\n\t\t\t}\n\n\t\t\treturn array(\n\t\t\t\t'entry'  => $entry,\n\t\t\t\t'lineno' => $lineno,\n\t\t\t);\n\t\t}\n\n\t\t\/**\n\t\t * @param resource $f\n\t\t * @param string   $action\n\t\t * @return boolean\n\t\t *\/\n\t\tfunction read_line( $f, $action = 'read' ) {\n\t\t\tstatic $last_line     = '';\n\t\t\tstatic $use_last_line = false;\n\t\t\tif ( 'clear' === $action ) {\n\t\t\t\t$last_line = '';\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif ( 'put-back' === $action ) {\n\t\t\t\t$use_last_line = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t$line          = $use_last_line ? $last_line : fgets( $f );\n\t\t\t$line          = ( \"\\r\\n\" === substr( $line, -2 ) ) ? rtrim( $line, \"\\r\\n\" ) . \"\\n\" : $line;\n\t\t\t$last_line     = $line;\n\t\t\t$use_last_line = false;\n\t\t\treturn $line;\n\t\t}\n\n\t\t\/**\n\t\t * @param wfTranslation_Entry $entry\n\t\t * @param string            $po_comment_line\n\t\t *\/\n\t\tfunction add_comment_to_entry( &$entry, $po_comment_line ) {\n\t\t\t$first_two = substr( $po_comment_line, 0, 2 );\n\t\t\t$comment   = trim( substr( $po_comment_line, 2 ) );\n\t\t\tif ( '#:' === $first_two ) {\n\t\t\t\t$entry->references = array_merge( $entry->references, preg_split( '\/\\s+\/', $comment ) );\n\t\t\t} elseif ( '#.' === $first_two ) {\n\t\t\t\t$entry->extracted_comments = trim( $entry->extracted_comments . \"\\n\" . $comment );\n\t\t\t} elseif ( '#,' === $first_two ) {\n\t\t\t\t$entry->flags = array_merge( $entry->flags, preg_split( '\/,\\s*\/', $comment ) );\n\t\t\t} else {\n\t\t\t\t$entry->translator_comments = trim( $entry->translator_comments . \"\\n\" . $comment );\n\t\t\t}\n\t\t}\n\n\t\t\/**\n\t\t * @param string $s\n\t\t * @return string\n\t\t *\/\n\t\tpublic static function trim_quotes( $s ) {\n\t\t\tif ( '\"' === substr( $s, 0, 1 ) ) {\n\t\t\t\t$s = substr( $s, 1 );\n\t\t\t}\n\t\t\tif ( '\"' === substr( $s, -1, 1 ) ) {\n\t\t\t\t$s = substr( $s, 0, -1 );\n\t\t\t}\n\t\t\treturn $s;\n\t\t}\n\t}\nendif;\n"},{"base":"plugins","rel":"wordfence\/waf\/pomo\/entry.php","ext":"php","size":4315,"mtime":1757312769,"type":"text","content":"<?php\n\/**\n * This is a modified version of the POMO library included with WordPress. The WordPress copyright has been included\n * for attribution.\n *\/\n\n\/*\nWordPress - Web publishing software\n\nCopyright 2011-2020 by the contributors\n\nThis program is free software; you can redistribute it and\/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\nThis program incorporates work covered by the following copyright and\npermission notices:\n\n  b2 is (c) 2001, 2002 Michel Valdrighi - https:\/\/cafelog.com\n\n  Wherever third party code has been used, credit has been given in the code's\n  comments.\n\n  b2 is released under the GPL\n\nand\n\n  WordPress - Web publishing software\n\n  Copyright 2003-2010 by the contributors\n\n  WordPress is released under the GPL\n *\/\n\n\n\/**\n * Contains Translation_Entry class\n *\n * @version $Id: entry.php 1157 2015-11-20 04:30:11Z dd32 $\n * @package pomo\n * @subpackage entry\n *\/\n\nif ( ! class_exists( 'wfTranslation_Entry', false ) ) :\n\t\/**\n\t * Translation_Entry class encapsulates a translatable string\n\t *\/\n\tclass wfTranslation_Entry {\n\n\t\t\/**\n\t\t * Whether the entry contains a string and its plural form, default is false\n\t\t *\n\t\t * @var boolean\n\t\t *\/\n\t\tvar $is_plural = false;\n\n\t\tvar $context             = null;\n\t\tvar $singular            = null;\n\t\tvar $plural              = null;\n\t\tvar $translations        = array();\n\t\tvar $translator_comments = '';\n\t\tvar $extracted_comments  = '';\n\t\tvar $references          = array();\n\t\tvar $flags               = array();\n\n\t\t\/**\n\t\t * @param array $args associative array, support following keys:\n\t\t *  - singular (string) -- the string to translate, if omitted and empty entry will be created\n\t\t *  - plural (string) -- the plural form of the string, setting this will set {@link $is_plural} to true\n\t\t *  - translations (array) -- translations of the string and possibly -- its plural forms\n\t\t *  - context (string) -- a string differentiating two equal strings used in different contexts\n\t\t *  - translator_comments (string) -- comments left by translators\n\t\t *  - extracted_comments (string) -- comments left by developers\n\t\t *  - references (array) -- places in the code this strings is used, in relative_to_root_path\/file.php:linenum form\n\t\t *  - flags (array) -- flags like php-format\n\t\t *\/\n\t\tfunction __construct( $args = array() ) {\n\t\t\t\/\/ If no singular -- empty object.\n\t\t\tif ( ! isset( $args['singular'] ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\/\/ Get member variable values from args hash.\n\t\t\tforeach ( $args as $varname => $value ) {\n\t\t\t\t$this->$varname = $value;\n\t\t\t}\n\t\t\tif ( isset( $args['plural'] ) && $args['plural'] ) {\n\t\t\t\t$this->is_plural = true;\n\t\t\t}\n\t\t\tif ( ! is_array( $this->translations ) ) {\n\t\t\t\t$this->translations = array();\n\t\t\t}\n\t\t\tif ( ! is_array( $this->references ) ) {\n\t\t\t\t$this->references = array();\n\t\t\t}\n\t\t\tif ( ! is_array( $this->flags ) ) {\n\t\t\t\t$this->flags = array();\n\t\t\t}\n\t\t}\n\n\t\t\/**\n\t\t * Generates a unique key for this entry\n\t\t *\n\t\t * @return string|bool the key or false if the entry is empty\n\t\t *\/\n\t\tfunction key() {\n\t\t\tif ( null === $this->singular || '' === $this->singular ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t\/\/ Prepend context and EOT, like in MO files.\n\t\t\t$key = ! $this->context ? $this->singular : $this->context . \"\\4\" . $this->singular;\n\t\t\t\/\/ Standardize on \\n line endings.\n\t\t\t$key = str_replace( array( \"\\r\\n\", \"\\r\" ), \"\\n\", $key );\n\n\t\t\treturn $key;\n\t\t}\n\n\t\t\/**\n\t\t * @param object $other\n\t\t *\/\n\t\tfunction merge_with( &$other ) {\n\t\t\t$this->flags      = array_unique( array_merge( $this->flags, $other->flags ) );\n\t\t\t$this->references = array_unique( array_merge( $this->references, $other->references ) );\n\t\t\tif ( $this->extracted_comments != $other->extracted_comments ) {\n\t\t\t\t$this->extracted_comments .= $other->extracted_comments;\n\t\t\t}\n\n\t\t}\n\t}\nendif;\n"},{"base":"plugins","rel":"wordfence\/waf\/pomo\/mo.php","ext":"php","size":10714,"mtime":1757312769,"type":"text","content":"<?php\n\/**\n * This is a modified version of the POMO library included with WordPress. The WordPress copyright has been included\n * for attribution.\n *\/\n\n\/*\nWordPress - Web publishing software\n\nCopyright 2011-2020 by the contributors\n\nThis program is free software; you can redistribute it and\/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\nThis program incorporates work covered by the following copyright and\npermission notices:\n\n  b2 is (c) 2001, 2002 Michel Valdrighi - https:\/\/cafelog.com\n\n  Wherever third party code has been used, credit has been given in the code's\n  comments.\n\n  b2 is released under the GPL\n\nand\n\n  WordPress - Web publishing software\n\n  Copyright 2003-2010 by the contributors\n\n  WordPress is released under the GPL\n *\/\n\n\n\/**\n * Class for working with MO files\n *\n * @version $Id: mo.php 1157 2015-11-20 04:30:11Z dd32 $\n * @package pomo\n * @subpackage mo\n *\/\n\nrequire_once __DIR__ . '\/translations.php';\nrequire_once __DIR__ . '\/streams.php';\n\nif ( ! class_exists( 'wfMO', false ) ) :\n\tclass wfMO extends wfGettext_Translations {\n\n\t\tvar $_nplurals = 2;\n\n\t\t\/**\n\t\t * Loaded MO file.\n\t\t *\n\t\t * @var string\n\t\t *\/\n\t\tprivate $filename = '';\n\n\t\t\/**\n\t\t * Returns the loaded MO file.\n\t\t *\n\t\t * @return string The loaded MO file.\n\t\t *\/\n\t\tpublic function get_filename() {\n\t\t\treturn $this->filename;\n\t\t}\n\n\t\t\/**\n\t\t * Fills up with the entries from MO file $filename\n\t\t *\n\t\t * @param string $filename MO file to load\n\t\t * @return bool True if the import from file was successful, otherwise false.\n\t\t *\/\n\t\tfunction import_from_file( $filename ) {\n\t\t\t$reader = new wfPOMO_FileReader( $filename );\n\n\t\t\tif ( ! $reader->is_resource() ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t$this->filename = (string) $filename;\n\n\t\t\treturn $this->import_from_reader( $reader );\n\t\t}\n\n\t\t\/**\n\t\t * @param string $filename\n\t\t * @return bool\n\t\t *\/\n\t\tfunction export_to_file( $filename ) {\n\t\t\t$fh = fopen( $filename, 'wb' );\n\t\t\tif ( ! $fh ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$res = $this->export_to_file_handle( $fh );\n\t\t\tfclose( $fh );\n\t\t\treturn $res;\n\t\t}\n\n\t\t\/**\n\t\t * @return string|false\n\t\t *\/\n\t\tfunction export() {\n\t\t\t$tmp_fh = fopen( 'php:\/\/temp', 'r+' );\n\t\t\tif ( ! $tmp_fh ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$this->export_to_file_handle( $tmp_fh );\n\t\t\trewind( $tmp_fh );\n\t\t\treturn stream_get_contents( $tmp_fh );\n\t\t}\n\n\t\t\/**\n\t\t * @param wfTranslation_Entry $entry\n\t\t * @return bool\n\t\t *\/\n\t\tfunction is_entry_good_for_export( $entry ) {\n\t\t\tif ( empty( $entry->translations ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif ( ! array_filter( $entry->translations ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\t\/**\n\t\t * @param resource $fh\n\t\t * @return true\n\t\t *\/\n\t\tfunction export_to_file_handle( $fh ) {\n\t\t\t$entries = array_filter( $this->entries, array( $this, 'is_entry_good_for_export' ) );\n\t\t\tksort( $entries );\n\t\t\t$magic                     = 0x950412de;\n\t\t\t$revision                  = 0;\n\t\t\t$total                     = count( $entries ) + 1; \/\/ All the headers are one entry.\n\t\t\t$originals_lenghts_addr    = 28;\n\t\t\t$translations_lenghts_addr = $originals_lenghts_addr + 8 * $total;\n\t\t\t$size_of_hash              = 0;\n\t\t\t$hash_addr                 = $translations_lenghts_addr + 8 * $total;\n\t\t\t$current_addr              = $hash_addr;\n\t\t\tfwrite(\n\t\t\t\t$fh,\n\t\t\t\tpack(\n\t\t\t\t\t'V*',\n\t\t\t\t\t$magic,\n\t\t\t\t\t$revision,\n\t\t\t\t\t$total,\n\t\t\t\t\t$originals_lenghts_addr,\n\t\t\t\t\t$translations_lenghts_addr,\n\t\t\t\t\t$size_of_hash,\n\t\t\t\t\t$hash_addr\n\t\t\t\t)\n\t\t\t);\n\t\t\tfseek( $fh, $originals_lenghts_addr );\n\n\t\t\t\/\/ Headers' msgid is an empty string.\n\t\t\tfwrite( $fh, pack( 'VV', 0, $current_addr ) );\n\t\t\t$current_addr++;\n\t\t\t$originals_table = \"\\0\";\n\n\t\t\t$reader = new wfPOMO_Reader();\n\n\t\t\tforeach ( $entries as $entry ) {\n\t\t\t\t$originals_table .= $this->export_original( $entry ) . \"\\0\";\n\t\t\t\t$length           = $reader->strlen( $this->export_original( $entry ) );\n\t\t\t\tfwrite( $fh, pack( 'VV', $length, $current_addr ) );\n\t\t\t\t$current_addr += $length + 1; \/\/ Account for the NULL byte after.\n\t\t\t}\n\n\t\t\t$exported_headers = $this->export_headers();\n\t\t\tfwrite( $fh, pack( 'VV', $reader->strlen( $exported_headers ), $current_addr ) );\n\t\t\t$current_addr      += strlen( $exported_headers ) + 1;\n\t\t\t$translations_table = $exported_headers . \"\\0\";\n\n\t\t\tforeach ( $entries as $entry ) {\n\t\t\t\t$translations_table .= $this->export_translations( $entry ) . \"\\0\";\n\t\t\t\t$length              = $reader->strlen( $this->export_translations( $entry ) );\n\t\t\t\tfwrite( $fh, pack( 'VV', $length, $current_addr ) );\n\t\t\t\t$current_addr += $length + 1;\n\t\t\t}\n\n\t\t\tfwrite( $fh, $originals_table );\n\t\t\tfwrite( $fh, $translations_table );\n\t\t\treturn true;\n\t\t}\n\n\t\t\/**\n\t\t * @param wfTranslation_Entry $entry\n\t\t * @return string\n\t\t *\/\n\t\tfunction export_original( $entry ) {\n\t\t\t\/\/ TODO: Warnings for control characters.\n\t\t\t$exported = $entry->singular;\n\t\t\tif ( $entry->is_plural ) {\n\t\t\t\t$exported .= \"\\0\" . $entry->plural;\n\t\t\t}\n\t\t\tif ( $entry->context ) {\n\t\t\t\t$exported = $entry->context . \"\\4\" . $exported;\n\t\t\t}\n\t\t\treturn $exported;\n\t\t}\n\n\t\t\/**\n\t\t * @param wfTranslation_Entry $entry\n\t\t * @return string\n\t\t *\/\n\t\tfunction export_translations( $entry ) {\n\t\t\t\/\/ TODO: Warnings for control characters.\n\t\t\treturn $entry->is_plural ? implode( \"\\0\", $entry->translations ) : $entry->translations[0];\n\t\t}\n\n\t\t\/**\n\t\t * @return string\n\t\t *\/\n\t\tfunction export_headers() {\n\t\t\t$exported = '';\n\t\t\tforeach ( $this->headers as $header => $value ) {\n\t\t\t\t$exported .= \"$header: $value\\n\";\n\t\t\t}\n\t\t\treturn $exported;\n\t\t}\n\n\t\t\/**\n\t\t * @param int $magic\n\t\t * @return string|false\n\t\t *\/\n\t\tfunction get_byteorder( $magic ) {\n\t\t\t\/\/ The magic is 0x950412de.\n\n\t\t\t\/\/ bug in PHP 5.0.2, see https:\/\/savannah.nongnu.org\/bugs\/?func=detailitem&item_id=10565\n\t\t\t$magic_little    = (int) - 1794895138;\n\t\t\t$magic_little_64 = (int) 2500072158;\n\t\t\t\/\/ 0xde120495\n\t\t\t$magic_big = ( (int) - 569244523 ) & 0xFFFFFFFF;\n\t\t\tif ( $magic_little == $magic || $magic_little_64 == $magic ) {\n\t\t\t\treturn 'little';\n\t\t\t} elseif ( $magic_big == $magic ) {\n\t\t\t\treturn 'big';\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t\/**\n\t\t * @param wfPOMO_FileReader $reader\n\t\t * @return bool True if the import was successful, otherwise false.\n\t\t *\/\n\t\tfunction import_from_reader( $reader ) {\n\t\t\t$endian_string = wfMO::get_byteorder( $reader->readint32() );\n\t\t\tif ( false === $endian_string ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$reader->setEndian( $endian_string );\n\n\t\t\t$endian = ( 'big' === $endian_string ) ? 'N' : 'V';\n\n\t\t\t$header = $reader->read( 24 );\n\t\t\tif ( $reader->strlen( $header ) != 24 ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t\/\/ Parse header.\n\t\t\t$header = unpack( \"{$endian}revision\/{$endian}total\/{$endian}originals_lenghts_addr\/{$endian}translations_lenghts_addr\/{$endian}hash_length\/{$endian}hash_addr\", $header );\n\t\t\tif ( ! is_array( $header ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t\/\/ Support revision 0 of MO format specs, only.\n\t\t\tif ( 0 != $header['revision'] ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t\/\/ Seek to data blocks.\n\t\t\t$reader->seekto( $header['originals_lenghts_addr'] );\n\n\t\t\t\/\/ Read originals' indices.\n\t\t\t$originals_lengths_length = $header['translations_lenghts_addr'] - $header['originals_lenghts_addr'];\n\t\t\tif ( $originals_lengths_length != $header['total'] * 8 ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t$originals = $reader->read( $originals_lengths_length );\n\t\t\tif ( $reader->strlen( $originals ) != $originals_lengths_length ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t\/\/ Read translations' indices.\n\t\t\t$translations_lenghts_length = $header['hash_addr'] - $header['translations_lenghts_addr'];\n\t\t\tif ( $translations_lenghts_length != $header['total'] * 8 ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t$translations = $reader->read( $translations_lenghts_length );\n\t\t\tif ( $reader->strlen( $translations ) != $translations_lenghts_length ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t\/\/ Transform raw data into set of indices.\n\t\t\t$originals    = $reader->str_split( $originals, 8 );\n\t\t\t$translations = $reader->str_split( $translations, 8 );\n\n\t\t\t\/\/ Skip hash table.\n\t\t\t$strings_addr = $header['hash_addr'] + $header['hash_length'] * 4;\n\n\t\t\t$reader->seekto( $strings_addr );\n\n\t\t\t$strings = $reader->read_all();\n\t\t\t$reader->close();\n\n\t\t\tfor ( $i = 0; $i < $header['total']; $i++ ) {\n\t\t\t\t$o = unpack( \"{$endian}length\/{$endian}pos\", $originals[ $i ] );\n\t\t\t\t$t = unpack( \"{$endian}length\/{$endian}pos\", $translations[ $i ] );\n\t\t\t\tif ( ! $o || ! $t ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t\/\/ Adjust offset due to reading strings to separate space before.\n\t\t\t\t$o['pos'] -= $strings_addr;\n\t\t\t\t$t['pos'] -= $strings_addr;\n\n\t\t\t\t$original    = $reader->substr( $strings, $o['pos'], $o['length'] );\n\t\t\t\t$translation = $reader->substr( $strings, $t['pos'], $t['length'] );\n\n\t\t\t\tif ( '' === $original ) {\n\t\t\t\t\t$this->set_headers( $this->make_headers( $translation ) );\n\t\t\t\t} else {\n\t\t\t\t\t$entry                          = &$this->make_entry( $original, $translation );\n\t\t\t\t\t$this->entries[ $entry->key() ] = &$entry;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t\/**\n\t\t * Build a Translation_Entry from original string and translation strings,\n\t\t * found in a MO file\n\t\t *\n\t\t * @static\n\t\t * @param string $original original string to translate from MO file. Might contain\n\t\t *  0x04 as context separator or 0x00 as singular\/plural separator\n\t\t * @param string $translation translation string from MO file. Might contain\n\t\t *  0x00 as a plural translations separator\n\t\t * @return wfTranslation_Entry Entry instance.\n\t\t *\/\n\t\tfunction &make_entry( $original, $translation ) {\n\t\t\t$entry = new wfTranslation_Entry();\n\t\t\t\/\/ Look for context, separated by \\4.\n\t\t\t$parts = explode( \"\\4\", $original );\n\t\t\tif ( isset( $parts[1] ) ) {\n\t\t\t\t$original       = $parts[1];\n\t\t\t\t$entry->context = $parts[0];\n\t\t\t}\n\t\t\t\/\/ Look for plural original.\n\t\t\t$parts           = explode( \"\\0\", $original );\n\t\t\t$entry->singular = $parts[0];\n\t\t\tif ( isset( $parts[1] ) ) {\n\t\t\t\t$entry->is_plural = true;\n\t\t\t\t$entry->plural    = $parts[1];\n\t\t\t}\n\t\t\t\/\/ Plural translations are also separated by \\0.\n\t\t\t$entry->translations = explode( \"\\0\", $translation );\n\t\t\treturn $entry;\n\t\t}\n\n\t\t\/**\n\t\t * @param int $count\n\t\t * @return string\n\t\t *\/\n\t\tfunction select_plural_form( $count ) {\n\t\t\treturn $this->gettext_select_plural_form( $count );\n\t\t}\n\n\t\t\/**\n\t\t * @return int\n\t\t *\/\n\t\tfunction get_plural_forms_count() {\n\t\t\treturn $this->_nplurals;\n\t\t}\n\t}\nendif;\n"},{"base":"plugins","rel":"wordfence\/waf\/pomo\/streams.php","ext":"php","size":7496,"mtime":1757312769,"type":"text","content":"<?php\n\/**\n * This is a modified version of the POMO library included with WordPress. The WordPress copyright has been included\n * for attribution.\n *\/\n\n\/*\nWordPress - Web publishing software\n\nCopyright 2011-2020 by the contributors\n\nThis program is free software; you can redistribute it and\/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\nThis program incorporates work covered by the following copyright and\npermission notices:\n\n  b2 is (c) 2001, 2002 Michel Valdrighi - https:\/\/cafelog.com\n\n  Wherever third party code has been used, credit has been given in the code's\n  comments.\n\n  b2 is released under the GPL\n\nand\n\n  WordPress - Web publishing software\n\n  Copyright 2003-2010 by the contributors\n\n  WordPress is released under the GPL\n *\/\n\n\n\/**\n * Classes, which help reading streams of data from files.\n * Based on the classes from Danilo Segan <danilo@kvota.net>\n *\n * @version $Id: streams.php 1157 2015-11-20 04:30:11Z dd32 $\n * @package pomo\n * @subpackage streams\n *\/\n\nif ( ! class_exists( 'wfPOMO_Reader', false ) ) :\n\tclass wfPOMO_Reader {\n\n\t\tvar $endian = 'little';\n\t\tvar $_post  = '';\n\n\t\tprivate $is_overloaded;\n\t\tprotected $_pos;\n\n\t\t\/**\n\t\t * PHP5 constructor.\n\t\t *\/\n\t\tfunction __construct() {\n\t\t\t$this->is_overloaded = ( ( ini_get( 'mbstring.func_overload' ) & 2 ) != 0 ) && function_exists( 'mb_substr' ); \/\/ phpcs:ignore PHPCompatibility.IniDirectives.RemovedIniDirectives.mbstring_func_overloadDeprecated\n\t\t\t$this->_pos          = 0;\n\t\t}\n\n\t\t\/**\n\t\t * Sets the endianness of the file.\n\t\t *\n\t\t * @param string $endian Set the endianness of the file. Accepts 'big', or 'little'.\n\t\t *\/\n\t\tfunction setEndian( $endian ) { \/\/ phpcs:ignore WordPress.NamingConventions.ValidFunctionName.MethodNameInvalid\n\t\t\t$this->endian = $endian;\n\t\t}\n\n\t\t\/**\n\t\t * Reads a 32bit Integer from the Stream\n\t\t *\n\t\t * @return mixed The integer, corresponding to the next 32 bits from\n\t\t *  the stream of false if there are not enough bytes or on error\n\t\t *\/\n\t\tfunction readint32() {\n\t\t\t$bytes = $this->read( 4 );\n\t\t\tif ( 4 != $this->strlen( $bytes ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$endian_letter = ( 'big' === $this->endian ) ? 'N' : 'V';\n\t\t\t$int           = unpack( $endian_letter, $bytes );\n\t\t\treturn reset( $int );\n\t\t}\n\n\t\t\/**\n\t\t * Reads an array of 32-bit Integers from the Stream\n\t\t *\n\t\t * @param integer $count How many elements should be read\n\t\t * @return mixed Array of integers or false if there isn't\n\t\t *  enough data or on error\n\t\t *\/\n\t\tfunction readint32array( $count ) {\n\t\t\t$bytes = $this->read( 4 * $count );\n\t\t\tif ( 4 * $count != $this->strlen( $bytes ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$endian_letter = ( 'big' === $this->endian ) ? 'N' : 'V';\n\t\t\treturn unpack( $endian_letter . $count, $bytes );\n\t\t}\n\n\t\t\/**\n\t\t * @param string $string\n\t\t * @param int    $start\n\t\t * @param int    $length\n\t\t * @return string\n\t\t *\/\n\t\tfunction substr( $string, $start, $length ) {\n\t\t\tif ( $this->is_overloaded ) {\n\t\t\t\treturn mb_substr( $string, $start, $length, 'ascii' );\n\t\t\t} else {\n\t\t\t\treturn substr( $string, $start, $length );\n\t\t\t}\n\t\t}\n\n\t\t\/**\n\t\t * @param string $string\n\t\t * @return int\n\t\t *\/\n\t\tfunction strlen( $string ) {\n\t\t\tif ( $this->is_overloaded ) {\n\t\t\t\treturn mb_strlen( $string, 'ascii' );\n\t\t\t} else {\n\t\t\t\treturn strlen( $string );\n\t\t\t}\n\t\t}\n\n\t\t\/**\n\t\t * @param string $string\n\t\t * @param int    $chunk_size\n\t\t * @return array\n\t\t *\/\n\t\tfunction str_split( $string, $chunk_size ) {\n\t\t\tif ( ! function_exists( 'str_split' ) ) {\n\t\t\t\t$length = $this->strlen( $string );\n\t\t\t\t$out    = array();\n\t\t\t\tfor ( $i = 0; $i < $length; $i += $chunk_size ) {\n\t\t\t\t\t$out[] = $this->substr( $string, $i, $chunk_size );\n\t\t\t\t}\n\t\t\t\treturn $out;\n\t\t\t} else {\n\t\t\t\treturn str_split( $string, $chunk_size );\n\t\t\t}\n\t\t}\n\n\t\t\/**\n\t\t * @return int\n\t\t *\/\n\t\tfunction pos() {\n\t\t\treturn $this->_pos;\n\t\t}\n\n\t\t\/**\n\t\t * @return true\n\t\t *\/\n\t\tfunction is_resource() {\n\t\t\treturn true;\n\t\t}\n\n\t\t\/**\n\t\t * @return true\n\t\t *\/\n\t\tfunction close() {\n\t\t\treturn true;\n\t\t}\n\t}\nendif;\n\nif ( ! class_exists( 'wfPOMO_FileReader', false ) ) :\n\tclass wfPOMO_FileReader extends wfPOMO_Reader {\n\n\t\tprivate $_f;\n\n\t\t\/**\n\t\t * @param string $filename\n\t\t *\/\n\t\tfunction __construct( $filename ) {\n\t\t\tparent::__construct();\n\t\t\t$this->_f = fopen( $filename, 'rb' );\n\t\t}\n\n\t\t\/**\n\t\t * @param int $bytes\n\t\t * @return string|false Returns read string, otherwise false.\n\t\t *\/\n\t\tfunction read( $bytes ) {\n\t\t\treturn fread( $this->_f, $bytes );\n\t\t}\n\n\t\t\/**\n\t\t * @param int $pos\n\t\t * @return boolean\n\t\t *\/\n\t\tfunction seekto( $pos ) {\n\t\t\tif ( -1 == fseek( $this->_f, $pos, SEEK_SET ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$this->_pos = $pos;\n\t\t\treturn true;\n\t\t}\n\n\t\t\/**\n\t\t * @return bool\n\t\t *\/\n\t\tfunction is_resource() {\n\t\t\treturn is_resource( $this->_f );\n\t\t}\n\n\t\t\/**\n\t\t * @return bool\n\t\t *\/\n\t\tfunction feof() {\n\t\t\treturn feof( $this->_f );\n\t\t}\n\n\t\t\/**\n\t\t * @return bool\n\t\t *\/\n\t\tfunction close() {\n\t\t\treturn fclose( $this->_f );\n\t\t}\n\n\t\t\/**\n\t\t * @return string\n\t\t *\/\n\t\tfunction read_all() {\n\t\t\t$all = '';\n\t\t\twhile ( ! $this->feof() ) {\n\t\t\t\t$all .= $this->read( 4096 );\n\t\t\t}\n\t\t\treturn $all;\n\t\t}\n\t}\nendif;\n\nif ( ! class_exists( 'wfPOMO_StringReader', false ) ) :\n\t\/**\n\t * Provides file-like methods for manipulating a string instead\n\t * of a physical file.\n\t *\/\n\tclass wfPOMO_StringReader extends wfPOMO_Reader {\n\n\t\tvar $_str = '';\n\n\t\t\/**\n\t\t * PHP5 constructor.\n\t\t *\/\n\t\tfunction __construct( $str = '' ) {\n\t\t\tparent::__construct();\n\t\t\t$this->_str = $str;\n\t\t\t$this->_pos = 0;\n\t\t}\n\n\t\t\/**\n\t\t * @param string $bytes\n\t\t * @return string\n\t\t *\/\n\t\tfunction read( $bytes ) {\n\t\t\t$data        = $this->substr( $this->_str, $this->_pos, $bytes );\n\t\t\t$this->_pos += $bytes;\n\t\t\tif ( $this->strlen( $this->_str ) < $this->_pos ) {\n\t\t\t\t$this->_pos = $this->strlen( $this->_str );\n\t\t\t}\n\t\t\treturn $data;\n\t\t}\n\n\t\t\/**\n\t\t * @param int $pos\n\t\t * @return int\n\t\t *\/\n\t\tfunction seekto( $pos ) {\n\t\t\t$this->_pos = $pos;\n\t\t\tif ( $this->strlen( $this->_str ) < $this->_pos ) {\n\t\t\t\t$this->_pos = $this->strlen( $this->_str );\n\t\t\t}\n\t\t\treturn $this->_pos;\n\t\t}\n\n\t\t\/**\n\t\t * @return int\n\t\t *\/\n\t\tfunction length() {\n\t\t\treturn $this->strlen( $this->_str );\n\t\t}\n\n\t\t\/**\n\t\t * @return string\n\t\t *\/\n\t\tfunction read_all() {\n\t\t\treturn $this->substr( $this->_str, $this->_pos, $this->strlen( $this->_str ) );\n\t\t}\n\n\t}\nendif;\n\nif ( ! class_exists( 'wfPOMO_CachedFileReader', false ) ) :\n\t\/**\n\t * Reads the contents of the file in the beginning.\n\t *\/\n\tclass wfPOMO_CachedFileReader extends wfPOMO_StringReader {\n\t\t\/**\n\t\t * PHP5 constructor.\n\t\t *\/\n\t\tfunction __construct( $filename ) {\n\t\t\tparent::__construct();\n\t\t\t$this->_str = file_get_contents( $filename );\n\t\t\tif ( false === $this->_str ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$this->_pos = 0;\n\t\t}\n\t}\nendif;\n\nif ( ! class_exists( 'wfPOMO_CachedIntFileReader', false ) ) :\n\t\/**\n\t * Reads the contents of the file in the beginning.\n\t *\/\n\tclass wfPOMO_CachedIntFileReader extends wfPOMO_CachedFileReader {\n\t\t\/**\n\t\t * PHP5 constructor.\n\t\t *\/\n\t\tpublic function __construct( $filename ) {\n\t\t\tparent::__construct( $filename );\n\t\t}\n\t}\nendif;\n"},{"base":"plugins","rel":"wordfence\/models\/page\/wfPage.php","ext":"php","size":7216,"mtime":1757312769,"type":"text","content":"<?php\n\nclass wfPage {\n\tconst PAGE_DASHBOARD = 'dashboard';\n\tconst PAGE_DASHBOARD_OPTIONS = 'dashboard-options';\n\tconst PAGE_FIREWALL = 'firewall';\n\tconst PAGE_FIREWALL_OPTIONS = 'firewall-options';\n\tconst PAGE_BLOCKING = 'blocking';\n\tconst PAGE_BLOCKING_OPTIONS = 'blocking-options';\n\tconst PAGE_SCAN = 'scan';\n\tconst PAGE_SCAN_OPTIONS = 'scan-options';\n\tconst PAGE_TOOLS_2FA = 'tools-2fa';\n\tconst PAGE_TOOLS_LIVE_TRAFFIC = 'tools-2fa';\n\tconst PAGE_TOOLS_WHOIS = 'tools-whois';\n\tconst PAGE_TOOLS_IMPORT_EXPORT = 'tools-import-export';\n\tconst PAGE_TOOLS_DIAGNOSTICS = 'tools-diagnostics';\n\tconst PAGE_SUPPORT = 'support';\n\t\n\t\/** @var string *\/\n\tprivate $_identifier;\n\t\n\t\/**\n\t * Provides validation for a user-provided page identifier.\n\t * \n\t * @param string $identifier\n\t * @return bool\n\t *\/\n\tpublic static function isValidPage($identifier) {\n\t\tswitch ($identifier) {\n\t\t\tcase self::PAGE_DASHBOARD:\n\t\t\tcase self::PAGE_DASHBOARD_OPTIONS:\n\t\t\tcase self::PAGE_FIREWALL:\n\t\t\tcase self::PAGE_FIREWALL_OPTIONS:\n\t\t\tcase self::PAGE_BLOCKING:\n\t\t\tcase self::PAGE_BLOCKING_OPTIONS:\n\t\t\tcase self::PAGE_SCAN:\n\t\t\tcase self::PAGE_SCAN_OPTIONS:\n\t\t\tcase self::PAGE_TOOLS_2FA:\n\t\t\tcase self::PAGE_TOOLS_LIVE_TRAFFIC:\n\t\t\tcase self::PAGE_TOOLS_IMPORT_EXPORT:\n\t\t\tcase self::PAGE_TOOLS_WHOIS:\n\t\t\tcase self::PAGE_TOOLS_DIAGNOSTICS:\n\t\t\tcase self::PAGE_SUPPORT:\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\/**\n\t * Convenience function for returning the user-displayable label for the given page.\n\t * \n\t * @param string $identifier\n\t * @return bool|string\n\t *\/\n\tpublic static function pageLabel($identifier) {\n\t\t$page = new wfPage($identifier);\n\t\treturn $page->label();\n\t}\n\t\n\t\/**\n\t * Convenience function for returning the canonical URL for the given page.\n\t * \n\t * @param string $identifier\n\t * @param string|bool $source The source page identifier to append to the URL if wanted.\n\t * @return string\n\t *\/\n\tpublic static function pageURL($identifier, $source = false) {\n\t\t$page = new wfPage($identifier);\n\t\treturn $page->url($source);\n\t}\n\t\n\tpublic function __construct($identifier) {\n\t\t$this->_identifier = $identifier;\n\t}\n\t\n\tpublic function __get($key) {\n\t\tswitch ($key) {\n\t\t\tcase 'identifier':\n\t\t\t\treturn $this->_identifier;\n\t\t}\n\t\t\n\t\tthrow new OutOfBoundsException(\"{$key} is not a valid property\");\n\t}\n\t\n\tpublic function __isset($key) {\n\t\tswitch ($key) {\n\t\t\tcase 'identifier':\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\/**\n\t * Returns the user-displayable label for the page.\n\t * \n\t * @return bool|string\n\t *\/\n\tpublic function label() {\n\t\tswitch ($this->identifier) {\n\t\t\tcase self::PAGE_DASHBOARD:\n\t\t\t\treturn __('Dashboard', 'wordfence');\n\t\t\tcase self::PAGE_DASHBOARD_OPTIONS:\n\t\t\t\treturn __('Global Options', 'wordfence');\n\t\t\tcase self::PAGE_FIREWALL:\n\t\t\t\treturn __('Firewall', 'wordfence');\n\t\t\tcase self::PAGE_FIREWALL_OPTIONS:\n\t\t\t\treturn __('Firewall Options', 'wordfence');\n\t\t\tcase self::PAGE_BLOCKING:\n\t\t\t\treturn __('Blocking', 'wordfence');\n\t\t\tcase self::PAGE_BLOCKING_OPTIONS:\n\t\t\t\treturn __('Blocking Options', 'wordfence');\n\t\t\tcase self::PAGE_SCAN:\n\t\t\t\treturn __('Scan', 'wordfence');\n\t\t\tcase self::PAGE_SCAN_OPTIONS:\n\t\t\t\treturn __('Scan Options', 'wordfence');\n\t\t\tcase self::PAGE_TOOLS_2FA:\n\t\t\t\treturn __('Two-Factor Authentication', 'wordfence');\n\t\t\tcase self::PAGE_TOOLS_LIVE_TRAFFIC:\n\t\t\t\treturn __('Live Traffic', 'wordfence');\n\t\t\tcase self::PAGE_TOOLS_IMPORT_EXPORT:\n\t\t\t\treturn __('Import\/Export Options', 'wordfence');\n\t\t\tcase self::PAGE_TOOLS_WHOIS:\n\t\t\t\treturn __('Whois Lookup', 'wordfence');\n\t\t\tcase self::PAGE_TOOLS_DIAGNOSTICS:\n\t\t\t\treturn __('Diagnostics', 'wordfence');\n\t\t\tcase self::PAGE_SUPPORT:\n\t\t\t\treturn __('Support', 'wordfence');\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t\/**\n\t * Returns the canonical URL for the page.\n\t * \n\t * @param string|bool $source The source page identifier to append to the URL if wanted.\n\t * @return string\n\t *\/\n\tpublic function url($source = false) {\n\t\t$page = '';\n\t\t$subpage = '';\n\t\t$hash = '';\n\t\tswitch ($this->identifier) {\n\t\t\tcase self::PAGE_DASHBOARD:\n\t\t\t\t$page = 'Wordfence';\n\t\t\t\tbreak;\n\t\t\tcase self::PAGE_DASHBOARD_OPTIONS:\n\t\t\t\t$page = 'Wordfence';\n\t\t\t\t$subpage = 'global_options';\n\t\t\t\tbreak;\n\t\t\tcase self::PAGE_FIREWALL:\n\t\t\t\t$page = 'WordfenceWAF';\n\t\t\t\tbreak;\n\t\t\tcase self::PAGE_FIREWALL_OPTIONS:\n\t\t\t\t$page = 'WordfenceWAF';\n\t\t\t\t$subpage = 'waf_options';\n\t\t\t\tbreak;\n\t\t\tcase self::PAGE_BLOCKING:\n\t\t\t\t$page = 'WordfenceWAF';\n\t\t\t\t$hash = '#top#blocking';\n\t\t\t\tbreak;\n\t\t\tcase self::PAGE_BLOCKING_OPTIONS:\n\t\t\t\t$page = 'WordfenceWAF';\n\t\t\t\t$subpage = 'blocking_options';\n\t\t\t\tbreak;\n\t\t\tcase self::PAGE_SCAN:\n\t\t\t\t$page = 'WordfenceScan';\n\t\t\t\tbreak;\n\t\t\tcase self::PAGE_SCAN_OPTIONS:\n\t\t\t\t$page = 'WordfenceScan';\n\t\t\t\t$subpage = 'scan_options';\n\t\t\t\tbreak;\n\t\t\tcase self::PAGE_TOOLS_2FA:\n\t\t\t\t$page = 'WordfenceTools';\n\t\t\t\t$subpage = 'twofactor';\n\t\t\t\tbreak;\n\t\t\tcase self::PAGE_TOOLS_LIVE_TRAFFIC:\n\t\t\t\t$page = 'WordfenceTools';\n\t\t\t\t$subpage = 'livetraffic';\n\t\t\t\tbreak;\n\t\t\tcase self::PAGE_TOOLS_IMPORT_EXPORT:\n\t\t\t\t$page = 'WordfenceTools';\n\t\t\t\t$subpage = 'importexport';\n\t\t\t\tbreak;\n\t\t\tcase self::PAGE_TOOLS_WHOIS:\n\t\t\t\t$page = 'WordfenceTools';\n\t\t\t\t$subpage = 'whois';\n\t\t\t\tbreak;\n\t\t\tcase self::PAGE_TOOLS_DIAGNOSTICS:\n\t\t\t\t$page = 'WordfenceTools';\n\t\t\t\t$subpage = 'diagnostics';\n\t\t\t\tbreak;\n\t\t\tcase self::PAGE_SUPPORT:\n\t\t\t\t$page = 'WordfenceSupport';\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\t$baseURL = 'admin.php?';\n\t\t$baseURL .= 'page=' . rawurlencode($page);\n\t\tif (!empty($subpage)) { $baseURL .= '&subpage=' . rawurlencode($subpage); }\n\t\tif (self::isValidPage($source))  { $baseURL .= '&source=' . rawurlencode($source); }\n\t\tif (!empty($hash)) { $baseURL .= $this->_hashURLEncode($hash); }\n\t\tif (function_exists('network_admin_url') && is_multisite()) {\n\t\t\treturn network_admin_url($baseURL);\n\t\t}\n\t\t\n\t\t return admin_url($baseURL);\n\t}\n\t\n\t\/**\n\t * Splits a URI hash component and URL-encodes its members.\n\t * \n\t * @param string $hash\n\t * @return string\n\t *\/\n\tprivate function _hashURLEncode($hash) {\n\t\t$components = explode('#', $hash);\n\t\tforeach ($components as &$c) {\n\t\t\t$c = rawurlencode($c);\n\t\t}\n\t\treturn implode('#', $components);\n\t}\n\t\n\t\/**\n\t * Returns an ordered array of the pages required to reach this page, this page being the last entry in the array.\n\t * \n\t * @return array\n\t *\/\n\tpublic function breadcrumbs() {\n\t\tswitch ($this->identifier) {\n\t\t\tcase self::PAGE_DASHBOARD:\n\t\t\t\treturn array($this);\n\t\t\tcase self::PAGE_DASHBOARD_OPTIONS:\n\t\t\t\treturn array(new wfPage(wfPage::PAGE_DASHBOARD), $this);\n\t\t\tcase self::PAGE_FIREWALL:\n\t\t\t\treturn array($this);\n\t\t\tcase self::PAGE_FIREWALL_OPTIONS:\n\t\t\t\treturn array(new wfPage(wfPage::PAGE_FIREWALL), $this);\n\t\t\tcase self::PAGE_BLOCKING:\n\t\t\t\treturn array($this);\n\t\t\tcase self::PAGE_BLOCKING_OPTIONS:\n\t\t\t\treturn array(new wfPage(wfPage::PAGE_BLOCKING), $this);\n\t\t\tcase self::PAGE_SCAN:\n\t\t\t\treturn array($this);\n\t\t\tcase self::PAGE_SCAN_OPTIONS:\n\t\t\t\treturn array(new wfPage(wfPage::PAGE_SCAN), $this);\n\t\t\tcase self::PAGE_TOOLS_2FA:\n\t\t\t\treturn array($this);\n\t\t\tcase self::PAGE_TOOLS_LIVE_TRAFFIC:\n\t\t\t\treturn array($this);\n\t\t\tcase self::PAGE_TOOLS_IMPORT_EXPORT:\n\t\t\t\treturn array($this);\n\t\t\tcase self::PAGE_TOOLS_WHOIS:\n\t\t\t\treturn array($this);\n\t\t\tcase self::PAGE_TOOLS_DIAGNOSTICS:\n\t\t\t\treturn array($this);\n\t\t\tcase self::PAGE_SUPPORT:\n\t\t\t\treturn array($this);\n\t\t}\n\t\t\n\t\treturn array();\n\t}\n}\n"},{"base":"plugins","rel":"wordfence\/models\/common\/wfTab.php","ext":"php","size":845,"mtime":1757312769,"type":"text","content":"<?php\n\n\/**\n * Defines a UI tab.\n *\n * @property string $id\n * @property string $a\n * @property string $tabTitle\n * @property string $pageTitle\n * @property bool $active\n *\/\nclass wfTab {\n\tprotected $_id;\n\tprotected $_a;\n\tprotected $_tabTitle;\n\tprotected $_pageTitle;\n\tprotected $_active;\n\t\n\tpublic function __construct($id, $a, $tabTitle, $pageTitle, $active = false) {\n\t\t$this->_id = $id;\n\t\t$this->_a = $a;\n\t\t$this->_tabTitle = $tabTitle;\n\t\t$this->_pageTitle = $pageTitle;\n\t\t$this->_active = $active;\n\t}\n\t\n\tpublic function __get($name) {\n\t\tswitch ($name) {\n\t\t\tcase 'id':\n\t\t\t\treturn $this->_id;\n\t\t\tcase 'a':\n\t\t\t\treturn $this->_a;\n\t\t\tcase 'tabTitle':\n\t\t\t\treturn $this->_tabTitle;\n\t\t\tcase 'pageTitle':\n\t\t\t\treturn $this->_pageTitle;\n\t\t\tcase 'active':\n\t\t\t\treturn $this->_active;\n\t\t}\n\t\t\n\t\tthrow new OutOfBoundsException('Invalid key: ' . $name);\n\t}\n}"},{"base":"plugins","rel":"wordfence\/models\/block\/wfRateLimit.php","ext":"php","size":7898,"mtime":1757312769,"type":"text","content":"<?php\n\nclass wfRateLimit {\n\tconst TYPE_GLOBAL = 'global';\n\tconst TYPE_CRAWLER_VIEWS = 'crawler-views';\n\tconst TYPE_CRAWLER_404S = 'crawler-404s';\n\tconst TYPE_HUMAN_VIEWS = 'human-views';\n\tconst TYPE_HUMAN_404S = 'human-404s';\n\t\n\tconst HIT_TYPE_404 = '404';\n\tconst HIT_TYPE_NORMAL = 'hit';\n\t\n\tconst VISITOR_TYPE_HUMAN = 'human';\n\tconst VISITOR_TYPE_CRAWLER = 'crawler';\n\t\n\tprotected $_type;\n\tprotected static $_hitCount = false;\n\t\n\tpublic static function table() {\n\t\treturn wfDB::networkTable('wfTrafficRates');\n\t}\n\t\n\tpublic static function trimData() {\n\t\t$wfdb = wfDB::shared();\n\t\t$table = self::table();\n\t\t$wfdb->queryWrite(\"DELETE FROM {$table} WHERE eMin < FLOOR((UNIX_TIMESTAMP() - 60) \/ 60)\");\n\t}\n\t\n\tpublic static function globalRateLimit() {\n\t\tstatic $_cachedGlobal = null;\n\t\tif ($_cachedGlobal === null) {\n\t\t\t$_cachedGlobal = new wfRateLimit(self::TYPE_GLOBAL);\n\t\t}\n\t\treturn $_cachedGlobal;\n\t}\n\t\n\tpublic static function crawlerViewsRateLimit() {\n\t\tstatic $_cachedCrawlerViews = null;\n\t\tif ($_cachedCrawlerViews === null) {\n\t\t\t$_cachedCrawlerViews = new wfRateLimit(self::TYPE_CRAWLER_VIEWS);\n\t\t}\n\t\treturn $_cachedCrawlerViews;\n\t}\n\t\n\tpublic static function crawler404sRateLimit() {\n\t\tstatic $_cachedCrawler404s = null;\n\t\tif ($_cachedCrawler404s === null) {\n\t\t\t$_cachedCrawler404s = new wfRateLimit(self::TYPE_CRAWLER_404S);\n\t\t}\n\t\treturn $_cachedCrawler404s;\n\t}\n\t\n\tpublic static function humanViewsRateLimit() {\n\t\tstatic $_cachedHumanViews = null;\n\t\tif ($_cachedHumanViews === null) {\n\t\t\t$_cachedHumanViews = new wfRateLimit(self::TYPE_HUMAN_VIEWS);\n\t\t}\n\t\treturn $_cachedHumanViews;\n\t}\n\t\n\tpublic static function human404sRateLimit() {\n\t\tstatic $_cachedHuman404s = null;\n\t\tif ($_cachedHuman404s === null) {\n\t\t\t$_cachedHuman404s = new wfRateLimit(self::TYPE_HUMAN_404S);\n\t\t}\n\t\treturn $_cachedHuman404s;\n\t}\n\t\n\t\/**\n\t * Returns whether or not humans and bots have the same rate limits configured.\n\t *\n\t * @return bool\n\t *\/\n\tpublic static function identicalHumanBotRateLimits() {\n\t\t$humanViews = self::humanViewsRateLimit();\n\t\t$crawlerViews = self::crawlerViewsRateLimit();\n\t\tif ($humanViews->isEnabled() != $crawlerViews->isEnabled()) {\n\t\t\treturn false;\n\t\t}\n\t\tif ($humanViews->limit() != $crawlerViews->limit()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t$human404s = self::human404sRateLimit();\n\t\t$crawler404s = self::crawler404sRateLimit();\n\t\tif ($human404s->isEnabled() != $crawler404s->isEnabled()) {\n\t\t\treturn false;\n\t\t}\n\t\tif ($human404s->limit() != $crawler404s->limit()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static function mightRateLimit($hitType) {\n\t\tif (!wfConfig::get('firewallEnabled')) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t$IP = wfUtils::getIP();\n\t\tif (wfBlock::isWhitelisted($IP)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (wfConfig::get('neverBlockBG') == 'neverBlockUA' && wfCrawl::isGoogleCrawler()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (wfConfig::get('neverBlockBG') == 'neverBlockVerified' && wfCrawl::isVerifiedGoogleCrawler()) {\n\t\t\treturn false;\n\t\t}\n\t\t\t\n\t\tif ($hitType == '404') {\n\t\t\t$allowed404s = wfConfig::get('allowed404s');\n\t\t\tif (is_string($allowed404s)) {\n\t\t\t\t$allowed404s = array_filter(preg_split(\"\/[\\r\\n]+\/\", $allowed404s));\n\t\t\t\t$allowed404sPattern = '';\n\t\t\t\tforeach ($allowed404s as $allowed404) {\n\t\t\t\t\t$allowed404sPattern .= preg_replace('\/\\\\\\\\\\*\/', '.*?', preg_quote($allowed404, '\/')) . '|';\n\t\t\t\t}\n\t\t\t\t$uri = $_SERVER['REQUEST_URI'];\n\t\t\t\tif (($index = strpos($uri, '?')) !== false) {\n\t\t\t\t\t$uri = substr($uri, 0, $index);\n\t\t\t\t}\n\t\t\t\tif ($allowed404sPattern && preg_match('\/^' . substr($allowed404sPattern, 0, -1) . '$\/i', $uri)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (self::globalRateLimit()->isEnabled()) {\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\t$visitorType = self::visitorType();\n\t\t\n\t\tif ($visitorType == self::VISITOR_TYPE_CRAWLER) {\n\t\t\tif ($hitType == self::HIT_TYPE_NORMAL) {\n\t\t\t\tif (self::crawlerViewsRateLimit()->isEnabled()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (self::crawler404sRateLimit()->isEnabled()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ($hitType == self::HIT_TYPE_NORMAL) {\n\t\t\t\tif (self::humanViewsRateLimit()->isEnabled()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (self::human404sRateLimit()->isEnabled()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic static function countHit($hitType, $ip) {\n\t\t$table  = self::table();\n\t\t$ipHex = wfDB::binaryValueToSQLHex(wfUtils::inet_pton($ip));\n\t\twfDB::shared()->queryWrite(\"INSERT INTO {$table} (eMin, IP, hitType, hits) VALUES (FLOOR(UNIX_TIMESTAMP() \/ 60), {$ipHex}, %s, @wfcurrenthits := 1) ON DUPLICATE KEY UPDATE hits = IF(@wfcurrenthits := hits + 1, hits + 1, hits + 1)\", $hitType);\n\t}\n\t\n\t\/**\n\t * Returns one of the VISITOR_TYPE_ constants for the purposes of determining which rate limit to apply.\n\t * \n\t * @return string\n\t *\/\n\tpublic static function visitorType() {\n\t\tstatic $_cachedVisitorType = null;\n\t\tif ($_cachedVisitorType === null) {\n\t\t\t$_cachedVisitorType = ((isset($_SERVER['HTTP_USER_AGENT']) && wfCrawl::isCrawler($_SERVER['HTTP_USER_AGENT'])) || empty($_SERVER['HTTP_USER_AGENT']) ? wfRateLimit::VISITOR_TYPE_CRAWLER : wfRateLimit::VISITOR_TYPE_HUMAN);\t\n\t\t}\n\t\treturn $_cachedVisitorType;\n\t}\n\t\n\tprotected function __construct($type) {\n\t\t$this->_type = $type;\n\t}\n\t\n\t\/**\n\t * Returns whether or not this rate limit is configured in a way where it would run.\n\t * \n\t * @return bool\n\t *\/\n\tpublic function isEnabled() {\n\t\tswitch ($this->_type) {\n\t\t\tcase self::TYPE_GLOBAL:\n\t\t\t\treturn wfConfig::get('maxGlobalRequests') != 'DISABLED' && wfConfig::getInt('maxGlobalRequests') > 0;\n\t\t\tcase self::TYPE_CRAWLER_VIEWS:\n\t\t\t\treturn wfConfig::get('maxRequestsCrawlers') != 'DISABLED' && wfConfig::getInt('maxRequestsCrawlers') > 0;\n\t\t\tcase self::TYPE_CRAWLER_404S:\n\t\t\t\treturn wfConfig::get('max404Crawlers') != 'DISABLED' && wfConfig::getInt('max404Crawlers') > 0;\n\t\t\tcase self::TYPE_HUMAN_VIEWS:\n\t\t\t\treturn wfConfig::get('maxRequestsHumans') != 'DISABLED' && wfConfig::getInt('maxRequestsHumans') > 0;\n\t\t\tcase self::TYPE_HUMAN_404S:\n\t\t\t\treturn wfConfig::get('max404Humans') != 'DISABLED' && wfConfig::getInt('max404Humans') > 0;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic function limit() {\n\t\tswitch ($this->_type) {\n\t\t\tcase self::TYPE_GLOBAL:\n\t\t\t\treturn wfConfig::getInt('maxGlobalRequests');\n\t\t\tcase self::TYPE_CRAWLER_VIEWS:\n\t\t\t\treturn wfConfig::getInt('maxRequestsCrawlers');\n\t\t\tcase self::TYPE_CRAWLER_404S:\n\t\t\t\treturn wfConfig::getInt('max404Crawlers');\n\t\t\tcase self::TYPE_HUMAN_VIEWS:\n\t\t\t\treturn wfConfig::getInt('maxRequestsHumans');\n\t\t\tcase self::TYPE_HUMAN_404S:\n\t\t\t\treturn wfConfig::getInt('max404Humans');\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tpublic function shouldEnforce($hitType) {\n\t\tswitch ($this->_type) {\n\t\t\tcase self::TYPE_GLOBAL:\n\t\t\t\treturn $this->isEnabled() && $this->_hitCount() > max(wfConfig::getInt('maxGlobalRequests'), 1);\n\t\t\tcase self::TYPE_CRAWLER_VIEWS:\n\t\t\t\treturn self::visitorType() == self::VISITOR_TYPE_CRAWLER && $hitType == self::HIT_TYPE_NORMAL && $this->isEnabled() && $this->_hitCount() > wfConfig::getInt('maxRequestsCrawlers');\n\t\t\tcase self::TYPE_CRAWLER_404S:\n\t\t\t\treturn self::visitorType() == self::VISITOR_TYPE_CRAWLER && $hitType == self::HIT_TYPE_404 && $this->isEnabled() && $this->_hitCount() > wfConfig::getInt('max404Crawlers');\n\t\t\tcase self::TYPE_HUMAN_VIEWS:\n\t\t\t\treturn self::visitorType() == self::VISITOR_TYPE_HUMAN && $hitType == self::HIT_TYPE_NORMAL && $this->isEnabled() && $this->_hitCount() > wfConfig::getInt('maxRequestsHumans');\n\t\t\tcase self::TYPE_HUMAN_404S:\n\t\t\t\treturn self::visitorType() == self::VISITOR_TYPE_HUMAN && $hitType == self::HIT_TYPE_404 && $this->isEnabled() && $this->_hitCount() > wfConfig::getInt('max404Humans');\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\/**\n\t * Returns the hit count corresponding to the current request type.\n\t * \n\t * @return int\n\t *\/\n\tprotected function _hitCount() {\n\t\tif (self::$_hitCount === false) {\n\t\t\tself::$_hitCount = (int) wfDB::shared()->querySingle(\"SELECT @wfcurrenthits\");\n\t\t}\n\t\treturn self::$_hitCount;\n\t}\n}"},{"base":"plugins","rel":"wordfence\/models\/block\/wfBlock.php","ext":"php","size":65933,"mtime":1757312769,"type":"text","content":"<?php\n\n\/**\n * Represents an individual block definition.\n * \n * @property int $id\n * @property int $type One of the TYPE_* constants.\n * @property string $ip The human-readable version of the IP if applicable for the block type.\n * @property int $blockedTime The timestamp the block was created.\n * @property string $reason Description of the block.\n * @property int $lastAttempt Timestamp of the last request blocked. If never, this will be 0.\n * @property int $blockedHits Count of the number of hits blocked.\n * @property int $expiration Timestamp when the block will expire. If never, this will be 0.\n * @property mixed $parameters Variable parameters defining the block (e.g., the matchers for a pattern block).\n * \n * @property bool $blockLogin For wfBlock::TYPE_COUNTRY only, this is whether or not to block hits to the login page.\n * @property bool $blockSite For wfBlock::TYPE_COUNTRY only, this is whether or not to block hits to the rest of the site.\n * @property array $countries For wfBlock::TYPE_COUNTRY only, this is the list of countries to block.\n * \n * @property mixed $ipRange For wfBlock::TYPE_PATTERN only, this is the matching IP range if set.\n * @property mixed $hostname For wfBlock::TYPE_PATTERN only, this is the hostname pattern if set.\n * @property mixed $userAgent For wfBlock::TYPE_PATTERN only, this is the user agent pattern if set.\n * @property mixed $referrer For wfBlock::TYPE_PATTERN only, this is the HTTP referrer pattern if set.\n *\/\nclass wfBlock {\n\t\/\/Constants for block record types\n\tconst TYPE_IP_MANUAL = 1; \/\/Same behavior as TYPE_IP_AUTOMATIC_PERMANENT - the reason will be overridden for public display\n\tconst TYPE_WFSN_TEMPORARY = 2;\n\tconst TYPE_COUNTRY = 3;\n\tconst TYPE_PATTERN = 4;\n\tconst TYPE_RATE_BLOCK = 5;\n\tconst TYPE_RATE_THROTTLE = 6;\n\tconst TYPE_LOCKOUT = 7; \/\/Blocks login-related actions only\n\tconst TYPE_IP_AUTOMATIC_TEMPORARY = 8; \/\/Automatic block, still temporary\n\tconst TYPE_IP_AUTOMATIC_PERMANENT = 9; \/\/Automatic block, started as temporary but now permanent as a result of admin action\n\t\n\t\/\/Constants to identify the match type of a block record\n\tconst MATCH_NONE = 0;\n\tconst MATCH_IP = 1;\n\tconst MATCH_COUNTRY_BLOCK = 2;\n\tconst MATCH_COUNTRY_REDIR = 3;\n\tconst MATCH_COUNTRY_REDIR_BYPASS = 4;\n\tconst MATCH_PATTERN = 5;\n\t\n\t\/\/Duration constants\n\tconst DURATION_FOREVER = 0;\n\t\n\t\/\/Constants defining the placeholder IPs for non-IP block records\n\tconst MARKER_COUNTRY = \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xff\\xc0\\x00\\x02\\x01\";\/\/ 192.0.2.1 TEST-NET-1\n\tconst MARKER_PATTERN = \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xff\\xc0\\x00\\x02\\x02\";\/\/ 192.0.2.2 TEST-NET-1\n\t\n\tprivate $_id;\n\tprivate $_type = false;\n\tprivate $_ip = false;\n\tprivate $_blockedTime = false;\n\tprivate $_reason = false;\n\tprivate $_lastAttempt = false;\n\tprivate $_blockedHits = false;\n\tprivate $_expiration = false;\n\tprivate $_parameters = false;\n\t\n\t\/**\n\t * Returns the name of the storage table for the blocks.\n\t * \n\t * @return string\n\t *\/\n\tpublic static function blocksTable() {\n\t\treturn wfDB::networkTable('wfBlocks7');\n\t}\n\t\n\t\/**\n\t * Returns a user-displayable name for the corresponding type constant.\n\t * \n\t * @param int $type\n\t * @return string\n\t *\/\n\tpublic static function nameForType($type) {\n\t\tswitch ($type) {\n\t\t\tcase self::TYPE_IP_MANUAL:\n\t\t\tcase self::TYPE_IP_AUTOMATIC_TEMPORARY:\n\t\t\tcase self::TYPE_IP_AUTOMATIC_PERMANENT:\n\t\t\tcase self::TYPE_WFSN_TEMPORARY:\n\t\t\tcase self::TYPE_RATE_BLOCK:\n\t\t\t\treturn __('IP Block', 'wordfence');\n\t\t\tcase self::TYPE_RATE_THROTTLE:\n\t\t\t\treturn __('IP Throttled', 'wordfence');\n\t\t\tcase self::TYPE_LOCKOUT:\n\t\t\t\treturn __('Lockout', 'wordfence');\n\t\t\tcase self::TYPE_COUNTRY:\n\t\t\t\treturn __('Country Block', 'wordfence');\n\t\t\tcase self::TYPE_PATTERN:\n\t\t\t\treturn __('Advanced Block', 'wordfence');\n\t\t}\n\t\t\n\t\treturn __('Unknown', 'wordfence');\n\t}\n\t\n\t\/**\n\t * Returns the number of seconds for a temporary block to last by default.\n\t * \n\t * @return int\n\t *\/\n\tpublic static function blockDuration() {\n\t\treturn (int) wfConfig::get('blockedTime');\n\t}\n\t\n\t\/**\n\t * Returns the number of seconds for a rate limit throttle to last by default.\n\t *\n\t * @return int\n\t *\/\n\tpublic static function rateLimitThrottleDuration() {\n\t\treturn 60;\n\t}\n\t\n\t\/**\n\t * Returns the number of seconds for a lockout to last by default.\n\t *\n\t * @return int\n\t *\/\n\tpublic static function lockoutDuration() {\n\t\treturn (int) wfConfig::get('loginSec_lockoutMins') * 60;\n\t}\n\t\n\t\/**\n\t * @param string $IP Should be in dot or colon notation (127.0.0.1 or ::1)\n\t * @param bool $forcedWhitelistEntry If provided, returns whether or not the IP is on a forced whitelist (i.e., it's not one the user can delete).\n\t * @return bool\n\t *\/\n\tpublic static function isWhitelisted($IP, &$forcedWhitelistEntry = null) {\n\t\tif ($forcedWhitelistEntry !== null) {\n\t\t\t$forcedWhitelistEntry = false;\n\t\t}\n\t\t\n\t\tif (\n\t\t\t(defined('DOING_CRON') && DOING_CRON) || \/\/Safe\n\t\t\t(defined('WORDFENCE_SYNCING_ATTACK_DATA') && WORDFENCE_SYNCING_ATTACK_DATA) \/\/Safe as long as it will actually run since it then exits\n\t\t) {\n\t\t\t$serverIPs = wfUtils::serverIPs();\n\t\t\tforeach ($serverIPs as $testIP) {\n\t\t\t\tif (wfUtils::inet_pton($IP) == wfUtils::inet_pton($testIP)) {\n\t\t\t\t\tif ($forcedWhitelistEntry !== null) {\n\t\t\t\t\t\t$forcedWhitelistEntry = true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tforeach (wfUtils::getIPWhitelist() as $subnet) {\n\t\t\tif ($subnet instanceof wfUserIPRange) {\n\t\t\t\tif ($subnet->isIPInRange($IP)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} elseif (wfUtils::subnetContainsIP($subnet, $IP)) {\n\t\t\t\tif ($forcedWhitelistEntry !== null) {\n\t\t\t\t\t$forcedWhitelistEntry = true;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t\/**\n\t * Validates the payload for block creation. Returns true if valid, otherwise it'll return the first error found.\n\t * \n\t * @param $payload\n\t * @return bool|string\n\t *\/\n\tpublic static function validate($payload) {\n\t\tif (!isset($payload['type']) || array_search($payload['type'], array('ip-address', 'country', 'custom-pattern')) === false) { return __('Invalid block type.', 'wordfence'); }\n\t\tif (!isset($payload['duration']) || intval($payload['duration']) < 0) { return __('Invalid block duration.', 'wordfence'); }\n\t\tif (!isset($payload['reason']) || empty($payload['reason'])) { return __('A block reason must be provided.', 'wordfence'); }\n\t\t\n\t\tif ($payload['type'] == 'ip-address') {\n\t\t\tif (!isset($payload['ip']) || !filter_var(trim($payload['ip']), FILTER_VALIDATE_IP) || wfUtils::inet_pton(trim($payload['ip'])) === false) { return __('Invalid IP address.', 'wordfence'); }\n\t\t\tif (self::isWhitelisted(trim($payload['ip']))) { return wp_kses(sprintf(\/* translators: Support URL *\/ __('This IP address is in a range of addresses that Wordfence does not block. The IP range may be internal or belong to a service that is always allowed. Allowlisting of external services can be disabled. <a href=\"%s\" target=\"_blank\" rel=\"noopener noreferrer\">Learn More<span class=\"screen-reader-text\"> (opens in new tab)<\/span><\/a>', 'wordfence'), wfSupportController::supportURL(wfSupportController::ITEM_FIREWALL_WAF_OPTION_WHITELISTED_SERVICES)), array('a'=>array('href'=>array(), 'target'=>array(), 'rel'=>array()), 'span'=>array('class'=>array()))); }\n\t\t}\n\t\telse if ($payload['type'] == 'country') {\n\t\t\tif (!isset($payload['blockLogin']) || !isset($payload['blockSite'])) { return __('Nothing selected to block.', 'wordfence'); }\n\t\t\tif (!$payload['blockLogin'] && !$payload['blockSite']) { return __('Nothing selected to block.', 'wordfence'); }\n\t\t\tif (!isset($payload['countries']) || empty($payload['countries']) || !is_array($payload['countries'])) { return __('No countries selected.', 'wordfence'); }\n\t\t\t\n\t\t\trequire(WORDFENCE_PATH . 'lib\/wfBulkCountries.php'); \/** @var array $wfBulkCountries *\/\n\t\t\tforeach ($payload['countries'] as $code) {\n\t\t\t\tif (!isset($wfBulkCountries[$code])) {\n\t\t\t\t\treturn __('An invalid country was selected.', 'wordfence');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ($payload['type'] == 'custom-pattern') {\n\t\t\t$hasOne = false;\n\t\t\tif (isset($payload['ipRange']) && !empty($payload['ipRange'])) {\n\t\t\t\t$ipRange = new wfUserIPRange($payload['ipRange']);\n\t\t\t\tif ($ipRange->isValidRange()) {\n\t\t\t\t\tif ($ipRange->isMixedRange()) {\n\t\t\t\t\t\treturn __('Ranges mixing IPv4 and IPv6 addresses are not supported.', 'wordfence');\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$hasOne = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn __('Invalid IP range.', 'wordfence');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isset($payload['hostname']) && !empty($payload['hostname'])) {\n\t\t\t\tif (preg_match('\/^[a-z0-9\\.\\*\\-]+$\/i', $payload['hostname'])) {\n\t\t\t\t\t$hasOne = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn __('Invalid hostname.', 'wordfence');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isset($payload['userAgent']) && !empty($payload['userAgent'])) { $hasOne = true; }\n\t\t\tif (isset($payload['referrer']) && !empty($payload['referrer'])) { $hasOne = true; }\n\t\t\tif (!$hasOne) { return __('No block parameters provided.', 'wordfence'); }\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\t\/**\n\t * Creates the block. The $payload value is expected to have been validated prior to calling this.\n\t * \n\t * @param $payload\n\t *\/\n\tpublic static function create($payload) {\n\t\t$type = $payload['type'];\n\t\t$duration = max((int) $payload['duration'], 0);\n\t\t$reason = $payload['reason'];\n\t\t\n\t\tif ($type == 'ip-address') {\n\t\t\t$ip = trim($payload['ip']);\n\t\t\twfBlock::createIP($reason, $ip, $duration);\n\t\t}\n\t\telse if ($type == 'country') {\n\t\t\t$blockLogin = !!$payload['blockLogin'];\n\t\t\t$blockSite = !!$payload['blockSite'];\n\t\t\t$countries = array_unique($payload['countries']);\n\t\t\twfBlock::createCountry($reason, $blockLogin, $blockSite, $countries, $duration);\n\t\t}\n\t\telse if ($type == 'custom-pattern') {\n\t\t\t$ipRange = '';\n\t\t\tif (isset($payload['ipRange']) && !empty($payload['ipRange'])) {\n\t\t\t\t$ipRange = new wfUserIPRange($payload['ipRange']);\n\t\t\t\t$ipRange = $ipRange->getIPString();\n\t\t\t}\n\t\t\t$hostname = (isset($payload['hostname']) && !empty($payload['hostname'])) ? $payload['hostname'] : '';\n\t\t\t$userAgent = (isset($payload['userAgent']) && !empty($payload['userAgent'])) ? $payload['userAgent'] : '';\n\t\t\t$referrer = (isset($payload['referrer']) && !empty($payload['referrer'])) ? $payload['referrer'] : '';\n\t\t\twfBlock::createPattern($reason, $ipRange, $hostname, $userAgent, $referrer, $duration);\n\t\t}\n\t}\n\t\n\t\/**\n\t * Creates an IP block if one doesn't already exist for the given IP. The parameters are expected to have been validated and sanitized prior to calling this.\n\t * \n\t * @param string $reason\n\t * @param string $ip\n\t * @param int $duration Optional. Defaults to forever. This is the number of seconds for the block to last.\n\t * @param bool|int $blockedTime Optional. Defaults to the current timestamp.\n\t * @param bool|int $lastAttempt Optional. Defaults to 0, which means never.\n\t * @param bool|int $blockedHits Optional. Defaults to 0.\n\t *\/\n\tpublic static function createIP($reason, $ip, $duration = self::DURATION_FOREVER, $blockedTime = false, $lastAttempt = false, $blockedHits = false, $type = self::TYPE_IP_MANUAL) {\n\t\tglobal $wpdb;\n\t\t\n\t\tif (self::isWhitelisted($ip)) { return; }\n\t\t\n\t\tif ($blockedTime === false) {\n\t\t\t$blockedTime = time();\n\t\t}\n\t\t\n\t\t$ipHex = wfDB::binaryValueToSQLHex(wfUtils::inet_pton($ip));\n\t\t$blocksTable = wfBlock::blocksTable();\n\t\t$hasExisting = $wpdb->query($wpdb->prepare(\"UPDATE `{$blocksTable}` SET `reason` = %s, `expiration` = %d WHERE `expiration` > UNIX_TIMESTAMP() AND `type` = %d AND `IP` = {$ipHex}\", $reason, ($duration ? $blockedTime + $duration : $duration), $type));\n\t\tif (!$hasExisting) {\n\t\t\t$wpdb->query($wpdb->prepare(\"INSERT INTO `{$blocksTable}` (`type`, `IP`, `blockedTime`, `reason`, `lastAttempt`, `blockedHits`, `expiration`, `parameters`) VALUES (%d, {$ipHex}, %d, %s, %d, %d, %d, NULL)\", $type, $blockedTime, $reason, (int) $lastAttempt, (int) $blockedHits, ($duration ? $blockedTime + $duration : $duration)));\n\t\t\t\n\t\t\twfConfig::inc('totalIPsBlocked');\n\t\t}\n\t\t\n\t\tif ($type == self::TYPE_IP_MANUAL || $type == self::TYPE_IP_AUTOMATIC_PERMANENT) {\n\t\t\t\/**\n\t\t\t * Fires when an IP\/Pattern block is created.\n\t\t\t *\n\t\t\t * @since 8.0.0\n\t\t\t *\n\t\t\t * @param string $type The type of block.\n\t\t\t * @param string $reason The reason for the block.\n\t\t\t * @param string|array $parameters The IP address being blocked for IP blocks or the pattern for pattern blocks.\n\t\t\t *\/\n\t\t\tdo_action('wordfence_created_ip_pattern_block', $type, $reason, $ip);\n\t\t}\n\t\t\n\t\tif (!WFWAF_SUBDIRECTORY_INSTALL && class_exists('wfWAFIPBlocksController')) {\n\t\t\twfWAFIPBlocksController::setNeedsSynchronizeConfigSettings();\n\t\t}\n\t}\n\t\n\t\/**\n\t * Creates an IP block for a WFSN response if one doesn't already exist for the given IP. The parameters are expected to have been validated and sanitized prior to calling this.\n\t *\n\t * @param string $reason\n\t * @param string $ip\n\t * @param int $duration This is the number of seconds for the block to last.\n\t * @param bool|int $blockedTime Optional. Defaults to the current timestamp.\n\t * @param bool|int $lastAttempt Optional. Defaults to 0, which means never.\n\t * @param bool|int $blockedHits Optional. Defaults to 0.\n\t *\/\n\tpublic static function createWFSN($reason, $ip, $duration, $blockedTime = false, $lastAttempt = false, $blockedHits = false) {\n\t\tglobal $wpdb;\n\t\t\n\t\tif (self::isWhitelisted($ip)) { return; }\n\t\t\n\t\tif ($blockedTime === false) {\n\t\t\t$blockedTime = time();\n\t\t}\n\t\t\n\t\t$ipHex = wfDB::binaryValueToSQLHex(wfUtils::inet_pton($ip));\n\t\t$blocksTable = wfBlock::blocksTable();\n\t\t$hasExisting = $wpdb->query($wpdb->prepare(\"UPDATE `{$blocksTable}` SET `reason` = %s, `expiration` = %d WHERE `expiration` > UNIX_TIMESTAMP() AND `type` = %d AND `IP` = {$ipHex}\", $reason, ($duration ? $blockedTime + $duration : $duration), self::TYPE_WFSN_TEMPORARY));\n\t\tif (!$hasExisting) {\n\t\t\t$wpdb->query($wpdb->prepare(\"INSERT INTO `{$blocksTable}` (`type`, `IP`, `blockedTime`, `reason`, `lastAttempt`, `blockedHits`, `expiration`, `parameters`) VALUES (%d, {$ipHex}, %d, %s, %d, %d, %d, NULL)\", self::TYPE_WFSN_TEMPORARY, $blockedTime, $reason, (int) $lastAttempt, (int) $blockedHits, ($duration ? $blockedTime + $duration : $duration)));\n\t\t\t\n\t\t\twfConfig::inc('totalIPsBlocked');\n\t\t}\n\t\t\n\t\tif (!WFWAF_SUBDIRECTORY_INSTALL && class_exists('wfWAFIPBlocksController')) {\n\t\t\twfWAFIPBlocksController::setNeedsSynchronizeConfigSettings();\n\t\t}\n\t}\n\t\n\t\/**\n\t * Creates an IP block for a rate limit if one doesn't already exist for the given IP. The parameters are expected to have been validated and sanitized prior to calling this.\n\t *\n\t * @param string $reason\n\t * @param string $ip\n\t * @param int $duration This is the number of seconds for the block to last.\n\t * @param bool|int $blockedTime Optional. Defaults to the current timestamp.\n\t * @param bool|int $lastAttempt Optional. Defaults to 0, which means never.\n\t * @param bool|int $blockedHits Optional. Defaults to 0.\n\t *\/\n\tpublic static function createRateBlock($reason, $ip, $duration, $blockedTime = false, $lastAttempt = false, $blockedHits = false) {\n\t\tglobal $wpdb;\n\t\t\n\t\tif (self::isWhitelisted($ip)) { return; }\n\t\t\n\t\tif ($blockedTime === false) {\n\t\t\t$blockedTime = time();\n\t\t}\n\t\t\n\t\t$ipHex = wfDB::binaryValueToSQLHex(wfUtils::inet_pton($ip));\n\t\t$blocksTable = wfBlock::blocksTable();\n\t\t$hasExisting = $wpdb->query($wpdb->prepare(\"UPDATE `{$blocksTable}` SET `reason` = %s, `expiration` = %d WHERE `expiration` > UNIX_TIMESTAMP() AND `type` = %d AND `IP` = {$ipHex}\", $reason, ($duration ? $blockedTime + $duration : $duration), self::TYPE_RATE_BLOCK));\n\t\tif (!$hasExisting) {\n\t\t\t$wpdb->query($wpdb->prepare(\"INSERT INTO `{$blocksTable}` (`type`, `IP`, `blockedTime`, `reason`, `lastAttempt`, `blockedHits`, `expiration`, `parameters`) VALUES (%d, {$ipHex}, %d, %s, %d, %d, %d, NULL)\", self::TYPE_RATE_BLOCK, $blockedTime, $reason, (int) $lastAttempt, (int) $blockedHits, ($duration ? $blockedTime + $duration : $duration)));\n\t\t\t\n\t\t\twfConfig::inc('totalIPsBlocked');\n\t\t}\n\t\t\n\t\tif (!WFWAF_SUBDIRECTORY_INSTALL && class_exists('wfWAFIPBlocksController')) {\n\t\t\twfWAFIPBlocksController::setNeedsSynchronizeConfigSettings();\n\t\t}\n\t}\n\t\n\t\/**\n\t * Creates an IP throttle for a rate limit if one doesn't already exist for the given IP. The parameters are expected to have been validated and sanitized prior to calling this.\n\t *\n\t * @param string $reason\n\t * @param string $ip\n\t * @param int $duration This is the number of seconds for the block to last.\n\t * @param bool|int $blockedTime Optional. Defaults to the current timestamp.\n\t * @param bool|int $lastAttempt Optional. Defaults to 0, which means never.\n\t * @param bool|int $blockedHits Optional. Defaults to 0.\n\t *\/\n\tpublic static function createRateThrottle($reason, $ip, $duration, $blockedTime = false, $lastAttempt = false, $blockedHits = false) {\n\t\tglobal $wpdb;\n\t\t\n\t\tif (self::isWhitelisted($ip)) { return; }\n\t\t\n\t\tif ($blockedTime === false) {\n\t\t\t$blockedTime = time();\n\t\t}\n\t\t\n\t\t$ipHex = wfDB::binaryValueToSQLHex(wfUtils::inet_pton($ip));\n\t\t$blocksTable = wfBlock::blocksTable();\n\t\t$hasExisting = $wpdb->query($wpdb->prepare(\"UPDATE `{$blocksTable}` SET `reason` = %s, `expiration` = %d WHERE `expiration` > UNIX_TIMESTAMP() AND `type` = %d AND `IP` = {$ipHex}\", $reason, ($duration ? $blockedTime + $duration : $duration), self::TYPE_RATE_THROTTLE));\n\t\tif (!$hasExisting) {\n\t\t\t$wpdb->query($wpdb->prepare(\"INSERT INTO `{$blocksTable}` (`type`, `IP`, `blockedTime`, `reason`, `lastAttempt`, `blockedHits`, `expiration`, `parameters`) VALUES (%d, {$ipHex}, %d, %s, %d, %d, %d, NULL)\", self::TYPE_RATE_THROTTLE, $blockedTime, $reason, (int) $lastAttempt, (int) $blockedHits, ($duration ? $blockedTime + $duration : $duration)));\n\t\t\t\n\t\t\twfConfig::inc('totalIPsBlocked');\n\t\t}\n\t\t\n\t\tif (!WFWAF_SUBDIRECTORY_INSTALL && class_exists('wfWAFIPBlocksController')) {\n\t\t\twfWAFIPBlocksController::setNeedsSynchronizeConfigSettings();\n\t\t}\n\t}\n\t\n\t\/**\n\t * Creates a lockout if one doesn't already exist for the given IP. The parameters are expected to have been validated and sanitized prior to calling this.\n\t *\n\t * @param string $reason\n\t * @param string $ip\n\t * @param int $duration This is the number of seconds for the block to last.\n\t * @param bool|int $blockedTime Optional. Defaults to the current timestamp.\n\t * @param bool|int $lastAttempt Optional. Defaults to 0, which means never.\n\t * @param bool|int $blockedHits Optional. Defaults to 0.\n\t *\/\n\tpublic static function createLockout($reason, $ip, $duration, $blockedTime = false, $lastAttempt = false, $blockedHits = false) {\n\t\tglobal $wpdb;\n\t\t\n\t\tif (self::isWhitelisted($ip)) { return; }\n\t\t\n\t\tif ($blockedTime === false) {\n\t\t\t$blockedTime = time();\n\t\t}\n\t\t\n\t\t$blocksTable = wfBlock::blocksTable();\n\t\t$ipHex = wfDB::binaryValueToSQLHex(wfUtils::inet_pton($ip));\n\t\t$hasExisting = $wpdb->query($wpdb->prepare(\"UPDATE `{$blocksTable}` SET `reason` = %s, `expiration` = %d WHERE `expiration` > UNIX_TIMESTAMP() AND `type` = %d AND `IP` = {$ipHex}\", $reason, ($duration ? $blockedTime + $duration : $duration), self::TYPE_LOCKOUT));\n\t\tif (!$hasExisting) {\n\t\t\t$wpdb->query($wpdb->prepare(\"INSERT INTO `{$blocksTable}` (`type`, `IP`, `blockedTime`, `reason`, `lastAttempt`, `blockedHits`, `expiration`, `parameters`) VALUES (%d, {$ipHex}, %d, %s, %d, %d, %d, NULL)\", self::TYPE_LOCKOUT, $blockedTime, $reason, (int) $lastAttempt, (int) $blockedHits, ($duration ? $blockedTime + $duration : $duration)));\n\t\t\t\n\t\t\twfConfig::inc('totalIPsLocked');\n\t\t}\n\t\t\n\t\tif (!WFWAF_SUBDIRECTORY_INSTALL && class_exists('wfWAFIPBlocksController')) {\n\t\t\twfWAFIPBlocksController::setNeedsSynchronizeConfigSettings();\n\t\t}\n\t}\n\t\n\t\/**\n\t * Creates a country block. The parameters are expected to have been validated and sanitized prior to calling this.\n\t *\n\t * @param string $reason\n\t * @param string $blockLogin\n\t * @param string $blockSite\n\t * @param string $countries\n\t * @param int $duration Optional. Defaults to forever. This is the number of seconds for the block to last.\n\t * @param bool|int $blockedTime Optional. Defaults to the current timestamp.\n\t * @param bool|int $lastAttempt Optional. Defaults to 0, which means never.\n\t * @param bool|int $blockedHits Optional. Defaults to 0.\n\t *\/\n\tpublic static function createCountry($reason, $blockLogin, $blockSite, $countries, $duration = self::DURATION_FOREVER, $blockedTime = false, $lastAttempt = false, $blockedHits = false) {\n\t\tglobal $wpdb;\n\t\t\n\t\tif ($blockedTime === false) {\n\t\t\t$blockedTime = time();\n\t\t}\n\t\t\n\t\t$parameters = array(\n\t\t\t'blockLogin' => $blockLogin ? 1 : 0,\n\t\t\t'blockSite' => $blockSite ? 1 : 0,\n\t\t\t'countries' => $countries,\n\t\t);\n\t\t\n\t\t$blocksTable = wfBlock::blocksTable();\n\t\t$existing = $wpdb->get_row($wpdb->prepare(\"SELECT * FROM `{$blocksTable}` WHERE `type` = %d LIMIT 1\", self::TYPE_COUNTRY), ARRAY_A);\n\t\t$before = array(\n\t\t\t'parameters' => null,\n\t\t\t'bypass' => array(\n\t\t\t\t'cbl_loggedInBlocked' => wfConfig::get('cbl_loggedInBlocked', false),\n\t\t\t\t'cbl_action' => wfConfig::get('cbl_action'),\n\t\t\t\t'cbl_redirURL' => wfConfig::get('cbl_redirURL', ''),\n\t\t\t\t'cbl_bypassRedirURL' => wfConfig::get('cbl_bypassRedirURL', ''),\n\t\t\t\t'cbl_bypassRedirDest' => wfConfig::get('cbl_bypassRedirDest', ''),\n\t\t\t\t'cbl_bypassViewURL' => wfConfig::get('cbl_bypassViewURL', ''),\n\t\t\t),\n\t\t);\n\t\t$after = $before;\n\t\t$after['parameters'] = $parameters;\n\t\tif ($existing) {\n\t\t\t$before['parameters'] = @json_decode($existing['parameters'], true);\n\t\t\tif (!is_array($before['parameters'])) { $before['parameters'] = array(); }\n\t\t\t$wpdb->query($wpdb->prepare(\"UPDATE `{$blocksTable}` SET `reason` = %s, `parameters` = %s WHERE `id` = %d\", $reason, json_encode($parameters), $existing['id']));\n\t\t}\n\t\telse {\n\t\t\t$wpdb->query($wpdb->prepare(\"INSERT INTO `{$blocksTable}` (`type`, `IP`, `blockedTime`, `reason`, `lastAttempt`, `blockedHits`, `expiration`, `parameters`) VALUES (%d, %s, %d, %s, %d, %d, %d, %s)\", self::TYPE_COUNTRY, self::MARKER_COUNTRY, $blockedTime, $reason, (int) $lastAttempt, (int) $blockedHits, ($duration ? $blockedTime + $duration : $duration), json_encode($parameters)));\n\t\t}\n\t\t\n\t\t\/**\n\t\t * Fires when the country blocking rule is updated.\n\t\t *\n\t\t * @since 8.0.0\n\t\t *\n\t\t * @param array $before {\n\t\t * \t\tThe country block configuration before the change\n\t\t * \n\t\t * \t\t@type array $parameters The parameters of the country block.\n\t\t * \t\t@type array $bypass {\n\t\t * \t\t\tThe assorted bypass settings for country blocking.\n\t\t * \n\t\t * \t\t\t@type bool $cbl_loggedInBlocked Block countries even if there is a valid logged-in user for the request\n\t\t * \t\t\t@type string $cbl_action Action taken when a request is received from a blocked country\n\t\t * \t\t\t@type string $cbl_redirURL URL destination when $cbl_action is `redir`\n\t\t * \t\t\t@type string $cbl_bypassRedirURL If a visitor hits this URL\n\t\t * \t\t\t@type string $cbl_bypassRedirDest then redirect to this URL and set a cookie that will bypass all country blocking\n\t\t * \t\t\t@type string $cbl_bypassViewURL If a user currently not blocked hits this URL, then set a cookie that will bypass country blocking in the future even if visiting from a blocked country\n\t\t * \t\t}\n\t\t * }\n\t\t * @param array $after The country block configuration after the change, same structure as $before\n\t\t *\/\n\t\tdo_action('wordfence_updated_country_blocking', $before, $after);\n\t\t\n\t\tif (!WFWAF_SUBDIRECTORY_INSTALL && class_exists('wfWAFIPBlocksController')) {\n\t\t\twfWAFIPBlocksController::setNeedsSynchronizeConfigSettings();\n\t\t}\n\t}\n\t\n\t\/**\n\t * Creates a pattern block. The parameters are expected to have been validated and sanitized prior to calling this.\n\t * \n\t * @param string $reason\n\t * @param string $ipRange\n\t * @param string $hostname\n\t * @param string $userAgent\n\t * @param string $referrer\n\t * @param int $duration Optional. Defaults to forever. This is the number of seconds for the block to last.\n\t * @param bool|int $blockedTime Optional. Defaults to the current timestamp.\n\t * @param bool|int $lastAttempt Optional. Defaults to 0, which means never.\n\t * @param bool|int $blockedHits Optional. Defaults to 0.\n\t *\/\n\tpublic static function createPattern($reason, $ipRange, $hostname, $userAgent, $referrer, $duration = self::DURATION_FOREVER, $blockedTime = false, $lastAttempt = false, $blockedHits = false) {\n\t\tglobal $wpdb;\n\t\t\n\t\tif ($blockedTime === false) {\n\t\t\t$blockedTime = time();\n\t\t}\n\t\t\n\t\t$parameters = array(\n\t\t\t'ipRange' => $ipRange,\n\t\t\t'hostname' => $hostname,\n\t\t\t'userAgent' => $userAgent,\n\t\t\t'referrer' => $referrer,\n\t\t);\n\t\t\n\t\t$blocksTable = wfBlock::blocksTable();\n\t\t$wpdb->query($wpdb->prepare(\"INSERT INTO `{$blocksTable}` (`type`, `IP`, `blockedTime`, `reason`, `lastAttempt`, `blockedHits`, `expiration`, `parameters`) VALUES (%d, %s, %d, %s, %d, %d, %d, %s)\", self::TYPE_PATTERN, self::MARKER_PATTERN, $blockedTime, $reason, (int) $lastAttempt, (int) $blockedHits, ($duration ? $blockedTime + $duration : $duration), json_encode($parameters)));\n\t\t\n\t\t\/**\n\t\t * @see wfBlock::createIP()\n\t\t *\/\n\t\tdo_action('wordfence_created_ip_pattern_block', self::TYPE_PATTERN, $reason, $parameters);\n\t\t\n\t\tif (!WFWAF_SUBDIRECTORY_INSTALL && class_exists('wfWAFIPBlocksController')) {\n\t\t\twfWAFIPBlocksController::setNeedsSynchronizeConfigSettings();\n\t\t}\n\t}\n\t\n\t\/**\n\t * Removes all expired blocks.\n\t *\/\n\tpublic static function vacuum() {\n\t\tglobal $wpdb;\n\t\t$blocksTable = wfBlock::blocksTable();\n\t\t$wpdb->query(\"DELETE FROM `{$blocksTable}` WHERE `expiration` <= UNIX_TIMESTAMP() AND `expiration` != \" . self::DURATION_FOREVER);\n\t}\n\t\n\t\/**\n\t * Imports all valid blocks in $blocks. If $replaceExisting is true, this will remove all permanent blocks prior to the import.\n\t * \n\t * @param array $blocks\n\t * @param bool $replaceExisting\n\t *\/\n\tpublic static function importBlocks($blocks, $replaceExisting = true) {\n\t\tglobal $wpdb;\n\t\t$blocksTable = wfBlock::blocksTable();\n\t\t\n\t\tif ($replaceExisting) {\n\t\t\t$removing = self::_recordsFromRows($wpdb->get_results(\"SELECT * FROM `{$blocksTable}` WHERE `expiration` = \" . self::DURATION_FOREVER, ARRAY_A));\n\t\t\tself::removeMultiple($removing, true);\n\t\t}\n\t\t\n\t\tforeach ($blocks as $b) {\n\t\t\tself::_importBlock($b);\n\t\t}\n\t\t\n\t\tif (!WFWAF_SUBDIRECTORY_INSTALL && class_exists('wfWAFIPBlocksController')) {\n\t\t\twfWAFIPBlocksController::setNeedsSynchronizeConfigSettings();\n\t\t}\n\t}\n\t\n\t\/**\n\t * Validates the block import record and inserts it if valid. This validation is identical to what is applied to adding one through the UI.\n\t * \n\t * @param array $b\n\t * @return bool\n\t *\/\n\tprivate static function _importBlock($b) {\n\t\tglobal $wpdb;\n\t\t$blocksTable = wfBlock::blocksTable();\n\t\t\n\t\tif (!isset($b['type']) || !isset($b['IP']) || !isset($b['blockedTime']) || !isset($b['reason']) || !isset($b['lastAttempt']) || !isset($b['blockedHits'])) { return false; }\n\t\tif (empty($b['IP']) || empty($b['reason'])) { return false; }\n\t\t\n\t\t$ip = wfUtils::inet_ntop(wfUtils::hex2bin($b['IP']));\n\t\tif (!wfUtils::isValidIP($ip)) { return false; }\n\t\t\n\t\tswitch ($b['type']) {\n\t\t\tcase self::TYPE_IP_MANUAL:\n\t\t\tcase self::TYPE_IP_AUTOMATIC_TEMPORARY:\n\t\t\tcase self::TYPE_IP_AUTOMATIC_PERMANENT:\n\t\t\tcase self::TYPE_WFSN_TEMPORARY:\n\t\t\tcase self::TYPE_RATE_BLOCK:\n\t\t\tcase self::TYPE_RATE_THROTTLE:\n\t\t\tcase self::TYPE_LOCKOUT:\n\t\t\t\tif (self::isWhitelisted($ip)) { return false; }\n\n\t\t\t\tif ($b['type'] == self::TYPE_IP_MANUAL || $b['type'] == self::TYPE_IP_AUTOMATIC_PERMANENT) {\n\t\t\t\t\t\/**\n\t\t\t\t\t * @see wfBlock::createIP()\n\t\t\t\t\t *\/\n\t\t\t\t\tdo_action('wordfence_created_ip_pattern_block', $b['type'], $b['reason'], $ip);\n\t\t\t\t}\n\t\t\t\n\t\t\t\t$ipHex = wfDB::binaryValueToSQLHex(wfUtils::inet_pton($ip));\n\t\t\t\treturn $wpdb->query($wpdb->prepare(\"INSERT INTO `{$blocksTable}` (`type`, `IP`, `blockedTime`, `reason`, `lastAttempt`, `blockedHits`, `expiration`, `parameters`) VALUES (%d, {$ipHex}, %d, %s, %d, %d, %d, NULL)\", (int) $b['type'], (int) $b['blockedTime'], $b['reason'], (int) $b['lastAttempt'], (int) $b['blockedHits'], self::DURATION_FOREVER)) !== false;\n\t\t\tcase self::TYPE_COUNTRY:\n\t\t\t\tif (!isset($b['parameters'])) { return false; }\n\t\t\t\tif (wfUtils::inet_pton($ip) != self::MARKER_COUNTRY) { return false; }\n\t\t\t\t$parameters = @json_decode($b['parameters'], true);\n\t\t\t\tif (!is_array($parameters)) { $parameters = array(); }\n\t\t\t\tif (!isset($parameters['blockLogin']) || !isset($parameters['blockSite']) || !isset($parameters['countries'])) { return false; }\n\t\t\t\t$parameters['blockLogin'] = wfUtils::truthyToInt($parameters['blockLogin']);\n\t\t\t\t$parameters['blockSite'] = wfUtils::truthyToInt($parameters['blockSite']);\n\t\t\t\t\n\t\t\t\trequire(WORDFENCE_PATH . 'lib\/wfBulkCountries.php'); \/** @var array $wfBulkCountries *\/\n\t\t\t\tforeach ($parameters['countries'] as $code) {\n\t\t\t\t\tif (!isset($wfBulkCountries[$code])) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t$parameters = array('blockLogin' => $parameters['blockLogin'], 'blockSite' => $parameters['blockSite'], 'countries' => $parameters['countries']);\n\t\t\t\n\t\t\t\t$before = array(\n\t\t\t\t\t'parameters' => null,\n\t\t\t\t\t'bypass' => array(\n\t\t\t\t\t\t'cbl_loggedInBlocked' => wfConfig::get('cbl_loggedInBlocked', false),\n\t\t\t\t\t\t'cbl_action' => wfConfig::get('cbl_action'),\n\t\t\t\t\t\t'cbl_redirURL' => wfConfig::get('cbl_redirURL', ''),\n\t\t\t\t\t\t'cbl_bypassRedirURL' => wfConfig::get('cbl_bypassRedirURL', ''),\n\t\t\t\t\t\t'cbl_bypassRedirDest' => wfConfig::get('cbl_bypassRedirDest', ''),\n\t\t\t\t\t\t'cbl_bypassViewURL' => wfConfig::get('cbl_bypassViewURL', ''),\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t\t$after = $before;\n\t\t\t\t$after['parameters'] = $parameters;\n\t\t\t\t\n\t\t\t\t\/**\n\t\t\t\t * @see wfBlock::createCountry()\n\t\t\t\t *\/\n\t\t\t\tdo_action('wordfence_updated_country_blocking', $before, $after);\n\t\t\t\t\n\t\t\t\t$ipHex = wfDB::binaryValueToSQLHex(self::MARKER_COUNTRY);\n\t\t\t\treturn $wpdb->query($wpdb->prepare(\"INSERT INTO `{$blocksTable}` (`type`, `IP`, `blockedTime`, `reason`, `lastAttempt`, `blockedHits`, `expiration`, `parameters`) VALUES (%d, {$ipHex}, %d, %s, %d, %d, %d, %s)\", self::TYPE_COUNTRY, (int) $b['blockedTime'], $b['reason'], (int) $b['lastAttempt'], (int) $b['blockedHits'], self::DURATION_FOREVER, json_encode($parameters))) !== false;\n\t\t\tcase self::TYPE_PATTERN:\n\t\t\t\tif (!isset($b['parameters'])) { return false; }\n\t\t\t\tif (wfUtils::inet_pton($ip) != self::MARKER_PATTERN) { return false; }\n\t\t\t\t$parameters = @json_decode($b['parameters'], true);\n\t\t\t\tif (!is_array($parameters)) { $parameters = array(); }\n\t\t\t\tif (!isset($parameters['ipRange']) || !isset($parameters['hostname']) || !isset($parameters['userAgent']) || !isset($parameters['referrer'])) { return false; }\n\t\t\t\t\n\t\t\t\t$hasOne = false;\n\t\t\t\tif (!empty($parameters['ipRange'])) {\n\t\t\t\t\t$ipRange = new wfUserIPRange($parameters['ipRange']);\n\t\t\t\t\tif ($ipRange->isValidRange()) {\n\t\t\t\t\t\tif ($ipRange->isMixedRange()) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t$hasOne = true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!empty($parameters['hostname'])) {\n\t\t\t\t\tif (preg_match('\/^[a-z0-9\\.\\*\\-]+$\/i', $parameters['hostname'])) {\n\t\t\t\t\t\t$hasOne = true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!empty($parameters['userAgent'])) { $hasOne = true; }\n\t\t\t\tif (!empty($parameters['referrer'])) { $hasOne = true; }\n\t\t\t\tif (!$hasOne) { return false; }\n\t\t\t\t\n\t\t\t\t$ipRange = '';\n\t\t\t\tif (!empty($parameters['ipRange'])) {\n\t\t\t\t\t$ipRange = new wfUserIPRange($parameters['ipRange']);\n\t\t\t\t\t$ipRange = $ipRange->getIPString();\n\t\t\t\t}\n\t\t\t\t$parameters = array(\n\t\t\t\t\t'ipRange' => $ipRange,\n\t\t\t\t\t'hostname' => $parameters['hostname'],\n\t\t\t\t\t'userAgent' => $parameters['userAgent'],\n\t\t\t\t\t'referrer' => $parameters['referrer'],\n\t\t\t\t);\n\t\t\t\t\n\t\t\t\t\/**\n\t\t\t\t * @see wfBlock::createIP()\n\t\t\t\t *\/\n\t\t\t\tdo_action('wordfence_created_ip_pattern_block', $b['type'], $b['reason'], $parameters);\n\t\t\t\t\n\t\t\t\t$ipHex = wfDB::binaryValueToSQLHex(self::MARKER_PATTERN);\n\t\t\t\treturn $wpdb->query($wpdb->prepare(\"INSERT INTO `{$blocksTable}` (`type`, `IP`, `blockedTime`, `reason`, `lastAttempt`, `blockedHits`, `expiration`, `parameters`) VALUES (%d, {$ipHex}, %d, %s, %d, %d, %d, %s)\", self::TYPE_PATTERN, (int) $b['blockedTime'], $b['reason'], (int) $b['lastAttempt'], (int) $b['blockedHits'], self::DURATION_FOREVER, json_encode($parameters))) !== false;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t\/**\n\t * Returns an array suitable for JSON output of all permanent blocks.\n\t * \n\t * @return array\n\t *\/\n\tpublic static function exportBlocks() {\n\t\tglobal $wpdb;\n\t\t$blocksTable = wfBlock::blocksTable();\n\t\t$query = \"SELECT `type`, HEX(`IP`) AS `IP`, `blockedTime`, `reason`, `lastAttempt`, `blockedHits`, `parameters` FROM `{$blocksTable}` WHERE `expiration` = \" . self::DURATION_FOREVER;\n\t\t$rows = $wpdb->get_results($query, ARRAY_A);\n\t\treturn $rows;\n\t}\n\t\n\t\/**\n\t * Returns all unexpired blocks (including lockouts by default), optionally only of the specified types. These are sorted descending by the time created.\n\t * \n\t * @param bool $prefetch If true, the full data for the block is fetched rather than using lazy loading.\n\t * @param array $ofTypes An optional array of block types to restrict the returned array of blocks to.\n\t * @param int $offset The offset to start the result fetch at.\n\t * @param int $limit The maximum number of results to return. -1 for all.\n\t * @param string $sortColumn The column to sort by.\n\t * @param string $sortDirection The direction to sort.\n\t * @param string $filter An optional value to filter by.\n\t * @return wfBlock[]\n\t *\/\n\tpublic static function allBlocks($prefetch = false, $ofTypes = array(), $offset = 0, $limit = -1, $sortColumn = 'type', $sortDirection = 'ascending', $filter = '') {\n\t\tglobal $wpdb;\n\t\t$blocksTable = wfBlock::blocksTable();\n\t\t$columns = '`id`';\n\t\tif ($prefetch) {\n\t\t\t$columns = '*';\n\t\t}\n\t\t\n\t\t$sort = 'typeSort';\n\t\tswitch ($sortColumn) { \/\/Match the display table column to the corresponding schema column\n\t\t\tcase 'type':\n\t\t\t\t\/\/Use default;\n\t\t\t\tbreak;\n\t\t\tcase 'detail':\n\t\t\t\t$sort = 'detailSort';\n\t\t\t\tbreak;\n\t\t\tcase 'ruleAdded':\n\t\t\t\t$sort = 'blockedTime';\n\t\t\t\tbreak;\n\t\t\tcase 'reason':\n\t\t\t\t$sort = 'reason';\n\t\t\t\tbreak;\n\t\t\tcase 'expiration':\n\t\t\t\t$sort = 'expiration';\n\t\t\t\tbreak;\n\t\t\tcase 'blockCount':\n\t\t\t\t$sort = 'blockedHits';\n\t\t\t\tbreak;\n\t\t\tcase 'lastAttempt':\n\t\t\t\t$sort = 'lastAttempt';\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\t$order = 'ASC';\n\t\tif ($sortDirection == 'descending') {\n\t\t\t$order = 'DESC';\n\t\t}\n\t\t\n\t\t$query = \"SELECT {$columns}, CASE \nWHEN `type` = \" . self::TYPE_COUNTRY . \" THEN 0\nWHEN `type` = \" . self::TYPE_PATTERN . \" THEN 1\nWHEN `type` = \" . self::TYPE_LOCKOUT . \" THEN 2\nWHEN `type` = \" . self::TYPE_RATE_THROTTLE . \" THEN 3\nWHEN `type` = \" . self::TYPE_RATE_BLOCK . \" THEN 4\nWHEN `type` = \" . self::TYPE_IP_AUTOMATIC_PERMANENT . \" THEN 5\nWHEN `type` = \" . self::TYPE_IP_AUTOMATIC_TEMPORARY . \" THEN 6\nWHEN `type` = \" . self::TYPE_WFSN_TEMPORARY . \" THEN 7\nWHEN `type` = \" . self::TYPE_IP_MANUAL . \" THEN 8\nELSE 9999\nEND AS `typeSort`, CASE \nWHEN `type` = \" . self::TYPE_COUNTRY . \" THEN `parameters`\nWHEN `type` = \" . self::TYPE_PATTERN . \" THEN `parameters`\nWHEN `type` = \" . self::TYPE_IP_MANUAL . \" THEN `IP`\nWHEN `type` = \" . self::TYPE_IP_AUTOMATIC_PERMANENT . \" THEN `IP`\nWHEN `type` = \" . self::TYPE_RATE_BLOCK . \" THEN `IP`\nWHEN `type` = \" . self::TYPE_RATE_THROTTLE . \" THEN `IP`\nWHEN `type` = \" . self::TYPE_LOCKOUT . \" THEN `IP`\nWHEN `type` = \" . self::TYPE_WFSN_TEMPORARY . \" THEN `IP`\nWHEN `type` = \" . self::TYPE_IP_AUTOMATIC_TEMPORARY . \" THEN `IP`\nELSE 9999\nEND AS `detailSort`\n FROM `{$blocksTable}` WHERE \";\n\t\tif (!empty($ofTypes)) {\n\t\t\t$sanitizedTypes = array_map('intval', $ofTypes);\n\t\t\t$query .= \"`type` IN (\" . implode(', ', $sanitizedTypes) . ') AND ';\n\t\t}\n\t\t$query .= '(`expiration` = ' . self::DURATION_FOREVER . \" OR `expiration` > UNIX_TIMESTAMP()) ORDER BY `{$sort}` {$order}, `id` DESC\";\n\t\t\n\t\tif ($limit > -1) {\n\t\t\t$offset = (int) $offset;\n\t\t\t$limit = (int) $limit;\n\t\t\t$query .= \" LIMIT {$offset},{$limit}\";\n\t\t}\n\t\t\n\t\t$rows = $wpdb->get_results($query, ARRAY_A);\n\t\t$result = array();\n\t\tforeach ($rows as $r) {\n\t\t\tif ($prefetch) {\n\t\t\t\tif ($r['type'] == self::TYPE_COUNTRY || $r['type'] == self::TYPE_PATTERN) {\n\t\t\t\t\t$ip = null;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$ip = wfUtils::inet_ntop($r['IP']);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t$parameters = null;\n\t\t\t\tif ($r['type'] == self::TYPE_PATTERN || $r['type'] == self::TYPE_COUNTRY) {\n\t\t\t\t\t$parameters = @json_decode($r['parameters'], true);\n\t\t\t\t\tif (!is_array($parameters)) { $parameters = array(); }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t$result[] = new wfBlock($r['id'], $r['type'], $ip, $r['blockedTime'], $r['reason'], $r['lastAttempt'], $r['blockedHits'], $r['expiration'], $parameters);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$result[] = new wfBlock($r['id']);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $result;\n\t}\n\t\n\t\/**\n\t * Functions identically to wfBlock::allBlocks except that it filters the result. The filtering is done within PHP rather than MySQL, so this will impose a performance penalty and should only\n\t * be used when filtering is actually wanted.\n\t * \n\t * @param bool $prefetch\n\t * @param array $ofTypes\n\t * @param int $offset\n\t * @param int $limit\n\t * @param string $sortColumn\n\t * @param string $sortDirection\n\t * @param string $filter\n\t * @return wfBlock[]\n\t *\/\n\tpublic static function filteredBlocks($prefetch = false, $ofTypes = array(), $offset = 0, $limit = -1, $sortColumn = 'type', $sortDirection = 'ascending', $filter = '') {\n\t\t$filter = trim($filter);\n\t\t$matchType = '';\n\t\t$matchValue = '';\n\t\tif (empty($filter)) {\n\t\t\treturn self::allBlocks($prefetch, $ofTypes, $offset, $limit, $sortColumn, $sortDirection);\n\t\t}\n\t\telse if (wfUtils::isValidIP($filter)) { \/\/e.g., 4.5.6.7, ffe0::, ::0\n\t\t\t$matchType = 'ip';\n\t\t\t$matchValue = wfUtils::inet_ntop(wfUtils::inet_pton($filter));\n\t\t}\n\t\t\n\t\tif (empty($matchType) && preg_match('\/^(?:[0-9]+|\\*)\\.(?:(?:[0-9]+|\\*)\\.(?!$))*(?:(?:[0-9]+|\\*))?$\/', trim($filter, '.'))) { \/\/e.g., possible wildcard IPv4 like 4.5.*\n\t\t\t$components = explode('.', trim($filter, '.'));\n\t\t\tif (count($components) <= 4) {\n\t\t\t\t$components = array_pad($components, 4, '*');\n\t\t\t\t$matchType = 'ipregex';\n\t\t\t\t$matchValue = '^';\n\t\t\t\tforeach ($components as $c) {\n\t\t\t\t\tif (empty($c) || $c == '*') {\n\t\t\t\t\t\t$matchValue .= '\\d+';\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t$matchValue .= (int) $c;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$matchValue .= '\\.';\n\t\t\t\t}\n\t\t\t\t$matchValue = substr($matchValue, 0, -2);\n\t\t\t\t$matchValue .= '$';\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (empty($matchType) && preg_match('\/^(?:[0-9a-f]+\\:)(?:[0-9a-f]+\\:|\\*){1,2}(?:[0-9a-f]+|\\*)?$\/i', $filter)) { \/\/e.g., possible wildcard IPv6 like ffe0:*\n\t\t\t$components = explode(':', $filter);\n\t\t\t$matchType = 'ipregex';\n\t\t\t$matchValue = '^';\n\t\t\tfor ($i = 0; $i < 4; $i++) {\n\t\t\t\tif (isset($components[$i])) {\n\t\t\t\t\t$matchValue .= strtoupper(str_pad(dechex($components[$i]), 4, '0', STR_PAD_LEFT));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$matchValue .= '[0-9a-f]{4}';\n\t\t\t\t}\n\t\t\t\t$matchValue .= ':';\n\t\t\t}\n\t\t\t$matchValue = substr($matchValue, 0, -1);\n\t\t\t$matchValue .= '$';\n\t\t}\n\t\t\n\t\tif (empty($matchType)) {\n\t\t\t$matchType = 'literal';\n\t\t\t$matchValue = $filter;\n\t\t}\n\t\t\n\t\t$offsetProcessed = 0;\n\t\t$limitProcessed = 0;\n\t\t\n\t\t$returnBlocks = array();\n\t\tfor ($i = 0; true; $i += WORDFENCE_BLOCKED_IPS_PER_PAGE) {\n\t\t\t$blocks = wfBlock::allBlocks(true, $ofTypes, $i, WORDFENCE_BLOCKED_IPS_PER_PAGE, $sortColumn, $sortDirection);\n\t\t\tif (empty($blocks)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tforeach ($blocks as $b) {\n\t\t\t\t$include = false;\n\t\t\t\t\n\t\t\t\tif (stripos($b->reason, $filter) !== false) {\n\t\t\t\t\t$include = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!$include && $b->type == self::TYPE_PATTERN) {\n\t\t\t\t\tif (stripos($b->hostname, $filter) !== false) { $include = true; }\n\t\t\t\t\telse if (stripos($b->userAgent, $filter) !== false) { $include = true; }\n\t\t\t\t\telse if (stripos($b->referrer, $filter) !== false) { $include = true; }\n\t\t\t\t\telse if (stripos($b->ipRange, $filter) !== false) { $include = true; }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!$include && stripos(self::nameForType($b->type), $filter) !== false) {\n\t\t\t\t\t$include = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!$include) {\n\t\t\t\t\tswitch ($matchType) {\n\t\t\t\t\t\tcase 'ip':\n\t\t\t\t\t\t\tif ($b->matchRequest($matchValue, '', '') != self::MATCH_NONE) {\n\t\t\t\t\t\t\t\t$include = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if ($b->type == self::TYPE_LOCKOUT && wfUtils::inet_pton($matchValue) == wfUtils::inet_pton($b->ip)) {\n\t\t\t\t\t\t\t\t$include = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'ipregex':\n\t\t\t\t\t\t\tif (preg_match('\/' . $matchValue . '\/i', $b->ip)) {\n\t\t\t\t\t\t\t\t$include = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'literal':\n\t\t\t\t\t\t\t\/\/Already checked above\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ($include) {\n\t\t\t\t\tif ($offsetProcessed < $offset) { \/\/Still searching for the start offset\n\t\t\t\t\t\t$offsetProcessed++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$returnBlocks[] = $b;\n\t\t\t\t\t$limitProcessed++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ($limit != -1 && $limitProcessed >= $limit) {\n\t\t\t\t\treturn $returnBlocks;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $returnBlocks;\n\t}\n\t\n\t\/**\n\t * Returns all unexpired blocks of types wfBlock::TYPE_IP_MANUAL, wfBlock::TYPE_IP_AUTOMATIC_TEMPORARY, wfBlock::TYPE_IP_AUTOMATIC_PERMANENT, wfBlock::TYPE_WFSN_TEMPORARY, wfBlock::TYPE_RATE_BLOCK, and wfBlock::TYPE_RATE_THROTTLE.\n\t *\n\t * @param bool $prefetch If true, the full data for the block is fetched rather than using lazy loading.\n\t * @return wfBlock[]\n\t *\/\n\tpublic static function ipBlocks($prefetch = false) {\n\t\treturn self::allBlocks($prefetch, array(self::TYPE_IP_MANUAL, self::TYPE_IP_AUTOMATIC_TEMPORARY, self::TYPE_IP_AUTOMATIC_PERMANENT, self::TYPE_WFSN_TEMPORARY, self::TYPE_RATE_BLOCK, self::TYPE_RATE_THROTTLE));\n\t}\n\t\n\t\/**\n\t * Finds an IP block matching the given IP, returning it if found. Returns false if none are found.\n\t * \n\t * @param string $ip\n\t * @return bool|wfBlock\n\t *\/\n\tpublic static function findIPBlock($ip) {\n\t\tglobal $wpdb;\n\t\t$blocksTable = wfBlock::blocksTable();\n\t\t\n\t\t$ipHex = wfDB::binaryValueToSQLHex(wfUtils::inet_pton($ip));\n\t\t\n\t\t$query = \"SELECT * FROM `{$blocksTable}` WHERE \";\n\t\t\n\t\t$ofTypes = array(self::TYPE_IP_MANUAL, self::TYPE_IP_AUTOMATIC_TEMPORARY, self::TYPE_IP_AUTOMATIC_PERMANENT, self::TYPE_WFSN_TEMPORARY, self::TYPE_RATE_BLOCK, self::TYPE_RATE_THROTTLE);\n\t\t$query .= \"`type` IN (\" . implode(', ', $ofTypes) . ') AND ';\n\t\t$query .= \"`IP` = {$ipHex} AND \";\n\t\t$query .= '(`expiration` = ' . self::DURATION_FOREVER . ' OR `expiration` > UNIX_TIMESTAMP()) ORDER BY `blockedTime` DESC LIMIT 1';\n\t\t\n\t\t$r = $wpdb->get_row($query, ARRAY_A);\n\t\tif (is_array($r)) {\n\t\t\t$ip = wfUtils::inet_ntop($r['IP']);\n\t\t\treturn self::_recordFromRow($r);\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\/**\n\t * Returns all unexpired blocks of type wfBlock::TYPE_COUNTRY.\n\t *\n\t * @param bool $prefetch If true, the full data for the block is fetched rather than using lazy loading.\n\t * @return wfBlock[]\n\t *\/\n\tpublic static function countryBlocks($prefetch = false) {\n\t\treturn self::allBlocks($prefetch, array(self::TYPE_COUNTRY));\n\t}\n\t\n\t\/**\n\t * Returns whether or not there is a country block rule.\n\t * \n\t * @return bool\n\t *\/\n\tpublic static function hasCountryBlock() {\n\t\t$countryBlocks = self::countryBlocks();\n\t\treturn !empty($countryBlocks);\n\t}\n\t\n\t\/**\n\t * Returns the value for the country blocking bypass cookie.\n\t *\n\t * @return string\n\t *\/\n\tpublic static function countryBlockingBypassCookieValue() {\n\t\t$val = wfConfig::get('cbl_cookieVal', false);\n\t\tif (!$val) {\n\t\t\t$val = uniqid();\n\t\t\twfConfig::set('cbl_cookieVal', $val);\n\t\t}\n\t\treturn $val;\n\t}\n\t\n\t\/**\n\t * Returns all unexpired blocks of type wfBlock::TYPE_PATTERN.\n\t * \n\t * @param bool $prefetch If true, the full data for the block is fetched rather than using lazy loading.\n\t * @return wfBlock[]\n\t *\/\n\tpublic static function patternBlocks($prefetch = false) {\n\t\treturn self::allBlocks($prefetch, array(self::TYPE_PATTERN));\n\t}\n\t\n\t\/**\n\t * Returns all unexpired lockouts (type wfBlock::TYPE_LOCKOUT).\n\t *\n\t * @param bool $prefetch If true, the full data for the block is fetched rather than using lazy loading.\n\t * @return wfBlock[]\n\t *\/\n\tpublic static function lockouts($prefetch = false) {\n\t\treturn self::allBlocks($prefetch, array(self::TYPE_LOCKOUT));\n\t}\n\t\n\t\/**\n\t * Returns the lockout record for the given IP if it exists.\n\t * \n\t * @param string $ip\n\t * @return bool|wfBlock\n\t *\/\n\tpublic static function lockoutForIP($ip) {\n\t\tglobal $wpdb;\n\t\t$blocksTable = wfBlock::blocksTable();\n\t\t$ipHex = wfDB::binaryValueToSQLHex(wfUtils::inet_pton($ip));\n\t\t\n\t\t$row = $wpdb->get_row($wpdb->prepare(\"SELECT * FROM `{$blocksTable}` WHERE `IP` = {$ipHex} AND `type` = %d AND (`expiration` = %d OR `expiration` > UNIX_TIMESTAMP())\",  self::TYPE_LOCKOUT, self::DURATION_FOREVER), ARRAY_A);\n\t\tif ($row) {\n\t\t\treturn self::_recordFromRow($row);\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t\/**\n\t * Removes all blocks whose ID is in the given array.\n\t * \n\t * @param array $blockIDs\n\t * @param bool $retrieve if true, fetch and return the deleted rows\n\t * @param bool $notify Whether or not to broadcast the deletion action (should only do when this is called in response to a manual action)\n\t * @return bool|array true(or an array of blocks, if $retrieve is specified) or false on failure\n\t *\/\n\tpublic static function removeBlockIDs($blockIDs, $retrieve = false, $notify = true) {\n\t\t$blockIDs = array_map('intval', $blockIDs);\n\t\t$blocks = self::_recordsFromRows($blockIDs);\n\t\t$result = self::removeMultiple($blocks, $notify);\n\t\tif ($retrieve && $result) {\n\t\t\treturn $result;\n\t\t}\n\t\t\n\t\treturn !!$result;\n\t}\n\t\n\t\/**\n\t * Removes all IP blocks (i.e., manual, wfsn, or rate limited)\n\t *\n\t * @param bool $notify Whether or not to broadcast the deletion action (should only do when this is called in response to a manual action)\n\t *\/\n\tpublic static function removeAllIPBlocks($notify = true) {\n\t\tglobal $wpdb;\n\t\t$blocksTable = wfBlock::blocksTable();\n\t\t$rows = $wpdb->get_results(\"SELECT * FROM `{$blocksTable}` WHERE `type` IN (\" . implode(', ', array(self::TYPE_IP_MANUAL, self::TYPE_IP_AUTOMATIC_TEMPORARY, self::TYPE_IP_AUTOMATIC_PERMANENT, self::TYPE_WFSN_TEMPORARY, self::TYPE_RATE_BLOCK, self::TYPE_RATE_THROTTLE, self::TYPE_LOCKOUT)) . \")\", ARRAY_A);\n\t\t$blocks = self::_recordsFromRows($rows);\n\t\tself::removeMultiple($blocks, $notify);\n\t}\n\t\n\t\/**\n\t * Removes all country blocks\n\t *\n\t * @param bool $notify Whether or not to broadcast the deletion action (should only do when this is called in response to a manual action)\n\t *\/\n\tpublic static function removeAllCountryBlocks($notify = true) {\n\t\tglobal $wpdb;\n\t\t$blocksTable = wfBlock::blocksTable();\n\t\t$rows = $wpdb->get_results(\"SELECT * FROM `{$blocksTable}` WHERE `type` IN (\" . implode(', ', array(self::TYPE_COUNTRY)) . \")\", ARRAY_A);\n\t\t$blocks = self::_recordsFromRows($rows);\n\t\tself::removeMultiple($blocks, $notify);\n\t}\n\t\n\t\/**\n\t * Removes all blocks that were created by WFSN responses.\n\t * \n\t * Note: if this ever becomes called by a manual user action, it should be refactored to call \n\t * self::removeMultiple() in order to dispatch the relevant event.\n\t *\/\n\tpublic static function removeTemporaryWFSNBlocks() {\n\t\tglobal $wpdb;\n\t\t$blocksTable = wfBlock::blocksTable();\n\t\t$wpdb->query($wpdb->prepare(\"DELETE FROM `{$blocksTable}` WHERE `type` = %d\", self::TYPE_WFSN_TEMPORARY));\n\t}\n\t\n\t\/**\n\t * Converts all blocks to non-expiring whose ID is in the given array.\n\t * \n\t * @param array $blockIDs\n\t *\/\n\tpublic static function makePermanentBlockIDs($blockIDs) {\n\t\tglobal $wpdb;\n\t\t$blocksTable = wfBlock::blocksTable();\n\t\t\n\t\t\/\/TODO: revise this if we support user-customizable durations\n\t\t$supportedTypes = array(\n\t\t\tself::TYPE_WFSN_TEMPORARY,\n\t\t\tself::TYPE_RATE_BLOCK,\n\t\t\tself::TYPE_RATE_THROTTLE,\n\t\t\tself::TYPE_LOCKOUT,\n\t\t\tself::TYPE_IP_AUTOMATIC_TEMPORARY,\n\t\t);\n\t\t\n\t\t$blockIDs = array_map('intval', $blockIDs);\n\t\t$query = $wpdb->prepare(\"UPDATE `{$blocksTable}` SET `expiration` = %d, `type` = %d WHERE `id` IN (\" . implode(', ', $blockIDs) . \") AND `type` IN (\" . implode(', ', $supportedTypes) . \") AND (`expiration` > UNIX_TIMESTAMP())\", self::DURATION_FOREVER, self::TYPE_IP_AUTOMATIC_PERMANENT);\n\t\t$wpdb->query($query);\n\t\t\n\t\t$supportedTypes = array(\n\t\t\tself::TYPE_IP_MANUAL,\n\t\t);\n\t\t\n\t\t$blockIDs = array_map('intval', $blockIDs);\n\t\t$query = $wpdb->prepare(\"UPDATE `{$blocksTable}` SET `expiration` = %d, `type` = %d WHERE `id` IN (\" . implode(', ', $blockIDs) . \") AND `type` IN (\" . implode(', ', $supportedTypes) . \") AND (`expiration` > UNIX_TIMESTAMP())\", self::DURATION_FOREVER, self::TYPE_IP_MANUAL);\n\t\t$wpdb->query($query);\n\t}\n\t\n\t\/**\n\t * Removes all specific IP blocks and lockouts that can result in the given IP being blocked.\n\t * \n\t * @param string $ip\n\t * @param bool $notify Whether or not to broadcast the deletion action (should only do when this is called in response to a manual action)\n\t *\/\n\tpublic static function unblockIP($ip, $notify = true) {\n\t\tglobal $wpdb;\n\t\t$blocksTable = wfBlock::blocksTable();\n\t\t$ipHex = wfDB::binaryValueToSQLHex(wfUtils::inet_pton($ip));\n\t\t$rows = $wpdb->get_results(\"SELECT * FROM `{$blocksTable}` WHERE `IP` = {$ipHex}\", ARRAY_A);\n\t\t$blocks = self::_recordsFromRows($rows);\n\t\tself::removeMultiple($blocks, $notify);\n\t}\n\t\n\t\/**\n\t * Removes all lockouts that can result in the given IP being blocked.\n\t *\n\t * @param string $ip\n\t * @param bool $notify Whether or not to broadcast the deletion action (should only do when this is called in response to a manual action)\n\t *\/\n\tpublic static function unlockOutIP($ip, $notify = true) {\n\t\tglobal $wpdb;\n\t\t$blocksTable = wfBlock::blocksTable();\n\t\t$ipHex = wfDB::binaryValueToSQLHex(wfUtils::inet_pton($ip));\n\t\t$rows = $wpdb->get_results($wpdb->prepare(\"SELECT * FROM `{$blocksTable}` WHERE `IP` = {$ipHex} AND `type` = %d\", self::TYPE_LOCKOUT), ARRAY_A);\n\t\t$blocks = self::_recordsFromRows($rows);\n\t\tself::removeMultiple($blocks, $notify);\n\t}\n\t\n\t\/**\n\t * Internal function to convert a raw query row result into a populated wfBlock instance. $row is expected to be an\n\t * associative array.\n\t * \n\t * @param array $row\n\t * @return mixed\n\t *\/\n\tprivate static function _recordFromRow($row) {\n\t\t$records = self::_recordsFromRows(array($row));\n\t\treturn $records[0];\n\t}\n\t\n\t\/**\n\t * Internal function to convert an array of raw query row results to an array of populated wfBlock instances. $rows\n\t * is expected to be an array of integer IDs or an array of associative arrays.\n\t * \n\t * @param array[]|int[] $rows\n\t * @return array\n\t *\/\n\tprivate static function _recordsFromRows($rows) {\n\t\t$records = array();\n\t\tforeach ($rows as $r) {\n\t\t\tif ($r instanceof stdClass) {\n\t\t\t\t$r = (array) $r;\n\t\t\t}\n\t\t\t\n\t\t\tif (is_array($r)) {\n\t\t\t\t$b = new wfBlock($r['id']);\n\t\t\t\t$b->_populateData($r);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$b = new wfBlock($r);\n\t\t\t}\n\t\t\t$records[] = $b;\n\t\t}\n\t\treturn $records;\n\t}\n\t\n\t\/**\n\t * Constructs a wfBlock instance. This _does not_ create a new record in the table, only fetches or updates an existing one.\n\t * \n\t * @param $id\n\t * @param bool $type\n\t * @param bool $ip\n\t * @param bool $blockedTime\n\t * @param bool $reason\n\t * @param bool $lastAttempt\n\t * @param bool $blockedHits\n\t * @param bool $expiration\n\t * @param bool $parameters\n\t *\/\n\tpublic function __construct($id, $type = false, $ip = false, $blockedTime = false, $reason = false, $lastAttempt = false, $blockedHits = false, $expiration = false, $parameters = false) {\n\t\t$this->_id = $id;\n\t\t$this->_type = $type;\n\t\t$this->_ip = $ip;\n\t\t$this->_blockedTime = $blockedTime;\n\t\t$this->_reason = $reason;\n\t\t$this->_lastAttempt = $lastAttempt;\n\t\t$this->_blockedHits = $blockedHits;\n\t\t$this->_expiration = $expiration;\n\t\t$this->_parameters = $parameters;\n\t}\n\t\n\tpublic function __get($key) {\n\t\tswitch ($key) {\n\t\t\tcase 'id':\n\t\t\t\treturn $this->_id;\n\t\t\tcase 'type':\n\t\t\t\tif ($this->_type === false) { $this->_fetch(); }\n\t\t\t\treturn $this->_type;\n\t\t\tcase 'IP':\n\t\t\tcase 'ip':\n\t\t\t\tif ($this->_type === false) { $this->_fetch(); }\n\t\t\t\treturn $this->_ip;\n\t\t\tcase 'blockedTime':\n\t\t\t\tif ($this->_type === false) { $this->_fetch(); }\n\t\t\t\treturn $this->_blockedTime;\n\t\t\tcase 'reason':\n\t\t\t\tif ($this->_type === false) { $this->_fetch(); }\n\t\t\t\treturn $this->_reason;\n\t\t\tcase 'lastAttempt':\n\t\t\t\tif ($this->_type === false) { $this->_fetch(); }\n\t\t\t\treturn $this->_lastAttempt;\n\t\t\tcase 'blockedHits':\n\t\t\t\tif ($this->_type === false) { $this->_fetch(); }\n\t\t\t\treturn $this->_blockedHits;\n\t\t\tcase 'expiration':\n\t\t\t\tif ($this->_type === false) { $this->_fetch(); }\n\t\t\t\treturn $this->_expiration;\n\t\t\tcase 'parameters':\n\t\t\t\tif ($this->_type === false) { $this->_fetch(); }\n\t\t\t\treturn $this->_parameters;\n\t\t\t\t\n\t\t\t\/\/Country\n\t\t\tcase 'blockLogin':\n\t\t\t\tif ($this->type != self::TYPE_COUNTRY) { throw new OutOfBoundsException(\"{$key} is not a valid property for this block type\"); }\n\t\t\t\treturn $this->parameters['blockLogin'];\n\t\t\tcase 'blockSite':\n\t\t\t\tif ($this->type != self::TYPE_COUNTRY) { throw new OutOfBoundsException(\"{$key} is not a valid property for this block type\"); }\n\t\t\t\treturn $this->parameters['blockSite'];\n\t\t\tcase 'countries':\n\t\t\t\tif ($this->type != self::TYPE_COUNTRY) { throw new OutOfBoundsException(\"{$key} is not a valid property for this block type\"); }\n\t\t\t\treturn $this->parameters['countries'];\n\t\t\t\t\n\t\t\t\/\/Pattern\n\t\t\tcase 'ipRange':\n\t\t\t\tif ($this->type != self::TYPE_PATTERN) { throw new OutOfBoundsException(\"{$key} is not a valid property for this block type\"); }\n\t\t\t\treturn $this->parameters['ipRange'];\n\t\t\tcase 'hostname':\n\t\t\t\tif ($this->type != self::TYPE_PATTERN) { throw new OutOfBoundsException(\"{$key} is not a valid property for this block type\"); }\n\t\t\t\treturn $this->parameters['hostname'];\n\t\t\tcase 'userAgent':\n\t\t\t\tif ($this->type != self::TYPE_PATTERN) { throw new OutOfBoundsException(\"{$key} is not a valid property for this block type\"); }\n\t\t\t\treturn $this->parameters['userAgent'];\n\t\t\tcase 'referrer':\n\t\t\t\tif ($this->type != self::TYPE_PATTERN) { throw new OutOfBoundsException(\"{$key} is not a valid property for this block type\"); }\n\t\t\t\treturn $this->parameters['referrer'];\n\t\t}\n\t\t\n\t\tthrow new OutOfBoundsException(\"{$key} is not a valid property\");\n\t}\n\t\n\tpublic function __isset($key) {\n\t\tswitch ($key) {\n\t\t\tcase 'id':\n\t\t\tcase 'type':\n\t\t\tcase 'ip':\n\t\t\tcase 'blockedTime':\n\t\t\tcase 'reason':\n\t\t\tcase 'lastAttempt':\n\t\t\tcase 'blockedHits':\n\t\t\tcase 'expiration':\n\t\t\t\treturn true;\n\t\t\tcase 'parameters':\n\t\t\t\tif ($this->_type === false) { $this->_fetch(); }\n\t\t\t\treturn !empty($this->_parameters);\n\t\t\t\n\t\t\t\/\/Country\n\t\t\tcase 'blockLogin':\n\t\t\t\tif ($this->type != self::TYPE_COUNTRY) { return false; }\n\t\t\t\treturn !empty($this->parameters['blockLogin']);\n\t\t\tcase 'blockSite':\n\t\t\t\tif ($this->type != self::TYPE_COUNTRY) { return false; }\n\t\t\t\treturn !empty($this->parameters['blockSite']);\n\t\t\tcase 'countries':\n\t\t\t\tif ($this->type != self::TYPE_COUNTRY) { return false; }\n\t\t\t\treturn !empty($this->parameters['countries']);\n\t\t\t\n\t\t\t\/\/Pattern\n\t\t\tcase 'ipRange':\n\t\t\t\tif ($this->type != self::TYPE_PATTERN) { return false; }\n\t\t\t\treturn !empty($this->parameters['ipRange']);\n\t\t\tcase 'hostname':\n\t\t\t\tif ($this->type != self::TYPE_PATTERN) { return false; }\n\t\t\t\treturn !empty($this->parameters['hostname']);\n\t\t\tcase 'userAgent':\n\t\t\t\tif ($this->type != self::TYPE_PATTERN) { return false; }\n\t\t\t\treturn !empty($this->parameters['userAgent']);\n\t\t\tcase 'referrer':\n\t\t\t\tif ($this->type != self::TYPE_PATTERN) { return false; }\n\t\t\t\treturn !empty($this->parameters['referrer']);\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t\/**\n\t * Fetches the record for the block from the database and populates the instance variables.\n\t *\/\n\tprivate function _fetch() {\n\t\tglobal $wpdb;\n\t\t$blocksTable = wfBlock::blocksTable();\n\t\t$row = $wpdb->get_row($wpdb->prepare(\"SELECT * FROM `{$blocksTable}` WHERE `id` = %d\", $this->id), ARRAY_A);\n\t\tif ($row !== null) {\n\t\t\t$this->_populateData($row);\n\t\t}\n\t}\n\t\n\t\/**\n\t * Populates the instance data from the given $row.\n\t * \n\t * @param array $row\n\t *\/\n\tprivate function _populateData($row) {\n\t\t$this->_type = $row['type'];\n\t\t\n\t\t$ip = $row['IP'];\n\t\tif ($ip == self::MARKER_COUNTRY || $ip == self::MARKER_PATTERN) {\n\t\t\t$this->_ip = null;\n\t\t}\n\t\telse {\n\t\t\t$this->_ip = wfUtils::inet_ntop($ip);\n\t\t}\n\t\t\n\t\t$this->_blockedTime = $row['blockedTime'];\n\t\t$this->_reason = $row['reason'];\n\t\t$this->_lastAttempt = $row['lastAttempt'];\n\t\t$this->_blockedHits = $row['blockedHits'];\n\t\t$this->_expiration = $row['expiration'];\n\t\t\n\t\t$parameters = $row['parameters'];\n\t\tif ($parameters === null) {\n\t\t\t$this->_parameters = null;\n\t\t}\n\t\telse {\n\t\t\t$this->_parameters = @json_decode($parameters, true);\n\t\t\tif (!is_array($this->_parameters)) { $this->_parameters = array(); }\n\t\t}\n\t}\n\t\n\t\/**\n\t * Tests the block parameters against the given request. If matched, this will return the corresponding wfBlock::MATCH_\n\t * constant. If not, it will return wfBlock::MATCH_NONE.\n\t * \n\t * @param $ip\n\t * @param $userAgent\n\t * @param $referrer\n\t * @return int\n\t *\/\n\tpublic function matchRequest($ip, $userAgent, $referrer) {\n\t\tswitch ($this->type) {\n\t\t\tcase self::TYPE_IP_MANUAL:\n\t\t\tcase self::TYPE_IP_AUTOMATIC_TEMPORARY:\n\t\t\tcase self::TYPE_IP_AUTOMATIC_PERMANENT:\n\t\t\tcase self::TYPE_WFSN_TEMPORARY:\n\t\t\tcase self::TYPE_RATE_BLOCK:\n\t\t\tcase self::TYPE_RATE_THROTTLE:\n\t\t\t\tif (wfUtils::inet_pton($ip) == wfUtils::inet_pton($this->ip))\n\t\t\t\t{\n\t\t\t\t\treturn self::MATCH_IP;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase self::TYPE_PATTERN:\n\t\t\t\t$match = (!empty($this->ipRange) || !empty($this->hostname) || !empty($this->userAgent) || !empty($this->referrer));\n\t\t\t\tif (!empty($this->ipRange)) {\n\t\t\t\t\t$range = new wfUserIPRange($this->ipRange);\n\t\t\t\t\t$match = $match && $range->isIPInRange($ip);\n\t\t\t\t}\n\t\t\t\tif (!empty($this->hostname)) {\n\t\t\t\t\t$hostname = wfUtils::reverseLookup($ip);\n\t\t\t\t\t$match = $match && preg_match(wfUtils::patternToRegex($this->hostname), $hostname);\n\t\t\t\t}\n\t\t\t\tif (!empty($this->userAgent)) {\n\t\t\t\t\t$match = $match && fnmatch($this->userAgent, $userAgent, FNM_CASEFOLD);\n\t\t\t\t}\n\t\t\t\tif (!empty($this->referrer)) {\n\t\t\t\t\t$match = $match && fnmatch($this->referrer, $referrer, FNM_CASEFOLD);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ($match) {\n\t\t\t\t\treturn self::MATCH_PATTERN;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\tcase self::TYPE_COUNTRY:\n\t\t\t\tif (!wfConfig::get('isPaid')) {\n\t\t\t\t\treturn self::MATCH_NONE;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\/\/Bypass Redirect URL Hit\n\t\t\t\t$bareRequestURI = wfUtils::extractBareURI($_SERVER['REQUEST_URI']);\n\t\t\t\t$bareBypassRedirURI = wfUtils::extractBareURI(wfConfig::get('cbl_bypassRedirURL', ''));\n\t\t\t\tif ($bareBypassRedirURI && $bareRequestURI == $bareBypassRedirURI) {\n\t\t\t\t\t$bypassRedirDest = wfConfig::get('cbl_bypassRedirDest', '');\n\t\t\t\t\tif ($bypassRedirDest) {\n\t\t\t\t\t\twfUtils::setcookie('wfCBLBypass', wfBlock::countryBlockingBypassCookieValue(), time() + (86400 * 365), '\/', null, wfUtils::isFullSSL(), true);\n\t\t\t\t\t\treturn self::MATCH_COUNTRY_REDIR_BYPASS;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\/\/Bypass View URL Hit\n\t\t\t\t$bareBypassViewURI = wfUtils::extractBareURI(wfConfig::get('cbl_bypassViewURL', ''));\n\t\t\t\tif ($bareBypassViewURI && $bareBypassViewURI == $bareRequestURI) {\n\t\t\t\t\twfUtils::setcookie('wfCBLBypass', wfBlock::countryBlockingBypassCookieValue(), time() + (86400 * 365), '\/', null, wfUtils::isFullSSL(), true);\n\t\t\t\t\treturn self::MATCH_NONE;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\/\/Early exit checks\n\t\t\t\tif ($this->_shouldBypassCountryBlocking()) { \/\/Has valid bypass cookie\n\t\t\t\t\treturn self::MATCH_NONE;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ($this->blockLogin) {\n\t\t\t\t\tadd_filter('authenticate', array($this, '_checkForBlockedCountryFilter'), 1, 1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!$this->blockLogin && $this->_isAuthRequest()) { \/\/Not blocking login and this is a login request\n\t\t\t\t\treturn self::MATCH_NONE;\n\t\t\t\t}\n\t\t\t\telse if (!$this->blockSite && !$this->_isAuthRequest()) { \/\/Not blocking site and this may be a site request\n\t\t\t\t\treturn self::MATCH_NONE;\n\t\t\t\t}\n\t\t\t\telse if (is_user_logged_in() && !wfConfig::get('cbl_loggedInBlocked', false)) { \/\/Not blocking logged in users and a login session exists\n\t\t\t\t\treturn self::MATCH_NONE;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\/\/Block everything\n\t\t\t\tif ($this->blockSite && $this->blockLogin) {\n\t\t\t\t\treturn $this->_checkForBlockedCountry();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\/\/Block the login form itself and any attempt to authenticate\n\t\t\t\tif ($this->blockLogin && $this->_isAuthRequest()) {\n\t\t\t\t\treturn $this->_checkForBlockedCountry();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\/\/Block requests that aren't to the login page, xmlrpc.php, or a user already logged in\n\t\t\t\tif ($this->blockSite && !$this->_isAuthRequest() && !defined('XMLRPC_REQUEST')) {\n\t\t\t\t\treturn $this->_checkForBlockedCountry();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\/\/XMLRPC is inaccesible when public portion of the site and auth is disabled\n\t\t\t\tif ($this->blockLogin && $this->blockSite && defined('XMLRPC_REQUEST')) {\n\t\t\t\t\treturn $this->_checkForBlockedCountry();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn self::MATCH_NONE;\n\t}\n\t\n\t\/**\n\t * Returns whether or not the current request should be treated as an auth request.\n\t * \n\t * @return bool\n\t *\/\n\tprivate function _isAuthRequest() {\n\t\tif ((strpos($_SERVER['REQUEST_URI'], '\/wp-login.php') !== false)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\/**\n\t * Tests whether or not the country blocking bypass cookie is set and valid.\n\t * \n\t * @return bool\n\t *\/\n\tprivate function _shouldBypassCountryBlocking() {\n\t\tif (isset($_COOKIE['wfCBLBypass']) && $_COOKIE['wfCBLBypass'] == wfBlock::countryBlockingBypassCookieValue()) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\/**\n\t * Checks the country block against the requesting IP, returning the action to take.\n\t * \n\t * @return int\n\t *\/\n\tprivate function _checkForBlockedCountry() {\n\t\t$blockedCountries = $this->countries;\n\t\t$bareRequestURI = untrailingslashit(wfUtils::extractBareURI($_SERVER['REQUEST_URI']));\n\t\t$IP = wfUtils::getIP();\n\t\tif ($country = wfUtils::IP2Country($IP)) {\n\t\t\tforeach ($blockedCountries as $blocked) {\n\t\t\t\tif (strtoupper($blocked) == strtoupper($country)) { \/\/At this point we know the user has been blocked\n\t\t\t\t\tif (wfConfig::get('cbl_action') == 'redir') {\n\t\t\t\t\t\t$redirURL = wfConfig::get('cbl_redirURL');\n\t\t\t\t\t\t$eRedirHost = wfUtils::extractHostname($redirURL);\n\t\t\t\t\t\t$isExternalRedir = false;\n\t\t\t\t\t\tif ($eRedirHost && $eRedirHost != wfUtils::extractHostname(home_url())) { \/\/It's an external redirect...\n\t\t\t\t\t\t\t$isExternalRedir = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ((!$isExternalRedir) && untrailingslashit(wfUtils::extractBareURI($redirURL)) == $bareRequestURI) { \/\/Is this the URI we want to redirect to, then don't block it\n\t\t\t\t\t\t\treturn self::MATCH_NONE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn self::MATCH_COUNTRY_REDIR;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn self::MATCH_COUNTRY_BLOCK;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn self::MATCH_NONE;\n\t}\n\t\n\t\/**\n\t * Filter hook for the country blocking check. Does nothing if not blocked, otherwise presents the block page and exits.\n\t * \n\t * Note: Must remain `public` for callback to work.\n\t *\/\n\tpublic function _checkForBlockedCountryFilter($user) {\n\t\t$block = $this->_checkForBlockedCountry();\n\t\tif ($block == self::MATCH_NONE) { \n\t\t\treturn $user;\n\t\t}\n\t\t\n\t\t$log = wfLog::shared();\n\t\t$log->getCurrentRequest()->actionDescription = __('blocked access via country blocking', 'wordfence');\n\t\twfConfig::inc('totalCountryBlocked');\n\t\twfActivityReport::logBlockedIP(wfUtils::getIP(), null, 'country');\n\t\t$log->do503(3600, wfI18n::__('Access from your area has been temporarily limited for security reasons', 'wordfence')); \/\/exits\n\t}\n\t\n\t\/**\n\t * Adds $quantity to the blocked count and sets the timestamp for lastAttempt.\n\t * \n\t * @param int $quantity\n\t * @param bool|int $timestamp\n\t *\/\n\tpublic function recordBlock($quantity = 1, $timestamp = false) {\n\t\tif ($timestamp === false) {\n\t\t\t$timestamp = time();\n\t\t}\n\t\t\n\t\tglobal $wpdb;\n\t\t$blocksTable = wfBlock::blocksTable();\n\t\t$wpdb->query($wpdb->prepare(\"UPDATE `{$blocksTable}` SET `blockedHits` = `blockedHits` + %d, `lastAttempt` = GREATEST(`lastAttempt`, %d) WHERE `id` = %d\", $quantity, $timestamp, $this->id));\n\t\t$this->_type = false; \/\/Trigger a re-fetch next access \n\t}\n\t\n\t\/**\n\t * Returns an array suitable for JSON of the values needed to edit the block.\n\t * \n\t * @return array\n\t *\/\n\tpublic function editValues() {\n\t\tswitch ($this->type) {\n\t\t\tcase self::TYPE_COUNTRY:\n\t\t\t\treturn array(\n\t\t\t\t\t'blockLogin' => wfUtils::truthyToInt($this->blockLogin),\n\t\t\t\t\t'blockSite' => wfUtils::truthyToInt($this->blockSite),\n\t\t\t\t\t'countries' => $this->countries,\n\t\t\t\t\t'reason' => $this->reason,\n\t\t\t\t\t'expiration' => $this->expiration,\n\t\t\t\t);\n\t\t}\n\t\t\n\t\treturn array();\n\t}\n\t\n\t\/**\n\t * Removes this block record. May trigger an additional query to fetch the notification data if $notify is true and\n\t * the record is ID-only.\n\t * \n\t * @param bool $notify If true, will dispatch the `wordfence_deleted_block` action.\n\t * @return null|wfBlock null if a failure occurs, otherwise the block\n\t *\/\n\tpublic function remove($notify = false) {\n\t\t$result = self::removeMultiple(array($this), $notify);\n\t\tif (is_array($result)) {\n\t\t\treturn $result[0];\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t\/**\n\t * Deletes the given block, optionally dispatching the `wordfence_deleted_block` action for each block. May trigger \n\t * an additional query to fetch the notification data if $notify is true and any record is ID-only.\n\t * \n\t * @param wfBlock[] $blocks\n\t * @param bool $notify If true, will dispatch the `wordfence_deleted_block` action.\n\t * @return null|wfBlock[] null if a failure occurs, otherwise the blocks\n\t *\/\n\tpublic static function removeMultiple($blocks, $notify = false) {\n\t\tif (empty($blocks)) { return array(); }\n\t\t\n\t\tglobal $wpdb;\n\t\t$blocksTable = wfBlock::blocksTable();\n\t\t\n\t\t$blockIDs = array_map(function($b) { return intval($b->id); }, $blocks);\n\t\t$inClause = implode(', ', $blockIDs);\n\t\t\n\t\tif ($notify) {\n\t\t\t$blockIDsToPopulate = array_filter(array_map(function($b) { return ($b->_type === false ? intval($b->id) : null); }, $blocks));\n\t\t\tif (!empty($blockIDsToPopulate)) {\n\t\t\t\t$populateInClause = implode(', ', $blockIDsToPopulate);\n\t\t\t\t$data = wfUtils::array_kmap(function($r) { return array($r['id'] => $r); }, $wpdb->get_results(\"SELECT * FROM `{$blocksTable}` WHERE `id` IN ({$populateInClause})\", ARRAY_A));\n\t\t\t\tforeach ($blocks as $b) { \/** @var wfBlock $b *\/\n\t\t\t\t\tif (isset($data[$b->id])) {\n\t\t\t\t\t\t$b->_populateData($data[$b->id]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t$query = \"DELETE FROM `{$blocksTable}` WHERE `id` IN (\" . $inClause . \")\";\n\t\tif ($wpdb->query($query) !== false) {\n\t\t\t$payload = array();\n\t\t\tif ($notify) {\n\t\t\t\tforeach ($blocks as $b) {\n\t\t\t\t\t$type = $b->type;\n\t\t\t\t\t$reason = $b->reason;\n\t\t\t\t\t$parameters = (($type != self::TYPE_COUNTRY && $type != self::TYPE_PATTERN) ? $b->ip : $b->parameters);\n\t\t\t\t\t\n\t\t\t\t\t\/**\n\t\t\t\t\t * Fires when a blocking rule is deleted by manual action.\n\t\t\t\t\t *\n\t\t\t\t\t * @since 8.0.0\n\t\t\t\t\t *\n\t\t\t\t\t * @param string $type The type of block.\n\t\t\t\t\t * @param string $reason The reason of the block.\n\t\t\t\t\t * @param array|null $parameters The parameters of the block if needed for disambiguation (e.g., the country block returns null because there is only one rule at most)\n\t\t\t\t\t *\/\n\t\t\t\t\tdo_action('wordfence_deleted_block', $type, $reason, $parameters);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn $blocks;\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n}"},{"base":"plugins","rel":"wordfence\/models\/firewall\/wfFirewall.php","ext":"php","size":16494,"mtime":1757312769,"type":"text","content":"<?php\n\nclass wfFirewall\n{\n\tconst FIREWALL_MODE_DISABLED = 'disabled';\n\tconst FIREWALL_MODE_LEARNING = 'learning-mode';\n\tconst FIREWALL_MODE_ENABLED = 'enabled';\n\t\n\tconst PROTECTION_MODE_EXTENDED = 'extended';\n\tconst PROTECTION_MODE_BASIC = 'basic';\n\t\n\tconst RULE_MODE_COMMUNITY = 'community';\n\tconst RULE_MODE_PREMIUM = 'premium';\n\t\n\tconst BLACKLIST_MODE_DISABLED = 'disabled';\n\tconst BLACKLIST_MODE_ENABLED = 'enabled';\n\t\n\tconst UPDATE_FAILURE_RATELIMIT = 'ratelimit';\n\tconst UPDATE_FAILURE_UNREACHABLE = 'unreachable';\n\tconst UPDATE_FAILURE_FILESYSTEM = 'filesystem';\n\t\n\t\/**\n\t * Returns a string suitable for display of the firewall status.\n\t * \n\t * @param null|string $status\n\t * @param null|string $protection\n\t * @return string\n\t *\/\n\tpublic function displayText($status = null, $protection = null) {\n\t\tif ($status === null) { $status = $this->firewallMode(); }\n\t\tif ($protection === null) { $protection = $this->protectionMode(); }\n\t\t\n\t\tswitch ($status) {\n\t\t\tcase self::FIREWALL_MODE_ENABLED:\n\t\t\t\t$statusText = __('Enabled', 'wordfence');\n\t\t\t\tbreak;\n\t\t\tcase self::FIREWALL_MODE_LEARNING:\n\t\t\t\t$statusText = __('Learning Mode', 'wordfence');\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn __('Disabled', 'wordfence');\n\t\t}\n\t\t\n\t\tswitch ($protection) {\n\t\t\tcase self::PROTECTION_MODE_EXTENDED:\n\t\t\t\t$protectionText = __('Extended Protection', 'wordfence');\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t$protectionText = __('Basic Protection', 'wordfence');\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn sprintf('%s (%s)', $statusText, $protectionText);\n\t}\n\t\n\t\/**\n\t * Syncs the status from WAF to the wfConfig table if $toDatabase is true, the reverse if false.\n\t * \n\t * @param bool $toDatabase\n\t *\/\n\tpublic function syncStatus($toDatabase = true) {\n\t\tif ($toDatabase) {\n\t\t\ttry {\n\t\t\t\t$status = wfWAF::getInstance()->getStorageEngine()->getConfig('wafStatus');\n\t\t\t\tif (in_array($status, array(self::FIREWALL_MODE_DISABLED, self::FIREWALL_MODE_LEARNING, self::FIREWALL_MODE_ENABLED))) {\n\t\t\t\t\twfConfig::set('waf_status', $status);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception $e) {\n\t\t\t\t\/\/Ignore\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\t$status = wfConfig::get('waf_status');\n\t\t\t\tif (in_array($status, array(self::FIREWALL_MODE_DISABLED, self::FIREWALL_MODE_LEARNING, self::FIREWALL_MODE_ENABLED))) {\n\t\t\t\t\twfWAF::getInstance()->getStorageEngine()->setConfig('wafStatus', $status);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception $e) {\n\t\t\t\t\/\/Ignore\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\/**\n\t * Tests the WAF configuration and returns true if successful.\n\t * \n\t * @return bool\n\t *\/\n\tpublic function testConfig() {\n\t\ttry {\n\t\t\twfWAF::getInstance()->getStorageEngine()->isDisabled();\n\t\t}\n\t\tcatch (Exception $e) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\t\/**\n\t * Returns a normalized percentage (i.e., in the range [0, 1]) to the corresponding display percentage\n\t * based on license type.\n\t * \n\t * @param float $percentage\n\t * @param bool $adjust Whether or not to adjust the range to [0, 0.7]\n\t * @return float\n\t *\/\n\tprotected function _normalizedPercentageToDisplay($percentage, $adjust = true) {\n\t\tif (wfConfig::get('isPaid') || !$adjust) {\n\t\t\treturn round($percentage, 2);\n\t\t}\n\t\t\n\t\treturn round($percentage * 0.70, 2);\n\t}\n\t\n\t\/**\n\t * Returns the percentage calculation of the overall firewall status, which is displayed under \"Firewall\" \n\t * on the Dashboard page.\n\t *\n\t * @return float\n\t *\/\n\tpublic function overallStatus() {\n\t\ttry {\n\t\t\t$wafStatus = $this->wafStatus();\n\t\t\t$bruteForceStatus = $this->bruteForceStatus();\n\t\t\t\n\t\t\t$percentage = 0.0;\n\t\t\t$percentage += $wafStatus * 0.80;\n\t\t\t$percentage += $bruteForceStatus * 0.20;\n\t\t\treturn $this->_normalizedPercentageToDisplay($percentage, false);\n\t\t}\n\t\tcatch (Exception $e) {\n\t\t\t\/\/Ignore, return 0%\n\t\t}\n\t\t\n\t\treturn 0.0;\n\t}\n\t\n\tpublic function statusList($section = null) {\n\t\t$statusList = array();\n\t\t$wafStatusList = $this->wafStatusList($section);\n\t\t$bruteForceStatusList = $this->bruteForceStatusList();\n\t\t\n\t\tforeach ($wafStatusList as $entry) {\n\t\t\t$entry['percentage'] *= 0.8;\n\t\t\t$statusList[] = $entry;\n\t\t}\n\t\t\n\t\tforeach ($bruteForceStatusList as $entry) {\n\t\t\t$entry['percentage'] *= 0.2;\n\t\t\t$statusList[] = $entry;\n\t\t}\n\t\t\t\n\t\treturn array_filter($statusList);\n\t}\n\t\n\t\/**\n\t * Returns the percentage calculation of the WAF status, which is displayed under \"Web Application\n\t * Firewall\" on the Firewall page.\n\t * \n\t * @return float\n\t *\/\n\tpublic function wafStatus() {\n\t\ttry {\n\t\t\t$ruleStatus = $this->ruleStatus(true);\n\t\t\t$blacklistStatus = $this->blacklistStatus();\n\t\t\t$wafEnabled = !(!WFWAF_ENABLED || wfWAF::getInstance()->getStorageEngine()->isDisabled());\n\t\t\t$extendedProtection = $wafEnabled && WFWAF_AUTO_PREPEND && !WFWAF_SUBDIRECTORY_INSTALL;\n\t\t\t$rateLimitingAdvancedBlockingEnabled = wfConfig::get('firewallEnabled', 1);\n\n\t\t\tif (!$wafEnabled) {\n\t\t\t\treturn 0.0;\n\t\t\t}\n\t\t\t\n\t\t\t$percentage = 0.0;\n\t\t\t$percentage += $this->_normalizedPercentageToDisplay($ruleStatus * 0.35, true);\n\t\t\t$percentage += $blacklistStatus * 0.35;\n\t\t\t$percentage += ($extendedProtection ? 0.20 : 0.0);\n\t\t\t$percentage += ($rateLimitingAdvancedBlockingEnabled ? 0.10 : 0.0);\n\t\t\treturn $this->_normalizedPercentageToDisplay($percentage, false);\n\t\t}\n\t\tcatch (Exception $e) {\n\t\t\t\/\/Ignore, return 0%\n\t\t}\n\t\t\n\t\treturn 0.0;\n\t}\n\n\tpublic function wafStatusList($section = null) {\n\t\t$statusList = array();\n\t\ttry {\n\t\t\t$wafEnabled = !(!WFWAF_ENABLED || wfWAF::getInstance()->getStorageEngine()->isDisabled());\n\t\t\tif (!$wafEnabled) {\n\t\t\t\treturn array(\n\t\t\t\t\tarray(\n\t\t\t\t\t\t'percentage' => 1.0,\n\t\t\t\t\t\t'title'      => __('Enable firewall.', 'wordfence'),\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t\/\/ Get percent of rules enabled.\n\t\t\t$ruleStatus = $this->ruleStatusDescription(true);\n\t\t\t$premiumStatus = array();\n\t\t\tif (!wfConfig::get('isPaid')) {\n\t\t\t\t$premiumStatus = array(\n\t\t\t\t\t'percentage' => 0.30,\n\t\t\t\t\t'title'      => __('Enable Premium Rules.', 'wordfence'),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif ($section === 'rules') {\n\t\t\t\tif ($ruleStatus) {\n\t\t\t\t\t$ruleStatus['percentage'] = $this->_normalizedPercentageToDisplay($ruleStatus['percentage']);\n\t\t\t\t}\n\t\t\t\treturn array_filter(array($ruleStatus, $premiumStatus));\n\t\t\t}\n\t\t\tif ($premiumStatus) {\n\t\t\t\t$premiumStatus['percentage'] *= 0.35;\n\t\t\t\t$premiumStatus['percentage'] = $this->_normalizedPercentageToDisplay($premiumStatus['percentage'], false);\n\t\t\t}\n\t\t\tif ($ruleStatus) {\n\t\t\t\t$ruleStatus['percentage'] *= 0.35;\n\t\t\t\t$ruleStatus['percentage'] = $this->_normalizedPercentageToDisplay($ruleStatus['percentage']);\n\t\t\t}\n\t\t\t$statusList = array_merge($statusList, array($ruleStatus), array($premiumStatus));\n\n\t\t\t$blacklistStatus = $this->blacklistStatusDescription();\n\t\t\tif ($section === 'blacklist') {\n\t\t\t\treturn array_filter(array($blacklistStatus));\n\t\t\t}\n\t\t\tif ($blacklistStatus) {\n\t\t\t\t$blacklistStatus['percentage'] *= 0.35;\n\t\t\t\t$blacklistStatus['percentage'] = $this->_normalizedPercentageToDisplay($blacklistStatus['percentage'], false);\n\t\t\t}\n\t\t\t$statusList = array_merge($statusList, array($blacklistStatus));\n\n\t\t\t$extendedProtection = $wafEnabled && WFWAF_AUTO_PREPEND && !WFWAF_SUBDIRECTORY_INSTALL;\n\t\t\tif (!$extendedProtection) {\n\t\t\t\t$statusList[] = array(\n\t\t\t\t\t'percentage' => $this->_normalizedPercentageToDisplay(0.20, false),\n\t\t\t\t\t'title' => __('Optimize the Wordfence Firewall.', 'wordfence'),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t$rateLimitingAdvancedBlockingEnabled = wfConfig::get('firewallEnabled', 1);\n\t\t\tif (!$rateLimitingAdvancedBlockingEnabled) {\n\t\t\t\t$statusList[] = array(\n\t\t\t\t\t'percentage' => $this->_normalizedPercentageToDisplay(0.10, false),\n\t\t\t\t\t'title' => __('Enable Rate Limiting and Advanced Blocking.', 'wordfence'),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn array_filter($statusList);\n\t\t}\n\t\tcatch (Exception $e) {\n\t\t\t\/\/Ignore, return 0%\n\t\t}\n\t\t\n\t\tif (!WFWAF_OPERATIONAL) {\n\t\t\treturn array(array('percentage' => 1.0, 'title' => __('Repair the Wordfence Firewall configuration.', 'wordfence')));\n\t\t}\n\n\t\treturn array();\n\t}\n\t\n\t\/**\n\t * Returns the status of the WAF.\n\t * \n\t * @return string\n\t *\/\n\tpublic function firewallMode() {\n\t\ttry {\n\t\t\treturn (!WFWAF_ENABLED ? 'disabled' : wfWAF::getInstance()->getStorageEngine()->getConfig('wafStatus'));\n\t\t}\n\t\tcatch (Exception $e) {\n\t\t\t\/\/Ignore\n\t\t}\n\t\t\n\t\treturn self::FIREWALL_MODE_DISABLED;\n\t}\n\t\n\t\/**\n\t * Returns the current protection mode configured for the WAF.\n\t * \n\t * @return string\n\t *\/\n\tpublic function protectionMode() {\n\t\tif (defined('WFWAF_AUTO_PREPEND') && WFWAF_AUTO_PREPEND) {\n\t\t\treturn self::PROTECTION_MODE_EXTENDED;\n\t\t}\n\t\treturn self::PROTECTION_MODE_BASIC;\n\t}\n\t\n\t\/**\n\t * Returns whether or not this installation is in a subdirectory of another WordPress site with the WAF already optimized.\n\t * \n\t * @return bool\n\t *\/\n\tpublic function isSubDirectoryInstallation() {\n\t\tif (defined('WFWAF_SUBDIRECTORY_INSTALL') && WFWAF_SUBDIRECTORY_INSTALL) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\/**\n\t * Returns the percentage calculation of the firewall rule status, which is displayed under \"Firewall Rules\" on the\n\t * Firewall page.\n\t * \n\t * The calculation is the number of rules enabled divided by the total number of rules. If the WAF is in learning \n\t * mode, no rules are enforced, so it's clamped to 0%.\n\t * \n\t * @param bool $round Round the percentage (in the range [0, 1]) to be only whole percentages.\n\t * @return float\n\t *\/\n\tpublic function ruleStatus($round = false) {\n\t\ttry {\n\t\t\t$wafEnabled = !(!WFWAF_ENABLED || wfWAF::getInstance()->getStorageEngine()->isDisabled());\n\t\t\tif (!$wafEnabled) {\n\t\t\t\treturn 0.0;\n\t\t\t}\n\t\t\t\n\t\t\t\/*$learningMode = !!wfWAF::getInstance()->isInLearningMode();\n\t\t\tif ($learningMode) {\n\t\t\t\treturn 0.0;\n\t\t\t}*\/\n\t\t\t\n\t\t\t$rules = wfWAF::getInstance()->getRules();\n\t\t\t$disabledRules = (array) wfWAF::getInstance()->getStorageEngine()->getConfig('disabledRules');\n\t\t\t\/** @var wfWAFRule $rule *\/\n\t\t\t$enabledCount = 0;\n\t\t\tforeach ($rules as $ruleID => $rule) {\n\t\t\t\tif (isset($disabledRules[$ruleID]) && $disabledRules[$ruleID]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t$enabledCount++;\n\t\t\t}\n\t\t\t\n\t\t\t$percentEnabled = (count($rules) == 0 ? 0 : $enabledCount \/ count($rules));\n\t\t\tif ($round) {\n\t\t\t\treturn round($percentEnabled, 2);\n\t\t\t}\n\t\t\t\n\t\t\treturn $this->_normalizedPercentageToDisplay($percentEnabled);\n\t\t}\n\t\tcatch (Exception $e) {\n\t\t\t\/\/Ignore, return 0%\n\t\t}\n\t\t\n\t\treturn 0.0;\n\t}\n\n\t\/**\n\t * @param bool $round\n\t * @return array\n\t *\/\n\tpublic function ruleStatusDescription($round = false) {\n\t\ttry {\n\t\t\t$wafEnabled = !(!WFWAF_ENABLED || wfWAF::getInstance()->getStorageEngine()->isDisabled());\n\t\t\tif (!$wafEnabled) {\n\t\t\t\treturn array(\n\t\t\t\t\t'percentage' => 1.0,\n\t\t\t\t\t'title'      => __('Enable firewall.', 'wordfence'),\n\t\t\t\t);\n\t\t\t}\n\t\t\t\n\t\t\t\/*$learningMode = !!wfWAF::getInstance()->isInLearningMode();\n\t\t\tif ($learningMode) {\n\t\t\t\treturn 0.0;\n\t\t\t}*\/\n\n\t\t\t$rules = wfWAF::getInstance()->getRules();\n\t\t\t$disabledRules = (array) wfWAF::getInstance()->getStorageEngine()->getConfig('disabledRules');\n\t\t\t\/** @var wfWAFRule $rule *\/\n\t\t\t$enabledCount = 0;\n\t\t\tforeach ($rules as $ruleID => $rule) {\n\t\t\t\tif (isset($disabledRules[$ruleID]) && $disabledRules[$ruleID]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t$enabledCount++;\n\t\t\t}\n\t\t\t\n\t\t\t$percentEnabled = 1.0 - ((float) (count($rules) == 0 ? 0 : $enabledCount \/ count($rules)));\n\t\t\tif ($percentEnabled === 0.0) {\n\t\t\t\treturn array();\n\t\t\t}\n\t\t\t$reenbleCount = count($rules) - $enabledCount;\n\t\t\treturn array(\n\t\t\t\t'percentage' => ($round ? round($percentEnabled, 2) : $percentEnabled),\n\t\t\t\t'title'      => sprintf(_n('Re-enable %d firewall rule.', 'Re-enable %d firewall rules.', $reenbleCount, 'wordfence'), number_format_i18n($reenbleCount)),\n\t\t\t);\n\t\t}\n\t\tcatch (Exception $e) {\n\t\t\t\/\/Ignore, return 0%\n\t\t}\n\n\t\treturn array(\n\t\t\t'percentage' => 1.0,\n\t\t\t'title'      => __('Enable firewall.', 'wordfence'),\n\t\t);\n\t}\n\t\n\t\/**\n\t * Returns the rule feed that is in use.\n\t * \n\t * @return string\n\t *\/\n\tpublic function ruleMode() {\n\t\tif (wfConfig::get('isPaid')) {\n\t\t\treturn self::RULE_MODE_PREMIUM;\n\t\t}\n\t\treturn self::RULE_MODE_COMMUNITY;\n\t}\n\t\n\t\/**\n\t * Returns 100% if the blacklist is enabled, 0% if not.\n\t * \n\t * @return float\n\t *\/\n\tpublic function blacklistStatus() {\n\t\ttry {\n\t\t\t$wafEnabled = !(!WFWAF_ENABLED || wfWAF::getInstance()->getStorageEngine()->isDisabled());\n\t\t\tif (!$wafEnabled) {\n\t\t\t\treturn 0.0;\n\t\t\t}\n\t\t\t\n\t\t\treturn $this->blacklistMode() == self::BLACKLIST_MODE_ENABLED ? 1.0 : 0.0;\n\t\t}\n\t\tcatch (Exception $e) {\n\t\t\t\/\/Ignore, return 0%\n\t\t}\n\t\t\n\t\treturn 0.0;\n\t}\n\t\n\t\/**\n\t * Returns 100% if the blacklist is enabled, 0% if not.\n\t *\n\t * @return array\n\t *\/\n\tpublic function blacklistStatusDescription() {\n\t\ttry {\n\t\t\t$wafEnabled = !(!WFWAF_ENABLED || wfWAF::getInstance()->getStorageEngine()->isDisabled());\n\t\t\tif (!$wafEnabled) {\n\t\t\t\treturn array(\n\t\t\t\t\t'percentage' => 1.0,\n\t\t\t\t\t'title'      => __('Enable Firewall.', 'wordfence'),\n\t\t\t\t);\n\t\t\t}\n\t\t\t\n\t\t\tif ($this->blacklistMode() == self::BLACKLIST_MODE_ENABLED) {\n\t\t\t\treturn array();\n\t\t\t}\n\t\t\treturn array(\n\t\t\t\t'percentage' => 1.0,\n\t\t\t\t'title'      => __('Enable Real-Time IP Blocklist.', 'wordfence'),\n\t\t\t);\n\t\t}\n\t\tcatch (Exception $e) {\n\t\t\t\/\/Ignore, return 0%\n\t\t}\n\t\t\t\n\t\treturn array(\n\t\t\t'percentage' => 1.0,\n\t\t\t'title'      => __('Enable Real-Time IP Blocklist.', 'wordfence'),\n\t\t);\n\t}\n\n\t\/**\n\t * Returns the blacklist mode.\n\t *\n\t * @return string\n\t *\/\n\tpublic function blacklistMode() {\n\t\t$blacklistEnabled = false;\n\t\ttry {\n\t\t\t$wafEnabled = !(!WFWAF_ENABLED || wfWAF::getInstance()->getStorageEngine()->isDisabled());\n\t\t\t$blacklistEnabled = $wafEnabled && !wfWAF::getInstance()->getStorageEngine()->getConfig('disableWAFBlacklistBlocking');\n\t\t}\n\t\tcatch (Exception $e) {\n\t\t\t\/\/Do nothing\n\t\t}\n\t\t\n\t\tif (wfConfig::get('isPaid') && $blacklistEnabled) {\n\t\t\treturn self::BLACKLIST_MODE_ENABLED;\n\t\t}\n\t\treturn self::BLACKLIST_MODE_DISABLED;\n\t}\n\t\n\t\/**\n\t * Returns a percentage rating for the brute force protection status. This includes both the WFSN enabled status\n\t * and the status of individual login security options. These options are available to all, so they are always\n\t * in the range [0,1].\n\t * \n\t * @return float\n\t *\/\n\tpublic function bruteForceStatus() {\n\t\t$networkBruteForceEnabled = !!wfConfig::get('other_WFNet');\n\t\t$localBruteForceEnabled = !!wfConfig::get('loginSecurityEnabled');\n\t\t\n\t\t$percentage = 0.0;\n\n\t\tif ($localBruteForceEnabled) {\n\t\t\t$percentage += 0.1;\n\n\t\t\tif ($networkBruteForceEnabled) {\n\t\t\t\t$percentage += 0.5;\n\t\t\t}\n\t\t\tif (wfConfig::get('loginSec_strongPasswds_enabled') && (wfConfig::get('loginSec_strongPasswds') == 'pubs' || wfConfig::get('loginSec_strongPasswds') == 'all')) {\n\t\t\t\t$percentage += 0.1;\n\t\t\t}\n\t\t\tif (wfConfig::get('loginSec_maskLoginErrors')) {\n\t\t\t\t$percentage += 0.1;\n\t\t\t}\n\t\t\tif (wfConfig::get('loginSec_blockAdminReg')) {\n\t\t\t\t$percentage += 0.1;\n\t\t\t}\n\t\t\tif (wfConfig::get('loginSec_disableAuthorScan')) {\n\t\t\t\t$percentage += 0.1;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn round($percentage, 2);\n\t}\n\t\n\t\/**\n\t * Returns the status of the WAF's learning mode.\n\t * \n\t * @return bool|int Returns true if enabled without an automatic switchover, a timestamp if enabled with one, and false if not in learning mode.\n\t *\/\n\tpublic function learningModeStatus() {\n\t\tif ($this->firewallMode() != self::FIREWALL_MODE_LEARNING) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\ttry {\n\t\t\t$config = wfWAF::getInstance()->getStorageEngine();\n\t\t\tif ($config->getConfig('learningModeGracePeriodEnabled')) {\n\t\t\t\treturn (int) $config->getConfig('learningModeGracePeriod');\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\tcatch (Exception $e) {\n\t\t\t\/\/Ignore, return false\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\n\t\/**\n\t * @return array\n\t *\/\n\tpublic function bruteForceStatusList() {\n\t\t$networkBruteForceEnabled = !!wfConfig::get('other_WFNet');\n\t\t$localBruteForceEnabled = !!wfConfig::get('loginSecurityEnabled');\n\n\t\t$status = array();\n\n\t\tif ($localBruteForceEnabled) {\n\t\t\tif (!$networkBruteForceEnabled) {\n\t\t\t\t$status[] = array(\n\t\t\t\t\t'percentage' => 0.5,\n\t\t\t\t\t'title' => __('Enable Real-Time Wordfence Security Network.', 'wordfence'),\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (!wfConfig::get('loginSec_strongPasswds_enabled')) {\n\t\t\t\t$status[] = array(\n\t\t\t\t\t'percentage' => 0.1,\n\t\t\t\t\t'title' => __('Enforce Strong Passwords.', 'wordfence'),\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (!wfConfig::get('loginSec_maskLoginErrors')) {\n\t\t\t\t$status[] = array(\n\t\t\t\t\t'percentage' => 0.1,\n\t\t\t\t\t'title' => __('Enable Mask Login Errors.', 'wordfence'),\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (!wfConfig::get('loginSec_blockAdminReg')) {\n\t\t\t\t$status[] = array(\n\t\t\t\t\t'percentage' => 0.1,\n\t\t\t\t\t'title' => __('Enable Block Admin Registration.', 'wordfence'),\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (!wfConfig::get('loginSec_disableAuthorScan')) {\n\t\t\t\t$status[] = array(\n\t\t\t\t\t'percentage' => 0.1,\n\t\t\t\t\t'title' => __('Disable Author Scanning.', 'wordfence'),\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\t$status[] = array(\n\t\t\t\t'percentage' => 1.0,\n\t\t\t\t'title' => __('Enable Brute Force Protection.', 'wordfence'),\n\t\t\t);\n\t\t}\n\n\t\treturn array_filter($status);\n\t}\n}\n"},{"base":"plugins","rel":"wordfence\/models\/scanner\/wfScanner.php","ext":"php","size":44084,"mtime":1757312769,"type":"text","content":"<?php\n\nclass wfScanner {\n\tconst SCAN_TYPE_QUICK = 'quick';\n\tconst SCAN_TYPE_LIMITED = 'limited';\n\tconst SCAN_TYPE_STANDARD = 'standard';\n\tconst SCAN_TYPE_HIGH_SENSITIVITY = 'highsensitivity';\n\tconst SCAN_TYPE_CUSTOM = 'custom';\n\t\n\tconst SCAN_SCHEDULING_MODE_AUTOMATIC = 'auto';\n\tconst SCAN_SCHEDULING_MODE_MANUAL = 'manual';\n\t\n\tconst MANUAL_SCHEDULING_ONCE_DAILY = 'onceDaily';\n\tconst MANUAL_SCHEDULING_TWICE_DAILY = 'twiceDaily';\n\tconst MANUAL_SCHEDULING_EVERY_OTHER_DAY = 'everyOtherDay';\n\tconst MANUAL_SCHEDULING_WEEKDAYS = 'weekdays';\n\tconst MANUAL_SCHEDULING_WEEKENDS = 'weekends';\n\tconst MANUAL_SCHEDULING_ODD_DAYS_WEEKENDS = 'oddDaysWE';\n\tconst MANUAL_SCHEDULING_CUSTOM = 'custom';\n\t\n\tconst SIGNATURE_MODE_PREMIUM = 'premium';\n\tconst SIGNATURE_MODE_COMMUNITY = 'community';\n\t\n\tconst STATUS_PENDING = 'pending';\n\tconst STATUS_RUNNING = 'running';\n\tconst STATUS_RUNNING_WARNING = 'running-warning';\n\tconst STATUS_COMPLETE_SUCCESS = 'complete-success';\n\tconst STATUS_COMPLETE_WARNING = 'complete-warning';\n\tconst STATUS_PREMIUM = 'premium';\n\tconst STATUS_DISABLED = 'disabled';\n\n\tconst STAGE_SPAMVERTISING_CHECKS = 'spamvertising';\n\tconst STAGE_SPAM_CHECK = 'spam';\n\tconst STAGE_BLACKLIST_CHECK = 'blacklist';\n\tconst STAGE_SERVER_STATE = 'server';\n\tconst STAGE_FILE_CHANGES = 'changes';\n\tconst STAGE_PUBLIC_FILES = 'public';\n\tconst STAGE_MALWARE_SCAN = 'malware';\n\tconst STAGE_CONTENT_SAFETY = 'content';\n\tconst STAGE_PASSWORD_STRENGTH = 'password';\n\tconst STAGE_VULNERABILITY_SCAN = 'vulnerability';\n\tconst STAGE_OPTIONS_AUDIT = 'options';\n\t\n\tconst SUMMARY_TOTAL_USERS = 'totalUsers';\n\tconst SUMMARY_TOTAL_PAGES = 'totalPages';\n\tconst SUMMARY_TOTAL_POSTS = 'totalPosts';\n\tconst SUMMARY_TOTAL_COMMENTS = 'totalComments';\n\tconst SUMMARY_TOTAL_CATEGORIES = 'totalCategories';\n\tconst SUMMARY_TOTAL_TABLES = 'totalTables';\n\tconst SUMMARY_TOTAL_ROWS = 'totalRows';\n\tconst SUMMARY_SCANNED_POSTS = 'scannedPosts';\n\tconst SUMMARY_SCANNED_COMMENTS = 'scannedComments';\n\tconst SUMMARY_SCANNED_FILES = 'scannedFiles';\n\tconst SUMMARY_SCANNED_PLUGINS = 'scannedPlugins';\n\tconst SUMMARY_SCANNED_THEMES = 'scannedThemes';\n\tconst SUMMARY_SCANNED_USERS = 'scannedUsers';\n\tconst SUMMARY_SCANNED_URLS = 'scannedURLs';\n\t\n\tconst CENTRAL_STAGE_UPDATE_THRESHOLD = 5;\n\t\n\tprivate $_scanType = false;\n\t\n\tprivate $_summary = false;\n\tprivate $_destructRegistered = false;\n\tprivate $_dirty = false;\n\t\n\t\/**\n\t * Returns the singleton wfScanner with the user-configured scan type set.\n\t * \n\t * @return wfScanner\n\t *\/\n\tpublic static function shared() {\n\t\tstatic $_scanner = null;\n\t\tif ($_scanner === null) {\n\t\t\t$_scanner = new wfScanner();\n\t\t}\n\t\treturn $_scanner;\n\t}\n\t\n\t\/**\n\t * Schedules a cron rescheduling to happen at the end of the current process's execution.\n\t *\/\n\tpublic static function setNeedsRescheduling() {\n\t\tstatic $willReschedule = false;\n\t\tif (!$willReschedule) {\n\t\t\t$willReschedule = true;\n\t\t\tregister_shutdown_function(array(self::shared(), 'scheduleScans'));\n\t\t}\n\t}\n\t\n\t\/**\n\t * Returns whether or not the scan type passed is valid.\n\t * \n\t * @param $type\n\t * @return bool\n\t *\/\n\tpublic static function isValidScanType($type) {\n\t\tswitch ($type) {\n\t\t\tcase self::SCAN_TYPE_QUICK:\n\t\t\tcase self::SCAN_TYPE_LIMITED:\n\t\t\tcase self::SCAN_TYPE_HIGH_SENSITIVITY:\n\t\t\tcase self::SCAN_TYPE_CUSTOM:\n\t\t\tcase self::SCAN_TYPE_STANDARD:\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\/**\n\t * Returns the display string for the given type.\n\t * \n\t * @param string $type\n\t * @return string\n\t *\/\n\tpublic static function displayScanType($type) {\n\t\tswitch ($type) {\n\t\t\tcase self::SCAN_TYPE_QUICK:\n\t\t\t\treturn __('Quick', 'wordfence');\n\t\t\tcase self::SCAN_TYPE_LIMITED:\n\t\t\t\treturn __('Limited', 'wordfence');\n\t\t\tcase self::SCAN_TYPE_HIGH_SENSITIVITY:\n\t\t\t\treturn __('High Sensitivity', 'wordfence');\n\t\t\tcase self::SCAN_TYPE_CUSTOM:\n\t\t\t\treturn __('Custom', 'wordfence');\n\t\t\tcase self::SCAN_TYPE_STANDARD:\n\t\t\tdefault:\n\t\t\t\treturn __('Standard', 'wordfence');\n\t\t}\n\t}\n\t\n\t\/**\n\t * Returns the display detail string for the given type.\n\t *\n\t * @param string $type\n\t * @return string\n\t *\/\n\tpublic static function displayScanTypeDetail($type) {\n\t\tswitch ($type) {\n\t\t\tcase self::SCAN_TYPE_QUICK:\n\t\t\tcase self::SCAN_TYPE_LIMITED:\n\t\t\t\treturn __('Low resource utilization, limited detection capability', 'wordfence');\n\t\t\tcase self::SCAN_TYPE_HIGH_SENSITIVITY:\n\t\t\t\treturn __('Standard detection capability, chance of false positives', 'wordfence');\n\t\t\tcase self::SCAN_TYPE_CUSTOM:\n\t\t\t\treturn __('Custom scan options selected', 'wordfence');\n\t\t\tcase self::SCAN_TYPE_STANDARD:\n\t\t\tdefault:\n\t\t\t\treturn __('Standard detection capability', 'wordfence');\n\t\t}\n\t}\n\t\n\t\/**\n\t * Returns an array of the scan options (as keys) and the corresponding value for the quick scan type. All omitted\n\t * scan stages are considered disabled.\n\t *\n\t * @return array\n\t *\/\n\tpublic static function quickScanTypeOptions() {\n\t\t$oldVersions = true;\n\t\t$wafStatus = true;\n\t\tif (wfConfig::get('scanType') == self::SCAN_TYPE_CUSTOM) { \/\/Obey the setting in custom if that's the true scan type\n\t\t\t$oldVersions = wfConfig::get('scansEnabled_oldVersions');\n\t\t\t$wafStatus = wfConfig::get('scansEnabled_wafStatus');\n\t\t}\n\t\t\n\t\treturn array_merge(self::_inactiveScanOptions(), array(\n\t\t\t'scansEnabled_oldVersions' => $oldVersions,\n\t\t\t'scansEnabled_wafStatus' => $wafStatus,\n\t\t));\n\t}\n\t\n\t\/**\n\t * Returns an array of the scan options (as keys) and the corresponding value for the limited scan type.\n\t * \n\t * @return array\n\t *\/\n\tpublic static function limitedScanTypeOptions() {\n\t\treturn array_merge(self::_inactiveScanOptions(), array(\n\t\t\t'scansEnabled_checkHowGetIPs' => true,\n\t\t\t'scansEnabled_malware' => true,\n\t\t\t'scansEnabled_fileContents' => true,\n\t\t\t'scansEnabled_fileContentsGSB' => true,\n\t\t\t'scansEnabled_suspiciousOptions' => true,\n\t\t\t'scansEnabled_oldVersions' => true,\n\t\t\t'scansEnabled_wafStatus' => true,\n\t\t\t'lowResourceScansEnabled' => true,\n\t\t\t'scan_exclude' => wfConfig::get('scan_exclude', ''),\n\t\t\t'scan_include_extra' => wfConfig::get('scan_include_extra', ''),\n\t\t\t'scansEnabled_geoipSupport' => true,\n\t\t));\n\t}\n\t\n\t\/**\n\t * Returns an array of the scan options (as keys) and the corresponding value for the standard scan type.\n\t *\n\t * @return array\n\t *\/\n\tpublic static function standardScanTypeOptions() {\n\t\treturn array_merge(self::_inactiveScanOptions(), array(\n\t\t\t'spamvertizeCheck' => true,\n\t\t\t'checkSpamIP' => true,\n\t\t\t'scansEnabled_checkGSB' => true,\n\t\t\t'scansEnabled_checkHowGetIPs' => true,\n\t\t\t'scansEnabled_checkReadableConfig' => true,\n\t\t\t'scansEnabled_suspectedFiles' => true,\n\t\t\t'scansEnabled_core' => true,\n\t\t\t'scansEnabled_coreUnknown' => true,\n\t\t\t'scansEnabled_malware' => true,\n\t\t\t'scansEnabled_fileContents' => true,\n\t\t\t'scansEnabled_fileContentsGSB' => true,\n\t\t\t'scansEnabled_posts' => true,\n\t\t\t'scansEnabled_comments' => true,\n\t\t\t'scansEnabled_suspiciousOptions' => true,\n\t\t\t'scansEnabled_oldVersions' => true,\n\t\t\t'scansEnabled_suspiciousAdminUsers' => true,\n\t\t\t'scansEnabled_passwds' => true,\n\t\t\t'scansEnabled_diskSpace' => true,\n\t\t\t'scansEnabled_wafStatus' => true,\n\t\t\t'scan_exclude' => wfConfig::get('scan_exclude', ''),\n\t\t\t'scan_include_extra' => wfConfig::get('scan_include_extra', ''),\n\t\t\t'scansEnabled_geoipSupport' => true,\n\t\t));\n\t}\n\t\n\t\/**\n\t * Returns an array of the scan options (as keys) and the corresponding value for the high sensitivity scan type.\n\t *\n\t * @return array\n\t *\/\n\tpublic static function highSensitivityScanTypeOptions() {\n\t\treturn array_merge(self::_inactiveScanOptions(), array(\n\t\t\t'spamvertizeCheck' => true,\n\t\t\t'checkSpamIP' => true,\n\t\t\t'scansEnabled_checkGSB' => true,\n\t\t\t'scansEnabled_checkHowGetIPs' => true,\n\t\t\t'scansEnabled_checkReadableConfig' => true,\n\t\t\t'scansEnabled_suspectedFiles' => true,\n\t\t\t'scansEnabled_core' => true,\n\t\t\t'scansEnabled_themes' => true,\n\t\t\t'scansEnabled_plugins' => true,\n\t\t\t'scansEnabled_coreUnknown' => true,\n\t\t\t'scansEnabled_malware' => true,\n\t\t\t'scansEnabled_fileContents' => true,\n\t\t\t'scansEnabled_fileContentsGSB' => true,\n\t\t\t'scansEnabled_posts' => true,\n\t\t\t'scansEnabled_comments' => true,\n\t\t\t'scansEnabled_suspiciousOptions' => true,\n\t\t\t'scansEnabled_oldVersions' => true,\n\t\t\t'scansEnabled_suspiciousAdminUsers' => true,\n\t\t\t'scansEnabled_passwds' => true,\n\t\t\t'scansEnabled_diskSpace' => true,\n\t\t\t'scansEnabled_wafStatus' => true,\n\t\t\t'other_scanOutside' => true,\n\t\t\t'scansEnabled_scanImages' => true,\n\t\t\t'scan_exclude' => wfConfig::get('scan_exclude', ''),\n\t\t\t'scan_include_extra' => wfConfig::get('scan_include_extra', ''),\n\t\t\t'scansEnabled_geoipSupport' => true,\n\t\t));\n\t}\n\t\n\t\/**\n\t * Returns an array of the scan options (as keys) and the corresponding value for the custom scan type.\n\t *\n\t * @return array\n\t *\/\n\tpublic static function customScanTypeOptions() {\n\t\t$allOptions = self::_inactiveScanOptions();\n\t\tforeach ($allOptions as $key => &$value) {\n\t\t\t$value = wfConfig::get($key);\n\t\t}\n\t\t\n\t\t$allOptions['scansEnabled_geoipSupport'] = true;\n\t\t$allOptions['scansEnabled_highSense'] = false; \/\/deprecated\n\t\t\n\t\treturn $allOptions;\n\t}\n\t\n\t\/**\n\t * Returns an array of scan options and their inactive values for convenience in merging with the various scan type\n\t * option arrays.\n\t * \n\t * @return array\n\t *\/\n\tprotected static function _inactiveScanOptions() {\n\t\treturn array(\n\t\t\t'spamvertizeCheck' => false,\n\t\t\t'checkSpamIP' => false,\n\t\t\t'scansEnabled_checkGSB' => false,\n\t\t\t'scansEnabled_checkHowGetIPs' => false,\n\t\t\t'scansEnabled_checkReadableConfig' => false,\n\t\t\t'scansEnabled_suspectedFiles' => false,\n\t\t\t'scansEnabled_core' => false,\n\t\t\t'scansEnabled_themes' => false,\n\t\t\t'scansEnabled_plugins' => false,\n\t\t\t'scansEnabled_coreUnknown' => false,\n\t\t\t'scansEnabled_malware' => false,\n\t\t\t'scansEnabled_fileContents' => false,\n\t\t\t'scan_include_extra' => '',\n\t\t\t'scansEnabled_fileContentsGSB' => false,\n\t\t\t'scansEnabled_posts' => false,\n\t\t\t'scansEnabled_comments' => false,\n\t\t\t'scansEnabled_suspiciousOptions' => false,\n\t\t\t'scansEnabled_oldVersions' => false,\n\t\t\t'scansEnabled_suspiciousAdminUsers' => false,\n\t\t\t'scansEnabled_passwds' => false,\n\t\t\t'scansEnabled_diskSpace' => false,\n\t\t\t'scansEnabled_wafStatus' => false,\n\t\t\t'other_scanOutside' => false,\n\t\t\t'scansEnabled_scanImages' => false,\n\t\t\t'scansEnabled_highSense' => false,\n\t\t\t'lowResourceScansEnabled' => false,\n\t\t\t'scan_exclude' => '',\n\t\t\t'scansEnabled_geoipSupport' => false,\n\t\t);\n\t}\n\t\n\t\/**\n\t * Returns the scan options only available to premium users.\n\t *\n\t * @return array\n\t *\/\n\tprotected static function _premiumScanOptions() {\n\t\treturn array('spamvertizeCheck', 'checkSpamIP', 'scansEnabled_checkGSB');\n\t}\n\t\n\t\/**\n\t * Returns an array of weights for calculating the scan option status score.\n\t * \n\t * @return array\n\t *\/\n\tprotected static function _scanOptionWeights() {\n\t\treturn array(\n\t\t\t'spamvertizeCheck' => 0.05,\n\t\t\t'checkSpamIP' => 0.05,\n\t\t\t'scansEnabled_checkGSB' => 0.05,\n\t\t\t'scansEnabled_checkHowGetIPs' => 0.05,\n\t\t\t'scansEnabled_checkReadableConfig' => 0.05,\n\t\t\t'scansEnabled_suspectedFiles' => 0.05,\n\t\t\t'scansEnabled_core' => 0.05,\n\t\t\t'scansEnabled_themes' => 0,\n\t\t\t'scansEnabled_plugins' => 0,\n\t\t\t'scansEnabled_coreUnknown' => 0.05,\n\t\t\t'scansEnabled_malware' => 0.05,\n\t\t\t'scansEnabled_fileContents' => 0.1,\n\t\t\t'scan_include_extra' => 0,\n\t\t\t'scansEnabled_fileContentsGSB' => 0.05,\n\t\t\t'scansEnabled_posts' => 0.05,\n\t\t\t'scansEnabled_comments' => 0.05,\n\t\t\t'scansEnabled_suspiciousOptions' => 0.05,\n\t\t\t'scansEnabled_oldVersions' => 0.1,\n\t\t\t'scansEnabled_suspiciousAdminUsers' => 0.05,\n\t\t\t'scansEnabled_passwds' => 0.05,\n\t\t\t'scansEnabled_diskSpace' => 0.05,\n\t\t\t'other_scanOutside' => 0,\n\t\t\t'scansEnabled_scanImages' => 0,\n\t\t\t'scansEnabled_highSense' => 0,\n\t\t\t'lowResourceScansEnabled' => 0,\n\t\t\t'scan_exclude' => 0,\n\t\t\t'scansEnabled_geoipSupport' => 0,\n\t\t\t'scansEnabled_wafStatus' => 0,\n\t\t);\n\t}\n\t\n\t\/**\n\t * wfScanner constructor.\n\t * @param int|bool $scanType If false, defaults to the config option `scanType`.\n\t *\/\n\tpublic function __construct($scanType = false) {\n\t\tif ($scanType === false || !self::isValidScanType($scanType)) {\n\t\t\t$this->_scanType = wfConfig::get('scanType');\n\t\t}\n\t\telse {\n\t\t\t$this->_scanType = $scanType;\n\t\t}\n\t}\n\t\n\t\/**\n\t * Returns whether or not the scanner will run as premium.\n\t * \n\t * @return bool\n\t *\/\n\tpublic function isPremiumScan() {\n\t\treturn !!wfConfig::get('isPaid');\n\t}\n\t\n\t\/**\n\t * Returns whether or not automatic scans will run.\n\t * \n\t * @return bool\n\t *\/\n\tpublic function isEnabled() {\n\t\treturn !!wfConfig::get('scheduledScansEnabled');\n\t}\n\t\n\t\/**\n\t * Returns whether or not a scan is running. A scan is considered running if the timestamp\n\t * under wf_scanRunning is within WORDFENCE_MAX_SCAN_LOCK_TIME seconds of now.\n\t * \n\t * @return bool\n\t *\/\n\tpublic function isRunning() {\n\t\t$scanRunning = wfConfig::get('wf_scanRunning');\n\t\treturn ($scanRunning && time() - $scanRunning < WORDFENCE_MAX_SCAN_LOCK_TIME);\n\t}\n\t\n\t\/**\n\t * Returns the current scan scheduling mode.\n\t * \n\t * @return string One of the SCAN_SCHEDULING_MODE_ constants\n\t *\/\n\tpublic function schedulingMode() {\n\t\tif (wfConfig::get('isPaid') && wfConfig::get('schedMode') == 'manual') {\n\t\t\treturn self::SCAN_SCHEDULING_MODE_MANUAL;\n\t\t}\n\t\treturn self::SCAN_SCHEDULING_MODE_AUTOMATIC;\n\t}\n\t\n\t\/**\n\t * Returns the manual scheduling type. This is only applicable when the scheduling mode is\n\t * SCAN_SCHEDULING_MODE_MANUAL.\n\t * \n\t * @return string One of the MANUAL_SCHEDULING_ constants.\n\t *\/\n\tpublic function manualSchedulingType() {\n\t\treturn wfConfig::get('manualScanType', self::MANUAL_SCHEDULING_ONCE_DAILY);\n\t}\n\t\n\t\/**\n\t * Returns the start hour used for non-custom manual schedules. This is initially random but may be modified\n\t * by the user later.\n\t *\n\t * @return int An hour number.\n\t *\/\n\tpublic function manualSchedulingStartHour() {\n\t\treturn wfConfig::get('schedStartHour');\n\t}\n\t\n\t\/**\n\t * Returns the currently defined custom schedule. This is only applicable when the scheduling mode is \n\t * SCAN_SCHEDULING_MODE_MANUAL and the manual type is set to MANUAL_SCHEDULING_CUSTOM.\n\t * \n\t * @return array The array will be of the format array(0 => array(0 => 0, 1 => 0 ... 23 => 0), ... 6 => array(...))\n\t *\/\n\tpublic function customSchedule() {\n\t\t$normalizedSchedule = array_fill(0, 7, array_fill(0, 24, 0));\n\t\t$storedSchedule = wfConfig::get_ser('scanSched', array());\n\t\tif (is_array($storedSchedule) && !empty($storedSchedule) && is_array($storedSchedule[0])) {\n\t\t\tforeach ($storedSchedule as $dayNumber => $day) {\n\t\t\t\tforeach ($day as $hourNumber => $enabled) {\n\t\t\t\t\t$normalizedSchedule[$dayNumber][$hourNumber] = wfUtils::truthyToInt($enabled);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn $normalizedSchedule;\n\t}\n\t\n\tpublic function shouldRunQuickScan() {\n\t\tif (!$this->isEnabled()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (time() - $this->lastQuickScanTime() < 79200) { \/\/Do not run within 22 hours of a completed quick scan\n\t\t\treturn false;\n\t\t} \n\t\t\n\t\t$lastFullScanCompletion = (int) $this->lastScanTime();\n\t\tif (time() - $lastFullScanCompletion < 43200) { \/\/Do not run within 12 hours of a completed full scan\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t$nextFullScan = $this->nextScheduledScanTime();\n\t\tif ($nextFullScan === false || $nextFullScan - time() < 3600) { \/\/Scans are not running (e.g., custom schedule selected with no times configured) or if scheduled, then avoid running within 1 hour of a pending full scan\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t$now = time();\n\t\t$tzOffset = wfUtils::formatLocalTime('Z', $now);\n\t\t$currentDayOfWeekUTC = date('w', $now);\n\t\t$currentHourUTC = date('G', $now);\n\t\t$preferredHourUTC = false;\n\t\t\n\t\tif ($this->schedulingMode() == wfScanner::SCAN_SCHEDULING_MODE_MANUAL) {\n\t\t\t$manualType = $this->manualSchedulingType();\n\t\t\t$preferredHourUTC = fmod(round(($this->manualSchedulingStartHour() * 3600 - $tzOffset) \/ 3600, 2), 24); \/\/round() rather than floor() to account for fractional time zones\n\t\t\tswitch ($manualType) {\n\t\t\t\tcase self::MANUAL_SCHEDULING_ONCE_DAILY:\n\t\t\t\tcase self::MANUAL_SCHEDULING_EVERY_OTHER_DAY:\n\t\t\t\tcase self::MANUAL_SCHEDULING_WEEKDAYS:\n\t\t\t\tcase self::MANUAL_SCHEDULING_WEEKENDS:\n\t\t\t\tcase self::MANUAL_SCHEDULING_ODD_DAYS_WEEKENDS:\n\t\t\t\t\t$preferredHourUTC = fmod($preferredHourUTC + 12, 24);\n\t\t\t\t\tbreak;\n\t\t\t\tcase self::MANUAL_SCHEDULING_TWICE_DAILY:\n\t\t\t\t\t$preferredHourUTC = fmod($preferredHourUTC + 6, 24); \/\/When automatic scans run twice daily, possibly run a quick scan 6 hours offset (will only run if either scheduled one fails for some reason)\n\t\t\t\t\tbreak;\n\t\t\t\tcase self::MANUAL_SCHEDULING_CUSTOM: \/\/Iterate from the current day backwards and base it on the first time found, may or may not actually run depending on the spacing of the custom schedule\n\t\t\t\t\t$preferredHourUTC = false;\n\t\t\t\t\t$oneWeekSchedule = $this->customSchedule();\n\t\t\t\t\tfor ($i = 7; $i > 0; $i--) { \/\/Sample sequence for `$currentDayOfWeekUTC == 2` => 2, 1, 0, 6, 5, 4, 3\n\t\t\t\t\t\t$checkingDayNumber = ($currentDayOfWeekUTC + $i) % 7;\n\t\t\t\t\t\t$day = $oneWeekSchedule[$checkingDayNumber];\n\t\t\t\t\t\t$dayHour = array_search(1, $day);\n\t\t\t\t\t\tif ($dayHour !== false) {\n\t\t\t\t\t\t\t$preferredHourUTC = fmod(round(($dayHour * 3600 - $tzOffset) \/ 3600, 2) + 12, 24);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif ($preferredHourUTC !== false) { \/\/The preferred hour of a manual scan schedule has been determined, run the quick scan at the desired offset if we're in that hour\n\t\t\t\treturn ($currentHourUTC >= $preferredHourUTC);\n\t\t\t}\n\t\t}\n\t\t\n\t\t$noc1ScanSchedule = wfConfig::get_ser('noc1ScanSchedule', array());\n\t\tif (count($noc1ScanSchedule)) {\n\t\t\t$preferredHourUTC = (int) fmod( (fmod($noc1ScanSchedule[0], 86400) \/ 3600) + 12, 24);\n\t\t\treturn ($currentHourUTC >= $preferredHourUTC);\n\t\t}\n\t\t\n\t\treturn false; \/\/If we've reached this point, the scan config is in a weird state so just skip the quick scan\n\t}\n\t\n\t\/**\n\t * Returns an associative array containing the current state each scan stage and its corresponding status.\n\t * \n\t * @return array\n\t *\/\n\tpublic function stageStatus() {\n\t\t$status = $this->_defaultStageStatuses();\n\t\t$runningStatus = wfConfig::get_ser('scanStageStatuses', array(), false);\n\t\t$status = array_merge($status, $runningStatus);\n\t\t\n\t\tforeach ($status as $stage => &$value) { \/\/Convert value array into status only\n\t\t\t$value = $value['status'];\n\t\t\tif (!$this->isRunning() && $value == self::STATUS_RUNNING) {\n\t\t\t\t$value = self::STATUS_PENDING;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $status;\n\t}\n\t\n\t\/**\n\t * Returns an array of all scan options for the given stage that are enabled.\n\t * \n\t * @param string $stage One of the STAGE_ constants\n\t * @return array\n\t *\/\n\tprivate function _scanJobsForStage($stage) {\n\t\t$always = array();\n\t\t$options = array();\n\t\tswitch ($stage) {\n\t\t\tcase self::STAGE_SPAMVERTISING_CHECKS:\n\t\t\t\t$options = array(\n\t\t\t\t\t'spamvertizeCheck',\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase self::STAGE_SPAM_CHECK:\n\t\t\t\t$options = array(\n\t\t\t\t\t'checkSpamIP',\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase self::STAGE_BLACKLIST_CHECK:\n\t\t\t\t$options = array(\n\t\t\t\t\t'scansEnabled_checkGSB',\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase self::STAGE_SERVER_STATE:\n\t\t\t\tif ($this->scanType() != self::SCAN_TYPE_QUICK) {\n\t\t\t\t\t$always = array(\n\t\t\t\t\t\t'checkSkippedFiles',\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\t$options = array(\n\t\t\t\t\t'scansEnabled_checkHowGetIPs',\n\t\t\t\t\t'scansEnabled_diskSpace',\n\t\t\t\t\t'scansEnabled_wafStatus',\n\t\t\t\t\t'scansEnabled_geoipSupport',\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase self::STAGE_FILE_CHANGES:\n\t\t\t\t$options = array(\n\t\t\t\t\t'scansEnabled_core',\n\t\t\t\t\t'scansEnabled_themes',\n\t\t\t\t\t'scansEnabled_plugins',\n\t\t\t\t\t'scansEnabled_coreUnknown',\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase self::STAGE_PUBLIC_FILES:\n\t\t\t\t$options = array(\n\t\t\t\t\t'scansEnabled_checkReadableConfig',\n\t\t\t\t\t'scansEnabled_suspectedFiles',\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase self::STAGE_MALWARE_SCAN:\n\t\t\t\t$options = array(\n\t\t\t\t\t'scansEnabled_malware',\n\t\t\t\t\t'scansEnabled_fileContents',\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase self::STAGE_CONTENT_SAFETY:\n\t\t\t\t$options = array(\n\t\t\t\t\t'scansEnabled_posts',\n\t\t\t\t\t'scansEnabled_comments',\n\t\t\t\t\t'scansEnabled_fileContentsGSB', \n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase self::STAGE_PASSWORD_STRENGTH:\n\t\t\t\t$options = array(\n\t\t\t\t\t'scansEnabled_passwds',\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase self::STAGE_VULNERABILITY_SCAN:\n\t\t\t\t$options = array(\n\t\t\t\t\t'scansEnabled_oldVersions',\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase self::STAGE_OPTIONS_AUDIT:\n\t\t\t\t$options = array(\n\t\t\t\t\t'scansEnabled_suspiciousOptions',\n\t\t\t\t\t'scansEnabled_suspiciousAdminUsers',\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\t$enabledOptions = $this->scanOptions();\n\t\t$filteredOptions = array();\n\t\tforeach ($options as $o) {\n\t\t\tif (isset($enabledOptions[$o]) && $enabledOptions[$o]) {\n\t\t\t\t$filteredOptions[] = $o;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn array_merge($filteredOptions, $always);\n\t}\n\t\n\t\/**\n\t * Returns an associative array containing each scan stage's default state. The keys are the stage identifiers and the value\n\t * is an array in the format \n\t * array(\n\t * \t\t'started' => the number of tasks for this stage that have started (initially 0),\n\t * \t\t'finished' => the number of tasks that have started and finished (initially 0),\n\t * \t\t'expected' => the expected number of tasks to run for this stage (based on the scan type and options enabled)\n\t * )\n\t * \n\t * @return array\n\t *\/\n\tprivate function _defaultStageStatuses() {\n\t\t$status = array(\n\t\t\tself::STAGE_SPAMVERTISING_CHECKS => array('status' => ($this->isPremiumScan() ? self::STATUS_PENDING : self::STATUS_PREMIUM), 'started' => 0, 'finished' => 0, 'expected' => 0),\n\t\t\tself::STAGE_SPAM_CHECK => array('status' => ($this->isPremiumScan() ? self::STATUS_PENDING : self::STATUS_PREMIUM), 'started' => 0, 'finished' => 0, 'expected' => 0),\n\t\t\tself::STAGE_BLACKLIST_CHECK => array('status' => ($this->isPremiumScan() ? self::STATUS_PENDING : self::STATUS_PREMIUM), 'started' => 0, 'finished' => 0, 'expected' => 0),\n\t\t\tself::STAGE_SERVER_STATE => array('status' => self::STATUS_PENDING, 'started' => 0, 'finished' => 0, 'expected' => 0),\n\t\t\tself::STAGE_FILE_CHANGES => array('status' => self::STATUS_PENDING, 'started' => 0, 'finished' => 0, 'expected' => 0),\n\t\t\tself::STAGE_PUBLIC_FILES => array('status' => self::STATUS_PENDING, 'started' => 0, 'finished' => 0, 'expected' => 0),\n\t\t\tself::STAGE_MALWARE_SCAN => array('status' => self::STATUS_PENDING, 'started' => 0, 'finished' => 0, 'expected' => 0),\n\t\t\tself::STAGE_CONTENT_SAFETY => array('status' => self::STATUS_PENDING, 'started' => 0, 'finished' => 0, 'expected' => 0),\n\t\t\tself::STAGE_PASSWORD_STRENGTH => array('status' => self::STATUS_PENDING, 'started' => 0, 'finished' => 0, 'expected' => 0),\n\t\t\tself::STAGE_VULNERABILITY_SCAN => array('status' => self::STATUS_PENDING, 'started' => 0, 'finished' => 0, 'expected' => 0),\n\t\t\tself::STAGE_OPTIONS_AUDIT => array('status' => self::STATUS_PENDING, 'started' => 0, 'finished' => 0, 'expected' => 0),\n\t\t);\n\t\t\n\t\tforeach ($status as $stage => &$parameters) {\n\t\t\tif ($parameters['status'] == self::STATUS_PREMIUM) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t$jobs = $this->_scanJobsForStage($stage);\n\t\t\tif (count($jobs)) {\n\t\t\t\t$parameters['expected'] = count($jobs);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$parameters['status'] = self::STATUS_DISABLED;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $status;\n\t}\n\t\n\t\/**\n\t * Resets the state of the scan stage status record.\n\t *\/\n\tpublic function resetStages() {\n\t\tif ($this->scanType() == self::SCAN_TYPE_QUICK) { \/\/Suppress for quick scans\n\t\t\treturn;\n\t\t}\n\t\twfConfig::set_ser('scanStageStatuses', $this->_defaultStageStatuses(), false, wfConfig::DONT_AUTOLOAD);\n\t}\n\t\n\tprivate function _shouldForceUpdate($stageID) {\n\t\tif ($stageID == wfScanner::STAGE_MALWARE_SCAN) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\/**\n\t * Increments the stage started counter and marks it as running if not already in that state.\n\t * \n\t * @param string $stageID One of the STAGE_ constants\n\t *\/\n\tpublic function startStage($stageID) {\n\t\tif ($this->scanType() == self::SCAN_TYPE_QUICK) { \/\/Suppress for quick scans\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t$runningStatus = wfConfig::get_ser('scanStageStatuses', array(), false);\n\t\tif ($runningStatus[$stageID]['status'] != self::STATUS_RUNNING_WARNING) {\n\t\t\t$runningStatus[$stageID]['status'] = self::STATUS_RUNNING;\n\t\t}\n\t\t\n\t\t$runningStatus[$stageID]['started'] += 1;\n\t\twfConfig::set_ser('scanStageStatuses', $runningStatus, false, wfConfig::DONT_AUTOLOAD);\n\t\tif (wfCentral::isConnected() && ($this->_shouldForceUpdate($stageID) || (time() - wfConfig::getInt('lastScanStageStatusUpdate', 0)) > self::CENTRAL_STAGE_UPDATE_THRESHOLD)) {\n\t\t\twfCentral::updateScanStatus($runningStatus);\n\t\t}\n\t}\n\t\n\t\/**\n\t * Increments the stage finished counter and updates the stage status according to whether it's fully finished or encountered a negative status.\n\t * \n\t * @param string $stageID One of the STAGE_ constants.\n\t * @param string $status One of the wfIssues::STATUS_ constants\n\t *\/\n\tpublic function completeStage($stageID, $status) {\n\t\tif ($this->scanType() == self::SCAN_TYPE_QUICK) { \/\/Suppress for quick scans\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t$runningStatus = wfConfig::get_ser('scanStageStatuses', array(), false);\n\t\t\n\t\tif ($runningStatus[$stageID]['status'] == self::STATUS_RUNNING && ($status == wfIssues::STATUS_PROBLEM)) {\n\t\t\t$runningStatus[$stageID]['status'] = self::STATUS_RUNNING_WARNING;\n\t\t}\n\t\t\n\t\t$runningStatus[$stageID]['finished'] += 1;\n\t\tif ($runningStatus[$stageID]['finished'] >= $runningStatus[$stageID]['expected']) {\n\t\t\tif ($runningStatus[$stageID]['status'] == self::STATUS_RUNNING) {\n\t\t\t\t$runningStatus[$stageID]['status'] = self::STATUS_COMPLETE_SUCCESS;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$runningStatus[$stageID]['status'] = self::STATUS_COMPLETE_WARNING;\n\t\t\t}\n\t\t}\n\t\t\n\t\twfConfig::set_ser('scanStageStatuses', $runningStatus, false, wfConfig::DONT_AUTOLOAD);\n\t\tif (wfCentral::isConnected()) {\n\t\t\t$forceSend = true; \/\/Force sending the last stage completion update even if the timing would otherwise prevent it\n\t\t\tforeach ($runningStatus as $stageID => $stage) {\n\t\t\t\tif ($runningStatus[$stageID]['finished'] < $runningStatus[$stageID]['expected']) {\n\t\t\t\t\t$forceSend = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif ($forceSend || (time() - wfConfig::getInt('lastScanStageStatusUpdate', 0)) > self::CENTRAL_STAGE_UPDATE_THRESHOLD) {\n\t\t\t\twfCentral::updateScanStatus($runningStatus);\n\t\t\t}\n\t\t}\n\n\t}\n\t\n\t\/**\n\t * Returns the selected type of the scan.\n\t * \n\t * @return string\n\t *\/\n\tpublic function scanType() {\n\t\tswitch ($this->_scanType) {\n\t\t\tcase self::SCAN_TYPE_QUICK:\/\/SCAN_TYPE_QUICK is not user-selectable\n\t\t\tcase self::SCAN_TYPE_LIMITED:\n\t\t\tcase self::SCAN_TYPE_STANDARD:\n\t\t\tcase self::SCAN_TYPE_HIGH_SENSITIVITY:\n\t\t\tcase self::SCAN_TYPE_CUSTOM:\n\t\t\t\treturn $this->_scanType;\n\t\t}\n\t\treturn self::SCAN_TYPE_STANDARD;\n\t}\n\t\n\t\/**\n\t * Returns the display name for the selected type of the scan.\n\t *\n\t * @return string\n\t *\/\n\tpublic function scanTypeName() {\n\t\tswitch ($this->_scanType) {\n\t\t\tcase self::SCAN_TYPE_QUICK:\n\t\t\t\treturn __('Quick Scan', 'wordfence');\n\t\t\tcase self::SCAN_TYPE_LIMITED:\n\t\t\t\treturn __('Limited Scan', 'wordfence');\n\t\t\tcase self::SCAN_TYPE_HIGH_SENSITIVITY:\n\t\t\t\treturn __('High Sensitivity', 'wordfence');\n\t\t\tcase self::SCAN_TYPE_CUSTOM:\n\t\t\t\treturn __('Custom Scan', 'wordfence');\n\t\t\tcase self::SCAN_TYPE_STANDARD:\n\t\t\tdefault:\n\t\t\t\treturn __('Standard Scan', 'wordfence');\n\t\t}\n\t}\n\t\n\t\/**\n\t * Returns a normalized percentage (i.e., in the range [0, 1]) to the corresponding display percentage\n\t * based on license type.\n\t *\n\t * @param float $percentage\n\t * @return float\n\t *\/\n\tprotected function _normalizedPercentageToDisplay($percentage) {\n\t\tif ($this->isPremiumScan()) {\n\t\t\treturn round($percentage, 2);\n\t\t}\n\t\t\n\t\treturn round($percentage * 0.70, 2);\n\t}\n\t\n\t\/**\n\t * Returns a normalized percentage (i.e., in the range [0, 1]) for the scan type status indicator.\n\t * \n\t * @return float\n\t *\/\n\tpublic function scanTypeStatus() {\n\t\t$isFree = !wfConfig::get('isPaid');\n\t\t$weights = self::_scanOptionWeights();\n\t\t$options = $this->scanOptions();\n\t\t$score = 0.0;\n\t\t$premiumOptions = self::_premiumScanOptions();\n\t\tforeach ($options as $key => $value) {\n\t\t\tif ($isFree && array_search($key, $premiumOptions) !== false) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif ($value) {\n\t\t\t\t$score += $weights[$key];\n\t\t\t}\n\t\t}\n\t\treturn $this->_normalizedPercentageToDisplay($score);\n\t}\n\n\tpublic function scanTypeStatusList() {\n\t\t$isFree = !wfConfig::get('isPaid');\n\t\t$weights = self::_scanOptionWeights();\n\t\t$options = $this->scanOptions();\n\t\t$disabledOptionCount = 0;\n\t\t$premiumDisabledOptionCount = 0;\n\t\t$percentage = 0.0;\n\t\t$premiumPercentage = 0.0;\n\t\t$premiumOptions = self::_premiumScanOptions();\n\t\t$statusList = array();\n\t\tforeach ($options as $key => $value) {\n\t\t\tif ($isFree && array_search($key, $premiumOptions) !== false) {\n\t\t\t\t$premiumPercentage += $weights[$key];\n\t\t\t\t$premiumDisabledOptionCount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (!$value && $weights[$key] > 0) {\n\t\t\t\t$percentage += $weights[$key];\n\t\t\t\t$disabledOptionCount++;\n\t\t\t}\n\t\t}\n\t\t\n\t\t$remainingPercentage = 1 - $this->scanTypeStatus();\n\t\tif ($isFree) {\n\t\t\t$remainingPercentage -= 0.30;\n\t\t\t$statusList[] = array(\n\t\t\t\t'percentage' => 0.30,\n\t\t\t\t'title'      => __('Enable Premium Scan Signatures.', 'wordfence'),\n\t\t\t);\n\t\t}\n\t\t\n\t\tif ($premiumPercentage > 0) {\n\t\t\t$subtraction = min($this->_normalizedPercentageToDisplay($premiumPercentage), $remainingPercentage);\n\t\t\t$remainingPercentage -= $subtraction;\n\t\t\t$statusList[] = array(\n\t\t\t\t'percentage' => $subtraction,\n\t\t\t\t'title'      => __('Enable Premium Reputation Checks.', 'wordfence'),\n\t\t\t);\n\t\t}\n\n\t\tif ($percentage > 0) {\n\t\t\t$subtraction = min($this->_normalizedPercentageToDisplay($percentage), $remainingPercentage);\n\t\t\t$statusList[] = array(\n\t\t\t\t'percentage' => $subtraction,\n\t\t\t\t'title' => sprintf(_n('Enable %d scan option.', 'Enable %d scan options.', $disabledOptionCount,'wordfence'), number_format_i18n($disabledOptionCount)),\n\t\t\t);\n\t\t}\n\n\t\treturn $statusList;\n\t}\n\t\/**\n\t * Returns the malware signature feed that is in use.\n\t *\n\t * @return string\n\t *\/\n\tpublic function signatureMode() {\n\t\tif ($this->isPremiumScan()) {\n\t\t\treturn self::SIGNATURE_MODE_PREMIUM;\n\t\t}\n\t\treturn self::SIGNATURE_MODE_COMMUNITY;\n\t}\n\t\n\t\/**\n\t * Returns a normalized percentage (i.e., in the range [0, 1]) for the reputation status indicator.\n\t * \n\t * @return float\n\t *\/\n\tpublic function reputationStatus() {\n\t\t$score = 0.0;\n\t\tif ($this->isPremiumScan()) {\n\t\t\t$options = $this->scanOptions();\n\t\t\tif ($options['spamvertizeCheck']) { $score += 0.333; }\n\t\t\tif ($options['checkSpamIP']) { $score += 0.333; }\n\t\t\tif ($options['scansEnabled_checkGSB']) { $score += 0.333; }\n\t\t}\n\t\treturn round($score, 2);\n\t}\n\n\t\/**\n\t * @return array\n\t *\/\n\tpublic function reputationStatusList() {\n\t\t$statusList = array();\n\t\t$options = $this->scanOptions();\n\n\t\t$reputationChecks = array(\n\t\t\t'spamvertizeCheck' => __('Enable scan option to check if this website is being \"Spamvertised\".', 'wordfence'),\n\t\t\t'checkSpamIP' => __('Enable scan option to check if your website IP is generating spam.', 'wordfence'),\n\t\t\t'scansEnabled_checkGSB' => __('Enable scan option to check if your website is on a domain blocklist.', 'wordfence'),\n\t\t);\n\n\t\tforeach ($reputationChecks as $option => $optionLabel) {\n\t\t\tif (!$this->isPremiumScan() || !$options[$option]) {\n\t\t\t\t$statusList[] = array(\n\t\t\t\t\t'percentage' => round(1 \/ count($reputationChecks), 2),\n\t\t\t\t\t'title'      => $optionLabel,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn $statusList;\n\t}\n\n\t\/**\n\t * Returns the options for the configured scan type.\n\t * \n\t * @return array\n\t *\/\n\tpublic function scanOptions() {\n\t\tswitch ($this->scanType()) {\n\t\t\tcase self::SCAN_TYPE_QUICK:\n\t\t\t\treturn self::quickScanTypeOptions();\n\t\t\tcase self::SCAN_TYPE_LIMITED:\n\t\t\t\treturn self::limitedScanTypeOptions();\n\t\t\tcase self::SCAN_TYPE_STANDARD:\n\t\t\t\treturn self::standardScanTypeOptions();\n\t\t\tcase self::SCAN_TYPE_HIGH_SENSITIVITY:\n\t\t\t\treturn self::highSensitivityScanTypeOptions();\n\t\t\tcase self::SCAN_TYPE_CUSTOM:\n\t\t\t\treturn self::customScanTypeOptions();\n\t\t}\n\t}\n\t\n\t\/**\n\t * Returns the array of jobs for the scan type.\n\t * \n\t * @return array\n\t *\/\n\tpublic function jobs() {\n\t\t$options = $this->scanOptions();\n\t\t$preferredOrder = array(\n\t\t\t'checkSpamvertized' => array('spamvertizeCheck'), \n\t\t\t'checkSpamIP' => array('checkSpamIP'), \n\t\t\t'checkGSB' => array('scansEnabled_checkGSB'),\n\t\t\t'checkHowGetIPs' => array('scansEnabled_checkHowGetIPs'),\n\t\t\t'diskSpace' => array('scansEnabled_diskSpace'),\n\t\t\t'wafStatus' => array('scansEnabled_wafStatus'),\n\t\t\t'geoipSupport' => array('scansEnabled_geoipSupport'),\n\t\t\t'checkSkippedFiles' => ($this->scanType() != self::SCAN_TYPE_QUICK), \/\/Always runs except for quick\n\t\t\t'knownFiles' => ($this->scanType() != self::SCAN_TYPE_QUICK), \/\/Always runs except for quick, options are scansEnabled_core, scansEnabled_themes, scansEnabled_plugins, scansEnabled_coreUnknown, scansEnabled_malware\n\t\t\t'checkReadableConfig' => array('scansEnabled_checkReadableConfig'),\n\t\t\t'fileContents' => ($this->scanType() != self::SCAN_TYPE_QUICK), \/\/Always runs except for quick, options are scansEnabled_fileContents and scansEnabled_fileContentsGSB\n\t\t\t'suspectedFiles' => array('scansEnabled_suspectedFiles'),\n\t\t\t'posts' => array('scansEnabled_posts'),\n\t\t\t'comments' => array('scansEnabled_comments'),\n\t\t\t'passwds' => array('scansEnabled_passwds'),\n\t\t\t'oldVersions' => array('scansEnabled_oldVersions'),\n\t\t\t'suspiciousAdminUsers' => array('scansEnabled_suspiciousAdminUsers'),\n\t\t\t'suspiciousOptions' => array('scansEnabled_suspiciousOptions'),\n\t\t);\n\t\t\n\t\t$jobs = array();\n\t\tforeach ($preferredOrder as $job => $enabler) {\n\t\t\tif ($enabler === true) {\n\t\t\t\t$jobs[] = $job;\n\t\t\t}\n\t\t\telse if (is_array($enabler)) {\n\t\t\t\tforeach ($enabler as $o) {\n\t\t\t\t\tif ($options[$o]) {\n\t\t\t\t\t\t$jobs[] = $job;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn $jobs;\n\t}\n\t\n\t\/**\n\t * Returns whether or not the scanner should use its low resource mode.\n\t * \n\t * @return bool\n\t *\/\n\tpublic function useLowResourceScanning() {\n\t\t$options = $this->scanOptions();\n\t\treturn $options['lowResourceScansEnabled'];\n\t}\n\t\n\t\/**\n\t * Returns the array of user-defined malware signatures for use by the scanner.\n\t * \n\t * @return array\n\t *\/\n\tpublic function userScanSignatures() {\n\t\t$options = $this->scanOptions();\n\t\t$value = $options['scan_include_extra'];\n\t\t$signatures = array();\n\t\tif (!empty($value)) {\n\t\t\t$regexs = explode(\"\\n\", $value);\n\t\t\t$id = 1000001;\n\t\t\tforeach ($regexs as $r) {\n\t\t\t\t$r = rtrim($r, \"\\r\");\n\t\t\t\tif (preg_match('\/' . $r . '\/i', \"\") !== false) {\n\t\t\t\t\t$signatures[] = array($id++, time(), $r, __('User defined scan pattern', 'wordfence'));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn $signatures;\n\t}\n\t\n\t\/**\n\t * Returns whether or not the scanner should check files outside of the WordPress installation.\n\t * \n\t * @return bool\n\t *\/\n\tpublic function scanOutsideWordPress() {\n\t\t$options = $this->scanOptions();\n\t\treturn $options['other_scanOutside'];\n\t}\n\t\n\t\/**\n\t * Returns the cleaned up array of user-excluded scan paths and patterns.\n\t * \n\t * @return array\n\t *\/\n\tpublic function userExclusions() {\n\t\t$options = $this->scanOptions();\n\t\t$value = $options['scan_exclude'];\n\t\treturn explode(\"\\n\", wfUtils::cleanupOneEntryPerLine($value));\n\t}\n\t\n\t\/**\n\t * Fetches the scan summary items into the internal cache.\n\t *\/\n\tprivate function _fetchSummaryItems() {\n\t\tif ($this->_summary !== false) { \n\t\t\treturn;\n\t\t}\n\t\t\n\t\t$this->_summary = wfConfig::get_ser('wf_summaryItems', array());\n\t}\n\t\n\t\/**\n\t * Writes the scan summary cache to permanent storage.\n\t *\/\n\tprivate function _saveSummaryItems() {\n\t\tif ($this->_summary !== false && $this->_dirty) {\n\t\t\t$this->_summary['lastUpdate'] = time();\n\t\t\twfConfig::set_ser('wf_summaryItems', $this->_summary);\n\t\t}\n\t\t$this->_dirty = false;\n\t}\n\t\n\t\/**\n\t * Saves the scan summary cache if it has been more than two seconds since the last update.\n\t * \n\t * @return bool Whether or not it saved.\n\t *\/\n\tprivate function _maybeSaveSummaryItems() {\n\t\tif ($this->_summary !== false && $this->_summary['lastUpdate'] < (time() - 2)) {\n\t\t\t$this->_saveSummaryItems();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\/**\n\t * Populates the scan summary with the default counters.\n\t *\/\n\tpublic function resetSummaryItems() {\n\t\tglobal $wpdb;\n\t\t\n\t\t$this->_summary = array();\n\t\t$this->_summary[self::SUMMARY_SCANNED_POSTS] = 0;\n\t\t$this->_summary[self::SUMMARY_SCANNED_COMMENTS] = 0;\n\t\t$this->_summary[self::SUMMARY_SCANNED_FILES] = 0;\n\t\t$this->_summary[self::SUMMARY_SCANNED_PLUGINS] = 0;\n\t\t$this->_summary[self::SUMMARY_SCANNED_THEMES] = 0;\n\t\t$this->_summary[self::SUMMARY_SCANNED_USERS] = 0;\n\t\t$this->_summary[self::SUMMARY_SCANNED_URLS] = 0;\n\t\t\n\t\t$this->_dirty = true;\n\t\t$this->_saveSummaryItems();\n\t}\n\t\n\t\/**\n\t * Forces a save of the scan summary cache.\n\t *\/\n\tpublic function flushSummaryItems() {\n\t\t$this->_saveSummaryItems();\n\t}\n\t\n\t\/**\n\t * Returns the corresponding summary value for $key or $default if not found.\n\t * \n\t * @param $key\n\t * @param mixed $default The value returned if there is no value for $key.\n\t * @return mixed\n\t *\/\n\tpublic function getSummaryItem($key, $default = false) {\n\t\t$this->_fetchSummaryItems();\n\t\tif (isset($this->_summary[$key])) {\n\t\t\treturn $this->_summary[$key];\n\t\t}\n\t\treturn $default;\n\t}\n\t\n\t\/**\n\t * Sets the summary item $key as $value.\n\t * \n\t * @param $key\n\t * @param $value\n\t *\/\n\tpublic function setSummaryItem($key, $value) {\n\t\t$this->_fetchSummaryItems();\n\t\t$this->_summary[$key] = $value;\n\t\t$this->_dirty = true;\n\t\t\n\t\tif (!$this->_maybeSaveSummaryItems() && !$this->_destructRegistered) {\n\t\t\tregister_shutdown_function(array($this, 'flushSummaryItems'));\n\t\t\t$this->_destructRegistered = true;\n\t\t}\n\t}\n\t\n\t\/**\n\t * Atomically increments the summary item under $key by $value.\n\t * \n\t * @param $key\n\t * @param int $value\n\t *\/\n\tpublic function incrementSummaryItem($key, $value = 1) {\n\t\tif ($value == 0) { return; }\n\t\t$this->_fetchSummaryItems();\n\t\tif (isset($this->_summary[$key])) {\n\t\t\t$this->_summary[$key] += $value;\n\t\t\t$this->_dirty = true;\n\t\t\t\n\t\t\tif (!$this->_maybeSaveSummaryItems() && !$this->_destructRegistered) {\n\t\t\t\tregister_shutdown_function(array($this, 'flushSummaryItems'));\n\t\t\t\t$this->_destructRegistered = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\/**\n\t * Schedules a single scan for the given time. If $originalTime is provided, it will be associated with the cron.\n\t * \n\t * @param $futureTime\n\t * @param bool|int $originalTime\n\t *\/\n\tpublic function scheduleSingleScan($futureTime, $originalTime = false) {\n\t\tif (is_main_site()) { \/\/ Removed ability to activate on network site in v5.3.12\n\t\t\tif ($originalTime === false) {\n\t\t\t\t$originalTime = $futureTime;\n\t\t\t}\n\t\t\twp_schedule_single_event($futureTime, 'wordfence_start_scheduled_scan', array((int) $originalTime));\n\t\t\t\n\t\t\t\/\/Saving our own copy of the schedule because the wp-cron functions all require the args list to act\n\t\t\t$allScansScheduled = wfConfig::get_ser('allScansScheduled', array());\n\t\t\t$allScansScheduled[] = array('timestamp' => $futureTime, 'args' => array((int) $originalTime));\n\t\t\twfConfig::set_ser('allScansScheduled', $allScansScheduled);\n\t\t}\n\t}\n\t\n\t\/**\n\t * Clears all scheduled scan cron jobs and re-creates them.\n\t *\/\n\tpublic function scheduleScans() {\n\t\t$this->unscheduleAllScans();\n\t\tif (!$this->isEnabled()) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif ($this->schedulingMode() == wfScanner::SCAN_SCHEDULING_MODE_MANUAL) {\n\t\t\t\/\/Generate a two-week schedule\n\t\t\t$manualType = $this->manualSchedulingType();\n\t\t\t$preferredHour = $this->manualSchedulingStartHour();\n\t\t\tswitch ($manualType) {\n\t\t\t\tcase self::MANUAL_SCHEDULING_ONCE_DAILY:\n\t\t\t\t\t$schedule = array_fill(0, 14, array_fill(0, 24, 0));\n\t\t\t\t\tforeach ($schedule as $dayNumber => &$day) {\n\t\t\t\t\t\t$day[$preferredHour] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase self::MANUAL_SCHEDULING_TWICE_DAILY:\n\t\t\t\t\t$schedule = array_fill(0, 14, array_fill(0, 24, 0));\n\t\t\t\t\tforeach ($schedule as $dayNumber => &$day) {\n\t\t\t\t\t\t$day[$preferredHour] = 1;\n\t\t\t\t\t\t$day[fmod($preferredHour + 12, 24)] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase self::MANUAL_SCHEDULING_EVERY_OTHER_DAY:\n\t\t\t\t\t$baseDay = floor(time() \/ 86400);\n\t\t\t\t\t$schedule = array_fill(0, 14, array_fill(0, 24, 0));\n\t\t\t\t\tforeach ($schedule as $dayNumber => &$day) {\n\t\t\t\t\t\tif (($baseDay + $dayNumber) % 2) {\n\t\t\t\t\t\t\t$day[$preferredHour] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase self::MANUAL_SCHEDULING_WEEKDAYS:\n\t\t\t\t\t$schedule = array_fill(0, 14, array_fill(0, 24, 0));\n\t\t\t\t\tforeach ($schedule as $dayNumber => &$day) {\n\t\t\t\t\t\tif ($dayNumber > 0 && $dayNumber < 6) {\n\t\t\t\t\t\t\t$day[$preferredHour] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase self::MANUAL_SCHEDULING_WEEKENDS:\n\t\t\t\t\t$schedule = array_fill(0, 14, array_fill(0, 24, 0));\n\t\t\t\t\tforeach ($schedule as $dayNumber => &$day) {\n\t\t\t\t\t\tif ($dayNumber == 0 || $dayNumber == 6) {\n\t\t\t\t\t\t\t$day[$preferredHour] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase self::MANUAL_SCHEDULING_ODD_DAYS_WEEKENDS:\n\t\t\t\t\t$schedule = array_fill(0, 14, array_fill(0, 24, 0));\n\t\t\t\t\tforeach ($schedule as $dayNumber => &$day) {\n\t\t\t\t\t\tif ($dayNumber == 0 || $dayNumber == 6 || ($dayNumber % 2)) {\n\t\t\t\t\t\t\t$day[$preferredHour] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase self::MANUAL_SCHEDULING_CUSTOM:\n\t\t\t\t\t$oneWeekSchedule = $this->customSchedule();\n\t\t\t\t\t$schedule = array();\n\t\t\t\t\tforeach ($oneWeekSchedule as $day) { $schedule[] = $day; }\n\t\t\t\t\tforeach ($oneWeekSchedule as $day) { $schedule[] = $day; }\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t$now = time();\n\t\t\t$tzOffset = wfUtils::formatLocalTime('Z', $now);\n\t\t\t\n\t\t\t\/\/Apply the time zone shift so the start times align to the server's time zone\n\t\t\t$shiftedSchedule = array_fill(0, 14, array());\n\t\t\tforeach ($schedule as $dayNumber => $day) {\n\t\t\t\tforeach ($day as $hourNumber => $enabled) {\n\t\t\t\t\tif ($enabled) {\n\t\t\t\t\t\t$effectiveHour = round(($hourNumber * 3600 - $tzOffset) \/ 3600); \/\/round() rather than floor() to account for fractional time zones\n\t\t\t\t\t\t$wrappedHour = (int) fmod($effectiveHour + 24, 24);\n\t\t\t\t\t\tif ($effectiveHour < 0) {\n\t\t\t\t\t\t\tif ($dayNumber > 0) {\n\t\t\t\t\t\t\t\t$shiftedSchedule[$dayNumber - 1][$wrappedHour] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ($effectiveHour > 23) {\n\t\t\t\t\t\t\tif ($dayNumber < count($schedule) - 1) {\n\t\t\t\t\t\t\t\t$shiftedSchedule[$dayNumber + 1][$wrappedHour] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t$shiftedSchedule[$dayNumber][$effectiveHour] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t$schedule = $shiftedSchedule;\n\t\t\t\n\t\t\t\/\/Trim out all but an 8-day period\n\t\t\t$currentDayOfWeekUTC = date('w', $now);\n\t\t\t$currentHourUTC = date('G', $now);\n\t\t\t$periodStart = floor($now \/ 86400) * 86400 - $currentDayOfWeekUTC * 86400;\n\t\t\t$schedule = array_slice($schedule, $currentDayOfWeekUTC, null, true);\n\t\t\t$schedule = array_slice($schedule, 0, 8, true);\n\t\t\t\n\t\t\t\/\/Schedule them\n\t\t\tforeach ($schedule as $dayNumber => $day) {\n\t\t\t\tforeach ($day as $hourNumber => $enabled) {\n\t\t\t\t\tif ($enabled) {\n\t\t\t\t\t\tif ($dayNumber == $currentDayOfWeekUTC && $currentHourUTC > $hourNumber) { \/\/It's today and we've already passed its hour, skip it\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ($dayNumber > 6 && ($dayNumber % 7) == $currentDayOfWeekUTC && $currentHourUTC <= $hourNumber) { \/\/It's one week from today but beyond the current hour, skip it this cycle\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$scanTime = $periodStart + $dayNumber * 86400 + $hourNumber * 3600 + wfWAFUtils::random_int(0, 3600);\n\t\t\t\t\t\twordfence::status(4, 'info', sprintf(\n\t\t\t\t\t\t\t\/* translators: 1. Day of week. 2. Hour of day. 3. Localized date. *\/\n\t\t\t\t\t\t\t__(\"Scheduled time for day %s hour %s is: %s\", 'wordfence'),\n\t\t\t\t\t\t\t$dayNumber,\n\t\t\t\t\t\t\t$hourNumber,\n\t\t\t\t\t\t\twfUtils::formatLocalTime('l jS \\of F Y h:i:s A P', $scanTime)\n\t\t\t\t\t\t));\n\t\t\t\t\t\t$this->scheduleSingleScan($scanTime);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t$noc1ScanSchedule = wfConfig::get_ser('noc1ScanSchedule', array());\n\t\t\tforeach ($noc1ScanSchedule as $timestamp) {\n\t\t\t\t$timestamp = wfUtils::denormalizedTime($timestamp);\n\t\t\t\tif ($timestamp > time()) {\n\t\t\t\t\t$this->scheduleSingleScan($timestamp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic function unscheduleAllScans() {\n\t\t$allScansScheduled = wfConfig::get_ser('allScansScheduled', array());\n\t\tforeach ($allScansScheduled as $entry) {\n\t\t\twp_unschedule_event($entry['timestamp'], 'wordfence_start_scheduled_scan', $entry['args']);\n\t\t}\n\t\twp_clear_scheduled_hook('wordfence_start_scheduled_scan');\n\t\twfConfig::set_ser('allScansScheduled', array());\n\t}\n\t\n\tpublic function nextScheduledScanTime() {\n\t\t$nextTime = false;\n\t\t$cron = _get_cron_array();\n\t\tforeach($cron as $key => $val){\n\t\t\tif(isset($val['wordfence_start_scheduled_scan'])){\n\t\t\t\t$nextTime = $key;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn $nextTime;\n\t}\n\t\n\tpublic function lastScanTime() {\n\t\treturn wfConfig::get('scanTime');\n\t}\n\t\n\tpublic function recordLastScanTime() {\n\t\twfConfig::set('scanTime', microtime(true));\n\t}\n\t\n\tpublic function lastQuickScanTime() {\n\t\treturn wfConfig::get('lastQuickScan', 0);\n\t}\n\t\n\tpublic function recordLastQuickScanTime() {\n\t\twfConfig::set('lastQuickScan', microtime(true));\n\t}\n}"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/autoload.php","ext":"php","size":260,"mtime":1756374919,"type":"text","content":"<?php\n\n\/\/ autoload.php @generated by Composer\n\nif (!class_exists('ComposerAutoloaderInite213e65b2dafae4ad799b13fe0d36f8e')) {\n\trequire_once __DIR__ . '\/composer\/autoload_real.php';\n}\n\nreturn ComposerAutoloaderInite213e65b2dafae4ad799b13fe0d36f8e::getLoader();\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/composer\/installed.json","ext":"json","size":5610,"mtime":1756374919,"type":"text","content":"{\n    \"packages\": [\n        {\n            \"name\": \"paragonie\/random_compat\",\n            \"version\": \"v2.0.21\",\n            \"version_normalized\": \"2.0.21.0\",\n            \"source\": {\n                \"type\": \"git\",\n                \"url\": \"https:\/\/github.com\/paragonie\/random_compat.git\",\n                \"reference\": \"96c132c7f2f7bc3230723b66e89f8f150b29d5ae\"\n            },\n            \"dist\": {\n                \"type\": \"zip\",\n                \"url\": \"https:\/\/api.github.com\/repos\/paragonie\/random_compat\/zipball\/96c132c7f2f7bc3230723b66e89f8f150b29d5ae\",\n                \"reference\": \"96c132c7f2f7bc3230723b66e89f8f150b29d5ae\",\n                \"shasum\": \"\"\n            },\n            \"require\": {\n                \"php\": \">=5.2.0\"\n            },\n            \"require-dev\": {\n                \"phpunit\/phpunit\": \"*\"\n            },\n            \"suggest\": {\n                \"ext-libsodium\": \"Provides a modern crypto API that can be used to generate random bytes.\"\n            },\n            \"time\": \"2022-02-16T17:07:03+00:00\",\n            \"type\": \"library\",\n            \"installation-source\": \"dist\",\n            \"autoload\": {\n                \"files\": [\n                    \"lib\/random.php\"\n                ]\n            },\n            \"notification-url\": \"https:\/\/packagist.org\/downloads\/\",\n            \"license\": [\n                \"MIT\"\n            ],\n            \"authors\": [\n                {\n                    \"name\": \"Paragon Initiative Enterprises\",\n                    \"email\": \"security@paragonie.com\",\n                    \"homepage\": \"https:\/\/paragonie.com\"\n                }\n            ],\n            \"description\": \"PHP 5.x polyfill for random_bytes() and random_int() from PHP 7\",\n            \"keywords\": [\n                \"csprng\",\n                \"polyfill\",\n                \"pseudorandom\",\n                \"random\"\n            ],\n            \"support\": {\n                \"email\": \"info@paragonie.com\",\n                \"issues\": \"https:\/\/github.com\/paragonie\/random_compat\/issues\",\n                \"source\": \"https:\/\/github.com\/paragonie\/random_compat\"\n            },\n            \"install-path\": \"..\/paragonie\/random_compat\"\n        },\n        {\n            \"name\": \"paragonie\/sodium_compat\",\n            \"version\": \"v1.20.0\",\n            \"version_normalized\": \"1.20.0.0\",\n            \"source\": {\n                \"type\": \"git\",\n                \"url\": \"https:\/\/github.com\/paragonie\/sodium_compat.git\",\n                \"reference\": \"e592a3e06d1fa0d43988c7c7d9948ca836f644b6\"\n            },\n            \"dist\": {\n                \"type\": \"zip\",\n                \"url\": \"https:\/\/api.github.com\/repos\/paragonie\/sodium_compat\/zipball\/e592a3e06d1fa0d43988c7c7d9948ca836f644b6\",\n                \"reference\": \"e592a3e06d1fa0d43988c7c7d9948ca836f644b6\",\n                \"shasum\": \"\"\n            },\n            \"require\": {\n                \"paragonie\/random_compat\": \">=1\",\n                \"php\": \"^5.2.4|^5.3|^5.4|^5.5|^5.6|^7|^8\"\n            },\n            \"require-dev\": {\n                \"phpunit\/phpunit\": \"^3|^4|^5|^6|^7|^8|^9\"\n            },\n            \"suggest\": {\n                \"ext-libsodium\": \"PHP < 7.0: Better performance, password hashing (Argon2i), secure memory management (memzero), and better security.\",\n                \"ext-sodium\": \"PHP >= 7.0: Better performance, password hashing (Argon2i), secure memory management (memzero), and better security.\"\n            },\n            \"time\": \"2023-04-30T00:54:53+00:00\",\n            \"type\": \"library\",\n            \"installation-source\": \"dist\",\n            \"autoload\": {\n                \"files\": [\n                    \"autoload.php\"\n                ]\n            },\n            \"notification-url\": \"https:\/\/packagist.org\/downloads\/\",\n            \"license\": [\n                \"ISC\"\n            ],\n            \"authors\": [\n                {\n                    \"name\": \"Paragon Initiative Enterprises\",\n                    \"email\": \"security@paragonie.com\"\n                },\n                {\n                    \"name\": \"Frank Denis\",\n                    \"email\": \"jedisct1@pureftpd.org\"\n                }\n            ],\n            \"description\": \"Pure PHP implementation of libsodium; uses the PHP extension if it exists\",\n            \"keywords\": [\n                \"Authentication\",\n                \"BLAKE2b\",\n                \"ChaCha20\",\n                \"ChaCha20-Poly1305\",\n                \"Chapoly\",\n                \"Curve25519\",\n                \"Ed25519\",\n                \"EdDSA\",\n                \"Edwards-curve Digital Signature Algorithm\",\n                \"Elliptic Curve Diffie-Hellman\",\n                \"Poly1305\",\n                \"Pure-PHP cryptography\",\n                \"RFC 7748\",\n                \"RFC 8032\",\n                \"Salpoly\",\n                \"Salsa20\",\n                \"X25519\",\n                \"XChaCha20-Poly1305\",\n                \"XSalsa20-Poly1305\",\n                \"Xchacha20\",\n                \"Xsalsa20\",\n                \"aead\",\n                \"cryptography\",\n                \"ecdh\",\n                \"elliptic curve\",\n                \"elliptic curve cryptography\",\n                \"encryption\",\n                \"libsodium\",\n                \"php\",\n                \"public-key cryptography\",\n                \"secret-key cryptography\",\n                \"side-channel resistant\"\n            ],\n            \"support\": {\n                \"issues\": \"https:\/\/github.com\/paragonie\/sodium_compat\/issues\",\n                \"source\": \"https:\/\/github.com\/paragonie\/sodium_compat\/tree\/v1.20.0\"\n            },\n            \"install-path\": \"..\/paragonie\/sodium_compat\"\n        }\n    ],\n    \"dev\": true,\n    \"dev-package-names\": []\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/composer\/autoload_psr4.php","ext":"php","size":143,"mtime":1756374919,"type":"text","content":"<?php\n\n\/\/ autoload_psr4.php @generated by Composer\n\n$vendorDir = dirname(dirname(__FILE__));\n$baseDir = dirname($vendorDir);\n\nreturn array(\n);\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/composer\/InstalledVersions.php","ext":"php","size":13927,"mtime":1756374919,"type":"text","content":"<?php\n\n\/*\n * This file is part of Composer.\n *\n * (c) Nils Adermann <naderman@naderman.de>\n *     Jordi Boggiano <j.boggiano@seld.be>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Composer;\n\nuse Composer\\Autoload\\ClassLoader;\nuse Composer\\Semver\\VersionParser;\n\n\/**\n * This class is copied in every Composer installed project and available to all\n *\n * See also https:\/\/getcomposer.org\/doc\/07-runtime.md#installed-versions\n *\n * To require it's presence, you can require `composer-runtime-api ^2.0`\n *\/\nclass InstalledVersions\n{\n    private static $installed;\n    private static $canGetVendors;\n    private static $installedByVendor = array();\n\n    \/**\n     * Returns a list of all package names which are present, either by being installed, replaced or provided\n     *\n     * @return string[]\n     * @psalm-return list<string>\n     *\/\n    public static function getInstalledPackages()\n    {\n        $packages = array();\n        foreach (self::getInstalled() as $installed) {\n            $packages[] = array_keys($installed['versions']);\n        }\n\n        if (1 === \\count($packages)) {\n            return $packages[0];\n        }\n\n        return array_keys(array_flip(\\call_user_func_array('array_merge', $packages)));\n    }\n\n    \/**\n     * Returns a list of all package names with a specific type e.g. 'library'\n     *\n     * @param  string   $type\n     * @return string[]\n     * @psalm-return list<string>\n     *\/\n    public static function getInstalledPackagesByType($type)\n    {\n        $packagesByType = array();\n\n        foreach (self::getInstalled() as $installed) {\n            foreach ($installed['versions'] as $name => $package) {\n                if (isset($package['type']) && $package['type'] === $type) {\n                    $packagesByType[] = $name;\n                }\n            }\n        }\n\n        return $packagesByType;\n    }\n\n    \/**\n     * Checks whether the given package is installed\n     *\n     * This also returns true if the package name is provided or replaced by another package\n     *\n     * @param  string $packageName\n     * @param  bool   $includeDevRequirements\n     * @return bool\n     *\/\n    public static function isInstalled($packageName, $includeDevRequirements = true)\n    {\n        foreach (self::getInstalled() as $installed) {\n            if (isset($installed['versions'][$packageName])) {\n                return $includeDevRequirements || empty($installed['versions'][$packageName]['dev_requirement']);\n            }\n        }\n\n        return false;\n    }\n\n    \/**\n     * Checks whether the given package satisfies a version constraint\n     *\n     * e.g. If you want to know whether version 2.3+ of package foo\/bar is installed, you would call:\n     *\n     *   Composer\\InstalledVersions::satisfies(new VersionParser, 'foo\/bar', '^2.3')\n     *\n     * @param  VersionParser $parser      Install composer\/semver to have access to this class and functionality\n     * @param  string        $packageName\n     * @param  string|null   $constraint  A version constraint to check for, if you pass one you have to make sure composer\/semver is required by your package\n     * @return bool\n     *\/\n    public static function satisfies(VersionParser $parser, $packageName, $constraint)\n    {\n        $constraint = $parser->parseConstraints($constraint);\n        $provided = $parser->parseConstraints(self::getVersionRanges($packageName));\n\n        return $provided->matches($constraint);\n    }\n\n    \/**\n     * Returns a version constraint representing all the range(s) which are installed for a given package\n     *\n     * It is easier to use this via isInstalled() with the $constraint argument if you need to check\n     * whether a given version of a package is installed, and not just whether it exists\n     *\n     * @param  string $packageName\n     * @return string Version constraint usable with composer\/semver\n     *\/\n    public static function getVersionRanges($packageName)\n    {\n        foreach (self::getInstalled() as $installed) {\n            if (!isset($installed['versions'][$packageName])) {\n                continue;\n            }\n\n            $ranges = array();\n            if (isset($installed['versions'][$packageName]['pretty_version'])) {\n                $ranges[] = $installed['versions'][$packageName]['pretty_version'];\n            }\n            if (array_key_exists('aliases', $installed['versions'][$packageName])) {\n                $ranges = array_merge($ranges, $installed['versions'][$packageName]['aliases']);\n            }\n            if (array_key_exists('replaced', $installed['versions'][$packageName])) {\n                $ranges = array_merge($ranges, $installed['versions'][$packageName]['replaced']);\n            }\n            if (array_key_exists('provided', $installed['versions'][$packageName])) {\n                $ranges = array_merge($ranges, $installed['versions'][$packageName]['provided']);\n            }\n\n            return implode(' || ', $ranges);\n        }\n\n        throw new \\OutOfBoundsException('Package \"' . $packageName . '\" is not installed');\n    }\n\n    \/**\n     * @param  string      $packageName\n     * @return string|null If the package is being replaced or provided but is not really installed, null will be returned as version, use satisfies or getVersionRanges if you need to know if a given version is present\n     *\/\n    public static function getVersion($packageName)\n    {\n        foreach (self::getInstalled() as $installed) {\n            if (!isset($installed['versions'][$packageName])) {\n                continue;\n            }\n\n            if (!isset($installed['versions'][$packageName]['version'])) {\n                return null;\n            }\n\n            return $installed['versions'][$packageName]['version'];\n        }\n\n        throw new \\OutOfBoundsException('Package \"' . $packageName . '\" is not installed');\n    }\n\n    \/**\n     * @param  string      $packageName\n     * @return string|null If the package is being replaced or provided but is not really installed, null will be returned as version, use satisfies or getVersionRanges if you need to know if a given version is present\n     *\/\n    public static function getPrettyVersion($packageName)\n    {\n        foreach (self::getInstalled() as $installed) {\n            if (!isset($installed['versions'][$packageName])) {\n                continue;\n            }\n\n            if (!isset($installed['versions'][$packageName]['pretty_version'])) {\n                return null;\n            }\n\n            return $installed['versions'][$packageName]['pretty_version'];\n        }\n\n        throw new \\OutOfBoundsException('Package \"' . $packageName . '\" is not installed');\n    }\n\n    \/**\n     * @param  string      $packageName\n     * @return string|null If the package is being replaced or provided but is not really installed, null will be returned as reference\n     *\/\n    public static function getReference($packageName)\n    {\n        foreach (self::getInstalled() as $installed) {\n            if (!isset($installed['versions'][$packageName])) {\n                continue;\n            }\n\n            if (!isset($installed['versions'][$packageName]['reference'])) {\n                return null;\n            }\n\n            return $installed['versions'][$packageName]['reference'];\n        }\n\n        throw new \\OutOfBoundsException('Package \"' . $packageName . '\" is not installed');\n    }\n\n    \/**\n     * @param  string      $packageName\n     * @return string|null If the package is being replaced or provided but is not really installed, null will be returned as install path. Packages of type metapackages also have a null install path.\n     *\/\n    public static function getInstallPath($packageName)\n    {\n        foreach (self::getInstalled() as $installed) {\n            if (!isset($installed['versions'][$packageName])) {\n                continue;\n            }\n\n            return isset($installed['versions'][$packageName]['install_path']) ? $installed['versions'][$packageName]['install_path'] : null;\n        }\n\n        throw new \\OutOfBoundsException('Package \"' . $packageName . '\" is not installed');\n    }\n\n    \/**\n     * @return array\n     * @psalm-return array{name: string, version: string, reference: string, pretty_version: string, aliases: string[], dev: bool, install_path: string}\n     *\/\n    public static function getRootPackage()\n    {\n        $installed = self::getInstalled();\n\n        return $installed[0]['root'];\n    }\n\n    \/**\n     * Returns the raw installed.php data for custom implementations\n     *\n     * @deprecated Use getAllRawData() instead which returns all datasets for all autoloaders present in the process. getRawData only returns the first dataset loaded, which may not be what you expect.\n     * @return array[]\n     * @psalm-return array{root: array{name: string, version: string, reference: string, pretty_version: string, aliases: string[], dev: bool, install_path: string}, versions: array<string, array{dev_requirement: bool, pretty_version?: string, version?: string, aliases?: string[], reference?: string, replaced?: string[], provided?: string[], install_path?: string}>}\n     *\/\n    public static function getRawData()\n    {\n        @trigger_error('getRawData only returns the first dataset loaded, which may not be what you expect. Use getAllRawData() instead which returns all datasets for all autoloaders present in the process.', E_USER_DEPRECATED);\n\n        if (null === self::$installed) {\n            \/\/ only require the installed.php file if this file is loaded from its dumped location,\n            \/\/ and not from its source location in the composer\/composer package, see https:\/\/github.com\/composer\/composer\/issues\/9937\n            if (substr(__DIR__, -8, 1) !== 'C') {\n                self::$installed = include __DIR__ . '\/installed.php';\n            } else {\n                self::$installed = array();\n            }\n        }\n\n        return self::$installed;\n    }\n\n    \/**\n     * Returns the raw data of all installed.php which are currently loaded for custom implementations\n     *\n     * @return array[]\n     * @psalm-return list<array{root: array{name: string, version: string, reference: string, pretty_version: string, aliases: string[], dev: bool, install_path: string}, versions: array<string, array{dev_requirement: bool, pretty_version?: string, version?: string, aliases?: string[], reference?: string, replaced?: string[], provided?: string[], install_path?: string}>}>\n     *\/\n    public static function getAllRawData()\n    {\n        return self::getInstalled();\n    }\n\n    \/**\n     * Lets you reload the static array from another file\n     *\n     * This is only useful for complex integrations in which a project needs to use\n     * this class but then also needs to execute another project's autoloader in process,\n     * and wants to ensure both projects have access to their version of installed.php.\n     *\n     * A typical case would be PHPUnit, where it would need to make sure it reads all\n     * the data it needs from this class, then call reload() with\n     * `require $CWD\/vendor\/composer\/installed.php` (or similar) as input to make sure\n     * the project in which it runs can then also use this class safely, without\n     * interference between PHPUnit's dependencies and the project's dependencies.\n     *\n     * @param  array[] $data A vendor\/composer\/installed.php data set\n     * @return void\n     *\n     * @psalm-param array{root: array{name: string, version: string, reference: string, pretty_version: string, aliases: string[], dev: bool, install_path: string}, versions: array<string, array{dev_requirement: bool, pretty_version?: string, version?: string, aliases?: string[], reference?: string, replaced?: string[], provided?: string[], install_path?: string}>} $data\n     *\/\n    public static function reload($data)\n    {\n        self::$installed = $data;\n        self::$installedByVendor = array();\n    }\n\n    \/**\n     * @return array[]\n     * @psalm-return list<array{root: array{name: string, version: string, reference: string, pretty_version: string, aliases: string[], dev: bool, install_path: string}, versions: array<string, array{dev_requirement: bool, pretty_version?: string, version?: string, aliases?: string[], reference?: string, replaced?: string[], provided?: string[], install_path?: string}>}>\n     *\/\n    private static function getInstalled()\n    {\n        if (null === self::$canGetVendors) {\n            self::$canGetVendors = method_exists('Composer\\Autoload\\ClassLoader', 'getRegisteredLoaders');\n        }\n\n        $installed = array();\n\n        if (self::$canGetVendors) {\n            foreach (ClassLoader::getRegisteredLoaders() as $vendorDir => $loader) {\n                if (isset(self::$installedByVendor[$vendorDir])) {\n                    $installed[] = self::$installedByVendor[$vendorDir];\n                } elseif (is_file($vendorDir.'\/composer\/installed.php')) {\n                    $installed[] = self::$installedByVendor[$vendorDir] = require $vendorDir.'\/composer\/installed.php';\n                    if (null === self::$installed && strtr($vendorDir.'\/composer', '\\\\', '\/') === strtr(__DIR__, '\\\\', '\/')) {\n                        self::$installed = $installed[count($installed) - 1];\n                    }\n                }\n            }\n        }\n\n        if (null === self::$installed) {\n            \/\/ only require the installed.php file if this file is loaded from its dumped location,\n            \/\/ and not from its source location in the composer\/composer package, see https:\/\/github.com\/composer\/composer\/issues\/9937\n            if (substr(__DIR__, -8, 1) !== 'C') {\n                self::$installed = require __DIR__ . '\/installed.php';\n            } else {\n                self::$installed = array();\n            }\n        }\n        $installed[] = self::$installed;\n\n        return $installed;\n    }\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/composer\/autoload_classmap.php","ext":"php","size":232,"mtime":1756374919,"type":"text","content":"<?php\n\n\/\/ autoload_classmap.php @generated by Composer\n\n$vendorDir = dirname(dirname(__FILE__));\n$baseDir = dirname($vendorDir);\n\nreturn array(\n    'Composer\\\\InstalledVersions' => $vendorDir . '\/composer\/InstalledVersions.php',\n);\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/composer\/installed.php","ext":"php","size":1508,"mtime":1756374919,"type":"text","content":"<?php return array(\n    'root' => array(\n        'pretty_version' => 'dev-master',\n        'version' => 'dev-master',\n        'type' => 'library',\n        'install_path' => __DIR__ . '\/..\/..\/',\n        'aliases' => array(),\n        'reference' => '4dbf15a23f788f9f3a3e57f5971bf957e5f9ba01',\n        'name' => '__root__',\n        'dev' => true,\n    ),\n    'versions' => array(\n        '__root__' => array(\n            'pretty_version' => 'dev-master',\n            'version' => 'dev-master',\n            'type' => 'library',\n            'install_path' => __DIR__ . '\/..\/..\/',\n            'aliases' => array(),\n            'reference' => '4dbf15a23f788f9f3a3e57f5971bf957e5f9ba01',\n            'dev_requirement' => false,\n        ),\n        'paragonie\/random_compat' => array(\n            'pretty_version' => 'v2.0.21',\n            'version' => '2.0.21.0',\n            'type' => 'library',\n            'install_path' => __DIR__ . '\/..\/paragonie\/random_compat',\n            'aliases' => array(),\n            'reference' => '96c132c7f2f7bc3230723b66e89f8f150b29d5ae',\n            'dev_requirement' => false,\n        ),\n        'paragonie\/sodium_compat' => array(\n            'pretty_version' => 'v1.20.0',\n            'version' => '1.20.0.0',\n            'type' => 'library',\n            'install_path' => __DIR__ . '\/..\/paragonie\/sodium_compat',\n            'aliases' => array(),\n            'reference' => 'e592a3e06d1fa0d43988c7c7d9948ca836f644b6',\n            'dev_requirement' => false,\n        ),\n    ),\n);\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/composer\/autoload_namespaces.php","ext":"php","size":149,"mtime":1756374919,"type":"text","content":"<?php\n\n\/\/ autoload_namespaces.php @generated by Composer\n\n$vendorDir = dirname(dirname(__FILE__));\n$baseDir = dirname($vendorDir);\n\nreturn array(\n);\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/composer\/ClassLoader.php","ext":"php","size":14389,"mtime":1756374919,"type":"text","content":"<?php\n\n\/*\n * This file is part of Composer.\n *\n * (c) Nils Adermann <naderman@naderman.de>\n *     Jordi Boggiano <j.boggiano@seld.be>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Composer\\Autoload;\n\n\/**\n * ClassLoader implements a PSR-0, PSR-4 and classmap class loader.\n *\n *     $loader = new \\Composer\\Autoload\\ClassLoader();\n *\n *     \/\/ register classes with namespaces\n *     $loader->add('Symfony\\Component', __DIR__.'\/component');\n *     $loader->add('Symfony',           __DIR__.'\/framework');\n *\n *     \/\/ activate the autoloader\n *     $loader->register();\n *\n *     \/\/ to enable searching the include path (eg. for PEAR packages)\n *     $loader->setUseIncludePath(true);\n *\n * In this example, if you try to use a class in the Symfony\\Component\n * namespace or one of its children (Symfony\\Component\\Console for instance),\n * the autoloader will first look for the class under the component\/\n * directory, and it will then fallback to the framework\/ directory if not\n * found before giving up.\n *\n * This class is loosely based on the Symfony UniversalClassLoader.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n * @author Jordi Boggiano <j.boggiano@seld.be>\n * @see    https:\/\/www.php-fig.org\/psr\/psr-0\/\n * @see    https:\/\/www.php-fig.org\/psr\/psr-4\/\n *\/\nclass ClassLoader\n{\n    private $vendorDir;\n\n    \/\/ PSR-4\n    private $prefixLengthsPsr4 = array();\n    private $prefixDirsPsr4 = array();\n    private $fallbackDirsPsr4 = array();\n\n    \/\/ PSR-0\n    private $prefixesPsr0 = array();\n    private $fallbackDirsPsr0 = array();\n\n    private $useIncludePath = false;\n    private $classMap = array();\n    private $classMapAuthoritative = false;\n    private $missingClasses = array();\n    private $apcuPrefix;\n\n    private static $registeredLoaders = array();\n\n    public function __construct($vendorDir = null)\n    {\n        $this->vendorDir = $vendorDir;\n    }\n\n    public function getPrefixes()\n    {\n        if (!empty($this->prefixesPsr0)) {\n            return call_user_func_array('array_merge', array_values($this->prefixesPsr0));\n        }\n\n        return array();\n    }\n\n    public function getPrefixesPsr4()\n    {\n        return $this->prefixDirsPsr4;\n    }\n\n    public function getFallbackDirs()\n    {\n        return $this->fallbackDirsPsr0;\n    }\n\n    public function getFallbackDirsPsr4()\n    {\n        return $this->fallbackDirsPsr4;\n    }\n\n    public function getClassMap()\n    {\n        return $this->classMap;\n    }\n\n    \/**\n     * @param array $classMap Class to filename map\n     *\/\n    public function addClassMap(array $classMap)\n    {\n        if ($this->classMap) {\n            $this->classMap = array_merge($this->classMap, $classMap);\n        } else {\n            $this->classMap = $classMap;\n        }\n    }\n\n    \/**\n     * Registers a set of PSR-0 directories for a given prefix, either\n     * appending or prepending to the ones previously set for this prefix.\n     *\n     * @param string       $prefix  The prefix\n     * @param array|string $paths   The PSR-0 root directories\n     * @param bool         $prepend Whether to prepend the directories\n     *\/\n    public function add($prefix, $paths, $prepend = false)\n    {\n        if (!$prefix) {\n            if ($prepend) {\n                $this->fallbackDirsPsr0 = array_merge(\n                    (array) $paths,\n                    $this->fallbackDirsPsr0\n                );\n            } else {\n                $this->fallbackDirsPsr0 = array_merge(\n                    $this->fallbackDirsPsr0,\n                    (array) $paths\n                );\n            }\n\n            return;\n        }\n\n        $first = $prefix[0];\n        if (!isset($this->prefixesPsr0[$first][$prefix])) {\n            $this->prefixesPsr0[$first][$prefix] = (array) $paths;\n\n            return;\n        }\n        if ($prepend) {\n            $this->prefixesPsr0[$first][$prefix] = array_merge(\n                (array) $paths,\n                $this->prefixesPsr0[$first][$prefix]\n            );\n        } else {\n            $this->prefixesPsr0[$first][$prefix] = array_merge(\n                $this->prefixesPsr0[$first][$prefix],\n                (array) $paths\n            );\n        }\n    }\n\n    \/**\n     * Registers a set of PSR-4 directories for a given namespace, either\n     * appending or prepending to the ones previously set for this namespace.\n     *\n     * @param string       $prefix  The prefix\/namespace, with trailing '\\\\'\n     * @param array|string $paths   The PSR-4 base directories\n     * @param bool         $prepend Whether to prepend the directories\n     *\n     * @throws \\InvalidArgumentException\n     *\/\n    public function addPsr4($prefix, $paths, $prepend = false)\n    {\n        if (!$prefix) {\n            \/\/ Register directories for the root namespace.\n            if ($prepend) {\n                $this->fallbackDirsPsr4 = array_merge(\n                    (array) $paths,\n                    $this->fallbackDirsPsr4\n                );\n            } else {\n                $this->fallbackDirsPsr4 = array_merge(\n                    $this->fallbackDirsPsr4,\n                    (array) $paths\n                );\n            }\n        } elseif (!isset($this->prefixDirsPsr4[$prefix])) {\n            \/\/ Register directories for a new namespace.\n            $length = strlen($prefix);\n            if ('\\\\' !== $prefix[$length - 1]) {\n                throw new \\InvalidArgumentException(\"A non-empty PSR-4 prefix must end with a namespace separator.\");\n            }\n            $this->prefixLengthsPsr4[$prefix[0]][$prefix] = $length;\n            $this->prefixDirsPsr4[$prefix] = (array) $paths;\n        } elseif ($prepend) {\n            \/\/ Prepend directories for an already registered namespace.\n            $this->prefixDirsPsr4[$prefix] = array_merge(\n                (array) $paths,\n                $this->prefixDirsPsr4[$prefix]\n            );\n        } else {\n            \/\/ Append directories for an already registered namespace.\n            $this->prefixDirsPsr4[$prefix] = array_merge(\n                $this->prefixDirsPsr4[$prefix],\n                (array) $paths\n            );\n        }\n    }\n\n    \/**\n     * Registers a set of PSR-0 directories for a given prefix,\n     * replacing any others previously set for this prefix.\n     *\n     * @param string       $prefix The prefix\n     * @param array|string $paths  The PSR-0 base directories\n     *\/\n    public function set($prefix, $paths)\n    {\n        if (!$prefix) {\n            $this->fallbackDirsPsr0 = (array) $paths;\n        } else {\n            $this->prefixesPsr0[$prefix[0]][$prefix] = (array) $paths;\n        }\n    }\n\n    \/**\n     * Registers a set of PSR-4 directories for a given namespace,\n     * replacing any others previously set for this namespace.\n     *\n     * @param string       $prefix The prefix\/namespace, with trailing '\\\\'\n     * @param array|string $paths  The PSR-4 base directories\n     *\n     * @throws \\InvalidArgumentException\n     *\/\n    public function setPsr4($prefix, $paths)\n    {\n        if (!$prefix) {\n            $this->fallbackDirsPsr4 = (array) $paths;\n        } else {\n            $length = strlen($prefix);\n            if ('\\\\' !== $prefix[$length - 1]) {\n                throw new \\InvalidArgumentException(\"A non-empty PSR-4 prefix must end with a namespace separator.\");\n            }\n            $this->prefixLengthsPsr4[$prefix[0]][$prefix] = $length;\n            $this->prefixDirsPsr4[$prefix] = (array) $paths;\n        }\n    }\n\n    \/**\n     * Turns on searching the include path for class files.\n     *\n     * @param bool $useIncludePath\n     *\/\n    public function setUseIncludePath($useIncludePath)\n    {\n        $this->useIncludePath = $useIncludePath;\n    }\n\n    \/**\n     * Can be used to check if the autoloader uses the include path to check\n     * for classes.\n     *\n     * @return bool\n     *\/\n    public function getUseIncludePath()\n    {\n        return $this->useIncludePath;\n    }\n\n    \/**\n     * Turns off searching the prefix and fallback directories for classes\n     * that have not been registered with the class map.\n     *\n     * @param bool $classMapAuthoritative\n     *\/\n    public function setClassMapAuthoritative($classMapAuthoritative)\n    {\n        $this->classMapAuthoritative = $classMapAuthoritative;\n    }\n\n    \/**\n     * Should class lookup fail if not found in the current class map?\n     *\n     * @return bool\n     *\/\n    public function isClassMapAuthoritative()\n    {\n        return $this->classMapAuthoritative;\n    }\n\n    \/**\n     * APCu prefix to use to cache found\/not-found classes, if the extension is enabled.\n     *\n     * @param string|null $apcuPrefix\n     *\/\n    public function setApcuPrefix($apcuPrefix)\n    {\n        $this->apcuPrefix = function_exists('apcu_fetch') && filter_var(ini_get('apc.enabled'), FILTER_VALIDATE_BOOLEAN) ? $apcuPrefix : null;\n    }\n\n    \/**\n     * The APCu prefix in use, or null if APCu caching is not enabled.\n     *\n     * @return string|null\n     *\/\n    public function getApcuPrefix()\n    {\n        return $this->apcuPrefix;\n    }\n\n    \/**\n     * Registers this instance as an autoloader.\n     *\n     * @param bool $prepend Whether to prepend the autoloader or not\n     *\/\n    public function register($prepend = false)\n    {\n        spl_autoload_register(array($this, 'loadClass'), true, $prepend);\n\n        if (null === $this->vendorDir) {\n            return;\n        }\n\n        if ($prepend) {\n            self::$registeredLoaders = array($this->vendorDir => $this) + self::$registeredLoaders;\n        } else {\n            unset(self::$registeredLoaders[$this->vendorDir]);\n            self::$registeredLoaders[$this->vendorDir] = $this;\n        }\n    }\n\n    \/**\n     * Unregisters this instance as an autoloader.\n     *\/\n    public function unregister()\n    {\n        spl_autoload_unregister(array($this, 'loadClass'));\n\n        if (null !== $this->vendorDir) {\n            unset(self::$registeredLoaders[$this->vendorDir]);\n        }\n    }\n\n    \/**\n     * Loads the given class or interface.\n     *\n     * @param  string    $class The name of the class\n     * @return true|null True if loaded, null otherwise\n     *\/\n    public function loadClass($class)\n    {\n        if ($file = $this->findFile($class)) {\n            includeFile($file);\n\n            return true;\n        }\n\n        return null;\n    }\n\n    \/**\n     * Finds the path to the file where the class is defined.\n     *\n     * @param string $class The name of the class\n     *\n     * @return string|false The path if found, false otherwise\n     *\/\n    public function findFile($class)\n    {\n        \/\/ class map lookup\n        if (isset($this->classMap[$class])) {\n            return $this->classMap[$class];\n        }\n        if ($this->classMapAuthoritative || isset($this->missingClasses[$class])) {\n            return false;\n        }\n        if (null !== $this->apcuPrefix) {\n            $file = apcu_fetch($this->apcuPrefix.$class, $hit);\n            if ($hit) {\n                return $file;\n            }\n        }\n\n        $file = $this->findFileWithExtension($class, '.php');\n\n        \/\/ Search for Hack files if we are running on HHVM\n        if (false === $file && defined('HHVM_VERSION')) {\n            $file = $this->findFileWithExtension($class, '.hh');\n        }\n\n        if (null !== $this->apcuPrefix) {\n            apcu_add($this->apcuPrefix.$class, $file);\n        }\n\n        if (false === $file) {\n            \/\/ Remember that this class does not exist.\n            $this->missingClasses[$class] = true;\n        }\n\n        return $file;\n    }\n\n    \/**\n     * Returns the currently registered loaders indexed by their corresponding vendor directories.\n     *\n     * @return self[]\n     *\/\n    public static function getRegisteredLoaders()\n    {\n        return self::$registeredLoaders;\n    }\n\n    private function findFileWithExtension($class, $ext)\n    {\n        \/\/ PSR-4 lookup\n        $logicalPathPsr4 = strtr($class, '\\\\', DIRECTORY_SEPARATOR) . $ext;\n\n        $first = $class[0];\n        if (isset($this->prefixLengthsPsr4[$first])) {\n            $subPath = $class;\n            while (false !== $lastPos = strrpos($subPath, '\\\\')) {\n                $subPath = substr($subPath, 0, $lastPos);\n                $search = $subPath . '\\\\';\n                if (isset($this->prefixDirsPsr4[$search])) {\n                    $pathEnd = DIRECTORY_SEPARATOR . substr($logicalPathPsr4, $lastPos + 1);\n                    foreach ($this->prefixDirsPsr4[$search] as $dir) {\n                        if (file_exists($file = $dir . $pathEnd)) {\n                            return $file;\n                        }\n                    }\n                }\n            }\n        }\n\n        \/\/ PSR-4 fallback dirs\n        foreach ($this->fallbackDirsPsr4 as $dir) {\n            if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr4)) {\n                return $file;\n            }\n        }\n\n        \/\/ PSR-0 lookup\n        if (false !== $pos = strrpos($class, '\\\\')) {\n            \/\/ namespaced class name\n            $logicalPathPsr0 = substr($logicalPathPsr4, 0, $pos + 1)\n                . strtr(substr($logicalPathPsr4, $pos + 1), '_', DIRECTORY_SEPARATOR);\n        } else {\n            \/\/ PEAR-like class name\n            $logicalPathPsr0 = strtr($class, '_', DIRECTORY_SEPARATOR) . $ext;\n        }\n\n        if (isset($this->prefixesPsr0[$first])) {\n            foreach ($this->prefixesPsr0[$first] as $prefix => $dirs) {\n                if (0 === strpos($class, $prefix)) {\n                    foreach ($dirs as $dir) {\n                        if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {\n                            return $file;\n                        }\n                    }\n                }\n            }\n        }\n\n        \/\/ PSR-0 fallback dirs\n        foreach ($this->fallbackDirsPsr0 as $dir) {\n            if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {\n                return $file;\n            }\n        }\n\n        \/\/ PSR-0 include paths.\n        if ($this->useIncludePath && $file = stream_resolve_include_path($logicalPathPsr0)) {\n            return $file;\n        }\n\n        return false;\n    }\n}\n\n\/**\n * Scope isolated include.\n *\n * Prevents access to $this\/self from included files.\n *\/\nfunction includeFile($file)\n{\n    include $file;\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/composer\/autoload_files.php","ext":"php","size":338,"mtime":1756374919,"type":"text","content":"<?php\n\n\/\/ autoload_files.php @generated by Composer\n\n$vendorDir = dirname(dirname(__FILE__));\n$baseDir = dirname($vendorDir);\n\nreturn array(\n    '5255c38a0faeba867671b61dfda6d864' => $vendorDir . '\/paragonie\/random_compat\/lib\/random.php',\n    '3109cb1a231dcd04bee1f9f620d46975' => $vendorDir . '\/paragonie\/sodium_compat\/autoload.php',\n);\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/composer\/autoload_static.php","ext":"php","size":807,"mtime":1756374919,"type":"text","content":"<?php\n\n\/\/ autoload_static.php @generated by Composer\n\nnamespace Composer\\Autoload;\n\nclass ComposerStaticInite213e65b2dafae4ad799b13fe0d36f8e\n{\n    public static $files = array (\n        '5255c38a0faeba867671b61dfda6d864' => __DIR__ . '\/..' . '\/paragonie\/random_compat\/lib\/random.php',\n        '3109cb1a231dcd04bee1f9f620d46975' => __DIR__ . '\/..' . '\/paragonie\/sodium_compat\/autoload.php',\n    );\n\n    public static $classMap = array (\n        'Composer\\\\InstalledVersions' => __DIR__ . '\/..' . '\/composer\/InstalledVersions.php',\n    );\n\n    public static function getInitializer(ClassLoader $loader)\n    {\n        return \\Closure::bind(function () use ($loader) {\n            $loader->classMap = ComposerStaticInite213e65b2dafae4ad799b13fe0d36f8e::$classMap;\n\n        }, null, ClassLoader::class);\n    }\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/composer\/platform_check.php","ext":"php","size":925,"mtime":1756374919,"type":"text","content":"<?php\n\n\/\/ platform_check.php @generated by Composer\n\n$issues = array();\n\nif (!(PHP_VERSION_ID >= 50204)) {\n    $issues[] = 'Your Composer dependencies require a PHP version \">= 5.2.4\". You are running ' . PHP_VERSION . '.';\n}\n\nif ($issues) {\n    if (!headers_sent()) {\n        header('HTTP\/1.1 500 Internal Server Error');\n    }\n    if (!ini_get('display_errors')) {\n        if (PHP_SAPI === 'cli' || PHP_SAPI === 'phpdbg') {\n            fwrite(STDERR, 'Composer detected issues in your platform:' . PHP_EOL.PHP_EOL . implode(PHP_EOL, $issues) . PHP_EOL.PHP_EOL);\n        } elseif (!headers_sent()) {\n            echo 'Composer detected issues in your platform:' . PHP_EOL.PHP_EOL . str_replace('You are running '.PHP_VERSION.'.', '', implode(PHP_EOL, $issues)) . PHP_EOL.PHP_EOL;\n        }\n    }\n    trigger_error(\n        'Composer detected issues in your platform: ' . implode(' ', $issues),\n        E_USER_ERROR\n    );\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/composer\/autoload_real.php","ext":"php","size":2549,"mtime":1756374919,"type":"text","content":"<?php\n\n\/\/ autoload_real.php @generated by Composer\n\nclass ComposerAutoloaderInite213e65b2dafae4ad799b13fe0d36f8e\n{\n    private static $loader;\n\n    public static function loadClassLoader($class)\n    {\n        if ('Composer\\Autoload\\ClassLoader' === $class) {\n            require __DIR__ . '\/ClassLoader.php';\n        }\n    }\n\n    \/**\n     * @return \\Composer\\Autoload\\ClassLoader\n     *\/\n    public static function getLoader()\n    {\n        if (null !== self::$loader) {\n            return self::$loader;\n        }\n\n        require __DIR__ . '\/platform_check.php';\n\n        spl_autoload_register(array('ComposerAutoloaderInite213e65b2dafae4ad799b13fe0d36f8e', 'loadClassLoader'), true, true);\n        self::$loader = $loader = new \\Composer\\Autoload\\ClassLoader(\\dirname(\\dirname(__FILE__)));\n        spl_autoload_unregister(array('ComposerAutoloaderInite213e65b2dafae4ad799b13fe0d36f8e', 'loadClassLoader'));\n\n        $useStaticLoader = PHP_VERSION_ID >= 50600 && !defined('HHVM_VERSION') && (!function_exists('zend_loader_file_encoded') || !zend_loader_file_encoded());\n        if ($useStaticLoader) {\n            require __DIR__ . '\/autoload_static.php';\n\n            call_user_func(\\Composer\\Autoload\\ComposerStaticInite213e65b2dafae4ad799b13fe0d36f8e::getInitializer($loader));\n        } else {\n            $map = require __DIR__ . '\/autoload_namespaces.php';\n            foreach ($map as $namespace => $path) {\n                $loader->set($namespace, $path);\n            }\n\n            $map = require __DIR__ . '\/autoload_psr4.php';\n            foreach ($map as $namespace => $path) {\n                $loader->setPsr4($namespace, $path);\n            }\n\n            $classMap = require __DIR__ . '\/autoload_classmap.php';\n            if ($classMap) {\n                $loader->addClassMap($classMap);\n            }\n        }\n\n        $loader->register(true);\n\n        if ($useStaticLoader) {\n            $includeFiles = Composer\\Autoload\\ComposerStaticInite213e65b2dafae4ad799b13fe0d36f8e::$files;\n        } else {\n            $includeFiles = require __DIR__ . '\/autoload_files.php';\n        }\n        foreach ($includeFiles as $fileIdentifier => $file) {\n            composerRequiree213e65b2dafae4ad799b13fe0d36f8e($fileIdentifier, $file);\n        }\n\n        return $loader;\n    }\n}\n\nfunction composerRequiree213e65b2dafae4ad799b13fe0d36f8e($fileIdentifier, $file)\n{\n    if (empty($GLOBALS['__composer_autoload_files'][$fileIdentifier])) {\n        require $file;\n\n        $GLOBALS['__composer_autoload_files'][$fileIdentifier] = true;\n    }\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/lib\/namespaced.php","ext":"php","size":1404,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\n\nrequire_once dirname(dirname(__FILE__)) . '\/autoload.php';\n\nif (PHP_VERSION_ID < 50300) {\n    return;\n}\n\n\/*\n * This file is just for convenience, to allow developers to reduce verbosity when\n * they add this project to their libraries.\n *\n * Replace this:\n *\n * $x = ParagonIE_Sodium_Compat::crypto_aead_xchacha20poly1305_encrypt(...$args);\n *\n * with this:\n *\n * use ParagonIE\\Sodium\\Compat;\n *\n * $x = Compat::crypto_aead_xchacha20poly1305_encrypt(...$args);\n *\/\nspl_autoload_register(function ($class) {\n    if ($class[0] === '\\\\') {\n        $class = substr($class, 1);\n    }\n    $namespace = 'ParagonIE\\\\Sodium';\n    \/\/ Does the class use the namespace prefix?\n    $len = strlen($namespace);\n    if (strncmp($namespace, $class, $len) !== 0) {\n        \/\/ no, move to the next registered autoloader\n        return false;\n    }\n\n    \/\/ Get the relative class name\n    $relative_class = substr($class, $len);\n\n    \/\/ Replace the namespace prefix with the base directory, replace namespace\n    \/\/ separators with directory separators in the relative class name, append\n    \/\/ with .php\n    $file = dirname(dirname(__FILE__)) . '\/namespaced\/' . str_replace('\\\\', '\/', $relative_class) . '.php';\n    \/\/ if the file exists, require it\n    if (file_exists($file)) {\n        require_once $file;\n        return true;\n    }\n    return false;\n});\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/lib\/php72compat.php","ext":"php","size":43596,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\n\nrequire_once dirname(dirname(__FILE__)) . '\/autoload.php';\n\n\/**\n * This file will monkey patch the pure-PHP implementation in place of the\n * PECL functions and constants, but only if they do not already exist.\n *\n * Thus, the functions or constants just proxy to the appropriate\n * ParagonIE_Sodium_Compat method or class constant, respectively.\n *\/\nforeach (array(\n    'BASE64_VARIANT_ORIGINAL',\n    'BASE64_VARIANT_ORIGINAL_NO_PADDING',\n    'BASE64_VARIANT_URLSAFE',\n    'BASE64_VARIANT_URLSAFE_NO_PADDING',\n    'CRYPTO_AEAD_CHACHA20POLY1305_KEYBYTES',\n    'CRYPTO_AEAD_CHACHA20POLY1305_NSECBYTES',\n    'CRYPTO_AEAD_CHACHA20POLY1305_NPUBBYTES',\n    'CRYPTO_AEAD_CHACHA20POLY1305_ABYTES',\n    'CRYPTO_AEAD_AES256GCM_KEYBYTES',\n    'CRYPTO_AEAD_AES256GCM_NSECBYTES',\n    'CRYPTO_AEAD_AES256GCM_NPUBBYTES',\n    'CRYPTO_AEAD_AES256GCM_ABYTES',\n    'CRYPTO_AEAD_CHACHA20POLY1305_IETF_KEYBYTES',\n    'CRYPTO_AEAD_CHACHA20POLY1305_IETF_NSECBYTES',\n    'CRYPTO_AEAD_CHACHA20POLY1305_IETF_NPUBBYTES',\n    'CRYPTO_AEAD_CHACHA20POLY1305_IETF_ABYTES',\n    'CRYPTO_AEAD_XCHACHA20POLY1305_IETF_KEYBYTES',\n    'CRYPTO_AEAD_XCHACHA20POLY1305_IETF_NSECBYTES',\n    'CRYPTO_AEAD_XCHACHA20POLY1305_IETF_NPUBBYTES',\n    'CRYPTO_AEAD_XCHACHA20POLY1305_IETF_ABYTES',\n    'CRYPTO_AUTH_BYTES',\n    'CRYPTO_AUTH_KEYBYTES',\n    'CRYPTO_BOX_SEALBYTES',\n    'CRYPTO_BOX_SECRETKEYBYTES',\n    'CRYPTO_BOX_PUBLICKEYBYTES',\n    'CRYPTO_BOX_KEYPAIRBYTES',\n    'CRYPTO_BOX_MACBYTES',\n    'CRYPTO_BOX_NONCEBYTES',\n    'CRYPTO_BOX_SEEDBYTES',\n    'CRYPTO_KDF_BYTES_MIN',\n    'CRYPTO_KDF_BYTES_MAX',\n    'CRYPTO_KDF_CONTEXTBYTES',\n    'CRYPTO_KDF_KEYBYTES',\n    'CRYPTO_KX_BYTES',\n    'CRYPTO_KX_KEYPAIRBYTES',\n    'CRYPTO_KX_PRIMITIVE',\n    'CRYPTO_KX_SEEDBYTES',\n    'CRYPTO_KX_PUBLICKEYBYTES',\n    'CRYPTO_KX_SECRETKEYBYTES',\n    'CRYPTO_KX_SESSIONKEYBYTES',\n    'CRYPTO_GENERICHASH_BYTES',\n    'CRYPTO_GENERICHASH_BYTES_MIN',\n    'CRYPTO_GENERICHASH_BYTES_MAX',\n    'CRYPTO_GENERICHASH_KEYBYTES',\n    'CRYPTO_GENERICHASH_KEYBYTES_MIN',\n    'CRYPTO_GENERICHASH_KEYBYTES_MAX',\n    'CRYPTO_PWHASH_SALTBYTES',\n    'CRYPTO_PWHASH_STRPREFIX',\n    'CRYPTO_PWHASH_ALG_ARGON2I13',\n    'CRYPTO_PWHASH_ALG_ARGON2ID13',\n    'CRYPTO_PWHASH_MEMLIMIT_INTERACTIVE',\n    'CRYPTO_PWHASH_OPSLIMIT_INTERACTIVE',\n    'CRYPTO_PWHASH_MEMLIMIT_MODERATE',\n    'CRYPTO_PWHASH_OPSLIMIT_MODERATE',\n    'CRYPTO_PWHASH_MEMLIMIT_SENSITIVE',\n    'CRYPTO_PWHASH_OPSLIMIT_SENSITIVE',\n    'CRYPTO_PWHASH_SCRYPTSALSA208SHA256_SALTBYTES',\n    'CRYPTO_PWHASH_SCRYPTSALSA208SHA256_STRPREFIX',\n    'CRYPTO_PWHASH_SCRYPTSALSA208SHA256_MEMLIMIT_INTERACTIVE',\n    'CRYPTO_PWHASH_SCRYPTSALSA208SHA256_OPSLIMIT_INTERACTIVE',\n    'CRYPTO_PWHASH_SCRYPTSALSA208SHA256_MEMLIMIT_SENSITIVE',\n    'CRYPTO_PWHASH_SCRYPTSALSA208SHA256_OPSLIMIT_SENSITIVE',\n    'CRYPTO_SCALARMULT_BYTES',\n    'CRYPTO_SCALARMULT_SCALARBYTES',\n    'CRYPTO_SHORTHASH_BYTES',\n    'CRYPTO_SHORTHASH_KEYBYTES',\n    'CRYPTO_SECRETBOX_KEYBYTES',\n    'CRYPTO_SECRETBOX_MACBYTES',\n    'CRYPTO_SECRETBOX_NONCEBYTES',\n    'CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_ABYTES',\n    'CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_HEADERBYTES',\n    'CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_KEYBYTES',\n    'CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_TAG_PUSH',\n    'CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_TAG_PULL',\n    'CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_TAG_REKEY',\n    'CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_TAG_FINAL',\n    'CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_MESSAGEBYTES_MAX',\n    'CRYPTO_SIGN_BYTES',\n    'CRYPTO_SIGN_SEEDBYTES',\n    'CRYPTO_SIGN_PUBLICKEYBYTES',\n    'CRYPTO_SIGN_SECRETKEYBYTES',\n    'CRYPTO_SIGN_KEYPAIRBYTES',\n    'CRYPTO_STREAM_KEYBYTES',\n    'CRYPTO_STREAM_NONCEBYTES',\n    'CRYPTO_STREAM_XCHACHA20_KEYBYTES',\n    'CRYPTO_STREAM_XCHACHA20_NONCEBYTES',\n    'LIBRARY_MAJOR_VERSION',\n    'LIBRARY_MINOR_VERSION',\n    'LIBRARY_VERSION_MAJOR',\n    'LIBRARY_VERSION_MINOR',\n    'VERSION_STRING'\n    ) as $constant\n) {\n    if (!defined(\"SODIUM_$constant\") && defined(\"ParagonIE_Sodium_Compat::$constant\")) {\n        define(\"SODIUM_$constant\", constant(\"ParagonIE_Sodium_Compat::$constant\"));\n    }\n}\nif (!is_callable('sodium_add')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::add()\n     * @param string $string1\n     * @param string $string2\n     * @return void\n     * @throws SodiumException\n     *\/\n    function sodium_add(&$string1, $string2)\n    {\n        ParagonIE_Sodium_Compat::add($string1, $string2);\n    }\n}\nif (!is_callable('sodium_base642bin')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::bin2base64()\n     * @param string $string\n     * @param int $variant\n     * @param string $ignore\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_base642bin($string, $variant, $ignore ='')\n    {\n        return ParagonIE_Sodium_Compat::base642bin($string, $variant, $ignore);\n    }\n}\nif (!is_callable('sodium_bin2base64')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::bin2base64()\n     * @param string $string\n     * @param int $variant\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_bin2base64($string, $variant)\n    {\n        return ParagonIE_Sodium_Compat::bin2base64($string, $variant);\n    }\n}\nif (!is_callable('sodium_bin2hex')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::hex2bin()\n     * @param string $string\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_bin2hex($string)\n    {\n        return ParagonIE_Sodium_Compat::bin2hex($string);\n    }\n}\nif (!is_callable('sodium_compare')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::compare()\n     * @param string $string1\n     * @param string $string2\n     * @return int\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_compare($string1, $string2)\n    {\n        return ParagonIE_Sodium_Compat::compare($string1, $string2);\n    }\n}\nif (!is_callable('sodium_crypto_aead_aes256gcm_decrypt')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_aead_aes256gcm_decrypt()\n     * @param string $ciphertext\n     * @param string $additional_data\n     * @param string $nonce\n     * @param string $key\n     * @return string|bool\n     *\/\n    function sodium_crypto_aead_aes256gcm_decrypt($ciphertext, $additional_data, $nonce, $key)\n    {\n        try {\n            return ParagonIE_Sodium_Compat::crypto_aead_aes256gcm_decrypt(\n                $ciphertext,\n                $additional_data,\n                $nonce,\n                $key\n            );\n        } catch (Error $ex) {\n            return false;\n        } catch (Exception $ex) {\n            if (($ex instanceof SodiumException) && ($ex->getMessage() === 'AES-256-GCM is not available')) {\n                throw $ex;\n            }\n            return false;\n        }\n    }\n}\nif (!is_callable('sodium_crypto_aead_aes256gcm_encrypt')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_aead_aes256gcm_encrypt()\n     * @param string $message\n     * @param string $additional_data\n     * @param string $nonce\n     * @param string $key\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_aead_aes256gcm_encrypt($message, $additional_data, $nonce, $key)\n    {\n        return ParagonIE_Sodium_Compat::crypto_aead_aes256gcm_encrypt($message, $additional_data, $nonce, $key);\n    }\n}\nif (!is_callable('sodium_crypto_aead_aes256gcm_is_available')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_aead_aes256gcm_is_available()\n     * @return bool\n     *\/\n    function sodium_crypto_aead_aes256gcm_is_available()\n    {\n        return ParagonIE_Sodium_Compat::crypto_aead_aes256gcm_is_available();\n    }\n}\nif (!is_callable('sodium_crypto_aead_chacha20poly1305_decrypt')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_aead_chacha20poly1305_decrypt()\n     * @param string $ciphertext\n     * @param string $additional_data\n     * @param string $nonce\n     * @param string $key\n     * @return string|bool\n     *\/\n    function sodium_crypto_aead_chacha20poly1305_decrypt($ciphertext, $additional_data, $nonce, $key)\n    {\n        try {\n            return ParagonIE_Sodium_Compat::crypto_aead_chacha20poly1305_decrypt(\n                $ciphertext,\n                $additional_data,\n                $nonce,\n                $key\n            );\n        } catch (Error $ex) {\n            return false;\n        } catch (Exception $ex) {\n            return false;\n        }\n    }\n}\nif (!is_callable('sodium_crypto_aead_chacha20poly1305_encrypt')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_aead_chacha20poly1305_encrypt()\n     * @param string $message\n     * @param string $additional_data\n     * @param string $nonce\n     * @param string $key\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_aead_chacha20poly1305_encrypt($message, $additional_data, $nonce, $key)\n    {\n        return ParagonIE_Sodium_Compat::crypto_aead_chacha20poly1305_encrypt(\n            $message,\n            $additional_data,\n            $nonce,\n            $key\n        );\n    }\n}\nif (!is_callable('sodium_crypto_aead_chacha20poly1305_keygen')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_aead_chacha20poly1305_keygen()\n     * @return string\n     * @throws Exception\n     *\/\n    function sodium_crypto_aead_chacha20poly1305_keygen()\n    {\n        return ParagonIE_Sodium_Compat::crypto_aead_chacha20poly1305_keygen();\n    }\n}\nif (!is_callable('sodium_crypto_aead_chacha20poly1305_ietf_decrypt')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_aead_chacha20poly1305_ietf_decrypt()\n     * @param string $message\n     * @param string $additional_data\n     * @param string $nonce\n     * @param string $key\n     * @return string|bool\n     *\/\n    function sodium_crypto_aead_chacha20poly1305_ietf_decrypt($message, $additional_data, $nonce, $key)\n    {\n        try {\n            return ParagonIE_Sodium_Compat::crypto_aead_chacha20poly1305_ietf_decrypt(\n                $message,\n                $additional_data,\n                $nonce,\n                $key\n            );\n        } catch (Error $ex) {\n            return false;\n        } catch (Exception $ex) {\n            return false;\n        }\n    }\n}\nif (!is_callable('sodium_crypto_aead_chacha20poly1305_ietf_encrypt')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_aead_chacha20poly1305_ietf_encrypt()\n     * @param string $message\n     * @param string $additional_data\n     * @param string $nonce\n     * @param string $key\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_aead_chacha20poly1305_ietf_encrypt($message, $additional_data, $nonce, $key)\n    {\n        return ParagonIE_Sodium_Compat::crypto_aead_chacha20poly1305_ietf_encrypt(\n            $message,\n            $additional_data,\n            $nonce,\n            $key\n        );\n    }\n}\nif (!is_callable('sodium_crypto_aead_chacha20poly1305_ietf_keygen')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_aead_chacha20poly1305_ietf_keygen()\n     * @return string\n     * @throws Exception\n     *\/\n    function sodium_crypto_aead_chacha20poly1305_ietf_keygen()\n    {\n        return ParagonIE_Sodium_Compat::crypto_aead_chacha20poly1305_ietf_keygen();\n    }\n}\nif (!is_callable('sodium_crypto_aead_xchacha20poly1305_ietf_decrypt')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_aead_xchacha20poly1305_ietf_decrypt()\n     * @param string $ciphertext\n     * @param string $additional_data\n     * @param string $nonce\n     * @param string $key\n     * @return string|bool\n     *\/\n    function sodium_crypto_aead_xchacha20poly1305_ietf_decrypt($ciphertext, $additional_data, $nonce, $key)\n    {\n        try {\n            return ParagonIE_Sodium_Compat::crypto_aead_xchacha20poly1305_ietf_decrypt(\n                $ciphertext,\n                $additional_data,\n                $nonce,\n                $key,\n                true\n            );\n        } catch (Error $ex) {\n            return false;\n        } catch (Exception $ex) {\n            return false;\n        }\n    }\n}\nif (!is_callable('sodium_crypto_aead_xchacha20poly1305_ietf_encrypt')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_aead_xchacha20poly1305_ietf_encrypt()\n     * @param string $message\n     * @param string $additional_data\n     * @param string $nonce\n     * @param string $key\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_aead_xchacha20poly1305_ietf_encrypt(\n        $message,\n        $additional_data,\n        $nonce,\n        $key\n    ) {\n        return ParagonIE_Sodium_Compat::crypto_aead_xchacha20poly1305_ietf_encrypt(\n            $message,\n            $additional_data,\n            $nonce,\n            $key,\n            true\n        );\n    }\n}\nif (!is_callable('sodium_crypto_aead_xchacha20poly1305_ietf_keygen')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_aead_xchacha20poly1305_ietf_keygen()\n     * @return string\n     * @throws Exception\n     *\/\n    function sodium_crypto_aead_xchacha20poly1305_ietf_keygen()\n    {\n        return ParagonIE_Sodium_Compat::crypto_aead_xchacha20poly1305_ietf_keygen();\n    }\n}\nif (!is_callable('sodium_crypto_auth')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_auth()\n     * @param string $message\n     * @param string $key\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_auth($message, $key)\n    {\n        return ParagonIE_Sodium_Compat::crypto_auth($message, $key);\n    }\n}\nif (!is_callable('sodium_crypto_auth_keygen')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_auth_keygen()\n     * @return string\n     * @throws Exception\n     *\/\n    function sodium_crypto_auth_keygen()\n    {\n        return ParagonIE_Sodium_Compat::crypto_auth_keygen();\n    }\n}\nif (!is_callable('sodium_crypto_auth_verify')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_auth_verify()\n     * @param string $mac\n     * @param string $message\n     * @param string $key\n     * @return bool\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_auth_verify($mac, $message, $key)\n    {\n        return ParagonIE_Sodium_Compat::crypto_auth_verify($mac, $message, $key);\n    }\n}\nif (!is_callable('sodium_crypto_box')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_box()\n     * @param string $message\n     * @param string $nonce\n     * @param string $key_pair\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_box($message, $nonce, $key_pair)\n    {\n        return ParagonIE_Sodium_Compat::crypto_box($message, $nonce, $key_pair);\n    }\n}\nif (!is_callable('sodium_crypto_box_keypair')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_box_keypair()\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_box_keypair()\n    {\n        return ParagonIE_Sodium_Compat::crypto_box_keypair();\n    }\n}\nif (!is_callable('sodium_crypto_box_keypair_from_secretkey_and_publickey')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_box_keypair_from_secretkey_and_publickey()\n     * @param string $secret_key\n     * @param string $public_key\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_box_keypair_from_secretkey_and_publickey($secret_key, $public_key)\n    {\n        return ParagonIE_Sodium_Compat::crypto_box_keypair_from_secretkey_and_publickey($secret_key, $public_key);\n    }\n}\nif (!is_callable('sodium_crypto_box_open')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_box_open()\n     * @param string $ciphertext\n     * @param string $nonce\n     * @param string $key_pair\n     * @return string|bool\n     *\/\n    function sodium_crypto_box_open($ciphertext, $nonce, $key_pair)\n    {\n        try {\n            return ParagonIE_Sodium_Compat::crypto_box_open($ciphertext, $nonce, $key_pair);\n        } catch (Error $ex) {\n            return false;\n        } catch (Exception $ex) {\n            return false;\n        }\n    }\n}\nif (!is_callable('sodium_crypto_box_publickey')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_box_publickey()\n     * @param string $key_pair\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_box_publickey($key_pair)\n    {\n        return ParagonIE_Sodium_Compat::crypto_box_publickey($key_pair);\n    }\n}\nif (!is_callable('sodium_crypto_box_publickey_from_secretkey')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_box_publickey_from_secretkey()\n     * @param string $secret_key\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_box_publickey_from_secretkey($secret_key)\n    {\n        return ParagonIE_Sodium_Compat::crypto_box_publickey_from_secretkey($secret_key);\n    }\n}\nif (!is_callable('sodium_crypto_box_seal')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_box_seal()\n     * @param string $message\n     * @param string $public_key\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_box_seal($message, $public_key)\n    {\n        return ParagonIE_Sodium_Compat::crypto_box_seal($message, $public_key);\n    }\n}\nif (!is_callable('sodium_crypto_box_seal_open')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_box_seal_open()\n     * @param string $message\n     * @param string $key_pair\n     * @return string|bool\n     * @throws SodiumException\n     *\/\n    function sodium_crypto_box_seal_open($message, $key_pair)\n    {\n        try {\n            return ParagonIE_Sodium_Compat::crypto_box_seal_open($message, $key_pair);\n        } catch (SodiumException $ex) {\n            if ($ex->getMessage() === 'Argument 2 must be CRYPTO_BOX_KEYPAIRBYTES long.') {\n                throw $ex;\n            }\n            return false;\n        }\n    }\n}\nif (!is_callable('sodium_crypto_box_secretkey')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_box_secretkey()\n     * @param string $key_pair\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_box_secretkey($key_pair)\n    {\n        return ParagonIE_Sodium_Compat::crypto_box_secretkey($key_pair);\n    }\n}\nif (!is_callable('sodium_crypto_box_seed_keypair')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_box_seed_keypair()\n     * @param string $seed\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_box_seed_keypair($seed)\n    {\n        return ParagonIE_Sodium_Compat::crypto_box_seed_keypair($seed);\n    }\n}\nif (!is_callable('sodium_crypto_generichash')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_generichash()\n     * @param string $message\n     * @param string|null $key\n     * @param int $length\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_generichash($message, $key = null, $length = 32)\n    {\n        return ParagonIE_Sodium_Compat::crypto_generichash($message, $key, $length);\n    }\n}\nif (!is_callable('sodium_crypto_generichash_final')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_generichash_final()\n     * @param string|null $state\n     * @param int $outputLength\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_generichash_final(&$state, $outputLength = 32)\n    {\n        return ParagonIE_Sodium_Compat::crypto_generichash_final($state, $outputLength);\n    }\n}\nif (!is_callable('sodium_crypto_generichash_init')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_generichash_init()\n     * @param string|null $key\n     * @param int $length\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_generichash_init($key = null, $length = 32)\n    {\n        return ParagonIE_Sodium_Compat::crypto_generichash_init($key, $length);\n    }\n}\nif (!is_callable('sodium_crypto_generichash_keygen')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_generichash_keygen()\n     * @return string\n     * @throws Exception\n     *\/\n    function sodium_crypto_generichash_keygen()\n    {\n        return ParagonIE_Sodium_Compat::crypto_generichash_keygen();\n    }\n}\nif (!is_callable('sodium_crypto_generichash_update')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_generichash_update()\n     * @param string|null $state\n     * @param string $message\n     * @return void\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_generichash_update(&$state, $message = '')\n    {\n        ParagonIE_Sodium_Compat::crypto_generichash_update($state, $message);\n    }\n}\nif (!is_callable('sodium_crypto_kdf_keygen')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_kdf_keygen()\n     * @return string\n     * @throws Exception\n     *\/\n    function sodium_crypto_kdf_keygen()\n    {\n        return ParagonIE_Sodium_Compat::crypto_kdf_keygen();\n    }\n}\nif (!is_callable('sodium_crypto_kdf_derive_from_key')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_kdf_derive_from_key()\n     * @param int $subkey_length\n     * @param int $subkey_id\n     * @param string $context\n     * @param string $key\n     * @return string\n     * @throws Exception\n     *\/\n    function sodium_crypto_kdf_derive_from_key($subkey_length, $subkey_id, $context, $key)\n    {\n        return ParagonIE_Sodium_Compat::crypto_kdf_derive_from_key(\n            $subkey_length,\n            $subkey_id,\n            $context,\n            $key\n        );\n    }\n}\nif (!is_callable('sodium_crypto_kx')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_kx()\n     * @param string $my_secret\n     * @param string $their_public\n     * @param string $client_public\n     * @param string $server_public\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_kx($my_secret, $their_public, $client_public, $server_public)\n    {\n        return ParagonIE_Sodium_Compat::crypto_kx(\n            $my_secret,\n            $their_public,\n            $client_public,\n            $server_public\n        );\n    }\n}\nif (!is_callable('sodium_crypto_kx_seed_keypair')) {\n    \/**\n     * @param string $seed\n     * @return string\n     * @throws Exception\n     *\/\n    function sodium_crypto_kx_seed_keypair($seed)\n    {\n        return ParagonIE_Sodium_Compat::crypto_kx_seed_keypair($seed);\n    }\n}\nif (!is_callable('sodium_crypto_kx_keypair')) {\n    \/**\n     * @return string\n     * @throws Exception\n     *\/\n    function sodium_crypto_kx_keypair()\n    {\n        return ParagonIE_Sodium_Compat::crypto_kx_keypair();\n    }\n}\nif (!is_callable('sodium_crypto_kx_client_session_keys')) {\n    \/**\n     * @param string $client_key_pair\n     * @param string $server_key\n     * @return array{0: string, 1: string}\n     * @throws SodiumException\n     *\/\n    function sodium_crypto_kx_client_session_keys($client_key_pair, $server_key)\n    {\n        return ParagonIE_Sodium_Compat::crypto_kx_client_session_keys($client_key_pair, $server_key);\n    }\n}\nif (!is_callable('sodium_crypto_kx_server_session_keys')) {\n    \/**\n     * @param string $server_key_pair\n     * @param string $client_key\n     * @return array{0: string, 1: string}\n     * @throws SodiumException\n     *\/\n    function sodium_crypto_kx_server_session_keys($server_key_pair, $client_key)\n    {\n        return ParagonIE_Sodium_Compat::crypto_kx_server_session_keys($server_key_pair, $client_key);\n    }\n}\nif (!is_callable('sodium_crypto_kx_secretkey')) {\n    \/**\n     * @param string $key_pair\n     * @return string\n     * @throws Exception\n     *\/\n    function sodium_crypto_kx_secretkey($key_pair)\n    {\n        return ParagonIE_Sodium_Compat::crypto_kx_secretkey($key_pair);\n    }\n}\nif (!is_callable('sodium_crypto_kx_publickey')) {\n    \/**\n     * @param string $key_pair\n     * @return string\n     * @throws Exception\n     *\/\n    function sodium_crypto_kx_publickey($key_pair)\n    {\n        return ParagonIE_Sodium_Compat::crypto_kx_publickey($key_pair);\n    }\n}\nif (!is_callable('sodium_crypto_pwhash')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_pwhash()\n     * @param int $length\n     * @param string $passwd\n     * @param string $salt\n     * @param int $opslimit\n     * @param int $memlimit\n     * @param int|null $algo\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_pwhash($length, $passwd, $salt, $opslimit, $memlimit, $algo = null)\n    {\n        return ParagonIE_Sodium_Compat::crypto_pwhash($length, $passwd, $salt, $opslimit, $memlimit, $algo);\n    }\n}\nif (!is_callable('sodium_crypto_pwhash_str')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_pwhash_str()\n     * @param string $passwd\n     * @param int $opslimit\n     * @param int $memlimit\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_pwhash_str($passwd, $opslimit, $memlimit)\n    {\n        return ParagonIE_Sodium_Compat::crypto_pwhash_str($passwd, $opslimit, $memlimit);\n    }\n}\nif (!is_callable('sodium_crypto_pwhash_str_needs_rehash')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_pwhash_str_needs_rehash()\n     * @param string $hash\n     * @param int $opslimit\n     * @param int $memlimit\n     * @return bool\n     *\n     * @throws SodiumException\n     *\/\n    function sodium_crypto_pwhash_str_needs_rehash($hash, $opslimit, $memlimit)\n    {\n        return ParagonIE_Sodium_Compat::crypto_pwhash_str_needs_rehash($hash, $opslimit, $memlimit);\n    }\n}\nif (!is_callable('sodium_crypto_pwhash_str_verify')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_pwhash_str_verify()\n     * @param string $passwd\n     * @param string $hash\n     * @return bool\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_pwhash_str_verify($passwd, $hash)\n    {\n        return ParagonIE_Sodium_Compat::crypto_pwhash_str_verify($passwd, $hash);\n    }\n}\nif (!is_callable('sodium_crypto_pwhash_scryptsalsa208sha256')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_pwhash_scryptsalsa208sha256()\n     * @param int $length\n     * @param string $passwd\n     * @param string $salt\n     * @param int $opslimit\n     * @param int $memlimit\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_pwhash_scryptsalsa208sha256($length, $passwd, $salt, $opslimit, $memlimit)\n    {\n        return ParagonIE_Sodium_Compat::crypto_pwhash_scryptsalsa208sha256(\n            $length,\n            $passwd,\n            $salt,\n            $opslimit,\n            $memlimit\n        );\n    }\n}\nif (!is_callable('sodium_crypto_pwhash_scryptsalsa208sha256_str')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_pwhash_scryptsalsa208sha256_str()\n     * @param string $passwd\n     * @param int $opslimit\n     * @param int $memlimit\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_pwhash_scryptsalsa208sha256_str($passwd, $opslimit, $memlimit)\n    {\n        return ParagonIE_Sodium_Compat::crypto_pwhash_scryptsalsa208sha256_str($passwd, $opslimit, $memlimit);\n    }\n}\nif (!is_callable('sodium_crypto_pwhash_scryptsalsa208sha256_str_verify')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_pwhash_scryptsalsa208sha256_str_verify()\n     * @param string $passwd\n     * @param string $hash\n     * @return bool\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_pwhash_scryptsalsa208sha256_str_verify($passwd, $hash)\n    {\n        return ParagonIE_Sodium_Compat::crypto_pwhash_scryptsalsa208sha256_str_verify($passwd, $hash);\n    }\n}\nif (!is_callable('sodium_crypto_scalarmult')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_scalarmult()\n     * @param string $n\n     * @param string $p\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_scalarmult($n, $p)\n    {\n        return ParagonIE_Sodium_Compat::crypto_scalarmult($n, $p);\n    }\n}\nif (!is_callable('sodium_crypto_scalarmult_base')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_scalarmult_base()\n     * @param string $n\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_scalarmult_base($n)\n    {\n        return ParagonIE_Sodium_Compat::crypto_scalarmult_base($n);\n    }\n}\nif (!is_callable('sodium_crypto_secretbox')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_secretbox()\n     * @param string $message\n     * @param string $nonce\n     * @param string $key\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_secretbox($message, $nonce, $key)\n    {\n        return ParagonIE_Sodium_Compat::crypto_secretbox($message, $nonce, $key);\n    }\n}\nif (!is_callable('sodium_crypto_secretbox_keygen')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_secretbox_keygen()\n     * @return string\n     * @throws Exception\n     *\/\n    function sodium_crypto_secretbox_keygen()\n    {\n        return ParagonIE_Sodium_Compat::crypto_secretbox_keygen();\n    }\n}\nif (!is_callable('sodium_crypto_secretbox_open')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_secretbox_open()\n     * @param string $ciphertext\n     * @param string $nonce\n     * @param string $key\n     * @return string|bool\n     *\/\n    function sodium_crypto_secretbox_open($ciphertext, $nonce, $key)\n    {\n        try {\n            return ParagonIE_Sodium_Compat::crypto_secretbox_open($ciphertext, $nonce, $key);\n        } catch (Error $ex) {\n            return false;\n        } catch (Exception $ex) {\n            return false;\n        }\n    }\n}\nif (!is_callable('sodium_crypto_secretstream_xchacha20poly1305_init_push')) {\n    \/**\n     * @param string $key\n     * @return array<int, string>\n     * @throws SodiumException\n     *\/\n    function sodium_crypto_secretstream_xchacha20poly1305_init_push($key)\n    {\n        return ParagonIE_Sodium_Compat::crypto_secretstream_xchacha20poly1305_init_push($key);\n    }\n}\nif (!is_callable('sodium_crypto_secretstream_xchacha20poly1305_push')) {\n    \/**\n     * @param string $state\n     * @param string $message\n     * @param string $additional_data\n     * @param int $tag\n     * @return string\n     * @throws SodiumException\n     *\/\n    function sodium_crypto_secretstream_xchacha20poly1305_push(\n        &$state,\n        $message,\n        $additional_data = '',\n        $tag = 0\n    ) {\n        return ParagonIE_Sodium_Compat::crypto_secretstream_xchacha20poly1305_push(\n            $state,\n            $message,\n            $additional_data,\n            $tag\n        );\n    }\n}\nif (!is_callable('sodium_crypto_secretstream_xchacha20poly1305_init_pull')) {\n    \/**\n     * @param string $header\n     * @param string $key\n     * @return string\n     * @throws Exception\n     *\/\n    function sodium_crypto_secretstream_xchacha20poly1305_init_pull($header, $key)\n    {\n        return ParagonIE_Sodium_Compat::crypto_secretstream_xchacha20poly1305_init_pull($header, $key);\n    }\n}\nif (!is_callable('sodium_crypto_secretstream_xchacha20poly1305_pull')) {\n    \/**\n     * @param string $state\n     * @param string $ciphertext\n     * @param string $additional_data\n     * @return bool|array{0: string, 1: int}\n     * @throws SodiumException\n     *\/\n    function sodium_crypto_secretstream_xchacha20poly1305_pull(&$state, $ciphertext, $additional_data = '')\n    {\n        return ParagonIE_Sodium_Compat::crypto_secretstream_xchacha20poly1305_pull(\n            $state,\n            $ciphertext,\n            $additional_data\n        );\n    }\n}\nif (!is_callable('sodium_crypto_secretstream_xchacha20poly1305_rekey')) {\n    \/**\n     * @param string $state\n     * @return void\n     * @throws SodiumException\n     *\/\n    function sodium_crypto_secretstream_xchacha20poly1305_rekey(&$state)\n    {\n        ParagonIE_Sodium_Compat::crypto_secretstream_xchacha20poly1305_rekey($state);\n    }\n}\nif (!is_callable('sodium_crypto_secretstream_xchacha20poly1305_keygen')) {\n    \/**\n     * @return string\n     * @throws Exception\n     *\/\n    function sodium_crypto_secretstream_xchacha20poly1305_keygen()\n    {\n        return ParagonIE_Sodium_Compat::crypto_secretstream_xchacha20poly1305_keygen();\n    }\n}\nif (!is_callable('sodium_crypto_shorthash')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_shorthash()\n     * @param string $message\n     * @param string $key\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_shorthash($message, $key = '')\n    {\n        return ParagonIE_Sodium_Compat::crypto_shorthash($message, $key);\n    }\n}\nif (!is_callable('sodium_crypto_shorthash_keygen')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_shorthash_keygen()\n     * @return string\n     * @throws Exception\n     *\/\n    function sodium_crypto_shorthash_keygen()\n    {\n        return ParagonIE_Sodium_Compat::crypto_shorthash_keygen();\n    }\n}\nif (!is_callable('sodium_crypto_sign')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_sign()\n     * @param string $message\n     * @param string $secret_key\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_sign($message, $secret_key)\n    {\n        return ParagonIE_Sodium_Compat::crypto_sign($message, $secret_key);\n    }\n}\nif (!is_callable('sodium_crypto_sign_detached')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_sign_detached()\n     * @param string $message\n     * @param string $secret_key\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_sign_detached($message, $secret_key)\n    {\n        return ParagonIE_Sodium_Compat::crypto_sign_detached($message, $secret_key);\n    }\n}\nif (!is_callable('sodium_crypto_sign_keypair_from_secretkey_and_publickey')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_sign_keypair_from_secretkey_and_publickey()\n     * @param string $secret_key\n     * @param string $public_key\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_sign_keypair_from_secretkey_and_publickey($secret_key, $public_key)\n    {\n        return ParagonIE_Sodium_Compat::crypto_sign_keypair_from_secretkey_and_publickey($secret_key, $public_key);\n    }\n}\nif (!is_callable('sodium_crypto_sign_keypair')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_sign_keypair()\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_sign_keypair()\n    {\n        return ParagonIE_Sodium_Compat::crypto_sign_keypair();\n    }\n}\nif (!is_callable('sodium_crypto_sign_open')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_sign_open()\n     * @param string $signedMessage\n     * @param string $public_key\n     * @return string|bool\n     *\/\n    function sodium_crypto_sign_open($signedMessage, $public_key)\n    {\n        try {\n            return ParagonIE_Sodium_Compat::crypto_sign_open($signedMessage, $public_key);\n        } catch (Error $ex) {\n            return false;\n        } catch (Exception $ex) {\n            return false;\n        }\n    }\n}\nif (!is_callable('sodium_crypto_sign_publickey')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_sign_publickey()\n     * @param string $key_pair\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_sign_publickey($key_pair)\n    {\n        return ParagonIE_Sodium_Compat::crypto_sign_publickey($key_pair);\n    }\n}\nif (!is_callable('sodium_crypto_sign_publickey_from_secretkey')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_sign_publickey_from_secretkey()\n     * @param string $secret_key\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_sign_publickey_from_secretkey($secret_key)\n    {\n        return ParagonIE_Sodium_Compat::crypto_sign_publickey_from_secretkey($secret_key);\n    }\n}\nif (!is_callable('sodium_crypto_sign_secretkey')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_sign_secretkey()\n     * @param string $key_pair\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_sign_secretkey($key_pair)\n    {\n        return ParagonIE_Sodium_Compat::crypto_sign_secretkey($key_pair);\n    }\n}\nif (!is_callable('sodium_crypto_sign_seed_keypair')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_sign_seed_keypair()\n     * @param string $seed\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_sign_seed_keypair($seed)\n    {\n        return ParagonIE_Sodium_Compat::crypto_sign_seed_keypair($seed);\n    }\n}\nif (!is_callable('sodium_crypto_sign_verify_detached')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_sign_verify_detached()\n     * @param string $signature\n     * @param string $message\n     * @param string $public_key\n     * @return bool\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_sign_verify_detached($signature, $message, $public_key)\n    {\n        return ParagonIE_Sodium_Compat::crypto_sign_verify_detached($signature, $message, $public_key);\n    }\n}\nif (!is_callable('sodium_crypto_sign_ed25519_pk_to_curve25519')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_sign_ed25519_pk_to_curve25519()\n     * @param string $public_key\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_sign_ed25519_pk_to_curve25519($public_key)\n    {\n        return ParagonIE_Sodium_Compat::crypto_sign_ed25519_pk_to_curve25519($public_key);\n    }\n}\nif (!is_callable('sodium_crypto_sign_ed25519_sk_to_curve25519')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_sign_ed25519_sk_to_curve25519()\n     * @param string $secret_key\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_sign_ed25519_sk_to_curve25519($secret_key)\n    {\n        return ParagonIE_Sodium_Compat::crypto_sign_ed25519_sk_to_curve25519($secret_key);\n    }\n}\nif (!is_callable('sodium_crypto_stream')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_stream()\n     * @param int $length\n     * @param string $nonce\n     * @param string $key\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_stream($length, $nonce, $key)\n    {\n        return ParagonIE_Sodium_Compat::crypto_stream($length, $nonce, $key);\n    }\n}\nif (!is_callable('sodium_crypto_stream_keygen')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_stream_keygen()\n     * @return string\n     * @throws Exception\n     *\/\n    function sodium_crypto_stream_keygen()\n    {\n        return ParagonIE_Sodium_Compat::crypto_stream_keygen();\n    }\n}\nif (!is_callable('sodium_crypto_stream_xor')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_stream_xor()\n     * @param string $message\n     * @param string $nonce\n     * @param string $key\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_stream_xor($message, $nonce, $key)\n    {\n        return ParagonIE_Sodium_Compat::crypto_stream_xor($message, $nonce, $key);\n    }\n}\nrequire_once dirname(__FILE__) . '\/stream-xchacha20.php';\nif (!is_callable('sodium_hex2bin')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::hex2bin()\n     * @param string $string\n     * @param string $ignore\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_hex2bin($string, $ignore = '')\n    {\n        return ParagonIE_Sodium_Compat::hex2bin($string, $ignore);\n    }\n}\nif (!is_callable('sodium_increment')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::increment()\n     * @param string $string\n     * @return void\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_increment(&$string)\n    {\n        ParagonIE_Sodium_Compat::increment($string);\n    }\n}\nif (!is_callable('sodium_library_version_major')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::library_version_major()\n     * @return int\n     *\/\n    function sodium_library_version_major()\n    {\n        return ParagonIE_Sodium_Compat::library_version_major();\n    }\n}\nif (!is_callable('sodium_library_version_minor')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::library_version_minor()\n     * @return int\n     *\/\n    function sodium_library_version_minor()\n    {\n        return ParagonIE_Sodium_Compat::library_version_minor();\n    }\n}\nif (!is_callable('sodium_version_string')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::version_string()\n     * @return string\n     *\/\n    function sodium_version_string()\n    {\n        return ParagonIE_Sodium_Compat::version_string();\n    }\n}\nif (!is_callable('sodium_memcmp')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::memcmp()\n     * @param string $string1\n     * @param string $string2\n     * @return int\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_memcmp($string1, $string2)\n    {\n        return ParagonIE_Sodium_Compat::memcmp($string1, $string2);\n    }\n}\nif (!is_callable('sodium_memzero')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::memzero()\n     * @param string $string\n     * @return void\n     * @throws SodiumException\n     * @throws TypeError\n     *\n     * @psalm-suppress ReferenceConstraintViolation\n     *\/\n    function sodium_memzero(&$string)\n    {\n        ParagonIE_Sodium_Compat::memzero($string);\n    }\n}\nif (!is_callable('sodium_pad')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::pad()\n     * @param string $unpadded\n     * @param int $block_size\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_pad($unpadded, $block_size)\n    {\n        return ParagonIE_Sodium_Compat::pad($unpadded, $block_size, true);\n    }\n}\nif (!is_callable('sodium_unpad')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::pad()\n     * @param string $padded\n     * @param int $block_size\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_unpad($padded, $block_size)\n    {\n        return ParagonIE_Sodium_Compat::unpad($padded, $block_size, true);\n    }\n}\nif (!is_callable('sodium_randombytes_buf')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::randombytes_buf()\n     * @param int $amount\n     * @return string\n     * @throws Exception\n     *\/\n    function sodium_randombytes_buf($amount)\n    {\n        return ParagonIE_Sodium_Compat::randombytes_buf($amount);\n    }\n}\n\nif (!is_callable('sodium_randombytes_uniform')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::randombytes_uniform()\n     * @param int $upperLimit\n     * @return int\n     * @throws Exception\n     *\/\n    function sodium_randombytes_uniform($upperLimit)\n    {\n        return ParagonIE_Sodium_Compat::randombytes_uniform($upperLimit);\n    }\n}\n\nif (!is_callable('sodium_randombytes_random16')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::randombytes_random16()\n     * @return int\n     * @throws Exception\n     *\/\n    function sodium_randombytes_random16()\n    {\n        return ParagonIE_Sodium_Compat::randombytes_random16();\n    }\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/lib\/php72compat_const.php","ext":"php","size":4656,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\n\nconst SODIUM_LIBRARY_MAJOR_VERSION = 9;\nconst SODIUM_LIBRARY_MINOR_VERSION = 1;\nconst SODIUM_LIBRARY_VERSION = '1.0.8';\n\nconst SODIUM_BASE64_VARIANT_ORIGINAL = 1;\nconst SODIUM_BASE64_VARIANT_ORIGINAL_NO_PADDING = 3;\nconst SODIUM_BASE64_VARIANT_URLSAFE = 5;\nconst SODIUM_BASE64_VARIANT_URLSAFE_NO_PADDING = 7;\nconst SODIUM_CRYPTO_AEAD_AES256GCM_KEYBYTES = 32;\nconst SODIUM_CRYPTO_AEAD_AES256GCM_NSECBYTES = 0;\nconst SODIUM_CRYPTO_AEAD_AES256GCM_NPUBBYTES = 12;\nconst SODIUM_CRYPTO_AEAD_AES256GCM_ABYTES = 16;\nconst SODIUM_CRYPTO_AEAD_CHACHA20POLY1305_KEYBYTES = 32;\nconst SODIUM_CRYPTO_AEAD_CHACHA20POLY1305_NSECBYTES = 0;\nconst SODIUM_CRYPTO_AEAD_CHACHA20POLY1305_NPUBBYTES = 8;\nconst SODIUM_CRYPTO_AEAD_CHACHA20POLY1305_ABYTES = 16;\nconst SODIUM_CRYPTO_AEAD_CHACHA20POLY1305_IETF_KEYBYTES = 32;\nconst SODIUM_CRYPTO_AEAD_CHACHA20POLY1305_IETF_NSECBYTES = 0;\nconst SODIUM_CRYPTO_AEAD_CHACHA20POLY1305_IETF_NPUBBYTES = 12;\nconst SODIUM_CRYPTO_AEAD_CHACHA20POLY1305_IETF_ABYTES = 16;\nconst SODIUM_CRYPTO_AEAD_XCHACHA20POLY1305_IETF_KEYBYTES = 32;\nconst SODIUM_CRYPTO_AEAD_XCHACHA20POLY1305_IETF_NSECBYTES = 0;\nconst SODIUM_CRYPTO_AEAD_XCHACHA20POLY1305_IETF_NPUBBYTES = 24;\nconst SODIUM_CRYPTO_AEAD_XCHACHA20POLY1305_IETF_ABYTES = 16;\nconst SODIUM_CRYPTO_AUTH_BYTES = 32;\nconst SODIUM_CRYPTO_AUTH_KEYBYTES = 32;\nconst SODIUM_CRYPTO_BOX_SEALBYTES = 16;\nconst SODIUM_CRYPTO_BOX_SECRETKEYBYTES = 32;\nconst SODIUM_CRYPTO_BOX_PUBLICKEYBYTES = 32;\nconst SODIUM_CRYPTO_BOX_KEYPAIRBYTES = 64;\nconst SODIUM_CRYPTO_BOX_MACBYTES = 16;\nconst SODIUM_CRYPTO_BOX_NONCEBYTES = 24;\nconst SODIUM_CRYPTO_BOX_SEEDBYTES = 32;\nconst SODIUM_CRYPTO_KDF_BYTES_MIN = 16;\nconst SODIUM_CRYPTO_KDF_BYTES_MAX = 64;\nconst SODIUM_CRYPTO_KDF_CONTEXTBYTES = 8;\nconst SODIUM_CRYPTO_KDF_KEYBYTES = 32;\nconst SODIUM_CRYPTO_KX_BYTES = 32;\nconst SODIUM_CRYPTO_KX_PRIMITIVE = 'x25519blake2b';\nconst SODIUM_CRYPTO_KX_SEEDBYTES = 32;\nconst SODIUM_CRYPTO_KX_KEYPAIRBYTES = 64;\nconst SODIUM_CRYPTO_KX_PUBLICKEYBYTES = 32;\nconst SODIUM_CRYPTO_KX_SECRETKEYBYTES = 32;\nconst SODIUM_CRYPTO_KX_SESSIONKEYBYTES = 32;\nconst SODIUM_CRYPTO_GENERICHASH_BYTES = 32;\nconst SODIUM_CRYPTO_GENERICHASH_BYTES_MIN = 16;\nconst SODIUM_CRYPTO_GENERICHASH_BYTES_MAX = 64;\nconst SODIUM_CRYPTO_GENERICHASH_KEYBYTES = 32;\nconst SODIUM_CRYPTO_GENERICHASH_KEYBYTES_MIN = 16;\nconst SODIUM_CRYPTO_GENERICHASH_KEYBYTES_MAX = 64;\nconst SODIUM_CRYPTO_PWHASH_SALTBYTES = 16;\nconst SODIUM_CRYPTO_PWHASH_STRPREFIX = '$argon2id$';\nconst SODIUM_CRYPTO_PWHASH_ALG_ARGON2I13 = 1;\nconst SODIUM_CRYPTO_PWHASH_ALG_ARGON2ID13 = 2;\nconst SODIUM_CRYPTO_PWHASH_MEMLIMIT_INTERACTIVE = 33554432;\nconst SODIUM_CRYPTO_PWHASH_OPSLIMIT_INTERACTIVE = 4;\nconst SODIUM_CRYPTO_PWHASH_MEMLIMIT_MODERATE = 134217728;\nconst SODIUM_CRYPTO_PWHASH_OPSLIMIT_MODERATE = 6;\nconst SODIUM_CRYPTO_PWHASH_MEMLIMIT_SENSITIVE = 536870912;\nconst SODIUM_CRYPTO_PWHASH_OPSLIMIT_SENSITIVE = 8;\nconst SODIUM_CRYPTO_PWHASH_SCRYPTSALSA208SHA256_SALTBYTES = 32;\nconst SODIUM_CRYPTO_PWHASH_SCRYPTSALSA208SHA256_STRPREFIX = '$7$';\nconst SODIUM_CRYPTO_PWHASH_SCRYPTSALSA208SHA256_OPSLIMIT_INTERACTIVE = 534288;\nconst SODIUM_CRYPTO_PWHASH_SCRYPTSALSA208SHA256_MEMLIMIT_INTERACTIVE = 16777216;\nconst SODIUM_CRYPTO_PWHASH_SCRYPTSALSA208SHA256_OPSLIMIT_SENSITIVE = 33554432;\nconst SODIUM_CRYPTO_PWHASH_SCRYPTSALSA208SHA256_MEMLIMIT_SENSITIVE = 1073741824;\nconst SODIUM_CRYPTO_SCALARMULT_BYTES = 32;\nconst SODIUM_CRYPTO_SCALARMULT_SCALARBYTES = 32;\nconst SODIUM_CRYPTO_SHORTHASH_BYTES = 8;\nconst SODIUM_CRYPTO_SHORTHASH_KEYBYTES = 16;\nconst SODIUM_CRYPTO_SECRETBOX_KEYBYTES = 32;\nconst SODIUM_CRYPTO_SECRETBOX_MACBYTES = 16;\nconst SODIUM_CRYPTO_SECRETBOX_NONCEBYTES = 24;\nconst SODIUM_CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_ABYTES = 17;\nconst SODIUM_CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_HEADERBYTES = 24;\nconst SODIUM_CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_KEYBYTES = 32;\nconst SODIUM_CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_TAG_PUSH = 0;\nconst SODIUM_CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_TAG_PULL = 1;\nconst SODIUM_CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_TAG_REKEY = 2;\nconst SODIUM_CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_TAG_FINAL = 3;\nconst SODIUM_CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_MESSAGEBYTES_MAX = 0x3fffffff80;\nconst SODIUM_CRYPTO_SIGN_BYTES = 64;\nconst SODIUM_CRYPTO_SIGN_SEEDBYTES = 32;\nconst SODIUM_CRYPTO_SIGN_PUBLICKEYBYTES = 32;\nconst SODIUM_CRYPTO_SIGN_SECRETKEYBYTES = 64;\nconst SODIUM_CRYPTO_SIGN_KEYPAIRBYTES = 96;\nconst SODIUM_CRYPTO_STREAM_KEYBYTES = 32;\nconst SODIUM_CRYPTO_STREAM_NONCEBYTES = 24;\nconst SODIUM_CRYPTO_STREAM_XCHACHA20_KEYBYTES = 32;\nconst SODIUM_CRYPTO_STREAM_XCHACHA20_NONCEBYTES = 24;\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/lib\/ristretto255.php","ext":"php","size":7269,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\n\nif (!defined('SODIUM_CRYPTO_CORE_RISTRETTO255_BYTES')) {\n    define(\n        'SODIUM_CRYPTO_CORE_RISTRETTO255_BYTES',\n        ParagonIE_Sodium_Compat::CRYPTO_CORE_RISTRETTO255_BYTES\n    );\n    define('SODIUM_COMPAT_POLYFILLED_RISTRETTO255', true);\n}\nif (!defined('SODIUM_CRYPTO_CORE_RISTRETTO255_HASHBYTES')) {\n    define(\n        'SODIUM_CRYPTO_CORE_RISTRETTO255_HASHBYTES',\n        ParagonIE_Sodium_Compat::CRYPTO_CORE_RISTRETTO255_HASHBYTES\n    );\n}\nif (!defined('SODIUM_CRYPTO_CORE_RISTRETTO255_SCALARBYTES')) {\n    define(\n        'SODIUM_CRYPTO_CORE_RISTRETTO255_SCALARBYTES',\n        ParagonIE_Sodium_Compat::CRYPTO_CORE_RISTRETTO255_SCALARBYTES\n    );\n}\nif (!defined('SODIUM_CRYPTO_CORE_RISTRETTO255_NONREDUCEDSCALARBYTES')) {\n    define(\n        'SODIUM_CRYPTO_CORE_RISTRETTO255_NONREDUCEDSCALARBYTES',\n        ParagonIE_Sodium_Compat::CRYPTO_CORE_RISTRETTO255_NONREDUCEDSCALARBYTES\n    );\n}\nif (!defined('SODIUM_CRYPTO_SCALARMULT_RISTRETTO255_SCALARBYTES')) {\n    define(\n        'SODIUM_CRYPTO_SCALARMULT_RISTRETTO255_SCALARBYTES',\n        ParagonIE_Sodium_Compat::CRYPTO_SCALARMULT_RISTRETTO255_SCALARBYTES\n    );\n}\nif (!defined('SODIUM_CRYPTO_SCALARMULT_RISTRETTO255_BYTES')) {\n    define(\n        'SODIUM_CRYPTO_SCALARMULT_RISTRETTO255_BYTES',\n        ParagonIE_Sodium_Compat::CRYPTO_SCALARMULT_RISTRETTO255_BYTES\n    );\n}\n\nif (!is_callable('sodium_crypto_core_ristretto255_add')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::ristretto255_add()\n     *\n     * @param string $p\n     * @param string $q\n     * @return string\n     * @throws SodiumException\n     *\/\n    function sodium_crypto_core_ristretto255_add($p, $q)\n    {\n        return ParagonIE_Sodium_Compat::ristretto255_add($p, $q, true);\n    }\n}\nif (!is_callable('sodium_crypto_core_ristretto255_from_hash')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::ristretto255_from_hash()\n     *\n     * @param string $s\n     * @return string\n     * @throws SodiumException\n     *\/\n    function sodium_crypto_core_ristretto255_from_hash($s)\n    {\n        return ParagonIE_Sodium_Compat::ristretto255_from_hash($s, true);\n    }\n}\nif (!is_callable('sodium_crypto_core_ristretto255_is_valid_point')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::ristretto255_is_valid_point()\n     *\n     * @param string $s\n     * @return bool\n     * @throws SodiumException\n     *\/\n    function sodium_crypto_core_ristretto255_is_valid_point($s)\n    {\n        return ParagonIE_Sodium_Compat::ristretto255_is_valid_point($s, true);\n    }\n}\nif (!is_callable('sodium_crypto_core_ristretto255_random')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::ristretto255_random()\n     *\n     * @return string\n     * @throws SodiumException\n     *\/\n    function sodium_crypto_core_ristretto255_random()\n    {\n        return ParagonIE_Sodium_Compat::ristretto255_random(true);\n    }\n}\nif (!is_callable('sodium_crypto_core_ristretto255_scalar_add')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::ristretto255_scalar_add()\n     *\n     * @param string $x\n     * @param string $y\n     * @return string\n     * @throws SodiumException\n     *\/\n    function sodium_crypto_core_ristretto255_scalar_add($x, $y)\n    {\n        return ParagonIE_Sodium_Compat::ristretto255_scalar_add($x, $y, true);\n    }\n}\nif (!is_callable('sodium_crypto_core_ristretto255_scalar_complement')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::ristretto255_scalar_complement()\n     *\n     * @param string $s\n     * @return string\n     * @throws SodiumException\n     *\/\n    function sodium_crypto_core_ristretto255_scalar_complement($s)\n    {\n        return ParagonIE_Sodium_Compat::ristretto255_scalar_complement($s, true);\n    }\n}\nif (!is_callable('sodium_crypto_core_ristretto255_scalar_invert')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::ristretto255_scalar_invert()\n     *\n     * @param string $p\n     * @return string\n     * @throws SodiumException\n     *\/\n    function sodium_crypto_core_ristretto255_scalar_invert($p)\n    {\n        return ParagonIE_Sodium_Compat::ristretto255_scalar_invert($p, true);\n    }\n}\nif (!is_callable('sodium_crypto_core_ristretto255_scalar_mul')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::ristretto255_scalar_mul()\n     *\n     * @param string $x\n     * @param string $y\n     * @return string\n     * @throws SodiumException\n     *\/\n    function sodium_crypto_core_ristretto255_scalar_mul($x, $y)\n    {\n        return ParagonIE_Sodium_Compat::ristretto255_scalar_mul($x, $y, true);\n    }\n}\nif (!is_callable('sodium_crypto_core_ristretto255_scalar_negate')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::ristretto255_scalar_negate()\n     *\n     * @param string $s\n     * @return string\n     * @throws SodiumException\n     *\/\n    function sodium_crypto_core_ristretto255_scalar_negate($s)\n    {\n        return ParagonIE_Sodium_Compat::ristretto255_scalar_negate($s, true);\n    }\n}\nif (!is_callable('sodium_crypto_core_ristretto255_scalar_random')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::ristretto255_scalar_random()\n     *\n     * @return string\n     * @throws SodiumException\n     *\/\n    function sodium_crypto_core_ristretto255_scalar_random()\n    {\n        return ParagonIE_Sodium_Compat::ristretto255_scalar_random(true);\n    }\n}\nif (!is_callable('sodium_crypto_core_ristretto255_scalar_reduce')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::ristretto255_scalar_reduce()\n     *\n     * @param string $s\n     * @return string\n     * @throws SodiumException\n     *\/\n    function sodium_crypto_core_ristretto255_scalar_reduce($s)\n    {\n        return ParagonIE_Sodium_Compat::ristretto255_scalar_reduce($s, true);\n    }\n}\nif (!is_callable('sodium_crypto_core_ristretto255_scalar_sub')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::ristretto255_scalar_sub()\n     *\n     * @param string $x\n     * @param string $y\n     * @return string\n     * @throws SodiumException\n     *\/\n    function sodium_crypto_core_ristretto255_scalar_sub($x, $y)\n    {\n        return ParagonIE_Sodium_Compat::ristretto255_scalar_sub($x, $y, true);\n    }\n}\nif (!is_callable('sodium_crypto_core_ristretto255_sub')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::ristretto255_sub()\n     *\n     * @param string $p\n     * @param string $q\n     * @return string\n     * @throws SodiumException\n     *\/\n    function sodium_crypto_core_ristretto255_sub($p, $q)\n    {\n        return ParagonIE_Sodium_Compat::ristretto255_sub($p, $q, true);\n    }\n}\nif (!is_callable('sodium_crypto_scalarmult_ristretto255')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_scalarmult_ristretto255()\n     * @param string $n\n     * @param string $p\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_scalarmult_ristretto255($n, $p)\n    {\n        return ParagonIE_Sodium_Compat::scalarmult_ristretto255($n, $p, true);\n    }\n}\nif (!is_callable('sodium_crypto_scalarmult_ristretto255_base')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_scalarmult_ristretto255_base()\n     * @param string $n\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_scalarmult_ristretto255_base($n)\n    {\n        return ParagonIE_Sodium_Compat::scalarmult_ristretto255_base($n, true);\n    }\n}"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/lib\/sodium_compat.php","ext":"php","size":24735,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\nnamespace Sodium;\n\nrequire_once dirname(dirname(__FILE__)) . '\/autoload.php';\n\nuse ParagonIE_Sodium_Compat;\n\n\/**\n * This file will monkey patch the pure-PHP implementation in place of the\n * PECL functions, but only if they do not already exist.\n *\n * Thus, the functions just proxy to the appropriate ParagonIE_Sodium_Compat\n * method.\n *\/\nif (!is_callable('\\\\Sodium\\\\bin2hex')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::bin2hex()\n     * @param string $string\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function bin2hex($string)\n    {\n        return ParagonIE_Sodium_Compat::bin2hex($string);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\compare')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::compare()\n     * @param string $a\n     * @param string $b\n     * @return int\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function compare($a, $b)\n    {\n        return ParagonIE_Sodium_Compat::compare($a, $b);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_aead_aes256gcm_decrypt')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_aead_aes256gcm_decrypt()\n     * @param string $message\n     * @param string $assocData\n     * @param string $nonce\n     * @param string $key\n     * @return string|bool\n     *\/\n    function crypto_aead_aes256gcm_decrypt($message, $assocData, $nonce, $key)\n    {\n        try {\n            return ParagonIE_Sodium_Compat::crypto_aead_aes256gcm_decrypt($message, $assocData, $nonce, $key);\n        } catch (\\TypeError $ex) {\n            return false;\n        } catch (\\SodiumException $ex) {\n            return false;\n        }\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_aead_aes256gcm_encrypt')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_aead_aes256gcm_encrypt()\n     * @param string $message\n     * @param string $assocData\n     * @param string $nonce\n     * @param string $key\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_aead_aes256gcm_encrypt($message, $assocData, $nonce, $key)\n    {\n        return ParagonIE_Sodium_Compat::crypto_aead_aes256gcm_encrypt($message, $assocData, $nonce, $key);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_aead_aes256gcm_is_available')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_aead_aes256gcm_is_available()\n     * @return bool\n     *\/\n    function crypto_aead_aes256gcm_is_available()\n    {\n        return ParagonIE_Sodium_Compat::crypto_aead_aes256gcm_is_available();\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_aead_chacha20poly1305_decrypt')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_aead_chacha20poly1305_decrypt()\n     * @param string $message\n     * @param string $assocData\n     * @param string $nonce\n     * @param string $key\n     * @return string|bool\n     *\/\n    function crypto_aead_chacha20poly1305_decrypt($message, $assocData, $nonce, $key)\n    {\n        try {\n            return ParagonIE_Sodium_Compat::crypto_aead_chacha20poly1305_decrypt($message, $assocData, $nonce, $key);\n        } catch (\\TypeError $ex) {\n            return false;\n        } catch (\\SodiumException $ex) {\n            return false;\n        }\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_aead_chacha20poly1305_encrypt')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_aead_chacha20poly1305_encrypt()\n     * @param string $message\n     * @param string $assocData\n     * @param string $nonce\n     * @param string $key\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_aead_chacha20poly1305_encrypt($message, $assocData, $nonce, $key)\n    {\n        return ParagonIE_Sodium_Compat::crypto_aead_chacha20poly1305_encrypt($message, $assocData, $nonce, $key);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_aead_chacha20poly1305_ietf_decrypt')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_aead_chacha20poly1305_ietf_decrypt()\n     * @param string $message\n     * @param string $assocData\n     * @param string $nonce\n     * @param string $key\n     * @return string|bool\n     *\/\n    function crypto_aead_chacha20poly1305_ietf_decrypt($message, $assocData, $nonce, $key)\n    {\n        try {\n            return ParagonIE_Sodium_Compat::crypto_aead_chacha20poly1305_ietf_decrypt($message, $assocData, $nonce, $key);\n        } catch (\\TypeError $ex) {\n            return false;\n        } catch (\\SodiumException $ex) {\n            return false;\n        }\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_aead_chacha20poly1305_ietf_encrypt')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_aead_chacha20poly1305_ietf_encrypt()\n     * @param string $message\n     * @param string $assocData\n     * @param string $nonce\n     * @param string $key\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_aead_chacha20poly1305_ietf_encrypt($message, $assocData, $nonce, $key)\n    {\n        return ParagonIE_Sodium_Compat::crypto_aead_chacha20poly1305_ietf_encrypt($message, $assocData, $nonce, $key);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_auth')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_auth()\n     * @param string $message\n     * @param string $key\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_auth($message, $key)\n    {\n        return ParagonIE_Sodium_Compat::crypto_auth($message, $key);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_auth_verify')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_auth_verify()\n     * @param string $mac\n     * @param string $message\n     * @param string $key\n     * @return bool\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_auth_verify($mac, $message, $key)\n    {\n        return ParagonIE_Sodium_Compat::crypto_auth_verify($mac, $message, $key);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_box')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_box()\n     * @param string $message\n     * @param string $nonce\n     * @param string $kp\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_box($message, $nonce, $kp)\n    {\n        return ParagonIE_Sodium_Compat::crypto_box($message, $nonce, $kp);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_box_keypair')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_box_keypair()\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_box_keypair()\n    {\n        return ParagonIE_Sodium_Compat::crypto_box_keypair();\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_box_keypair_from_secretkey_and_publickey')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_box_keypair_from_secretkey_and_publickey()\n     * @param string $sk\n     * @param string $pk\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_box_keypair_from_secretkey_and_publickey($sk, $pk)\n    {\n        return ParagonIE_Sodium_Compat::crypto_box_keypair_from_secretkey_and_publickey($sk, $pk);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_box_open')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_box_open()\n     * @param string $message\n     * @param string $nonce\n     * @param string $kp\n     * @return string|bool\n     *\/\n    function crypto_box_open($message, $nonce, $kp)\n    {\n        try {\n            return ParagonIE_Sodium_Compat::crypto_box_open($message, $nonce, $kp);\n        } catch (\\TypeError $ex) {\n            return false;\n        } catch (\\SodiumException $ex) {\n            return false;\n        }\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_box_publickey')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_box_publickey()\n     * @param string $keypair\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_box_publickey($keypair)\n    {\n        return ParagonIE_Sodium_Compat::crypto_box_publickey($keypair);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_box_publickey_from_secretkey')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_box_publickey_from_secretkey()\n     * @param string $sk\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_box_publickey_from_secretkey($sk)\n    {\n        return ParagonIE_Sodium_Compat::crypto_box_publickey_from_secretkey($sk);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_box_seal')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_box_seal_open()\n     * @param string $message\n     * @param string $publicKey\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_box_seal($message, $publicKey)\n    {\n        return ParagonIE_Sodium_Compat::crypto_box_seal($message, $publicKey);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_box_seal_open')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_box_seal_open()\n     * @param string $message\n     * @param string $kp\n     * @return string|bool\n     *\/\n    function crypto_box_seal_open($message, $kp)\n    {\n        try {\n            return ParagonIE_Sodium_Compat::crypto_box_seal_open($message, $kp);\n        } catch (\\TypeError $ex) {\n            return false;\n        } catch (\\SodiumException $ex) {\n            return false;\n        }\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_box_secretkey')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_box_secretkey()\n     * @param string $keypair\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_box_secretkey($keypair)\n    {\n        return ParagonIE_Sodium_Compat::crypto_box_secretkey($keypair);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_generichash')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_generichash()\n     * @param string $message\n     * @param string|null $key\n     * @param int $outLen\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_generichash($message, $key = null, $outLen = 32)\n    {\n        return ParagonIE_Sodium_Compat::crypto_generichash($message, $key, $outLen);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_generichash_final')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_generichash_final()\n     * @param string|null $ctx\n     * @param int $outputLength\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_generichash_final(&$ctx, $outputLength = 32)\n    {\n        return ParagonIE_Sodium_Compat::crypto_generichash_final($ctx, $outputLength);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_generichash_init')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_generichash_init()\n     * @param string|null $key\n     * @param int $outLen\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_generichash_init($key = null, $outLen = 32)\n    {\n        return ParagonIE_Sodium_Compat::crypto_generichash_init($key, $outLen);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_generichash_update')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_generichash_update()\n     * @param string|null $ctx\n     * @param string $message\n     * @return void\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_generichash_update(&$ctx, $message = '')\n    {\n        ParagonIE_Sodium_Compat::crypto_generichash_update($ctx, $message);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_kx')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_kx()\n     * @param string $my_secret\n     * @param string $their_public\n     * @param string $client_public\n     * @param string $server_public\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_kx($my_secret, $their_public, $client_public, $server_public)\n    {\n        return ParagonIE_Sodium_Compat::crypto_kx(\n            $my_secret,\n            $their_public,\n            $client_public,\n            $server_public,\n            true\n        );\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_pwhash')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_pwhash()\n     * @param int $outlen\n     * @param string $passwd\n     * @param string $salt\n     * @param int $opslimit\n     * @param int $memlimit\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_pwhash($outlen, $passwd, $salt, $opslimit, $memlimit)\n    {\n        return ParagonIE_Sodium_Compat::crypto_pwhash($outlen, $passwd, $salt, $opslimit, $memlimit);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_pwhash_str')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_pwhash_str()\n     * @param string $passwd\n     * @param int $opslimit\n     * @param int $memlimit\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_pwhash_str($passwd, $opslimit, $memlimit)\n    {\n        return ParagonIE_Sodium_Compat::crypto_pwhash_str($passwd, $opslimit, $memlimit);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_pwhash_str_verify')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_pwhash_str_verify()\n     * @param string $passwd\n     * @param string $hash\n     * @return bool\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_pwhash_str_verify($passwd, $hash)\n    {\n        return ParagonIE_Sodium_Compat::crypto_pwhash_str_verify($passwd, $hash);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_pwhash_scryptsalsa208sha256')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_pwhash_scryptsalsa208sha256()\n     * @param int $outlen\n     * @param string $passwd\n     * @param string $salt\n     * @param int $opslimit\n     * @param int $memlimit\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_pwhash_scryptsalsa208sha256($outlen, $passwd, $salt, $opslimit, $memlimit)\n    {\n        return ParagonIE_Sodium_Compat::crypto_pwhash_scryptsalsa208sha256($outlen, $passwd, $salt, $opslimit, $memlimit);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_pwhash_scryptsalsa208sha256_str')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_pwhash_scryptsalsa208sha256_str()\n     * @param string $passwd\n     * @param int $opslimit\n     * @param int $memlimit\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_pwhash_scryptsalsa208sha256_str($passwd, $opslimit, $memlimit)\n    {\n        return ParagonIE_Sodium_Compat::crypto_pwhash_scryptsalsa208sha256_str($passwd, $opslimit, $memlimit);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_pwhash_scryptsalsa208sha256_str_verify')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_pwhash_scryptsalsa208sha256_str_verify()\n     * @param string $passwd\n     * @param string $hash\n     * @return bool\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_pwhash_scryptsalsa208sha256_str_verify($passwd, $hash)\n    {\n        return ParagonIE_Sodium_Compat::crypto_pwhash_scryptsalsa208sha256_str_verify($passwd, $hash);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_scalarmult')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_scalarmult()\n     * @param string $n\n     * @param string $p\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_scalarmult($n, $p)\n    {\n        return ParagonIE_Sodium_Compat::crypto_scalarmult($n, $p);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_scalarmult_base')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_scalarmult_base()\n     * @param string $n\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_scalarmult_base($n)\n    {\n        return ParagonIE_Sodium_Compat::crypto_scalarmult_base($n);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_secretbox')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_secretbox()\n     * @param string $message\n     * @param string $nonce\n     * @param string $key\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_secretbox($message, $nonce, $key)\n    {\n        return ParagonIE_Sodium_Compat::crypto_secretbox($message, $nonce, $key);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_secretbox_open')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_secretbox_open()\n     * @param string $message\n     * @param string $nonce\n     * @param string $key\n     * @return string|bool\n     *\/\n    function crypto_secretbox_open($message, $nonce, $key)\n    {\n        try {\n            return ParagonIE_Sodium_Compat::crypto_secretbox_open($message, $nonce, $key);\n        } catch (\\TypeError $ex) {\n            return false;\n        } catch (\\SodiumException $ex) {\n            return false;\n        }\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_shorthash')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_shorthash()\n     * @param string $message\n     * @param string $key\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_shorthash($message, $key = '')\n    {\n        return ParagonIE_Sodium_Compat::crypto_shorthash($message, $key);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_sign')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_sign()\n     * @param string $message\n     * @param string $sk\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_sign($message, $sk)\n    {\n        return ParagonIE_Sodium_Compat::crypto_sign($message, $sk);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_sign_detached')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_sign_detached()\n     * @param string $message\n     * @param string $sk\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_sign_detached($message, $sk)\n    {\n        return ParagonIE_Sodium_Compat::crypto_sign_detached($message, $sk);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_sign_keypair')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_sign_keypair()\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_sign_keypair()\n    {\n        return ParagonIE_Sodium_Compat::crypto_sign_keypair();\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_sign_open')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_sign_open()\n     * @param string $signedMessage\n     * @param string $pk\n     * @return string|bool\n     *\/\n    function crypto_sign_open($signedMessage, $pk)\n    {\n        try {\n            return ParagonIE_Sodium_Compat::crypto_sign_open($signedMessage, $pk);\n        } catch (\\TypeError $ex) {\n            return false;\n        } catch (\\SodiumException $ex) {\n            return false;\n        }\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_sign_publickey')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_sign_publickey()\n     * @param string $keypair\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_sign_publickey($keypair)\n    {\n        return ParagonIE_Sodium_Compat::crypto_sign_publickey($keypair);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_sign_publickey_from_secretkey')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_sign_publickey_from_secretkey()\n     * @param string $sk\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_sign_publickey_from_secretkey($sk)\n    {\n        return ParagonIE_Sodium_Compat::crypto_sign_publickey_from_secretkey($sk);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_sign_secretkey')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_sign_secretkey()\n     * @param string $keypair\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_sign_secretkey($keypair)\n    {\n        return ParagonIE_Sodium_Compat::crypto_sign_secretkey($keypair);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_sign_seed_keypair')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_sign_seed_keypair()\n     * @param string $seed\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_sign_seed_keypair($seed)\n    {\n        return ParagonIE_Sodium_Compat::crypto_sign_seed_keypair($seed);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_sign_verify_detached')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_sign_verify_detached()\n     * @param string $signature\n     * @param string $message\n     * @param string $pk\n     * @return bool\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_sign_verify_detached($signature, $message, $pk)\n    {\n        return ParagonIE_Sodium_Compat::crypto_sign_verify_detached($signature, $message, $pk);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_sign_ed25519_pk_to_curve25519')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_sign_ed25519_pk_to_curve25519()\n     * @param string $pk\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_sign_ed25519_pk_to_curve25519($pk)\n    {\n        return ParagonIE_Sodium_Compat::crypto_sign_ed25519_pk_to_curve25519($pk);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_sign_ed25519_sk_to_curve25519')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_sign_ed25519_sk_to_curve25519()\n     * @param string $sk\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_sign_ed25519_sk_to_curve25519($sk)\n    {\n        return ParagonIE_Sodium_Compat::crypto_sign_ed25519_sk_to_curve25519($sk);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_stream')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_stream()\n     * @param int $len\n     * @param string $nonce\n     * @param string $key\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_stream($len, $nonce, $key)\n    {\n        return ParagonIE_Sodium_Compat::crypto_stream($len, $nonce, $key);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\crypto_stream_xor')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_stream_xor()\n     * @param string $message\n     * @param string $nonce\n     * @param string $key\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function crypto_stream_xor($message, $nonce, $key)\n    {\n        return ParagonIE_Sodium_Compat::crypto_stream_xor($message, $nonce, $key);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\hex2bin')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::hex2bin()\n     * @param string $string\n     * @return string\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function hex2bin($string)\n    {\n        return ParagonIE_Sodium_Compat::hex2bin($string);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\memcmp')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::memcmp()\n     * @param string $a\n     * @param string $b\n     * @return int\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\/\n    function memcmp($a, $b)\n    {\n        return ParagonIE_Sodium_Compat::memcmp($a, $b);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\memzero')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::memzero()\n     * @param string $str\n     * @return void\n     * @throws \\SodiumException\n     * @throws \\TypeError\n     *\n     * @psalm-suppress MissingParamType\n     * @psalm-suppress MissingReturnType\n     * @psalm-suppress ReferenceConstraintViolation\n     *\/\n    function memzero(&$str)\n    {\n        ParagonIE_Sodium_Compat::memzero($str);\n    }\n}\nif (!is_callable('\\\\Sodium\\\\randombytes_buf')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::randombytes_buf()\n     * @param int $amount\n     * @return string\n     * @throws \\TypeError\n     *\/\n    function randombytes_buf($amount)\n    {\n        return ParagonIE_Sodium_Compat::randombytes_buf($amount);\n    }\n}\n\nif (!is_callable('\\\\Sodium\\\\randombytes_uniform')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::randombytes_uniform()\n     * @param int $upperLimit\n     * @return int\n     * @throws \\SodiumException\n     * @throws \\Error\n     *\/\n    function randombytes_uniform($upperLimit)\n    {\n        return ParagonIE_Sodium_Compat::randombytes_uniform($upperLimit);\n    }\n}\n\nif (!is_callable('\\\\Sodium\\\\randombytes_random16')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::randombytes_random16()\n     * @return int\n     *\/\n    function randombytes_random16()\n    {\n        return ParagonIE_Sodium_Compat::randombytes_random16();\n    }\n}\n\nif (!defined('\\\\Sodium\\\\CRYPTO_AUTH_BYTES')) {\n    require_once dirname(__FILE__) . '\/constants.php';\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/lib\/constants.php","ext":"php","size":4220,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\nnamespace Sodium;\n\nrequire_once dirname(dirname(__FILE__)) . '\/autoload.php';\n\nuse ParagonIE_Sodium_Compat;\n\nconst CRYPTO_AEAD_AES256GCM_KEYBYTES = ParagonIE_Sodium_Compat::CRYPTO_AEAD_AES256GCM_KEYBYTES;\nconst CRYPTO_AEAD_AES256GCM_NSECBYTES = ParagonIE_Sodium_Compat::CRYPTO_AEAD_AES256GCM_NSECBYTES;\nconst CRYPTO_AEAD_AES256GCM_NPUBBYTES = ParagonIE_Sodium_Compat::CRYPTO_AEAD_AES256GCM_NPUBBYTES;\nconst CRYPTO_AEAD_AES256GCM_ABYTES = ParagonIE_Sodium_Compat::CRYPTO_AEAD_AES256GCM_ABYTES;\nconst CRYPTO_AEAD_CHACHA20POLY1305_KEYBYTES = ParagonIE_Sodium_Compat::CRYPTO_AEAD_CHACHA20POLY1305_KEYBYTES;\nconst CRYPTO_AEAD_CHACHA20POLY1305_NSECBYTES = ParagonIE_Sodium_Compat::CRYPTO_AEAD_CHACHA20POLY1305_NSECBYTES;\nconst CRYPTO_AEAD_CHACHA20POLY1305_NPUBBYTES = ParagonIE_Sodium_Compat::CRYPTO_AEAD_CHACHA20POLY1305_NPUBBYTES;\nconst CRYPTO_AEAD_CHACHA20POLY1305_ABYTES = ParagonIE_Sodium_Compat::CRYPTO_AEAD_CHACHA20POLY1305_ABYTES;\nconst CRYPTO_AEAD_CHACHA20POLY1305_IETF_KEYBYTES = ParagonIE_Sodium_Compat::CRYPTO_AEAD_CHACHA20POLY1305_IETF_KEYBYTES;\nconst CRYPTO_AEAD_CHACHA20POLY1305_IETF_NSECBYTES = ParagonIE_Sodium_Compat::CRYPTO_AEAD_CHACHA20POLY1305_IETF_NSECBYTES;\nconst CRYPTO_AEAD_CHACHA20POLY1305_IETF_NPUBBYTES = ParagonIE_Sodium_Compat::CRYPTO_AEAD_CHACHA20POLY1305_IETF_NPUBBYTES;\nconst CRYPTO_AEAD_CHACHA20POLY1305_IETF_ABYTES = ParagonIE_Sodium_Compat::CRYPTO_AEAD_CHACHA20POLY1305_IETF_ABYTES;\nconst CRYPTO_AUTH_BYTES = ParagonIE_Sodium_Compat::CRYPTO_AUTH_BYTES;\nconst CRYPTO_AUTH_KEYBYTES = ParagonIE_Sodium_Compat::CRYPTO_AUTH_KEYBYTES;\nconst CRYPTO_BOX_SEALBYTES = ParagonIE_Sodium_Compat::CRYPTO_BOX_SEALBYTES;\nconst CRYPTO_BOX_SECRETKEYBYTES = ParagonIE_Sodium_Compat::CRYPTO_BOX_SECRETKEYBYTES;\nconst CRYPTO_BOX_PUBLICKEYBYTES = ParagonIE_Sodium_Compat::CRYPTO_BOX_PUBLICKEYBYTES;\nconst CRYPTO_BOX_KEYPAIRBYTES = ParagonIE_Sodium_Compat::CRYPTO_BOX_KEYPAIRBYTES;\nconst CRYPTO_BOX_MACBYTES = ParagonIE_Sodium_Compat::CRYPTO_BOX_MACBYTES;\nconst CRYPTO_BOX_NONCEBYTES = ParagonIE_Sodium_Compat::CRYPTO_BOX_NONCEBYTES;\nconst CRYPTO_BOX_SEEDBYTES = ParagonIE_Sodium_Compat::CRYPTO_BOX_SEEDBYTES;\nconst CRYPTO_KX_BYTES = ParagonIE_Sodium_Compat::CRYPTO_KX_BYTES;\nconst CRYPTO_KX_SEEDBYTES = ParagonIE_Sodium_Compat::CRYPTO_KX_SEEDBYTES;\nconst CRYPTO_KX_PUBLICKEYBYTES = ParagonIE_Sodium_Compat::CRYPTO_KX_PUBLICKEYBYTES;\nconst CRYPTO_KX_SECRETKEYBYTES = ParagonIE_Sodium_Compat::CRYPTO_KX_SECRETKEYBYTES;\nconst CRYPTO_GENERICHASH_BYTES = ParagonIE_Sodium_Compat::CRYPTO_GENERICHASH_BYTES;\nconst CRYPTO_GENERICHASH_BYTES_MIN = ParagonIE_Sodium_Compat::CRYPTO_GENERICHASH_BYTES_MIN;\nconst CRYPTO_GENERICHASH_BYTES_MAX = ParagonIE_Sodium_Compat::CRYPTO_GENERICHASH_BYTES_MAX;\nconst CRYPTO_GENERICHASH_KEYBYTES = ParagonIE_Sodium_Compat::CRYPTO_GENERICHASH_KEYBYTES;\nconst CRYPTO_GENERICHASH_KEYBYTES_MIN = ParagonIE_Sodium_Compat::CRYPTO_GENERICHASH_KEYBYTES_MIN;\nconst CRYPTO_GENERICHASH_KEYBYTES_MAX = ParagonIE_Sodium_Compat::CRYPTO_GENERICHASH_KEYBYTES_MAX;\nconst CRYPTO_SCALARMULT_BYTES = ParagonIE_Sodium_Compat::CRYPTO_SCALARMULT_BYTES;\nconst CRYPTO_SCALARMULT_SCALARBYTES = ParagonIE_Sodium_Compat::CRYPTO_SCALARMULT_SCALARBYTES;\nconst CRYPTO_SHORTHASH_BYTES = ParagonIE_Sodium_Compat::CRYPTO_SHORTHASH_BYTES;\nconst CRYPTO_SHORTHASH_KEYBYTES = ParagonIE_Sodium_Compat::CRYPTO_SHORTHASH_KEYBYTES;\nconst CRYPTO_SECRETBOX_KEYBYTES = ParagonIE_Sodium_Compat::CRYPTO_SECRETBOX_KEYBYTES;\nconst CRYPTO_SECRETBOX_MACBYTES = ParagonIE_Sodium_Compat::CRYPTO_SECRETBOX_MACBYTES;\nconst CRYPTO_SECRETBOX_NONCEBYTES = ParagonIE_Sodium_Compat::CRYPTO_SECRETBOX_NONCEBYTES;\nconst CRYPTO_SIGN_BYTES = ParagonIE_Sodium_Compat::CRYPTO_SIGN_BYTES;\nconst CRYPTO_SIGN_SEEDBYTES = ParagonIE_Sodium_Compat::CRYPTO_SIGN_SEEDBYTES;\nconst CRYPTO_SIGN_PUBLICKEYBYTES = ParagonIE_Sodium_Compat::CRYPTO_SIGN_PUBLICKEYBYTES;\nconst CRYPTO_SIGN_SECRETKEYBYTES = ParagonIE_Sodium_Compat::CRYPTO_SIGN_SECRETKEYBYTES;\nconst CRYPTO_SIGN_KEYPAIRBYTES = ParagonIE_Sodium_Compat::CRYPTO_SIGN_KEYPAIRBYTES;\nconst CRYPTO_STREAM_KEYBYTES = ParagonIE_Sodium_Compat::CRYPTO_STREAM_KEYBYTES;\nconst CRYPTO_STREAM_NONCEBYTES = ParagonIE_Sodium_Compat::CRYPTO_STREAM_NONCEBYTES;\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/lib\/stream-xchacha20.php","ext":"php","size":1893,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\n\nif (!is_callable('sodium_crypto_stream_xchacha20')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_stream_xchacha20()\n     * @param int $len\n     * @param string $nonce\n     * @param string $key\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_stream_xchacha20($len, $nonce, $key)\n    {\n        return ParagonIE_Sodium_Compat::crypto_stream_xchacha20($len, $nonce, $key, true);\n    }\n}\nif (!is_callable('sodium_crypto_stream_xchacha20_keygen')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_stream_xchacha20_keygen()\n     * @return string\n     * @throws Exception\n     *\/\n    function sodium_crypto_stream_xchacha20_keygen()\n    {\n        return ParagonIE_Sodium_Compat::crypto_stream_xchacha20_keygen();\n    }\n}\nif (!is_callable('sodium_crypto_stream_xchacha20_xor')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_stream_xchacha20_xor()\n     * @param string $message\n     * @param string $nonce\n     * @param string $key\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_stream_xchacha20_xor($message, $nonce, $key)\n    {\n        return ParagonIE_Sodium_Compat::crypto_stream_xchacha20_xor($message, $nonce, $key, true);\n    }\n}\nif (!is_callable('sodium_crypto_stream_xchacha20_xor_ic')) {\n    \/**\n     * @see ParagonIE_Sodium_Compat::crypto_stream_xchacha20_xor_ic()\n     * @param string $message\n     * @param string $nonce\n     * @param int $counter\n     * @param string $key\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    function sodium_crypto_stream_xchacha20_xor_ic($message, $nonce, $counter, $key)\n    {\n        return ParagonIE_Sodium_Compat::crypto_stream_xchacha20_xor_ic($message, $nonce, $counter, $key, true);\n    }\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/autoload.php","ext":"php","size":2914,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\n\nif (PHP_VERSION_ID < 70000) {\n    if (!is_callable('sodiumCompatAutoloader')) {\n        \/**\n         * Sodium_Compat autoloader.\n         *\n         * @param string $class Class name to be autoloaded.\n         *\n         * @return bool         Stop autoloading?\n         *\/\n        function sodiumCompatAutoloader($class)\n        {\n            $namespace = 'ParagonIE_Sodium_';\n            \/\/ Does the class use the namespace prefix?\n            $len = strlen($namespace);\n            if (strncmp($namespace, $class, $len) !== 0) {\n                \/\/ no, move to the next registered autoloader\n                return false;\n            }\n\n            \/\/ Get the relative class name\n            $relative_class = substr($class, $len);\n\n            \/\/ Replace the namespace prefix with the base directory, replace namespace\n            \/\/ separators with directory separators in the relative class name, append\n            \/\/ with .php\n            $file = dirname(__FILE__) . '\/src\/' . str_replace('_', '\/', $relative_class) . '.php';\n            \/\/ if the file exists, require it\n            if (file_exists($file)) {\n                require_once $file;\n                return true;\n            }\n            return false;\n        }\n\n        \/\/ Now that we have an autoloader, let's register it!\n        spl_autoload_register('sodiumCompatAutoloader');\n    }\n} else {\n    require_once dirname(__FILE__) . '\/autoload-php7.php';\n}\n\n\/* Explicitly, always load the Compat class: *\/\nif (!class_exists('ParagonIE_Sodium_Compat', false)) {\n    require_once dirname(__FILE__) . '\/src\/Compat.php';\n}\n\nif (!class_exists('SodiumException', false)) {\n    require_once dirname(__FILE__) . '\/src\/SodiumException.php';\n}\nif (PHP_VERSION_ID >= 50300) {\n    \/\/ Namespaces didn't exist before 5.3.0, so don't even try to use this\n    \/\/ unless PHP >= 5.3.0\n    require_once dirname(__FILE__) . '\/lib\/namespaced.php';\n    require_once dirname(__FILE__) . '\/lib\/sodium_compat.php';\n} else {\n    require_once dirname(__FILE__) . '\/src\/PHP52\/SplFixedArray.php';\n}\nif (PHP_VERSION_ID < 70200 || !extension_loaded('sodium')) {\n    if (PHP_VERSION_ID >= 50300 && !defined('SODIUM_CRYPTO_SCALARMULT_BYTES')) {\n        require_once dirname(__FILE__) . '\/lib\/php72compat_const.php';\n    }\n    if (PHP_VERSION_ID >= 70000) {\n        assert(class_exists('ParagonIE_Sodium_Compat'), 'Possible filesystem\/autoloader bug?');\n    } else {\n        assert(class_exists('ParagonIE_Sodium_Compat'));\n    }\n    require_once(dirname(__FILE__) . '\/lib\/php72compat.php');\n} elseif (!function_exists('sodium_crypto_stream_xchacha20_xor')) {\n    \/\/ Older versions of {PHP, ext\/sodium} will not define these\n    require_once(dirname(__FILE__) . '\/lib\/php72compat.php');\n}\nrequire_once(dirname(__FILE__) . '\/lib\/stream-xchacha20.php');\nrequire_once(dirname(__FILE__) . '\/lib\/ristretto255.php');\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/composer-php52.json","ext":"json","size":2179,"mtime":1756374919,"type":"text","content":"{\n  \"name\": \"paragonie\/sodium_compat\",\n  \"description\": \"Pure PHP implementation of libsodium; uses the PHP extension if it exists\",\n  \"keywords\": [\n    \"PHP\",\n    \"cryptography\",\n    \"elliptic curve\",\n    \"elliptic curve cryptography\",\n    \"Pure-PHP cryptography\",\n    \"side-channel resistant\",\n    \"Curve25519\",\n    \"X25519\",\n    \"ECDH\",\n    \"Elliptic Curve Diffie-Hellman\",\n    \"Ed25519\",\n    \"RFC 7748\",\n    \"RFC 8032\",\n    \"EdDSA\",\n    \"Edwards-curve Digital Signature Algorithm\",\n    \"ChaCha20\",\n    \"Salsa20\",\n    \"Xchacha20\",\n    \"Xsalsa20\",\n    \"Poly1305\",\n    \"BLAKE2b\",\n    \"public-key cryptography\",\n    \"secret-key cryptography\",\n    \"AEAD\",\n    \"Chapoly\",\n    \"Salpoly\",\n    \"ChaCha20-Poly1305\",\n    \"XSalsa20-Poly1305\",\n    \"XChaCha20-Poly1305\",\n    \"encryption\",\n    \"authentication\",\n    \"libsodium\"\n  ],\n  \"license\": \"ISC\",\n  \"authors\": [\n    {\n      \"name\": \"Paragon Initiative Enterprises\",\n      \"email\": \"security@paragonie.com\"\n    },\n    {\n      \"name\": \"Frank Denis\",\n      \"email\": \"jedisct1@pureftpd.org\"\n    }\n  ],\n  \"autoload\": {\n    \"files\": [\"autoload.php\"]\n  },\n  \"repositories\": [\n    {\n      \"type\": \"git\",\n      \"url\": \"https:\/\/github.com\/garex\/phpunit\"\n    },\n    {\n      \"type\": \"git\",\n      \"url\": \"https:\/\/github.com\/garex\/phpunit-mock-objects\"\n    }\n  ],\n  \"require\": {\n    \"php\": \"^5.2.4|^5.3|^5.4|^5.5|^5.6|^7|^8\",\n    \"xrstf\/composer-php52\": \"1.*\",\n    \"paragonie\/random_compat\": \">=1\"\n  },\n  \"minimum-stability\": \"dev\",\n  \"require-dev\": {\n    \"phpunit\/phpunit-php52\": \"dev-3.6.12-php52\",\n    \"phpunit\/phpunit-mock-objects-php52\": \"dev-1.1.0-php52\"\n  },\n  \"scripts\": {\n    \"post-install-cmd\": [\n      \"xrstf\\\\Composer52\\\\Generator::onPostInstallCmd\"\n    ],\n    \"post-update-cmd\": [\n      \"xrstf\\\\Composer52\\\\Generator::onPostInstallCmd\"\n    ],\n    \"post-autoload-dump\": [\n      \"xrstf\\\\Composer52\\\\Generator::onPostInstallCmd\"\n    ]\n  },\n  \"suggest\": {\n    \"ext-libsodium\": \"PHP < 7.0: Better performance, password hashing (Argon2i), secure memory management (memzero), and better security.\",\n    \"ext-sodium\": \"PHP >= 7.0: Better performance, password hashing (Argon2i), secure memory management (memzero), and better security.\"\n  }\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/autoload-php7.php","ext":"php","size":949,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\n\/*\n This file should only ever be loaded on PHP 7+\n *\/\nif (PHP_VERSION_ID < 70000) {\n    return;\n}\n\nspl_autoload_register(function ($class) {\n    $namespace = 'ParagonIE_Sodium_';\n    \/\/ Does the class use the namespace prefix?\n    $len = strlen($namespace);\n    if (strncmp($namespace, $class, $len) !== 0) {\n        \/\/ no, move to the next registered autoloader\n        return false;\n    }\n\n    \/\/ Get the relative class name\n    $relative_class = substr($class, $len);\n\n    \/\/ Replace the namespace prefix with the base directory, replace namespace\n    \/\/ separators with directory separators in the relative class name, append\n    \/\/ with .php\n    $file = dirname(__FILE__) . '\/src\/' . str_replace('_', '\/', $relative_class) . '.php';\n    \/\/ if the file exists, require it\n    if (file_exists($file)) {\n        require_once $file;\n        return true;\n    }\n    return false;\n});\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/namespaced\/Core\/Ed25519.php","ext":"php","size":157,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\nnamespace ParagonIE\\Sodium\\Core;\n\nclass Ed25519 extends \\ParagonIE_Sodium_Core_Ed25519\n{\n\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/namespaced\/Core\/X25519.php","ext":"php","size":155,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\nnamespace ParagonIE\\Sodium\\Core;\n\nclass X25519 extends \\ParagonIE_Sodium_Core_X25519\n{\n\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/namespaced\/Core\/XChaCha20.php","ext":"php","size":161,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\nnamespace ParagonIE\\Sodium\\Core;\n\nclass XChaCha20 extends \\ParagonIE_Sodium_Core_XChaCha20\n{\n\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/namespaced\/Core\/Salsa20.php","ext":"php","size":157,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\nnamespace ParagonIE\\Sodium\\Core;\n\nclass Salsa20 extends \\ParagonIE_Sodium_Core_Salsa20\n{\n\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/namespaced\/Core\/Util.php","ext":"php","size":151,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\nnamespace ParagonIE\\Sodium\\Core;\n\nclass Util extends \\ParagonIE_Sodium_Core_Util\n{\n\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/namespaced\/Core\/Curve25519.php","ext":"php","size":163,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\nnamespace ParagonIE\\Sodium\\Core;\n\nclass Curve25519 extends \\ParagonIE_Sodium_Core_Curve25519\n{\n\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/namespaced\/Core\/Poly1305\/State.php","ext":"php","size":171,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\nnamespace ParagonIE\\Sodium\\Core\\Poly1305;\n\nclass State extends \\ParagonIE_Sodium_Core_Poly1305_State\n{\n\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/namespaced\/Core\/BLAKE2b.php","ext":"php","size":157,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\nnamespace ParagonIE\\Sodium\\Core;\n\nclass BLAKE2b extends \\ParagonIE_Sodium_Core_BLAKE2b\n{\n\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/namespaced\/Core\/ChaCha20.php","ext":"php","size":159,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\nnamespace ParagonIE\\Sodium\\Core;\n\nclass ChaCha20 extends \\ParagonIE_Sodium_Core_ChaCha20\n{\n\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/namespaced\/Core\/SipHash.php","ext":"php","size":157,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\nnamespace ParagonIE\\Sodium\\Core;\n\nclass SipHash extends \\ParagonIE_Sodium_Core_SipHash\n{\n\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/namespaced\/Core\/HChaCha20.php","ext":"php","size":161,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\nnamespace ParagonIE\\Sodium\\Core;\n\nclass HChaCha20 extends \\ParagonIE_Sodium_Core_HChaCha20\n{\n\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/namespaced\/Core\/Poly1305.php","ext":"php","size":159,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\nnamespace ParagonIE\\Sodium\\Core;\n\nclass Poly1305 extends \\ParagonIE_Sodium_Core_Poly1305\n{\n\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/namespaced\/Core\/Curve25519\/Fe.php","ext":"php","size":169,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\nnamespace ParagonIE\\Sodium\\Core\\Curve25519;\n\nclass Fe extends \\ParagonIE_Sodium_Core_Curve25519_Fe\n{\n\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/namespaced\/Core\/Curve25519\/H.php","ext":"php","size":167,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\nnamespace ParagonIE\\Sodium\\Core\\Curve25519;\n\nclass H extends \\ParagonIE_Sodium_Core_Curve25519_H\n{\n\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/namespaced\/Core\/Curve25519\/Ge\/Cached.php","ext":"php","size":183,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\nnamespace ParagonIE\\Sodium\\Core\\Curve25519\\Ge;\n\nclass Cached extends \\ParagonIE_Sodium_Core_Curve25519_Ge_Cached\n{\n\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/namespaced\/Core\/Curve25519\/Ge\/Precomp.php","ext":"php","size":185,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\nnamespace ParagonIE\\Sodium\\Core\\Curve25519\\Ge;\n\nclass Precomp extends \\ParagonIE_Sodium_Core_Curve25519_Ge_Precomp\n{\n\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/namespaced\/Core\/Curve25519\/Ge\/P3.php","ext":"php","size":175,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\nnamespace ParagonIE\\Sodium\\Core\\Curve25519\\Ge;\n\nclass P3 extends \\ParagonIE_Sodium_Core_Curve25519_Ge_P3\n{\n\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/namespaced\/Core\/Curve25519\/Ge\/P1p1.php","ext":"php","size":179,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\nnamespace ParagonIE\\Sodium\\Core\\Curve25519\\Ge;\n\nclass P1p1 extends \\ParagonIE_Sodium_Core_Curve25519_Ge_P1p1\n{\n\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/namespaced\/Core\/Curve25519\/Ge\/P2.php","ext":"php","size":175,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\nnamespace ParagonIE\\Sodium\\Core\\Curve25519\\Ge;\n\nclass P2 extends \\ParagonIE_Sodium_Core_Curve25519_Ge_P2\n{\n\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/namespaced\/Core\/HSalsa20.php","ext":"php","size":159,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\nnamespace ParagonIE\\Sodium\\Core;\n\nclass HSalsa20 extends \\ParagonIE_Sodium_Core_HSalsa20\n{\n\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/namespaced\/Core\/Xsalsa20.php","ext":"php","size":159,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\nnamespace ParagonIE\\Sodium\\Core;\n\nclass Xsalsa20 extends \\ParagonIE_Sodium_Core_XSalsa20\n{\n\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/namespaced\/Core\/ChaCha20\/IetfCtx.php","ext":"php","size":175,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\nnamespace ParagonIE\\Sodium\\Core\\ChaCha20;\n\nclass IetfCtx extends \\ParagonIE_Sodium_Core_ChaCha20_IetfCtx\n{\n\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/namespaced\/Core\/ChaCha20\/Ctx.php","ext":"php","size":167,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\nnamespace ParagonIE\\Sodium\\Core\\ChaCha20;\n\nclass Ctx extends \\ParagonIE_Sodium_Core_ChaCha20_Ctx\n{\n\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/namespaced\/Crypto.php","ext":"php","size":145,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\nnamespace ParagonIE\\Sodium;\n\nclass Crypto extends \\ParagonIE_Sodium_Crypto\n{\n\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/namespaced\/Compat.php","ext":"php","size":145,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\nnamespace ParagonIE\\Sodium;\n\nclass Compat extends \\ParagonIE_Sodium_Compat\n{\n\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/namespaced\/File.php","ext":"php","size":141,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\nnamespace ParagonIE\\Sodium;\n\nclass File extends \\ParagonIE_Sodium_File\n{\n\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/src\/PHP52\/SplFixedArray.php","ext":"php","size":4175,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\n\nif (class_exists('SplFixedArray')) {\n    return;\n}\n\n\/**\n * The SplFixedArray class provides the main functionalities of array. The\n * main differences between a SplFixedArray and a normal PHP array is that\n * the SplFixedArray is of fixed length and allows only integers within\n * the range as indexes. The advantage is that it allows a faster array\n * implementation.\n *\/\nclass SplFixedArray implements Iterator, ArrayAccess, Countable\n{\n    \/** @var array<int, mixed> *\/\n    private $internalArray = array();\n\n    \/** @var int $size *\/\n    private $size = 0;\n\n    \/**\n     * SplFixedArray constructor.\n     * @param int $size\n     *\/\n    public function __construct($size = 0)\n    {\n        $this->size = $size;\n        $this->internalArray = array();\n    }\n\n    \/**\n     * @return int\n     *\/\n    public function count()\n    {\n        return count($this->internalArray);\n    }\n\n    \/**\n     * @return array\n     *\/\n    public function toArray()\n    {\n        ksort($this->internalArray);\n        return (array) $this->internalArray;\n    }\n\n    \/**\n     * @param array $array\n     * @param bool $save_indexes\n     * @return SplFixedArray\n     * @psalm-suppress MixedAssignment\n     *\/\n    public static function fromArray(array $array, $save_indexes = true)\n    {\n        $self = new SplFixedArray(count($array));\n        if($save_indexes) {\n            foreach($array as $key => $value) {\n                $self[(int) $key] = $value;\n            }\n        } else {\n            $i = 0;\n            foreach (array_values($array) as $value) {\n                $self[$i] = $value;\n                $i++;\n            }\n        }\n        return $self;\n    }\n\n    \/**\n     * @return int\n     *\/\n    public function getSize()\n    {\n        return $this->size;\n    }\n\n    \/**\n     * @param int $size\n     * @return bool\n     *\/\n    public function setSize($size)\n    {\n        $this->size = $size;\n        return true;\n    }\n\n    \/**\n     * @param string|int $index\n     * @return bool\n     *\/\n    public function offsetExists($index)\n    {\n        return array_key_exists((int) $index, $this->internalArray);\n    }\n\n    \/**\n     * @param string|int $index\n     * @return mixed\n     *\/\n    public function offsetGet($index)\n    {\n        \/** @psalm-suppress MixedReturnStatement *\/\n        return $this->internalArray[(int) $index];\n    }\n\n    \/**\n     * @param string|int $index\n     * @param mixed $newval\n     * @psalm-suppress MixedAssignment\n     *\/\n    public function offsetSet($index, $newval)\n    {\n        $this->internalArray[(int) $index] = $newval;\n    }\n\n    \/**\n     * @param string|int $index\n     *\/\n    public function offsetUnset($index)\n    {\n        unset($this->internalArray[(int) $index]);\n    }\n\n    \/**\n     * Rewind iterator back to the start\n     * @link https:\/\/php.net\/manual\/en\/splfixedarray.rewind.php\n     * @return void\n     * @since 5.3.0\n     *\/\n    public function rewind()\n    {\n        reset($this->internalArray);\n    }\n\n    \/**\n     * Return current array entry\n     * @link https:\/\/php.net\/manual\/en\/splfixedarray.current.php\n     * @return mixed The current element value.\n     * @since 5.3.0\n     *\/\n    public function current()\n    {\n        \/** @psalm-suppress MixedReturnStatement *\/\n        return current($this->internalArray);\n    }\n\n    \/**\n     * Return current array index\n     * @return int The current array index.\n     *\/\n    public function key()\n    {\n        return key($this->internalArray);\n    }\n\n    \/**\n     * @return void\n     *\/\n    public function next()\n    {\n        next($this->internalArray);\n    }\n\n    \/**\n     * Check whether the array contains more elements\n     * @link https:\/\/php.net\/manual\/en\/splfixedarray.valid.php\n     * @return bool true if the array contains any more elements, false otherwise.\n     *\/\n    public function valid()\n    {\n        if (empty($this->internalArray)) {\n            return false;\n        }\n        $result = next($this->internalArray) !== false;\n        prev($this->internalArray);\n        return $result;\n    }\n\n    \/**\n     * Do nothing.\n     *\/\n    public function __wakeup()\n    {\n        \/\/ NOP\n    }\n}"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/src\/SodiumException.php","ext":"php","size":217,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\n\nif (!class_exists('SodiumException', false)) {\n    \/**\n     * Class SodiumException\n     *\/\n    class SodiumException extends Exception\n    {\n\n    }\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/src\/Core\/Ed25519.php","ext":"php","size":17543,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\n\nif (class_exists('ParagonIE_Sodium_Core_Ed25519', false)) {\n    return;\n}\nif (!class_exists('ParagonIE_Sodium_Core_Curve25519', false)) {\n    require_once dirname(__FILE__) . '\/Curve25519.php';\n}\n\n\/**\n * Class ParagonIE_Sodium_Core_Ed25519\n *\/\nabstract class ParagonIE_Sodium_Core_Ed25519 extends ParagonIE_Sodium_Core_Curve25519\n{\n    const KEYPAIR_BYTES = 96;\n    const SEED_BYTES = 32;\n    const SCALAR_BYTES = 32;\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @return string (96 bytes)\n     * @throws Exception\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function keypair()\n    {\n        $seed = random_bytes(self::SEED_BYTES);\n        $pk = '';\n        $sk = '';\n        self::seed_keypair($pk, $sk, $seed);\n        return $sk . $pk;\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param string $pk\n     * @param string $sk\n     * @param string $seed\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function seed_keypair(&$pk, &$sk, $seed)\n    {\n        if (self::strlen($seed) !== self::SEED_BYTES) {\n            throw new RangeException('crypto_sign keypair seed must be 32 bytes long');\n        }\n\n        \/** @var string $pk *\/\n        $pk = self::publickey_from_secretkey($seed);\n        $sk = $seed . $pk;\n        return $sk;\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param string $keypair\n     * @return string\n     * @throws TypeError\n     *\/\n    public static function secretkey($keypair)\n    {\n        if (self::strlen($keypair) !== self::KEYPAIR_BYTES) {\n            throw new RangeException('crypto_sign keypair must be 96 bytes long');\n        }\n        return self::substr($keypair, 0, 64);\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param string $keypair\n     * @return string\n     * @throws TypeError\n     *\/\n    public static function publickey($keypair)\n    {\n        if (self::strlen($keypair) !== self::KEYPAIR_BYTES) {\n            throw new RangeException('crypto_sign keypair must be 96 bytes long');\n        }\n        return self::substr($keypair, 64, 32);\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param string $sk\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function publickey_from_secretkey($sk)\n    {\n        \/** @var string $sk *\/\n        $sk = hash('sha512', self::substr($sk, 0, 32), true);\n        $sk[0] = self::intToChr(\n            self::chrToInt($sk[0]) & 248\n        );\n        $sk[31] = self::intToChr(\n            (self::chrToInt($sk[31]) & 63) | 64\n        );\n        return self::sk_to_pk($sk);\n    }\n\n    \/**\n     * @param string $pk\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function pk_to_curve25519($pk)\n    {\n        if (self::small_order($pk)) {\n            throw new SodiumException('Public key is on a small order');\n        }\n        $A = self::ge_frombytes_negate_vartime(self::substr($pk, 0, 32));\n        $p1 = self::ge_mul_l($A);\n        if (!self::fe_isnonzero($p1->X)) {\n            throw new SodiumException('Unexpected zero result');\n        }\n\n        # fe_1(one_minus_y);\n        # fe_sub(one_minus_y, one_minus_y, A.Y);\n        # fe_invert(one_minus_y, one_minus_y);\n        $one_minux_y = self::fe_invert(\n            self::fe_sub(\n                self::fe_1(),\n                $A->Y\n            )\n        );\n\n        # fe_1(x);\n        # fe_add(x, x, A.Y);\n        # fe_mul(x, x, one_minus_y);\n        $x = self::fe_mul(\n            self::fe_add(self::fe_1(), $A->Y),\n            $one_minux_y\n        );\n\n        # fe_tobytes(curve25519_pk, x);\n        return self::fe_tobytes($x);\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param string $sk\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function sk_to_pk($sk)\n    {\n        return self::ge_p3_tobytes(\n            self::ge_scalarmult_base(\n                self::substr($sk, 0, 32)\n            )\n        );\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param string $message\n     * @param string $sk\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function sign($message, $sk)\n    {\n        \/** @var string $signature *\/\n        $signature = self::sign_detached($message, $sk);\n        return $signature . $message;\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param string $message A signed message\n     * @param string $pk      Public key\n     * @return string         Message (without signature)\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function sign_open($message, $pk)\n    {\n        \/** @var string $signature *\/\n        $signature = self::substr($message, 0, 64);\n\n        \/** @var string $message *\/\n        $message = self::substr($message, 64);\n\n        if (self::verify_detached($signature, $message, $pk)) {\n            return $message;\n        }\n        throw new SodiumException('Invalid signature');\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param string $message\n     * @param string $sk\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function sign_detached($message, $sk)\n    {\n        # crypto_hash_sha512(az, sk, 32);\n        $az =  hash('sha512', self::substr($sk, 0, 32), true);\n\n        # az[0] &= 248;\n        # az[31] &= 63;\n        # az[31] |= 64;\n        $az[0] = self::intToChr(self::chrToInt($az[0]) & 248);\n        $az[31] = self::intToChr((self::chrToInt($az[31]) & 63) | 64);\n\n        # crypto_hash_sha512_init(&hs);\n        # crypto_hash_sha512_update(&hs, az + 32, 32);\n        # crypto_hash_sha512_update(&hs, m, mlen);\n        # crypto_hash_sha512_final(&hs, nonce);\n        $hs = hash_init('sha512');\n        hash_update($hs, self::substr($az, 32, 32));\n        hash_update($hs, $message);\n        $nonceHash = hash_final($hs, true);\n\n        # memmove(sig + 32, sk + 32, 32);\n        $pk = self::substr($sk, 32, 32);\n\n        # sc_reduce(nonce);\n        # ge_scalarmult_base(&R, nonce);\n        # ge_p3_tobytes(sig, &R);\n        $nonce = self::sc_reduce($nonceHash) . self::substr($nonceHash, 32);\n        $sig = self::ge_p3_tobytes(\n            self::ge_scalarmult_base($nonce)\n        );\n\n        # crypto_hash_sha512_init(&hs);\n        # crypto_hash_sha512_update(&hs, sig, 64);\n        # crypto_hash_sha512_update(&hs, m, mlen);\n        # crypto_hash_sha512_final(&hs, hram);\n        $hs = hash_init('sha512');\n        hash_update($hs, self::substr($sig, 0, 32));\n        hash_update($hs, self::substr($pk, 0, 32));\n        hash_update($hs, $message);\n        $hramHash = hash_final($hs, true);\n\n        # sc_reduce(hram);\n        # sc_muladd(sig + 32, hram, az, nonce);\n        $hram = self::sc_reduce($hramHash);\n        $sigAfter = self::sc_muladd($hram, $az, $nonce);\n        $sig = self::substr($sig, 0, 32) . self::substr($sigAfter, 0, 32);\n\n        try {\n            ParagonIE_Sodium_Compat::memzero($az);\n        } catch (SodiumException $ex) {\n            $az = null;\n        }\n        return $sig;\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param string $sig\n     * @param string $message\n     * @param string $pk\n     * @return bool\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function verify_detached($sig, $message, $pk)\n    {\n        if (self::strlen($sig) < 64) {\n            throw new SodiumException('Signature is too short');\n        }\n        if ((self::chrToInt($sig[63]) & 240) && self::check_S_lt_L(self::substr($sig, 32, 32))) {\n            throw new SodiumException('S < L - Invalid signature');\n        }\n        if (self::small_order($sig)) {\n            throw new SodiumException('Signature is on too small of an order');\n        }\n        if ((self::chrToInt($sig[63]) & 224) !== 0) {\n            throw new SodiumException('Invalid signature');\n        }\n        $d = 0;\n        for ($i = 0; $i < 32; ++$i) {\n            $d |= self::chrToInt($pk[$i]);\n        }\n        if ($d === 0) {\n            throw new SodiumException('All zero public key');\n        }\n\n        \/** @var bool The original value of ParagonIE_Sodium_Compat::$fastMult *\/\n        $orig = ParagonIE_Sodium_Compat::$fastMult;\n\n        \/\/ Set ParagonIE_Sodium_Compat::$fastMult to true to speed up verification.\n        ParagonIE_Sodium_Compat::$fastMult = true;\n\n        \/** @var ParagonIE_Sodium_Core_Curve25519_Ge_P3 $A *\/\n        $A = self::ge_frombytes_negate_vartime($pk);\n\n        \/** @var string $hDigest *\/\n        $hDigest = hash(\n            'sha512',\n            self::substr($sig, 0, 32) .\n                self::substr($pk, 0, 32) .\n                $message,\n            true\n        );\n\n        \/** @var string $h *\/\n        $h = self::sc_reduce($hDigest) . self::substr($hDigest, 32);\n\n        \/** @var ParagonIE_Sodium_Core_Curve25519_Ge_P2 $R *\/\n        $R = self::ge_double_scalarmult_vartime(\n            $h,\n            $A,\n            self::substr($sig, 32)\n        );\n\n        \/** @var string $rcheck *\/\n        $rcheck = self::ge_tobytes($R);\n\n        \/\/ Reset ParagonIE_Sodium_Compat::$fastMult to what it was before.\n        ParagonIE_Sodium_Compat::$fastMult = $orig;\n\n        return self::verify_32($rcheck, self::substr($sig, 0, 32));\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param string $S\n     * @return bool\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function check_S_lt_L($S)\n    {\n        if (self::strlen($S) < 32) {\n            throw new SodiumException('Signature must be 32 bytes');\n        }\n        $L = array(\n            0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58,\n            0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10\n        );\n        $c = 0;\n        $n = 1;\n        $i = 32;\n\n        \/** @var array<int, int> $L *\/\n        do {\n            --$i;\n            $x = self::chrToInt($S[$i]);\n            $c |= (\n                (($x - $L[$i]) >> 8) & $n\n            );\n            $n &= (\n                (($x ^ $L[$i]) - 1) >> 8\n            );\n        } while ($i !== 0);\n\n        return $c === 0;\n    }\n\n    \/**\n     * @param string $R\n     * @return bool\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function small_order($R)\n    {\n        \/** @var array<int, array<int, int>> $blocklist *\/\n        $blocklist = array(\n            \/* 0 (order 4) *\/\n            array(\n                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n            ),\n            \/* 1 (order 1) *\/\n            array(\n                0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n            ),\n            \/* 2707385501144840649318225287225658788936804267575313519463743609750303402022 (order 8) *\/\n            array(\n                0x26, 0xe8, 0x95, 0x8f, 0xc2, 0xb2, 0x27, 0xb0,\n                0x45, 0xc3, 0xf4, 0x89, 0xf2, 0xef, 0x98, 0xf0,\n                0xd5, 0xdf, 0xac, 0x05, 0xd3, 0xc6, 0x33, 0x39,\n                0xb1, 0x38, 0x02, 0x88, 0x6d, 0x53, 0xfc, 0x05\n            ),\n            \/* 55188659117513257062467267217118295137698188065244968500265048394206261417927 (order 8) *\/\n            array(\n                0xc7, 0x17, 0x6a, 0x70, 0x3d, 0x4d, 0xd8, 0x4f,\n                0xba, 0x3c, 0x0b, 0x76, 0x0d, 0x10, 0x67, 0x0f,\n                0x2a, 0x20, 0x53, 0xfa, 0x2c, 0x39, 0xcc, 0xc6,\n                0x4e, 0xc7, 0xfd, 0x77, 0x92, 0xac, 0x03, 0x7a\n            ),\n            \/* p-1 (order 2) *\/\n            array(\n                0x13, 0xe8, 0x95, 0x8f, 0xc2, 0xb2, 0x27, 0xb0,\n                0x45, 0xc3, 0xf4, 0x89, 0xf2, 0xef, 0x98, 0xf0,\n                0xd5, 0xdf, 0xac, 0x05, 0xd3, 0xc6, 0x33, 0x39,\n                0xb1, 0x38, 0x02, 0x88, 0x6d, 0x53, 0xfc, 0x85\n            ),\n            \/* p (order 4) *\/\n            array(\n                0xb4, 0x17, 0x6a, 0x70, 0x3d, 0x4d, 0xd8, 0x4f,\n                0xba, 0x3c, 0x0b, 0x76, 0x0d, 0x10, 0x67, 0x0f,\n                0x2a, 0x20, 0x53, 0xfa, 0x2c, 0x39, 0xcc, 0xc6,\n                0x4e, 0xc7, 0xfd, 0x77, 0x92, 0xac, 0x03, 0xfa\n            ),\n            \/* p+1 (order 1) *\/\n            array(\n                0xec, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f\n            ),\n            \/* p+2707385501144840649318225287225658788936804267575313519463743609750303402022 (order 8) *\/\n            array(\n                0xed, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f\n            ),\n            \/* p+55188659117513257062467267217118295137698188065244968500265048394206261417927 (order 8) *\/\n            array(\n                0xee, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f\n            ),\n            \/* 2p-1 (order 2) *\/\n            array(\n                0xd9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n            ),\n            \/* 2p (order 4) *\/\n            array(\n                0xda, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n            ),\n            \/* 2p+1 (order 1) *\/\n            array(\n                0xdb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n            )\n        );\n        \/** @var int $countBlocklist *\/\n        $countBlocklist = count($blocklist);\n\n        for ($i = 0; $i < $countBlocklist; ++$i) {\n            $c = 0;\n            for ($j = 0; $j < 32; ++$j) {\n                $c |= self::chrToInt($R[$j]) ^ (int) $blocklist[$i][$j];\n            }\n            if ($c === 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    \/**\n     * @param string $s\n     * @return string\n     * @throws SodiumException\n     *\/\n    public static function scalar_complement($s)\n    {\n        $t_ = self::L . str_repeat(\"\\x00\", 32);\n        sodium_increment($t_);\n        $s_ = $s . str_repeat(\"\\x00\", 32);\n        ParagonIE_Sodium_Compat::sub($t_, $s_);\n        return self::sc_reduce($t_);\n    }\n\n    \/**\n     * @return string\n     * @throws SodiumException\n     *\/\n    public static function scalar_random()\n    {\n        do {\n            $r = ParagonIE_Sodium_Compat::randombytes_buf(self::SCALAR_BYTES);\n            $r[self::SCALAR_BYTES - 1] = self::intToChr(\n                self::chrToInt($r[self::SCALAR_BYTES - 1]) & 0x1f\n            );\n        } while (\n            !self::check_S_lt_L($r) || ParagonIE_Sodium_Compat::is_zero($r)\n        );\n        return $r;\n    }\n\n    \/**\n     * @param string $s\n     * @return string\n     * @throws SodiumException\n     *\/\n    public static function scalar_negate($s)\n    {\n        $t_ = self::L . str_repeat(\"\\x00\", 32) ;\n        $s_ = $s . str_repeat(\"\\x00\", 32) ;\n        ParagonIE_Sodium_Compat::sub($t_, $s_);\n        return self::sc_reduce($t_);\n    }\n\n    \/**\n     * @param string $a\n     * @param string $b\n     * @return string\n     * @throws SodiumException\n     *\/\n    public static function scalar_add($a, $b)\n    {\n        $a_ = $a . str_repeat(\"\\x00\", 32);\n        $b_ = $b . str_repeat(\"\\x00\", 32);\n        ParagonIE_Sodium_Compat::add($a_, $b_);\n        return self::sc_reduce($a_);\n    }\n\n    \/**\n     * @param string $x\n     * @param string $y\n     * @return string\n     * @throws SodiumException\n     *\/\n    public static function scalar_sub($x, $y)\n    {\n        $yn = self::scalar_negate($y);\n        return self::scalar_add($x, $yn);\n    }\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/src\/Core\/Ristretto255.php","ext":"php","size":21943,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\n\n\/**\n * Class ParagonIE_Sodium_Core_Ristretto255\n *\/\nclass ParagonIE_Sodium_Core_Ristretto255 extends ParagonIE_Sodium_Core_Ed25519\n{\n    const crypto_core_ristretto255_HASHBYTES = 64;\n    const HASH_SC_L = 48;\n    const CORE_H2C_SHA256 = 1;\n    const CORE_H2C_SHA512 = 2;\n\n    \/**\n     * @param ParagonIE_Sodium_Core_Curve25519_Fe $f\n     * @param int $b\n     * @return ParagonIE_Sodium_Core_Curve25519_Fe\n     *\/\n    public static function fe_cneg(ParagonIE_Sodium_Core_Curve25519_Fe $f, $b)\n    {\n        $negf = self::fe_neg($f);\n        return self::fe_cmov($f, $negf, $b);\n    }\n\n    \/**\n     * @param ParagonIE_Sodium_Core_Curve25519_Fe $f\n     * @return ParagonIE_Sodium_Core_Curve25519_Fe\n     * @throws SodiumException\n     *\/\n    public static function fe_abs(ParagonIE_Sodium_Core_Curve25519_Fe $f)\n    {\n        return self::fe_cneg($f, self::fe_isnegative($f));\n    }\n\n    \/**\n     * Returns 0 if this field element results in all NUL bytes.\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param ParagonIE_Sodium_Core_Curve25519_Fe $f\n     * @return int\n     * @throws SodiumException\n     *\/\n    public static function fe_iszero(ParagonIE_Sodium_Core_Curve25519_Fe $f)\n    {\n        static $zero;\n        if ($zero === null) {\n            $zero = str_repeat(\"\\x00\", 32);\n        }\n        \/** @var string $zero *\/\n        $str = self::fe_tobytes($f);\n\n        $d = 0;\n        for ($i = 0; $i < 32; ++$i) {\n            $d |= self::chrToInt($str[$i]);\n        }\n        return (($d - 1) >> 31) & 1;\n    }\n\n\n    \/**\n     * @param ParagonIE_Sodium_Core_Curve25519_Fe $u\n     * @param ParagonIE_Sodium_Core_Curve25519_Fe $v\n     * @return array{x: ParagonIE_Sodium_Core_Curve25519_Fe, nonsquare: int}\n     *\n     * @throws SodiumException\n     *\/\n    public static function ristretto255_sqrt_ratio_m1(\n        ParagonIE_Sodium_Core_Curve25519_Fe $u,\n        ParagonIE_Sodium_Core_Curve25519_Fe $v\n    ) {\n        $sqrtm1 = ParagonIE_Sodium_Core_Curve25519_Fe::fromArray(self::$sqrtm1);\n\n        $v3 = self::fe_mul(\n            self::fe_sq($v),\n            $v\n        ); \/* v3 = v^3 *\/\n        $x = self::fe_mul(\n            self::fe_mul(\n                self::fe_sq($v3),\n                $u\n            ),\n            $v\n        ); \/* x = uv^7 *\/\n\n        $x = self::fe_mul(\n            self::fe_mul(\n                self::fe_pow22523($x), \/* x = (uv^7)^((q-5)\/8) *\/\n                $v3\n            ),\n            $u\n        ); \/* x = uv^3(uv^7)^((q-5)\/8) *\/\n\n        $vxx = self::fe_mul(\n            self::fe_sq($x),\n            $v\n        ); \/* vx^2 *\/\n\n        $m_root_check = self::fe_sub($vxx, $u); \/* vx^2-u *\/\n        $p_root_check = self::fe_add($vxx, $u); \/* vx^2+u *\/\n        $f_root_check = self::fe_mul($u, $sqrtm1); \/* u*sqrt(-1) *\/\n        $f_root_check = self::fe_add($vxx, $f_root_check); \/* vx^2+u*sqrt(-1) *\/\n\n        $has_m_root = self::fe_iszero($m_root_check);\n        $has_p_root = self::fe_iszero($p_root_check);\n        $has_f_root = self::fe_iszero($f_root_check);\n\n        $x_sqrtm1 = self::fe_mul($x, $sqrtm1); \/* x*sqrt(-1) *\/\n\n        $x = self::fe_abs(\n            self::fe_cmov($x, $x_sqrtm1, $has_p_root | $has_f_root)\n        );\n        return array(\n            'x' => $x,\n            'nonsquare' => $has_m_root | $has_p_root\n        );\n    }\n\n    \/**\n     * @param string $s\n     * @return int\n     * @throws SodiumException\n     *\/\n    public static function ristretto255_point_is_canonical($s)\n    {\n        $c = (self::chrToInt($s[31]) & 0x7f) ^ 0x7f;\n        for ($i = 30; $i > 0; --$i) {\n            $c |= self::chrToInt($s[$i]) ^ 0xff;\n        }\n        $c = ($c - 1) >> 8;\n        $d = (0xed - 1 - self::chrToInt($s[0])) >> 8;\n        $e = self::chrToInt($s[31]) >> 7;\n\n        return 1 - ((($c & $d) | $e | self::chrToInt($s[0])) & 1);\n    }\n\n    \/**\n     * @param string $s\n     * @param bool $skipCanonicalCheck\n     * @return array{h: ParagonIE_Sodium_Core_Curve25519_Ge_P3, res: int}\n     * @throws SodiumException\n     *\/\n    public static function ristretto255_frombytes($s, $skipCanonicalCheck = false)\n    {\n        if (!$skipCanonicalCheck) {\n            if (!self::ristretto255_point_is_canonical($s)) {\n                throw new SodiumException('S is not canonical');\n            }\n        }\n\n        $s_ = self::fe_frombytes($s);\n        $ss = self::fe_sq($s_); \/* ss = s^2 *\/\n\n        $u1 = self::fe_sub(self::fe_1(), $ss); \/* u1 = 1-ss *\/\n        $u1u1 = self::fe_sq($u1); \/* u1u1 = u1^2 *\/\n\n        $u2 = self::fe_add(self::fe_1(), $ss); \/* u2 = 1+ss *\/\n        $u2u2 = self::fe_sq($u2); \/* u2u2 = u2^2 *\/\n\n        $v = self::fe_mul(\n            ParagonIE_Sodium_Core_Curve25519_Fe::fromArray(self::$d),\n            $u1u1\n        ); \/* v = d*u1^2 *\/\n        $v = self::fe_neg($v); \/* v = -d*u1^2 *\/\n        $v = self::fe_sub($v, $u2u2); \/* v = -(d*u1^2)-u2^2 *\/\n        $v_u2u2 = self::fe_mul($v, $u2u2); \/* v_u2u2 = v*u2^2 *\/\n\n        \/\/ fe25519_1(one);\n        \/\/ notsquare = ristretto255_sqrt_ratio_m1(inv_sqrt, one, v_u2u2);\n        $one = self::fe_1();\n        $result = self::ristretto255_sqrt_ratio_m1($one, $v_u2u2);\n        $inv_sqrt = $result['x'];\n        $notsquare = $result['nonsquare'];\n\n        $h = new ParagonIE_Sodium_Core_Curve25519_Ge_P3();\n\n        $h->X = self::fe_mul($inv_sqrt, $u2);\n        $h->Y = self::fe_mul(self::fe_mul($inv_sqrt, $h->X), $v);\n\n        $h->X = self::fe_mul($h->X, $s_);\n        $h->X = self::fe_abs(\n            self::fe_add($h->X, $h->X)\n        );\n        $h->Y = self::fe_mul($u1, $h->Y);\n        $h->Z = self::fe_1();\n        $h->T = self::fe_mul($h->X, $h->Y);\n\n        $res = - ((1 - $notsquare) | self::fe_isnegative($h->T) | self::fe_iszero($h->Y));\n        return array('h' => $h, 'res' => $res);\n    }\n\n    \/**\n     * @param ParagonIE_Sodium_Core_Curve25519_Ge_P3 $h\n     * @return string\n     * @throws SodiumException\n     *\/\n    public static function ristretto255_p3_tobytes(ParagonIE_Sodium_Core_Curve25519_Ge_P3 $h)\n    {\n        $sqrtm1 = ParagonIE_Sodium_Core_Curve25519_Fe::fromArray(self::$sqrtm1);\n        $invsqrtamd = ParagonIE_Sodium_Core_Curve25519_Fe::fromArray(self::$invsqrtamd);\n\n        $u1 = self::fe_add($h->Z, $h->Y); \/* u1 = Z+Y *\/\n        $zmy = self::fe_sub($h->Z, $h->Y); \/* zmy = Z-Y *\/\n        $u1 = self::fe_mul($u1, $zmy); \/* u1 = (Z+Y)*(Z-Y) *\/\n        $u2 = self::fe_mul($h->X, $h->Y); \/* u2 = X*Y *\/\n\n        $u1_u2u2 = self::fe_mul(self::fe_sq($u2), $u1); \/* u1_u2u2 = u1*u2^2 *\/\n        $one = self::fe_1();\n\n        \/\/ fe25519_1(one);\n        \/\/ (void) ristretto255_sqrt_ratio_m1(inv_sqrt, one, u1_u2u2);\n        $result = self::ristretto255_sqrt_ratio_m1($one, $u1_u2u2);\n        $inv_sqrt = $result['x'];\n\n        $den1 = self::fe_mul($inv_sqrt, $u1); \/* den1 = inv_sqrt*u1 *\/\n        $den2 = self::fe_mul($inv_sqrt, $u2); \/* den2 = inv_sqrt*u2 *\/\n        $z_inv = self::fe_mul($h->T, self::fe_mul($den1, $den2)); \/* z_inv = den1*den2*T *\/\n\n        $ix = self::fe_mul($h->X, $sqrtm1); \/* ix = X*sqrt(-1) *\/\n        $iy = self::fe_mul($h->Y, $sqrtm1); \/* iy = Y*sqrt(-1) *\/\n        $eden = self::fe_mul($den1, $invsqrtamd);\n\n        $t_z_inv =  self::fe_mul($h->T, $z_inv); \/* t_z_inv = T*z_inv *\/\n        $rotate = self::fe_isnegative($t_z_inv);\n\n        $x_ = self::fe_copy($h->X);\n        $y_ = self::fe_copy($h->Y);\n        $den_inv = self::fe_copy($den2);\n\n        $x_ = self::fe_cmov($x_, $iy, $rotate);\n        $y_ = self::fe_cmov($y_, $ix, $rotate);\n        $den_inv = self::fe_cmov($den_inv, $eden, $rotate);\n\n        $x_z_inv = self::fe_mul($x_, $z_inv);\n        $y_ = self::fe_cneg($y_, self::fe_isnegative($x_z_inv));\n\n\n        \/\/ fe25519_sub(s_, h->Z, y_);\n        \/\/ fe25519_mul(s_, den_inv, s_);\n        \/\/ fe25519_abs(s_, s_);\n        \/\/ fe25519_tobytes(s, s_);\n        return self::fe_tobytes(\n            self::fe_abs(\n                self::fe_mul(\n                    $den_inv,\n                    self::fe_sub($h->Z, $y_)\n                )\n            )\n        );\n    }\n\n    \/**\n     * @param ParagonIE_Sodium_Core_Curve25519_Fe $t\n     * @return ParagonIE_Sodium_Core_Curve25519_Ge_P3\n     *\n     * @throws SodiumException\n     *\/\n    public static function ristretto255_elligator(ParagonIE_Sodium_Core_Curve25519_Fe $t)\n    {\n        $sqrtm1   = ParagonIE_Sodium_Core_Curve25519_Fe::fromArray(self::$sqrtm1);\n        $onemsqd  = ParagonIE_Sodium_Core_Curve25519_Fe::fromArray(self::$onemsqd);\n        $d        = ParagonIE_Sodium_Core_Curve25519_Fe::fromArray(self::$d);\n        $sqdmone  = ParagonIE_Sodium_Core_Curve25519_Fe::fromArray(self::$sqdmone);\n        $sqrtadm1 = ParagonIE_Sodium_Core_Curve25519_Fe::fromArray(self::$sqrtadm1);\n\n        $one = self::fe_1();\n        $r   = self::fe_mul($sqrtm1, self::fe_sq($t));         \/* r = sqrt(-1)*t^2 *\/\n        $u   = self::fe_mul(self::fe_add($r, $one), $onemsqd); \/* u = (r+1)*(1-d^2) *\/\n        $c   = self::fe_neg(self::fe_1());                     \/* c = -1 *\/\n        $rpd = self::fe_add($r, $d);                           \/* rpd = r+d *\/\n\n        $v = self::fe_mul(\n            self::fe_sub(\n                $c,\n                self::fe_mul($r, $d)\n            ),\n            $rpd\n        ); \/* v = (c-r*d)*(r+d) *\/\n\n        $result = self::ristretto255_sqrt_ratio_m1($u, $v);\n        $s = $result['x'];\n        $wasnt_square = 1 - $result['nonsquare'];\n\n        $s_prime = self::fe_neg(\n            self::fe_abs(\n                self::fe_mul($s, $t)\n            )\n        ); \/* s_prime = -|s*t| *\/\n        $s = self::fe_cmov($s, $s_prime, $wasnt_square);\n        $c = self::fe_cmov($c, $r, $wasnt_square);\n\n        \/\/ fe25519_sub(n, r, one);            \/* n = r-1 *\/\n        \/\/ fe25519_mul(n, n, c);              \/* n = c*(r-1) *\/\n        \/\/ fe25519_mul(n, n, ed25519_sqdmone); \/* n = c*(r-1)*(d-1)^2 *\/\n        \/\/ fe25519_sub(n, n, v);              \/* n =  c*(r-1)*(d-1)^2-v *\/\n        $n = self::fe_sub(\n            self::fe_mul(\n                self::fe_mul(\n                    self::fe_sub($r, $one),\n                    $c\n                ),\n                $sqdmone\n            ),\n            $v\n        ); \/* n =  c*(r-1)*(d-1)^2-v *\/\n\n        $w0 = self::fe_mul(\n            self::fe_add($s, $s),\n            $v\n        ); \/* w0 = 2s*v *\/\n\n        $w1 = self::fe_mul($n, $sqrtadm1); \/* w1 = n*sqrt(ad-1) *\/\n        $ss = self::fe_sq($s); \/* ss = s^2 *\/\n        $w2 = self::fe_sub($one, $ss); \/* w2 = 1-s^2 *\/\n        $w3 = self::fe_add($one, $ss); \/* w3 = 1+s^2 *\/\n\n        return new ParagonIE_Sodium_Core_Curve25519_Ge_P3(\n            self::fe_mul($w0, $w3),\n            self::fe_mul($w2, $w1),\n            self::fe_mul($w1, $w3),\n            self::fe_mul($w0, $w2)\n        );\n    }\n\n    \/**\n     * @param string $h\n     * @return string\n     * @throws SodiumException\n     *\/\n    public static function ristretto255_from_hash($h)\n    {\n        if (self::strlen($h) !== 64) {\n            throw new SodiumException('Hash must be 64 bytes');\n        }\n        \/\/fe25519_frombytes(r0, h);\n        \/\/fe25519_frombytes(r1, h + 32);\n        $r0 = self::fe_frombytes(self::substr($h, 0, 32));\n        $r1 = self::fe_frombytes(self::substr($h, 32, 32));\n\n        \/\/ristretto255_elligator(&p0, r0);\n        \/\/ristretto255_elligator(&p1, r1);\n        $p0 = self::ristretto255_elligator($r0);\n        $p1 = self::ristretto255_elligator($r1);\n\n        \/\/ge25519_p3_to_cached(&p1_cached, &p1);\n        \/\/ge25519_add_cached(&p_p1p1, &p0, &p1_cached);\n        $p_p1p1 = self::ge_add(\n            $p0,\n            self::ge_p3_to_cached($p1)\n        );\n\n        \/\/ge25519_p1p1_to_p3(&p, &p_p1p1);\n        \/\/ristretto255_p3_tobytes(s, &p);\n        return self::ristretto255_p3_tobytes(\n            self::ge_p1p1_to_p3($p_p1p1)\n        );\n    }\n\n    \/**\n     * @param string $p\n     * @return int\n     * @throws SodiumException\n     *\/\n    public static function is_valid_point($p)\n    {\n        $result = self::ristretto255_frombytes($p);\n        if ($result['res'] !== 0) {\n            return 0;\n        }\n        return 1;\n    }\n\n    \/**\n     * @param string $p\n     * @param string $q\n     * @return string\n     * @throws SodiumException\n     *\/\n    public static function ristretto255_add($p, $q)\n    {\n        $p_res = self::ristretto255_frombytes($p);\n        $q_res = self::ristretto255_frombytes($q);\n        if ($p_res['res'] !== 0 || $q_res['res'] !== 0) {\n            throw new SodiumException('Could not add points');\n        }\n        $p_p3 = $p_res['h'];\n        $q_p3 = $q_res['h'];\n        $q_cached = self::ge_p3_to_cached($q_p3);\n        $r_p1p1 = self::ge_add($p_p3, $q_cached);\n        $r_p3 = self::ge_p1p1_to_p3($r_p1p1);\n        return self::ristretto255_p3_tobytes($r_p3);\n    }\n\n    \/**\n     * @param string $p\n     * @param string $q\n     * @return string\n     * @throws SodiumException\n     *\/\n    public static function ristretto255_sub($p, $q)\n    {\n        $p_res = self::ristretto255_frombytes($p);\n        $q_res = self::ristretto255_frombytes($q);\n        if ($p_res['res'] !== 0 || $q_res['res'] !== 0) {\n            throw new SodiumException('Could not add points');\n        }\n        $p_p3 = $p_res['h'];\n        $q_p3 = $q_res['h'];\n        $q_cached = self::ge_p3_to_cached($q_p3);\n        $r_p1p1 = self::ge_sub($p_p3, $q_cached);\n        $r_p3 = self::ge_p1p1_to_p3($r_p1p1);\n        return self::ristretto255_p3_tobytes($r_p3);\n    }\n\n\n    \/**\n     * @param int $hLen\n     * @param ?string $ctx\n     * @param string $msg\n     * @return string\n     * @throws SodiumException\n     * @psalm-suppress PossiblyInvalidArgument hash API\n     *\/\n    protected static function h2c_string_to_hash_sha256($hLen, $ctx, $msg)\n    {\n        $h = array_fill(0, $hLen, 0);\n        $ctx_len = !is_null($ctx) ? self::strlen($ctx) : 0;\n        if ($hLen > 0xff) {\n            throw new SodiumException('Hash must be less than 256 bytes');\n        }\n\n        if ($ctx_len > 0xff) {\n            $st = hash_init('sha256');\n            self::hash_update($st, \"H2C-OVERSIZE-DST-\");\n            self::hash_update($st, $ctx);\n            $ctx = hash_final($st, true);\n            $ctx_len = 32;\n        }\n        $t = array(0, $hLen, 0);\n        $ux = str_repeat(\"\\0\", 64);\n        $st = hash_init('sha256');\n        self::hash_update($st, $ux);\n        self::hash_update($st, $msg);\n        self::hash_update($st, self::intArrayToString($t));\n        self::hash_update($st, $ctx);\n        self::hash_update($st, self::intToChr($ctx_len));\n        $u0 = hash_final($st, true);\n\n        for ($i = 0; $i < $hLen; $i += 64) {\n            $ux = self::xorStrings($ux, $u0);\n            ++$t[2];\n            $st = hash_init('sha256');\n            self::hash_update($st, $ux);\n            self::hash_update($st, self::intToChr($t[2]));\n            self::hash_update($st, $ctx);\n            self::hash_update($st, self::intToChr($ctx_len));\n            $ux = hash_final($st, true);\n            $amount = min($hLen - $i, 64);\n            for ($j = 0; $j < $amount; ++$j) {\n                $h[$i + $j] = self::chrToInt($ux[$i]);\n            }\n        }\n        return self::intArrayToString(array_slice($h, 0, $hLen));\n    }\n\n    \/**\n     * @param int $hLen\n     * @param ?string $ctx\n     * @param string $msg\n     * @return string\n     * @throws SodiumException\n     * @psalm-suppress PossiblyInvalidArgument hash API\n     *\/\n    protected static function h2c_string_to_hash_sha512($hLen, $ctx, $msg)\n    {\n        $h = array_fill(0, $hLen, 0);\n        $ctx_len = !is_null($ctx) ? self::strlen($ctx) : 0;\n        if ($hLen > 0xff) {\n            throw new SodiumException('Hash must be less than 256 bytes');\n        }\n\n        if ($ctx_len > 0xff) {\n            $st = hash_init('sha256');\n            self::hash_update($st, \"H2C-OVERSIZE-DST-\");\n            self::hash_update($st, $ctx);\n            $ctx = hash_final($st, true);\n            $ctx_len = 32;\n        }\n        $t = array(0, $hLen, 0);\n        $ux = str_repeat(\"\\0\", 128);\n        $st = hash_init('sha512');\n        self::hash_update($st, $ux);\n        self::hash_update($st, $msg);\n        self::hash_update($st, self::intArrayToString($t));\n        self::hash_update($st, $ctx);\n        self::hash_update($st, self::intToChr($ctx_len));\n        $u0 = hash_final($st, true);\n\n        for ($i = 0; $i < $hLen; $i += 128) {\n            $ux = self::xorStrings($ux, $u0);\n            ++$t[2];\n            $st = hash_init('sha512');\n            self::hash_update($st, $ux);\n            self::hash_update($st, self::intToChr($t[2]));\n            self::hash_update($st, $ctx);\n            self::hash_update($st, self::intToChr($ctx_len));\n            $ux = hash_final($st, true);\n            $amount = min($hLen - $i, 128);\n            for ($j = 0; $j < $amount; ++$j) {\n                $h[$i + $j] = self::chrToInt($ux[$i]);\n            }\n        }\n        return self::intArrayToString(array_slice($h, 0, $hLen));\n    }\n\n    \/**\n     * @param int $hLen\n     * @param ?string $ctx\n     * @param string $msg\n     * @param int $hash_alg\n     * @return string\n     * @throws SodiumException\n     *\/\n    public static function h2c_string_to_hash($hLen, $ctx, $msg, $hash_alg)\n    {\n        switch ($hash_alg) {\n            case self::CORE_H2C_SHA256:\n                return self::h2c_string_to_hash_sha256($hLen, $ctx, $msg);\n            case self::CORE_H2C_SHA512:\n                return self::h2c_string_to_hash_sha512($hLen, $ctx, $msg);\n            default:\n                throw new SodiumException('Invalid H2C hash algorithm');\n        }\n    }\n\n    \/**\n     * @param ?string $ctx\n     * @param string $msg\n     * @param int $hash_alg\n     * @return string\n     * @throws SodiumException\n     *\/\n    protected static function _string_to_element($ctx, $msg, $hash_alg)\n    {\n        return self::ristretto255_from_hash(\n            self::h2c_string_to_hash(self::crypto_core_ristretto255_HASHBYTES, $ctx, $msg, $hash_alg)\n        );\n    }\n\n    \/**\n     * @return string\n     * @throws SodiumException\n     * @throws Exception\n     *\/\n    public static function ristretto255_random()\n    {\n        return self::ristretto255_from_hash(\n            ParagonIE_Sodium_Compat::randombytes_buf(self::crypto_core_ristretto255_HASHBYTES)\n        );\n    }\n\n    \/**\n     * @return string\n     * @throws SodiumException\n     *\/\n    public static function ristretto255_scalar_random()\n    {\n        return self::scalar_random();\n    }\n\n    \/**\n     * @param string $s\n     * @return string\n     * @throws SodiumException\n     *\/\n    public static function ristretto255_scalar_complement($s)\n    {\n        return self::scalar_complement($s);\n    }\n\n\n    \/**\n     * @param string $s\n     * @return string\n     *\/\n    public static function ristretto255_scalar_invert($s)\n    {\n        return self::sc25519_invert($s);\n    }\n\n    \/**\n     * @param string $s\n     * @return string\n     * @throws SodiumException\n     *\/\n    public static function ristretto255_scalar_negate($s)\n    {\n        return self::scalar_negate($s);\n    }\n\n    \/**\n     * @param string $x\n     * @param string $y\n     * @return string\n     *\/\n    public static function ristretto255_scalar_add($x, $y)\n    {\n        return self::scalar_add($x, $y);\n    }\n\n    \/**\n     * @param string $x\n     * @param string $y\n     * @return string\n     *\/\n    public static function ristretto255_scalar_sub($x, $y)\n    {\n        return self::scalar_sub($x, $y);\n    }\n\n    \/**\n     * @param string $x\n     * @param string $y\n     * @return string\n     *\/\n    public static function ristretto255_scalar_mul($x, $y)\n    {\n        return self::sc25519_mul($x, $y);\n    }\n\n    \/**\n     * @param string $ctx\n     * @param string $msg\n     * @param int $hash_alg\n     * @return string\n     * @throws SodiumException\n     *\/\n    public static function ristretto255_scalar_from_string($ctx, $msg, $hash_alg)\n    {\n        $h = array_fill(0, 64, 0);\n        $h_be = self::stringToIntArray(\n            self::h2c_string_to_hash(\n                self::HASH_SC_L, $ctx, $msg, $hash_alg\n            )\n        );\n\n        for ($i = 0; $i < self::HASH_SC_L; ++$i) {\n            $h[$i] = $h_be[self::HASH_SC_L - 1 - $i];\n        }\n        return self::ristretto255_scalar_reduce(self::intArrayToString($h));\n    }\n\n    \/**\n     * @param string $s\n     * @return string\n     *\/\n    public static function ristretto255_scalar_reduce($s)\n    {\n        return self::sc_reduce($s);\n    }\n\n    \/**\n     * @param string $n\n     * @param string $p\n     * @return string\n     * @throws SodiumException\n     *\/\n    public static function scalarmult_ristretto255($n, $p)\n    {\n        if (self::strlen($n) !== 32) {\n            throw new SodiumException('Scalar must be 32 bytes, ' . self::strlen($p) . ' given.');\n        }\n        if (self::strlen($p) !== 32) {\n            throw new SodiumException('Point must be 32 bytes, ' . self::strlen($p) . ' given.');\n        }\n        $result = self::ristretto255_frombytes($p);\n        if ($result['res'] !== 0) {\n            throw new SodiumException('Could not multiply points');\n        }\n        $P = $result['h'];\n\n        $t = self::stringToIntArray($n);\n        $t[31] &= 0x7f;\n        $Q = self::ge_scalarmult(self::intArrayToString($t), $P);\n        $q = self::ristretto255_p3_tobytes($Q);\n        if (ParagonIE_Sodium_Compat::is_zero($q)) {\n            throw new SodiumException('An unknown error has occurred');\n        }\n        return $q;\n    }\n\n    \/**\n     * @param string $n\n     * @return string\n     * @throws SodiumException\n     *\/\n    public static function scalarmult_ristretto255_base($n)\n    {\n        $t = self::stringToIntArray($n);\n        $t[31] &= 0x7f;\n        $Q = self::ge_scalarmult_base(self::intArrayToString($t));\n        $q = self::ristretto255_p3_tobytes($Q);\n        if (ParagonIE_Sodium_Compat::is_zero($q)) {\n            throw new SodiumException('An unknown error has occurred');\n        }\n        return $q;\n    }\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/src\/Core\/X25519.php","ext":"php","size":9509,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\n\nif (class_exists('ParagonIE_Sodium_Core_X25519', false)) {\n    return;\n}\n\n\/**\n * Class ParagonIE_Sodium_Core_X25519\n *\/\nabstract class ParagonIE_Sodium_Core_X25519 extends ParagonIE_Sodium_Core_Curve25519\n{\n    \/**\n     * Alters the objects passed to this method in place.\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param ParagonIE_Sodium_Core_Curve25519_Fe $f\n     * @param ParagonIE_Sodium_Core_Curve25519_Fe $g\n     * @param int $b\n     * @return void\n     * @psalm-suppress MixedAssignment\n     *\/\n    public static function fe_cswap(\n        ParagonIE_Sodium_Core_Curve25519_Fe $f,\n        ParagonIE_Sodium_Core_Curve25519_Fe $g,\n        $b = 0\n    ) {\n        $f0 = (int) $f[0];\n        $f1 = (int) $f[1];\n        $f2 = (int) $f[2];\n        $f3 = (int) $f[3];\n        $f4 = (int) $f[4];\n        $f5 = (int) $f[5];\n        $f6 = (int) $f[6];\n        $f7 = (int) $f[7];\n        $f8 = (int) $f[8];\n        $f9 = (int) $f[9];\n        $g0 = (int) $g[0];\n        $g1 = (int) $g[1];\n        $g2 = (int) $g[2];\n        $g3 = (int) $g[3];\n        $g4 = (int) $g[4];\n        $g5 = (int) $g[5];\n        $g6 = (int) $g[6];\n        $g7 = (int) $g[7];\n        $g8 = (int) $g[8];\n        $g9 = (int) $g[9];\n        $b = -$b;\n        $x0 = ($f0 ^ $g0) & $b;\n        $x1 = ($f1 ^ $g1) & $b;\n        $x2 = ($f2 ^ $g2) & $b;\n        $x3 = ($f3 ^ $g3) & $b;\n        $x4 = ($f4 ^ $g4) & $b;\n        $x5 = ($f5 ^ $g5) & $b;\n        $x6 = ($f6 ^ $g6) & $b;\n        $x7 = ($f7 ^ $g7) & $b;\n        $x8 = ($f8 ^ $g8) & $b;\n        $x9 = ($f9 ^ $g9) & $b;\n        $f[0] = $f0 ^ $x0;\n        $f[1] = $f1 ^ $x1;\n        $f[2] = $f2 ^ $x2;\n        $f[3] = $f3 ^ $x3;\n        $f[4] = $f4 ^ $x4;\n        $f[5] = $f5 ^ $x5;\n        $f[6] = $f6 ^ $x6;\n        $f[7] = $f7 ^ $x7;\n        $f[8] = $f8 ^ $x8;\n        $f[9] = $f9 ^ $x9;\n        $g[0] = $g0 ^ $x0;\n        $g[1] = $g1 ^ $x1;\n        $g[2] = $g2 ^ $x2;\n        $g[3] = $g3 ^ $x3;\n        $g[4] = $g4 ^ $x4;\n        $g[5] = $g5 ^ $x5;\n        $g[6] = $g6 ^ $x6;\n        $g[7] = $g7 ^ $x7;\n        $g[8] = $g8 ^ $x8;\n        $g[9] = $g9 ^ $x9;\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param ParagonIE_Sodium_Core_Curve25519_Fe $f\n     * @return ParagonIE_Sodium_Core_Curve25519_Fe\n     *\/\n    public static function fe_mul121666(ParagonIE_Sodium_Core_Curve25519_Fe $f)\n    {\n        $h = array(\n            self::mul((int) $f[0], 121666, 17),\n            self::mul((int) $f[1], 121666, 17),\n            self::mul((int) $f[2], 121666, 17),\n            self::mul((int) $f[3], 121666, 17),\n            self::mul((int) $f[4], 121666, 17),\n            self::mul((int) $f[5], 121666, 17),\n            self::mul((int) $f[6], 121666, 17),\n            self::mul((int) $f[7], 121666, 17),\n            self::mul((int) $f[8], 121666, 17),\n            self::mul((int) $f[9], 121666, 17)\n        );\n\n        \/** @var int $carry9 *\/\n        $carry9 = ($h[9] + (1 << 24)) >> 25;\n        $h[0] += self::mul($carry9, 19, 5);\n        $h[9] -= $carry9 << 25;\n        \/** @var int $carry1 *\/\n        $carry1 = ($h[1] + (1 << 24)) >> 25;\n        $h[2] += $carry1;\n        $h[1] -= $carry1 << 25;\n        \/** @var int $carry3 *\/\n        $carry3 = ($h[3] + (1 << 24)) >> 25;\n        $h[4] += $carry3;\n        $h[3] -= $carry3 << 25;\n        \/** @var int $carry5 *\/\n        $carry5 = ($h[5] + (1 << 24)) >> 25;\n        $h[6] += $carry5;\n        $h[5] -= $carry5 << 25;\n        \/** @var int $carry7 *\/\n        $carry7 = ($h[7] + (1 << 24)) >> 25;\n        $h[8] += $carry7;\n        $h[7] -= $carry7 << 25;\n\n        \/** @var int $carry0 *\/\n        $carry0 = ($h[0] + (1 << 25)) >> 26;\n        $h[1] += $carry0;\n        $h[0] -= $carry0 << 26;\n        \/** @var int $carry2 *\/\n        $carry2 = ($h[2] + (1 << 25)) >> 26;\n        $h[3] += $carry2;\n        $h[2] -= $carry2 << 26;\n        \/** @var int $carry4 *\/\n        $carry4 = ($h[4] + (1 << 25)) >> 26;\n        $h[5] += $carry4;\n        $h[4] -= $carry4 << 26;\n        \/** @var int $carry6 *\/\n        $carry6 = ($h[6] + (1 << 25)) >> 26;\n        $h[7] += $carry6;\n        $h[6] -= $carry6 << 26;\n        \/** @var int $carry8 *\/\n        $carry8 = ($h[8] + (1 << 25)) >> 26;\n        $h[9] += $carry8;\n        $h[8] -= $carry8 << 26;\n\n        foreach ($h as $i => $value) {\n            $h[$i] = (int) $value;\n        }\n        return ParagonIE_Sodium_Core_Curve25519_Fe::fromArray($h);\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * Inline comments preceded by # are from libsodium's ref10 code.\n     *\n     * @param string $n\n     * @param string $p\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function crypto_scalarmult_curve25519_ref10($n, $p)\n    {\n        # for (i = 0;i < 32;++i) e[i] = n[i];\n        $e = '' . $n;\n        # e[0] &= 248;\n        $e[0] = self::intToChr(\n            self::chrToInt($e[0]) & 248\n        );\n        # e[31] &= 127;\n        # e[31] |= 64;\n        $e[31] = self::intToChr(\n            (self::chrToInt($e[31]) & 127) | 64\n        );\n        # fe_frombytes(x1,p);\n        $x1 = self::fe_frombytes($p);\n        # fe_1(x2);\n        $x2 = self::fe_1();\n        # fe_0(z2);\n        $z2 = self::fe_0();\n        # fe_copy(x3,x1);\n        $x3 = self::fe_copy($x1);\n        # fe_1(z3);\n        $z3 = self::fe_1();\n\n        # swap = 0;\n        \/** @var int $swap *\/\n        $swap = 0;\n\n        # for (pos = 254;pos >= 0;--pos) {\n        for ($pos = 254; $pos >= 0; --$pos) {\n            # b = e[pos \/ 8] >> (pos & 7);\n            \/** @var int $b *\/\n            $b = self::chrToInt(\n                    $e[(int) floor($pos \/ 8)]\n                ) >> ($pos & 7);\n            # b &= 1;\n            $b &= 1;\n            # swap ^= b;\n            $swap ^= $b;\n            # fe_cswap(x2,x3,swap);\n            self::fe_cswap($x2, $x3, $swap);\n            # fe_cswap(z2,z3,swap);\n            self::fe_cswap($z2, $z3, $swap);\n            # swap = b;\n            $swap = $b;\n            # fe_sub(tmp0,x3,z3);\n            $tmp0 = self::fe_sub($x3, $z3);\n            # fe_sub(tmp1,x2,z2);\n            $tmp1 = self::fe_sub($x2, $z2);\n\n            # fe_add(x2,x2,z2);\n            $x2 = self::fe_add($x2, $z2);\n\n            # fe_add(z2,x3,z3);\n            $z2 = self::fe_add($x3, $z3);\n\n            # fe_mul(z3,tmp0,x2);\n            $z3 = self::fe_mul($tmp0, $x2);\n\n            # fe_mul(z2,z2,tmp1);\n            $z2 = self::fe_mul($z2, $tmp1);\n\n            # fe_sq(tmp0,tmp1);\n            $tmp0 = self::fe_sq($tmp1);\n\n            # fe_sq(tmp1,x2);\n            $tmp1 = self::fe_sq($x2);\n\n            # fe_add(x3,z3,z2);\n            $x3 = self::fe_add($z3, $z2);\n\n            # fe_sub(z2,z3,z2);\n            $z2 = self::fe_sub($z3, $z2);\n\n            # fe_mul(x2,tmp1,tmp0);\n            $x2 = self::fe_mul($tmp1, $tmp0);\n\n            # fe_sub(tmp1,tmp1,tmp0);\n            $tmp1 = self::fe_sub($tmp1, $tmp0);\n\n            # fe_sq(z2,z2);\n            $z2 = self::fe_sq($z2);\n\n            # fe_mul121666(z3,tmp1);\n            $z3 = self::fe_mul121666($tmp1);\n\n            # fe_sq(x3,x3);\n            $x3 = self::fe_sq($x3);\n\n            # fe_add(tmp0,tmp0,z3);\n            $tmp0 = self::fe_add($tmp0, $z3);\n\n            # fe_mul(z3,x1,z2);\n            $z3 = self::fe_mul($x1, $z2);\n\n            # fe_mul(z2,tmp1,tmp0);\n            $z2 = self::fe_mul($tmp1, $tmp0);\n        }\n\n        # fe_cswap(x2,x3,swap);\n        self::fe_cswap($x2, $x3, $swap);\n\n        # fe_cswap(z2,z3,swap);\n        self::fe_cswap($z2, $z3, $swap);\n\n        # fe_invert(z2,z2);\n        $z2 = self::fe_invert($z2);\n\n        # fe_mul(x2,x2,z2);\n        $x2 = self::fe_mul($x2, $z2);\n        # fe_tobytes(q,x2);\n        return self::fe_tobytes($x2);\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param ParagonIE_Sodium_Core_Curve25519_Fe $edwardsY\n     * @param ParagonIE_Sodium_Core_Curve25519_Fe $edwardsZ\n     * @return ParagonIE_Sodium_Core_Curve25519_Fe\n     *\/\n    public static function edwards_to_montgomery(\n        ParagonIE_Sodium_Core_Curve25519_Fe $edwardsY,\n        ParagonIE_Sodium_Core_Curve25519_Fe $edwardsZ\n    ) {\n        $tempX = self::fe_add($edwardsZ, $edwardsY);\n        $tempZ = self::fe_sub($edwardsZ, $edwardsY);\n        $tempZ = self::fe_invert($tempZ);\n        return self::fe_mul($tempX, $tempZ);\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param string $n\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function crypto_scalarmult_curve25519_ref10_base($n)\n    {\n        # for (i = 0;i < 32;++i) e[i] = n[i];\n        $e = '' . $n;\n\n        # e[0] &= 248;\n        $e[0] = self::intToChr(\n            self::chrToInt($e[0]) & 248\n        );\n\n        # e[31] &= 127;\n        # e[31] |= 64;\n        $e[31] = self::intToChr(\n            (self::chrToInt($e[31]) & 127) | 64\n        );\n\n        $A = self::ge_scalarmult_base($e);\n        if (\n            !($A->Y instanceof ParagonIE_Sodium_Core_Curve25519_Fe)\n                ||\n            !($A->Z instanceof ParagonIE_Sodium_Core_Curve25519_Fe)\n        ) {\n            throw new TypeError('Null points encountered');\n        }\n        $pk = self::edwards_to_montgomery($A->Y, $A->Z);\n        return self::fe_tobytes($pk);\n    }\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/src\/Core\/XChaCha20.php","ext":"php","size":3429,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\n\nif (class_exists('ParagonIE_Sodium_Core_XChaCha20', false)) {\n    return;\n}\n\n\/**\n * Class ParagonIE_Sodium_Core_XChaCha20\n *\/\nclass ParagonIE_Sodium_Core_XChaCha20 extends ParagonIE_Sodium_Core_HChaCha20\n{\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param int $len\n     * @param string $nonce\n     * @param string $key\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function stream($len = 64, $nonce = '', $key = '')\n    {\n        if (self::strlen($nonce) !== 24) {\n            throw new SodiumException('Nonce must be 24 bytes long');\n        }\n        return self::encryptBytes(\n            new ParagonIE_Sodium_Core_ChaCha20_Ctx(\n                self::hChaCha20(\n                    self::substr($nonce, 0, 16),\n                    $key\n                ),\n                self::substr($nonce, 16, 8)\n            ),\n            str_repeat(\"\\x00\", $len)\n        );\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param int $len\n     * @param string $nonce\n     * @param string $key\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function ietfStream($len = 64, $nonce = '', $key = '')\n    {\n        if (self::strlen($nonce) !== 24) {\n            throw new SodiumException('Nonce must be 24 bytes long');\n        }\n        return self::encryptBytes(\n            new ParagonIE_Sodium_Core_ChaCha20_IetfCtx(\n                self::hChaCha20(\n                    self::substr($nonce, 0, 16),\n                    $key\n                ),\n                \"\\x00\\x00\\x00\\x00\" . self::substr($nonce, 16, 8)\n            ),\n            str_repeat(\"\\x00\", $len)\n        );\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param string $message\n     * @param string $nonce\n     * @param string $key\n     * @param string $ic\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function streamXorIc($message, $nonce = '', $key = '', $ic = '')\n    {\n        if (self::strlen($nonce) !== 24) {\n            throw new SodiumException('Nonce must be 24 bytes long');\n        }\n        return self::encryptBytes(\n            new ParagonIE_Sodium_Core_ChaCha20_Ctx(\n                self::hChaCha20(self::substr($nonce, 0, 16), $key),\n                self::substr($nonce, 16, 8),\n                $ic\n            ),\n            $message\n        );\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param string $message\n     * @param string $nonce\n     * @param string $key\n     * @param string $ic\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function ietfStreamXorIc($message, $nonce = '', $key = '', $ic = '')\n    {\n        if (self::strlen($nonce) !== 24) {\n            throw new SodiumException('Nonce must be 24 bytes long');\n        }\n        return self::encryptBytes(\n            new ParagonIE_Sodium_Core_ChaCha20_IetfCtx(\n                self::hChaCha20(self::substr($nonce, 0, 16), $key),\n                \"\\x00\\x00\\x00\\x00\" . self::substr($nonce, 16, 8),\n                $ic\n            ),\n            $message\n        );\n    }\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/src\/Core\/XSalsa20.php","ext":"php","size":1430,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\n\nif (class_exists('ParagonIE_Sodium_Core_XSalsa20', false)) {\n    return;\n}\n\n\/**\n * Class ParagonIE_Sodium_Core_XSalsa20\n *\/\nabstract class ParagonIE_Sodium_Core_XSalsa20 extends ParagonIE_Sodium_Core_HSalsa20\n{\n    \/**\n     * Expand a key and nonce into an xsalsa20 keystream.\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param int $len\n     * @param string $nonce\n     * @param string $key\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function xsalsa20($len, $nonce, $key)\n    {\n        $ret = self::salsa20(\n            $len,\n            self::substr($nonce, 16, 8),\n            self::hsalsa20($nonce, $key)\n        );\n        return $ret;\n    }\n\n    \/**\n     * Encrypt a string with XSalsa20. Doesn't provide integrity.\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param string $message\n     * @param string $nonce\n     * @param string $key\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function xsalsa20_xor($message, $nonce, $key)\n    {\n        return self::xorStrings(\n            $message,\n            self::xsalsa20(\n                self::strlen($message),\n                $nonce,\n                $key\n            )\n        );\n    }\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/src\/Core\/Salsa20.php","ext":"php","size":8292,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\n\nif (class_exists('ParagonIE_Sodium_Core_Salsa20', false)) {\n    return;\n}\n\n\/**\n * Class ParagonIE_Sodium_Core_Salsa20\n *\/\nabstract class ParagonIE_Sodium_Core_Salsa20 extends ParagonIE_Sodium_Core_Util\n{\n    const ROUNDS = 20;\n\n    \/**\n     * Calculate an salsa20 hash of a single block\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param string $in\n     * @param string $k\n     * @param string|null $c\n     * @return string\n     * @throws TypeError\n     *\/\n    public static function core_salsa20($in, $k, $c = null)\n    {\n        if (self::strlen($k) < 32) {\n            throw new RangeException('Key must be 32 bytes long');\n        }\n        if ($c === null) {\n            $j0  = $x0  = 0x61707865;\n            $j5  = $x5  = 0x3320646e;\n            $j10 = $x10 = 0x79622d32;\n            $j15 = $x15 = 0x6b206574;\n        } else {\n            $j0  = $x0  = self::load_4(self::substr($c, 0, 4));\n            $j5  = $x5  = self::load_4(self::substr($c, 4, 4));\n            $j10 = $x10 = self::load_4(self::substr($c, 8, 4));\n            $j15 = $x15 = self::load_4(self::substr($c, 12, 4));\n        }\n        $j1  = $x1  = self::load_4(self::substr($k, 0, 4));\n        $j2  = $x2  = self::load_4(self::substr($k, 4, 4));\n        $j3  = $x3  = self::load_4(self::substr($k, 8, 4));\n        $j4  = $x4  = self::load_4(self::substr($k, 12, 4));\n        $j6  = $x6  = self::load_4(self::substr($in, 0, 4));\n        $j7  = $x7  = self::load_4(self::substr($in, 4, 4));\n        $j8  = $x8  = self::load_4(self::substr($in, 8, 4));\n        $j9  = $x9  = self::load_4(self::substr($in, 12, 4));\n        $j11 = $x11 = self::load_4(self::substr($k, 16, 4));\n        $j12 = $x12 = self::load_4(self::substr($k, 20, 4));\n        $j13 = $x13 = self::load_4(self::substr($k, 24, 4));\n        $j14 = $x14 = self::load_4(self::substr($k, 28, 4));\n\n        for ($i = self::ROUNDS; $i > 0; $i -= 2) {\n            $x4 ^= self::rotate($x0 + $x12, 7);\n            $x8 ^= self::rotate($x4 + $x0, 9);\n            $x12 ^= self::rotate($x8 + $x4, 13);\n            $x0 ^= self::rotate($x12 + $x8, 18);\n\n            $x9 ^= self::rotate($x5 + $x1, 7);\n            $x13 ^= self::rotate($x9 + $x5, 9);\n            $x1 ^= self::rotate($x13 + $x9, 13);\n            $x5 ^= self::rotate($x1 + $x13, 18);\n\n            $x14 ^= self::rotate($x10 + $x6, 7);\n            $x2 ^= self::rotate($x14 + $x10, 9);\n            $x6 ^= self::rotate($x2 + $x14, 13);\n            $x10 ^= self::rotate($x6 + $x2, 18);\n\n            $x3 ^= self::rotate($x15 + $x11, 7);\n            $x7 ^= self::rotate($x3 + $x15, 9);\n            $x11 ^= self::rotate($x7 + $x3, 13);\n            $x15 ^= self::rotate($x11 + $x7, 18);\n\n            $x1 ^= self::rotate($x0 + $x3, 7);\n            $x2 ^= self::rotate($x1 + $x0, 9);\n            $x3 ^= self::rotate($x2 + $x1, 13);\n            $x0 ^= self::rotate($x3 + $x2, 18);\n\n            $x6 ^= self::rotate($x5 + $x4, 7);\n            $x7 ^= self::rotate($x6 + $x5, 9);\n            $x4 ^= self::rotate($x7 + $x6, 13);\n            $x5 ^= self::rotate($x4 + $x7, 18);\n\n            $x11 ^= self::rotate($x10 + $x9, 7);\n            $x8 ^= self::rotate($x11 + $x10, 9);\n            $x9 ^= self::rotate($x8 + $x11, 13);\n            $x10 ^= self::rotate($x9 + $x8, 18);\n\n            $x12 ^= self::rotate($x15 + $x14, 7);\n            $x13 ^= self::rotate($x12 + $x15, 9);\n            $x14 ^= self::rotate($x13 + $x12, 13);\n            $x15 ^= self::rotate($x14 + $x13, 18);\n        }\n\n        $x0  += $j0;\n        $x1  += $j1;\n        $x2  += $j2;\n        $x3  += $j3;\n        $x4  += $j4;\n        $x5  += $j5;\n        $x6  += $j6;\n        $x7  += $j7;\n        $x8  += $j8;\n        $x9  += $j9;\n        $x10 += $j10;\n        $x11 += $j11;\n        $x12 += $j12;\n        $x13 += $j13;\n        $x14 += $j14;\n        $x15 += $j15;\n\n        return self::store32_le($x0) .\n            self::store32_le($x1) .\n            self::store32_le($x2) .\n            self::store32_le($x3) .\n            self::store32_le($x4) .\n            self::store32_le($x5) .\n            self::store32_le($x6) .\n            self::store32_le($x7) .\n            self::store32_le($x8) .\n            self::store32_le($x9) .\n            self::store32_le($x10) .\n            self::store32_le($x11) .\n            self::store32_le($x12) .\n            self::store32_le($x13) .\n            self::store32_le($x14) .\n            self::store32_le($x15);\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param int $len\n     * @param string $nonce\n     * @param string $key\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function salsa20($len, $nonce, $key)\n    {\n        if (self::strlen($key) !== 32) {\n            throw new RangeException('Key must be 32 bytes long');\n        }\n        $kcopy = '' . $key;\n        $in = self::substr($nonce, 0, 8) . str_repeat(\"\\0\", 8);\n        $c = '';\n        while ($len >= 64) {\n            $c .= self::core_salsa20($in, $kcopy, null);\n            $u = 1;\n            \/\/ Internal counter.\n            for ($i = 8; $i < 16; ++$i) {\n                $u += self::chrToInt($in[$i]);\n                $in[$i] = self::intToChr($u & 0xff);\n                $u >>= 8;\n            }\n            $len -= 64;\n        }\n        if ($len > 0) {\n            $c .= self::substr(\n                self::core_salsa20($in, $kcopy, null),\n                0,\n                $len\n            );\n        }\n        try {\n            ParagonIE_Sodium_Compat::memzero($kcopy);\n        } catch (SodiumException $ex) {\n            $kcopy = null;\n        }\n        return $c;\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param string $m\n     * @param string $n\n     * @param int $ic\n     * @param string $k\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function salsa20_xor_ic($m, $n, $ic, $k)\n    {\n        $mlen = self::strlen($m);\n        if ($mlen < 1) {\n            return '';\n        }\n        $kcopy = self::substr($k, 0, 32);\n        $in = self::substr($n, 0, 8);\n        \/\/ Initialize the counter\n        $in .= ParagonIE_Sodium_Core_Util::store64_le($ic);\n\n        $c = '';\n        while ($mlen >= 64) {\n            $block = self::core_salsa20($in, $kcopy, null);\n            $c .= self::xorStrings(\n                self::substr($m, 0, 64),\n                self::substr($block, 0, 64)\n            );\n            $u = 1;\n            for ($i = 8; $i < 16; ++$i) {\n                $u += self::chrToInt($in[$i]);\n                $in[$i] = self::intToChr($u & 0xff);\n                $u >>= 8;\n            }\n\n            $mlen -= 64;\n            $m = self::substr($m, 64);\n        }\n\n        if ($mlen) {\n            $block = self::core_salsa20($in, $kcopy, null);\n            $c .= self::xorStrings(\n                self::substr($m, 0, $mlen),\n                self::substr($block, 0, $mlen)\n            );\n        }\n        try {\n            ParagonIE_Sodium_Compat::memzero($block);\n            ParagonIE_Sodium_Compat::memzero($kcopy);\n        } catch (SodiumException $ex) {\n            $block = null;\n            $kcopy = null;\n        }\n\n        return $c;\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param string $message\n     * @param string $nonce\n     * @param string $key\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function salsa20_xor($message, $nonce, $key)\n    {\n        return self::xorStrings(\n            $message,\n            self::salsa20(\n                self::strlen($message),\n                $nonce,\n                $key\n            )\n        );\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param int $u\n     * @param int $c\n     * @return int\n     *\/\n    public static function rotate($u, $c)\n    {\n        $u &= 0xffffffff;\n        $c %= 32;\n        return (int) (0xffffffff & (\n                ($u << $c)\n                    |\n                ($u >> (32 - $c))\n            )\n        );\n    }\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/src\/Core\/Util.php","ext":"php","size":28323,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\n\nif (class_exists('ParagonIE_Sodium_Core_Util', false)) {\n    return;\n}\n\n\/**\n * Class ParagonIE_Sodium_Core_Util\n *\/\nabstract class ParagonIE_Sodium_Core_Util\n{\n    \/**\n     * @param int $integer\n     * @param int $size (16, 32, 64)\n     * @return int\n     *\/\n    public static function abs($integer, $size = 0)\n    {\n        \/** @var int $realSize *\/\n        $realSize = (PHP_INT_SIZE << 3) - 1;\n        if ($size) {\n            --$size;\n        } else {\n            \/** @var int $size *\/\n            $size = $realSize;\n        }\n\n        $negative = -(($integer >> $size) & 1);\n        return (int) (\n            ($integer ^ $negative)\n                +\n            (($negative >> $realSize) & 1)\n        );\n    }\n\n    \/**\n     * Convert a binary string into a hexadecimal string without cache-timing\n     * leaks\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param string $binaryString (raw binary)\n     * @return string\n     * @throws TypeError\n     *\/\n    public static function bin2hex($binaryString)\n    {\n        \/* Type checks: *\/\n        if (!is_string($binaryString)) {\n            throw new TypeError('Argument 1 must be a string, ' . gettype($binaryString) . ' given.');\n        }\n\n        $hex = '';\n        $len = self::strlen($binaryString);\n        for ($i = 0; $i < $len; ++$i) {\n            \/** @var array<int, int> $chunk *\/\n            $chunk = unpack('C', $binaryString[$i]);\n            \/** @var int $c *\/\n            $c = $chunk[1] & 0xf;\n            \/** @var int $b *\/\n            $b = $chunk[1] >> 4;\n            $hex .= pack(\n                'CC',\n                (87 + $b + ((($b - 10) >> 8) & ~38)),\n                (87 + $c + ((($c - 10) >> 8) & ~38))\n            );\n        }\n        return $hex;\n    }\n\n    \/**\n     * Convert a binary string into a hexadecimal string without cache-timing\n     * leaks, returning uppercase letters (as per RFC 4648)\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param string $bin_string (raw binary)\n     * @return string\n     * @throws TypeError\n     *\/\n    public static function bin2hexUpper($bin_string)\n    {\n        $hex = '';\n        $len = self::strlen($bin_string);\n        for ($i = 0; $i < $len; ++$i) {\n            \/** @var array<int, int> $chunk *\/\n            $chunk = unpack('C', $bin_string[$i]);\n            \/**\n             * Lower 16 bits\n             *\n             * @var int $c\n             *\/\n            $c = $chunk[1] & 0xf;\n\n            \/**\n             * Upper 16 bits\n             * @var int $b\n             *\/\n            $b = $chunk[1] >> 4;\n\n            \/**\n             * Use pack() and binary operators to turn the two integers\n             * into hexadecimal characters. We don't use chr() here, because\n             * it uses a lookup table internally and we want to avoid\n             * cache-timing side-channels.\n             *\/\n            $hex .= pack(\n                'CC',\n                (55 + $b + ((($b - 10) >> 8) & ~6)),\n                (55 + $c + ((($c - 10) >> 8) & ~6))\n            );\n        }\n        return $hex;\n    }\n\n    \/**\n     * Cache-timing-safe variant of ord()\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param string $chr\n     * @return int\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function chrToInt($chr)\n    {\n        \/* Type checks: *\/\n        if (!is_string($chr)) {\n            throw new TypeError('Argument 1 must be a string, ' . gettype($chr) . ' given.');\n        }\n        if (self::strlen($chr) !== 1) {\n            throw new SodiumException('chrToInt() expects a string that is exactly 1 character long');\n        }\n        \/** @var array<int, int> $chunk *\/\n        $chunk = unpack('C', $chr);\n        return (int) ($chunk[1]);\n    }\n\n    \/**\n     * Compares two strings.\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param string $left\n     * @param string $right\n     * @param int $len\n     * @return int\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function compare($left, $right, $len = null)\n    {\n        $leftLen = self::strlen($left);\n        $rightLen = self::strlen($right);\n        if ($len === null) {\n            $len = max($leftLen, $rightLen);\n            $left = str_pad($left, $len, \"\\x00\", STR_PAD_RIGHT);\n            $right = str_pad($right, $len, \"\\x00\", STR_PAD_RIGHT);\n        }\n\n        $gt = 0;\n        $eq = 1;\n        $i = $len;\n        while ($i !== 0) {\n            --$i;\n            $gt |= ((self::chrToInt($right[$i]) - self::chrToInt($left[$i])) >> 8) & $eq;\n            $eq &= ((self::chrToInt($right[$i]) ^ self::chrToInt($left[$i])) - 1) >> 8;\n        }\n        return ($gt + $gt + $eq) - 1;\n    }\n\n    \/**\n     * If a variable does not match a given type, throw a TypeError.\n     *\n     * @param mixed $mixedVar\n     * @param string $type\n     * @param int $argumentIndex\n     * @throws TypeError\n     * @throws SodiumException\n     * @return void\n     *\/\n    public static function declareScalarType(&$mixedVar = null, $type = 'void', $argumentIndex = 0)\n    {\n        if (func_num_args() === 0) {\n            \/* Tautology, by default *\/\n            return;\n        }\n        if (func_num_args() === 1) {\n            throw new TypeError('Declared void, but passed a variable');\n        }\n        $realType = strtolower(gettype($mixedVar));\n        $type = strtolower($type);\n        switch ($type) {\n            case 'null':\n                if ($mixedVar !== null) {\n                    throw new TypeError('Argument ' . $argumentIndex . ' must be null, ' . $realType . ' given.');\n                }\n                break;\n            case 'integer':\n            case 'int':\n                $allow = array('int', 'integer');\n                if (!in_array($type, $allow)) {\n                    throw new TypeError('Argument ' . $argumentIndex . ' must be an integer, ' . $realType . ' given.');\n                }\n                $mixedVar = (int) $mixedVar;\n                break;\n            case 'boolean':\n            case 'bool':\n                $allow = array('bool', 'boolean');\n                if (!in_array($type, $allow)) {\n                    throw new TypeError('Argument ' . $argumentIndex . ' must be a boolean, ' . $realType . ' given.');\n                }\n                $mixedVar = (bool) $mixedVar;\n                break;\n            case 'string':\n                if (!is_string($mixedVar)) {\n                    throw new TypeError('Argument ' . $argumentIndex . ' must be a string, ' . $realType . ' given.');\n                }\n                $mixedVar = (string) $mixedVar;\n                break;\n            case 'decimal':\n            case 'double':\n            case 'float':\n                $allow = array('decimal', 'double', 'float');\n                if (!in_array($type, $allow)) {\n                    throw new TypeError('Argument ' . $argumentIndex . ' must be a float, ' . $realType . ' given.');\n                }\n                $mixedVar = (float) $mixedVar;\n                break;\n            case 'object':\n                if (!is_object($mixedVar)) {\n                    throw new TypeError('Argument ' . $argumentIndex . ' must be an object, ' . $realType . ' given.');\n                }\n                break;\n            case 'array':\n                if (!is_array($mixedVar)) {\n                    if (is_object($mixedVar)) {\n                        if ($mixedVar instanceof ArrayAccess) {\n                            return;\n                        }\n                    }\n                    throw new TypeError('Argument ' . $argumentIndex . ' must be an array, ' . $realType . ' given.');\n                }\n                break;\n            default:\n                throw new SodiumException('Unknown type (' . $realType .') does not match expect type (' . $type . ')');\n        }\n    }\n\n    \/**\n     * Evaluate whether or not two strings are equal (in constant-time)\n     *\n     * @param string $left\n     * @param string $right\n     * @return bool\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function hashEquals($left, $right)\n    {\n        \/* Type checks: *\/\n        if (!is_string($left)) {\n            throw new TypeError('Argument 1 must be a string, ' . gettype($left) . ' given.');\n        }\n        if (!is_string($right)) {\n            throw new TypeError('Argument 2 must be a string, ' . gettype($right) . ' given.');\n        }\n\n        if (is_callable('hash_equals')) {\n            return hash_equals($left, $right);\n        }\n        $d = 0;\n        \/** @var int $len *\/\n        $len = self::strlen($left);\n        if ($len !== self::strlen($right)) {\n            return false;\n        }\n        for ($i = 0; $i < $len; ++$i) {\n            $d |= self::chrToInt($left[$i]) ^ self::chrToInt($right[$i]);\n        }\n\n        if ($d !== 0) {\n            return false;\n        }\n        return $left === $right;\n    }\n\n    \/**\n     * Catch hash_update() failures and throw instead of silently proceeding\n     *\n     * @param HashContext|resource &$hs\n     * @param string $data\n     * @return void\n     * @throws SodiumException\n     * @psalm-suppress PossiblyInvalidArgument\n     *\/\n    protected static function hash_update(&$hs, $data)\n    {\n        if (!hash_update($hs, $data)) {\n            throw new SodiumException('hash_update() failed');\n        }\n    }\n\n    \/**\n     * Convert a hexadecimal string into a binary string without cache-timing\n     * leaks\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param string $hexString\n     * @param string $ignore\n     * @param bool $strictPadding\n     * @return string (raw binary)\n     * @throws RangeException\n     * @throws TypeError\n     *\/\n    public static function hex2bin($hexString, $ignore = '', $strictPadding = false)\n    {\n        \/* Type checks: *\/\n        if (!is_string($hexString)) {\n            throw new TypeError('Argument 1 must be a string, ' . gettype($hexString) . ' given.');\n        }\n        if (!is_string($ignore)) {\n            throw new TypeError('Argument 2 must be a string, ' . gettype($hexString) . ' given.');\n        }\n\n        $hex_pos = 0;\n        $bin = '';\n        $c_acc = 0;\n        $hex_len = self::strlen($hexString);\n        $state = 0;\n        if (($hex_len & 1) !== 0) {\n            if ($strictPadding) {\n                throw new RangeException(\n                    'Expected an even number of hexadecimal characters'\n                );\n            } else {\n                $hexString = '0' . $hexString;\n                ++$hex_len;\n            }\n        }\n\n        $chunk = unpack('C*', $hexString);\n        while ($hex_pos < $hex_len) {\n            ++$hex_pos;\n            \/** @var int $c *\/\n            $c = $chunk[$hex_pos];\n            $c_num = $c ^ 48;\n            $c_num0 = ($c_num - 10) >> 8;\n            $c_alpha = ($c & ~32) - 55;\n            $c_alpha0 = (($c_alpha - 10) ^ ($c_alpha - 16)) >> 8;\n            if (($c_num0 | $c_alpha0) === 0) {\n                if ($ignore && $state === 0 && strpos($ignore, self::intToChr($c)) !== false) {\n                    continue;\n                }\n                throw new RangeException(\n                    'hex2bin() only expects hexadecimal characters'\n                );\n            }\n            $c_val = ($c_num0 & $c_num) | ($c_alpha & $c_alpha0);\n            if ($state === 0) {\n                $c_acc = $c_val * 16;\n            } else {\n                $bin .= pack('C', $c_acc | $c_val);\n            }\n            $state ^= 1;\n        }\n        return $bin;\n    }\n\n    \/**\n     * Turn an array of integers into a string\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param array<int, int> $ints\n     * @return string\n     *\/\n    public static function intArrayToString(array $ints)\n    {\n        $args = $ints;\n        foreach ($args as $i => $v) {\n            $args[$i] = (int) ($v & 0xff);\n        }\n        array_unshift($args, str_repeat('C', count($ints)));\n        return (string) (call_user_func_array('pack', $args));\n    }\n\n    \/**\n     * Cache-timing-safe variant of ord()\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param int $int\n     * @return string\n     * @throws TypeError\n     *\/\n    public static function intToChr($int)\n    {\n        return pack('C', $int);\n    }\n\n    \/**\n     * Load a 3 character substring into an integer\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param string $string\n     * @return int\n     * @throws RangeException\n     * @throws TypeError\n     *\/\n    public static function load_3($string)\n    {\n        \/* Type checks: *\/\n        if (!is_string($string)) {\n            throw new TypeError('Argument 1 must be a string, ' . gettype($string) . ' given.');\n        }\n\n        \/* Input validation: *\/\n        if (self::strlen($string) < 3) {\n            throw new RangeException(\n                'String must be 3 bytes or more; ' . self::strlen($string) . ' given.'\n            );\n        }\n        \/** @var array<int, int> $unpacked *\/\n        $unpacked = unpack('V', $string . \"\\0\");\n        return (int) ($unpacked[1] & 0xffffff);\n    }\n\n    \/**\n     * Load a 4 character substring into an integer\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param string $string\n     * @return int\n     * @throws RangeException\n     * @throws TypeError\n     *\/\n    public static function load_4($string)\n    {\n        \/* Type checks: *\/\n        if (!is_string($string)) {\n            throw new TypeError('Argument 1 must be a string, ' . gettype($string) . ' given.');\n        }\n\n        \/* Input validation: *\/\n        if (self::strlen($string) < 4) {\n            throw new RangeException(\n                'String must be 4 bytes or more; ' . self::strlen($string) . ' given.'\n            );\n        }\n        \/** @var array<int, int> $unpacked *\/\n        $unpacked = unpack('V', $string);\n        return (int) $unpacked[1];\n    }\n\n    \/**\n     * Load a 8 character substring into an integer\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param string $string\n     * @return int\n     * @throws RangeException\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function load64_le($string)\n    {\n        \/* Type checks: *\/\n        if (!is_string($string)) {\n            throw new TypeError('Argument 1 must be a string, ' . gettype($string) . ' given.');\n        }\n\n        \/* Input validation: *\/\n        if (self::strlen($string) < 4) {\n            throw new RangeException(\n                'String must be 4 bytes or more; ' . self::strlen($string) . ' given.'\n            );\n        }\n        if (PHP_VERSION_ID >= 50603 && PHP_INT_SIZE === 8) {\n            \/** @var array<int, int> $unpacked *\/\n            $unpacked = unpack('P', $string);\n            return (int) $unpacked[1];\n        }\n\n        \/** @var int $result *\/\n        $result  = (self::chrToInt($string[0]) & 0xff);\n        $result |= (self::chrToInt($string[1]) & 0xff) <<  8;\n        $result |= (self::chrToInt($string[2]) & 0xff) << 16;\n        $result |= (self::chrToInt($string[3]) & 0xff) << 24;\n        $result |= (self::chrToInt($string[4]) & 0xff) << 32;\n        $result |= (self::chrToInt($string[5]) & 0xff) << 40;\n        $result |= (self::chrToInt($string[6]) & 0xff) << 48;\n        $result |= (self::chrToInt($string[7]) & 0xff) << 56;\n        return (int) $result;\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param string $left\n     * @param string $right\n     * @return int\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function memcmp($left, $right)\n    {\n        if (self::hashEquals($left, $right)) {\n            return 0;\n        }\n        return -1;\n    }\n\n    \/**\n     * Multiply two integers in constant-time\n     *\n     * Micro-architecture timing side-channels caused by how your CPU\n     * implements multiplication are best prevented by never using the\n     * multiplication operators and ensuring that our code always takes\n     * the same number of operations to complete, regardless of the values\n     * of $a and $b.\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param int $a\n     * @param int $b\n     * @param int $size Limits the number of operations (useful for small,\n     *                  constant operands)\n     * @return int\n     *\/\n    public static function mul($a, $b, $size = 0)\n    {\n        if (ParagonIE_Sodium_Compat::$fastMult) {\n            return (int) ($a * $b);\n        }\n\n        static $defaultSize = null;\n        \/** @var int $defaultSize *\/\n        if (!$defaultSize) {\n            \/** @var int $defaultSize *\/\n            $defaultSize = (PHP_INT_SIZE << 3) - 1;\n        }\n        if ($size < 1) {\n            \/** @var int $size *\/\n            $size = $defaultSize;\n        }\n        \/** @var int $size *\/\n\n        $c = 0;\n\n        \/**\n         * Mask is either -1 or 0.\n         *\n         * -1 in binary looks like 0x1111 ... 1111\n         *  0 in binary looks like 0x0000 ... 0000\n         *\n         * @var int\n         *\/\n        $mask = -(($b >> ((int) $defaultSize)) & 1);\n\n        \/**\n         * Ensure $b is a positive integer, without creating\n         * a branching side-channel\n         *\n         * @var int $b\n         *\/\n        $b = ($b & ~$mask) | ($mask & -$b);\n\n        \/**\n         * Unless $size is provided:\n         *\n         * This loop always runs 32 times when PHP_INT_SIZE is 4.\n         * This loop always runs 64 times when PHP_INT_SIZE is 8.\n         *\/\n        for ($i = $size; $i >= 0; --$i) {\n            $c += (int) ($a & -($b & 1));\n            $a <<= 1;\n            $b >>= 1;\n        }\n        $c = (int) @($c & -1);\n\n        \/**\n         * If $b was negative, we then apply the same value to $c here.\n         * It doesn't matter much if $a was negative; the $c += above would\n         * have produced a negative integer to begin with. But a negative $b\n         * makes $b >>= 1 never return 0, so we would end up with incorrect\n         * results.\n         *\n         * The end result is what we'd expect from integer multiplication.\n         *\/\n        return (int) (($c & ~$mask) | ($mask & -$c));\n    }\n\n    \/**\n     * Convert any arbitrary numbers into two 32-bit integers that represent\n     * a 64-bit integer.\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param int|float $num\n     * @return array<int, int>\n     *\/\n    public static function numericTo64BitInteger($num)\n    {\n        $high = 0;\n        \/** @var int $low *\/\n        if (PHP_INT_SIZE === 4) {\n            $low = (int) $num;\n        } else {\n            $low = $num & 0xffffffff;\n        }\n\n        if ((+(abs($num))) >= 1) {\n            if ($num > 0) {\n                \/** @var int $high *\/\n                $high = min((+(floor($num\/4294967296))), 4294967295);\n            } else {\n                \/** @var int $high *\/\n                $high = ~~((+(ceil(($num - (+((~~($num)))))\/4294967296))));\n            }\n        }\n        return array((int) $high, (int) $low);\n    }\n\n    \/**\n     * Store a 24-bit integer into a string, treating it as big-endian.\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param int $int\n     * @return string\n     * @throws TypeError\n     *\/\n    public static function store_3($int)\n    {\n        \/* Type checks: *\/\n        if (!is_int($int)) {\n            if (is_numeric($int)) {\n                $int = (int) $int;\n            } else {\n                throw new TypeError('Argument 1 must be an integer, ' . gettype($int) . ' given.');\n            }\n        }\n        \/** @var string $packed *\/\n        $packed = pack('N', $int);\n        return self::substr($packed, 1, 3);\n    }\n\n    \/**\n     * Store a 32-bit integer into a string, treating it as little-endian.\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param int $int\n     * @return string\n     * @throws TypeError\n     *\/\n    public static function store32_le($int)\n    {\n        \/* Type checks: *\/\n        if (!is_int($int)) {\n            if (is_numeric($int)) {\n                $int = (int) $int;\n            } else {\n                throw new TypeError('Argument 1 must be an integer, ' . gettype($int) . ' given.');\n            }\n        }\n\n        \/** @var string $packed *\/\n        $packed = pack('V', $int);\n        return $packed;\n    }\n\n    \/**\n     * Store a 32-bit integer into a string, treating it as big-endian.\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param int $int\n     * @return string\n     * @throws TypeError\n     *\/\n    public static function store_4($int)\n    {\n        \/* Type checks: *\/\n        if (!is_int($int)) {\n            if (is_numeric($int)) {\n                $int = (int) $int;\n            } else {\n                throw new TypeError('Argument 1 must be an integer, ' . gettype($int) . ' given.');\n            }\n        }\n\n        \/** @var string $packed *\/\n        $packed = pack('N', $int);\n        return $packed;\n    }\n\n    \/**\n     * Stores a 64-bit integer as an string, treating it as little-endian.\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param int $int\n     * @return string\n     * @throws TypeError\n     *\/\n    public static function store64_le($int)\n    {\n        \/* Type checks: *\/\n        if (!is_int($int)) {\n            if (is_numeric($int)) {\n                $int = (int) $int;\n            } else {\n                throw new TypeError('Argument 1 must be an integer, ' . gettype($int) . ' given.');\n            }\n        }\n\n        if (PHP_INT_SIZE === 8) {\n            if (PHP_VERSION_ID >= 50603) {\n                \/** @var string $packed *\/\n                $packed = pack('P', $int);\n                return $packed;\n            }\n            return self::intToChr($int & 0xff) .\n                self::intToChr(($int >>  8) & 0xff) .\n                self::intToChr(($int >> 16) & 0xff) .\n                self::intToChr(($int >> 24) & 0xff) .\n                self::intToChr(($int >> 32) & 0xff) .\n                self::intToChr(($int >> 40) & 0xff) .\n                self::intToChr(($int >> 48) & 0xff) .\n                self::intToChr(($int >> 56) & 0xff);\n        }\n        if ($int > PHP_INT_MAX) {\n            list($hiB, $int) = self::numericTo64BitInteger($int);\n        } else {\n            $hiB = 0;\n        }\n        return\n            self::intToChr(($int      ) & 0xff) .\n            self::intToChr(($int >>  8) & 0xff) .\n            self::intToChr(($int >> 16) & 0xff) .\n            self::intToChr(($int >> 24) & 0xff) .\n            self::intToChr($hiB & 0xff) .\n            self::intToChr(($hiB >>  8) & 0xff) .\n            self::intToChr(($hiB >> 16) & 0xff) .\n            self::intToChr(($hiB >> 24) & 0xff);\n    }\n\n    \/**\n     * Safe string length\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @ref mbstring.func_overload\n     *\n     * @param string $str\n     * @return int\n     * @throws TypeError\n     *\/\n    public static function strlen($str)\n    {\n        \/* Type checks: *\/\n        if (!is_string($str)) {\n            throw new TypeError('String expected');\n        }\n\n        return (int) (\n        self::isMbStringOverride()\n            ? mb_strlen($str, '8bit')\n            : strlen($str)\n        );\n    }\n\n    \/**\n     * Turn a string into an array of integers\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param string $string\n     * @return array<int, int>\n     * @throws TypeError\n     *\/\n    public static function stringToIntArray($string)\n    {\n        if (!is_string($string)) {\n            throw new TypeError('String expected');\n        }\n        \/**\n         * @var array<int, int>\n         *\/\n        $values = array_values(\n            unpack('C*', $string)\n        );\n        return $values;\n    }\n\n    \/**\n     * Safe substring\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @ref mbstring.func_overload\n     *\n     * @param string $str\n     * @param int $start\n     * @param int $length\n     * @return string\n     * @throws TypeError\n     *\/\n    public static function substr($str, $start = 0, $length = null)\n    {\n        \/* Type checks: *\/\n        if (!is_string($str)) {\n            throw new TypeError('String expected');\n        }\n\n        if ($length === 0) {\n            return '';\n        }\n\n        if (self::isMbStringOverride()) {\n            if (PHP_VERSION_ID < 50400 && $length === null) {\n                $length = self::strlen($str);\n            }\n            $sub = (string) mb_substr($str, $start, $length, '8bit');\n        } elseif ($length === null) {\n            $sub = (string) substr($str, $start);\n        } else {\n            $sub = (string) substr($str, $start, $length);\n        }\n        if ($sub !== '') {\n            return $sub;\n        }\n        return '';\n    }\n\n    \/**\n     * Compare a 16-character byte string in constant time.\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param string $a\n     * @param string $b\n     * @return bool\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function verify_16($a, $b)\n    {\n        \/* Type checks: *\/\n        if (!is_string($a)) {\n            throw new TypeError('String expected');\n        }\n        if (!is_string($b)) {\n            throw new TypeError('String expected');\n        }\n        return self::hashEquals(\n            self::substr($a, 0, 16),\n            self::substr($b, 0, 16)\n        );\n    }\n\n    \/**\n     * Compare a 32-character byte string in constant time.\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param string $a\n     * @param string $b\n     * @return bool\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function verify_32($a, $b)\n    {\n        \/* Type checks: *\/\n        if (!is_string($a)) {\n            throw new TypeError('String expected');\n        }\n        if (!is_string($b)) {\n            throw new TypeError('String expected');\n        }\n        return self::hashEquals(\n            self::substr($a, 0, 32),\n            self::substr($b, 0, 32)\n        );\n    }\n\n    \/**\n     * Calculate $a ^ $b for two strings.\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param string $a\n     * @param string $b\n     * @return string\n     * @throws TypeError\n     *\/\n    public static function xorStrings($a, $b)\n    {\n        \/* Type checks: *\/\n        if (!is_string($a)) {\n            throw new TypeError('Argument 1 must be a string');\n        }\n        if (!is_string($b)) {\n            throw new TypeError('Argument 2 must be a string');\n        }\n\n        return (string) ($a ^ $b);\n    }\n\n    \/**\n     * Returns whether or not mbstring.func_overload is in effect.\n     *\n     * @internal You should not use this directly from another application\n     *\n     * Note: MB_OVERLOAD_STRING === 2, but we don't reference the constant\n     * (for nuisance-free PHP 8 support)\n     *\n     * @return bool\n     *\/\n    protected static function isMbStringOverride()\n    {\n        static $mbstring = null;\n\n        if ($mbstring === null) {\n            if (!defined('MB_OVERLOAD_STRING')) {\n                $mbstring = false;\n                return $mbstring;\n            }\n            $mbstring = extension_loaded('mbstring')\n                && defined('MB_OVERLOAD_STRING')\n                &&\n            ((int) (ini_get('mbstring.func_overload')) & 2);\n            \/\/ MB_OVERLOAD_STRING === 2\n        }\n        \/** @var bool $mbstring *\/\n\n        return $mbstring;\n    }\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/src\/Core\/Curve25519.php","ext":"php","size":142689,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\n\nif (class_exists('ParagonIE_Sodium_Core_Curve25519', false)) {\n    return;\n}\n\n\/**\n * Class ParagonIE_Sodium_Core_Curve25519\n *\n * Implements Curve25519 core functions\n *\n * Based on the ref10 curve25519 code provided by libsodium\n *\n * @ref https:\/\/github.com\/jedisct1\/libsodium\/blob\/master\/src\/libsodium\/crypto_core\/curve25519\/ref10\/curve25519_ref10.c\n *\/\nabstract class ParagonIE_Sodium_Core_Curve25519 extends ParagonIE_Sodium_Core_Curve25519_H\n{\n    \/**\n     * Get a field element of size 10 with a value of 0\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @return ParagonIE_Sodium_Core_Curve25519_Fe\n     *\/\n    public static function fe_0()\n    {\n        return ParagonIE_Sodium_Core_Curve25519_Fe::fromArray(\n            array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n        );\n    }\n\n    \/**\n     * Get a field element of size 10 with a value of 1\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @return ParagonIE_Sodium_Core_Curve25519_Fe\n     *\/\n    public static function fe_1()\n    {\n        return ParagonIE_Sodium_Core_Curve25519_Fe::fromArray(\n            array(1, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n        );\n    }\n\n    \/**\n     * Add two field elements.\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param ParagonIE_Sodium_Core_Curve25519_Fe $f\n     * @param ParagonIE_Sodium_Core_Curve25519_Fe $g\n     * @return ParagonIE_Sodium_Core_Curve25519_Fe\n     * @psalm-suppress MixedAssignment\n     * @psalm-suppress MixedOperand\n     *\/\n    public static function fe_add(\n        ParagonIE_Sodium_Core_Curve25519_Fe $f,\n        ParagonIE_Sodium_Core_Curve25519_Fe $g\n    ) {\n        \/** @var array<int, int> $arr *\/\n        $arr = array();\n        for ($i = 0; $i < 10; ++$i) {\n            $arr[$i] = (int) ($f[$i] + $g[$i]);\n        }\n        return ParagonIE_Sodium_Core_Curve25519_Fe::fromArray($arr);\n    }\n\n    \/**\n     * Constant-time conditional move.\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param ParagonIE_Sodium_Core_Curve25519_Fe $f\n     * @param ParagonIE_Sodium_Core_Curve25519_Fe $g\n     * @param int $b\n     * @return ParagonIE_Sodium_Core_Curve25519_Fe\n     * @psalm-suppress MixedAssignment\n     *\/\n    public static function fe_cmov(\n        ParagonIE_Sodium_Core_Curve25519_Fe $f,\n        ParagonIE_Sodium_Core_Curve25519_Fe $g,\n        $b = 0\n    ) {\n        \/** @var array<int, int> $h *\/\n        $h = array();\n        $b *= -1;\n        for ($i = 0; $i < 10; ++$i) {\n            $x = (($f[$i] ^ $g[$i]) & $b);\n            $h[$i] = ($f[$i]) ^ $x;\n        }\n        return ParagonIE_Sodium_Core_Curve25519_Fe::fromArray($h);\n    }\n\n    \/**\n     * Create a copy of a field element.\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param ParagonIE_Sodium_Core_Curve25519_Fe $f\n     * @return ParagonIE_Sodium_Core_Curve25519_Fe\n     *\/\n    public static function fe_copy(ParagonIE_Sodium_Core_Curve25519_Fe $f)\n    {\n        $h = clone $f;\n        return $h;\n    }\n\n    \/**\n     * Give: 32-byte string.\n     * Receive: A field element object to use for internal calculations.\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param string $s\n     * @return ParagonIE_Sodium_Core_Curve25519_Fe\n     * @throws RangeException\n     * @throws TypeError\n     *\/\n    public static function fe_frombytes($s)\n    {\n        if (self::strlen($s) !== 32) {\n            throw new RangeException('Expected a 32-byte string.');\n        }\n        $h0 = self::load_4($s);\n        $h1 = self::load_3(self::substr($s, 4, 3)) << 6;\n        $h2 = self::load_3(self::substr($s, 7, 3)) << 5;\n        $h3 = self::load_3(self::substr($s, 10, 3)) << 3;\n        $h4 = self::load_3(self::substr($s, 13, 3)) << 2;\n        $h5 = self::load_4(self::substr($s, 16, 4));\n        $h6 = self::load_3(self::substr($s, 20, 3)) << 7;\n        $h7 = self::load_3(self::substr($s, 23, 3)) << 5;\n        $h8 = self::load_3(self::substr($s, 26, 3)) << 4;\n        $h9 = (self::load_3(self::substr($s, 29, 3)) & 8388607) << 2;\n\n        $carry9 = ($h9 + (1 << 24)) >> 25;\n        $h0 += self::mul($carry9, 19, 5);\n        $h9 -= $carry9 << 25;\n        $carry1 = ($h1 + (1 << 24)) >> 25;\n        $h2 += $carry1;\n        $h1 -= $carry1 << 25;\n        $carry3 = ($h3 + (1 << 24)) >> 25;\n        $h4 += $carry3;\n        $h3 -= $carry3 << 25;\n        $carry5 = ($h5 + (1 << 24)) >> 25;\n        $h6 += $carry5;\n        $h5 -= $carry5 << 25;\n        $carry7 = ($h7 + (1 << 24)) >> 25;\n        $h8 += $carry7;\n        $h7 -= $carry7 << 25;\n\n        $carry0 = ($h0 + (1 << 25)) >> 26;\n        $h1 += $carry0;\n        $h0 -= $carry0 << 26;\n        $carry2 = ($h2 + (1 << 25)) >> 26;\n        $h3 += $carry2;\n        $h2 -= $carry2 << 26;\n        $carry4 = ($h4 + (1 << 25)) >> 26;\n        $h5 += $carry4;\n        $h4 -= $carry4 << 26;\n        $carry6 = ($h6 + (1 << 25)) >> 26;\n        $h7 += $carry6;\n        $h6 -= $carry6 << 26;\n        $carry8 = ($h8 + (1 << 25)) >> 26;\n        $h9 += $carry8;\n        $h8 -= $carry8 << 26;\n\n        return ParagonIE_Sodium_Core_Curve25519_Fe::fromArray(\n            array(\n                (int) $h0,\n                (int) $h1,\n                (int) $h2,\n                (int) $h3,\n                (int) $h4,\n                (int) $h5,\n                (int) $h6,\n                (int) $h7,\n                (int) $h8,\n                (int) $h9\n            )\n        );\n    }\n\n    \/**\n     * Convert a field element to a byte string.\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param ParagonIE_Sodium_Core_Curve25519_Fe $h\n     * @return string\n     *\/\n    public static function fe_tobytes(ParagonIE_Sodium_Core_Curve25519_Fe $h)\n    {\n        $h0 = (int) $h[0];\n        $h1 = (int) $h[1];\n        $h2 = (int) $h[2];\n        $h3 = (int) $h[3];\n        $h4 = (int) $h[4];\n        $h5 = (int) $h[5];\n        $h6 = (int) $h[6];\n        $h7 = (int) $h[7];\n        $h8 = (int) $h[8];\n        $h9 = (int) $h[9];\n\n        $q = (self::mul($h9, 19, 5) + (1 << 24)) >> 25;\n        $q = ($h0 + $q) >> 26;\n        $q = ($h1 + $q) >> 25;\n        $q = ($h2 + $q) >> 26;\n        $q = ($h3 + $q) >> 25;\n        $q = ($h4 + $q) >> 26;\n        $q = ($h5 + $q) >> 25;\n        $q = ($h6 + $q) >> 26;\n        $q = ($h7 + $q) >> 25;\n        $q = ($h8 + $q) >> 26;\n        $q = ($h9 + $q) >> 25;\n\n        $h0 += self::mul($q, 19, 5);\n\n        $carry0 = $h0 >> 26;\n        $h1 += $carry0;\n        $h0 -= $carry0 << 26;\n        $carry1 = $h1 >> 25;\n        $h2 += $carry1;\n        $h1 -= $carry1 << 25;\n        $carry2 = $h2 >> 26;\n        $h3 += $carry2;\n        $h2 -= $carry2 << 26;\n        $carry3 = $h3 >> 25;\n        $h4 += $carry3;\n        $h3 -= $carry3 << 25;\n        $carry4 = $h4 >> 26;\n        $h5 += $carry4;\n        $h4 -= $carry4 << 26;\n        $carry5 = $h5 >> 25;\n        $h6 += $carry5;\n        $h5 -= $carry5 << 25;\n        $carry6 = $h6 >> 26;\n        $h7 += $carry6;\n        $h6 -= $carry6 << 26;\n        $carry7 = $h7 >> 25;\n        $h8 += $carry7;\n        $h7 -= $carry7 << 25;\n        $carry8 = $h8 >> 26;\n        $h9 += $carry8;\n        $h8 -= $carry8 << 26;\n        $carry9 = $h9 >> 25;\n        $h9 -= $carry9 << 25;\n\n        \/**\n         * @var array<int, int>\n         *\/\n        $s = array(\n            (int) (($h0 >> 0) & 0xff),\n            (int) (($h0 >> 8) & 0xff),\n            (int) (($h0 >> 16) & 0xff),\n            (int) ((($h0 >> 24) | ($h1 << 2)) & 0xff),\n            (int) (($h1 >> 6) & 0xff),\n            (int) (($h1 >> 14) & 0xff),\n            (int) ((($h1 >> 22) | ($h2 << 3)) & 0xff),\n            (int) (($h2 >> 5) & 0xff),\n            (int) (($h2 >> 13) & 0xff),\n            (int) ((($h2 >> 21) | ($h3 << 5)) & 0xff),\n            (int) (($h3 >> 3) & 0xff),\n            (int) (($h3 >> 11) & 0xff),\n            (int) ((($h3 >> 19) | ($h4 << 6)) & 0xff),\n            (int) (($h4 >> 2) & 0xff),\n            (int) (($h4 >> 10) & 0xff),\n            (int) (($h4 >> 18) & 0xff),\n            (int) (($h5 >> 0) & 0xff),\n            (int) (($h5 >> 8) & 0xff),\n            (int) (($h5 >> 16) & 0xff),\n            (int) ((($h5 >> 24) | ($h6 << 1)) & 0xff),\n            (int) (($h6 >> 7) & 0xff),\n            (int) (($h6 >> 15) & 0xff),\n            (int) ((($h6 >> 23) | ($h7 << 3)) & 0xff),\n            (int) (($h7 >> 5) & 0xff),\n            (int) (($h7 >> 13) & 0xff),\n            (int) ((($h7 >> 21) | ($h8 << 4)) & 0xff),\n            (int) (($h8 >> 4) & 0xff),\n            (int) (($h8 >> 12) & 0xff),\n            (int) ((($h8 >> 20) | ($h9 << 6)) & 0xff),\n            (int) (($h9 >> 2) & 0xff),\n            (int) (($h9 >> 10) & 0xff),\n            (int) (($h9 >> 18) & 0xff)\n        );\n        return self::intArrayToString($s);\n    }\n\n    \/**\n     * Is a field element negative? (1 = yes, 0 = no. Used in calculations.)\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param ParagonIE_Sodium_Core_Curve25519_Fe $f\n     * @return int\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function fe_isnegative(ParagonIE_Sodium_Core_Curve25519_Fe $f)\n    {\n        $str = self::fe_tobytes($f);\n        return (int) (self::chrToInt($str[0]) & 1);\n    }\n\n    \/**\n     * Returns 0 if this field element results in all NUL bytes.\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param ParagonIE_Sodium_Core_Curve25519_Fe $f\n     * @return bool\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function fe_isnonzero(ParagonIE_Sodium_Core_Curve25519_Fe $f)\n    {\n        static $zero;\n        if ($zero === null) {\n            $zero = str_repeat(\"\\x00\", 32);\n        }\n        \/** @var string $zero *\/\n        \/** @var string $str *\/\n        $str = self::fe_tobytes($f);\n        return !self::verify_32($str, (string) $zero);\n    }\n\n    \/**\n     * Multiply two field elements\n     *\n     * h = f * g\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @security Is multiplication a source of timing leaks? If so, can we do\n     *           anything to prevent that from happening?\n     *\n     * @param ParagonIE_Sodium_Core_Curve25519_Fe $f\n     * @param ParagonIE_Sodium_Core_Curve25519_Fe $g\n     * @return ParagonIE_Sodium_Core_Curve25519_Fe\n     *\/\n    public static function fe_mul(\n        ParagonIE_Sodium_Core_Curve25519_Fe $f,\n        ParagonIE_Sodium_Core_Curve25519_Fe $g\n    ) {\n        \/\/ Ensure limbs aren't oversized.\n        $f = self::fe_normalize($f);\n        $g = self::fe_normalize($g);\n        $f0 = $f[0];\n        $f1 = $f[1];\n        $f2 = $f[2];\n        $f3 = $f[3];\n        $f4 = $f[4];\n        $f5 = $f[5];\n        $f6 = $f[6];\n        $f7 = $f[7];\n        $f8 = $f[8];\n        $f9 = $f[9];\n        $g0 = $g[0];\n        $g1 = $g[1];\n        $g2 = $g[2];\n        $g3 = $g[3];\n        $g4 = $g[4];\n        $g5 = $g[5];\n        $g6 = $g[6];\n        $g7 = $g[7];\n        $g8 = $g[8];\n        $g9 = $g[9];\n        $g1_19 = self::mul($g1, 19, 5);\n        $g2_19 = self::mul($g2, 19, 5);\n        $g3_19 = self::mul($g3, 19, 5);\n        $g4_19 = self::mul($g4, 19, 5);\n        $g5_19 = self::mul($g5, 19, 5);\n        $g6_19 = self::mul($g6, 19, 5);\n        $g7_19 = self::mul($g7, 19, 5);\n        $g8_19 = self::mul($g8, 19, 5);\n        $g9_19 = self::mul($g9, 19, 5);\n        $f1_2 = $f1 << 1;\n        $f3_2 = $f3 << 1;\n        $f5_2 = $f5 << 1;\n        $f7_2 = $f7 << 1;\n        $f9_2 = $f9 << 1;\n        $f0g0    = self::mul($f0,    $g0, 26);\n        $f0g1    = self::mul($f0,    $g1, 25);\n        $f0g2    = self::mul($f0,    $g2, 26);\n        $f0g3    = self::mul($f0,    $g3, 25);\n        $f0g4    = self::mul($f0,    $g4, 26);\n        $f0g5    = self::mul($f0,    $g5, 25);\n        $f0g6    = self::mul($f0,    $g6, 26);\n        $f0g7    = self::mul($f0,    $g7, 25);\n        $f0g8    = self::mul($f0,    $g8, 26);\n        $f0g9    = self::mul($f0,    $g9, 26);\n        $f1g0    = self::mul($f1,    $g0, 26);\n        $f1g1_2  = self::mul($f1_2,  $g1, 25);\n        $f1g2    = self::mul($f1,    $g2, 26);\n        $f1g3_2  = self::mul($f1_2,  $g3, 25);\n        $f1g4    = self::mul($f1,    $g4, 26);\n        $f1g5_2  = self::mul($f1_2,  $g5, 25);\n        $f1g6    = self::mul($f1,    $g6, 26);\n        $f1g7_2  = self::mul($f1_2,  $g7, 25);\n        $f1g8    = self::mul($f1,    $g8, 26);\n        $f1g9_38 = self::mul($g9_19, $f1_2, 26);\n        $f2g0    = self::mul($f2,    $g0, 26);\n        $f2g1    = self::mul($f2,    $g1, 25);\n        $f2g2    = self::mul($f2,    $g2, 26);\n        $f2g3    = self::mul($f2,    $g3, 25);\n        $f2g4    = self::mul($f2,    $g4, 26);\n        $f2g5    = self::mul($f2,    $g5, 25);\n        $f2g6    = self::mul($f2,    $g6, 26);\n        $f2g7    = self::mul($f2,    $g7, 25);\n        $f2g8_19 = self::mul($g8_19, $f2, 26);\n        $f2g9_19 = self::mul($g9_19, $f2, 26);\n        $f3g0    = self::mul($f3,    $g0, 26);\n        $f3g1_2  = self::mul($f3_2,  $g1, 25);\n        $f3g2    = self::mul($f3,    $g2, 26);\n        $f3g3_2  = self::mul($f3_2,  $g3, 25);\n        $f3g4    = self::mul($f3,    $g4, 26);\n        $f3g5_2  = self::mul($f3_2,  $g5, 25);\n        $f3g6    = self::mul($f3,    $g6, 26);\n        $f3g7_38 = self::mul($g7_19, $f3_2, 26);\n        $f3g8_19 = self::mul($g8_19, $f3, 25);\n        $f3g9_38 = self::mul($g9_19, $f3_2, 26);\n        $f4g0    = self::mul($f4,    $g0, 26);\n        $f4g1    = self::mul($f4,    $g1, 25);\n        $f4g2    = self::mul($f4,    $g2, 26);\n        $f4g3    = self::mul($f4,    $g3, 25);\n        $f4g4    = self::mul($f4,    $g4, 26);\n        $f4g5    = self::mul($f4,    $g5, 25);\n        $f4g6_19 = self::mul($g6_19, $f4, 26);\n        $f4g7_19 = self::mul($g7_19, $f4, 26);\n        $f4g8_19 = self::mul($g8_19, $f4, 26);\n        $f4g9_19 = self::mul($g9_19, $f4, 26);\n        $f5g0    = self::mul($f5,    $g0, 26);\n        $f5g1_2  = self::mul($f5_2,  $g1, 25);\n        $f5g2    = self::mul($f5,    $g2, 26);\n        $f5g3_2  = self::mul($f5_2,  $g3, 25);\n        $f5g4    = self::mul($f5,    $g4, 26);\n        $f5g5_38 = self::mul($g5_19, $f5_2, 26);\n        $f5g6_19 = self::mul($g6_19, $f5, 25);\n        $f5g7_38 = self::mul($g7_19, $f5_2, 26);\n        $f5g8_19 = self::mul($g8_19, $f5, 25);\n        $f5g9_38 = self::mul($g9_19, $f5_2, 26);\n        $f6g0    = self::mul($f6,    $g0, 26);\n        $f6g1    = self::mul($f6,    $g1, 25);\n        $f6g2    = self::mul($f6,    $g2, 26);\n        $f6g3    = self::mul($f6,    $g3, 25);\n        $f6g4_19 = self::mul($g4_19, $f6, 26);\n        $f6g5_19 = self::mul($g5_19, $f6, 26);\n        $f6g6_19 = self::mul($g6_19, $f6, 26);\n        $f6g7_19 = self::mul($g7_19, $f6, 26);\n        $f6g8_19 = self::mul($g8_19, $f6, 26);\n        $f6g9_19 = self::mul($g9_19, $f6, 26);\n        $f7g0    = self::mul($f7,    $g0, 26);\n        $f7g1_2  = self::mul($f7_2,  $g1, 25);\n        $f7g2    = self::mul($f7,    $g2, 26);\n        $f7g3_38 = self::mul($g3_19, $f7_2, 26);\n        $f7g4_19 = self::mul($g4_19, $f7, 26);\n        $f7g5_38 = self::mul($g5_19, $f7_2, 26);\n        $f7g6_19 = self::mul($g6_19, $f7, 25);\n        $f7g7_38 = self::mul($g7_19, $f7_2, 26);\n        $f7g8_19 = self::mul($g8_19, $f7, 25);\n        $f7g9_38 = self::mul($g9_19,$f7_2, 26);\n        $f8g0    = self::mul($f8,    $g0, 26);\n        $f8g1    = self::mul($f8,    $g1, 25);\n        $f8g2_19 = self::mul($g2_19, $f8, 26);\n        $f8g3_19 = self::mul($g3_19, $f8, 26);\n        $f8g4_19 = self::mul($g4_19, $f8, 26);\n        $f8g5_19 = self::mul($g5_19, $f8, 26);\n        $f8g6_19 = self::mul($g6_19, $f8, 26);\n        $f8g7_19 = self::mul($g7_19, $f8, 26);\n        $f8g8_19 = self::mul($g8_19, $f8, 26);\n        $f8g9_19 = self::mul($g9_19, $f8, 26);\n        $f9g0    = self::mul($f9,    $g0, 26);\n        $f9g1_38 = self::mul($g1_19, $f9_2, 26);\n        $f9g2_19 = self::mul($g2_19, $f9, 25);\n        $f9g3_38 = self::mul($g3_19, $f9_2, 26);\n        $f9g4_19 = self::mul($g4_19, $f9, 25);\n        $f9g5_38 = self::mul($g5_19, $f9_2, 26);\n        $f9g6_19 = self::mul($g6_19, $f9, 25);\n        $f9g7_38 = self::mul($g7_19, $f9_2, 26);\n        $f9g8_19 = self::mul($g8_19, $f9, 25);\n        $f9g9_38 = self::mul($g9_19, $f9_2, 26);\n\n        $h0 = $f0g0 + $f1g9_38 + $f2g8_19 + $f3g7_38 + $f4g6_19 + $f5g5_38 + $f6g4_19 + $f7g3_38 + $f8g2_19 + $f9g1_38;\n        $h1 = $f0g1 + $f1g0    + $f2g9_19 + $f3g8_19 + $f4g7_19 + $f5g6_19 + $f6g5_19 + $f7g4_19 + $f8g3_19 + $f9g2_19;\n        $h2 = $f0g2 + $f1g1_2  + $f2g0    + $f3g9_38 + $f4g8_19 + $f5g7_38 + $f6g6_19 + $f7g5_38 + $f8g4_19 + $f9g3_38;\n        $h3 = $f0g3 + $f1g2    + $f2g1    + $f3g0    + $f4g9_19 + $f5g8_19 + $f6g7_19 + $f7g6_19 + $f8g5_19 + $f9g4_19;\n        $h4 = $f0g4 + $f1g3_2  + $f2g2    + $f3g1_2  + $f4g0    + $f5g9_38 + $f6g8_19 + $f7g7_38 + $f8g6_19 + $f9g5_38;\n        $h5 = $f0g5 + $f1g4    + $f2g3    + $f3g2    + $f4g1    + $f5g0    + $f6g9_19 + $f7g8_19 + $f8g7_19 + $f9g6_19;\n        $h6 = $f0g6 + $f1g5_2  + $f2g4    + $f3g3_2  + $f4g2    + $f5g1_2  + $f6g0    + $f7g9_38 + $f8g8_19 + $f9g7_38;\n        $h7 = $f0g7 + $f1g6    + $f2g5    + $f3g4    + $f4g3    + $f5g2    + $f6g1    + $f7g0    + $f8g9_19 + $f9g8_19;\n        $h8 = $f0g8 + $f1g7_2  + $f2g6    + $f3g5_2  + $f4g4    + $f5g3_2  + $f6g2    + $f7g1_2  + $f8g0    + $f9g9_38;\n        $h9 = $f0g9 + $f1g8    + $f2g7    + $f3g6    + $f4g5    + $f5g4    + $f6g3    + $f7g2    + $f8g1    + $f9g0   ;\n\n        $carry0 = ($h0 + (1 << 25)) >> 26;\n        $h1 += $carry0;\n        $h0 -= $carry0 << 26;\n        $carry4 = ($h4 + (1 << 25)) >> 26;\n        $h5 += $carry4;\n        $h4 -= $carry4 << 26;\n\n        $carry1 = ($h1 + (1 << 24)) >> 25;\n        $h2 += $carry1;\n        $h1 -= $carry1 << 25;\n        $carry5 = ($h5 + (1 << 24)) >> 25;\n        $h6 += $carry5;\n        $h5 -= $carry5 << 25;\n\n        $carry2 = ($h2 + (1 << 25)) >> 26;\n        $h3 += $carry2;\n        $h2 -= $carry2 << 26;\n        $carry6 = ($h6 + (1 << 25)) >> 26;\n        $h7 += $carry6;\n        $h6 -= $carry6 << 26;\n\n        $carry3 = ($h3 + (1 << 24)) >> 25;\n        $h4 += $carry3;\n        $h3 -= $carry3 << 25;\n        $carry7 = ($h7 + (1 << 24)) >> 25;\n        $h8 += $carry7;\n        $h7 -= $carry7 << 25;\n\n        $carry4 = ($h4 + (1 << 25)) >> 26;\n        $h5 += $carry4;\n        $h4 -= $carry4 << 26;\n        $carry8 = ($h8 + (1 << 25)) >> 26;\n        $h9 += $carry8;\n        $h8 -= $carry8 << 26;\n\n        $carry9 = ($h9 + (1 << 24)) >> 25;\n        $h0 += self::mul($carry9, 19, 5);\n        $h9 -= $carry9 << 25;\n\n        $carry0 = ($h0 + (1 << 25)) >> 26;\n        $h1 += $carry0;\n        $h0 -= $carry0 << 26;\n\n        return self::fe_normalize(\n            ParagonIE_Sodium_Core_Curve25519_Fe::fromArray(\n                array(\n                    (int) $h0,\n                    (int) $h1,\n                    (int) $h2,\n                    (int) $h3,\n                    (int) $h4,\n                    (int) $h5,\n                    (int) $h6,\n                    (int) $h7,\n                    (int) $h8,\n                    (int) $h9\n                )\n            )\n        );\n    }\n\n    \/**\n     * Get the negative values for each piece of the field element.\n     *\n     * h = -f\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param ParagonIE_Sodium_Core_Curve25519_Fe $f\n     * @return ParagonIE_Sodium_Core_Curve25519_Fe\n     * @psalm-suppress MixedAssignment\n     *\/\n    public static function fe_neg(ParagonIE_Sodium_Core_Curve25519_Fe $f)\n    {\n        $h = new ParagonIE_Sodium_Core_Curve25519_Fe();\n        for ($i = 0; $i < 10; ++$i) {\n            $h[$i] = -$f[$i];\n        }\n        return self::fe_normalize($h);\n    }\n\n    \/**\n     * Square a field element\n     *\n     * h = f * f\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param ParagonIE_Sodium_Core_Curve25519_Fe $f\n     * @return ParagonIE_Sodium_Core_Curve25519_Fe\n     *\/\n    public static function fe_sq(ParagonIE_Sodium_Core_Curve25519_Fe $f)\n    {\n        $f = self::fe_normalize($f);\n        $f0 = (int) $f[0];\n        $f1 = (int) $f[1];\n        $f2 = (int) $f[2];\n        $f3 = (int) $f[3];\n        $f4 = (int) $f[4];\n        $f5 = (int) $f[5];\n        $f6 = (int) $f[6];\n        $f7 = (int) $f[7];\n        $f8 = (int) $f[8];\n        $f9 = (int) $f[9];\n\n        $f0_2 = $f0 << 1;\n        $f1_2 = $f1 << 1;\n        $f2_2 = $f2 << 1;\n        $f3_2 = $f3 << 1;\n        $f4_2 = $f4 << 1;\n        $f5_2 = $f5 << 1;\n        $f6_2 = $f6 << 1;\n        $f7_2 = $f7 << 1;\n        $f5_38 = self::mul($f5, 38, 6);\n        $f6_19 = self::mul($f6, 19, 5);\n        $f7_38 = self::mul($f7, 38, 6);\n        $f8_19 = self::mul($f8, 19, 5);\n        $f9_38 = self::mul($f9, 38, 6);\n        $f0f0    = self::mul($f0,    $f0,    26);\n        $f0f1_2  = self::mul($f0_2,  $f1,    26);\n        $f0f2_2  = self::mul($f0_2,  $f2,    26);\n        $f0f3_2  = self::mul($f0_2,  $f3,    26);\n        $f0f4_2  = self::mul($f0_2,  $f4,    26);\n        $f0f5_2  = self::mul($f0_2,  $f5,    26);\n        $f0f6_2  = self::mul($f0_2,  $f6,    26);\n        $f0f7_2  = self::mul($f0_2,  $f7,    26);\n        $f0f8_2  = self::mul($f0_2,  $f8,    26);\n        $f0f9_2  = self::mul($f0_2,  $f9,    26);\n        $f1f1_2  = self::mul($f1_2,  $f1,    26);\n        $f1f2_2  = self::mul($f1_2,  $f2,    26);\n        $f1f3_4  = self::mul($f1_2,  $f3_2,  26);\n        $f1f4_2  = self::mul($f1_2,  $f4,    26);\n        $f1f5_4  = self::mul($f1_2,  $f5_2,  26);\n        $f1f6_2  = self::mul($f1_2,  $f6,    26);\n        $f1f7_4  = self::mul($f1_2,  $f7_2,  26);\n        $f1f8_2  = self::mul($f1_2,  $f8,    26);\n        $f1f9_76 = self::mul($f9_38, $f1_2,  27);\n        $f2f2    = self::mul($f2,    $f2,    27);\n        $f2f3_2  = self::mul($f2_2,  $f3,    27);\n        $f2f4_2  = self::mul($f2_2,  $f4,    27);\n        $f2f5_2  = self::mul($f2_2,  $f5,    27);\n        $f2f6_2  = self::mul($f2_2,  $f6,    27);\n        $f2f7_2  = self::mul($f2_2,  $f7,    27);\n        $f2f8_38 = self::mul($f8_19, $f2_2,  27);\n        $f2f9_38 = self::mul($f9_38, $f2,    26);\n        $f3f3_2  = self::mul($f3_2,  $f3,    26);\n        $f3f4_2  = self::mul($f3_2,  $f4,    26);\n        $f3f5_4  = self::mul($f3_2,  $f5_2,  26);\n        $f3f6_2  = self::mul($f3_2,  $f6,    26);\n        $f3f7_76 = self::mul($f7_38, $f3_2,  26);\n        $f3f8_38 = self::mul($f8_19, $f3_2,  26);\n        $f3f9_76 = self::mul($f9_38, $f3_2,  26);\n        $f4f4    = self::mul($f4,    $f4,    26);\n        $f4f5_2  = self::mul($f4_2,  $f5,    26);\n        $f4f6_38 = self::mul($f6_19, $f4_2,  27);\n        $f4f7_38 = self::mul($f7_38, $f4,    26);\n        $f4f8_38 = self::mul($f8_19, $f4_2,  27);\n        $f4f9_38 = self::mul($f9_38, $f4,    26);\n        $f5f5_38 = self::mul($f5_38, $f5,    26);\n        $f5f6_38 = self::mul($f6_19, $f5_2,  26);\n        $f5f7_76 = self::mul($f7_38, $f5_2,  26);\n        $f5f8_38 = self::mul($f8_19, $f5_2,  26);\n        $f5f9_76 = self::mul($f9_38, $f5_2,  26);\n        $f6f6_19 = self::mul($f6_19, $f6,    26);\n        $f6f7_38 = self::mul($f7_38, $f6,    26);\n        $f6f8_38 = self::mul($f8_19, $f6_2,  27);\n        $f6f9_38 = self::mul($f9_38, $f6,    26);\n        $f7f7_38 = self::mul($f7_38, $f7,    26);\n        $f7f8_38 = self::mul($f8_19, $f7_2,  26);\n        $f7f9_76 = self::mul($f9_38, $f7_2,  26);\n        $f8f8_19 = self::mul($f8_19, $f8,    26);\n        $f8f9_38 = self::mul($f9_38, $f8,    26);\n        $f9f9_38 = self::mul($f9_38, $f9,    26);\n        $h0 = $f0f0   + $f1f9_76 + $f2f8_38 + $f3f7_76 + $f4f6_38 + $f5f5_38;\n        $h1 = $f0f1_2 + $f2f9_38 + $f3f8_38 + $f4f7_38 + $f5f6_38;\n        $h2 = $f0f2_2 + $f1f1_2  + $f3f9_76 + $f4f8_38 + $f5f7_76 + $f6f6_19;\n        $h3 = $f0f3_2 + $f1f2_2  + $f4f9_38 + $f5f8_38 + $f6f7_38;\n        $h4 = $f0f4_2 + $f1f3_4  + $f2f2    + $f5f9_76 + $f6f8_38 + $f7f7_38;\n        $h5 = $f0f5_2 + $f1f4_2  + $f2f3_2  + $f6f9_38 + $f7f8_38;\n        $h6 = $f0f6_2 + $f1f5_4  + $f2f4_2  + $f3f3_2  + $f7f9_76 + $f8f8_19;\n        $h7 = $f0f7_2 + $f1f6_2  + $f2f5_2  + $f3f4_2  + $f8f9_38;\n        $h8 = $f0f8_2 + $f1f7_4  + $f2f6_2  + $f3f5_4  + $f4f4    + $f9f9_38;\n        $h9 = $f0f9_2 + $f1f8_2  + $f2f7_2  + $f3f6_2  + $f4f5_2;\n\n        $carry0 = ($h0 + (1 << 25)) >> 26;\n        $h1 += $carry0;\n        $h0 -= $carry0 << 26;\n        $carry4 = ($h4 + (1 << 25)) >> 26;\n        $h5 += $carry4;\n        $h4 -= $carry4 << 26;\n\n        $carry1 = ($h1 + (1 << 24)) >> 25;\n        $h2 += $carry1;\n        $h1 -= $carry1 << 25;\n        $carry5 = ($h5 + (1 << 24)) >> 25;\n        $h6 += $carry5;\n        $h5 -= $carry5 << 25;\n\n        $carry2 = ($h2 + (1 << 25)) >> 26;\n        $h3 += $carry2;\n        $h2 -= $carry2 << 26;\n        $carry6 = ($h6 + (1 << 25)) >> 26;\n        $h7 += $carry6;\n        $h6 -= $carry6 << 26;\n\n        $carry3 = ($h3 + (1 << 24)) >> 25;\n        $h4 += $carry3;\n        $h3 -= $carry3 << 25;\n        $carry7 = ($h7 + (1 << 24)) >> 25;\n        $h8 += $carry7;\n        $h7 -= $carry7 << 25;\n\n        $carry4 = ($h4 + (1 << 25)) >> 26;\n        $h5 += $carry4;\n        $h4 -= $carry4 << 26;\n        $carry8 = ($h8 + (1 << 25)) >> 26;\n        $h9 += $carry8;\n        $h8 -= $carry8 << 26;\n\n        $carry9 = ($h9 + (1 << 24)) >> 25;\n        $h0 += self::mul($carry9, 19, 5);\n        $h9 -= $carry9 << 25;\n\n        $carry0 = ($h0 + (1 << 25)) >> 26;\n        $h1 += $carry0;\n        $h0 -= $carry0 << 26;\n\n        return self::fe_normalize(\n            ParagonIE_Sodium_Core_Curve25519_Fe::fromArray(\n                array(\n                    (int) $h0,\n                    (int) $h1,\n                    (int) $h2,\n                    (int) $h3,\n                    (int) $h4,\n                    (int) $h5,\n                    (int) $h6,\n                    (int) $h7,\n                    (int) $h8,\n                    (int) $h9\n                )\n            )\n        );\n    }\n\n\n    \/**\n     * Square and double a field element\n     *\n     * h = 2 * f * f\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param ParagonIE_Sodium_Core_Curve25519_Fe $f\n     * @return ParagonIE_Sodium_Core_Curve25519_Fe\n     *\/\n    public static function fe_sq2(ParagonIE_Sodium_Core_Curve25519_Fe $f)\n    {\n        $f = self::fe_normalize($f);\n        $f0 = (int) $f[0];\n        $f1 = (int) $f[1];\n        $f2 = (int) $f[2];\n        $f3 = (int) $f[3];\n        $f4 = (int) $f[4];\n        $f5 = (int) $f[5];\n        $f6 = (int) $f[6];\n        $f7 = (int) $f[7];\n        $f8 = (int) $f[8];\n        $f9 = (int) $f[9];\n\n        $f0_2 = $f0 << 1;\n        $f1_2 = $f1 << 1;\n        $f2_2 = $f2 << 1;\n        $f3_2 = $f3 << 1;\n        $f4_2 = $f4 << 1;\n        $f5_2 = $f5 << 1;\n        $f6_2 = $f6 << 1;\n        $f7_2 = $f7 << 1;\n        $f5_38 = self::mul($f5, 38, 6); \/* 1.959375*2^30 *\/\n        $f6_19 = self::mul($f6, 19, 5); \/* 1.959375*2^30 *\/\n        $f7_38 = self::mul($f7, 38, 6); \/* 1.959375*2^30 *\/\n        $f8_19 = self::mul($f8, 19, 5); \/* 1.959375*2^30 *\/\n        $f9_38 = self::mul($f9, 38, 6); \/* 1.959375*2^30 *\/\n        $f0f0 = self::mul($f0, $f0, 24);\n        $f0f1_2 = self::mul($f0_2, $f1, 24);\n        $f0f2_2 = self::mul($f0_2, $f2, 24);\n        $f0f3_2 = self::mul($f0_2, $f3, 24);\n        $f0f4_2 = self::mul($f0_2, $f4, 24);\n        $f0f5_2 = self::mul($f0_2, $f5, 24);\n        $f0f6_2 = self::mul($f0_2, $f6, 24);\n        $f0f7_2 = self::mul($f0_2, $f7, 24);\n        $f0f8_2 = self::mul($f0_2, $f8, 24);\n        $f0f9_2 = self::mul($f0_2, $f9, 24);\n        $f1f1_2 = self::mul($f1_2,  $f1, 24);\n        $f1f2_2 = self::mul($f1_2,  $f2, 24);\n        $f1f3_4 = self::mul($f1_2,  $f3_2, 24);\n        $f1f4_2 = self::mul($f1_2,  $f4, 24);\n        $f1f5_4 = self::mul($f1_2,  $f5_2, 24);\n        $f1f6_2 = self::mul($f1_2,  $f6, 24);\n        $f1f7_4 = self::mul($f1_2,  $f7_2, 24);\n        $f1f8_2 = self::mul($f1_2,  $f8, 24);\n        $f1f9_76 = self::mul($f9_38, $f1_2, 24);\n        $f2f2 = self::mul($f2,  $f2, 24);\n        $f2f3_2 = self::mul($f2_2,  $f3, 24);\n        $f2f4_2 = self::mul($f2_2,  $f4, 24);\n        $f2f5_2 = self::mul($f2_2,  $f5, 24);\n        $f2f6_2 = self::mul($f2_2,  $f6, 24);\n        $f2f7_2 = self::mul($f2_2,  $f7, 24);\n        $f2f8_38 = self::mul($f8_19, $f2_2, 25);\n        $f2f9_38 = self::mul($f9_38, $f2, 24);\n        $f3f3_2 = self::mul($f3_2,  $f3, 24);\n        $f3f4_2 = self::mul($f3_2,  $f4, 24);\n        $f3f5_4 = self::mul($f3_2,  $f5_2, 24);\n        $f3f6_2 = self::mul($f3_2,  $f6, 24);\n        $f3f7_76 = self::mul($f7_38, $f3_2, 24);\n        $f3f8_38 = self::mul($f8_19, $f3_2, 24);\n        $f3f9_76 = self::mul($f9_38, $f3_2, 24);\n        $f4f4 = self::mul($f4,  $f4, 24);\n        $f4f5_2 = self::mul($f4_2,  $f5, 24);\n        $f4f6_38 = self::mul($f6_19, $f4_2, 25);\n        $f4f7_38 = self::mul($f7_38, $f4, 24);\n        $f4f8_38 = self::mul($f8_19, $f4_2, 25);\n        $f4f9_38 = self::mul($f9_38, $f4, 24);\n        $f5f5_38 = self::mul($f5_38, $f5, 24);\n        $f5f6_38 = self::mul($f6_19, $f5_2, 24);\n        $f5f7_76 = self::mul($f7_38, $f5_2, 24);\n        $f5f8_38 = self::mul($f8_19, $f5_2, 24);\n        $f5f9_76 = self::mul($f9_38, $f5_2, 24);\n        $f6f6_19 = self::mul($f6_19, $f6, 24);\n        $f6f7_38 = self::mul($f7_38, $f6, 24);\n        $f6f8_38 = self::mul($f8_19, $f6_2, 25);\n        $f6f9_38 = self::mul($f9_38, $f6, 24);\n        $f7f7_38 = self::mul($f7_38, $f7, 24);\n        $f7f8_38 = self::mul($f8_19, $f7_2, 24);\n        $f7f9_76 = self::mul($f9_38, $f7_2, 24);\n        $f8f8_19 = self::mul($f8_19, $f8, 24);\n        $f8f9_38 = self::mul($f9_38, $f8, 24);\n        $f9f9_38 = self::mul($f9_38, $f9, 24);\n\n        $h0 = (int) ($f0f0 + $f1f9_76 + $f2f8_38 + $f3f7_76 + $f4f6_38 + $f5f5_38) << 1;\n        $h1 = (int) ($f0f1_2 + $f2f9_38 + $f3f8_38 + $f4f7_38 + $f5f6_38) << 1;\n        $h2 = (int) ($f0f2_2 + $f1f1_2  + $f3f9_76 + $f4f8_38 + $f5f7_76 + $f6f6_19) << 1;\n        $h3 = (int) ($f0f3_2 + $f1f2_2  + $f4f9_38 + $f5f8_38 + $f6f7_38) << 1;\n        $h4 = (int) ($f0f4_2 + $f1f3_4  + $f2f2    + $f5f9_76 + $f6f8_38 + $f7f7_38) << 1;\n        $h5 = (int) ($f0f5_2 + $f1f4_2  + $f2f3_2  + $f6f9_38 + $f7f8_38) << 1;\n        $h6 = (int) ($f0f6_2 + $f1f5_4  + $f2f4_2  + $f3f3_2  + $f7f9_76 + $f8f8_19) << 1;\n        $h7 = (int) ($f0f7_2 + $f1f6_2  + $f2f5_2  + $f3f4_2  + $f8f9_38) << 1;\n        $h8 = (int) ($f0f8_2 + $f1f7_4  + $f2f6_2  + $f3f5_4  + $f4f4    + $f9f9_38) << 1;\n        $h9 = (int) ($f0f9_2 + $f1f8_2  + $f2f7_2  + $f3f6_2  + $f4f5_2) << 1;\n\n        $carry0 = ($h0 + (1 << 25)) >> 26;\n        $h1 += $carry0;\n        $h0 -= $carry0 << 26;\n        $carry4 = ($h4 + (1 << 25)) >> 26;\n        $h5 += $carry4;\n        $h4 -= $carry4 << 26;\n\n        $carry1 = ($h1 + (1 << 24)) >> 25;\n        $h2 += $carry1;\n        $h1 -= $carry1 << 25;\n        $carry5 = ($h5 + (1 << 24)) >> 25;\n        $h6 += $carry5;\n        $h5 -= $carry5 << 25;\n\n        $carry2 = ($h2 + (1 << 25)) >> 26;\n        $h3 += $carry2;\n        $h2 -= $carry2 << 26;\n        $carry6 = ($h6 + (1 << 25)) >> 26;\n        $h7 += $carry6;\n        $h6 -= $carry6 << 26;\n\n        $carry3 = ($h3 + (1 << 24)) >> 25;\n        $h4 += $carry3;\n        $h3 -= $carry3 << 25;\n        $carry7 = ($h7 + (1 << 24)) >> 25;\n        $h8 += $carry7;\n        $h7 -= $carry7 << 25;\n\n        $carry4 = ($h4 + (1 << 25)) >> 26;\n        $h5 += $carry4;\n        $h4 -= $carry4 << 26;\n        $carry8 = ($h8 + (1 << 25)) >> 26;\n        $h9 += $carry8;\n        $h8 -= $carry8 << 26;\n\n        $carry9 = ($h9 + (1 << 24)) >> 25;\n        $h0 += self::mul($carry9, 19, 5);\n        $h9 -= $carry9 << 25;\n\n        $carry0 = ($h0 + (1 << 25)) >> 26;\n        $h1 += $carry0;\n        $h0 -= $carry0 << 26;\n\n        return self::fe_normalize(\n            ParagonIE_Sodium_Core_Curve25519_Fe::fromArray(\n                array(\n                    (int) $h0,\n                    (int) $h1,\n                    (int) $h2,\n                    (int) $h3,\n                    (int) $h4,\n                    (int) $h5,\n                    (int) $h6,\n                    (int) $h7,\n                    (int) $h8,\n                    (int) $h9\n                )\n            )\n        );\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param ParagonIE_Sodium_Core_Curve25519_Fe $Z\n     * @return ParagonIE_Sodium_Core_Curve25519_Fe\n     *\/\n    public static function fe_invert(ParagonIE_Sodium_Core_Curve25519_Fe $Z)\n    {\n        $z = clone $Z;\n        $t0 = self::fe_sq($z);\n        $t1 = self::fe_sq($t0);\n        $t1 = self::fe_sq($t1);\n        $t1 = self::fe_mul($z, $t1);\n        $t0 = self::fe_mul($t0, $t1);\n        $t2 = self::fe_sq($t0);\n        $t1 = self::fe_mul($t1, $t2);\n        $t2 = self::fe_sq($t1);\n        for ($i = 1; $i < 5; ++$i) {\n            $t2 = self::fe_sq($t2);\n        }\n        $t1 = self::fe_mul($t2, $t1);\n        $t2 = self::fe_sq($t1);\n        for ($i = 1; $i < 10; ++$i) {\n            $t2 = self::fe_sq($t2);\n        }\n        $t2 = self::fe_mul($t2, $t1);\n        $t3 = self::fe_sq($t2);\n        for ($i = 1; $i < 20; ++$i) {\n            $t3 = self::fe_sq($t3);\n        }\n        $t2 = self::fe_mul($t3, $t2);\n        $t2 = self::fe_sq($t2);\n        for ($i = 1; $i < 10; ++$i) {\n            $t2 = self::fe_sq($t2);\n        }\n        $t1 = self::fe_mul($t2, $t1);\n        $t2 = self::fe_sq($t1);\n        for ($i = 1; $i < 50; ++$i) {\n            $t2 = self::fe_sq($t2);\n        }\n        $t2 = self::fe_mul($t2, $t1);\n        $t3 = self::fe_sq($t2);\n        for ($i = 1; $i < 100; ++$i) {\n            $t3 = self::fe_sq($t3);\n        }\n        $t2 = self::fe_mul($t3, $t2);\n        $t2 = self::fe_sq($t2);\n        for ($i = 1; $i < 50; ++$i) {\n            $t2 = self::fe_sq($t2);\n        }\n        $t1 = self::fe_mul($t2, $t1);\n        $t1 = self::fe_sq($t1);\n        for ($i = 1; $i < 5; ++$i) {\n            $t1 = self::fe_sq($t1);\n        }\n        return self::fe_mul($t1, $t0);\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @ref https:\/\/github.com\/jedisct1\/libsodium\/blob\/68564326e1e9dc57ef03746f85734232d20ca6fb\/src\/libsodium\/crypto_core\/curve25519\/ref10\/curve25519_ref10.c#L1054-L1106\n     *\n     * @param ParagonIE_Sodium_Core_Curve25519_Fe $z\n     * @return ParagonIE_Sodium_Core_Curve25519_Fe\n     *\/\n    public static function fe_pow22523(ParagonIE_Sodium_Core_Curve25519_Fe $z)\n    {\n        $z = self::fe_normalize($z);\n        # fe_sq(t0, z);\n        # fe_sq(t1, t0);\n        # fe_sq(t1, t1);\n        # fe_mul(t1, z, t1);\n        # fe_mul(t0, t0, t1);\n        # fe_sq(t0, t0);\n        # fe_mul(t0, t1, t0);\n        # fe_sq(t1, t0);\n        $t0 = self::fe_sq($z);\n        $t1 = self::fe_sq($t0);\n        $t1 = self::fe_sq($t1);\n        $t1 = self::fe_mul($z, $t1);\n        $t0 = self::fe_mul($t0, $t1);\n        $t0 = self::fe_sq($t0);\n        $t0 = self::fe_mul($t1, $t0);\n        $t1 = self::fe_sq($t0);\n\n        # for (i = 1; i < 5; ++i) {\n        #     fe_sq(t1, t1);\n        # }\n        for ($i = 1; $i < 5; ++$i) {\n            $t1 = self::fe_sq($t1);\n        }\n\n        # fe_mul(t0, t1, t0);\n        # fe_sq(t1, t0);\n        $t0 = self::fe_mul($t1, $t0);\n        $t1 = self::fe_sq($t0);\n\n        # for (i = 1; i < 10; ++i) {\n        #     fe_sq(t1, t1);\n        # }\n        for ($i = 1; $i < 10; ++$i) {\n            $t1 = self::fe_sq($t1);\n        }\n\n        # fe_mul(t1, t1, t0);\n        # fe_sq(t2, t1);\n        $t1 = self::fe_mul($t1, $t0);\n        $t2 = self::fe_sq($t1);\n\n        # for (i = 1; i < 20; ++i) {\n        #     fe_sq(t2, t2);\n        # }\n        for ($i = 1; $i < 20; ++$i) {\n            $t2 = self::fe_sq($t2);\n        }\n\n        # fe_mul(t1, t2, t1);\n        # fe_sq(t1, t1);\n        $t1 = self::fe_mul($t2, $t1);\n        $t1 = self::fe_sq($t1);\n\n        # for (i = 1; i < 10; ++i) {\n        #     fe_sq(t1, t1);\n        # }\n        for ($i = 1; $i < 10; ++$i) {\n            $t1 = self::fe_sq($t1);\n        }\n\n        # fe_mul(t0, t1, t0);\n        # fe_sq(t1, t0);\n        $t0 = self::fe_mul($t1, $t0);\n        $t1 = self::fe_sq($t0);\n\n        # for (i = 1; i < 50; ++i) {\n        #     fe_sq(t1, t1);\n        # }\n        for ($i = 1; $i < 50; ++$i) {\n            $t1 = self::fe_sq($t1);\n        }\n\n        # fe_mul(t1, t1, t0);\n        # fe_sq(t2, t1);\n        $t1 = self::fe_mul($t1, $t0);\n        $t2 = self::fe_sq($t1);\n\n        # for (i = 1; i < 100; ++i) {\n        #     fe_sq(t2, t2);\n        # }\n        for ($i = 1; $i < 100; ++$i) {\n            $t2 = self::fe_sq($t2);\n        }\n\n        # fe_mul(t1, t2, t1);\n        # fe_sq(t1, t1);\n        $t1 = self::fe_mul($t2, $t1);\n        $t1 = self::fe_sq($t1);\n\n        # for (i = 1; i < 50; ++i) {\n        #     fe_sq(t1, t1);\n        # }\n        for ($i = 1; $i < 50; ++$i) {\n            $t1 = self::fe_sq($t1);\n        }\n\n        # fe_mul(t0, t1, t0);\n        # fe_sq(t0, t0);\n        # fe_sq(t0, t0);\n        # fe_mul(out, t0, z);\n        $t0 = self::fe_mul($t1, $t0);\n        $t0 = self::fe_sq($t0);\n        $t0 = self::fe_sq($t0);\n        return self::fe_mul($t0, $z);\n    }\n\n    \/**\n     * Subtract two field elements.\n     *\n     * h = f - g\n     *\n     * Preconditions:\n     * |f| bounded by 1.1*2^25,1.1*2^24,1.1*2^25,1.1*2^24,etc.\n     * |g| bounded by 1.1*2^25,1.1*2^24,1.1*2^25,1.1*2^24,etc.\n     *\n     * Postconditions:\n     * |h| bounded by 1.1*2^26,1.1*2^25,1.1*2^26,1.1*2^25,etc.\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param ParagonIE_Sodium_Core_Curve25519_Fe $f\n     * @param ParagonIE_Sodium_Core_Curve25519_Fe $g\n     * @return ParagonIE_Sodium_Core_Curve25519_Fe\n     * @psalm-suppress MixedOperand\n     *\/\n    public static function fe_sub(ParagonIE_Sodium_Core_Curve25519_Fe $f, ParagonIE_Sodium_Core_Curve25519_Fe $g)\n    {\n        return self::fe_normalize(\n            ParagonIE_Sodium_Core_Curve25519_Fe::fromArray(\n                array(\n                    (int) ($f[0] - $g[0]),\n                    (int) ($f[1] - $g[1]),\n                    (int) ($f[2] - $g[2]),\n                    (int) ($f[3] - $g[3]),\n                    (int) ($f[4] - $g[4]),\n                    (int) ($f[5] - $g[5]),\n                    (int) ($f[6] - $g[6]),\n                    (int) ($f[7] - $g[7]),\n                    (int) ($f[8] - $g[8]),\n                    (int) ($f[9] - $g[9])\n                )\n            )\n        );\n    }\n\n    \/**\n     * Add two group elements.\n     *\n     * r = p + q\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param ParagonIE_Sodium_Core_Curve25519_Ge_P3 $p\n     * @param ParagonIE_Sodium_Core_Curve25519_Ge_Cached $q\n     * @return ParagonIE_Sodium_Core_Curve25519_Ge_P1p1\n     *\/\n    public static function ge_add(\n        ParagonIE_Sodium_Core_Curve25519_Ge_P3 $p,\n        ParagonIE_Sodium_Core_Curve25519_Ge_Cached $q\n    ) {\n        $r = new ParagonIE_Sodium_Core_Curve25519_Ge_P1p1();\n        $r->X = self::fe_add($p->Y, $p->X);\n        $r->Y = self::fe_sub($p->Y, $p->X);\n        $r->Z = self::fe_mul($r->X, $q->YplusX);\n        $r->Y = self::fe_mul($r->Y, $q->YminusX);\n        $r->T = self::fe_mul($q->T2d, $p->T);\n        $r->X = self::fe_mul($p->Z, $q->Z);\n        $t0   = self::fe_add($r->X, $r->X);\n        $r->X = self::fe_sub($r->Z, $r->Y);\n        $r->Y = self::fe_add($r->Z, $r->Y);\n        $r->Z = self::fe_add($t0, $r->T);\n        $r->T = self::fe_sub($t0, $r->T);\n        return $r;\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @ref https:\/\/github.com\/jedisct1\/libsodium\/blob\/157c4a80c13b117608aeae12178b2d38825f9f8f\/src\/libsodium\/crypto_core\/curve25519\/ref10\/curve25519_ref10.c#L1185-L1215\n     * @param string $a\n     * @return array<int, mixed>\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function slide($a)\n    {\n        if (self::strlen($a) < 256) {\n            if (self::strlen($a) < 16) {\n                $a = str_pad($a, 256, '0', STR_PAD_RIGHT);\n            }\n        }\n        \/** @var array<int, int> $r *\/\n        $r = array();\n\n        \/** @var int $i *\/\n        for ($i = 0; $i < 256; ++$i) {\n            $r[$i] = (int) (\n                1 & (\n                    self::chrToInt($a[(int) ($i >> 3)])\n                        >>\n                    ($i & 7)\n                )\n            );\n        }\n\n        for ($i = 0;$i < 256;++$i) {\n            if ($r[$i]) {\n                for ($b = 1;$b <= 6 && $i + $b < 256;++$b) {\n                    if ($r[$i + $b]) {\n                        if ($r[$i] + ($r[$i + $b] << $b) <= 15) {\n                            $r[$i] += $r[$i + $b] << $b;\n                            $r[$i + $b] = 0;\n                        } elseif ($r[$i] - ($r[$i + $b] << $b) >= -15) {\n                            $r[$i] -= $r[$i + $b] << $b;\n                            for ($k = $i + $b; $k < 256; ++$k) {\n                                if (!$r[$k]) {\n                                    $r[$k] = 1;\n                                    break;\n                                }\n                                $r[$k] = 0;\n                            }\n                        } else {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        return $r;\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param string $s\n     * @return ParagonIE_Sodium_Core_Curve25519_Ge_P3\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function ge_frombytes_negate_vartime($s)\n    {\n        static $d = null;\n        if (!$d) {\n            $d = ParagonIE_Sodium_Core_Curve25519_Fe::fromArray(self::$d);\n        }\n\n        # fe_frombytes(h->Y,s);\n        # fe_1(h->Z);\n        $h = new ParagonIE_Sodium_Core_Curve25519_Ge_P3(\n            self::fe_0(),\n            self::fe_frombytes($s),\n            self::fe_1()\n        );\n\n        # fe_sq(u,h->Y);\n        # fe_mul(v,u,d);\n        # fe_sub(u,u,h->Z);       \/* u = y^2-1 *\/\n        # fe_add(v,v,h->Z);       \/* v = dy^2+1 *\/\n        $u = self::fe_sq($h->Y);\n        \/** @var ParagonIE_Sodium_Core_Curve25519_Fe $d *\/\n        $v = self::fe_mul($u, $d);\n        $u = self::fe_sub($u, $h->Z); \/* u =  y^2 - 1 *\/\n        $v = self::fe_add($v, $h->Z); \/* v = dy^2 + 1 *\/\n\n        # fe_sq(v3,v);\n        # fe_mul(v3,v3,v);        \/* v3 = v^3 *\/\n        # fe_sq(h->X,v3);\n        # fe_mul(h->X,h->X,v);\n        # fe_mul(h->X,h->X,u);    \/* x = uv^7 *\/\n        $v3 = self::fe_sq($v);\n        $v3 = self::fe_mul($v3, $v); \/* v3 = v^3 *\/\n        $h->X = self::fe_sq($v3);\n        $h->X = self::fe_mul($h->X, $v);\n        $h->X = self::fe_mul($h->X, $u); \/* x = uv^7 *\/\n\n        # fe_pow22523(h->X,h->X); \/* x = (uv^7)^((q-5)\/8) *\/\n        # fe_mul(h->X,h->X,v3);\n        # fe_mul(h->X,h->X,u);    \/* x = uv^3(uv^7)^((q-5)\/8) *\/\n        $h->X = self::fe_pow22523($h->X); \/* x = (uv^7)^((q-5)\/8) *\/\n        $h->X = self::fe_mul($h->X, $v3);\n        $h->X = self::fe_mul($h->X, $u); \/* x = uv^3(uv^7)^((q-5)\/8) *\/\n\n        # fe_sq(vxx,h->X);\n        # fe_mul(vxx,vxx,v);\n        # fe_sub(check,vxx,u);    \/* vx^2-u *\/\n        $vxx = self::fe_sq($h->X);\n        $vxx = self::fe_mul($vxx, $v);\n        $check = self::fe_sub($vxx, $u); \/* vx^2 - u *\/\n\n        # if (fe_isnonzero(check)) {\n        #     fe_add(check,vxx,u);  \/* vx^2+u *\/\n        #     if (fe_isnonzero(check)) {\n        #         return -1;\n        #     }\n        #     fe_mul(h->X,h->X,sqrtm1);\n        # }\n        if (self::fe_isnonzero($check)) {\n            $check = self::fe_add($vxx, $u); \/* vx^2 + u *\/\n            if (self::fe_isnonzero($check)) {\n                throw new RangeException('Internal check failed.');\n            }\n            $h->X = self::fe_mul(\n                $h->X,\n                ParagonIE_Sodium_Core_Curve25519_Fe::fromArray(self::$sqrtm1)\n            );\n        }\n\n        # if (fe_isnegative(h->X) == (s[31] >> 7)) {\n        #     fe_neg(h->X,h->X);\n        # }\n        $i = self::chrToInt($s[31]);\n        if (self::fe_isnegative($h->X) === ($i >> 7)) {\n            $h->X = self::fe_neg($h->X);\n        }\n\n        # fe_mul(h->T,h->X,h->Y);\n        $h->T = self::fe_mul($h->X, $h->Y);\n        return $h;\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param ParagonIE_Sodium_Core_Curve25519_Ge_P1p1 $R\n     * @param ParagonIE_Sodium_Core_Curve25519_Ge_P3 $p\n     * @param ParagonIE_Sodium_Core_Curve25519_Ge_Precomp $q\n     * @return ParagonIE_Sodium_Core_Curve25519_Ge_P1p1\n     *\/\n    public static function ge_madd(\n        ParagonIE_Sodium_Core_Curve25519_Ge_P1p1 $R,\n        ParagonIE_Sodium_Core_Curve25519_Ge_P3 $p,\n        ParagonIE_Sodium_Core_Curve25519_Ge_Precomp $q\n    ) {\n        $r = clone $R;\n        $r->X = self::fe_add($p->Y, $p->X);\n        $r->Y = self::fe_sub($p->Y, $p->X);\n        $r->Z = self::fe_mul($r->X, $q->yplusx);\n        $r->Y = self::fe_mul($r->Y, $q->yminusx);\n        $r->T = self::fe_mul($q->xy2d, $p->T);\n        $t0 = self::fe_add(clone $p->Z, clone $p->Z);\n        $r->X = self::fe_sub($r->Z, $r->Y);\n        $r->Y = self::fe_add($r->Z, $r->Y);\n        $r->Z = self::fe_add($t0, $r->T);\n        $r->T = self::fe_sub($t0, $r->T);\n\n        return $r;\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param ParagonIE_Sodium_Core_Curve25519_Ge_P1p1 $R\n     * @param ParagonIE_Sodium_Core_Curve25519_Ge_P3 $p\n     * @param ParagonIE_Sodium_Core_Curve25519_Ge_Precomp $q\n     * @return ParagonIE_Sodium_Core_Curve25519_Ge_P1p1\n     *\/\n    public static function ge_msub(\n        ParagonIE_Sodium_Core_Curve25519_Ge_P1p1 $R,\n        ParagonIE_Sodium_Core_Curve25519_Ge_P3 $p,\n        ParagonIE_Sodium_Core_Curve25519_Ge_Precomp $q\n    ) {\n        $r = clone $R;\n\n        $r->X = self::fe_add($p->Y, $p->X);\n        $r->Y = self::fe_sub($p->Y, $p->X);\n        $r->Z = self::fe_mul($r->X, $q->yminusx);\n        $r->Y = self::fe_mul($r->Y, $q->yplusx);\n        $r->T = self::fe_mul($q->xy2d, $p->T);\n        $t0 = self::fe_add($p->Z, $p->Z);\n        $r->X = self::fe_sub($r->Z, $r->Y);\n        $r->Y = self::fe_add($r->Z, $r->Y);\n        $r->Z = self::fe_sub($t0, $r->T);\n        $r->T = self::fe_add($t0, $r->T);\n\n        return $r;\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param ParagonIE_Sodium_Core_Curve25519_Ge_P1p1 $p\n     * @return ParagonIE_Sodium_Core_Curve25519_Ge_P2\n     *\/\n    public static function ge_p1p1_to_p2(ParagonIE_Sodium_Core_Curve25519_Ge_P1p1 $p)\n    {\n        $r = new ParagonIE_Sodium_Core_Curve25519_Ge_P2();\n        $r->X = self::fe_mul($p->X, $p->T);\n        $r->Y = self::fe_mul($p->Y, $p->Z);\n        $r->Z = self::fe_mul($p->Z, $p->T);\n        return $r;\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param ParagonIE_Sodium_Core_Curve25519_Ge_P1p1 $p\n     * @return ParagonIE_Sodium_Core_Curve25519_Ge_P3\n     *\/\n    public static function ge_p1p1_to_p3(ParagonIE_Sodium_Core_Curve25519_Ge_P1p1 $p)\n    {\n        $r = new ParagonIE_Sodium_Core_Curve25519_Ge_P3();\n        $r->X = self::fe_mul($p->X, $p->T);\n        $r->Y = self::fe_mul($p->Y, $p->Z);\n        $r->Z = self::fe_mul($p->Z, $p->T);\n        $r->T = self::fe_mul($p->X, $p->Y);\n        return $r;\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @return ParagonIE_Sodium_Core_Curve25519_Ge_P2\n     *\/\n    public static function ge_p2_0()\n    {\n        return new ParagonIE_Sodium_Core_Curve25519_Ge_P2(\n            self::fe_0(),\n            self::fe_1(),\n            self::fe_1()\n        );\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param ParagonIE_Sodium_Core_Curve25519_Ge_P2 $p\n     * @return ParagonIE_Sodium_Core_Curve25519_Ge_P1p1\n     *\/\n    public static function ge_p2_dbl(ParagonIE_Sodium_Core_Curve25519_Ge_P2 $p)\n    {\n        $r = new ParagonIE_Sodium_Core_Curve25519_Ge_P1p1();\n\n        $r->X = self::fe_sq($p->X);\n        $r->Z = self::fe_sq($p->Y);\n        $r->T = self::fe_sq2($p->Z);\n        $r->Y = self::fe_add($p->X, $p->Y);\n        $t0   = self::fe_sq($r->Y);\n        $r->Y = self::fe_add($r->Z, $r->X);\n        $r->Z = self::fe_sub($r->Z, $r->X);\n        $r->X = self::fe_sub($t0, $r->Y);\n        $r->T = self::fe_sub($r->T, $r->Z);\n\n        return $r;\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @return ParagonIE_Sodium_Core_Curve25519_Ge_P3\n     *\/\n    public static function ge_p3_0()\n    {\n        return new ParagonIE_Sodium_Core_Curve25519_Ge_P3(\n            self::fe_0(),\n            self::fe_1(),\n            self::fe_1(),\n            self::fe_0()\n        );\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param ParagonIE_Sodium_Core_Curve25519_Ge_P3 $p\n     * @return ParagonIE_Sodium_Core_Curve25519_Ge_Cached\n     *\/\n    public static function ge_p3_to_cached(ParagonIE_Sodium_Core_Curve25519_Ge_P3 $p)\n    {\n        static $d2 = null;\n        if ($d2 === null) {\n            $d2 = ParagonIE_Sodium_Core_Curve25519_Fe::fromArray(self::$d2);\n        }\n        \/** @var ParagonIE_Sodium_Core_Curve25519_Fe $d2 *\/\n        $r = new ParagonIE_Sodium_Core_Curve25519_Ge_Cached();\n        $r->YplusX = self::fe_add($p->Y, $p->X);\n        $r->YminusX = self::fe_sub($p->Y, $p->X);\n        $r->Z = self::fe_copy($p->Z);\n        $r->T2d = self::fe_mul($p->T, $d2);\n        return $r;\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param ParagonIE_Sodium_Core_Curve25519_Ge_P3 $p\n     * @return ParagonIE_Sodium_Core_Curve25519_Ge_P2\n     *\/\n    public static function ge_p3_to_p2(ParagonIE_Sodium_Core_Curve25519_Ge_P3 $p)\n    {\n        return new ParagonIE_Sodium_Core_Curve25519_Ge_P2(\n            self::fe_copy($p->X),\n            self::fe_copy($p->Y),\n            self::fe_copy($p->Z)\n        );\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param ParagonIE_Sodium_Core_Curve25519_Ge_P3 $h\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function ge_p3_tobytes(ParagonIE_Sodium_Core_Curve25519_Ge_P3 $h)\n    {\n        $recip = self::fe_invert($h->Z);\n        $x = self::fe_mul($h->X, $recip);\n        $y = self::fe_mul($h->Y, $recip);\n        $s = self::fe_tobytes($y);\n        $s[31] = self::intToChr(\n            self::chrToInt($s[31]) ^ (self::fe_isnegative($x) << 7)\n        );\n        return $s;\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param ParagonIE_Sodium_Core_Curve25519_Ge_P3 $p\n     * @return ParagonIE_Sodium_Core_Curve25519_Ge_P1p1\n     *\/\n    public static function ge_p3_dbl(ParagonIE_Sodium_Core_Curve25519_Ge_P3 $p)\n    {\n        $q = self::ge_p3_to_p2($p);\n        return self::ge_p2_dbl($q);\n    }\n\n    \/**\n     * @return ParagonIE_Sodium_Core_Curve25519_Ge_Precomp\n     *\/\n    public static function ge_precomp_0()\n    {\n        return new ParagonIE_Sodium_Core_Curve25519_Ge_Precomp(\n            self::fe_1(),\n            self::fe_1(),\n            self::fe_0()\n        );\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param int $b\n     * @param int $c\n     * @return int\n     *\/\n    public static function equal($b, $c)\n    {\n        return (int) ((($b ^ $c) - 1) >> 31) & 1;\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param int|string $char\n     * @return int (1 = yes, 0 = no)\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function negative($char)\n    {\n        if (is_int($char)) {\n            return ($char >> 63) & 1;\n        }\n        $x = self::chrToInt(self::substr($char, 0, 1));\n        return (int) ($x >> 63);\n    }\n\n    \/**\n     * Conditional move\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param ParagonIE_Sodium_Core_Curve25519_Ge_Precomp $t\n     * @param ParagonIE_Sodium_Core_Curve25519_Ge_Precomp $u\n     * @param int $b\n     * @return ParagonIE_Sodium_Core_Curve25519_Ge_Precomp\n     *\/\n    public static function cmov(\n        ParagonIE_Sodium_Core_Curve25519_Ge_Precomp $t,\n        ParagonIE_Sodium_Core_Curve25519_Ge_Precomp $u,\n        $b\n    ) {\n        if (!is_int($b)) {\n            throw new InvalidArgumentException('Expected an integer.');\n        }\n        return new ParagonIE_Sodium_Core_Curve25519_Ge_Precomp(\n            self::fe_cmov($t->yplusx,  $u->yplusx,  $b),\n            self::fe_cmov($t->yminusx, $u->yminusx, $b),\n            self::fe_cmov($t->xy2d,    $u->xy2d,    $b)\n        );\n    }\n\n    \/**\n     * @param ParagonIE_Sodium_Core_Curve25519_Ge_Cached $t\n     * @param ParagonIE_Sodium_Core_Curve25519_Ge_Cached $u\n     * @param int $b\n     * @return ParagonIE_Sodium_Core_Curve25519_Ge_Cached\n     *\/\n    public static function ge_cmov_cached(\n        ParagonIE_Sodium_Core_Curve25519_Ge_Cached $t,\n        ParagonIE_Sodium_Core_Curve25519_Ge_Cached $u,\n        $b\n    ) {\n        $b &= 1;\n        $ret = new ParagonIE_Sodium_Core_Curve25519_Ge_Cached();\n        $ret->YplusX  = self::fe_cmov($t->YplusX,  $u->YplusX,  $b);\n        $ret->YminusX = self::fe_cmov($t->YminusX, $u->YminusX, $b);\n        $ret->Z       = self::fe_cmov($t->Z,       $u->Z,       $b);\n        $ret->T2d     = self::fe_cmov($t->T2d,     $u->T2d,     $b);\n        return $ret;\n    }\n\n    \/**\n     * @param ParagonIE_Sodium_Core_Curve25519_Ge_Cached[] $cached\n     * @param int $b\n     * @return ParagonIE_Sodium_Core_Curve25519_Ge_Cached\n     * @throws SodiumException\n     *\/\n    public static function ge_cmov8_cached(array $cached, $b)\n    {\n        \/\/ const unsigned char bnegative = negative(b);\n        \/\/ const unsigned char babs      = b - (((-bnegative) & b) * ((signed char) 1 << 1));\n        $bnegative = self::negative($b);\n        $babs = $b - (((-$bnegative) & $b) << 1);\n\n        \/\/ ge25519_cached_0(t);\n        $t = new ParagonIE_Sodium_Core_Curve25519_Ge_Cached(\n            self::fe_1(),\n            self::fe_1(),\n            self::fe_1(),\n            self::fe_0()\n        );\n\n        \/\/ ge25519_cmov_cached(t, &cached[0], equal(babs, 1));\n        \/\/ ge25519_cmov_cached(t, &cached[1], equal(babs, 2));\n        \/\/ ge25519_cmov_cached(t, &cached[2], equal(babs, 3));\n        \/\/ ge25519_cmov_cached(t, &cached[3], equal(babs, 4));\n        \/\/ ge25519_cmov_cached(t, &cached[4], equal(babs, 5));\n        \/\/ ge25519_cmov_cached(t, &cached[5], equal(babs, 6));\n        \/\/ ge25519_cmov_cached(t, &cached[6], equal(babs, 7));\n        \/\/ ge25519_cmov_cached(t, &cached[7], equal(babs, 8));\n        for ($x = 0; $x < 8; ++$x) {\n            $t = self::ge_cmov_cached($t, $cached[$x], self::equal($babs, $x + 1));\n        }\n\n        \/\/ fe25519_copy(minust.YplusX, t->YminusX);\n        \/\/ fe25519_copy(minust.YminusX, t->YplusX);\n        \/\/ fe25519_copy(minust.Z, t->Z);\n        \/\/ fe25519_neg(minust.T2d, t->T2d);\n        $minust = new ParagonIE_Sodium_Core_Curve25519_Ge_Cached(\n            self::fe_copy($t->YminusX),\n            self::fe_copy($t->YplusX),\n            self::fe_copy($t->Z),\n            self::fe_neg($t->T2d)\n        );\n        return self::ge_cmov_cached($t, $minust, $bnegative);\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param int $pos\n     * @param int $b\n     * @return ParagonIE_Sodium_Core_Curve25519_Ge_Precomp\n     * @throws SodiumException\n     * @throws TypeError\n     * @psalm-suppress MixedArgument\n     * @psalm-suppress MixedArrayAccess\n     * @psalm-suppress MixedArrayOffset\n     *\/\n    public static function ge_select($pos = 0, $b = 0)\n    {\n        static $base = null;\n        if ($base === null) {\n            $base = array();\n            \/** @var int $i *\/\n            foreach (self::$base as $i => $bas) {\n                for ($j = 0; $j < 8; ++$j) {\n                    $base[$i][$j] = new ParagonIE_Sodium_Core_Curve25519_Ge_Precomp(\n                        ParagonIE_Sodium_Core_Curve25519_Fe::fromArray($bas[$j][0]),\n                        ParagonIE_Sodium_Core_Curve25519_Fe::fromArray($bas[$j][1]),\n                        ParagonIE_Sodium_Core_Curve25519_Fe::fromArray($bas[$j][2])\n                    );\n                }\n            }\n        }\n        \/** @var array<int, array<int, ParagonIE_Sodium_Core_Curve25519_Ge_Precomp>> $base *\/\n        if (!is_int($pos)) {\n            throw new InvalidArgumentException('Position must be an integer');\n        }\n        if ($pos < 0 || $pos > 31) {\n            throw new RangeException('Position is out of range [0, 31]');\n        }\n\n        $bnegative = self::negative($b);\n        $babs = $b - (((-$bnegative) & $b) << 1);\n\n        $t = self::ge_precomp_0();\n        for ($i = 0; $i < 8; ++$i) {\n            $t = self::cmov(\n                $t,\n                $base[$pos][$i],\n                self::equal($babs, $i + 1)\n            );\n        }\n        $minusT = new ParagonIE_Sodium_Core_Curve25519_Ge_Precomp(\n            self::fe_copy($t->yminusx),\n            self::fe_copy($t->yplusx),\n            self::fe_neg($t->xy2d)\n        );\n        return self::cmov($t, $minusT, $bnegative);\n    }\n\n    \/**\n     * Subtract two group elements.\n     *\n     * r = p - q\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param ParagonIE_Sodium_Core_Curve25519_Ge_P3 $p\n     * @param ParagonIE_Sodium_Core_Curve25519_Ge_Cached $q\n     * @return ParagonIE_Sodium_Core_Curve25519_Ge_P1p1\n     *\/\n    public static function ge_sub(\n        ParagonIE_Sodium_Core_Curve25519_Ge_P3 $p,\n        ParagonIE_Sodium_Core_Curve25519_Ge_Cached $q\n    ) {\n        $r = new ParagonIE_Sodium_Core_Curve25519_Ge_P1p1();\n\n        $r->X = self::fe_add($p->Y, $p->X);\n        $r->Y = self::fe_sub($p->Y, $p->X);\n        $r->Z = self::fe_mul($r->X, $q->YminusX);\n        $r->Y = self::fe_mul($r->Y, $q->YplusX);\n        $r->T = self::fe_mul($q->T2d, $p->T);\n        $r->X = self::fe_mul($p->Z, $q->Z);\n        $t0 = self::fe_add($r->X, $r->X);\n        $r->X = self::fe_sub($r->Z, $r->Y);\n        $r->Y = self::fe_add($r->Z, $r->Y);\n        $r->Z = self::fe_sub($t0, $r->T);\n        $r->T = self::fe_add($t0, $r->T);\n\n        return $r;\n    }\n\n    \/**\n     * Convert a group element to a byte string.\n     *\n     * @param ParagonIE_Sodium_Core_Curve25519_Ge_P2 $h\n     * @return string\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public static function ge_tobytes(ParagonIE_Sodium_Core_Curve25519_Ge_P2 $h)\n    {\n        $recip = self::fe_invert($h->Z);\n        $x = self::fe_mul($h->X, $recip);\n        $y = self::fe_mul($h->Y, $recip);\n        $s = self::fe_tobytes($y);\n        $s[31] = self::intToChr(\n            self::chrToInt($s[31]) ^ (self::fe_isnegative($x) << 7)\n        );\n        return $s;\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param string $a\n     * @param ParagonIE_Sodium_Core_Curve25519_Ge_P3 $A\n     * @param string $b\n     * @return ParagonIE_Sodium_Core_Curve25519_Ge_P2\n     * @throws SodiumException\n     * @throws TypeError\n     * @psalm-suppress MixedArgument\n     * @psalm-suppress MixedArrayAccess\n     *\/\n    public static function ge_double_scalarmult_vartime(\n        $a,\n        ParagonIE_Sodium_Core_Curve25519_Ge_P3 $A,\n        $b\n    ) {\n        \/** @var array<int, ParagonIE_Sodium_Core_Curve25519_Ge_Cached> $Ai *\/\n        $Ai = array();\n\n        \/** @var array<int, ParagonIE_Sodium_Core_Curve25519_Ge_Precomp> $Bi *\/\n        static $Bi = array();\n        if (!$Bi) {\n            for ($i = 0; $i < 8; ++$i) {\n                $Bi[$i] = new ParagonIE_Sodium_Core_Curve25519_Ge_Precomp(\n                    ParagonIE_Sodium_Core_Curve25519_Fe::fromArray(self::$base2[$i][0]),\n                    ParagonIE_Sodium_Core_Curve25519_Fe::fromArray(self::$base2[$i][1]),\n                    ParagonIE_Sodium_Core_Curve25519_Fe::fromArray(self::$base2[$i][2])\n                );\n            }\n        }\n        for ($i = 0; $i < 8; ++$i) {\n            $Ai[$i] = new ParagonIE_Sodium_Core_Curve25519_Ge_Cached(\n                self::fe_0(),\n                self::fe_0(),\n                self::fe_0(),\n                self::fe_0()\n            );\n        }\n\n        # slide(aslide,a);\n        # slide(bslide,b);\n        \/** @var array<int, int> $aslide *\/\n        $aslide = self::slide($a);\n        \/** @var array<int, int> $bslide *\/\n        $bslide = self::slide($b);\n\n        # ge_p3_to_cached(&Ai[0],A);\n        # ge_p3_dbl(&t,A); ge_p1p1_to_p3(&A2,&t);\n        $Ai[0] = self::ge_p3_to_cached($A);\n        $t = self::ge_p3_dbl($A);\n        $A2 = self::ge_p1p1_to_p3($t);\n\n        # ge_add(&t,&A2,&Ai[0]); ge_p1p1_to_p3(&u,&t); ge_p3_to_cached(&Ai[1],&u);\n        # ge_add(&t,&A2,&Ai[1]); ge_p1p1_to_p3(&u,&t); ge_p3_to_cached(&Ai[2],&u);\n        # ge_add(&t,&A2,&Ai[2]); ge_p1p1_to_p3(&u,&t); ge_p3_to_cached(&Ai[3],&u);\n        # ge_add(&t,&A2,&Ai[3]); ge_p1p1_to_p3(&u,&t); ge_p3_to_cached(&Ai[4],&u);\n        # ge_add(&t,&A2,&Ai[4]); ge_p1p1_to_p3(&u,&t); ge_p3_to_cached(&Ai[5],&u);\n        # ge_add(&t,&A2,&Ai[5]); ge_p1p1_to_p3(&u,&t); ge_p3_to_cached(&Ai[6],&u);\n        # ge_add(&t,&A2,&Ai[6]); ge_p1p1_to_p3(&u,&t); ge_p3_to_cached(&Ai[7],&u);\n        for ($i = 0; $i < 7; ++$i) {\n            $t = self::ge_add($A2, $Ai[$i]);\n            $u = self::ge_p1p1_to_p3($t);\n            $Ai[$i + 1] = self::ge_p3_to_cached($u);\n        }\n\n        # ge_p2_0(r);\n        $r = self::ge_p2_0();\n\n        # for (i = 255;i >= 0;--i) {\n        #     if (aslide[i] || bslide[i]) break;\n        # }\n        $i = 255;\n        for (; $i >= 0; --$i) {\n            if ($aslide[$i] || $bslide[$i]) {\n                break;\n            }\n        }\n\n        # for (;i >= 0;--i) {\n        for (; $i >= 0; --$i) {\n            # ge_p2_dbl(&t,r);\n            $t = self::ge_p2_dbl($r);\n\n            # if (aslide[i] > 0) {\n            if ($aslide[$i] > 0) {\n                # ge_p1p1_to_p3(&u,&t);\n                # ge_add(&t,&u,&Ai[aslide[i]\/2]);\n                $u = self::ge_p1p1_to_p3($t);\n                $t = self::ge_add(\n                    $u,\n                    $Ai[(int) floor($aslide[$i] \/ 2)]\n                );\n            # } else if (aslide[i] < 0) {\n            } elseif ($aslide[$i] < 0) {\n                # ge_p1p1_to_p3(&u,&t);\n                # ge_sub(&t,&u,&Ai[(-aslide[i])\/2]);\n                $u = self::ge_p1p1_to_p3($t);\n                $t = self::ge_sub(\n                    $u,\n                    $Ai[(int) floor(-$aslide[$i] \/ 2)]\n                );\n            }\n\n            # if (bslide[i] > 0) {\n            if ($bslide[$i] > 0) {\n                \/** @var int $index *\/\n                $index = (int) floor($bslide[$i] \/ 2);\n                # ge_p1p1_to_p3(&u,&t);\n                # ge_madd(&t,&u,&Bi[bslide[i]\/2]);\n                $u = self::ge_p1p1_to_p3($t);\n                $t = self::ge_madd($t, $u, $Bi[$index]);\n            # } else if (bslide[i] < 0) {\n            } elseif ($bslide[$i] < 0) {\n                \/** @var int $index *\/\n                $index = (int) floor(-$bslide[$i] \/ 2);\n                # ge_p1p1_to_p3(&u,&t);\n                # ge_msub(&t,&u,&Bi[(-bslide[i])\/2]);\n                $u = self::ge_p1p1_to_p3($t);\n                $t = self::ge_msub($t, $u, $Bi[$index]);\n            }\n            # ge_p1p1_to_p2(r,&t);\n            $r = self::ge_p1p1_to_p2($t);\n        }\n        return $r;\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param string $a\n     * @param ParagonIE_Sodium_Core_Curve25519_Ge_P3 $p\n     * @return ParagonIE_Sodium_Core_Curve25519_Ge_P3\n     * @throws SodiumException\n     * @throws TypeError\n     * @psalm-suppress MixedAssignment\n     * @psalm-suppress MixedOperand\n     *\/\n    public static function ge_scalarmult($a, $p)\n    {\n        $e = array_fill(0, 64, 0);\n\n        \/** @var ParagonIE_Sodium_Core_Curve25519_Ge_Cached[] $pi *\/\n        $pi = array();\n\n        \/\/        ge25519_p3_to_cached(&pi[1 - 1], p);   \/* p *\/\n        $pi[0] = self::ge_p3_to_cached($p);\n\n        \/\/        ge25519_p3_dbl(&t2, p);\n        \/\/        ge25519_p1p1_to_p3(&p2, &t2);\n        \/\/        ge25519_p3_to_cached(&pi[2 - 1], &p2); \/* 2p = 2*p *\/\n        $t2 = self::ge_p3_dbl($p);\n        $p2 = self::ge_p1p1_to_p3($t2);\n        $pi[1] = self::ge_p3_to_cached($p2);\n\n        \/\/        ge25519_add_cached(&t3, p, &pi[2 - 1]);\n        \/\/        ge25519_p1p1_to_p3(&p3, &t3);\n        \/\/        ge25519_p3_to_cached(&pi[3 - 1], &p3); \/* 3p = 2p+p *\/\n        $t3 = self::ge_add($p, $pi[1]);\n        $p3 = self::ge_p1p1_to_p3($t3);\n        $pi[2] = self::ge_p3_to_cached($p3);\n\n        \/\/        ge25519_p3_dbl(&t4, &p2);\n        \/\/        ge25519_p1p1_to_p3(&p4, &t4);\n        \/\/        ge25519_p3_to_cached(&pi[4 - 1], &p4); \/* 4p = 2*2p *\/\n        $t4 = self::ge_p3_dbl($p2);\n        $p4 = self::ge_p1p1_to_p3($t4);\n        $pi[3] = self::ge_p3_to_cached($p4);\n\n        \/\/        ge25519_add_cached(&t5, p, &pi[4 - 1]);\n        \/\/        ge25519_p1p1_to_p3(&p5, &t5);\n        \/\/        ge25519_p3_to_cached(&pi[5 - 1], &p5); \/* 5p = 4p+p *\/\n        $t5 = self::ge_add($p, $pi[3]);\n        $p5 = self::ge_p1p1_to_p3($t5);\n        $pi[4] = self::ge_p3_to_cached($p5);\n\n        \/\/        ge25519_p3_dbl(&t6, &p3);\n        \/\/        ge25519_p1p1_to_p3(&p6, &t6);\n        \/\/        ge25519_p3_to_cached(&pi[6 - 1], &p6); \/* 6p = 2*3p *\/\n        $t6 = self::ge_p3_dbl($p3);\n        $p6 = self::ge_p1p1_to_p3($t6);\n        $pi[5] = self::ge_p3_to_cached($p6);\n\n        \/\/        ge25519_add_cached(&t7, p, &pi[6 - 1]);\n        \/\/        ge25519_p1p1_to_p3(&p7, &t7);\n        \/\/        ge25519_p3_to_cached(&pi[7 - 1], &p7); \/* 7p = 6p+p *\/\n        $t7 = self::ge_add($p, $pi[5]);\n        $p7 = self::ge_p1p1_to_p3($t7);\n        $pi[6] = self::ge_p3_to_cached($p7);\n\n        \/\/        ge25519_p3_dbl(&t8, &p4);\n        \/\/        ge25519_p1p1_to_p3(&p8, &t8);\n        \/\/        ge25519_p3_to_cached(&pi[8 - 1], &p8); \/* 8p = 2*4p *\/\n        $t8 = self::ge_p3_dbl($p4);\n        $p8 = self::ge_p1p1_to_p3($t8);\n        $pi[7] = self::ge_p3_to_cached($p8);\n\n\n        \/\/        for (i = 0; i < 32; ++i) {\n        \/\/            e[2 * i + 0] = (a[i] >> 0) & 15;\n        \/\/            e[2 * i + 1] = (a[i] >> 4) & 15;\n        \/\/        }\n        for ($i = 0; $i < 32; ++$i) {\n            $e[($i << 1)    ] =  self::chrToInt($a[$i]) & 15;\n            $e[($i << 1) + 1] = (self::chrToInt($a[$i]) >> 4) & 15;\n        }\n        \/\/        \/* each e[i] is between 0 and 15 *\/\n        \/\/        \/* e[63] is between 0 and 7 *\/\n\n        \/\/        carry = 0;\n        \/\/        for (i = 0; i < 63; ++i) {\n        \/\/            e[i] += carry;\n        \/\/            carry = e[i] + 8;\n        \/\/            carry >>= 4;\n        \/\/            e[i] -= carry * ((signed char) 1 << 4);\n        \/\/        }\n        $carry = 0;\n        for ($i = 0; $i < 63; ++$i) {\n            $e[$i] += $carry;\n            $carry = $e[$i] + 8;\n            $carry >>= 4;\n            $e[$i] -= $carry << 4;\n        }\n        \/\/        e[63] += carry;\n        \/\/        \/* each e[i] is between -8 and 8 *\/\n        $e[63] += $carry;\n\n        \/\/        ge25519_p3_0(h);\n        $h = self::ge_p3_0();\n\n        \/\/        for (i = 63; i != 0; i--) {\n        for ($i = 63; $i != 0; --$i) {\n            \/\/ ge25519_cmov8_cached(&t, pi, e[i]);\n            $t = self::ge_cmov8_cached($pi, $e[$i]);\n            \/\/ ge25519_add_cached(&r, h, &t);\n            $r = self::ge_add($h, $t);\n\n            \/\/ ge25519_p1p1_to_p2(&s, &r);\n            \/\/ ge25519_p2_dbl(&r, &s);\n            \/\/ ge25519_p1p1_to_p2(&s, &r);\n            \/\/ ge25519_p2_dbl(&r, &s);\n            \/\/ ge25519_p1p1_to_p2(&s, &r);\n            \/\/ ge25519_p2_dbl(&r, &s);\n            \/\/ ge25519_p1p1_to_p2(&s, &r);\n            \/\/ ge25519_p2_dbl(&r, &s);\n            $s = self::ge_p1p1_to_p2($r);\n            $r = self::ge_p2_dbl($s);\n            $s = self::ge_p1p1_to_p2($r);\n            $r = self::ge_p2_dbl($s);\n            $s = self::ge_p1p1_to_p2($r);\n            $r = self::ge_p2_dbl($s);\n            $s = self::ge_p1p1_to_p2($r);\n            $r = self::ge_p2_dbl($s);\n\n            \/\/ ge25519_p1p1_to_p3(h, &r);  \/* *16 *\/\n            $h = self::ge_p1p1_to_p3($r); \/* *16 *\/\n        }\n\n        \/\/        ge25519_cmov8_cached(&t, pi, e[i]);\n        \/\/        ge25519_add_cached(&r, h, &t);\n        \/\/        ge25519_p1p1_to_p3(h, &r);\n        $t = self::ge_cmov8_cached($pi, $e[0]);\n        $r = self::ge_add($h, $t);\n        return self::ge_p1p1_to_p3($r);\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param string $a\n     * @return ParagonIE_Sodium_Core_Curve25519_Ge_P3\n     * @throws SodiumException\n     * @throws TypeError\n     * @psalm-suppress MixedAssignment\n     * @psalm-suppress MixedOperand\n     *\/\n    public static function ge_scalarmult_base($a)\n    {\n        \/** @var array<int, int> $e *\/\n        $e = array();\n        $r = new ParagonIE_Sodium_Core_Curve25519_Ge_P1p1();\n\n        for ($i = 0; $i < 32; ++$i) {\n            $dbl = (int) $i << 1;\n            $e[$dbl] = (int) self::chrToInt($a[$i]) & 15;\n            $e[$dbl + 1] = (int) (self::chrToInt($a[$i]) >> 4) & 15;\n        }\n\n        $carry = 0;\n        for ($i = 0; $i < 63; ++$i) {\n            $e[$i] += $carry;\n            $carry = $e[$i] + 8;\n            $carry >>= 4;\n            $e[$i] -= $carry << 4;\n        }\n        $e[63] += (int) $carry;\n\n        $h = self::ge_p3_0();\n\n        for ($i = 1; $i < 64; $i += 2) {\n            $t = self::ge_select((int) floor($i \/ 2), (int) $e[$i]);\n            $r = self::ge_madd($r, $h, $t);\n            $h = self::ge_p1p1_to_p3($r);\n        }\n\n        $r = self::ge_p3_dbl($h);\n\n        $s = self::ge_p1p1_to_p2($r);\n        $r = self::ge_p2_dbl($s);\n        $s = self::ge_p1p1_to_p2($r);\n        $r = self::ge_p2_dbl($s);\n        $s = self::ge_p1p1_to_p2($r);\n        $r = self::ge_p2_dbl($s);\n\n        $h = self::ge_p1p1_to_p3($r);\n\n        for ($i = 0; $i < 64; $i += 2) {\n            $t = self::ge_select($i >> 1, (int) $e[$i]);\n            $r = self::ge_madd($r, $h, $t);\n            $h = self::ge_p1p1_to_p3($r);\n        }\n        return $h;\n    }\n\n    \/**\n     * Calculates (ab + c) mod l\n     * where l = 2^252 + 27742317777372353535851937790883648493\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param string $a\n     * @param string $b\n     * @param string $c\n     * @return string\n     * @throws TypeError\n     *\/\n    public static function sc_muladd($a, $b, $c)\n    {\n        $a0 = 2097151 & self::load_3(self::substr($a, 0, 3));\n        $a1 = 2097151 & (self::load_4(self::substr($a, 2, 4)) >> 5);\n        $a2 = 2097151 & (self::load_3(self::substr($a, 5, 3)) >> 2);\n        $a3 = 2097151 & (self::load_4(self::substr($a, 7, 4)) >> 7);\n        $a4 = 2097151 & (self::load_4(self::substr($a, 10, 4)) >> 4);\n        $a5 = 2097151 & (self::load_3(self::substr($a, 13, 3)) >> 1);\n        $a6 = 2097151 & (self::load_4(self::substr($a, 15, 4)) >> 6);\n        $a7 = 2097151 & (self::load_3(self::substr($a, 18, 3)) >> 3);\n        $a8 = 2097151 & self::load_3(self::substr($a, 21, 3));\n        $a9 = 2097151 & (self::load_4(self::substr($a, 23, 4)) >> 5);\n        $a10 = 2097151 & (self::load_3(self::substr($a, 26, 3)) >> 2);\n        $a11 = (self::load_4(self::substr($a, 28, 4)) >> 7);\n\n        $b0 = 2097151 & self::load_3(self::substr($b, 0, 3));\n        $b1 = 2097151 & (self::load_4(self::substr($b, 2, 4)) >> 5);\n        $b2 = 2097151 & (self::load_3(self::substr($b, 5, 3)) >> 2);\n        $b3 = 2097151 & (self::load_4(self::substr($b, 7, 4)) >> 7);\n        $b4 = 2097151 & (self::load_4(self::substr($b, 10, 4)) >> 4);\n        $b5 = 2097151 & (self::load_3(self::substr($b, 13, 3)) >> 1);\n        $b6 = 2097151 & (self::load_4(self::substr($b, 15, 4)) >> 6);\n        $b7 = 2097151 & (self::load_3(self::substr($b, 18, 3)) >> 3);\n        $b8 = 2097151 & self::load_3(self::substr($b, 21, 3));\n        $b9 = 2097151 & (self::load_4(self::substr($b, 23, 4)) >> 5);\n        $b10 = 2097151 & (self::load_3(self::substr($b, 26, 3)) >> 2);\n        $b11 = (self::load_4(self::substr($b, 28, 4)) >> 7);\n\n        $c0 = 2097151 & self::load_3(self::substr($c, 0, 3));\n        $c1 = 2097151 & (self::load_4(self::substr($c, 2, 4)) >> 5);\n        $c2 = 2097151 & (self::load_3(self::substr($c, 5, 3)) >> 2);\n        $c3 = 2097151 & (self::load_4(self::substr($c, 7, 4)) >> 7);\n        $c4 = 2097151 & (self::load_4(self::substr($c, 10, 4)) >> 4);\n        $c5 = 2097151 & (self::load_3(self::substr($c, 13, 3)) >> 1);\n        $c6 = 2097151 & (self::load_4(self::substr($c, 15, 4)) >> 6);\n        $c7 = 2097151 & (self::load_3(self::substr($c, 18, 3)) >> 3);\n        $c8 = 2097151 & self::load_3(self::substr($c, 21, 3));\n        $c9 = 2097151 & (self::load_4(self::substr($c, 23, 4)) >> 5);\n        $c10 = 2097151 & (self::load_3(self::substr($c, 26, 3)) >> 2);\n        $c11 = (self::load_4(self::substr($c, 28, 4)) >> 7);\n\n        \/* Can't really avoid the pyramid here: *\/\n        $s0 = $c0 + self::mul($a0, $b0, 24);\n        $s1 = $c1 + self::mul($a0, $b1, 24) + self::mul($a1, $b0, 24);\n        $s2 = $c2 + self::mul($a0, $b2, 24) + self::mul($a1, $b1, 24) + self::mul($a2, $b0, 24);\n        $s3 = $c3 + self::mul($a0, $b3, 24) + self::mul($a1, $b2, 24) + self::mul($a2, $b1, 24) + self::mul($a3, $b0, 24);\n        $s4 = $c4 + self::mul($a0, $b4, 24) + self::mul($a1, $b3, 24) + self::mul($a2, $b2, 24) + self::mul($a3, $b1, 24) +\n               self::mul($a4, $b0, 24);\n        $s5 = $c5 + self::mul($a0, $b5, 24) + self::mul($a1, $b4, 24) + self::mul($a2, $b3, 24) + self::mul($a3, $b2, 24) +\n               self::mul($a4, $b1, 24) + self::mul($a5, $b0, 24);\n        $s6 = $c6 + self::mul($a0, $b6, 24) + self::mul($a1, $b5, 24) + self::mul($a2, $b4, 24) + self::mul($a3, $b3, 24) +\n               self::mul($a4, $b2, 24) + self::mul($a5, $b1, 24) + self::mul($a6, $b0, 24);\n        $s7 = $c7 + self::mul($a0, $b7, 24) + self::mul($a1, $b6, 24) + self::mul($a2, $b5, 24) + self::mul($a3, $b4, 24) +\n               self::mul($a4, $b3, 24) + self::mul($a5, $b2, 24) + self::mul($a6, $b1, 24) + self::mul($a7, $b0, 24);\n        $s8 = $c8 + self::mul($a0, $b8, 24) + self::mul($a1, $b7, 24) + self::mul($a2, $b6, 24) + self::mul($a3, $b5, 24) +\n               self::mul($a4, $b4, 24) + self::mul($a5, $b3, 24) + self::mul($a6, $b2, 24) + self::mul($a7, $b1, 24) +\n               self::mul($a8, $b0, 24);\n        $s9 = $c9 + self::mul($a0, $b9, 24) + self::mul($a1, $b8, 24) + self::mul($a2, $b7, 24) + self::mul($a3, $b6, 24) +\n               self::mul($a4, $b5, 24) + self::mul($a5, $b4, 24) + self::mul($a6, $b3, 24) + self::mul($a7, $b2, 24) +\n               self::mul($a8, $b1, 24) + self::mul($a9, $b0, 24);\n        $s10 = $c10 + self::mul($a0, $b10, 24) + self::mul($a1, $b9, 24) + self::mul($a2, $b8, 24) + self::mul($a3, $b7, 24) +\n               self::mul($a4, $b6, 24) + self::mul($a5, $b5, 24) + self::mul($a6, $b4, 24) + self::mul($a7, $b3, 24) +\n               self::mul($a8, $b2, 24) + self::mul($a9, $b1, 24) + self::mul($a10, $b0, 24);\n        $s11 = $c11 + self::mul($a0, $b11, 24) + self::mul($a1, $b10, 24) + self::mul($a2, $b9, 24) + self::mul($a3, $b8, 24) +\n               self::mul($a4, $b7, 24) + self::mul($a5, $b6, 24) + self::mul($a6, $b5, 24) + self::mul($a7, $b4, 24) +\n               self::mul($a8, $b3, 24) + self::mul($a9, $b2, 24) + self::mul($a10, $b1, 24) + self::mul($a11, $b0, 24);\n        $s12 = self::mul($a1, $b11, 24) + self::mul($a2, $b10, 24) + self::mul($a3, $b9, 24) + self::mul($a4, $b8, 24) +\n               self::mul($a5, $b7, 24) + self::mul($a6, $b6, 24) + self::mul($a7, $b5, 24) + self::mul($a8, $b4, 24) +\n               self::mul($a9, $b3, 24) + self::mul($a10, $b2, 24) + self::mul($a11, $b1, 24);\n        $s13 = self::mul($a2, $b11, 24) + self::mul($a3, $b10, 24) + self::mul($a4, $b9, 24) + self::mul($a5, $b8, 24) +\n               self::mul($a6, $b7, 24) + self::mul($a7, $b6, 24) + self::mul($a8, $b5, 24) + self::mul($a9, $b4, 24) +\n               self::mul($a10, $b3, 24) + self::mul($a11, $b2, 24);\n        $s14 = self::mul($a3, $b11, 24) + self::mul($a4, $b10, 24) + self::mul($a5, $b9, 24) + self::mul($a6, $b8, 24) +\n               self::mul($a7, $b7, 24) + self::mul($a8, $b6, 24) + self::mul($a9, $b5, 24) + self::mul($a10, $b4, 24) +\n               self::mul($a11, $b3, 24);\n        $s15 = self::mul($a4, $b11, 24) + self::mul($a5, $b10, 24) + self::mul($a6, $b9, 24) + self::mul($a7, $b8, 24) +\n               self::mul($a8, $b7, 24) + self::mul($a9, $b6, 24) + self::mul($a10, $b5, 24) + self::mul($a11, $b4, 24);\n        $s16 = self::mul($a5, $b11, 24) + self::mul($a6, $b10, 24) + self::mul($a7, $b9, 24) + self::mul($a8, $b8, 24) +\n               self::mul($a9, $b7, 24) + self::mul($a10, $b6, 24) + self::mul($a11, $b5, 24);\n        $s17 = self::mul($a6, $b11, 24) + self::mul($a7, $b10, 24) + self::mul($a8, $b9, 24) + self::mul($a9, $b8, 24) +\n               self::mul($a10, $b7, 24) + self::mul($a11, $b6, 24);\n        $s18 = self::mul($a7, $b11, 24) + self::mul($a8, $b10, 24) + self::mul($a9, $b9, 24) + self::mul($a10, $b8, 24) +\n               self::mul($a11, $b7, 24);\n        $s19 = self::mul($a8, $b11, 24) + self::mul($a9, $b10, 24) + self::mul($a10, $b9, 24) + self::mul($a11, $b8, 24);\n        $s20 = self::mul($a9, $b11, 24) + self::mul($a10, $b10, 24) + self::mul($a11, $b9, 24);\n        $s21 = self::mul($a10, $b11, 24) + self::mul($a11, $b10, 24);\n        $s22 = self::mul($a11, $b11, 24);\n        $s23 = 0;\n\n        $carry0 = ($s0 + (1 << 20)) >> 21;\n        $s1 += $carry0;\n        $s0 -= $carry0 << 21;\n        $carry2 = ($s2 + (1 << 20)) >> 21;\n        $s3 += $carry2;\n        $s2 -= $carry2 << 21;\n        $carry4 = ($s4 + (1 << 20)) >> 21;\n        $s5 += $carry4;\n        $s4 -= $carry4 << 21;\n        $carry6 = ($s6 + (1 << 20)) >> 21;\n        $s7 += $carry6;\n        $s6 -= $carry6 << 21;\n        $carry8 = ($s8 + (1 << 20)) >> 21;\n        $s9 += $carry8;\n        $s8 -= $carry8 << 21;\n        $carry10 = ($s10 + (1 << 20)) >> 21;\n        $s11 += $carry10;\n        $s10 -= $carry10 << 21;\n        $carry12 = ($s12 + (1 << 20)) >> 21;\n        $s13 += $carry12;\n        $s12 -= $carry12 << 21;\n        $carry14 = ($s14 + (1 << 20)) >> 21;\n        $s15 += $carry14;\n        $s14 -= $carry14 << 21;\n        $carry16 = ($s16 + (1 << 20)) >> 21;\n        $s17 += $carry16;\n        $s16 -= $carry16 << 21;\n        $carry18 = ($s18 + (1 << 20)) >> 21;\n        $s19 += $carry18;\n        $s18 -= $carry18 << 21;\n        $carry20 = ($s20 + (1 << 20)) >> 21;\n        $s21 += $carry20;\n        $s20 -= $carry20 << 21;\n        $carry22 = ($s22 + (1 << 20)) >> 21;\n        $s23 += $carry22;\n        $s22 -= $carry22 << 21;\n\n        $carry1 = ($s1 + (1 << 20)) >> 21;\n        $s2 += $carry1;\n        $s1 -= $carry1 << 21;\n        $carry3 = ($s3 + (1 << 20)) >> 21;\n        $s4 += $carry3;\n        $s3 -= $carry3 << 21;\n        $carry5 = ($s5 + (1 << 20)) >> 21;\n        $s6 += $carry5;\n        $s5 -= $carry5 << 21;\n        $carry7 = ($s7 + (1 << 20)) >> 21;\n        $s8 += $carry7;\n        $s7 -= $carry7 << 21;\n        $carry9 = ($s9 + (1 << 20)) >> 21;\n        $s10 += $carry9;\n        $s9 -= $carry9 << 21;\n        $carry11 = ($s11 + (1 << 20)) >> 21;\n        $s12 += $carry11;\n        $s11 -= $carry11 << 21;\n        $carry13 = ($s13 + (1 << 20)) >> 21;\n        $s14 += $carry13;\n        $s13 -= $carry13 << 21;\n        $carry15 = ($s15 + (1 << 20)) >> 21;\n        $s16 += $carry15;\n        $s15 -= $carry15 << 21;\n        $carry17 = ($s17 + (1 << 20)) >> 21;\n        $s18 += $carry17;\n        $s17 -= $carry17 << 21;\n        $carry19 = ($s19 + (1 << 20)) >> 21;\n        $s20 += $carry19;\n        $s19 -= $carry19 << 21;\n        $carry21 = ($s21 + (1 << 20)) >> 21;\n        $s22 += $carry21;\n        $s21 -= $carry21 << 21;\n\n        $s11 += self::mul($s23, 666643, 20);\n        $s12 += self::mul($s23, 470296, 19);\n        $s13 += self::mul($s23, 654183, 20);\n        $s14 -= self::mul($s23, 997805, 20);\n        $s15 += self::mul($s23, 136657, 18);\n        $s16 -= self::mul($s23, 683901, 20);\n\n        $s10 += self::mul($s22, 666643, 20);\n        $s11 += self::mul($s22, 470296, 19);\n        $s12 += self::mul($s22, 654183, 20);\n        $s13 -= self::mul($s22, 997805, 20);\n        $s14 += self::mul($s22, 136657, 18);\n        $s15 -= self::mul($s22, 683901, 20);\n\n        $s9  += self::mul($s21,  666643, 20);\n        $s10 += self::mul($s21,  470296, 19);\n        $s11 += self::mul($s21,  654183, 20);\n        $s12 -= self::mul($s21,  997805, 20);\n        $s13 += self::mul($s21,  136657, 18);\n        $s14 -= self::mul($s21,  683901, 20);\n\n        $s8  += self::mul($s20,  666643, 20);\n        $s9  += self::mul($s20,  470296, 19);\n        $s10 += self::mul($s20,  654183, 20);\n        $s11 -= self::mul($s20,  997805, 20);\n        $s12 += self::mul($s20,  136657, 18);\n        $s13 -= self::mul($s20,  683901, 20);\n\n        $s7  += self::mul($s19,  666643, 20);\n        $s8  += self::mul($s19,  470296, 19);\n        $s9  += self::mul($s19,  654183, 20);\n        $s10 -= self::mul($s19,  997805, 20);\n        $s11 += self::mul($s19,  136657, 18);\n        $s12 -= self::mul($s19,  683901, 20);\n\n        $s6  += self::mul($s18,  666643, 20);\n        $s7  += self::mul($s18,  470296, 19);\n        $s8  += self::mul($s18,  654183, 20);\n        $s9  -= self::mul($s18,  997805, 20);\n        $s10 += self::mul($s18,  136657, 18);\n        $s11 -= self::mul($s18,  683901, 20);\n\n        $carry6 = ($s6 + (1 << 20)) >> 21;\n        $s7 += $carry6;\n        $s6 -= $carry6 << 21;\n        $carry8 = ($s8 + (1 << 20)) >> 21;\n        $s9 += $carry8;\n        $s8 -= $carry8 << 21;\n        $carry10 = ($s10 + (1 << 20)) >> 21;\n        $s11 += $carry10;\n        $s10 -= $carry10 << 21;\n        $carry12 = ($s12 + (1 << 20)) >> 21;\n        $s13 += $carry12;\n        $s12 -= $carry12 << 21;\n        $carry14 = ($s14 + (1 << 20)) >> 21;\n        $s15 += $carry14;\n        $s14 -= $carry14 << 21;\n        $carry16 = ($s16 + (1 << 20)) >> 21;\n        $s17 += $carry16;\n        $s16 -= $carry16 << 21;\n\n        $carry7 = ($s7 + (1 << 20)) >> 21;\n        $s8 += $carry7;\n        $s7 -= $carry7 << 21;\n        $carry9 = ($s9 + (1 << 20)) >> 21;\n        $s10 += $carry9;\n        $s9 -= $carry9 << 21;\n        $carry11 = ($s11 + (1 << 20)) >> 21;\n        $s12 += $carry11;\n        $s11 -= $carry11 << 21;\n        $carry13 = ($s13 + (1 << 20)) >> 21;\n        $s14 += $carry13;\n        $s13 -= $carry13 << 21;\n        $carry15 = ($s15 + (1 << 20)) >> 21;\n        $s16 += $carry15;\n        $s15 -= $carry15 << 21;\n\n        $s5  += self::mul($s17,  666643, 20);\n        $s6  += self::mul($s17,  470296, 19);\n        $s7  += self::mul($s17,  654183, 20);\n        $s8  -= self::mul($s17,  997805, 20);\n        $s9  += self::mul($s17,  136657, 18);\n        $s10 -= self::mul($s17,  683901, 20);\n\n        $s4 += self::mul($s16,  666643, 20);\n        $s5 += self::mul($s16,  470296, 19);\n        $s6 += self::mul($s16,  654183, 20);\n        $s7 -= self::mul($s16,  997805, 20);\n        $s8 += self::mul($s16,  136657, 18);\n        $s9 -= self::mul($s16,  683901, 20);\n\n        $s3 += self::mul($s15,  666643, 20);\n        $s4 += self::mul($s15,  470296, 19);\n        $s5 += self::mul($s15,  654183, 20);\n        $s6 -= self::mul($s15,  997805, 20);\n        $s7 += self::mul($s15,  136657, 18);\n        $s8 -= self::mul($s15,  683901, 20);\n\n        $s2 += self::mul($s14,  666643, 20);\n        $s3 += self::mul($s14,  470296, 19);\n        $s4 += self::mul($s14,  654183, 20);\n        $s5 -= self::mul($s14,  997805, 20);\n        $s6 += self::mul($s14,  136657, 18);\n        $s7 -= self::mul($s14,  683901, 20);\n\n        $s1 += self::mul($s13,  666643, 20);\n        $s2 += self::mul($s13,  470296, 19);\n        $s3 += self::mul($s13,  654183, 20);\n        $s4 -= self::mul($s13,  997805, 20);\n        $s5 += self::mul($s13,  136657, 18);\n        $s6 -= self::mul($s13,  683901, 20);\n\n        $s0 += self::mul($s12,  666643, 20);\n        $s1 += self::mul($s12,  470296, 19);\n        $s2 += self::mul($s12,  654183, 20);\n        $s3 -= self::mul($s12,  997805, 20);\n        $s4 += self::mul($s12,  136657, 18);\n        $s5 -= self::mul($s12,  683901, 20);\n        $s12 = 0;\n\n        $carry0 = ($s0 + (1 << 20)) >> 21;\n        $s1 += $carry0;\n        $s0 -= $carry0 << 21;\n        $carry2 = ($s2 + (1 << 20)) >> 21;\n        $s3 += $carry2;\n        $s2 -= $carry2 << 21;\n        $carry4 = ($s4 + (1 << 20)) >> 21;\n        $s5 += $carry4;\n        $s4 -= $carry4 << 21;\n        $carry6 = ($s6 + (1 << 20)) >> 21;\n        $s7 += $carry6;\n        $s6 -= $carry6 << 21;\n        $carry8 = ($s8 + (1 << 20)) >> 21;\n        $s9 += $carry8;\n        $s8 -= $carry8 << 21;\n        $carry10 = ($s10 + (1 << 20)) >> 21;\n        $s11 += $carry10;\n        $s10 -= $carry10 << 21;\n\n        $carry1 = ($s1 + (1 << 20)) >> 21;\n        $s2 += $carry1;\n        $s1 -= $carry1 << 21;\n        $carry3 = ($s3 + (1 << 20)) >> 21;\n        $s4 += $carry3;\n        $s3 -= $carry3 << 21;\n        $carry5 = ($s5 + (1 << 20)) >> 21;\n        $s6 += $carry5;\n        $s5 -= $carry5 << 21;\n        $carry7 = ($s7 + (1 << 20)) >> 21;\n        $s8 += $carry7;\n        $s7 -= $carry7 << 21;\n        $carry9 = ($s9 + (1 << 20)) >> 21;\n        $s10 += $carry9;\n        $s9 -= $carry9 << 21;\n        $carry11 = ($s11 + (1 << 20)) >> 21;\n        $s12 += $carry11;\n        $s11 -= $carry11 << 21;\n\n        $s0 += self::mul($s12,  666643, 20);\n        $s1 += self::mul($s12,  470296, 19);\n        $s2 += self::mul($s12,  654183, 20);\n        $s3 -= self::mul($s12,  997805, 20);\n        $s4 += self::mul($s12,  136657, 18);\n        $s5 -= self::mul($s12,  683901, 20);\n        $s12 = 0;\n\n        $carry0 = $s0 >> 21;\n        $s1 += $carry0;\n        $s0 -= $carry0 << 21;\n        $carry1 = $s1 >> 21;\n        $s2 += $carry1;\n        $s1 -= $carry1 << 21;\n        $carry2 = $s2 >> 21;\n        $s3 += $carry2;\n        $s2 -= $carry2 << 21;\n        $carry3 = $s3 >> 21;\n        $s4 += $carry3;\n        $s3 -= $carry3 << 21;\n        $carry4 = $s4 >> 21;\n        $s5 += $carry4;\n        $s4 -= $carry4 << 21;\n        $carry5 = $s5 >> 21;\n        $s6 += $carry5;\n        $s5 -= $carry5 << 21;\n        $carry6 = $s6 >> 21;\n        $s7 += $carry6;\n        $s6 -= $carry6 << 21;\n        $carry7 = $s7 >> 21;\n        $s8 += $carry7;\n        $s7 -= $carry7 << 21;\n        $carry8 = $s8 >> 21;\n        $s9 += $carry8;\n        $s8 -= $carry8 << 21;\n        $carry9 = $s9 >> 21;\n        $s10 += $carry9;\n        $s9 -= $carry9 << 21;\n        $carry10 = $s10 >> 21;\n        $s11 += $carry10;\n        $s10 -= $carry10 << 21;\n        $carry11 = $s11 >> 21;\n        $s12 += $carry11;\n        $s11 -= $carry11 << 21;\n\n        $s0 += self::mul($s12,  666643, 20);\n        $s1 += self::mul($s12,  470296, 19);\n        $s2 += self::mul($s12,  654183, 20);\n        $s3 -= self::mul($s12,  997805, 20);\n        $s4 += self::mul($s12,  136657, 18);\n        $s5 -= self::mul($s12,  683901, 20);\n\n        $carry0 = $s0 >> 21;\n        $s1 += $carry0;\n        $s0 -= $carry0 << 21;\n        $carry1 = $s1 >> 21;\n        $s2 += $carry1;\n        $s1 -= $carry1 << 21;\n        $carry2 = $s2 >> 21;\n        $s3 += $carry2;\n        $s2 -= $carry2 << 21;\n        $carry3 = $s3 >> 21;\n        $s4 += $carry3;\n        $s3 -= $carry3 << 21;\n        $carry4 = $s4 >> 21;\n        $s5 += $carry4;\n        $s4 -= $carry4 << 21;\n        $carry5 = $s5 >> 21;\n        $s6 += $carry5;\n        $s5 -= $carry5 << 21;\n        $carry6 = $s6 >> 21;\n        $s7 += $carry6;\n        $s6 -= $carry6 << 21;\n        $carry7 = $s7 >> 21;\n        $s8 += $carry7;\n        $s7 -= $carry7 << 21;\n        $carry8 = $s8 >> 21;\n        $s9 += $carry8;\n        $s8 -= $carry8 << 21;\n        $carry9 = $s9 >> 21;\n        $s10 += $carry9;\n        $s9 -= $carry9 << 21;\n        $carry10 = $s10 >> 21;\n        $s11 += $carry10;\n        $s10 -= $carry10 << 21;\n\n        \/**\n         * @var array<int, int>\n         *\/\n        $arr = array(\n            (int) (0xff & ($s0 >> 0)),\n            (int) (0xff & ($s0 >> 8)),\n            (int) (0xff & (($s0 >> 16) | $s1 << 5)),\n            (int) (0xff & ($s1 >> 3)),\n            (int) (0xff & ($s1 >> 11)),\n            (int) (0xff & (($s1 >> 19) | $s2 << 2)),\n            (int) (0xff & ($s2 >> 6)),\n            (int) (0xff & (($s2 >> 14) | $s3 << 7)),\n            (int) (0xff & ($s3 >> 1)),\n            (int) (0xff & ($s3 >> 9)),\n            (int) (0xff & (($s3 >> 17) | $s4 << 4)),\n            (int) (0xff & ($s4 >> 4)),\n            (int) (0xff & ($s4 >> 12)),\n            (int) (0xff & (($s4 >> 20) | $s5 << 1)),\n            (int) (0xff & ($s5 >> 7)),\n            (int) (0xff & (($s5 >> 15) | $s6 << 6)),\n            (int) (0xff & ($s6 >> 2)),\n            (int) (0xff & ($s6 >> 10)),\n            (int) (0xff & (($s6 >> 18) | $s7 << 3)),\n            (int) (0xff & ($s7 >> 5)),\n            (int) (0xff & ($s7 >> 13)),\n            (int) (0xff & ($s8 >> 0)),\n            (int) (0xff & ($s8 >> 8)),\n            (int) (0xff & (($s8 >> 16) | $s9 << 5)),\n            (int) (0xff & ($s9 >> 3)),\n            (int) (0xff & ($s9 >> 11)),\n            (int) (0xff & (($s9 >> 19) | $s10 << 2)),\n            (int) (0xff & ($s10 >> 6)),\n            (int) (0xff & (($s10 >> 14) | $s11 << 7)),\n            (int) (0xff & ($s11 >> 1)),\n            (int) (0xff & ($s11 >> 9)),\n            0xff & ($s11 >> 17)\n        );\n        return self::intArrayToString($arr);\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param string $s\n     * @return string\n     * @throws TypeError\n     *\/\n    public static function sc_reduce($s)\n    {\n        $s0 = 2097151 & self::load_3(self::substr($s, 0, 3));\n        $s1 = 2097151 & (self::load_4(self::substr($s, 2, 4)) >> 5);\n        $s2 = 2097151 & (self::load_3(self::substr($s, 5, 3)) >> 2);\n        $s3 = 2097151 & (self::load_4(self::substr($s, 7, 4)) >> 7);\n        $s4 = 2097151 & (self::load_4(self::substr($s, 10, 4)) >> 4);\n        $s5 = 2097151 & (self::load_3(self::substr($s, 13, 3)) >> 1);\n        $s6 = 2097151 & (self::load_4(self::substr($s, 15, 4)) >> 6);\n        $s7 = 2097151 & (self::load_3(self::substr($s, 18, 4)) >> 3);\n        $s8 = 2097151 & self::load_3(self::substr($s, 21, 3));\n        $s9 = 2097151 & (self::load_4(self::substr($s, 23, 4)) >> 5);\n        $s10 = 2097151 & (self::load_3(self::substr($s, 26, 3)) >> 2);\n        $s11 = 2097151 & (self::load_4(self::substr($s, 28, 4)) >> 7);\n        $s12 = 2097151 & (self::load_4(self::substr($s, 31, 4)) >> 4);\n        $s13 = 2097151 & (self::load_3(self::substr($s, 34, 3)) >> 1);\n        $s14 = 2097151 & (self::load_4(self::substr($s, 36, 4)) >> 6);\n        $s15 = 2097151 & (self::load_3(self::substr($s, 39, 4)) >> 3);\n        $s16 = 2097151 & self::load_3(self::substr($s, 42, 3));\n        $s17 = 2097151 & (self::load_4(self::substr($s, 44, 4)) >> 5);\n        $s18 = 2097151 & (self::load_3(self::substr($s, 47, 3)) >> 2);\n        $s19 = 2097151 & (self::load_4(self::substr($s, 49, 4)) >> 7);\n        $s20 = 2097151 & (self::load_4(self::substr($s, 52, 4)) >> 4);\n        $s21 = 2097151 & (self::load_3(self::substr($s, 55, 3)) >> 1);\n        $s22 = 2097151 & (self::load_4(self::substr($s, 57, 4)) >> 6);\n        $s23 = 0x1fffffff & (self::load_4(self::substr($s, 60, 4)) >> 3);\n\n        $s11 += self::mul($s23,  666643, 20);\n        $s12 += self::mul($s23,  470296, 19);\n        $s13 += self::mul($s23,  654183, 20);\n        $s14 -= self::mul($s23,  997805, 20);\n        $s15 += self::mul($s23,  136657, 18);\n        $s16 -= self::mul($s23,  683901, 20);\n\n        $s10 += self::mul($s22,  666643, 20);\n        $s11 += self::mul($s22,  470296, 19);\n        $s12 += self::mul($s22,  654183, 20);\n        $s13 -= self::mul($s22,  997805, 20);\n        $s14 += self::mul($s22,  136657, 18);\n        $s15 -= self::mul($s22,  683901, 20);\n\n        $s9  += self::mul($s21,  666643, 20);\n        $s10 += self::mul($s21,  470296, 19);\n        $s11 += self::mul($s21,  654183, 20);\n        $s12 -= self::mul($s21,  997805, 20);\n        $s13 += self::mul($s21,  136657, 18);\n        $s14 -= self::mul($s21,  683901, 20);\n\n        $s8  += self::mul($s20,  666643, 20);\n        $s9  += self::mul($s20,  470296, 19);\n        $s10 += self::mul($s20,  654183, 20);\n        $s11 -= self::mul($s20,  997805, 20);\n        $s12 += self::mul($s20,  136657, 18);\n        $s13 -= self::mul($s20,  683901, 20);\n\n        $s7  += self::mul($s19,  666643, 20);\n        $s8  += self::mul($s19,  470296, 19);\n        $s9  += self::mul($s19,  654183, 20);\n        $s10 -= self::mul($s19,  997805, 20);\n        $s11 += self::mul($s19,  136657, 18);\n        $s12 -= self::mul($s19,  683901, 20);\n\n        $s6  += self::mul($s18,  666643, 20);\n        $s7  += self::mul($s18,  470296, 19);\n        $s8  += self::mul($s18,  654183, 20);\n        $s9  -= self::mul($s18,  997805, 20);\n        $s10 += self::mul($s18,  136657, 18);\n        $s11 -= self::mul($s18,  683901, 20);\n\n        $carry6 = ($s6 + (1 << 20)) >> 21;\n        $s7 += $carry6;\n        $s6 -= $carry6 << 21;\n        $carry8 = ($s8 + (1 << 20)) >> 21;\n        $s9 += $carry8;\n        $s8 -= $carry8 << 21;\n        $carry10 = ($s10 + (1 << 20)) >> 21;\n        $s11 += $carry10;\n        $s10 -= $carry10 << 21;\n        $carry12 = ($s12 + (1 << 20)) >> 21;\n        $s13 += $carry12;\n        $s12 -= $carry12 << 21;\n        $carry14 = ($s14 + (1 << 20)) >> 21;\n        $s15 += $carry14;\n        $s14 -= $carry14 << 21;\n        $carry16 = ($s16 + (1 << 20)) >> 21;\n        $s17 += $carry16;\n        $s16 -= $carry16 << 21;\n\n        $carry7 = ($s7 + (1 << 20)) >> 21;\n        $s8 += $carry7;\n        $s7 -= $carry7 << 21;\n        $carry9 = ($s9 + (1 << 20)) >> 21;\n        $s10 += $carry9;\n        $s9 -= $carry9 << 21;\n        $carry11 = ($s11 + (1 << 20)) >> 21;\n        $s12 += $carry11;\n        $s11 -= $carry11 << 21;\n        $carry13 = ($s13 + (1 << 20)) >> 21;\n        $s14 += $carry13;\n        $s13 -= $carry13 << 21;\n        $carry15 = ($s15 + (1 << 20)) >> 21;\n        $s16 += $carry15;\n        $s15 -= $carry15 << 21;\n\n        $s5  += self::mul($s17,  666643, 20);\n        $s6  += self::mul($s17,  470296, 19);\n        $s7  += self::mul($s17,  654183, 20);\n        $s8  -= self::mul($s17,  997805, 20);\n        $s9  += self::mul($s17,  136657, 18);\n        $s10 -= self::mul($s17,  683901, 20);\n\n        $s4 += self::mul($s16,  666643, 20);\n        $s5 += self::mul($s16,  470296, 19);\n        $s6 += self::mul($s16,  654183, 20);\n        $s7 -= self::mul($s16,  997805, 20);\n        $s8 += self::mul($s16,  136657, 18);\n        $s9 -= self::mul($s16,  683901, 20);\n\n        $s3 += self::mul($s15,  666643, 20);\n        $s4 += self::mul($s15,  470296, 19);\n        $s5 += self::mul($s15,  654183, 20);\n        $s6 -= self::mul($s15,  997805, 20);\n        $s7 += self::mul($s15,  136657, 18);\n        $s8 -= self::mul($s15,  683901, 20);\n\n        $s2 += self::mul($s14,  666643, 20);\n        $s3 += self::mul($s14,  470296, 19);\n        $s4 += self::mul($s14,  654183, 20);\n        $s5 -= self::mul($s14,  997805, 20);\n        $s6 += self::mul($s14,  136657, 18);\n        $s7 -= self::mul($s14,  683901, 20);\n\n        $s1 += self::mul($s13,  666643, 20);\n        $s2 += self::mul($s13,  470296, 19);\n        $s3 += self::mul($s13,  654183, 20);\n        $s4 -= self::mul($s13,  997805, 20);\n        $s5 += self::mul($s13,  136657, 18);\n        $s6 -= self::mul($s13,  683901, 20);\n\n        $s0 += self::mul($s12,  666643, 20);\n        $s1 += self::mul($s12,  470296, 19);\n        $s2 += self::mul($s12,  654183, 20);\n        $s3 -= self::mul($s12,  997805, 20);\n        $s4 += self::mul($s12,  136657, 18);\n        $s5 -= self::mul($s12,  683901, 20);\n        $s12 = 0;\n\n        $carry0 = ($s0 + (1 << 20)) >> 21;\n        $s1 += $carry0;\n        $s0 -= $carry0 << 21;\n        $carry2 = ($s2 + (1 << 20)) >> 21;\n        $s3 += $carry2;\n        $s2 -= $carry2 << 21;\n        $carry4 = ($s4 + (1 << 20)) >> 21;\n        $s5 += $carry4;\n        $s4 -= $carry4 << 21;\n        $carry6 = ($s6 + (1 << 20)) >> 21;\n        $s7 += $carry6;\n        $s6 -= $carry6 << 21;\n        $carry8 = ($s8 + (1 << 20)) >> 21;\n        $s9 += $carry8;\n        $s8 -= $carry8 << 21;\n        $carry10 = ($s10 + (1 << 20)) >> 21;\n        $s11 += $carry10;\n        $s10 -= $carry10 << 21;\n\n        $carry1 = ($s1 + (1 << 20)) >> 21;\n        $s2 += $carry1;\n        $s1 -= $carry1 << 21;\n        $carry3 = ($s3 + (1 << 20)) >> 21;\n        $s4 += $carry3;\n        $s3 -= $carry3 << 21;\n        $carry5 = ($s5 + (1 << 20)) >> 21;\n        $s6 += $carry5;\n        $s5 -= $carry5 << 21;\n        $carry7 = ($s7 + (1 << 20)) >> 21;\n        $s8 += $carry7;\n        $s7 -= $carry7 << 21;\n        $carry9 = ($s9 + (1 << 20)) >> 21;\n        $s10 += $carry9;\n        $s9 -= $carry9 << 21;\n        $carry11 = ($s11 + (1 << 20)) >> 21;\n        $s12 += $carry11;\n        $s11 -= $carry11 << 21;\n\n        $s0 += self::mul($s12,  666643, 20);\n        $s1 += self::mul($s12,  470296, 19);\n        $s2 += self::mul($s12,  654183, 20);\n        $s3 -= self::mul($s12,  997805, 20);\n        $s4 += self::mul($s12,  136657, 18);\n        $s5 -= self::mul($s12,  683901, 20);\n        $s12 = 0;\n\n        $carry0 = $s0 >> 21;\n        $s1 += $carry0;\n        $s0 -= $carry0 << 21;\n        $carry1 = $s1 >> 21;\n        $s2 += $carry1;\n        $s1 -= $carry1 << 21;\n        $carry2 = $s2 >> 21;\n        $s3 += $carry2;\n        $s2 -= $carry2 << 21;\n        $carry3 = $s3 >> 21;\n        $s4 += $carry3;\n        $s3 -= $carry3 << 21;\n        $carry4 = $s4 >> 21;\n        $s5 += $carry4;\n        $s4 -= $carry4 << 21;\n        $carry5 = $s5 >> 21;\n        $s6 += $carry5;\n        $s5 -= $carry5 << 21;\n        $carry6 = $s6 >> 21;\n        $s7 += $carry6;\n        $s6 -= $carry6 << 21;\n        $carry7 = $s7 >> 21;\n        $s8 += $carry7;\n        $s7 -= $carry7 << 21;\n        $carry8 = $s8 >> 21;\n        $s9 += $carry8;\n        $s8 -= $carry8 << 21;\n        $carry9 = $s9 >> 21;\n        $s10 += $carry9;\n        $s9 -= $carry9 << 21;\n        $carry10 = $s10 >> 21;\n        $s11 += $carry10;\n        $s10 -= $carry10 << 21;\n        $carry11 = $s11 >> 21;\n        $s12 += $carry11;\n        $s11 -= $carry11 << 21;\n\n        $s0 += self::mul($s12,  666643, 20);\n        $s1 += self::mul($s12,  470296, 19);\n        $s2 += self::mul($s12,  654183, 20);\n        $s3 -= self::mul($s12,  997805, 20);\n        $s4 += self::mul($s12,  136657, 18);\n        $s5 -= self::mul($s12,  683901, 20);\n\n        $carry0 = $s0 >> 21;\n        $s1 += $carry0;\n        $s0 -= $carry0 << 21;\n        $carry1 = $s1 >> 21;\n        $s2 += $carry1;\n        $s1 -= $carry1 << 21;\n        $carry2 = $s2 >> 21;\n        $s3 += $carry2;\n        $s2 -= $carry2 << 21;\n        $carry3 = $s3 >> 21;\n        $s4 += $carry3;\n        $s3 -= $carry3 << 21;\n        $carry4 = $s4 >> 21;\n        $s5 += $carry4;\n        $s4 -= $carry4 << 21;\n        $carry5 = $s5 >> 21;\n        $s6 += $carry5;\n        $s5 -= $carry5 << 21;\n        $carry6 = $s6 >> 21;\n        $s7 += $carry6;\n        $s6 -= $carry6 << 21;\n        $carry7 = $s7 >> 21;\n        $s8 += $carry7;\n        $s7 -= $carry7 << 21;\n        $carry8 = $s8 >> 21;\n        $s9 += $carry8;\n        $s8 -= $carry8 << 21;\n        $carry9 = $s9 >> 21;\n        $s10 += $carry9;\n        $s9 -= $carry9 << 21;\n        $carry10 = $s10 >> 21;\n        $s11 += $carry10;\n        $s10 -= $carry10 << 21;\n\n        \/**\n         * @var array<int, int>\n         *\/\n        $arr = array(\n            (int) ($s0 >> 0),\n            (int) ($s0 >> 8),\n            (int) (($s0 >> 16) | $s1 << 5),\n            (int) ($s1 >> 3),\n            (int) ($s1 >> 11),\n            (int) (($s1 >> 19) | $s2 << 2),\n            (int) ($s2 >> 6),\n            (int) (($s2 >> 14) | $s3 << 7),\n            (int) ($s3 >> 1),\n            (int) ($s3 >> 9),\n            (int) (($s3 >> 17) | $s4 << 4),\n            (int) ($s4 >> 4),\n            (int) ($s4 >> 12),\n            (int) (($s4 >> 20) | $s5 << 1),\n            (int) ($s5 >> 7),\n            (int) (($s5 >> 15) | $s6 << 6),\n            (int) ($s6 >> 2),\n            (int) ($s6 >> 10),\n            (int) (($s6 >> 18) | $s7 << 3),\n            (int) ($s7 >> 5),\n            (int) ($s7 >> 13),\n            (int) ($s8 >> 0),\n            (int) ($s8 >> 8),\n            (int) (($s8 >> 16) | $s9 << 5),\n            (int) ($s9 >> 3),\n            (int) ($s9 >> 11),\n            (int) (($s9 >> 19) | $s10 << 2),\n            (int) ($s10 >> 6),\n            (int) (($s10 >> 14) | $s11 << 7),\n            (int) ($s11 >> 1),\n            (int) ($s11 >> 9),\n            (int) $s11 >> 17\n        );\n        return self::intArrayToString($arr);\n    }\n\n    \/**\n     * multiply by the order of the main subgroup l = 2^252+27742317777372353535851937790883648493\n     *\n     * @param ParagonIE_Sodium_Core_Curve25519_Ge_P3 $A\n     * @return ParagonIE_Sodium_Core_Curve25519_Ge_P3\n     *\/\n    public static function ge_mul_l(ParagonIE_Sodium_Core_Curve25519_Ge_P3 $A)\n    {\n        $aslide = array(\n            13, 0, 0, 0, 0, -1, 0, 0, 0, 0, -11, 0, 0, 0, 0, 0, 0, -5, 0, 0, 0,\n            0, 0, 0, -3, 0, 0, 0, 0, -13, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 3, 0,\n            0, 0, 0, -13, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0,\n            0, 0, 11, 0, 0, 0, 0, -13, 0, 0, 0, 0, 0, 0, -3, 0, 0, 0, 0, 0, -1,\n            0, 0, 0, 0, 3, 0, 0, 0, 0, -11, 0, 0, 0, 0, 0, 0, 0, 15, 0, 0, 0,\n            0, 0, -1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 5, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1\n        );\n\n        \/** @var array<int, ParagonIE_Sodium_Core_Curve25519_Ge_Cached> $Ai size 8 *\/\n        $Ai = array();\n\n        # ge_p3_to_cached(&Ai[0], A);\n        $Ai[0] = self::ge_p3_to_cached($A);\n        # ge_p3_dbl(&t, A);\n        $t = self::ge_p3_dbl($A);\n        # ge_p1p1_to_p3(&A2, &t);\n        $A2 = self::ge_p1p1_to_p3($t);\n\n        for ($i = 1; $i < 8; ++$i) {\n            # ge_add(&t, &A2, &Ai[0]);\n            $t = self::ge_add($A2, $Ai[$i - 1]);\n            # ge_p1p1_to_p3(&u, &t);\n            $u = self::ge_p1p1_to_p3($t);\n            # ge_p3_to_cached(&Ai[i], &u);\n            $Ai[$i] = self::ge_p3_to_cached($u);\n        }\n\n        $r = self::ge_p3_0();\n        for ($i = 252; $i >= 0; --$i) {\n            $t = self::ge_p3_dbl($r);\n            if ($aslide[$i] > 0) {\n                # ge_p1p1_to_p3(&u, &t);\n                $u = self::ge_p1p1_to_p3($t);\n                # ge_add(&t, &u, &Ai[aslide[i] \/ 2]);\n                $t = self::ge_add($u, $Ai[(int)($aslide[$i] \/ 2)]);\n            } elseif ($aslide[$i] < 0) {\n                # ge_p1p1_to_p3(&u, &t);\n                $u = self::ge_p1p1_to_p3($t);\n                # ge_sub(&t, &u, &Ai[(-aslide[i]) \/ 2]);\n                $t = self::ge_sub($u, $Ai[(int)(-$aslide[$i] \/ 2)]);\n            }\n        }\n\n        # ge_p1p1_to_p3(r, &t);\n        return self::ge_p1p1_to_p3($t);\n    }\n\n    \/**\n     * @param string $a\n     * @param string $b\n     * @return string\n     *\/\n    public static function sc25519_mul($a, $b)\n    {\n        \/\/    int64_t a0  = 2097151 & load_3(a);\n        \/\/    int64_t a1  = 2097151 & (load_4(a + 2) >> 5);\n        \/\/    int64_t a2  = 2097151 & (load_3(a + 5) >> 2);\n        \/\/    int64_t a3  = 2097151 & (load_4(a + 7) >> 7);\n        \/\/    int64_t a4  = 2097151 & (load_4(a + 10) >> 4);\n        \/\/    int64_t a5  = 2097151 & (load_3(a + 13) >> 1);\n        \/\/    int64_t a6  = 2097151 & (load_4(a + 15) >> 6);\n        \/\/    int64_t a7  = 2097151 & (load_3(a + 18) >> 3);\n        \/\/    int64_t a8  = 2097151 & load_3(a + 21);\n        \/\/    int64_t a9  = 2097151 & (load_4(a + 23) >> 5);\n        \/\/    int64_t a10 = 2097151 & (load_3(a + 26) >> 2);\n        \/\/    int64_t a11 = (load_4(a + 28) >> 7);\n        $a0  = 2097151 &  self::load_3(self::substr($a, 0, 3));\n        $a1  = 2097151 & (self::load_4(self::substr($a, 2, 4)) >> 5);\n        $a2  = 2097151 & (self::load_3(self::substr($a, 5, 3)) >> 2);\n        $a3  = 2097151 & (self::load_4(self::substr($a, 7, 4)) >> 7);\n        $a4  = 2097151 & (self::load_4(self::substr($a, 10, 4)) >> 4);\n        $a5  = 2097151 & (self::load_3(self::substr($a, 13, 3)) >> 1);\n        $a6  = 2097151 & (self::load_4(self::substr($a, 15, 4)) >> 6);\n        $a7  = 2097151 & (self::load_3(self::substr($a, 18, 3)) >> 3);\n        $a8  = 2097151 &  self::load_3(self::substr($a, 21, 3));\n        $a9  = 2097151 & (self::load_4(self::substr($a, 23, 4)) >> 5);\n        $a10 = 2097151 & (self::load_3(self::substr($a, 26, 3)) >> 2);\n        $a11 = (self::load_4(self::substr($a, 28, 4)) >> 7);\n\n        \/\/    int64_t b0  = 2097151 & load_3(b);\n        \/\/    int64_t b1  = 2097151 & (load_4(b + 2) >> 5);\n        \/\/    int64_t b2  = 2097151 & (load_3(b + 5) >> 2);\n        \/\/    int64_t b3  = 2097151 & (load_4(b + 7) >> 7);\n        \/\/    int64_t b4  = 2097151 & (load_4(b + 10) >> 4);\n        \/\/    int64_t b5  = 2097151 & (load_3(b + 13) >> 1);\n        \/\/    int64_t b6  = 2097151 & (load_4(b + 15) >> 6);\n        \/\/    int64_t b7  = 2097151 & (load_3(b + 18) >> 3);\n        \/\/    int64_t b8  = 2097151 & load_3(b + 21);\n        \/\/    int64_t b9  = 2097151 & (load_4(b + 23) >> 5);\n        \/\/    int64_t b10 = 2097151 & (load_3(b + 26) >> 2);\n        \/\/    int64_t b11 = (load_4(b + 28) >> 7);\n        $b0  = 2097151 &  self::load_3(self::substr($b, 0, 3));\n        $b1  = 2097151 & (self::load_4(self::substr($b, 2, 4)) >> 5);\n        $b2  = 2097151 & (self::load_3(self::substr($b, 5, 3)) >> 2);\n        $b3  = 2097151 & (self::load_4(self::substr($b, 7, 4)) >> 7);\n        $b4  = 2097151 & (self::load_4(self::substr($b, 10, 4)) >> 4);\n        $b5  = 2097151 & (self::load_3(self::substr($b, 13, 3)) >> 1);\n        $b6  = 2097151 & (self::load_4(self::substr($b, 15, 4)) >> 6);\n        $b7  = 2097151 & (self::load_3(self::substr($b, 18, 3)) >> 3);\n        $b8  = 2097151 &  self::load_3(self::substr($b, 21, 3));\n        $b9  = 2097151 & (self::load_4(self::substr($b, 23, 4)) >> 5);\n        $b10 = 2097151 & (self::load_3(self::substr($b, 26, 3)) >> 2);\n        $b11 = (self::load_4(self::substr($b, 28, 4)) >> 7);\n\n        \/\/    s0 = a0 * b0;\n        \/\/    s1 = a0 * b1 + a1 * b0;\n        \/\/    s2 = a0 * b2 + a1 * b1 + a2 * b0;\n        \/\/    s3 = a0 * b3 + a1 * b2 + a2 * b1 + a3 * b0;\n        \/\/    s4 = a0 * b4 + a1 * b3 + a2 * b2 + a3 * b1 + a4 * b0;\n        \/\/    s5 = a0 * b5 + a1 * b4 + a2 * b3 + a3 * b2 + a4 * b1 + a5 * b0;\n        \/\/    s6 = a0 * b6 + a1 * b5 + a2 * b4 + a3 * b3 + a4 * b2 + a5 * b1 + a6 * b0;\n        \/\/    s7 = a0 * b7 + a1 * b6 + a2 * b5 + a3 * b4 + a4 * b3 + a5 * b2 +\n        \/\/        a6 * b1 + a7 * b0;\n        \/\/    s8 = a0 * b8 + a1 * b7 + a2 * b6 + a3 * b5 + a4 * b4 + a5 * b3 +\n        \/\/        a6 * b2 + a7 * b1 + a8 * b0;\n        \/\/    s9 = a0 * b9 + a1 * b8 + a2 * b7 + a3 * b6 + a4 * b5 + a5 * b4 +\n        \/\/        a6 * b3 + a7 * b2 + a8 * b1 + a9 * b0;\n        \/\/    s10 = a0 * b10 + a1 * b9 + a2 * b8 + a3 * b7 + a4 * b6 + a5 * b5 +\n        \/\/        a6 * b4 + a7 * b3 + a8 * b2 + a9 * b1 + a10 * b0;\n        \/\/    s11 = a0 * b11 + a1 * b10 + a2 * b9 + a3 * b8 + a4 * b7 + a5 * b6 +\n        \/\/        a6 * b5 + a7 * b4 + a8 * b3 + a9 * b2 + a10 * b1 + a11 * b0;\n        \/\/    s12 = a1 * b11 + a2 * b10 + a3 * b9 + a4 * b8 + a5 * b7 + a6 * b6 +\n        \/\/        a7 * b5 + a8 * b4 + a9 * b3 + a10 * b2 + a11 * b1;\n        \/\/    s13 = a2 * b11 + a3 * b10 + a4 * b9 + a5 * b8 + a6 * b7 + a7 * b6 +\n        \/\/        a8 * b5 + a9 * b4 + a10 * b3 + a11 * b2;\n        \/\/    s14 = a3 * b11 + a4 * b10 + a5 * b9 + a6 * b8 + a7 * b7 + a8 * b6 +\n        \/\/        a9 * b5 + a10 * b4 + a11 * b3;\n        \/\/    s15 = a4 * b11 + a5 * b10 + a6 * b9 + a7 * b8 + a8 * b7 + a9 * b6 +\n        \/\/        a10 * b5 + a11 * b4;\n        \/\/    s16 =\n        \/\/        a5 * b11 + a6 * b10 + a7 * b9 + a8 * b8 + a9 * b7 + a10 * b6 + a11 * b5;\n        \/\/    s17 = a6 * b11 + a7 * b10 + a8 * b9 + a9 * b8 + a10 * b7 + a11 * b6;\n        \/\/    s18 = a7 * b11 + a8 * b10 + a9 * b9 + a10 * b8 + a11 * b7;\n        \/\/    s19 = a8 * b11 + a9 * b10 + a10 * b9 + a11 * b8;\n        \/\/    s20 = a9 * b11 + a10 * b10 + a11 * b9;\n        \/\/    s21 = a10 * b11 + a11 * b10;\n        \/\/    s22 = a11 * b11;\n        \/\/    s23 = 0;\n        $s0 = self::mul($a0, $b0, 22);\n        $s1 = self::mul($a0, $b1, 22) + self::mul($a1, $b0, 22);\n        $s2 = self::mul($a0, $b2, 22) + self::mul($a1, $b1, 22) + self::mul($a2, $b0, 22);\n        $s3 = self::mul($a0, $b3, 22) + self::mul($a1, $b2, 22) + self::mul($a2, $b1, 22) + self::mul($a3, $b0, 22);\n        $s4 = self::mul($a0, $b4, 22) + self::mul($a1, $b3, 22) + self::mul($a2, $b2, 22) + self::mul($a3, $b1, 22) +\n            self::mul($a4, $b0, 22);\n        $s5 = self::mul($a0, $b5, 22) + self::mul($a1, $b4, 22) + self::mul($a2, $b3, 22) + self::mul($a3, $b2, 22) +\n            self::mul($a4, $b1, 22) + self::mul($a5, $b0, 22);\n        $s6 = self::mul($a0, $b6, 22) + self::mul($a1, $b5, 22) + self::mul($a2, $b4, 22) + self::mul($a3, $b3, 22) +\n            self::mul($a4, $b2, 22) + self::mul($a5, $b1, 22) + self::mul($a6, $b0, 22);\n        $s7 = self::mul($a0, $b7, 22) + self::mul($a1, $b6, 22) + self::mul($a2, $b5, 22) + self::mul($a3, $b4, 22) +\n            self::mul($a4, $b3, 22) + self::mul($a5, $b2, 22) + self::mul($a6, $b1, 22) + self::mul($a7, $b0, 22);\n        $s8 = self::mul($a0, $b8, 22) + self::mul($a1, $b7, 22) + self::mul($a2, $b6, 22) + self::mul($a3, $b5, 22) +\n            self::mul($a4, $b4, 22) + self::mul($a5, $b3, 22) + self::mul($a6, $b2, 22) + self::mul($a7, $b1, 22) +\n            self::mul($a8, $b0, 22);\n        $s9 = self::mul($a0, $b9, 22) + self::mul($a1, $b8, 22) + self::mul($a2, $b7, 22) + self::mul($a3, $b6, 22) +\n            self::mul($a4, $b5, 22) + self::mul($a5, $b4, 22) + self::mul($a6, $b3, 22) + self::mul($a7, $b2, 22) +\n            self::mul($a8, $b1, 22) + self::mul($a9, $b0, 22);\n        $s10 = self::mul($a0, $b10, 22) + self::mul($a1, $b9, 22) + self::mul($a2, $b8, 22) + self::mul($a3, $b7, 22) +\n            self::mul($a4, $b6, 22) + self::mul($a5, $b5, 22) + self::mul($a6, $b4, 22) + self::mul($a7, $b3, 22) +\n            self::mul($a8, $b2, 22) + self::mul($a9, $b1, 22) + self::mul($a10, $b0, 22);\n        $s11 = self::mul($a0, $b11, 22) + self::mul($a1, $b10, 22) + self::mul($a2, $b9, 22) + self::mul($a3, $b8, 22) +\n            self::mul($a4, $b7, 22) + self::mul($a5, $b6, 22) + self::mul($a6, $b5, 22) + self::mul($a7, $b4, 22) +\n            self::mul($a8, $b3, 22) + self::mul($a9, $b2, 22) + self::mul($a10, $b1, 22) + self::mul($a11, $b0, 22);\n        $s12 = self::mul($a1, $b11, 22) + self::mul($a2, $b10, 22) + self::mul($a3, $b9, 22) + self::mul($a4, $b8, 22) +\n            self::mul($a5, $b7, 22) + self::mul($a6, $b6, 22) + self::mul($a7, $b5, 22) + self::mul($a8, $b4, 22) +\n            self::mul($a9, $b3, 22) + self::mul($a10, $b2, 22) + self::mul($a11, $b1, 22);\n        $s13 = self::mul($a2, $b11, 22) + self::mul($a3, $b10, 22) + self::mul($a4, $b9, 22) + self::mul($a5, $b8, 22) +\n            self::mul($a6, $b7, 22) + self::mul($a7, $b6, 22) + self::mul($a8, $b5, 22) + self::mul($a9, $b4, 22) +\n            self::mul($a10, $b3, 22) + self::mul($a11, $b2, 22);\n        $s14 = self::mul($a3, $b11, 22) + self::mul($a4, $b10, 22) + self::mul($a5, $b9, 22) + self::mul($a6, $b8, 22) +\n            self::mul($a7, $b7, 22) + self::mul($a8, $b6, 22) + self::mul($a9, $b5, 22) + self::mul($a10, $b4, 22) +\n            self::mul($a11, $b3, 22);\n        $s15 = self::mul($a4, $b11, 22) + self::mul($a5, $b10, 22) + self::mul($a6, $b9, 22) + self::mul($a7, $b8, 22) +\n            self::mul($a8, $b7, 22) + self::mul($a9, $b6, 22) + self::mul($a10, $b5, 22) + self::mul($a11, $b4, 22);\n        $s16 =\n            self::mul($a5, $b11, 22) + self::mul($a6, $b10, 22) + self::mul($a7, $b9, 22) + self::mul($a8, $b8, 22) +\n            self::mul($a9, $b7, 22) + self::mul($a10, $b6, 22) + self::mul($a11, $b5, 22);\n        $s17 = self::mul($a6, $b11, 22) + self::mul($a7, $b10, 22) + self::mul($a8, $b9, 22) + self::mul($a9, $b8, 22) +\n            self::mul($a10, $b7, 22) + self::mul($a11, $b6, 22);\n        $s18 = self::mul($a7, $b11, 22) + self::mul($a8, $b10, 22) + self::mul($a9, $b9, 22) + self::mul($a10, $b8, 22)\n            + self::mul($a11, $b7, 22);\n        $s19 = self::mul($a8, $b11, 22) + self::mul($a9, $b10, 22) + self::mul($a10, $b9, 22) +\n            self::mul($a11, $b8, 22);\n        $s20 = self::mul($a9, $b11, 22) + self::mul($a10, $b10, 22) + self::mul($a11, $b9, 22);\n        $s21 = self::mul($a10, $b11, 22) + self::mul($a11, $b10, 22);\n        $s22 = self::mul($a11, $b11, 22);\n        $s23 = 0;\n\n        \/\/    carry0 = (s0 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s1 += carry0;\n        \/\/    s0 -= carry0 * ((uint64_t) 1L << 21);\n        $carry0 = ($s0 + (1 << 20)) >> 21;\n        $s1 += $carry0;\n        $s0 -= $carry0 << 21;\n        \/\/    carry2 = (s2 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s3 += carry2;\n        \/\/    s2 -= carry2 * ((uint64_t) 1L << 21);\n        $carry2 = ($s2 + (1 << 20)) >> 21;\n        $s3 += $carry2;\n        $s2 -= $carry2 << 21;\n        \/\/    carry4 = (s4 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s5 += carry4;\n        \/\/    s4 -= carry4 * ((uint64_t) 1L << 21);\n        $carry4 = ($s4 + (1 << 20)) >> 21;\n        $s5 += $carry4;\n        $s4 -= $carry4 << 21;\n        \/\/    carry6 = (s6 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s7 += carry6;\n        \/\/    s6 -= carry6 * ((uint64_t) 1L << 21);\n        $carry6 = ($s6 + (1 << 20)) >> 21;\n        $s7 += $carry6;\n        $s6 -= $carry6 << 21;\n        \/\/    carry8 = (s8 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s9 += carry8;\n        \/\/    s8 -= carry8 * ((uint64_t) 1L << 21);\n        $carry8 = ($s8 + (1 << 20)) >> 21;\n        $s9 += $carry8;\n        $s8 -= $carry8 << 21;\n        \/\/    carry10 = (s10 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s11 += carry10;\n        \/\/    s10 -= carry10 * ((uint64_t) 1L << 21);\n        $carry10 = ($s10 + (1 << 20)) >> 21;\n        $s11 += $carry10;\n        $s10 -= $carry10 << 21;\n        \/\/    carry12 = (s12 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s13 += carry12;\n        \/\/    s12 -= carry12 * ((uint64_t) 1L << 21);\n        $carry12 = ($s12 + (1 << 20)) >> 21;\n        $s13 += $carry12;\n        $s12 -= $carry12 << 21;\n        \/\/    carry14 = (s14 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s15 += carry14;\n        \/\/    s14 -= carry14 * ((uint64_t) 1L << 21);\n        $carry14 = ($s14 + (1 << 20)) >> 21;\n        $s15 += $carry14;\n        $s14 -= $carry14 << 21;\n        \/\/    carry16 = (s16 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s17 += carry16;\n        \/\/    s16 -= carry16 * ((uint64_t) 1L << 21);\n        $carry16 = ($s16 + (1 << 20)) >> 21;\n        $s17 += $carry16;\n        $s16 -= $carry16 << 21;\n        \/\/    carry18 = (s18 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s19 += carry18;\n        \/\/    s18 -= carry18 * ((uint64_t) 1L << 21);\n        $carry18 = ($s18 + (1 << 20)) >> 21;\n        $s19 += $carry18;\n        $s18 -= $carry18 << 21;\n        \/\/    carry20 = (s20 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s21 += carry20;\n        \/\/    s20 -= carry20 * ((uint64_t) 1L << 21);\n        $carry20 = ($s20 + (1 << 20)) >> 21;\n        $s21 += $carry20;\n        $s20 -= $carry20 << 21;\n        \/\/    carry22 = (s22 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s23 += carry22;\n        \/\/    s22 -= carry22 * ((uint64_t) 1L << 21);\n        $carry22 = ($s22 + (1 << 20)) >> 21;\n        $s23 += $carry22;\n        $s22 -= $carry22 << 21;\n\n        \/\/    carry1 = (s1 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s2 += carry1;\n        \/\/    s1 -= carry1 * ((uint64_t) 1L << 21);\n        $carry1 = ($s1 + (1 << 20)) >> 21;\n        $s2 += $carry1;\n        $s1 -= $carry1 << 21;\n        \/\/    carry3 = (s3 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s4 += carry3;\n        \/\/    s3 -= carry3 * ((uint64_t) 1L << 21);\n        $carry3 = ($s3 + (1 << 20)) >> 21;\n        $s4 += $carry3;\n        $s3 -= $carry3 << 21;\n        \/\/    carry5 = (s5 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s6 += carry5;\n        \/\/    s5 -= carry5 * ((uint64_t) 1L << 21);\n        $carry5 = ($s5 + (1 << 20)) >> 21;\n        $s6 += $carry5;\n        $s5 -= $carry5 << 21;\n        \/\/    carry7 = (s7 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s8 += carry7;\n        \/\/    s7 -= carry7 * ((uint64_t) 1L << 21);\n        $carry7 = ($s7 + (1 << 20)) >> 21;\n        $s8 += $carry7;\n        $s7 -= $carry7 << 21;\n        \/\/    carry9 = (s9 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s10 += carry9;\n        \/\/    s9 -= carry9 * ((uint64_t) 1L << 21);\n        $carry9 = ($s9 + (1 << 20)) >> 21;\n        $s10 += $carry9;\n        $s9 -= $carry9 << 21;\n        \/\/    carry11 = (s11 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s12 += carry11;\n        \/\/    s11 -= carry11 * ((uint64_t) 1L << 21);\n        $carry11 = ($s11 + (1 << 20)) >> 21;\n        $s12 += $carry11;\n        $s11 -= $carry11 << 21;\n        \/\/    carry13 = (s13 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s14 += carry13;\n        \/\/    s13 -= carry13 * ((uint64_t) 1L << 21);\n        $carry13 = ($s13 + (1 << 20)) >> 21;\n        $s14 += $carry13;\n        $s13 -= $carry13 << 21;\n        \/\/    carry15 = (s15 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s16 += carry15;\n        \/\/    s15 -= carry15 * ((uint64_t) 1L << 21);\n        $carry15 = ($s15 + (1 << 20)) >> 21;\n        $s16 += $carry15;\n        $s15 -= $carry15 << 21;\n        \/\/    carry17 = (s17 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s18 += carry17;\n        \/\/    s17 -= carry17 * ((uint64_t) 1L << 21);\n        $carry17 = ($s17 + (1 << 20)) >> 21;\n        $s18 += $carry17;\n        $s17 -= $carry17 << 21;\n        \/\/    carry19 = (s19 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s20 += carry19;\n        \/\/    s19 -= carry19 * ((uint64_t) 1L << 21);\n        $carry19 = ($s19 + (1 << 20)) >> 21;\n        $s20 += $carry19;\n        $s19 -= $carry19 << 21;\n        \/\/    carry21 = (s21 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s22 += carry21;\n        \/\/    s21 -= carry21 * ((uint64_t) 1L << 21);\n        $carry21 = ($s21 + (1 << 20)) >> 21;\n        $s22 += $carry21;\n        $s21 -= $carry21 << 21;\n\n        \/\/    s11 += s23 * 666643;\n        \/\/    s12 += s23 * 470296;\n        \/\/    s13 += s23 * 654183;\n        \/\/    s14 -= s23 * 997805;\n        \/\/    s15 += s23 * 136657;\n        \/\/    s16 -= s23 * 683901;\n        $s11 += self::mul($s23, 666643, 20);\n        $s12 += self::mul($s23, 470296, 19);\n        $s13 += self::mul($s23, 654183, 20);\n        $s14 -= self::mul($s23, 997805, 20);\n        $s15 += self::mul($s23, 136657, 18);\n        $s16 -= self::mul($s23, 683901, 20);\n\n        \/\/    s10 += s22 * 666643;\n        \/\/    s11 += s22 * 470296;\n        \/\/    s12 += s22 * 654183;\n        \/\/    s13 -= s22 * 997805;\n        \/\/    s14 += s22 * 136657;\n        \/\/    s15 -= s22 * 683901;\n        $s10 += self::mul($s22, 666643, 20);\n        $s11 += self::mul($s22, 470296, 19);\n        $s12 += self::mul($s22, 654183, 20);\n        $s13 -= self::mul($s22, 997805, 20);\n        $s14 += self::mul($s22, 136657, 18);\n        $s15 -= self::mul($s22, 683901, 20);\n\n        \/\/    s9 += s21 * 666643;\n        \/\/    s10 += s21 * 470296;\n        \/\/    s11 += s21 * 654183;\n        \/\/    s12 -= s21 * 997805;\n        \/\/    s13 += s21 * 136657;\n        \/\/    s14 -= s21 * 683901;\n        $s9 += self::mul($s21, 666643, 20);\n        $s10 += self::mul($s21, 470296, 19);\n        $s11 += self::mul($s21, 654183, 20);\n        $s12 -= self::mul($s21, 997805, 20);\n        $s13 += self::mul($s21, 136657, 18);\n        $s14 -= self::mul($s21, 683901, 20);\n\n        \/\/    s8 += s20 * 666643;\n        \/\/    s9 += s20 * 470296;\n        \/\/    s10 += s20 * 654183;\n        \/\/    s11 -= s20 * 997805;\n        \/\/    s12 += s20 * 136657;\n        \/\/    s13 -= s20 * 683901;\n        $s8 += self::mul($s20, 666643, 20);\n        $s9 += self::mul($s20, 470296, 19);\n        $s10 += self::mul($s20, 654183, 20);\n        $s11 -= self::mul($s20, 997805, 20);\n        $s12 += self::mul($s20, 136657, 18);\n        $s13 -= self::mul($s20, 683901, 20);\n\n        \/\/    s7 += s19 * 666643;\n        \/\/    s8 += s19 * 470296;\n        \/\/    s9 += s19 * 654183;\n        \/\/    s10 -= s19 * 997805;\n        \/\/    s11 += s19 * 136657;\n        \/\/    s12 -= s19 * 683901;\n        $s7 += self::mul($s19, 666643, 20);\n        $s8 += self::mul($s19, 470296, 19);\n        $s9 += self::mul($s19, 654183, 20);\n        $s10 -= self::mul($s19, 997805, 20);\n        $s11 += self::mul($s19, 136657, 18);\n        $s12 -= self::mul($s19, 683901, 20);\n\n        \/\/    s6 += s18 * 666643;\n        \/\/    s7 += s18 * 470296;\n        \/\/    s8 += s18 * 654183;\n        \/\/    s9 -= s18 * 997805;\n        \/\/    s10 += s18 * 136657;\n        \/\/    s11 -= s18 * 683901;\n        $s6 += self::mul($s18, 666643, 20);\n        $s7 += self::mul($s18, 470296, 19);\n        $s8 += self::mul($s18, 654183, 20);\n        $s9 -= self::mul($s18, 997805, 20);\n        $s10 += self::mul($s18, 136657, 18);\n        $s11 -= self::mul($s18, 683901, 20);\n\n        \/\/    carry6 = (s6 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s7 += carry6;\n        \/\/    s6 -= carry6 * ((uint64_t) 1L << 21);\n        $carry6 = ($s6 + (1 << 20)) >> 21;\n        $s7 += $carry6;\n        $s6 -= $carry6 << 21;\n        \/\/    carry8 = (s8 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s9 += carry8;\n        \/\/    s8 -= carry8 * ((uint64_t) 1L << 21);\n        $carry8 = ($s8 + (1 << 20)) >> 21;\n        $s9 += $carry8;\n        $s8 -= $carry8 << 21;\n        \/\/    carry10 = (s10 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s11 += carry10;\n        \/\/    s10 -= carry10 * ((uint64_t) 1L << 21);\n        $carry10 = ($s10 + (1 << 20)) >> 21;\n        $s11 += $carry10;\n        $s10 -= $carry10 << 21;\n        \/\/    carry12 = (s12 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s13 += carry12;\n        \/\/    s12 -= carry12 * ((uint64_t) 1L << 21);\n        $carry12 = ($s12 + (1 << 20)) >> 21;\n        $s13 += $carry12;\n        $s12 -= $carry12 << 21;\n        \/\/    carry14 = (s14 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s15 += carry14;\n        \/\/    s14 -= carry14 * ((uint64_t) 1L << 21);\n        $carry14 = ($s14 + (1 << 20)) >> 21;\n        $s15 += $carry14;\n        $s14 -= $carry14 << 21;\n        \/\/    carry16 = (s16 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s17 += carry16;\n        \/\/    s16 -= carry16 * ((uint64_t) 1L << 21);\n        $carry16 = ($s16 + (1 << 20)) >> 21;\n        $s17 += $carry16;\n        $s16 -= $carry16 << 21;\n\n        \/\/    carry7 = (s7 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s8 += carry7;\n        \/\/    s7 -= carry7 * ((uint64_t) 1L << 21);\n        $carry7 = ($s7 + (1 << 20)) >> 21;\n        $s8 += $carry7;\n        $s7 -= $carry7 << 21;\n        \/\/    carry9 = (s9 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s10 += carry9;\n        \/\/    s9 -= carry9 * ((uint64_t) 1L << 21);\n        $carry9 = ($s9 + (1 << 20)) >> 21;\n        $s10 += $carry9;\n        $s9 -= $carry9 << 21;\n        \/\/    carry11 = (s11 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s12 += carry11;\n        \/\/    s11 -= carry11 * ((uint64_t) 1L << 21);\n        $carry11 = ($s11 + (1 << 20)) >> 21;\n        $s12 += $carry11;\n        $s11 -= $carry11 << 21;\n        \/\/    carry13 = (s13 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s14 += carry13;\n        \/\/    s13 -= carry13 * ((uint64_t) 1L << 21);\n        $carry13 = ($s13 + (1 << 20)) >> 21;\n        $s14 += $carry13;\n        $s13 -= $carry13 << 21;\n        \/\/    carry15 = (s15 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s16 += carry15;\n        \/\/    s15 -= carry15 * ((uint64_t) 1L << 21);\n        $carry15 = ($s15 + (1 << 20)) >> 21;\n        $s16 += $carry15;\n        $s15 -= $carry15 << 21;\n\n        \/\/    s5 += s17 * 666643;\n        \/\/    s6 += s17 * 470296;\n        \/\/    s7 += s17 * 654183;\n        \/\/    s8 -= s17 * 997805;\n        \/\/    s9 += s17 * 136657;\n        \/\/    s10 -= s17 * 683901;\n        $s5 += self::mul($s17, 666643, 20);\n        $s6 += self::mul($s17, 470296, 19);\n        $s7 += self::mul($s17, 654183, 20);\n        $s8 -= self::mul($s17, 997805, 20);\n        $s9 += self::mul($s17, 136657, 18);\n        $s10 -= self::mul($s17, 683901, 20);\n\n        \/\/    s4 += s16 * 666643;\n        \/\/    s5 += s16 * 470296;\n        \/\/    s6 += s16 * 654183;\n        \/\/    s7 -= s16 * 997805;\n        \/\/    s8 += s16 * 136657;\n        \/\/    s9 -= s16 * 683901;\n        $s4 += self::mul($s16, 666643, 20);\n        $s5 += self::mul($s16, 470296, 19);\n        $s6 += self::mul($s16, 654183, 20);\n        $s7 -= self::mul($s16, 997805, 20);\n        $s8 += self::mul($s16, 136657, 18);\n        $s9 -= self::mul($s16, 683901, 20);\n\n        \/\/    s3 += s15 * 666643;\n        \/\/    s4 += s15 * 470296;\n        \/\/    s5 += s15 * 654183;\n        \/\/    s6 -= s15 * 997805;\n        \/\/    s7 += s15 * 136657;\n        \/\/    s8 -= s15 * 683901;\n        $s3 += self::mul($s15, 666643, 20);\n        $s4 += self::mul($s15, 470296, 19);\n        $s5 += self::mul($s15, 654183, 20);\n        $s6 -= self::mul($s15, 997805, 20);\n        $s7 += self::mul($s15, 136657, 18);\n        $s8 -= self::mul($s15, 683901, 20);\n\n        \/\/    s2 += s14 * 666643;\n        \/\/    s3 += s14 * 470296;\n        \/\/    s4 += s14 * 654183;\n        \/\/    s5 -= s14 * 997805;\n        \/\/    s6 += s14 * 136657;\n        \/\/    s7 -= s14 * 683901;\n        $s2 += self::mul($s14, 666643, 20);\n        $s3 += self::mul($s14, 470296, 19);\n        $s4 += self::mul($s14, 654183, 20);\n        $s5 -= self::mul($s14, 997805, 20);\n        $s6 += self::mul($s14, 136657, 18);\n        $s7 -= self::mul($s14, 683901, 20);\n\n        \/\/    s1 += s13 * 666643;\n        \/\/    s2 += s13 * 470296;\n        \/\/    s3 += s13 * 654183;\n        \/\/    s4 -= s13 * 997805;\n        \/\/    s5 += s13 * 136657;\n        \/\/    s6 -= s13 * 683901;\n        $s1 += self::mul($s13, 666643, 20);\n        $s2 += self::mul($s13, 470296, 19);\n        $s3 += self::mul($s13, 654183, 20);\n        $s4 -= self::mul($s13, 997805, 20);\n        $s5 += self::mul($s13, 136657, 18);\n        $s6 -= self::mul($s13, 683901, 20);\n\n        \/\/    s0 += s12 * 666643;\n        \/\/    s1 += s12 * 470296;\n        \/\/    s2 += s12 * 654183;\n        \/\/    s3 -= s12 * 997805;\n        \/\/    s4 += s12 * 136657;\n        \/\/    s5 -= s12 * 683901;\n        \/\/    s12 = 0;\n        $s0 += self::mul($s12, 666643, 20);\n        $s1 += self::mul($s12, 470296, 19);\n        $s2 += self::mul($s12, 654183, 20);\n        $s3 -= self::mul($s12, 997805, 20);\n        $s4 += self::mul($s12, 136657, 18);\n        $s5 -= self::mul($s12, 683901, 20);\n        $s12 = 0;\n\n        \/\/    carry0 = (s0 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s1 += carry0;\n        \/\/    s0 -= carry0 * ((uint64_t) 1L << 21);\n        $carry0 = ($s0 + (1 << 20)) >> 21;\n        $s1 += $carry0;\n        $s0 -= $carry0 << 21;\n        \/\/    carry2 = (s2 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s3 += carry2;\n        \/\/    s2 -= carry2 * ((uint64_t) 1L << 21);\n        $carry2 = ($s2 + (1 << 20)) >> 21;\n        $s3 += $carry2;\n        $s2 -= $carry2 << 21;\n        \/\/    carry4 = (s4 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s5 += carry4;\n        \/\/    s4 -= carry4 * ((uint64_t) 1L << 21);\n        $carry4 = ($s4 + (1 << 20)) >> 21;\n        $s5 += $carry4;\n        $s4 -= $carry4 << 21;\n        \/\/    carry6 = (s6 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s7 += carry6;\n        \/\/    s6 -= carry6 * ((uint64_t) 1L << 21);\n        $carry6 = ($s6 + (1 << 20)) >> 21;\n        $s7 += $carry6;\n        $s6 -= $carry6 << 21;\n        \/\/    carry8 = (s8 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s9 += carry8;\n        \/\/    s8 -= carry8 * ((uint64_t) 1L << 21);\n        $carry8 = ($s8 + (1 << 20)) >> 21;\n        $s9 += $carry8;\n        $s8 -= $carry8 << 21;\n        \/\/    carry10 = (s10 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s11 += carry10;\n        \/\/    s10 -= carry10 * ((uint64_t) 1L << 21);\n        $carry10 = ($s10 + (1 << 20)) >> 21;\n        $s11 += $carry10;\n        $s10 -= $carry10 << 21;\n\n        \/\/    carry1 = (s1 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s2 += carry1;\n        \/\/    s1 -= carry1 * ((uint64_t) 1L << 21);\n        $carry1 = ($s1 + (1 << 20)) >> 21;\n        $s2 += $carry1;\n        $s1 -= $carry1 << 21;\n        \/\/    carry3 = (s3 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s4 += carry3;\n        \/\/    s3 -= carry3 * ((uint64_t) 1L << 21);\n        $carry3 = ($s3 + (1 << 20)) >> 21;\n        $s4 += $carry3;\n        $s3 -= $carry3 << 21;\n        \/\/    carry5 = (s5 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s6 += carry5;\n        \/\/    s5 -= carry5 * ((uint64_t) 1L << 21);\n        $carry5 = ($s5 + (1 << 20)) >> 21;\n        $s6 += $carry5;\n        $s5 -= $carry5 << 21;\n        \/\/    carry7 = (s7 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s8 += carry7;\n        \/\/    s7 -= carry7 * ((uint64_t) 1L << 21);\n        $carry7 = ($s7 + (1 << 20)) >> 21;\n        $s8 += $carry7;\n        $s7 -= $carry7 << 21;\n        \/\/    carry9 = (s9 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s10 += carry9;\n        \/\/    s9 -= carry9 * ((uint64_t) 1L << 21);\n        $carry9 = ($s9 + (1 << 20)) >> 21;\n        $s10 += $carry9;\n        $s9 -= $carry9 << 21;\n        \/\/    carry11 = (s11 + (int64_t) (1L << 20)) >> 21;\n        \/\/    s12 += carry11;\n        \/\/    s11 -= carry11 * ((uint64_t) 1L << 21);\n        $carry11 = ($s11 + (1 << 20)) >> 21;\n        $s12 += $carry11;\n        $s11 -= $carry11 << 21;\n\n        \/\/    s0 += s12 * 666643;\n        \/\/    s1 += s12 * 470296;\n        \/\/    s2 += s12 * 654183;\n        \/\/    s3 -= s12 * 997805;\n        \/\/    s4 += s12 * 136657;\n        \/\/    s5 -= s12 * 683901;\n        \/\/    s12 = 0;\n        $s0 += self::mul($s12, 666643, 20);\n        $s1 += self::mul($s12, 470296, 19);\n        $s2 += self::mul($s12, 654183, 20);\n        $s3 -= self::mul($s12, 997805, 20);\n        $s4 += self::mul($s12, 136657, 18);\n        $s5 -= self::mul($s12, 683901, 20);\n        $s12 = 0;\n\n        \/\/    carry0 = s0 >> 21;\n        \/\/    s1 += carry0;\n        \/\/    s0 -= carry0 * ((uint64_t) 1L << 21);\n        $carry0 = $s0 >> 21;\n        $s1 += $carry0;\n        $s0 -= $carry0 << 21;\n        \/\/    carry1 = s1 >> 21;\n        \/\/    s2 += carry1;\n        \/\/    s1 -= carry1 * ((uint64_t) 1L << 21);\n        $carry1 = $s1 >> 21;\n        $s2 += $carry1;\n        $s1 -= $carry1 << 21;\n        \/\/    carry2 = s2 >> 21;\n        \/\/    s3 += carry2;\n        \/\/    s2 -= carry2 * ((uint64_t) 1L << 21);\n        $carry2 = $s2 >> 21;\n        $s3 += $carry2;\n        $s2 -= $carry2 << 21;\n        \/\/    carry3 = s3 >> 21;\n        \/\/    s4 += carry3;\n        \/\/    s3 -= carry3 * ((uint64_t) 1L << 21);\n        $carry3 = $s3 >> 21;\n        $s4 += $carry3;\n        $s3 -= $carry3 << 21;\n        \/\/    carry4 = s4 >> 21;\n        \/\/    s5 += carry4;\n        \/\/    s4 -= carry4 * ((uint64_t) 1L << 21);\n        $carry4 = $s4 >> 21;\n        $s5 += $carry4;\n        $s4 -= $carry4 << 21;\n        \/\/    carry5 = s5 >> 21;\n        \/\/    s6 += carry5;\n        \/\/    s5 -= carry5 * ((uint64_t) 1L << 21);\n        $carry5 = $s5 >> 21;\n        $s6 += $carry5;\n        $s5 -= $carry5 << 21;\n        \/\/    carry6 = s6 >> 21;\n        \/\/    s7 += carry6;\n        \/\/    s6 -= carry6 * ((uint64_t) 1L << 21);\n        $carry6 = $s6 >> 21;\n        $s7 += $carry6;\n        $s6 -= $carry6 << 21;\n        \/\/    carry7 = s7 >> 21;\n        \/\/    s8 += carry7;\n        \/\/    s7 -= carry7 * ((uint64_t) 1L << 21);\n        $carry7 = $s7 >> 21;\n        $s8 += $carry7;\n        $s7 -= $carry7 << 21;\n        \/\/    carry8 = s8 >> 21;\n        \/\/    s9 += carry8;\n        \/\/    s8 -= carry8 * ((uint64_t) 1L << 21);\n        $carry8 = $s8 >> 21;\n        $s9 += $carry8;\n        $s8 -= $carry8 << 21;\n        \/\/    carry9 = s9 >> 21;\n        \/\/    s10 += carry9;\n        \/\/    s9 -= carry9 * ((uint64_t) 1L << 21);\n        $carry9 = $s9 >> 21;\n        $s10 += $carry9;\n        $s9 -= $carry9 << 21;\n        \/\/    carry10 = s10 >> 21;\n        \/\/    s11 += carry10;\n        \/\/    s10 -= carry10 * ((uint64_t) 1L << 21);\n        $carry10 = $s10 >> 21;\n        $s11 += $carry10;\n        $s10 -= $carry10 << 21;\n        \/\/    carry11 = s11 >> 21;\n        \/\/    s12 += carry11;\n        \/\/    s11 -= carry11 * ((uint64_t) 1L << 21);\n        $carry11 = $s11 >> 21;\n        $s12 += $carry11;\n        $s11 -= $carry11 << 21;\n\n        \/\/    s0 += s12 * 666643;\n        \/\/    s1 += s12 * 470296;\n        \/\/    s2 += s12 * 654183;\n        \/\/    s3 -= s12 * 997805;\n        \/\/    s4 += s12 * 136657;\n        \/\/    s5 -= s12 * 683901;\n        $s0 += self::mul($s12, 666643, 20);\n        $s1 += self::mul($s12, 470296, 19);\n        $s2 += self::mul($s12, 654183, 20);\n        $s3 -= self::mul($s12, 997805, 20);\n        $s4 += self::mul($s12, 136657, 18);\n        $s5 -= self::mul($s12, 683901, 20);\n\n        \/\/    carry0 = s0 >> 21;\n        \/\/    s1 += carry0;\n        \/\/    s0 -= carry0 * ((uint64_t) 1L << 21);\n        $carry0 = $s0 >> 21;\n        $s1 += $carry0;\n        $s0 -= $carry0 << 21;\n        \/\/    carry1 = s1 >> 21;\n        \/\/    s2 += carry1;\n        \/\/    s1 -= carry1 * ((uint64_t) 1L << 21);\n        $carry1 = $s1 >> 21;\n        $s2 += $carry1;\n        $s1 -= $carry1 << 21;\n        \/\/    carry2 = s2 >> 21;\n        \/\/    s3 += carry2;\n        \/\/    s2 -= carry2 * ((uint64_t) 1L << 21);\n        $carry2 = $s2 >> 21;\n        $s3 += $carry2;\n        $s2 -= $carry2 << 21;\n        \/\/    carry3 = s3 >> 21;\n        \/\/    s4 += carry3;\n        \/\/    s3 -= carry3 * ((uint64_t) 1L << 21);\n        $carry3 = $s3 >> 21;\n        $s4 += $carry3;\n        $s3 -= $carry3 << 21;\n        \/\/    carry4 = s4 >> 21;\n        \/\/    s5 += carry4;\n        \/\/    s4 -= carry4 * ((uint64_t) 1L << 21);\n        $carry4 = $s4 >> 21;\n        $s5 += $carry4;\n        $s4 -= $carry4 << 21;\n        \/\/    carry5 = s5 >> 21;\n        \/\/    s6 += carry5;\n        \/\/    s5 -= carry5 * ((uint64_t) 1L << 21);\n        $carry5 = $s5 >> 21;\n        $s6 += $carry5;\n        $s5 -= $carry5 << 21;\n        \/\/    carry6 = s6 >> 21;\n        \/\/    s7 += carry6;\n        \/\/    s6 -= carry6 * ((uint64_t) 1L << 21);\n        $carry6 = $s6 >> 21;\n        $s7 += $carry6;\n        $s6 -= $carry6 << 21;\n        \/\/    carry7 = s7 >> 21;\n        \/\/    s8 += carry7;\n        \/\/    s7 -= carry7 * ((uint64_t) 1L << 21);\n        $carry7 = $s7 >> 21;\n        $s8 += $carry7;\n        $s7 -= $carry7 << 21;\n        \/\/    carry8 = s8 >> 21;\n        \/\/    s9 += carry8;\n        \/\/    s8 -= carry8 * ((uint64_t) 1L << 21);\n        $carry8 = $s8 >> 21;\n        $s9 += $carry8;\n        $s8 -= $carry8 << 21;\n        \/\/    carry9 = s9 >> 21;\n        \/\/    s10 += carry9;\n        \/\/    s9 -= carry9 * ((uint64_t) 1L << 21);\n        $carry9 = $s9 >> 21;\n        $s10 += $carry9;\n        $s9 -= $carry9 << 21;\n        \/\/    carry10 = s10 >> 21;\n        \/\/    s11 += carry10;\n        \/\/    s10 -= carry10 * ((uint64_t) 1L << 21);\n        $carry10 = $s10 >> 21;\n        $s11 += $carry10;\n        $s10 -= $carry10 << 21;\n\n        $s = array_fill(0, 32, 0);\n        \/\/ s[0]  = s0 >> 0;\n        $s[0]  = $s0 >> 0;\n        \/\/ s[1]  = s0 >> 8;\n        $s[1]  = $s0 >> 8;\n        \/\/ s[2]  = (s0 >> 16) | (s1 * ((uint64_t) 1 << 5));\n        $s[2]  = ($s0 >> 16) | ($s1 << 5);\n        \/\/ s[3]  = s1 >> 3;\n        $s[3]  = $s1 >> 3;\n        \/\/ s[4]  = s1 >> 11;\n        $s[4]  = $s1 >> 11;\n        \/\/ s[5]  = (s1 >> 19) | (s2 * ((uint64_t) 1 << 2));\n        $s[5]  = ($s1 >> 19) | ($s2 << 2);\n        \/\/ s[6]  = s2 >> 6;\n        $s[6]  = $s2 >> 6;\n        \/\/ s[7]  = (s2 >> 14) | (s3 * ((uint64_t) 1 << 7));\n        $s[7]  = ($s2 >> 14) | ($s3 << 7);\n        \/\/ s[8]  = s3 >> 1;\n        $s[8]  = $s3 >> 1;\n        \/\/ s[9]  = s3 >> 9;\n        $s[9]  = $s3 >> 9;\n        \/\/ s[10] = (s3 >> 17) | (s4 * ((uint64_t) 1 << 4));\n        $s[10] = ($s3 >> 17) | ($s4 << 4);\n        \/\/ s[11] = s4 >> 4;\n        $s[11] = $s4 >> 4;\n        \/\/ s[12] = s4 >> 12;\n        $s[12] = $s4 >> 12;\n        \/\/ s[13] = (s4 >> 20) | (s5 * ((uint64_t) 1 << 1));\n        $s[13] = ($s4 >> 20) | ($s5 << 1);\n        \/\/ s[14] = s5 >> 7;\n        $s[14] = $s5 >> 7;\n        \/\/ s[15] = (s5 >> 15) | (s6 * ((uint64_t) 1 << 6));\n        $s[15] = ($s5 >> 15) | ($s6 << 6);\n        \/\/ s[16] = s6 >> 2;\n        $s[16] = $s6 >> 2;\n        \/\/ s[17] = s6 >> 10;\n        $s[17] = $s6 >> 10;\n        \/\/ s[18] = (s6 >> 18) | (s7 * ((uint64_t) 1 << 3));\n        $s[18] = ($s6 >> 18) | ($s7 << 3);\n        \/\/ s[19] = s7 >> 5;\n        $s[19] = $s7 >> 5;\n        \/\/ s[20] = s7 >> 13;\n        $s[20] = $s7 >> 13;\n        \/\/ s[21] = s8 >> 0;\n        $s[21] = $s8 >> 0;\n        \/\/ s[22] = s8 >> 8;\n        $s[22] = $s8 >> 8;\n        \/\/ s[23] = (s8 >> 16) | (s9 * ((uint64_t) 1 << 5));\n        $s[23] = ($s8 >> 16) | ($s9 << 5);\n        \/\/ s[24] = s9 >> 3;\n        $s[24] = $s9 >> 3;\n        \/\/ s[25] = s9 >> 11;\n        $s[25] = $s9 >> 11;\n        \/\/ s[26] = (s9 >> 19) | (s10 * ((uint64_t) 1 << 2));\n        $s[26] = ($s9 >> 19) | ($s10 << 2);\n        \/\/ s[27] = s10 >> 6;\n        $s[27] = $s10 >> 6;\n        \/\/ s[28] = (s10 >> 14) | (s11 * ((uint64_t) 1 << 7));\n        $s[28] = ($s10 >> 14) | ($s11 << 7);\n        \/\/ s[29] = s11 >> 1;\n        $s[29] = $s11 >> 1;\n        \/\/ s[30] = s11 >> 9;\n        $s[30] = $s11 >> 9;\n        \/\/ s[31] = s11 >> 17;\n        $s[31] = $s11 >> 17;\n        return self::intArrayToString($s);\n    }\n\n    \/**\n     * @param string $s\n     * @return string\n     *\/\n    public static function sc25519_sq($s)\n    {\n        return self::sc25519_mul($s, $s);\n    }\n\n    \/**\n     * @param string $s\n     * @param int $n\n     * @param string $a\n     * @return string\n     *\/\n    public static function sc25519_sqmul($s, $n, $a)\n    {\n        for ($i = 0; $i < $n; ++$i) {\n            $s = self::sc25519_sq($s);\n        }\n        return self::sc25519_mul($s, $a);\n    }\n\n    \/**\n     * @param string $s\n     * @return string\n     *\/\n    public static function sc25519_invert($s)\n    {\n        $_10 = self::sc25519_sq($s);\n        $_11 = self::sc25519_mul($s, $_10);\n        $_100 = self::sc25519_mul($s, $_11);\n        $_1000 = self::sc25519_sq($_100);\n        $_1010 = self::sc25519_mul($_10, $_1000);\n        $_1011 = self::sc25519_mul($s, $_1010);\n        $_10000 = self::sc25519_sq($_1000);\n        $_10110 = self::sc25519_sq($_1011);\n        $_100000 = self::sc25519_mul($_1010, $_10110);\n        $_100110 = self::sc25519_mul($_10000, $_10110);\n        $_1000000 = self::sc25519_sq($_100000);\n        $_1010000 = self::sc25519_mul($_10000, $_1000000);\n        $_1010011 = self::sc25519_mul($_11, $_1010000);\n        $_1100011 = self::sc25519_mul($_10000, $_1010011);\n        $_1100111 = self::sc25519_mul($_100, $_1100011);\n        $_1101011 = self::sc25519_mul($_100, $_1100111);\n        $_10010011 = self::sc25519_mul($_1000000, $_1010011);\n        $_10010111 = self::sc25519_mul($_100, $_10010011);\n        $_10111101 = self::sc25519_mul($_100110, $_10010111);\n        $_11010011 = self::sc25519_mul($_10110, $_10111101);\n        $_11100111 = self::sc25519_mul($_1010000, $_10010111);\n        $_11101011 = self::sc25519_mul($_100, $_11100111);\n        $_11110101 = self::sc25519_mul($_1010, $_11101011);\n\n        $recip = self::sc25519_mul($_1011, $_11110101);\n        $recip = self::sc25519_sqmul($recip, 126, $_1010011);\n        $recip = self::sc25519_sqmul($recip, 9, $_10);\n        $recip = self::sc25519_mul($recip, $_11110101);\n        $recip = self::sc25519_sqmul($recip, 7, $_1100111);\n        $recip = self::sc25519_sqmul($recip, 9, $_11110101);\n        $recip = self::sc25519_sqmul($recip, 11, $_10111101);\n        $recip = self::sc25519_sqmul($recip, 8, $_11100111);\n        $recip = self::sc25519_sqmul($recip, 9, $_1101011);\n        $recip = self::sc25519_sqmul($recip, 6, $_1011);\n        $recip = self::sc25519_sqmul($recip, 14, $_10010011);\n        $recip = self::sc25519_sqmul($recip, 10, $_1100011);\n        $recip = self::sc25519_sqmul($recip, 9, $_10010111);\n        $recip = self::sc25519_sqmul($recip, 10, $_11110101);\n        $recip = self::sc25519_sqmul($recip, 8, $_11010011);\n        return self::sc25519_sqmul($recip, 8, $_11101011);\n    }\n\n    \/**\n     * @param string $s\n     * @return string\n     *\/\n    public static function clamp($s)\n    {\n        $s_ = self::stringToIntArray($s);\n        $s_[0] &= 248;\n        $s_[31] |= 64;\n        $s_[31] &= 128;\n        return self::intArrayToString($s_);\n    }\n\n    \/**\n     * Ensure limbs are less than 28 bits long to prevent float promotion.\n     *\n     * This uses a constant-time conditional swap under the hood.\n     *\n     * @param ParagonIE_Sodium_Core_Curve25519_Fe $f\n     * @return ParagonIE_Sodium_Core_Curve25519_Fe\n     *\/\n    public static function fe_normalize(ParagonIE_Sodium_Core_Curve25519_Fe $f)\n    {\n        $x = (PHP_INT_SIZE << 3) - 1; \/\/ 31 or 63\n\n        $g = self::fe_copy($f);\n        for ($i = 0; $i < 10; ++$i) {\n            $mask = -(($g[$i] >> $x) & 1);\n\n            \/*\n             * Get two candidate normalized values for $g[$i], depending on the sign of $g[$i]:\n             *\/\n            $a = $g[$i] & 0x7ffffff;\n            $b = -((-$g[$i]) & 0x7ffffff);\n\n            \/*\n             * Return the appropriate candidate value, based on the sign of the original input:\n             *\n             * The following is equivalent to this ternary:\n             *\n             * $g[$i] = (($g[$i] >> $x) & 1) ? $a : $b;\n             *\n             * Except what's written doesn't contain timing leaks.\n             *\/\n            $g[$i] = ($a ^ (($a ^ $b) & $mask));\n        }\n        return $g;\n    }\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/src\/Core\/Poly1305\/State.php","ext":"php","size":12971,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\n\nif (class_exists('ParagonIE_Sodium_Core_Poly1305_State', false)) {\n    return;\n}\n\n\/**\n * Class ParagonIE_Sodium_Core_Poly1305_State\n *\/\nclass ParagonIE_Sodium_Core_Poly1305_State extends ParagonIE_Sodium_Core_Util\n{\n    \/**\n     * @var array<int, int>\n     *\/\n    protected $buffer = array();\n\n    \/**\n     * @var bool\n     *\/\n    protected $final = false;\n\n    \/**\n     * @var array<int, int>\n     *\/\n    public $h;\n\n    \/**\n     * @var int\n     *\/\n    protected $leftover = 0;\n\n    \/**\n     * @var int[]\n     *\/\n    public $r;\n\n    \/**\n     * @var int[]\n     *\/\n    public $pad;\n\n    \/**\n     * ParagonIE_Sodium_Core_Poly1305_State constructor.\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param string $key\n     * @throws InvalidArgumentException\n     * @throws TypeError\n     *\/\n    public function __construct($key = '')\n    {\n        if (self::strlen($key) < 32) {\n            throw new InvalidArgumentException(\n                'Poly1305 requires a 32-byte key'\n            );\n        }\n        \/* r &= 0xffffffc0ffffffc0ffffffc0fffffff *\/\n        $this->r = array(\n            (int) ((self::load_4(self::substr($key, 0, 4))) & 0x3ffffff),\n            (int) ((self::load_4(self::substr($key, 3, 4)) >> 2) & 0x3ffff03),\n            (int) ((self::load_4(self::substr($key, 6, 4)) >> 4) & 0x3ffc0ff),\n            (int) ((self::load_4(self::substr($key, 9, 4)) >> 6) & 0x3f03fff),\n            (int) ((self::load_4(self::substr($key, 12, 4)) >> 8) & 0x00fffff)\n        );\n\n        \/* h = 0 *\/\n        $this->h = array(0, 0, 0, 0, 0);\n\n        \/* save pad for later *\/\n        $this->pad = array(\n            self::load_4(self::substr($key, 16, 4)),\n            self::load_4(self::substr($key, 20, 4)),\n            self::load_4(self::substr($key, 24, 4)),\n            self::load_4(self::substr($key, 28, 4)),\n        );\n\n        $this->leftover = 0;\n        $this->final = false;\n    }\n\n    \/**\n     * Zero internal buffer upon destruction\n     *\/\n    public function __destruct()\n    {\n        $this->r[0] ^= $this->r[0];\n        $this->r[1] ^= $this->r[1];\n        $this->r[2] ^= $this->r[2];\n        $this->r[3] ^= $this->r[3];\n        $this->r[4] ^= $this->r[4];\n        $this->h[0] ^= $this->h[0];\n        $this->h[1] ^= $this->h[1];\n        $this->h[2] ^= $this->h[2];\n        $this->h[3] ^= $this->h[3];\n        $this->h[4] ^= $this->h[4];\n        $this->pad[0] ^= $this->pad[0];\n        $this->pad[1] ^= $this->pad[1];\n        $this->pad[2] ^= $this->pad[2];\n        $this->pad[3] ^= $this->pad[3];\n        $this->leftover = 0;\n        $this->final = true;\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param string $message\n     * @return self\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    public function update($message = '')\n    {\n        $bytes = self::strlen($message);\n        if ($bytes < 1) {\n            return $this;\n        }\n\n        \/* handle leftover *\/\n        if ($this->leftover) {\n            $want = ParagonIE_Sodium_Core_Poly1305::BLOCK_SIZE - $this->leftover;\n            if ($want > $bytes) {\n                $want = $bytes;\n            }\n            for ($i = 0; $i < $want; ++$i) {\n                $mi = self::chrToInt($message[$i]);\n                $this->buffer[$this->leftover + $i] = $mi;\n            }\n            \/\/ We snip off the leftmost bytes.\n            $message = self::substr($message, $want);\n            $bytes = self::strlen($message);\n            $this->leftover += $want;\n            if ($this->leftover < ParagonIE_Sodium_Core_Poly1305::BLOCK_SIZE) {\n                \/\/ We still don't have enough to run $this->blocks()\n                return $this;\n            }\n\n            $this->blocks(\n                self::intArrayToString($this->buffer),\n                ParagonIE_Sodium_Core_Poly1305::BLOCK_SIZE\n            );\n            $this->leftover = 0;\n        }\n\n        \/* process full blocks *\/\n        if ($bytes >= ParagonIE_Sodium_Core_Poly1305::BLOCK_SIZE) {\n            \/** @var int $want *\/\n            $want = $bytes & ~(ParagonIE_Sodium_Core_Poly1305::BLOCK_SIZE - 1);\n            if ($want >= ParagonIE_Sodium_Core_Poly1305::BLOCK_SIZE) {\n                $block = self::substr($message, 0, $want);\n                if (self::strlen($block) >= ParagonIE_Sodium_Core_Poly1305::BLOCK_SIZE) {\n                    $this->blocks($block, $want);\n                    $message = self::substr($message, $want);\n                    $bytes = self::strlen($message);\n                }\n            }\n        }\n\n        \/* store leftover *\/\n        if ($bytes) {\n            for ($i = 0; $i < $bytes; ++$i) {\n                $mi = self::chrToInt($message[$i]);\n                $this->buffer[$this->leftover + $i] = $mi;\n            }\n            $this->leftover = (int) $this->leftover + $bytes;\n        }\n        return $this;\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param string $message\n     * @param int $bytes\n     * @return self\n     * @throws TypeError\n     *\/\n    public function blocks($message, $bytes)\n    {\n        if (self::strlen($message) < 16) {\n            $message = str_pad($message, 16, \"\\x00\", STR_PAD_RIGHT);\n        }\n        \/** @var int $hibit *\/\n        $hibit = $this->final ? 0 : 1 << 24; \/* 1 << 128 *\/\n        $r0 = (int) $this->r[0];\n        $r1 = (int) $this->r[1];\n        $r2 = (int) $this->r[2];\n        $r3 = (int) $this->r[3];\n        $r4 = (int) $this->r[4];\n\n        $s1 = self::mul($r1, 5, 3);\n        $s2 = self::mul($r2, 5, 3);\n        $s3 = self::mul($r3, 5, 3);\n        $s4 = self::mul($r4, 5, 3);\n\n        $h0 = $this->h[0];\n        $h1 = $this->h[1];\n        $h2 = $this->h[2];\n        $h3 = $this->h[3];\n        $h4 = $this->h[4];\n\n        while ($bytes >= ParagonIE_Sodium_Core_Poly1305::BLOCK_SIZE) {\n            \/* h += m[i] *\/\n            $h0 +=  self::load_4(self::substr($message, 0, 4))       & 0x3ffffff;\n            $h1 += (self::load_4(self::substr($message, 3, 4)) >> 2) & 0x3ffffff;\n            $h2 += (self::load_4(self::substr($message, 6, 4)) >> 4) & 0x3ffffff;\n            $h3 += (self::load_4(self::substr($message, 9, 4)) >> 6) & 0x3ffffff;\n            $h4 += (self::load_4(self::substr($message, 12, 4)) >> 8) | $hibit;\n\n            \/* h *= r *\/\n            $d0 = (\n                self::mul($h0, $r0, 27) +\n                self::mul($s4, $h1, 27) +\n                self::mul($s3, $h2, 27) +\n                self::mul($s2, $h3, 27) +\n                self::mul($s1, $h4, 27)\n            );\n\n            $d1 = (\n                self::mul($h0, $r1, 27) +\n                self::mul($h1, $r0, 27) +\n                self::mul($s4, $h2, 27) +\n                self::mul($s3, $h3, 27) +\n                self::mul($s2, $h4, 27)\n            );\n\n            $d2 = (\n                self::mul($h0, $r2, 27) +\n                self::mul($h1, $r1, 27) +\n                self::mul($h2, $r0, 27) +\n                self::mul($s4, $h3, 27) +\n                self::mul($s3, $h4, 27)\n            );\n\n            $d3 = (\n                self::mul($h0, $r3, 27) +\n                self::mul($h1, $r2, 27) +\n                self::mul($h2, $r1, 27) +\n                self::mul($h3, $r0, 27) +\n                self::mul($s4, $h4, 27)\n            );\n\n            $d4 = (\n                self::mul($h0, $r4, 27) +\n                self::mul($h1, $r3, 27) +\n                self::mul($h2, $r2, 27) +\n                self::mul($h3, $r1, 27) +\n                self::mul($h4, $r0, 27)\n            );\n\n            \/* (partial) h %= p *\/\n            \/** @var int $c *\/\n            $c = $d0 >> 26;\n            \/** @var int $h0 *\/\n            $h0 = $d0 & 0x3ffffff;\n            $d1 += $c;\n\n            \/** @var int $c *\/\n            $c = $d1 >> 26;\n            \/** @var int $h1 *\/\n            $h1 = $d1 & 0x3ffffff;\n            $d2 += $c;\n\n            \/** @var int $c *\/\n            $c = $d2 >> 26;\n            \/** @var int $h2  *\/\n            $h2 = $d2 & 0x3ffffff;\n            $d3 += $c;\n\n            \/** @var int $c *\/\n            $c = $d3 >> 26;\n            \/** @var int $h3 *\/\n            $h3 = $d3 & 0x3ffffff;\n            $d4 += $c;\n\n            \/** @var int $c *\/\n            $c = $d4 >> 26;\n            \/** @var int $h4 *\/\n            $h4 = $d4 & 0x3ffffff;\n            $h0 += (int) self::mul($c, 5, 3);\n\n            \/** @var int $c *\/\n            $c = $h0 >> 26;\n            \/** @var int $h0 *\/\n            $h0 &= 0x3ffffff;\n            $h1 += $c;\n\n            \/\/ Chop off the left 32 bytes.\n            $message = self::substr(\n                $message,\n                ParagonIE_Sodium_Core_Poly1305::BLOCK_SIZE\n            );\n            $bytes -= ParagonIE_Sodium_Core_Poly1305::BLOCK_SIZE;\n        }\n\n        $this->h = array(\n            (int) ($h0 & 0xffffffff),\n            (int) ($h1 & 0xffffffff),\n            (int) ($h2 & 0xffffffff),\n            (int) ($h3 & 0xffffffff),\n            (int) ($h4 & 0xffffffff)\n        );\n        return $this;\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @return string\n     * @throws TypeError\n     *\/\n    public function finish()\n    {\n        \/* process the remaining block *\/\n        if ($this->leftover) {\n            $i = $this->leftover;\n            $this->buffer[$i++] = 1;\n            for (; $i < ParagonIE_Sodium_Core_Poly1305::BLOCK_SIZE; ++$i) {\n                $this->buffer[$i] = 0;\n            }\n            $this->final = true;\n            $this->blocks(\n                self::substr(\n                    self::intArrayToString($this->buffer),\n                    0,\n                    ParagonIE_Sodium_Core_Poly1305::BLOCK_SIZE\n                ),\n                ParagonIE_Sodium_Core_Poly1305::BLOCK_SIZE\n            );\n        }\n\n        $h0 = (int) $this->h[0];\n        $h1 = (int) $this->h[1];\n        $h2 = (int) $this->h[2];\n        $h3 = (int) $this->h[3];\n        $h4 = (int) $this->h[4];\n\n        \/** @var int $c *\/\n        $c = $h1 >> 26;\n        \/** @var int $h1 *\/\n        $h1 &= 0x3ffffff;\n        \/** @var int $h2 *\/\n        $h2 += $c;\n        \/** @var int $c *\/\n        $c = $h2 >> 26;\n        \/** @var int $h2 *\/\n        $h2 &= 0x3ffffff;\n        $h3 += $c;\n        \/** @var int $c *\/\n        $c = $h3 >> 26;\n        $h3 &= 0x3ffffff;\n        $h4 += $c;\n        \/** @var int $c *\/\n        $c = $h4 >> 26;\n        $h4 &= 0x3ffffff;\n        \/** @var int $h0 *\/\n        $h0 += self::mul($c, 5, 3);\n        \/** @var int $c *\/\n        $c = $h0 >> 26;\n        \/** @var int $h0 *\/\n        $h0 &= 0x3ffffff;\n        \/** @var int $h1 *\/\n        $h1 += $c;\n\n        \/* compute h + -p *\/\n        \/** @var int $g0 *\/\n        $g0 = $h0 + 5;\n        \/** @var int $c *\/\n        $c = $g0 >> 26;\n        \/** @var int $g0 *\/\n        $g0 &= 0x3ffffff;\n\n        \/** @var int $g1 *\/\n        $g1 = $h1 + $c;\n        \/** @var int $c *\/\n        $c = $g1 >> 26;\n        $g1 &= 0x3ffffff;\n\n        \/** @var int $g2 *\/\n        $g2 = $h2 + $c;\n        \/** @var int $c *\/\n        $c = $g2 >> 26;\n        \/** @var int $g2 *\/\n        $g2 &= 0x3ffffff;\n\n        \/** @var int $g3 *\/\n        $g3 = $h3 + $c;\n        \/** @var int $c *\/\n        $c = $g3 >> 26;\n        \/** @var int $g3 *\/\n        $g3 &= 0x3ffffff;\n\n        \/** @var int $g4 *\/\n        $g4 = ($h4 + $c - (1 << 26)) & 0xffffffff;\n\n        \/* select h if h < p, or h + -p if h >= p *\/\n        \/** @var int $mask *\/\n        $mask = ($g4 >> 31) - 1;\n\n        $g0 &= $mask;\n        $g1 &= $mask;\n        $g2 &= $mask;\n        $g3 &= $mask;\n        $g4 &= $mask;\n\n        \/** @var int $mask *\/\n        $mask = ~$mask & 0xffffffff;\n        \/** @var int $h0 *\/\n        $h0 = ($h0 & $mask) | $g0;\n        \/** @var int $h1 *\/\n        $h1 = ($h1 & $mask) | $g1;\n        \/** @var int $h2 *\/\n        $h2 = ($h2 & $mask) | $g2;\n        \/** @var int $h3 *\/\n        $h3 = ($h3 & $mask) | $g3;\n        \/** @var int $h4 *\/\n        $h4 = ($h4 & $mask) | $g4;\n\n        \/* h = h % (2^128) *\/\n        \/** @var int $h0 *\/\n        $h0 = (($h0) | ($h1 << 26)) & 0xffffffff;\n        \/** @var int $h1 *\/\n        $h1 = (($h1 >>  6) | ($h2 << 20)) & 0xffffffff;\n        \/** @var int $h2 *\/\n        $h2 = (($h2 >> 12) | ($h3 << 14)) & 0xffffffff;\n        \/** @var int $h3 *\/\n        $h3 = (($h3 >> 18) | ($h4 <<  8)) & 0xffffffff;\n\n        \/* mac = (h + pad) % (2^128) *\/\n        $f = (int) ($h0 + $this->pad[0]);\n        $h0 = (int) $f;\n        $f = (int) ($h1 + $this->pad[1] + ($f >> 32));\n        $h1 = (int) $f;\n        $f = (int) ($h2 + $this->pad[2] + ($f >> 32));\n        $h2 = (int) $f;\n        $f = (int) ($h3 + $this->pad[3] + ($f >> 32));\n        $h3 = (int) $f;\n\n        return self::store32_le($h0 & 0xffffffff) .\n            self::store32_le($h1 & 0xffffffff) .\n            self::store32_le($h2 & 0xffffffff) .\n            self::store32_le($h3 & 0xffffffff);\n    }\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/src\/Core\/BLAKE2b.php","ext":"php","size":24251,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\n\nif (class_exists('ParagonIE_Sodium_Core_BLAKE2b', false)) {\n    return;\n}\n\n\/**\n * Class ParagonIE_Sodium_Core_BLAKE2b\n *\n * Based on the work of Devi Mandiri in devi\/salt.\n *\/\nabstract class ParagonIE_Sodium_Core_BLAKE2b extends ParagonIE_Sodium_Core_Util\n{\n    \/**\n     * @var SplFixedArray\n     *\/\n    protected static $iv;\n\n    \/**\n     * @var array<int, array<int, int>>\n     *\/\n    protected static $sigma = array(\n        array(  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15),\n        array( 14, 10,  4,  8,  9, 15, 13,  6,  1, 12,  0,  2, 11,  7,  5,  3),\n        array( 11,  8, 12,  0,  5,  2, 15, 13, 10, 14,  3,  6,  7,  1,  9,  4),\n        array(  7,  9,  3,  1, 13, 12, 11, 14,  2,  6,  5, 10,  4,  0, 15,  8),\n        array(  9,  0,  5,  7,  2,  4, 10, 15, 14,  1, 11, 12,  6,  8,  3, 13),\n        array(  2, 12,  6, 10,  0, 11,  8,  3,  4, 13,  7,  5, 15, 14,  1,  9),\n        array( 12,  5,  1, 15, 14, 13,  4, 10,  0,  7,  6,  3,  9,  2,  8, 11),\n        array( 13, 11,  7, 14, 12,  1,  3,  9,  5,  0, 15,  4,  8,  6,  2, 10),\n        array(  6, 15, 14,  9, 11,  3,  0,  8, 12,  2, 13,  7,  1,  4, 10,  5),\n        array( 10,  2,  8,  4,  7,  6,  1,  5, 15, 11,  9, 14,  3, 12, 13 , 0),\n        array(  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15),\n        array( 14, 10,  4,  8,  9, 15, 13,  6,  1, 12,  0,  2, 11,  7,  5,  3)\n    );\n\n    const BLOCKBYTES = 128;\n    const OUTBYTES   = 64;\n    const KEYBYTES   = 64;\n\n    \/**\n     * Turn two 32-bit integers into a fixed array representing a 64-bit integer.\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param int $high\n     * @param int $low\n     * @return SplFixedArray\n     * @psalm-suppress MixedAssignment\n     *\/\n    public static function new64($high, $low)\n    {\n        if (PHP_INT_SIZE === 4) {\n            throw new SodiumException(\"Error, use 32-bit\");\n        }\n        $i64 = new SplFixedArray(2);\n        $i64[0] = $high & 0xffffffff;\n        $i64[1] = $low & 0xffffffff;\n        return $i64;\n    }\n\n    \/**\n     * Convert an arbitrary number into an SplFixedArray of two 32-bit integers\n     * that represents a 64-bit integer.\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param int $num\n     * @return SplFixedArray\n     *\/\n    protected static function to64($num)\n    {\n        list($hi, $lo) = self::numericTo64BitInteger($num);\n        return self::new64($hi, $lo);\n    }\n\n    \/**\n     * Adds two 64-bit integers together, returning their sum as a SplFixedArray\n     * containing two 32-bit integers (representing a 64-bit integer).\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param SplFixedArray $x\n     * @param SplFixedArray $y\n     * @return SplFixedArray\n     * @psalm-suppress MixedArgument\n     * @psalm-suppress MixedAssignment\n     * @psalm-suppress MixedOperand\n     *\/\n    protected static function add64($x, $y)\n    {\n        if (PHP_INT_SIZE === 4) {\n            throw new SodiumException(\"Error, use 32-bit\");\n        }\n        $l = ($x[1] + $y[1]) & 0xffffffff;\n        return self::new64(\n            (int) ($x[0] + $y[0] + (\n                ($l < $x[1]) ? 1 : 0\n            )),\n            (int) $l\n        );\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param SplFixedArray $x\n     * @param SplFixedArray $y\n     * @param SplFixedArray $z\n     * @return SplFixedArray\n     *\/\n    protected static function add364($x, $y, $z)\n    {\n        return self::add64($x, self::add64($y, $z));\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param SplFixedArray $x\n     * @param SplFixedArray $y\n     * @return SplFixedArray\n     * @throws SodiumException\n     * @throws TypeError\n     *\/\n    protected static function xor64(SplFixedArray $x, SplFixedArray $y)\n    {\n        if (PHP_INT_SIZE === 4) {\n            throw new SodiumException(\"Error, use 32-bit\");\n        }\n        if (!is_numeric($x[0])) {\n            throw new SodiumException('x[0] is not an integer');\n        }\n        if (!is_numeric($x[1])) {\n            throw new SodiumException('x[1] is not an integer');\n        }\n        if (!is_numeric($y[0])) {\n            throw new SodiumException('y[0] is not an integer');\n        }\n        if (!is_numeric($y[1])) {\n            throw new SodiumException('y[1] is not an integer');\n        }\n        return self::new64(\n            (int) (($x[0] ^ $y[0]) & 0xffffffff),\n            (int) (($x[1] ^ $y[1]) & 0xffffffff)\n        );\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param SplFixedArray $x\n     * @param int $c\n     * @return SplFixedArray\n     * @psalm-suppress MixedAssignment\n     *\/\n    public static function rotr64($x, $c)\n    {\n        if (PHP_INT_SIZE === 4) {\n            throw new SodiumException(\"Error, use 32-bit\");\n        }\n        if ($c >= 64) {\n            $c %= 64;\n        }\n        if ($c >= 32) {\n            \/** @var int $tmp *\/\n            $tmp = $x[0];\n            $x[0] = $x[1];\n            $x[1] = $tmp;\n            $c -= 32;\n        }\n        if ($c === 0) {\n            return $x;\n        }\n\n        $l0 = 0;\n        $c = 64 - $c;\n\n        \/** @var int $c *\/\n        if ($c < 32) {\n            $h0 = ((int) ($x[0]) << $c) | (\n                (\n                    (int) ($x[1]) & ((1 << $c) - 1)\n                        <<\n                    (32 - $c)\n                ) >> (32 - $c)\n            );\n            $l0 = (int) ($x[1]) << $c;\n        } else {\n            $h0 = (int) ($x[1]) << ($c - 32);\n        }\n\n        $h1 = 0;\n        $c1 = 64 - $c;\n\n        if ($c1 < 32) {\n            $h1 = (int) ($x[0]) >> $c1;\n            $l1 = ((int) ($x[1]) >> $c1) | ((int) ($x[0]) & ((1 << $c1) - 1)) << (32 - $c1);\n        } else {\n            $l1 = (int) ($x[0]) >> ($c1 - 32);\n        }\n\n        return self::new64($h0 | $h1, $l0 | $l1);\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param SplFixedArray $x\n     * @return int\n     * @psalm-suppress MixedOperand\n     *\/\n    protected static function flatten64($x)\n    {\n        return (int) ($x[0] * 4294967296 + $x[1]);\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param SplFixedArray $x\n     * @param int $i\n     * @return SplFixedArray\n     * @psalm-suppress MixedArgument\n     * @psalm-suppress MixedArrayOffset\n     *\/\n    protected static function load64(SplFixedArray $x, $i)\n    {\n        \/** @var int $l *\/\n        $l = (int) ($x[$i])\n             | ((int) ($x[$i+1]) << 8)\n             | ((int) ($x[$i+2]) << 16)\n             | ((int) ($x[$i+3]) << 24);\n        \/** @var int $h *\/\n        $h = (int) ($x[$i+4])\n             | ((int) ($x[$i+5]) << 8)\n             | ((int) ($x[$i+6]) << 16)\n             | ((int) ($x[$i+7]) << 24);\n        return self::new64($h, $l);\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param SplFixedArray $x\n     * @param int $i\n     * @param SplFixedArray $u\n     * @return void\n     * @psalm-suppress MixedAssignment\n     *\/\n    protected static function store64(SplFixedArray $x, $i, SplFixedArray $u)\n    {\n        $maxLength = $x->getSize() - 1;\n        for ($j = 0; $j < 8; ++$j) {\n            \/*\n               [0, 1, 2, 3, 4, 5, 6, 7]\n                    ... becomes ...\n               [0, 0, 0, 0, 1, 1, 1, 1]\n            *\/\n            \/** @var int $uIdx *\/\n            $uIdx = ((7 - $j) & 4) >> 2;\n            $x[$i]   = ((int) ($u[$uIdx]) & 0xff);\n            if (++$i > $maxLength) {\n                return;\n            }\n            \/** @psalm-suppress MixedOperand *\/\n            $u[$uIdx] >>= 8;\n        }\n    }\n\n    \/**\n     * This just sets the $iv static variable.\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @return void\n     *\/\n    public static function pseudoConstructor()\n    {\n        static $called = false;\n        if ($called) {\n            return;\n        }\n        self::$iv = new SplFixedArray(8);\n        self::$iv[0] = self::new64(0x6a09e667, 0xf3bcc908);\n        self::$iv[1] = self::new64(0xbb67ae85, 0x84caa73b);\n        self::$iv[2] = self::new64(0x3c6ef372, 0xfe94f82b);\n        self::$iv[3] = self::new64(0xa54ff53a, 0x5f1d36f1);\n        self::$iv[4] = self::new64(0x510e527f, 0xade682d1);\n        self::$iv[5] = self::new64(0x9b05688c, 0x2b3e6c1f);\n        self::$iv[6] = self::new64(0x1f83d9ab, 0xfb41bd6b);\n        self::$iv[7] = self::new64(0x5be0cd19, 0x137e2179);\n\n        $called = true;\n    }\n\n    \/**\n     * Returns a fresh BLAKE2 context.\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @return SplFixedArray\n     * @psalm-suppress MixedAssignment\n     * @psalm-suppress MixedArrayAccess\n     * @psalm-suppress MixedArrayAssignment\n     *\/\n    protected static function context()\n    {\n        $ctx    = new SplFixedArray(6);\n        $ctx[0] = new SplFixedArray(8);   \/\/ h\n        $ctx[1] = new SplFixedArray(2);   \/\/ t\n        $ctx[2] = new SplFixedArray(2);   \/\/ f\n        $ctx[3] = new SplFixedArray(256); \/\/ buf\n        $ctx[4] = 0;                      \/\/ buflen\n        $ctx[5] = 0;                      \/\/ last_node (uint8_t)\n\n        for ($i = 8; $i--;) {\n            $ctx[0][$i] = self::$iv[$i];\n        }\n        for ($i = 256; $i--;) {\n            $ctx[3][$i] = 0;\n        }\n\n        $zero = self::new64(0, 0);\n        $ctx[1][0] = $zero;\n        $ctx[1][1] = $zero;\n        $ctx[2][0] = $zero;\n        $ctx[2][1] = $zero;\n\n        return $ctx;\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param SplFixedArray $ctx\n     * @param SplFixedArray $buf\n     * @return void\n     * @throws SodiumException\n     * @throws TypeError\n     * @psalm-suppress MixedArgument\n     * @psalm-suppress MixedAssignment\n     * @psalm-suppress MixedArrayAccess\n     * @psalm-suppress MixedArrayAssignment\n     * @psalm-suppress MixedArrayOffset\n     *\/\n    protected static function compress(SplFixedArray $ctx, SplFixedArray $buf)\n    {\n        $m = new SplFixedArray(16);\n        $v = new SplFixedArray(16);\n\n        for ($i = 16; $i--;) {\n            $m[$i] = self::load64($buf, $i << 3);\n        }\n\n        for ($i = 8; $i--;) {\n            $v[$i] = $ctx[0][$i];\n        }\n\n        $v[ 8] = self::$iv[0];\n        $v[ 9] = self::$iv[1];\n        $v[10] = self::$iv[2];\n        $v[11] = self::$iv[3];\n\n        $v[12] = self::xor64($ctx[1][0], self::$iv[4]);\n        $v[13] = self::xor64($ctx[1][1], self::$iv[5]);\n        $v[14] = self::xor64($ctx[2][0], self::$iv[6]);\n        $v[15] = self::xor64($ctx[2][1], self::$iv[7]);\n\n        for ($r = 0; $r < 12; ++$r) {\n            $v = self::G($r, 0, 0, 4, 8, 12, $v, $m);\n            $v = self::G($r, 1, 1, 5, 9, 13, $v, $m);\n            $v = self::G($r, 2, 2, 6, 10, 14, $v, $m);\n            $v = self::G($r, 3, 3, 7, 11, 15, $v, $m);\n            $v = self::G($r, 4, 0, 5, 10, 15, $v, $m);\n            $v = self::G($r, 5, 1, 6, 11, 12, $v, $m);\n            $v = self::G($r, 6, 2, 7, 8, 13, $v, $m);\n            $v = self::G($r, 7, 3, 4, 9, 14, $v, $m);\n        }\n\n        for ($i = 8; $i--;) {\n            $ctx[0][$i] = self::xor64(\n                $ctx[0][$i], self::xor64($v[$i], $v[$i+8])\n            );\n        }\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param int $r\n     * @param int $i\n     * @param int $a\n     * @param int $b\n     * @param int $c\n     * @param int $d\n     * @param SplFixedArray $v\n     * @param SplFixedArray $m\n     * @return SplFixedArray\n     * @throws SodiumException\n     * @throws TypeError\n     * @psalm-suppress MixedArgument\n     * @psalm-suppress MixedArrayOffset\n     *\/\n    public static function G($r, $i, $a, $b, $c, $d, SplFixedArray $v, SplFixedArray $m)\n    {\n        $v[$a] = self::add364($v[$a], $v[$b], $m[self::$sigma[$r][$i << 1]]);\n        $v[$d] = self::rotr64(self::xor64($v[$d], $v[$a]), 32);\n        $v[$c] = self::add64($v[$c], $v[$d]);\n        $v[$b] = self::rotr64(self::xor64($v[$b], $v[$c]), 24);\n        $v[$a] = self::add364($v[$a], $v[$b], $m[self::$sigma[$r][($i << 1) + 1]]);\n        $v[$d] = self::rotr64(self::xor64($v[$d], $v[$a]), 16);\n        $v[$c] = self::add64($v[$c], $v[$d]);\n        $v[$b] = self::rotr64(self::xor64($v[$b], $v[$c]), 63);\n        return $v;\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param SplFixedArray $ctx\n     * @param int $inc\n     * @return void\n     * @throws SodiumException\n     * @psalm-suppress MixedArgument\n     * @psalm-suppress MixedArrayAccess\n     * @psalm-suppress MixedArrayAssignment\n     *\/\n    public static function increment_counter($ctx, $inc)\n    {\n        if ($inc < 0) {\n            throw new SodiumException('Increasing by a negative number makes no sense.');\n        }\n        $t = self::to64($inc);\n        # S->t is $ctx[1] in our implementation\n\n        # S->t[0] = ( uint64_t )( t >> 0 );\n        $ctx[1][0] = self::add64($ctx[1][0], $t);\n\n        # S->t[1] += ( S->t[0] < inc );\n        if (self::flatten64($ctx[1][0]) < $inc) {\n            $ctx[1][1] = self::add64($ctx[1][1], self::to64(1));\n        }\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param SplFixedArray $ctx\n     * @param SplFixedArray $p\n     * @param int $plen\n     * @return void\n     * @throws SodiumException\n     * @throws TypeError\n     * @psalm-suppress MixedArgument\n     * @psalm-suppress MixedAssignment\n     * @psalm-suppress MixedArrayAccess\n     * @psalm-suppress MixedArrayAssignment\n     * @psalm-suppress MixedArrayOffset\n     * @psalm-suppress MixedOperand\n     *\/\n    public static function update(SplFixedArray $ctx, SplFixedArray $p, $plen)\n    {\n        self::pseudoConstructor();\n\n        $offset = 0;\n        while ($plen > 0) {\n            $left = $ctx[4];\n            $fill = 256 - $left;\n\n            if ($plen > $fill) {\n                # memcpy( S->buf + left, in, fill ); \/* Fill buffer *\/\n                for ($i = $fill; $i--;) {\n                    $ctx[3][$i + $left] = $p[$i + $offset];\n                }\n\n                # S->buflen += fill;\n                $ctx[4] += $fill;\n\n                # blake2b_increment_counter( S, BLAKE2B_BLOCKBYTES );\n                self::increment_counter($ctx, 128);\n\n                # blake2b_compress( S, S->buf ); \/* Compress *\/\n                self::compress($ctx, $ctx[3]);\n\n                # memcpy( S->buf, S->buf + BLAKE2B_BLOCKBYTES, BLAKE2B_BLOCKBYTES ); \/* Shift buffer left *\/\n                for ($i = 128; $i--;) {\n                    $ctx[3][$i] = $ctx[3][$i + 128];\n                }\n\n                # S->buflen -= BLAKE2B_BLOCKBYTES;\n                $ctx[4] -= 128;\n\n                # in += fill;\n                $offset += $fill;\n\n                # inlen -= fill;\n                $plen -= $fill;\n            } else {\n                for ($i = $plen; $i--;) {\n                    $ctx[3][$i + $left] = $p[$i + $offset];\n                }\n                $ctx[4] += $plen;\n                $offset += $plen;\n                $plen -= $plen;\n            }\n        }\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param SplFixedArray $ctx\n     * @param SplFixedArray $out\n     * @return SplFixedArray\n     * @throws SodiumException\n     * @throws TypeError\n     * @psalm-suppress MixedArgument\n     * @psalm-suppress MixedAssignment\n     * @psalm-suppress MixedArrayAccess\n     * @psalm-suppress MixedArrayAssignment\n     * @psalm-suppress MixedArrayOffset\n     * @psalm-suppress MixedOperand\n     *\/\n    public static function finish(SplFixedArray $ctx, SplFixedArray $out)\n    {\n        self::pseudoConstructor();\n        if ($ctx[4] > 128) {\n            self::increment_counter($ctx, 128);\n            self::compress($ctx, $ctx[3]);\n            $ctx[4] -= 128;\n            if ($ctx[4] > 128) {\n                throw new SodiumException('Failed to assert that buflen <= 128 bytes');\n            }\n            for ($i = $ctx[4]; $i--;) {\n                $ctx[3][$i] = $ctx[3][$i + 128];\n            }\n        }\n\n        self::increment_counter($ctx, $ctx[4]);\n        $ctx[2][0] = self::new64(0xffffffff, 0xffffffff);\n\n        for ($i = 256 - $ctx[4]; $i--;) {\n            $ctx[3][$i+$ctx[4]] = 0;\n        }\n\n        self::compress($ctx, $ctx[3]);\n\n        $i = (int) (($out->getSize() - 1) \/ 8);\n        for (; $i >= 0; --$i) {\n            self::store64($out, $i << 3, $ctx[0][$i]);\n        }\n        return $out;\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param SplFixedArray|null $key\n     * @param int $outlen\n     * @param SplFixedArray|null $salt\n     * @param SplFixedArray|null $personal\n     * @return SplFixedArray\n     * @throws SodiumException\n     * @throws TypeError\n     * @psalm-suppress MixedArgument\n     * @psalm-suppress MixedAssignment\n     * @psalm-suppress MixedArrayAccess\n     * @psalm-suppress MixedArrayAssignment\n     * @psalm-suppress MixedArrayOffset\n     *\/\n    public static function init(\n        $key = null,\n        $outlen = 64,\n        $salt = null,\n        $personal = null\n    ) {\n        self::pseudoConstructor();\n        $klen = 0;\n\n        if ($key !== null) {\n            if (count($key) > 64) {\n                throw new SodiumException('Invalid key size');\n            }\n            $klen = count($key);\n        }\n\n        if ($outlen > 64) {\n            throw new SodiumException('Invalid output size');\n        }\n\n        $ctx = self::context();\n\n        $p = new SplFixedArray(64);\n        \/\/ Zero our param buffer...\n        for ($i = 64; --$i;) {\n            $p[$i] = 0;\n        }\n\n        $p[0] = $outlen; \/\/ digest_length\n        $p[1] = $klen;   \/\/ key_length\n        $p[2] = 1;       \/\/ fanout\n        $p[3] = 1;       \/\/ depth\n\n        if ($salt instanceof SplFixedArray) {\n            \/\/ salt: [32] through [47]\n            for ($i = 0; $i < 16; ++$i) {\n                $p[32 + $i] = (int) $salt[$i];\n            }\n        }\n        if ($personal instanceof SplFixedArray) {\n            \/\/ personal: [48] through [63]\n            for ($i = 0; $i < 16; ++$i) {\n                $p[48 + $i] = (int) $personal[$i];\n            }\n        }\n\n        $ctx[0][0] = self::xor64(\n            $ctx[0][0],\n            self::load64($p, 0)\n        );\n        if ($salt instanceof SplFixedArray || $personal instanceof SplFixedArray) {\n            \/\/ We need to do what blake2b_init_param() does:\n            for ($i = 1; $i < 8; ++$i) {\n                $ctx[0][$i] = self::xor64(\n                    $ctx[0][$i],\n                    self::load64($p, $i << 3)\n                );\n            }\n        }\n\n        if ($klen > 0 && $key instanceof SplFixedArray) {\n            $block = new SplFixedArray(128);\n            for ($i = 128; $i--;) {\n                $block[$i] = 0;\n            }\n            for ($i = $klen; $i--;) {\n                $block[$i] = $key[$i];\n            }\n            self::update($ctx, $block, 128);\n            $ctx[4] = 128;\n        }\n\n        return $ctx;\n    }\n\n    \/**\n     * Convert a string into an SplFixedArray of integers\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param string $str\n     * @return SplFixedArray\n     * @psalm-suppress MixedArgumentTypeCoercion\n     *\/\n    public static function stringToSplFixedArray($str = '')\n    {\n        $values = unpack('C*', $str);\n        return SplFixedArray::fromArray(array_values($values));\n    }\n\n    \/**\n     * Convert an SplFixedArray of integers into a string\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param SplFixedArray $a\n     * @return string\n     * @throws TypeError\n     *\/\n    public static function SplFixedArrayToString(SplFixedArray $a)\n    {\n        \/**\n         * @var array<int, int|string> $arr\n         *\/\n        $arr = $a->toArray();\n        $c = $a->count();\n        array_unshift($arr, str_repeat('C', $c));\n        return (string) (call_user_func_array('pack', $arr));\n    }\n\n    \/**\n     * @internal You should not use this directly from another application\n     *\n     * @param SplFixedArray $ctx\n     * @return string\n     * @throws TypeError\n     * @psalm-suppress MixedArgument\n     * @psalm-suppress MixedAssignment\n     * @psalm-suppress MixedArrayAccess\n     * @psalm-suppress MixedArrayAssignment\n     * @psalm-suppress MixedArrayOffset\n     * @psalm-suppress MixedMethodCall\n     *\/\n    public static function contextToString(SplFixedArray $ctx)\n    {\n        $str = '';\n        \/** @var array<int, array<int, int>> $ctxA *\/\n        $ctxA = $ctx[0]->toArray();\n\n        # uint64_t h[8];\n        for ($i = 0; $i < 8; ++$i) {\n            $str .= self::store32_le($ctxA[$i][1]);\n            $str .= self::store32_le($ctxA[$i][0]);\n        }\n\n        # uint64_t t[2];\n        # uint64_t f[2];\n        for ($i = 1; $i < 3; ++$i) {\n            $ctxA = $ctx[$i]->toArray();\n            $str .= self::store32_le($ctxA[0][1]);\n            $str .= self::store32_le($ctxA[0][0]);\n            $str .= self::store32_le($ctxA[1][1]);\n            $str .= self::store32_le($ctxA[1][0]);\n        }\n\n        # uint8_t buf[2 * 128];\n        $str .= self::SplFixedArrayToString($ctx[3]);\n\n        \/** @var int $ctx4 *\/\n        $ctx4 = (int) $ctx[4];\n\n        # size_t buflen;\n        $str .= implode('', array(\n            self::intToChr($ctx4 & 0xff),\n            self::intToChr(($ctx4 >> 8) & 0xff),\n            self::intToChr(($ctx4 >> 16) & 0xff),\n            self::intToChr(($ctx4 >> 24) & 0xff),\n            self::intToChr(($ctx4 >> 32) & 0xff),\n            self::intToChr(($ctx4 >> 40) & 0xff),\n            self::intToChr(($ctx4 >> 48) & 0xff),\n            self::intToChr(($ctx4 >> 56) & 0xff)\n        ));\n        # uint8_t last_node;\n        return $str . self::intToChr($ctx[5]) . str_repeat(\"\\x00\", 23);\n    }\n\n    \/**\n     * Creates an SplFixedArray containing other SplFixedArray elements, from\n     * a string (compatible with \\Sodium\\crypto_generichash_{init, update, final})\n     *\n     * @internal You should not use this directly from another application\n     *\n     * @param string $string\n     * @return SplFixedArray\n     * @throws SodiumException\n     * @throws TypeError\n     * @psalm-suppress MixedArrayAssignment\n     *\/\n    public static function stringToContext($string)\n    {\n        $ctx = self::context();\n\n        # uint64_t h[8];\n        for ($i = 0; $i < 8; ++$i) {\n            $ctx[0][$i] = SplFixedArray::fromArray(\n                array(\n                    self::load_4(\n                        self::substr($string, (($i << 3) + 4), 4)\n                    ),\n                    self::load_4(\n                        self::substr($string, (($i << 3) + 0), 4)\n                    )\n                )\n            );\n        }\n\n        # uint64_t t[2];\n        # uint64_t f[2];\n        for ($i = 1; $i < 3; ++$i) {\n            $ctx[$i][1] = SplFixedArray::fromArray(\n                array(\n                    self::load_4(self::substr($string, 76 + (($i - 1) << 4), 4)),\n                    self::load_4(self::substr($string, 72 + (($i - 1) << 4), 4))\n                )\n            );\n            $ctx[$i][0] = SplFixedArray::fromArray(\n                array(\n                    self::load_4(self::substr($string, 68 + (($i - 1) << 4), 4)),\n                    self::load_4(self::substr($string, 64 + (($i - 1) << 4), 4))\n                )\n            );\n        }\n\n        # uint8_t buf[2 * 128];\n        $ctx[3] = self::stringToSplFixedArray(self::substr($string, 96, 256));\n\n        # uint8_t buf[2 * 128];\n        $int = 0;\n        for ($i = 0; $i < 8; ++$i) {\n            $int |= self::chrToInt($string[352 + $i]) << ($i << 3);\n        }\n        $ctx[4] = $int;\n\n        return $ctx;\n    }\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/src\/Core\/SecretStream\/State.php","ext":"php","size":3683,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\n\n\/**\n * Class ParagonIE_Sodium_Core_SecretStream_State\n *\/\nclass ParagonIE_Sodium_Core_SecretStream_State\n{\n    \/** @var string $key *\/\n    protected $key;\n\n    \/** @var int $counter *\/\n    protected $counter;\n\n    \/** @var string $nonce *\/\n    protected $nonce;\n\n    \/** @var string $_pad *\/\n    protected $_pad;\n\n    \/**\n     * ParagonIE_Sodium_Core_SecretStream_State constructor.\n     * @param string $key\n     * @param string|null $nonce\n     *\/\n    public function __construct($key, $nonce = null)\n    {\n        $this->key = $key;\n        $this->counter = 1;\n        if (is_null($nonce)) {\n            $nonce = str_repeat(\"\\0\", 12);\n        }\n        $this->nonce = str_pad($nonce, 12, \"\\0\", STR_PAD_RIGHT);;\n        $this->_pad = str_repeat(\"\\0\", 4);\n    }\n\n    \/**\n     * @return self\n     *\/\n    public function counterReset()\n    {\n        $this->counter = 1;\n        $this->_pad = str_repeat(\"\\0\", 4);\n        return $this;\n    }\n\n    \/**\n     * @return string\n     *\/\n    public function getKey()\n    {\n        return $this->key;\n    }\n\n    \/**\n     * @return string\n     *\/\n    public function getCounter()\n    {\n        return ParagonIE_Sodium_Core_Util::store32_le($this->counter);\n    }\n\n    \/**\n     * @return string\n     *\/\n    public function getNonce()\n    {\n        if (!is_string($this->nonce)) {\n            $this->nonce = str_repeat(\"\\0\", 12);\n        }\n        if (ParagonIE_Sodium_Core_Util::strlen($this->nonce) !== 12) {\n            $this->nonce = str_pad($this->nonce, 12, \"\\0\", STR_PAD_RIGHT);\n        }\n        return $this->nonce;\n    }\n\n    \/**\n     * @return string\n     *\/\n    public function getCombinedNonce()\n    {\n        return $this->getCounter() .\n            ParagonIE_Sodium_Core_Util::substr($this->getNonce(), 0, 8);\n    }\n\n    \/**\n     * @return self\n     *\/\n    public function incrementCounter()\n    {\n        ++$this->counter;\n        return $this;\n    }\n\n    \/**\n     * @return bool\n     *\/\n    public function needsRekey()\n    {\n        return ($this->counter & 0xffff) === 0;\n    }\n\n    \/**\n     * @param string $newKeyAndNonce\n     * @return self\n     *\/\n    public function rekey($newKeyAndNonce)\n    {\n        $this->key = ParagonIE_Sodium_Core_Util::substr($newKeyAndNonce, 0, 32);\n        $this->nonce = str_pad(\n            ParagonIE_Sodium_Core_Util::substr($newKeyAndNonce, 32),\n            12,\n            \"\\0\",\n            STR_PAD_RIGHT\n        );\n        return $this;\n    }\n\n    \/**\n     * @param string $str\n     * @return self\n     *\/\n    public function xorNonce($str)\n    {\n        $this->nonce = ParagonIE_Sodium_Core_Util::xorStrings(\n            $this->getNonce(),\n            str_pad(\n                ParagonIE_Sodium_Core_Util::substr($str, 0, 8),\n                12,\n                \"\\0\",\n                STR_PAD_RIGHT\n            )\n        );\n        return $this;\n    }\n\n    \/**\n     * @param string $string\n     * @return self\n     *\/\n    public static function fromString($string)\n    {\n        $state = new ParagonIE_Sodium_Core_SecretStream_State(\n            ParagonIE_Sodium_Core_Util::substr($string, 0, 32)\n        );\n        $state->counter = ParagonIE_Sodium_Core_Util::load_4(\n            ParagonIE_Sodium_Core_Util::substr($string, 32, 4)\n        );\n        $state->nonce = ParagonIE_Sodium_Core_Util::substr($string, 36, 12);\n        $state->_pad = ParagonIE_Sodium_Core_Util::substr($string, 48, 8);\n        return $state;\n    }\n\n    \/**\n     * @return string\n     *\/\n    public function toString()\n    {\n        return $this->key .\n            $this->getCounter() .\n            $this->nonce .\n            $this->_pad;\n    }\n}\n"},{"base":"plugins","rel":"wordfence\/crypto\/vendor\/paragonie\/sodium_compat\/src\/Core\/Base64\/UrlSafe.php","ext":"php","size":7790,"mtime":1756374919,"type":"text","content":"<?php\n\/\/ phpcs:ignoreFile -- compatibility library for PHP 5-7.1\n\n\/**\n * Class ParagonIE_Sodium_Core_Base64UrlSafe\n *\n *  Copyright (c) 2016 - 2018 Paragon Initiative Enterprises.\n *  Copyright (c) 2014 Steve \"Sc00bz\" Thomas (steve at tobtu dot com)\n *\/\nclass ParagonIE_Sodium_Core_Base64_UrlSafe\n{\n    \/\/ COPY ParagonIE_Sodium_Core_Base64_Common STARTING HERE\n    \/**\n     * Encode into Base64\n     *\n     * Base64 character set \"[A-Z][a-z][0-9]+\/\"\n     *\n     * @param string $src\n     * @return string\n     * @throws TypeError\n     *\/\n    public static function encode($src)\n    {\n        return self::doEncode($src, true);\n    }\n\n    \/**\n     * Encode into Base64, no = padding\n     *\n     * Base64 character set \"[A-Z][a-z][0-9]+\/\"\n     *\n     * @param string $src\n     * @return string\n     * @throws TypeError\n     *\/\n    public static function encodeUnpadded($src)\n    {\n        return self::doEncode($src, false);\n    }\n\n    \/**\n     * @param string $src\n     * @param bool $pad   Include = padding?\n     * @return string\n     * @throws TypeError\n     *\/\n    protected static function doEncode($src, $pad = true)\n    {\n        $dest = '';\n        $srcLen = ParagonIE_Sodium_Core_Util::strlen($src);\n        \/\/ Main loop (no padding):\n        for ($i = 0; $i + 3 <= $srcLen; $i += 3) {\n            \/** @var array<int, int> $chunk *\/\n            $chunk = unpack('C*', ParagonIE_Sodium_Core_Util::substr($src, $i, 3));\n            $b0 = $chunk[1];\n            $b1 = $chunk[2];\n            $b2 = $chunk[3];\n\n            $dest .=\n                self::encode6Bits(               $b0 >> 2       ) .\n                self::encode6Bits((($b0 << 4) | ($b1 >> 4)) & 63) .\n                self::encode6Bits((($b1 << 2) | ($b2 >> 6)) & 63) .\n                self::encode6Bits(  $b2                     & 63);\n        }\n        \/\/ The last chunk, which may have padding:\n        if ($i < $srcLen) {\n            \/** @var array<int, int> $chunk *\/\n            $chunk = unpack('C*', ParagonIE_Sodium_Core_Util::substr($src, $i, $srcLen - $i));\n            $b0 = $chunk[1];\n            if ($i + 1 < $srcLen) {\n                $b1 = $chunk[2];\n                $dest .=\n                    self::encode6Bits($b0 >> 2) .\n                    self::encode6Bits((($b0 << 4) | ($b1 >> 4)) & 63) .\n                    self::encode6Bits(($b1 << 2) & 63);\n                if ($pad) {\n                    $dest .= '=';\n                }\n            } else {\n                $dest .=\n                    self::encode6Bits( $b0 >> 2) .\n                    self::encode6Bits(($b0 << 4) & 63);\n                if ($pad) {\n                    $dest .= '==';\n                }\n            }\n        }\n        return $dest;\n    }\n\n    \/**\n     * decode from base64 into binary\n     *\n     * Base64 character set \".\/[A-Z][a-z][0-9]\"\n     *\n     * @param string $src\n     * @param bool $strictPadding\n     * @return string\n     * @throws RangeException\n     * @throws TypeError\n     * @psalm-suppress RedundantCondition\n     *\/\n    public static function decode($src, $strictPadding = false)\n    {\n        \/\/ Remove padding\n        $srcLen = ParagonIE_Sodium_Core_Util::strlen($src);\n        if ($srcLen === 0) {\n            return '';\n        }\n\n        if ($strictPadding) {\n            if (($srcLen & 3) === 0) {\n                if ($src[$srcLen - 1] === '=') {\n                    $srcLen--;\n                    if ($src[$srcLen - 1] === '=') {\n                        $srcLen--;\n                    }\n                }\n            }\n            if (($srcLen & 3) === 1) {\n                throw new RangeException(\n                    'Incorrect padding'\n                );\n            }\n            if ($src[$srcLen - 1] === '=') {\n                throw new RangeException(\n                    'Incorrect padding'\n                );\n            }\n        } else {\n            $src = rtrim($src, '=');\n            $srcLen =  ParagonIE_Sodium_Core_Util::strlen($src);\n        }\n\n        $err = 0;\n        $dest = '';\n        \/\/ Main loop (no padding):\n        for ($i = 0; $i + 4 <= $srcLen; $i += 4) {\n            \/** @var array<int, int> $chunk *\/\n            $chunk = unpack('C*', ParagonIE_Sodium_Core_Util::substr($src, $i, 4));\n            $c0 = self::decode6Bits($chunk[1]);\n            $c1 = self::decode6Bits($chunk[2]);\n            $c2 = self::decode6Bits($chunk[3]);\n            $c3 = self::decode6Bits($chunk[4]);\n\n            $dest .= pack(\n                'CCC',\n                ((($c0 << 2) | ($c1 >> 4)) & 0xff),\n                ((($c1 << 4) | ($c2 >> 2)) & 0xff),\n                ((($c2 << 6) | $c3) & 0xff)\n            );\n            $err |= ($c0 | $c1 | $c2 | $c3) >> 8;\n        }\n        \/\/ The last chunk, which may have padding:\n        if ($i < $srcLen) {\n            \/** @var array<int, int> $chunk *\/\n            $chunk = unpack('C*', ParagonIE_Sodium_Core_Util::substr($src, $i, $srcLen - $i));\n            $c0 = self::decode6Bits($chunk[1]);\n\n            if ($i + 2 < $srcLen) {\n                $c1 = self::decode6Bits($chunk[2]);\n                $c2 = self::decode6Bits($chunk[3]);\n                $dest .= pack(\n                    'CC',\n                    ((($c0 << 2) | ($c1 >> 4)) & 0xff),\n                    ((($c1 << 4) | ($c2 >> 2)) & 0xff)\n                );\n                $err |= ($c0 | $c1 | $c2) >> 8;\n            } elseif ($i + 1 < $srcLen) {\n                $c1 = self::decode6Bits($chunk[2]);\n                $dest .= pack(\n                    'C',\n                    ((($c0 << 2) | ($c1 >> 4)) & 0xff)\n                );\n                $err |= ($c0 | $c1) >> 8;\n            } elseif ($i < $srcLen && $strictPadding) {\n                $err |= 1;\n            }\n        }\n        \/** @var bool $check *\/\n        $check = ($err === 0);\n        if (!$check) {\n            throw new RangeException(\n                'Base64::decode() only expects characters in the correct base64 alphabet'\n            );\n        }\n        return $dest;\n    }\n    \/\/ COPY ParagonIE_Sodium_Core_Base64_Common ENDING HERE\n    \/**\n     * Uses bitwise operators instead of table-lookups to turn 6-bit integers\n     * into 8-bit integers.\n     *\n     * Base64 character set:\n     * [A-Z]      [a-z]      [0-9]      +     \/\n     * 0x41-0x5a, 0x61-0x7a, 0x30-0x39, 0x2b, 0x2f\n     *\n     * @param int $src\n     * @return int\n     *\/\n    protected static function decode6Bits($src)\n    {\n        $ret = -1;\n\n        \/\/ if ($src > 0x40 && $src < 0x5b) $ret += $src - 0x41 + 1; \/\/ -64\n        $ret += (((0x40 - $src) & ($src - 0x5b)) >> 8) & ($src - 64);\n\n        \/\/ if ($src > 0x60 && $src < 0x7b) $ret += $src - 0x61 + 26 + 1; \/\/ -70\n        $ret += (((0x60 - $src) & ($src - 0x7b)) >> 8) & ($src - 70);\n\n        \/\/ if ($src > 0x2f && $src < 0x3a) $ret += $src - 0x30 + 52 + 1; \/\/ 5\n        $ret += (((0x2f - $src) & ($src - 0x3a)) >> 8) & ($src + 5);\n\n        \/\/ if ($src == 0x2c) $ret += 62 + 1;\n        $ret += (((0x2c - $src) & ($src - 0x2e)) >> 8) & 63;\n\n        \/\/ if ($src == 0x5f) ret += 63 + 1;\n        $ret += (((0x5e - $src) & ($src - 0x60)) >> 8) & 64;\n\n        return $ret;\n    }\n\n    \/**\n     * Uses bitwise operators instead of table-lookups to turn 8-bit integers\n     * into 6-bit integers.\n     *\n     * @param int $src\n     * @return string\n     *\/\n    protected static function encode6Bits($src)\n    {\n        $diff = 0x41;\n\n        \/\/ if ($src > 25) $diff += 0x61 - 0x41 - 26; \/\/ 6\n        $diff += ((25 - $src) >> 8) & 6;\n\n        \/\/ if ($src > 51) $diff += 0x30 - 0x61 - 26; \/\/ -75\n        $diff -= ((51 - $src) >> 8) & 75;\n\n        \/\/ if ($src > 61) $diff += 0x2d - 0x30 - 10; \/\/ -13\n        $diff -= ((61 - $src) >> 8) & 13;\n\n        \/\/ if ($src > 62) $diff += 0x5f - 0x2b - 1; \/\/ 3\n        $diff += ((62 - $src) >> 8) & 49;\n\n        return pack('C', $src + $diff);\n    }\n}\n"}]