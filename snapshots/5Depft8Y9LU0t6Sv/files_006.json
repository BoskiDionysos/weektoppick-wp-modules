"[{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/ascii_extras_by_languages.php\",\"ext\":\"php\",\"size\":18290,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\nreturn [\\n    \/\/ Dutch (Flemish)\\n    'nl' => [\\n        '=' => ' gelijk ',\\n        '%' => ' procent ',\\n        '\u2211' => ' som ',\\n        '\u2206' => ' delta ',\\n        '\u221e' => ' oneindig ',\\n        '\u2665' => ' love ',\\n        '&' => ' en ',\\n        '+' => ' plus ',\\n    ],\\n    \/\/ Italian\\n    'it' => [\\n        '=' => ' uguale ',\\n        '%' => ' percent ',\\n        '\u2211' => ' somma ',\\n        '\u2206' => ' delta ',\\n        '\u221e' => ' infinito ',\\n        '\u2665' => ' amore ',\\n        '&' => ' e ',\\n        '+' => ' piu ',\\n    ],\\n    \/\/ Macedonian\\n    'mk' => [\\n        '=' => ' ednakva ',\\n        '%' => ' procenti ',\\n        '\u2211' => ' zbir ',\\n        '\u2206' => ' delta ',\\n        '\u221e' => ' beskonecnost ',\\n        '\u2665' => ' loveubov ',\\n        '&' => ' i ',\\n        '+' => ' plus ',\\n    ],\\n    \/\/ Portuguese (Brazil)\\n    'pt' => [\\n        '=' => ' igual ',\\n        '%' => ' por cento ',\\n        '\u2211' => ' soma ',\\n        '\u2206' => ' delta ',\\n        '\u221e' => ' infinito ',\\n        '\u2665' => ' amor ',\\n        '&' => ' e ',\\n        '+' => ' mais ',\\n    ],\\n    \/\/ Greek(lish) (Ell\u00e1da)\\n    'el__greeklish' => [\\n        '=' => ' isos ',\\n        '%' => ' tois ekato ',\\n        '\u2211' => ' athroisma ',\\n        '\u2206' => ' delta ',\\n        '\u221e' => ' apeiro ',\\n        '\u2665' => ' agape ',\\n        '&' => ' kai ',\\n        '+' => ' syn ',\\n    ],\\n    \/\/ Greek (Ell\u00e1da)\\n    'el' => [\\n        '=' => ' isos ',\\n        '%' => ' tois ekato ',\\n        '\u2211' => ' athroisma ',\\n        '\u2206' => ' delta ',\\n        '\u221e' => ' apeiro ',\\n        '\u2665' => ' agape ',\\n        '&' => ' kai ',\\n        '+' => ' syn ',\\n    ],\\n    \/\/ Hindi\\n    'hi' => [\\n        '=' => ' samana ',\\n        '%' => ' paratisata ',\\n        '\u2211' => ' yoga ',\\n        '\u2206' => ' dalata ',\\n        '\u221e' => ' anata ',\\n        '\u2665' => ' payara ',\\n        '&' => ' aura ',\\n        '+' => ' palasa ',\\n    ],\\n    \/\/ Armenian\\n    'hy' => [\\n        '=' => ' havasar ',\\n        '%' => ' tvokvos ',\\n        '\u2211' => ' gvoumar ',\\n        '\u2206' => ' delta ',\\n        '\u221e' => ' ansahmanvouthyvoun ',\\n        '\u2665' => ' ser ',\\n        '&' => ' ev ',\\n        '+' => ' gvoumarats ',\\n    ],\\n    \/\/ Swedish\\n    'sv' => [\\n        '=' => ' lika ',\\n        '%' => ' procent ',\\n        '\u2211' => ' summa ',\\n        '\u2206' => ' delta ',\\n        '\u221e' => ' oandlighet ',\\n        '\u2665' => ' alskar ',\\n        '&' => ' och ',\\n        '+' => ' plus ',\\n    ],\\n    \/\/ Turkmen\\n    'tk' => [\\n        '=' => ' den ',\\n        '%' => ' yuzde ',\\n        '\u2211' => ' jem ',\\n        '\u2206' => ' delta ',\\n        '\u221e' => ' mudimilik ',\\n        '\u2665' => ' soygi ',\\n        '&' => ' we ',\\n        '+' => ' yzy ',\\n    ],\\n    \/\/ Turkish\\n    'tr' => [\\n        '=' => ' esit ',\\n        '%' => ' yuzde ',\\n        '\u2211' => ' Toplam ',\\n        '\u2206' => ' delta ',\\n        '\u221e' => ' sonsuzluk ',\\n        '\u2665' => ' ask ',\\n        '&' => ' ve ',\\n        '+' => ' arti ',\\n    ],\\n    \/\/ Bulgarian\\n    'bg' => [\\n        '=' => ' raven ',\\n        '%' => ' na sto ',\\n        '\u2211' => ' suma ',\\n        '\u2206' => ' delta ',\\n        '\u221e' => ' bezkrajnost ',\\n        '\u2665' => ' obicam ',\\n        '&' => ' i ',\\n        '+' => ' plus ',\\n    ],\\n    \/\/ Hungarian\\n    'hu' => [\\n        '=' => ' Egyenlo ',\\n        '%' => ' Szazalek ',\\n        '\u2211' => ' osszeg ',\\n        '\u2206' => ' delta ',\\n        '\u221e' => ' vegtelenitett ',\\n        '\u2665' => ' love ',\\n        '&' => ' Es ',\\n        '+' => ' Plusz ',\\n    ],\\n    \/\/ Myanmar (Burmese)\\n    'my' => [\\n        '=' => ' ttn:ttnnym? ',\\n        '%' => ' raakhngnn:k ',\\n        '\u2211' => ' ld ',\\n        '\u2206' => ' m?cwk?n:pe? ',\\n        '\u221e' => ' ach:m ',\\n        '\u2665' => ' mettttaa ',\\n        '&' => ' n ',\\n        '+' => ' ape?ng: ',\\n    ],\\n    \/\/ Croatian (Hrvatska)\\n    'hr' => [\\n        '=' => ' Jednaki ',\\n        '%' => ' Posto ',\\n        '\u2211' => ' zbroj ',\\n        '\u2206' => ' Delta ',\\n        '\u221e' => ' beskonacno ',\\n        '\u2665' => ' ljubav ',\\n        '&' => ' I ',\\n        '+' => ' Plus ',\\n    ],\\n    \/\/ Finnish\\n    'fi' => [\\n        '=' => ' Sama ',\\n        '%' => ' Prosenttia ',\\n        '\u2211' => ' sum ',\\n        '\u2206' => ' delta ',\\n        '\u221e' => ' aareton ',\\n        '\u2665' => ' rakkautta ',\\n        '&' => ' Ja ',\\n        '+' => ' Plus ',\\n    ],\\n    \/\/ Georgian (Kartvelian)\\n    'ka' => [\\n        '=' => ' tanasts\\\\'ori ',\\n        '%' => ' p\\\\'rotsent\\\\'i ',\\n        '\u2211' => ' tankha ',\\n        '\u2206' => ' delt\\\\'a ',\\n        '\u221e' => ' usasrulo ',\\n        '\u2665' => ' siq\\\\'varuli ',\\n        '&' => ' da ',\\n        '+' => ' p\\\\'lus ',\\n    ],\\n    \/\/ Russian\\n    'ru' => [\\n        '=' => ' ravnyj ',\\n        '%' => ' procent ',\\n        '\u2211' => ' summa ',\\n        '\u2206' => ' del\\\\'ta ',\\n        '\u221e' => ' beskonecnost\\\\' ',\\n        '\u2665' => ' lublu ',\\n        '&' => ' i ',\\n        '+' => ' plus ',\\n    ],\\n    \/\/ Russian - GOST 7.79-2000(B)\\n    'ru__gost_2000_b' => [\\n        '=' => ' ravnyj ',\\n        '%' => ' procent ',\\n        '\u2211' => ' summa ',\\n        '\u2206' => ' del\\\\'ta ',\\n        '\u221e' => ' beskonecnost\\\\' ',\\n        '\u2665' => ' lublu ',\\n        '&' => ' i ',\\n        '+' => ' plus ',\\n    ],\\n    \/\/ Russian - Passport (2013), ICAO\\n    'ru__passport_2013' => [\\n        '=' => ' ravnyj ',\\n        '%' => ' procent ',\\n        '\u2211' => ' summa ',\\n        '\u2206' => ' del\\\\'ta ',\\n        '\u221e' => ' beskonecnost\\\\' ',\\n        '\u2665' => ' lublu ',\\n        '&' => ' i ',\\n        '+' => ' plus ',\\n    ],\\n    \/\/ Ukrainian\\n    'uk' => [\\n        '=' => ' rivnij ',\\n        '%' => ' vidsotkiv ',\\n        '\u2211' => ' suma ',\\n        '\u2206' => ' del\\\\'ta ',\\n        '\u221e' => ' neskincennist\\\\' ',\\n        '\u2665' => ' lubov ',\\n        '&' => ' i ',\\n        '+' => ' plus ',\\n    ],\\n    \/\/ Kazakh\\n    'kk' => [\\n        '=' => ' ten\\\\' ',\\n        '%' => ' Pajyzdar ',\\n        '\u2211' => ' zalpy ',\\n        '\u2206' => ' ajyrmasylyk, ',\\n        '\u221e' => ' seksiz ',\\n        '\u2665' => ' mahabbat ',\\n        '&' => ' z@ne ',\\n        '+' => ' plus ',\\n    ],\\n    \/\/ Czech\\n    'cs' => [\\n        '=' => ' rovnat se ',\\n        '%' => ' procento ',\\n        '\u2211' => ' soucet ',\\n        '\u2206' => ' delta ',\\n        '\u221e' => ' nekonecno ',\\n        '\u2665' => ' laska ',\\n        '&' => ' a ',\\n        '+' => ' plus ',\\n    ],\\n    \/\/ Danish\\n    'da' => [\\n        '=' => ' Lige ',\\n        '%' => ' Prozent ',\\n        '\u2211' => ' sum ',\\n        '\u2206' => ' delta ',\\n        '\u221e' => ' uendelig ',\\n        '\u2665' => ' kaerlighed ',\\n        '&' => ' Og ',\\n        '+' => ' Plus ',\\n    ],\\n    \/\/ Polish\\n    'pl' => [\\n        '=' => ' rowny ',\\n        '%' => ' procent ',\\n        '\u2211' => ' suma ',\\n        '\u2206' => ' delta ',\\n        '\u221e' => ' nieskonczonosc ',\\n        '\u2665' => ' milosc ',\\n        '&' => ' i ',\\n        '+' => ' plus ',\\n    ],\\n    \/\/ Romanian\\n    'ro' => [\\n        '=' => ' egal ',\\n        '%' => ' la suta ',\\n        '\u2211' => ' suma ',\\n        '\u2206' => ' delta ',\\n        '\u221e' => ' infinit ',\\n        '\u2665' => ' dragoste ',\\n        '&' => ' si ',\\n        '+' => ' la care se adauga ',\\n    ],\\n    \/\/ Esperanto\\n    'eo' => [\\n        '=' => ' Egalaj ',\\n        '%' => ' Procento ',\\n        '\u2211' => ' sumo ',\\n        '\u2206' => ' delto ',\\n        '\u221e' => ' senfina ',\\n        '\u2665' => ' amo ',\\n        '&' => ' Kaj ',\\n        '+' => ' Pli ',\\n    ],\\n    \/\/ Estonian\\n    'et' => [\\n        '=' => ' Vordsed ',\\n        '%' => ' Protsenti ',\\n        '\u2211' => ' summa ',\\n        '\u2206' => ' o ',\\n        '\u221e' => ' loputut ',\\n        '\u2665' => ' armastus ',\\n        '&' => ' Ja ',\\n        '+' => ' Pluss ',\\n    ],\\n    \/\/ Latvian\\n    'lv' => [\\n        '=' => ' vienads ',\\n        '%' => ' procents ',\\n        '\u2211' => ' summa ',\\n        '\u2206' => ' delta ',\\n        '\u221e' => ' bezgaliba ',\\n        '\u2665' => ' milestiba ',\\n        '&' => ' un ',\\n        '+' => ' pluss ',\\n    ],\\n    \/\/ Lithuanian\\n    'lt' => [\\n        '=' => ' lygus ',\\n        '%' => ' procentu ',\\n        '\u2211' => ' suma ',\\n        '\u2206' => ' delta ',\\n        '\u221e' => ' begalybe ',\\n        '\u2665' => ' meile ',\\n        '&' => ' ir ',\\n        '+' => ' plius ',\\n    ],\\n    \/\/ Norwegian\\n    'no' => [\\n        '=' => ' Lik ',\\n        '%' => ' Prosent ',\\n        '\u2211' => ' sum ',\\n        '\u2206' => ' delta ',\\n        '\u221e' => ' uendelig ',\\n        '\u2665' => ' kjaerlighet ',\\n        '&' => ' Og ',\\n        '+' => ' Pluss ',\\n    ],\\n    \/\/ Vietnamese\\n    'vi' => [\\n        '=' => ' cong bang ',\\n        '%' => ' phan tram ',\\n        '\u2211' => ' tong so ',\\n        '\u2206' => ' dong bang ',\\n        '\u221e' => ' vo cuc ',\\n        '\u2665' => ' Yeu ',\\n        '&' => ' va ',\\n        '+' => ' them ',\\n    ],\\n    \/\/ Arabic\\n    'ar' => [\\n        '=' => ' mtsawy ',\\n        '%' => ' nsbh mywyh ',\\n        '\u2211' => ' mjmw\\\\' ',\\n        '\u2206' => ' dlta ',\\n        '\u221e' => ' ma la nhayt ',\\n        '\u2665' => ' hb ',\\n        '&' => ' w ',\\n        '+' => ' zayd ',\\n    ],\\n    \/\/ Persian (Farsi)\\n    'fa' => [\\n        '=' => ' brabr ',\\n        '%' => ' dr sd ',\\n        '\u2211' => ' mjmw\\\\' ',\\n        '\u2206' => ' dlta ',\\n        '\u221e' => ' by nhayt ',\\n        '\u2665' => ' \\\\'shq ',\\n        '&' => ' w ',\\n        '+' => ' bh \\\\'lawh ',\\n    ],\\n    \/\/ Serbian\\n    'sr' => [\\n        '=' => ' jednak ',\\n        '%' => ' procenat ',\\n        '\u2211' => ' zbir ',\\n        '\u2206' => ' delta ',\\n        '\u221e' => ' beskraj ',\\n        '\u2665' => ' lubav ',\\n        '&' => ' i ',\\n        '+' => ' vise ',\\n    ],\\n    \/\/ Serbian - Cyrillic\\n    'sr__cyr' => [\\n        '=' => ' jednak ',\\n        '%' => ' procenat ',\\n        '\u2211' => ' zbir ',\\n        '\u2206' => ' delta ',\\n        '\u221e' => ' beskraj ',\\n        '\u2665' => ' lubav ',\\n        '&' => ' i ',\\n        '+' => ' vise ',\\n    ],\\n    \/\/ Serbian - Latin\\n    'sr__lat' => [\\n        '=' => ' jednak ',\\n        '%' => ' procenat ',\\n        '\u2211' => ' zbir ',\\n        '\u2206' => ' delta ',\\n        '\u221e' => ' beskraj ',\\n        '\u2665' => ' lubav ',\\n        '&' => ' i ',\\n        '+' => ' vise ',\\n    ],\\n    \/\/ Azerbaijani\\n    'az' => [\\n        '=' => ' b@rab@r ',\\n        '%' => ' faiz ',\\n        '\u2211' => ' m@bl@g ',\\n        '\u2206' => ' delta ',\\n        '\u221e' => ' sonsuzluq ',\\n        '\u2665' => ' sevgi ',\\n        '&' => ' v@ ',\\n        '+' => ' plus ',\\n    ],\\n    \/\/ Slovak\\n    'sk' => [\\n        '=' => ' rovny ',\\n        '%' => ' percento ',\\n        '\u2211' => ' sucet ',\\n        '\u2206' => ' delta ',\\n        '\u221e' => ' infinity ',\\n        '\u2665' => ' milovat ',\\n        '&' => ' a ',\\n        '+' => ' viac ',\\n    ],\\n    \/\/ French\\n    'fr' => [\\n        '=' => ' Egal ',\\n        '%' => ' Pourcentage ',\\n        '\u2211' => ' somme ',\\n        '\u2206' => ' delta ',\\n        '\u221e' => ' infini ',\\n        '\u2665' => ' amour ',\\n        '&' => ' Et ',\\n        '+' => ' Plus ',\\n    ],\\n    \/\/ Austrian (French)\\n    'fr_at' => [\\n        '=' => ' Egal ',\\n        '%' => ' Pourcentage ',\\n        '\u2211' => ' somme ',\\n        '\u2206' => ' delta ',\\n        '\u221e' => ' infini ',\\n        '\u2665' => ' amour ',\\n        '&' => ' Et ',\\n        '+' => ' Plus ',\\n    ],\\n    \/\/ Switzerland (French)\\n    'fr_ch' => [\\n        '=' => ' Egal ',\\n        '%' => ' Pourcentage ',\\n        '\u2211' => ' somme ',\\n        '\u2206' => ' delta ',\\n        '\u221e' => ' infini ',\\n        '\u2665' => ' amour ',\\n        '&' => ' Et ',\\n        '+' => ' Plus ',\\n    ],\\n    \/\/ German\\n    'de' => [\\n        '=' => ' gleich ',\\n        '%' => ' Prozent ',\\n        '\u2211' => ' gesamt ',\\n        '\u2206' => ' Unterschied ',\\n        '\u221e' => ' undendlich ',\\n        '\u2665' => ' liebe ',\\n        '&' => ' und ',\\n        '+' => ' plus ',\\n    ],\\n    \/\/ Austrian (German)\\n    'de_at' => [\\n        '=' => ' gleich ',\\n        '%' => ' Prozent ',\\n        '\u2211' => ' gesamt ',\\n        '\u2206' => ' Unterschied ',\\n        '\u221e' => ' undendlich ',\\n        '\u2665' => ' liebe ',\\n        '&' => ' und ',\\n        '+' => ' plus ',\\n    ],\\n    \/\/ Switzerland (German)\\n    'de_ch' => [\\n        '=' => ' gleich ',\\n        '%' => ' Prozent ',\\n        '\u2211' => ' gesamt ',\\n        '\u2206' => ' Unterschied ',\\n        '\u221e' => ' undendlich ',\\n        '\u2665' => ' liebe ',\\n        '&' => ' und ',\\n        '+' => ' plus ',\\n    ],\\n    \/\/ Bengali (Bangla)\\n    'bn' => [\\n        '=' => ' Saman ',\\n        '%' => ' Satakora ',\\n        '\u2211' => ' Samasti ',\\n        '\u2206' => ' Badhip ',\\n        '\u221e' => ' Ananta ',\\n        '\u2665' => ' Valobasa ',\\n        '&' => ' Abong ',\\n        '+' => ' Songzojon ',\\n    ],\\n    \/\/ English\\n    'en' => [\\n        '=' => ' equal ',\\n        '%' => ' percent ',\\n        '\u2211' => ' sum ',\\n        '\u2206' => ' delta ',\\n        '\u221e' => ' infinity ',\\n        '\u2665' => ' love ',\\n        '&' => ' and ',\\n        '+' => ' plus ',\\n    ],\\n    \/\/ Currency\\n    \/\/\\n    \/\/ url: https:\/\/en.wikipedia.org\/wiki\/Currency_symbol\\n    'currency' => [\\n        '\u20ac'  => ' Euro ',\\n        '$'  => ' Dollar ',\\n        '\u20a2'  => ' cruzeiro ',\\n        '\u20a3'  => ' French franc ',\\n        '\u00a3'  => ' pound ',\\n        '\u20a4'  => ' lira ', \/\/ Italian\\n        '\u20b6'  => ' livre tournois ',\\n        '\u2133'  => ' mark ',\\n        '\u20a5'  => ' mill ',\\n        '\u20a6'  => ' naira ',\\n        '\u20a7'  => ' peseta ',\\n        '\u20a8'  => ' rupee ',\\n        '\u0dbb\u0dd4' => ' rupee ', \/\/ Sri Lankan\\n        '\u0bb0\u0bc2' => ' rupee ', \/\/ Sri Lankan\\n        '\u0bf9'  => ' rupee ', \/\/ Tamil\\n        '\u0930\u0942' => ' rupee ', \/\/ Nepalese\\n        '\u20b9'  => ' rupee ', \/\/ Indian\\n        '\u0af1'  => ' rupee ', \/\/ Gujarat\\n        '\u20a9'  => ' won ',\\n        '\u20aa'  => ' new shequel ',\\n        '\u20b8'  => ' tenge ',\\n        '\u20ab'  => ' dong ',\\n        '\u058f'  => ' dram ',\\n        '\u20ad'  => ' kip ',\\n        '\u20ba'  => ' lira ', \/\/ Turkish\\n        '\u20bc'  => ' manat ',\\n        '\u20ae'  => ' tugrik ',\\n        '\u20af'  => ' drachma ',\\n        '\u20b0'  => ' pfennig ',\\n        '\u20b7'  => ' spesmilo ',\\n        '\u20b1'  => ' peso ', \/\/ Philippine\\n        '\ufdfc\u200e' => ' riyal ',\\n        '\u20b2'  => ' guarani ',\\n        '\u20be'  => ' lari ',\\n        '\u20b3'  => ' austral ',\\n        '\u20b4'  => ' hryvnia ',\\n        '\u20bd'  => ' ruble ',\\n        '\u20b5'  => ' cedi ',\\n        '\u20a1'  => ' colon ',\\n        '\u00a2'  => ' cent ',\\n        '\u00a5'  => ' yen ',\\n        '\u5186'  => ' yen ',\\n        '\u09f3'  => ' taka ',\\n        '\u5143'  => ' yuan ',\\n        '\ufdfc'  => ' riyal ',\\n        '\u17db'  => ' riel ',\\n        '\u20a0'  => ' European Currency ',\\n        '\u00a4'  => ' currency ',\\n        '\u0e3f'  => ' baht ',\\n        '\u060b'  => ' afghani ',\\n    ],\\n    \/\/ Temperature\\n    \/\/\\n    \/\/ url: https:\/\/en.wikipedia.org\/wiki\/Conversion_of_units_of_temperature\\n    'temperature' => [\\n        '\u00b0De' => ' Delisle ',\\n        '\u00b0Re' => ' Reaumur ', \/\/ R\u00e9aumur\\n        '\u00b0Ro' => ' Romer ', \/\/ R\u00f8mer\\n        '\u00b0R'  => ' Rankine ',\\n        '\u00b0C'  => ' Celsius ',\\n        '\u00b0F'  => ' Fahrenheit ',\\n        '\u00b0N'  => ' Newton ',\\n    ],\\n    'latin_symbols' => [\\n        '=' => '=',\\n        '%' => '%',\\n        '\u2211' => '\u2211',\\n        '\u2206' => '\u2206',\\n        '\u221e' => '\u221e',\\n        '\u2665' => '\u2665',\\n        '&' => '&',\\n        '+' => '+',\\n        \/\/ ---\\n        '\u00a9' => ' (c) ',\\n        '\u00ae' => ' (r) ',\\n        '@' => ' (at) ',\\n        '\u2116' => ' No. ',\\n        '\u211e' => ' Rx ',\\n        '\uff3b' => '[',\\n        '\uff3c' => '\\\\\\\\',\\n        '\uff3d' => ']',\\n        '\uff3e' => '^',\\n        '\uff3f' => '_',\\n        '\uff40' => '`',\\n        '\u2010' => '-',\\n        '\u2011' => '-',\\n        '\u2012' => '-',\\n        '\u2013' => '-',\\n        '\u2212' => '-',\\n        '\u2014' => '-',\\n        '\u2015' => '-',\\n        '\ufe58' => '-',\\n        '\u2502' => '|',\\n        '\u2216' => '\\\\\\\\',\\n        '\u2215' => '\/',\\n        '\u2044' => '\/',\\n        '\uffe9' => '<-',\\n        '\uffeb' => '->',\\n        '\uffea' => '|',\\n        '\uffec' => '|',\\n        '\u2045' => '[',\\n        '\u2046' => ']',\\n        '\u204e' => '*',\\n        '\u3001' => ',',\\n        '\u3002' => '.',\\n        '\u3008' => '<',\\n        '\u3009' => '>',\\n        '\u300a' => '<<',\\n        '\u300b' => '>>',\\n        '\u3014' => '[',\\n        '\u3015' => ']',\\n        '\u3018' => '[',\\n        '\u3019' => ']',\\n        '\u301a' => '[',\\n        '\u301b' => ']',\\n        '\ufe5d' => '[',\\n        '\ufe5e' => ']',\\n        '\ufe39' => '[',\\n        '\ufe3a' => ']',\\n        '\ufe47' => '[',\\n        '\ufe48' => ']',\\n        '\ufe10' => ',',\\n        '\ufe11' => ',',\\n        '\ufe12' => '.',\\n        '\ufe13' => ':',\\n        '\ufe14' => ';',\\n        '\ufe15' => '!',\\n        '\ufe16' => '?',\\n        '\ufe19' => '...',\\n        '\ufe30' => '..',\\n        '\ufe35' => '(',\\n        '\ufe36' => ')',\\n        '\ufe59' => '(',\\n        '\ufe5a' => ')',\\n        '\ufe37' => '{',\\n        '\ufe38' => '}',\\n        '\ufe5b' => '{',\\n        '\ufe5c' => '}',\\n        '\ufe3d' => '<<',\\n        '\ufe3e' => '>>',\\n        '\ufe3f' => '<',\\n        '\ufe40' => '>',\\n        '\u00d7' => '*',\\n        '\u00f7' => '\/',\\n        '\u226a' => '<<',\\n        '\u226b' => '>>',\\n        '\u2985' => '((',\\n        '\u2986' => '))',\\n        '\u3007' => '0',\\n        '\u2032' => '\\\\'',\\n        '\u301d' => '\\\"',\\n        '\u301e' => '\\\"',\\n        '\u00ab' => '<<',\\n        '\u00bb' => '>>',\\n        '\u2018' => \\\"'\\\",\\n        '\u2019' => \\\"'\\\",\\n        '\u201a' => ',',\\n        '\u201b' => \\\"'\\\",\\n        '\u201c' => '\\\"',\\n        '\u201d' => '\\\"',\\n        '\u201e' => '\\\"',\\n        '\u201f' => '\\\"',\\n        '\u2039' => '<',\\n        '\u203a' => '>',\\n        '\u2024' => '.',\\n        '\u2025' => '..',\\n        '\u2026' => '...',\\n        '\u2033' => '\\\"',\\n        '\u2034' => '\\\\'\\\\'\\\\'',\\n        '\u2036' => '``',\\n        '\u2037' => '```',\\n        '\u203c' => '!!',\\n        '\u2047' => '??',\\n        '\u2048' => '?!',\\n        '\u2049' => '!?',\\n        '\u2057' => '````',\\n        '\u2a74' => '::=',\\n        '\u2a75' => '==',\\n        '\u2a76' => '===',\\n        '\ufe54' => ';',\\n        '\ufe55' => ':',\\n        '\ufe56' => '?',\\n        '\ufe57' => '!',\\n        '\ufe4d' => '_',\\n        '\ufe4e' => '_',\\n        '\ufe4f' => '_',\\n        '\ufe50' => ',',\\n        '\ufe51' => ',',\\n        '\ufe52' => '.',\\n        '\ufe5f' => '#',\\n        '\ufe60' => '&',\\n        '\ufe61' => '*',\\n        '\ufe62' => '+',\\n        '\ufe63' => '-',\\n        '\ufe64' => '<',\\n        '\ufe65' => '>',\\n        '\ufe66' => '=',\\n        '\ufe68' => '\\\\\\\\',\\n        '\ufe69' => '$',\\n        '\ufe6a' => '%',\\n        '\ufe6b' => '@',\\n        '\uff01' => '!',\\n        '\uff02' => '\\\"',\\n        '\uff03' => '#',\\n        '\uff04' => '$',\\n        '\uff05' => '%',\\n        '\uff06' => '&',\\n        '\uff07' => '\\\\'',\\n        '\uff08' => '(',\\n        '\uff09' => ')',\\n        '\uff0a' => '*',\\n        '\uff0b' => '+',\\n        '\uff0c' => ',',\\n        '\uff0d' => '-',\\n        '\uff0e' => '.',\\n        '\uff0f' => '\/',\\n        '\uff1a' => ':',\\n        '\uff1b' => ';',\\n        '\uff1c' => '<',\\n        '\uff1d' => '=',\\n        '\uff1e' => '>',\\n        '\uff1f' => '?',\\n        '\uff20' => '@',\\n        '\uff5b' => '{',\\n        '\uff5c' => '|',\\n        '\uff5d' => '}',\\n        '\uff5e' => '~',\\n        '\uff5f' => '((',\\n        '\uff60' => '))',\\n        '\uffe2' => '!',\\n        '\uffe3' => '-',\\n        '\uffe4' => '|',\\n        '\uffed' => '#',\\n    ],\\n];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/x0bb.php\",\"ext\":\"php\",\"size\":2174,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php return ['moen', 'moenj', 'moenh', 'moed', 'moel', 'moelg', 'moelm', 'moelb', 'moels', 'moelt', 'moelp', 'moelh', 'moem', 'moeb', 'moebs', 'moes', 'moess', 'moeng', 'moej', 'moec', 'moek', 'moet', 'moep', 'moeh', 'myo', 'myog', 'myogg', 'myogs', 'myon', 'myonj', 'myonh', 'myod', 'myol', 'myolg', 'myolm', 'myolb', 'myols', 'myolt', 'myolp', 'myolh', 'myom', 'myob', 'myobs', 'myos', 'myoss', 'myong', 'myoj', 'myoc', 'myok', 'myot', 'myop', 'myoh', 'mu', 'mug', 'mugg', 'mugs', 'mun', 'munj', 'munh', 'mud', 'mul', 'mulg', 'mulm', 'mulb', 'muls', 'mult', 'mulp', 'mulh', 'mum', 'mub', 'mubs', 'mus', 'muss', 'mung', 'muj', 'muc', 'muk', 'mut', 'mup', 'muh', 'mweo', 'mweog', 'mweogg', 'mweogs', 'mweon', 'mweonj', 'mweonh', 'mweod', 'mweol', 'mweolg', 'mweolm', 'mweolb', 'mweols', 'mweolt', 'mweolp', 'mweolh', 'mweom', 'mweob', 'mweobs', 'mweos', 'mweoss', 'mweong', 'mweoj', 'mweoc', 'mweok', 'mweot', 'mweop', 'mweoh', 'mwe', 'mweg', 'mwegg', 'mwegs', 'mwen', 'mwenj', 'mwenh', 'mwed', 'mwel', 'mwelg', 'mwelm', 'mwelb', 'mwels', 'mwelt', 'mwelp', 'mwelh', 'mwem', 'mweb', 'mwebs', 'mwes', 'mwess', 'mweng', 'mwej', 'mwec', 'mwek', 'mwet', 'mwep', 'mweh', 'mwi', 'mwig', 'mwigg', 'mwigs', 'mwin', 'mwinj', 'mwinh', 'mwid', 'mwil', 'mwilg', 'mwilm', 'mwilb', 'mwils', 'mwilt', 'mwilp', 'mwilh', 'mwim', 'mwib', 'mwibs', 'mwis', 'mwiss', 'mwing', 'mwij', 'mwic', 'mwik', 'mwit', 'mwip', 'mwih', 'myu', 'myug', 'myugg', 'myugs', 'myun', 'myunj', 'myunh', 'myud', 'myul', 'myulg', 'myulm', 'myulb', 'myuls', 'myult', 'myulp', 'myulh', 'myum', 'myub', 'myubs', 'myus', 'myuss', 'myung', 'myuj', 'myuc', 'myuk', 'myut', 'myup', 'myuh', 'meu', 'meug', 'meugg', 'meugs', 'meun', 'meunj', 'meunh', 'meud', 'meul', 'meulg', 'meulm', 'meulb', 'meuls', 'meult', 'meulp', 'meulh', 'meum', 'meub', 'meubs', 'meus', 'meuss', 'meung', 'meuj', 'meuc', 'meuk', 'meut', 'meup', 'meuh', 'myi', 'myig', 'myigg', 'myigs', 'myin', 'myinj', 'myinh', 'myid', 'myil', 'myilg', 'myilm', 'myilb', 'myils', 'myilt', 'myilp', 'myilh', 'myim', 'myib', 'myibs', 'myis', 'myiss', 'mying', 'myij', 'myic', 'myik', 'myit', 'myip', 'myih', 'mi', 'mig', 'migg', 'migs', 'min', 'minj', 'minh', 'mid'];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/x017.php\",\"ext\":\"php\",\"size\":1644,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php return ['[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', 'k', 'kh', 'g', 'gh', 'ng', 'c', 'ch', 'j', 'jh', 'ny', 't', 'tth', 'd', 'ddh', 'nn', 't', 'th', 'd', 'dh', 'n', 'p', 'ph', 'b', 'bh', 'm', 'y', 'r', 'l', 'v', 'sh', 'ss', 's', 'h', 'l', 'q', 'a', 'aa', 'i', 'ii', 'u', 'uk', 'uu', 'uuv', 'ry', 'ryy', 'ly', 'lyy', 'e', 'ai', 'oo', 'oo', 'au', 'a', 'aa', 'aa', 'i', 'ii', 'y', 'yy', 'u', 'uu', 'ua', 'oe', 'ya', 'ie', 'e', 'ae', 'ai', 'oo', 'au', 'M', 'H', 'a`', '', '', '', 'r', '', '!', '', '', '', '', '', '.', ' \/\/ ', ':', '+', '++', ' * ', ' \/\/\/ ', 'KR', '\\\\'', '[?]', '[?]', '[?]', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]'];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/x097.php\",\"ext\":\"php\",\"size\":2087,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php return ['Xu ', 'Ji ', 'Mu ', 'Chen ', 'Xiao ', 'Zha ', 'Ting ', 'Zhen ', 'Pei ', 'Mei ', 'Ling ', 'Qi ', 'Chou ', 'Huo ', 'Sha ', 'Fei ', 'Weng ', 'Zhan ', 'Yin ', 'Ni ', 'Chou ', 'Tun ', 'Lin ', '[?] ', 'Dong ', 'Ying ', 'Wu ', 'Ling ', 'Shuang ', 'Ling ', 'Xia ', 'Hong ', 'Yin ', 'Mo ', 'Mai ', 'Yun ', 'Liu ', 'Meng ', 'Bin ', 'Wu ', 'Wei ', 'Huo ', 'Yin ', 'Xi ', 'Yi ', 'Ai ', 'Dan ', 'Deng ', 'Xian ', 'Yu ', 'Lu ', 'Long ', 'Dai ', 'Ji ', 'Pang ', 'Yang ', 'Ba ', 'Pi ', 'Wei ', '[?] ', 'Xi ', 'Ji ', 'Mai ', 'Meng ', 'Meng ', 'Lei ', 'Li ', 'Huo ', 'Ai ', 'Fei ', 'Dai ', 'Long ', 'Ling ', 'Ai ', 'Feng ', 'Li ', 'Bao ', '[?] ', 'He ', 'He ', 'Bing ', 'Qing ', 'Qing ', 'Jing ', 'Tian ', 'Zhen ', 'Jing ', 'Cheng ', 'Qing ', 'Jing ', 'Jing ', 'Dian ', 'Jing ', 'Tian ', 'Fei ', 'Fei ', 'Kao ', 'Mi ', 'Mian ', 'Mian ', 'Pao ', 'Ye ', 'Tian ', 'Hui ', 'Ye ', 'Ge ', 'Ding ', 'Cha ', 'Jian ', 'Ren ', 'Di ', 'Du ', 'Wu ', 'Ren ', 'Qin ', 'Jin ', 'Xue ', 'Niu ', 'Ba ', 'Yin ', 'Sa ', 'Na ', 'Mo ', 'Zu ', 'Da ', 'Ban ', 'Yi ', 'Yao ', 'Tao ', 'Tuo ', 'Jia ', 'Hong ', 'Pao ', 'Yang ', 'Tomo ', 'Yin ', 'Jia ', 'Tao ', 'Ji ', 'Xie ', 'An ', 'An ', 'Hen ', 'Gong ', 'Kohaze ', 'Da ', 'Qiao ', 'Ting ', 'Wan ', 'Ying ', 'Sui ', 'Tiao ', 'Qiao ', 'Xuan ', 'Kong ', 'Beng ', 'Ta ', 'Zhang ', 'Bing ', 'Kuo ', 'Ju ', 'La ', 'Xie ', 'Rou ', 'Bang ', 'Yi ', 'Qiu ', 'Qiu ', 'He ', 'Xiao ', 'Mu ', 'Ju ', 'Jian ', 'Bian ', 'Di ', 'Jian ', 'On ', 'Tao ', 'Gou ', 'Ta ', 'Bei ', 'Xie ', 'Pan ', 'Ge ', 'Bi ', 'Kuo ', 'Tang ', 'Lou ', 'Gui ', 'Qiao ', 'Xue ', 'Ji ', 'Jian ', 'Jiang ', 'Chan ', 'Da ', 'Huo ', 'Xian ', 'Qian ', 'Du ', 'Wa ', 'Jian ', 'Lan ', 'Wei ', 'Ren ', 'Fu ', 'Mei ', 'Juan ', 'Ge ', 'Wei ', 'Qiao ', 'Han ', 'Chang ', '[?] ', 'Rou ', 'Xun ', 'She ', 'Wei ', 'Ge ', 'Bei ', 'Tao ', 'Gou ', 'Yun ', '[?] ', 'Bi ', 'Wei ', 'Hui ', 'Du ', 'Wa ', 'Du ', 'Wei ', 'Ren ', 'Fu ', 'Han ', 'Wei ', 'Yun ', 'Tao ', 'Jiu ', 'Jiu ', 'Xian ', 'Xie ', 'Xian ', 'Ji ', 'Yin ', 'Za ', 'Yun ', 'Shao ', 'Le ', 'Peng ', 'Heng ', 'Ying ', 'Yun ', 'Peng ', 'Yin ', 'Yin ', 'Xiang '];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/x1d4.php\",\"ext\":\"php\",\"size\":1382,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php return ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 26 => 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 52 => 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 78 => 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 104 => 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 130 => 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 156 => 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 181 => 'Z', 182 => 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 208 => 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 234 => 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/x0bc.php\",\"ext\":\"php\",\"size\":2151,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php return ['mil', 'milg', 'milm', 'milb', 'mils', 'milt', 'milp', 'milh', 'mim', 'mib', 'mibs', 'mis', 'miss', 'ming', 'mij', 'mic', 'mik', 'mit', 'mip', 'mih', 'ba', 'bag', 'bagg', 'bags', 'ban', 'banj', 'banh', 'bad', 'bal', 'balg', 'balm', 'balb', 'bals', 'balt', 'balp', 'balh', 'bam', 'bab', 'babs', 'bas', 'bass', 'bang', 'baj', 'bac', 'bak', 'bat', 'bap', 'bah', 'bae', 'baeg', 'baegg', 'baegs', 'baen', 'baenj', 'baenh', 'baed', 'bael', 'baelg', 'baelm', 'baelb', 'baels', 'baelt', 'baelp', 'baelh', 'baem', 'baeb', 'baebs', 'baes', 'baess', 'baeng', 'baej', 'baec', 'baek', 'baet', 'baep', 'baeh', 'bya', 'byag', 'byagg', 'byags', 'byan', 'byanj', 'byanh', 'byad', 'byal', 'byalg', 'byalm', 'byalb', 'byals', 'byalt', 'byalp', 'byalh', 'byam', 'byab', 'byabs', 'byas', 'byass', 'byang', 'byaj', 'byac', 'byak', 'byat', 'byap', 'byah', 'byae', 'byaeg', 'byaegg', 'byaegs', 'byaen', 'byaenj', 'byaenh', 'byaed', 'byael', 'byaelg', 'byaelm', 'byaelb', 'byaels', 'byaelt', 'byaelp', 'byaelh', 'byaem', 'byaeb', 'byaebs', 'byaes', 'byaess', 'byaeng', 'byaej', 'byaec', 'byaek', 'byaet', 'byaep', 'byaeh', 'beo', 'beog', 'beogg', 'beogs', 'beon', 'beonj', 'beonh', 'beod', 'beol', 'beolg', 'beolm', 'beolb', 'beols', 'beolt', 'beolp', 'beolh', 'beom', 'beob', 'beobs', 'beos', 'beoss', 'beong', 'beoj', 'beoc', 'beok', 'beot', 'beop', 'beoh', 'be', 'beg', 'begg', 'begs', 'ben', 'benj', 'benh', 'bed', 'bel', 'belg', 'belm', 'belb', 'bels', 'belt', 'belp', 'belh', 'bem', 'beb', 'bebs', 'bes', 'bess', 'beng', 'bej', 'bec', 'bek', 'bet', 'bep', 'beh', 'byeo', 'byeog', 'byeogg', 'byeogs', 'byeon', 'byeonj', 'byeonh', 'byeod', 'byeol', 'byeolg', 'byeolm', 'byeolb', 'byeols', 'byeolt', 'byeolp', 'byeolh', 'byeom', 'byeob', 'byeobs', 'byeos', 'byeoss', 'byeong', 'byeoj', 'byeoc', 'byeok', 'byeot', 'byeop', 'byeoh', 'bye', 'byeg', 'byegg', 'byegs', 'byen', 'byenj', 'byenh', 'byed', 'byel', 'byelg', 'byelm', 'byelb', 'byels', 'byelt', 'byelp', 'byelh', 'byem', 'byeb', 'byebs', 'byes', 'byess', 'byeng', 'byej', 'byec', 'byek', 'byet', 'byep', 'byeh', 'bo', 'bog', 'bogg', 'bogs', 'bon', 'bonj', 'bonh', 'bod', 'bol', 'bolg', 'bolm', 'bolb'];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/x088.php\",\"ext\":\"php\",\"size\":2089,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php return ['Ci ', 'Xiang ', 'She ', 'Luo ', 'Qin ', 'Ying ', 'Chai ', 'Li ', 'Ze ', 'Xuan ', 'Lian ', 'Zhu ', 'Ze ', 'Xie ', 'Mang ', 'Xie ', 'Qi ', 'Rong ', 'Jian ', 'Meng ', 'Hao ', 'Ruan ', 'Huo ', 'Zhuo ', 'Jie ', 'Bin ', 'He ', 'Mie ', 'Fan ', 'Lei ', 'Jie ', 'La ', 'Mi ', 'Li ', 'Chun ', 'Li ', 'Qiu ', 'Nie ', 'Lu ', 'Du ', 'Xiao ', 'Zhu ', 'Long ', 'Li ', 'Long ', 'Feng ', 'Ye ', 'Beng ', 'Shang ', 'Gu ', 'Juan ', 'Ying ', '[?] ', 'Xi ', 'Can ', 'Qu ', 'Quan ', 'Du ', 'Can ', 'Man ', 'Jue ', 'Jie ', 'Zhu ', 'Zha ', 'Xie ', 'Huang ', 'Niu ', 'Pei ', 'Nu ', 'Xin ', 'Zhong ', 'Mo ', 'Er ', 'Ke ', 'Mie ', 'Xi ', 'Xing ', 'Yan ', 'Kan ', 'Yuan ', '[?] ', 'Ling ', 'Xuan ', 'Shu ', 'Xian ', 'Tong ', 'Long ', 'Jie ', 'Xian ', 'Ya ', 'Hu ', 'Wei ', 'Dao ', 'Chong ', 'Wei ', 'Dao ', 'Zhun ', 'Heng ', 'Qu ', 'Yi ', 'Yi ', 'Bu ', 'Gan ', 'Yu ', 'Biao ', 'Cha ', 'Yi ', 'Shan ', 'Chen ', 'Fu ', 'Gun ', 'Fen ', 'Shuai ', 'Jie ', 'Na ', 'Zhong ', 'Dan ', 'Ri ', 'Zhong ', 'Zhong ', 'Xie ', 'Qi ', 'Xie ', 'Ran ', 'Zhi ', 'Ren ', 'Qin ', 'Jin ', 'Jun ', 'Yuan ', 'Mei ', 'Chai ', 'Ao ', 'Niao ', 'Hui ', 'Ran ', 'Jia ', 'Tuo ', 'Ling ', 'Dai ', 'Bao ', 'Pao ', 'Yao ', 'Zuo ', 'Bi ', 'Shao ', 'Tan ', 'Ju ', 'He ', 'Shu ', 'Xiu ', 'Zhen ', 'Yi ', 'Pa ', 'Bo ', 'Di ', 'Wa ', 'Fu ', 'Gun ', 'Zhi ', 'Zhi ', 'Ran ', 'Pan ', 'Yi ', 'Mao ', 'Tuo ', 'Na ', 'Kou ', 'Xian ', 'Chan ', 'Qu ', 'Bei ', 'Gun ', 'Xi ', 'Ne ', 'Bo ', 'Horo ', 'Fu ', 'Yi ', 'Chi ', 'Ku ', 'Ren ', 'Jiang ', 'Jia ', 'Cun ', 'Mo ', 'Jie ', 'Er ', 'Luo ', 'Ru ', 'Zhu ', 'Gui ', 'Yin ', 'Cai ', 'Lie ', 'Kamishimo ', 'Yuki ', 'Zhuang ', 'Dang ', '[?] ', 'Kun ', 'Ken ', 'Niao ', 'Shu ', 'Jia ', 'Kun ', 'Cheng ', 'Li ', 'Juan ', 'Shen ', 'Pou ', 'Ge ', 'Yi ', 'Yu ', 'Zhen ', 'Liu ', 'Qiu ', 'Qun ', 'Ji ', 'Yi ', 'Bu ', 'Zhuang ', 'Shui ', 'Sha ', 'Qun ', 'Li ', 'Lian ', 'Lian ', 'Ku ', 'Jian ', 'Fou ', 'Chan ', 'Bi ', 'Gun ', 'Tao ', 'Yuan ', 'Ling ', 'Chi ', 'Chang ', 'Chou ', 'Duo ', 'Biao ', 'Liang ', 'Chang ', 'Pei ', 'Pei ', 'Fei ', 'Yuan ', 'Luo ', 'Guo ', 'Yan ', 'Du ', 'Xi ', 'Zhi ', 'Ju ', 'Qi '];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/x0be.php\",\"ext\":\"php\",\"size\":2293,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php return ['byum', 'byub', 'byubs', 'byus', 'byuss', 'byung', 'byuj', 'byuc', 'byuk', 'byut', 'byup', 'byuh', 'beu', 'beug', 'beugg', 'beugs', 'beun', 'beunj', 'beunh', 'beud', 'beul', 'beulg', 'beulm', 'beulb', 'beuls', 'beult', 'beulp', 'beulh', 'beum', 'beub', 'beubs', 'beus', 'beuss', 'beung', 'beuj', 'beuc', 'beuk', 'beut', 'beup', 'beuh', 'byi', 'byig', 'byigg', 'byigs', 'byin', 'byinj', 'byinh', 'byid', 'byil', 'byilg', 'byilm', 'byilb', 'byils', 'byilt', 'byilp', 'byilh', 'byim', 'byib', 'byibs', 'byis', 'byiss', 'bying', 'byij', 'byic', 'byik', 'byit', 'byip', 'byih', 'bi', 'big', 'bigg', 'bigs', 'bin', 'binj', 'binh', 'bid', 'bil', 'bilg', 'bilm', 'bilb', 'bils', 'bilt', 'bilp', 'bilh', 'bim', 'bib', 'bibs', 'bis', 'biss', 'bing', 'bij', 'bic', 'bik', 'bit', 'bip', 'bih', 'bba', 'bbag', 'bbagg', 'bbags', 'bban', 'bbanj', 'bbanh', 'bbad', 'bbal', 'bbalg', 'bbalm', 'bbalb', 'bbals', 'bbalt', 'bbalp', 'bbalh', 'bbam', 'bbab', 'bbabs', 'bbas', 'bbass', 'bbang', 'bbaj', 'bbac', 'bbak', 'bbat', 'bbap', 'bbah', 'bbae', 'bbaeg', 'bbaegg', 'bbaegs', 'bbaen', 'bbaenj', 'bbaenh', 'bbaed', 'bbael', 'bbaelg', 'bbaelm', 'bbaelb', 'bbaels', 'bbaelt', 'bbaelp', 'bbaelh', 'bbaem', 'bbaeb', 'bbaebs', 'bbaes', 'bbaess', 'bbaeng', 'bbaej', 'bbaec', 'bbaek', 'bbaet', 'bbaep', 'bbaeh', 'bbya', 'bbyag', 'bbyagg', 'bbyags', 'bbyan', 'bbyanj', 'bbyanh', 'bbyad', 'bbyal', 'bbyalg', 'bbyalm', 'bbyalb', 'bbyals', 'bbyalt', 'bbyalp', 'bbyalh', 'bbyam', 'bbyab', 'bbyabs', 'bbyas', 'bbyass', 'bbyang', 'bbyaj', 'bbyac', 'bbyak', 'bbyat', 'bbyap', 'bbyah', 'bbyae', 'bbyaeg', 'bbyaegg', 'bbyaegs', 'bbyaen', 'bbyaenj', 'bbyaenh', 'bbyaed', 'bbyael', 'bbyaelg', 'bbyaelm', 'bbyaelb', 'bbyaels', 'bbyaelt', 'bbyaelp', 'bbyaelh', 'bbyaem', 'bbyaeb', 'bbyaebs', 'bbyaes', 'bbyaess', 'bbyaeng', 'bbyaej', 'bbyaec', 'bbyaek', 'bbyaet', 'bbyaep', 'bbyaeh', 'bbeo', 'bbeog', 'bbeogg', 'bbeogs', 'bbeon', 'bbeonj', 'bbeonh', 'bbeod', 'bbeol', 'bbeolg', 'bbeolm', 'bbeolb', 'bbeols', 'bbeolt', 'bbeolp', 'bbeolh', 'bbeom', 'bbeob', 'bbeobs', 'bbeos', 'bbeoss', 'bbeong', 'bbeoj', 'bbeoc', 'bbeok', 'bbeot', 'bbeop', 'bbeoh', 'bbe', 'bbeg', 'bbegg', 'bbegs', 'bben', 'bbenj', 'bbenh', 'bbed', 'bbel', 'bbelg', 'bbelm', 'bbelb', 'bbels', 'bbelt', 'bbelp', 'bbelh', 'bbem', 'bbeb', 'bbebs', 'bbes'];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/x071.php\",\"ext\":\"php\",\"size\":2114,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php return ['Hu ', 'Xi ', 'Shu ', 'He ', 'Xun ', 'Ku ', 'Jue ', 'Xiao ', 'Xi ', 'Yan ', 'Han ', 'Zhuang ', 'Jun ', 'Di ', 'Xie ', 'Ji ', 'Wu ', '[?] ', '[?] ', 'Han ', 'Yan ', 'Huan ', 'Men ', 'Ju ', 'Chou ', 'Bei ', 'Fen ', 'Lin ', 'Kun ', 'Hun ', 'Tun ', 'Xi ', 'Cui ', 'Wu ', 'Hong ', 'Ju ', 'Fu ', 'Wo ', 'Jiao ', 'Cong ', 'Feng ', 'Ping ', 'Qiong ', 'Ruo ', 'Xi ', 'Qiong ', 'Xin ', 'Zhuo ', 'Yan ', 'Yan ', 'Yi ', 'Jue ', 'Yu ', 'Gang ', 'Ran ', 'Pi ', 'Gu ', '[?] ', 'Sheng ', 'Chang ', 'Shao ', '[?] ', '[?] ', '[?] ', '[?] ', 'Chen ', 'He ', 'Kui ', 'Zhong ', 'Duan ', 'Xia ', 'Hui ', 'Feng ', 'Lian ', 'Xuan ', 'Xing ', 'Huang ', 'Jiao ', 'Jian ', 'Bi ', 'Ying ', 'Zhu ', 'Wei ', 'Tuan ', 'Tian ', 'Xi ', 'Nuan ', 'Nuan ', 'Chan ', 'Yan ', 'Jiong ', 'Jiong ', 'Yu ', 'Mei ', 'Sha ', 'Wei ', 'Ye ', 'Xin ', 'Qiong ', 'Rou ', 'Mei ', 'Huan ', 'Xu ', 'Zhao ', 'Wei ', 'Fan ', 'Qiu ', 'Sui ', 'Yang ', 'Lie ', 'Zhu ', 'Jie ', 'Gao ', 'Gua ', 'Bao ', 'Hu ', 'Yun ', 'Xia ', '[?] ', '[?] ', 'Bian ', 'Gou ', 'Tui ', 'Tang ', 'Chao ', 'Shan ', 'N ', 'Bo ', 'Huang ', 'Xie ', 'Xi ', 'Wu ', 'Xi ', 'Yun ', 'He ', 'He ', 'Xi ', 'Yun ', 'Xiong ', 'Nai ', 'Shan ', 'Qiong ', 'Yao ', 'Xun ', 'Mi ', 'Lian ', 'Ying ', 'Wen ', 'Rong ', 'Oozutsu ', '[?] ', 'Qiang ', 'Liu ', 'Xi ', 'Bi ', 'Biao ', 'Zong ', 'Lu ', 'Jian ', 'Shou ', 'Yi ', 'Lou ', 'Feng ', 'Sui ', 'Yi ', 'Tong ', 'Jue ', 'Zong ', 'Yun ', 'Hu ', 'Yi ', 'Zhi ', 'Ao ', 'Wei ', 'Liao ', 'Han ', 'Ou ', 'Re ', 'Jiong ', 'Man ', '[?] ', 'Shang ', 'Cuan ', 'Zeng ', 'Jian ', 'Xi ', 'Xi ', 'Xi ', 'Yi ', 'Xiao ', 'Chi ', 'Huang ', 'Chan ', 'Ye ', 'Qian ', 'Ran ', 'Yan ', 'Xian ', 'Qiao ', 'Zun ', 'Deng ', 'Dun ', 'Shen ', 'Jiao ', 'Fen ', 'Si ', 'Liao ', 'Yu ', 'Lin ', 'Tong ', 'Shao ', 'Fen ', 'Fan ', 'Yan ', 'Xun ', 'Lan ', 'Mei ', 'Tang ', 'Yi ', 'Jing ', 'Men ', '[?] ', '[?] ', 'Ying ', 'Yu ', 'Yi ', 'Xue ', 'Lan ', 'Tai ', 'Zao ', 'Can ', 'Sui ', 'Xi ', 'Que ', 'Cong ', 'Lian ', 'Hui ', 'Zhu ', 'Xie ', 'Ling ', 'Wei ', 'Yi ', 'Xie ', 'Zhao ', 'Hui ', 'Tatsu ', 'Nung ', 'Lan ', 'Ru ', 'Xian ', 'Kao ', 'Xun ', 'Jin ', 'Chou ', 'Chou ', 'Yao '];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/x04e.php\",\"ext\":\"php\",\"size\":2090,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php return ['Yi ', 'Ding ', 'Kao ', 'Qi ', 'Shang ', 'Xia ', '[?] ', 'Mo ', 'Zhang ', 'San ', 'Shang ', 'Xia ', 'Ji ', 'Bu ', 'Yu ', 'Mian ', 'Gai ', 'Chou ', 'Chou ', 'Zhuan ', 'Qie ', 'Pi ', 'Shi ', 'Shi ', 'Qiu ', 'Bing ', 'Ye ', 'Cong ', 'Dong ', 'Si ', 'Cheng ', 'Diu ', 'Qiu ', 'Liang ', 'Diu ', 'You ', 'Liang ', 'Yan ', 'Bing ', 'Sang ', 'Gun ', 'Jiu ', 'Ge ', 'Ya ', 'Qiang ', 'Zhong ', 'Ji ', 'Jie ', 'Feng ', 'Guan ', 'Chuan ', 'Chan ', 'Lin ', 'Zhuo ', 'Zhu ', 'Ha ', 'Wan ', 'Dan ', 'Wei ', 'Zhu ', 'Jing ', 'Li ', 'Ju ', 'Pie ', 'Fu ', 'Yi ', 'Yi ', 'Nai ', 'Shime ', 'Jiu ', 'Jiu ', 'Zhe ', 'Yao ', 'Yi ', '[?] ', 'Zhi ', 'Wu ', 'Zha ', 'Hu ', 'Fa ', 'Le ', 'Zhong ', 'Ping ', 'Pang ', 'Qiao ', 'Hu ', 'Guai ', 'Cheng ', 'Cheng ', 'Yi ', 'Yin ', '[?] ', 'Mie ', 'Jiu ', 'Qi ', 'Ye ', 'Xi ', 'Xiang ', 'Gai ', 'Diu ', 'Hal ', '[?] ', 'Shu ', 'Twul ', 'Shi ', 'Ji ', 'Nang ', 'Jia ', 'Kel ', 'Shi ', '[?] ', 'Ol ', 'Mai ', 'Luan ', 'Cal ', 'Ru ', 'Xue ', 'Yan ', 'Fu ', 'Sha ', 'Na ', 'Gan ', 'Sol ', 'El ', 'Cwul ', '[?] ', 'Gan ', 'Chi ', 'Gui ', 'Gan ', 'Luan ', 'Lin ', 'Yi ', 'Jue ', 'Liao ', 'Ma ', 'Yu ', 'Zheng ', 'Shi ', 'Shi ', 'Er ', 'Chu ', 'Yu ', 'Yu ', 'Yu ', 'Yun ', 'Hu ', 'Qi ', 'Wu ', 'Jing ', 'Si ', 'Sui ', 'Gen ', 'Gen ', 'Ya ', 'Xie ', 'Ya ', 'Qi ', 'Ya ', 'Ji ', 'Tou ', 'Wang ', 'Kang ', 'Ta ', 'Jiao ', 'Hai ', 'Yi ', 'Chan ', 'Heng ', 'Mu ', '[?] ', 'Xiang ', 'Jing ', 'Ting ', 'Liang ', 'Xiang ', 'Jing ', 'Ye ', 'Qin ', 'Bo ', 'You ', 'Xie ', 'Dan ', 'Lian ', 'Duo ', 'Wei ', 'Ren ', 'Ren ', 'Ji ', 'La ', 'Wang ', 'Yi ', 'Shi ', 'Ren ', 'Le ', 'Ding ', 'Ze ', 'Jin ', 'Pu ', 'Chou ', 'Ba ', 'Zhang ', 'Jin ', 'Jie ', 'Bing ', 'Reng ', 'Cong ', 'Fo ', 'San ', 'Lun ', 'Sya ', 'Cang ', 'Zi ', 'Shi ', 'Ta ', 'Zhang ', 'Fu ', 'Xian ', 'Xian ', 'Tuo ', 'Hong ', 'Tong ', 'Ren ', 'Qian ', 'Gan ', 'Yi ', 'Di ', 'Dai ', 'Ling ', 'Yi ', 'Chao ', 'Chang ', 'Sa ', '[?] ', 'Yi ', 'Mu ', 'Men ', 'Ren ', 'Jia ', 'Chao ', 'Yang ', 'Qian ', 'Zhong ', 'Pi ', 'Wan ', 'Wu ', 'Jian ', 'Jie ', 'Yao ', 'Feng ', 'Cang ', 'Ren ', 'Wang ', 'Fen ', 'Di ', 'Fang '];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/x0b9.php\",\"ext\":\"php\",\"size\":2148,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php return ['ruk', 'rut', 'rup', 'ruh', 'rweo', 'rweog', 'rweogg', 'rweogs', 'rweon', 'rweonj', 'rweonh', 'rweod', 'rweol', 'rweolg', 'rweolm', 'rweolb', 'rweols', 'rweolt', 'rweolp', 'rweolh', 'rweom', 'rweob', 'rweobs', 'rweos', 'rweoss', 'rweong', 'rweoj', 'rweoc', 'rweok', 'rweot', 'rweop', 'rweoh', 'rwe', 'rweg', 'rwegg', 'rwegs', 'rwen', 'rwenj', 'rwenh', 'rwed', 'rwel', 'rwelg', 'rwelm', 'rwelb', 'rwels', 'rwelt', 'rwelp', 'rwelh', 'rwem', 'rweb', 'rwebs', 'rwes', 'rwess', 'rweng', 'rwej', 'rwec', 'rwek', 'rwet', 'rwep', 'rweh', 'rwi', 'rwig', 'rwigg', 'rwigs', 'rwin', 'rwinj', 'rwinh', 'rwid', 'rwil', 'rwilg', 'rwilm', 'rwilb', 'rwils', 'rwilt', 'rwilp', 'rwilh', 'rwim', 'rwib', 'rwibs', 'rwis', 'rwiss', 'rwing', 'rwij', 'rwic', 'rwik', 'rwit', 'rwip', 'rwih', 'ryu', 'ryug', 'ryugg', 'ryugs', 'ryun', 'ryunj', 'ryunh', 'ryud', 'ryul', 'ryulg', 'ryulm', 'ryulb', 'ryuls', 'ryult', 'ryulp', 'ryulh', 'ryum', 'ryub', 'ryubs', 'ryus', 'ryuss', 'ryung', 'ryuj', 'ryuc', 'ryuk', 'ryut', 'ryup', 'ryuh', 'reu', 'reug', 'reugg', 'reugs', 'reun', 'reunj', 'reunh', 'reud', 'reul', 'reulg', 'reulm', 'reulb', 'reuls', 'reult', 'reulp', 'reulh', 'reum', 'reub', 'reubs', 'reus', 'reuss', 'reung', 'reuj', 'reuc', 'reuk', 'reut', 'reup', 'reuh', 'ryi', 'ryig', 'ryigg', 'ryigs', 'ryin', 'ryinj', 'ryinh', 'ryid', 'ryil', 'ryilg', 'ryilm', 'ryilb', 'ryils', 'ryilt', 'ryilp', 'ryilh', 'ryim', 'ryib', 'ryibs', 'ryis', 'ryiss', 'rying', 'ryij', 'ryic', 'ryik', 'ryit', 'ryip', 'ryih', 'ri', 'rig', 'rigg', 'rigs', 'rin', 'rinj', 'rinh', 'rid', 'ril', 'rilg', 'rilm', 'rilb', 'rils', 'rilt', 'rilp', 'rilh', 'rim', 'rib', 'ribs', 'ris', 'riss', 'ring', 'rij', 'ric', 'rik', 'rit', 'rip', 'rih', 'ma', 'mag', 'magg', 'mags', 'man', 'manj', 'manh', 'mad', 'mal', 'malg', 'malm', 'malb', 'mals', 'malt', 'malp', 'malh', 'mam', 'mab', 'mabs', 'mas', 'mass', 'mang', 'maj', 'mac', 'mak', 'mat', 'map', 'mah', 'mae', 'maeg', 'maegg', 'maegs', 'maen', 'maenj', 'maenh', 'maed', 'mael', 'maelg', 'maelm', 'maelb', 'maels', 'maelt', 'maelp', 'maelh', 'maem', 'maeb', 'maebs', 'maes', 'maess', 'maeng', 'maej', 'maec', 'maek', 'maet', 'maep', 'maeh'];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/x0a0.php\",\"ext\":\"php\",\"size\":1872,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php return ['it', 'ix', 'i', 'ip', 'iet', 'iex', 'ie', 'iep', 'at', 'ax', 'a', 'ap', 'uox', 'uo', 'uop', 'ot', 'ox', 'o', 'op', 'ex', 'e', 'wu', 'bit', 'bix', 'bi', 'bip', 'biet', 'biex', 'bie', 'biep', 'bat', 'bax', 'ba', 'bap', 'buox', 'buo', 'buop', 'bot', 'box', 'bo', 'bop', 'bex', 'be', 'bep', 'but', 'bux', 'bu', 'bup', 'burx', 'bur', 'byt', 'byx', 'by', 'byp', 'byrx', 'byr', 'pit', 'pix', 'pi', 'pip', 'piex', 'pie', 'piep', 'pat', 'pax', 'pa', 'pap', 'puox', 'puo', 'puop', 'pot', 'pox', 'po', 'pop', 'put', 'pux', 'pu', 'pup', 'purx', 'pur', 'pyt', 'pyx', 'py', 'pyp', 'pyrx', 'pyr', 'bbit', 'bbix', 'bbi', 'bbip', 'bbiet', 'bbiex', 'bbie', 'bbiep', 'bbat', 'bbax', 'bba', 'bbap', 'bbuox', 'bbuo', 'bbuop', 'bbot', 'bbox', 'bbo', 'bbop', 'bbex', 'bbe', 'bbep', 'bbut', 'bbux', 'bbu', 'bbup', 'bburx', 'bbur', 'bbyt', 'bbyx', 'bby', 'bbyp', 'nbit', 'nbix', 'nbi', 'nbip', 'nbiex', 'nbie', 'nbiep', 'nbat', 'nbax', 'nba', 'nbap', 'nbot', 'nbox', 'nbo', 'nbop', 'nbut', 'nbux', 'nbu', 'nbup', 'nburx', 'nbur', 'nbyt', 'nbyx', 'nby', 'nbyp', 'nbyrx', 'nbyr', 'hmit', 'hmix', 'hmi', 'hmip', 'hmiex', 'hmie', 'hmiep', 'hmat', 'hmax', 'hma', 'hmap', 'hmuox', 'hmuo', 'hmuop', 'hmot', 'hmox', 'hmo', 'hmop', 'hmut', 'hmux', 'hmu', 'hmup', 'hmurx', 'hmur', 'hmyx', 'hmy', 'hmyp', 'hmyrx', 'hmyr', 'mit', 'mix', 'mi', 'mip', 'miex', 'mie', 'miep', 'mat', 'max', 'ma', 'map', 'muot', 'muox', 'muo', 'muop', 'mot', 'mox', 'mo', 'mop', 'mex', 'me', 'mut', 'mux', 'mu', 'mup', 'murx', 'mur', 'myt', 'myx', 'my', 'myp', 'fit', 'fix', 'fi', 'fip', 'fat', 'fax', 'fa', 'fap', 'fox', 'fo', 'fop', 'fut', 'fux', 'fu', 'fup', 'furx', 'fur', 'fyt', 'fyx', 'fy', 'fyp', 'vit', 'vix', 'vi', 'vip', 'viet', 'viex', 'vie', 'viep', 'vat', 'vax', 'va', 'vap', 'vot', 'vox', 'vo', 'vop', 'vex', 'vep', 'vut', 'vux', 'vu', 'vup', 'vurx', 'vur', 'vyt', 'vyx', 'vy', 'vyp', 'vyrx', 'vyr'];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/x02c.php\",\"ext\":\"php\",\"size\":1050,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php return ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'L', 'l', 'L', 'P', 'R', 'a', 't', 'H', 'h', 'K', 'k', 'Z', 'z', '', 'M', 'A', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/x064.php\",\"ext\":\"php\",\"size\":2099,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php return ['Chan ', 'Ge ', 'Lou ', 'Zong ', 'Geng ', 'Jiao ', 'Gou ', 'Qin ', 'Yong ', 'Que ', 'Chou ', 'Chi ', 'Zhan ', 'Sun ', 'Sun ', 'Bo ', 'Chu ', 'Rong ', 'Beng ', 'Cuo ', 'Sao ', 'Ke ', 'Yao ', 'Dao ', 'Zhi ', 'Nu ', 'Xie ', 'Jian ', 'Sou ', 'Qiu ', 'Gao ', 'Xian ', 'Shuo ', 'Sang ', 'Jin ', 'Mie ', 'E ', 'Chui ', 'Nuo ', 'Shan ', 'Ta ', 'Jie ', 'Tang ', 'Pan ', 'Ban ', 'Da ', 'Li ', 'Tao ', 'Hu ', 'Zhi ', 'Wa ', 'Xia ', 'Qian ', 'Wen ', 'Qiang ', 'Tian ', 'Zhen ', 'E ', 'Xi ', 'Nuo ', 'Quan ', 'Cha ', 'Zha ', 'Ge ', 'Wu ', 'En ', 'She ', 'Kang ', 'She ', 'Shu ', 'Bai ', 'Yao ', 'Bin ', 'Sou ', 'Tan ', 'Sa ', 'Chan ', 'Suo ', 'Liao ', 'Chong ', 'Chuang ', 'Guo ', 'Bing ', 'Feng ', 'Shuai ', 'Di ', 'Qi ', 'Sou ', 'Zhai ', 'Lian ', 'Tang ', 'Chi ', 'Guan ', 'Lu ', 'Luo ', 'Lou ', 'Zong ', 'Gai ', 'Hu ', 'Zha ', 'Chuang ', 'Tang ', 'Hua ', 'Cui ', 'Nai ', 'Mo ', 'Jiang ', 'Gui ', 'Ying ', 'Zhi ', 'Ao ', 'Zhi ', 'Nie ', 'Man ', 'Shan ', 'Kou ', 'Shu ', 'Suo ', 'Tuan ', 'Jiao ', 'Mo ', 'Mo ', 'Zhe ', 'Xian ', 'Keng ', 'Piao ', 'Jiang ', 'Yin ', 'Gou ', 'Qian ', 'Lue ', 'Ji ', 'Ying ', 'Jue ', 'Pie ', 'Pie ', 'Lao ', 'Dun ', 'Xian ', 'Ruan ', 'Kui ', 'Zan ', 'Yi ', 'Xun ', 'Cheng ', 'Cheng ', 'Sa ', 'Nao ', 'Heng ', 'Si ', 'Qian ', 'Huang ', 'Da ', 'Zun ', 'Nian ', 'Lin ', 'Zheng ', 'Hui ', 'Zhuang ', 'Jiao ', 'Ji ', 'Cao ', 'Dan ', 'Dan ', 'Che ', 'Bo ', 'Che ', 'Jue ', 'Xiao ', 'Liao ', 'Ben ', 'Fu ', 'Qiao ', 'Bo ', 'Cuo ', 'Zhuo ', 'Zhuan ', 'Tuo ', 'Pu ', 'Qin ', 'Dun ', 'Nian ', '[?] ', 'Xie ', 'Lu ', 'Jiao ', 'Cuan ', 'Ta ', 'Han ', 'Qiao ', 'Zhua ', 'Jian ', 'Gan ', 'Yong ', 'Lei ', 'Kuo ', 'Lu ', 'Shan ', 'Zhuo ', 'Ze ', 'Pu ', 'Chuo ', 'Ji ', 'Dang ', 'Suo ', 'Cao ', 'Qing ', 'Jing ', 'Huan ', 'Jie ', 'Qin ', 'Kuai ', 'Dan ', 'Xi ', 'Ge ', 'Pi ', 'Bo ', 'Ao ', 'Ju ', 'Ye ', '[?] ', 'Mang ', 'Sou ', 'Mi ', 'Ji ', 'Tai ', 'Zhuo ', 'Dao ', 'Xing ', 'Lan ', 'Ca ', 'Ju ', 'Ye ', 'Ru ', 'Ye ', 'Ye ', 'Ni ', 'Hu ', 'Ji ', 'Bin ', 'Ning ', 'Ge ', 'Zhi ', 'Jie ', 'Kuo ', 'Mo ', 'Jian ', 'Xie ', 'Lie ', 'Tan ', 'Bai ', 'Sou ', 'Lu ', 'Lue ', 'Rao ', 'Zhi '];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/x083.php\",\"ext\":\"php\",\"size\":2087,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php return ['Fu ', 'Zhuo ', 'Mao ', 'Fan ', 'Qie ', 'Mao ', 'Mao ', 'Ba ', 'Zi ', 'Mo ', 'Zi ', 'Di ', 'Chi ', 'Ji ', 'Jing ', 'Long ', '[?] ', 'Niao ', '[?] ', 'Xue ', 'Ying ', 'Qiong ', 'Ge ', 'Ming ', 'Li ', 'Rong ', 'Yin ', 'Gen ', 'Qian ', 'Chai ', 'Chen ', 'Yu ', 'Xiu ', 'Zi ', 'Lie ', 'Wu ', 'Ji ', 'Kui ', 'Ce ', 'Chong ', 'Ci ', 'Gou ', 'Guang ', 'Mang ', 'Chi ', 'Jiao ', 'Jiao ', 'Fu ', 'Yu ', 'Zhu ', 'Zi ', 'Jiang ', 'Hui ', 'Yin ', 'Cha ', 'Fa ', 'Rong ', 'Ru ', 'Chong ', 'Mang ', 'Tong ', 'Zhong ', '[?] ', 'Zhu ', 'Xun ', 'Huan ', 'Kua ', 'Quan ', 'Gai ', 'Da ', 'Jing ', 'Xing ', 'Quan ', 'Cao ', 'Jing ', 'Er ', 'An ', 'Shou ', 'Chi ', 'Ren ', 'Jian ', 'Ti ', 'Huang ', 'Ping ', 'Li ', 'Jin ', 'Lao ', 'Shu ', 'Zhuang ', 'Da ', 'Jia ', 'Rao ', 'Bi ', 'Ze ', 'Qiao ', 'Hui ', 'Qi ', 'Dang ', '[?] ', 'Rong ', 'Hun ', 'Ying ', 'Luo ', 'Ying ', 'Xun ', 'Jin ', 'Sun ', 'Yin ', 'Mai ', 'Hong ', 'Zhou ', 'Yao ', 'Du ', 'Wei ', 'Chu ', 'Dou ', 'Fu ', 'Ren ', 'Yin ', 'He ', 'Bi ', 'Bu ', 'Yun ', 'Di ', 'Tu ', 'Sui ', 'Sui ', 'Cheng ', 'Chen ', 'Wu ', 'Bie ', 'Xi ', 'Geng ', 'Li ', 'Fu ', 'Zhu ', 'Mo ', 'Li ', 'Zhuang ', 'Ji ', 'Duo ', 'Qiu ', 'Sha ', 'Suo ', 'Chen ', 'Feng ', 'Ju ', 'Mei ', 'Meng ', 'Xing ', 'Jing ', 'Che ', 'Xin ', 'Jun ', 'Yan ', 'Ting ', 'Diao ', 'Cuo ', 'Wan ', 'Han ', 'You ', 'Cuo ', 'Jia ', 'Wang ', 'You ', 'Niu ', 'Shao ', 'Xian ', 'Lang ', 'Fu ', 'E ', 'Mo ', 'Wen ', 'Jie ', 'Nan ', 'Mu ', 'Kan ', 'Lai ', 'Lian ', 'Shi ', 'Wo ', 'Usagi ', 'Lian ', 'Huo ', 'You ', 'Ying ', 'Ying ', 'Nuc ', 'Chun ', 'Mang ', 'Mang ', 'Ci ', 'Wan ', 'Jing ', 'Di ', 'Qu ', 'Dong ', 'Jian ', 'Zou ', 'Gu ', 'La ', 'Lu ', 'Ju ', 'Wei ', 'Jun ', 'Nie ', 'Kun ', 'He ', 'Pu ', 'Zi ', 'Gao ', 'Guo ', 'Fu ', 'Lun ', 'Chang ', 'Chou ', 'Song ', 'Chui ', 'Zhan ', 'Men ', 'Cai ', 'Ba ', 'Li ', 'Tu ', 'Bo ', 'Han ', 'Bao ', 'Qin ', 'Juan ', 'Xi ', 'Qin ', 'Di ', 'Jie ', 'Pu ', 'Dang ', 'Jin ', 'Zhao ', 'Tai ', 'Geng ', 'Hua ', 'Gu ', 'Ling ', 'Fei ', 'Jin ', 'An ', 'Wang ', 'Beng ', 'Zhou ', 'Yan ', 'Ju ', 'Jian ', 'Lin ', 'Tan ', 'Shu ', 'Tian ', 'Dao '];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/x01e.php\",\"ext\":\"php\",\"size\":1298,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php return ['A', 'a', 'B', 'b', 'B', 'b', 'B', 'b', 'C', 'c', 'D', 'd', 'D', 'd', 'D', 'd', 'D', 'd', 'D', 'd', 'E', 'e', 'E', 'e', 'E', 'e', 'E', 'e', 'E', 'e', 'F', 'f', 'G', 'g', 'H', 'h', 'H', 'h', 'H', 'h', 'H', 'h', 'H', 'h', 'I', 'i', 'I', 'i', 'K', 'k', 'K', 'k', 'K', 'k', 'L', 'l', 'L', 'l', 'L', 'l', 'L', 'l', 'M', 'm', 'M', 'm', 'M', 'm', 'N', 'n', 'N', 'n', 'N', 'n', 'N', 'n', 'O', 'o', 'O', 'o', 'O', 'o', 'O', 'o', 'P', 'p', 'P', 'p', 'R', 'r', 'R', 'r', 'R', 'r', 'R', 'r', 'S', 's', 'S', 's', 'S', 's', 'S', 's', 'S', 's', 'T', 't', 'T', 't', 'T', 't', 'T', 't', 'U', 'u', 'U', 'u', 'U', 'u', 'U', 'u', 'U', 'u', 'V', 'v', 'V', 'v', 'W', 'w', 'W', 'w', 'W', 'w', 'W', 'w', 'W', 'w', 'X', 'x', 'X', 'x', 'Y', 'y', 'Z', 'z', 'Z', 'z', 'Z', 'z', 'h', 't', 'w', 'y', 'a', 's', 's', 's', 'Ss', 'd', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'E', 'e', 'E', 'e', 'E', 'e', 'E', 'e', 'E', 'e', 'E', 'e', 'E', 'e', 'E', 'e', 'I', 'i', 'I', 'i', 'O', 'o', 'O', 'o', 'O', 'o', 'O', 'o', 'O', 'o', 'O', 'o', 'O', 'o', 'O', 'o', 'O', 'o', 'O', 'o', 'O', 'o', 'O', 'o', 'U', 'u', 'U', 'u', 'U', 'u', 'U', 'u', 'U', 'u', 'U', 'u', 'U', 'u', 'Y', 'y', 'Y', 'y', 'Y', 'y', 'Y', 'y', 'LL', 'll', 'V', 'v', 'Y', 'y'];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/x032.php\",\"ext\":\"php\",\"size\":1939,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php return ['(g)', '(n)', '(d)', '(r)', '(m)', '(b)', '(s)', '()', '(j)', '(c)', '(k)', '(t)', '(p)', '(h)', '(ga)', '(na)', '(da)', '(ra)', '(ma)', '(ba)', '(sa)', '(a)', '(ja)', '(ca)', '(ka)', '(ta)', '(pa)', '(ha)', '(ju)', '[?]', '[?]', '[?]', '(1) ', '(2) ', '(3) ', '(4) ', '(5) ', '(6) ', '(7) ', '(8) ', '(9) ', '(10) ', '(Yue) ', '(Huo) ', '(Shui) ', '(Mu) ', '(Jin) ', '(Tu) ', '(Ri) ', '(Zhu) ', '(You) ', '(She) ', '(Ming) ', '(Te) ', '(Cai) ', '(Zhu) ', '(Lao) ', '(Dai) ', '(Hu) ', '(Xue) ', '(Jian) ', '(Qi) ', '(Zi) ', '(Xie) ', '(Ji) ', '(Xiu) ', '<<', '>>', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', '31', '32', '33', '34', '35', '(g)', '(n)', '(d)', '(r)', '(m)', '(b)', '(s)', '()', '(j)', '(c)', '(k)', '(t)', '(p)', '(h)', '(ga)', '(na)', '(da)', '(ra)', '(ma)', '(ba)', '(sa)', '(a)', '(ja)', '(ca)', '(ka)', '(ta)', '(pa)', '(ha)', '[?]', '[?]', '[?]', 'KIS ', '(1) ', '(2) ', '(3) ', '(4) ', '(5) ', '(6) ', '(7) ', '(8) ', '(9) ', '(10) ', '(Yue) ', '(Huo) ', '(Shui) ', '(Mu) ', '(Jin) ', '(Tu) ', '(Ri) ', '(Zhu) ', '(You) ', '(She) ', '(Ming) ', '(Te) ', '(Cai) ', '(Zhu) ', '(Lao) ', '(Mi) ', '(Nan) ', '(Nu) ', '(Shi) ', '(You) ', '(Yin) ', '(Zhu) ', '(Xiang) ', '(Xiu) ', '(Xie) ', '(Zheng) ', '(Shang) ', '(Zhong) ', '(Xia) ', '(Zuo) ', '(You) ', '(Yi) ', '(Zong) ', '(Xue) ', '(Jian) ', '(Qi) ', '(Zi) ', '(Xie) ', '(Ye) ', '36', '37', '38', '39', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '50', '1M', '2M', '3M', '4M', '5M', '6M', '7M', '8M', '9M', '10M', '11M', '12M', 'Hg', 'erg', 'eV', 'LTD', 'a', 'i', 'u', 'u', 'o', 'ka', 'ki', 'ku', 'ke', 'ko', 'sa', 'si', 'su', 'se', 'so', 'ta', 'ti', 'tu', 'te', 'to', 'na', 'ni', 'nu', 'ne', 'no', 'ha', 'hi', 'hu', 'he', 'ho', 'ma', 'mi', 'mu', 'me', 'mo', 'ya', 'yu', 'yo', 'ra', 'ri', 'ru', 're', 'ro', 'wa', 'wi', 'we', 'wo'];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/x0ae.php\",\"ext\":\"php\",\"size\":2319,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php return ['geul', 'geulg', 'geulm', 'geulb', 'geuls', 'geult', 'geulp', 'geulh', 'geum', 'geub', 'geubs', 'geus', 'geuss', 'geung', 'geuj', 'geuc', 'geuk', 'geut', 'geup', 'geuh', 'gyi', 'gyig', 'gyigg', 'gyigs', 'gyin', 'gyinj', 'gyinh', 'gyid', 'gyil', 'gyilg', 'gyilm', 'gyilb', 'gyils', 'gyilt', 'gyilp', 'gyilh', 'gyim', 'gyib', 'gyibs', 'gyis', 'gyiss', 'gying', 'gyij', 'gyic', 'gyik', 'gyit', 'gyip', 'gyih', 'gi', 'gig', 'gigg', 'gigs', 'gin', 'ginj', 'ginh', 'gid', 'gil', 'gilg', 'gilm', 'gilb', 'gils', 'gilt', 'gilp', 'gilh', 'gim', 'gib', 'gibs', 'gis', 'giss', 'ging', 'gij', 'gic', 'gik', 'git', 'gip', 'gih', 'gga', 'ggag', 'ggagg', 'ggags', 'ggan', 'gganj', 'gganh', 'ggad', 'ggal', 'ggalg', 'ggalm', 'ggalb', 'ggals', 'ggalt', 'ggalp', 'ggalh', 'ggam', 'ggab', 'ggabs', 'ggas', 'ggass', 'ggang', 'ggaj', 'ggac', 'ggak', 'ggat', 'ggap', 'ggah', 'ggae', 'ggaeg', 'ggaegg', 'ggaegs', 'ggaen', 'ggaenj', 'ggaenh', 'ggaed', 'ggael', 'ggaelg', 'ggaelm', 'ggaelb', 'ggaels', 'ggaelt', 'ggaelp', 'ggaelh', 'ggaem', 'ggaeb', 'ggaebs', 'ggaes', 'ggaess', 'ggaeng', 'ggaej', 'ggaec', 'ggaek', 'ggaet', 'ggaep', 'ggaeh', 'ggya', 'ggyag', 'ggyagg', 'ggyags', 'ggyan', 'ggyanj', 'ggyanh', 'ggyad', 'ggyal', 'ggyalg', 'ggyalm', 'ggyalb', 'ggyals', 'ggyalt', 'ggyalp', 'ggyalh', 'ggyam', 'ggyab', 'ggyabs', 'ggyas', 'ggyass', 'ggyang', 'ggyaj', 'ggyac', 'ggyak', 'ggyat', 'ggyap', 'ggyah', 'ggyae', 'ggyaeg', 'ggyaegg', 'ggyaegs', 'ggyaen', 'ggyaenj', 'ggyaenh', 'ggyaed', 'ggyael', 'ggyaelg', 'ggyaelm', 'ggyaelb', 'ggyaels', 'ggyaelt', 'ggyaelp', 'ggyaelh', 'ggyaem', 'ggyaeb', 'ggyaebs', 'ggyaes', 'ggyaess', 'ggyaeng', 'ggyaej', 'ggyaec', 'ggyaek', 'ggyaet', 'ggyaep', 'ggyaeh', 'ggeo', 'ggeog', 'ggeogg', 'ggeogs', 'ggeon', 'ggeonj', 'ggeonh', 'ggeod', 'ggeol', 'ggeolg', 'ggeolm', 'ggeolb', 'ggeols', 'ggeolt', 'ggeolp', 'ggeolh', 'ggeom', 'ggeob', 'ggeobs', 'ggeos', 'ggeoss', 'ggeong', 'ggeoj', 'ggeoc', 'ggeok', 'ggeot', 'ggeop', 'ggeoh', 'gge', 'ggeg', 'ggegg', 'ggegs', 'ggen', 'ggenj', 'ggenh', 'gged', 'ggel', 'ggelg', 'ggelm', 'ggelb', 'ggels', 'ggelt', 'ggelp', 'ggelh', 'ggem', 'ggeb', 'ggebs', 'gges', 'ggess', 'ggeng', 'ggej', 'ggec', 'ggek', 'gget', 'ggep', 'ggeh', 'ggyeo', 'ggyeog', 'ggyeogg', 'ggyeogs', 'ggyeon', 'ggyeonj', 'ggyeonh', 'ggyeod', 'ggyeol', 'ggyeolg', 'ggyeolm', 'ggyeolb'];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/x0d2.php\",\"ext\":\"php\",\"size\":2168,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php return ['toels', 'toelt', 'toelp', 'toelh', 'toem', 'toeb', 'toebs', 'toes', 'toess', 'toeng', 'toej', 'toec', 'toek', 'toet', 'toep', 'toeh', 'tyo', 'tyog', 'tyogg', 'tyogs', 'tyon', 'tyonj', 'tyonh', 'tyod', 'tyol', 'tyolg', 'tyolm', 'tyolb', 'tyols', 'tyolt', 'tyolp', 'tyolh', 'tyom', 'tyob', 'tyobs', 'tyos', 'tyoss', 'tyong', 'tyoj', 'tyoc', 'tyok', 'tyot', 'tyop', 'tyoh', 'tu', 'tug', 'tugg', 'tugs', 'tun', 'tunj', 'tunh', 'tud', 'tul', 'tulg', 'tulm', 'tulb', 'tuls', 'tult', 'tulp', 'tulh', 'tum', 'tub', 'tubs', 'tus', 'tuss', 'tung', 'tuj', 'tuc', 'tuk', 'tut', 'tup', 'tuh', 'tweo', 'tweog', 'tweogg', 'tweogs', 'tweon', 'tweonj', 'tweonh', 'tweod', 'tweol', 'tweolg', 'tweolm', 'tweolb', 'tweols', 'tweolt', 'tweolp', 'tweolh', 'tweom', 'tweob', 'tweobs', 'tweos', 'tweoss', 'tweong', 'tweoj', 'tweoc', 'tweok', 'tweot', 'tweop', 'tweoh', 'twe', 'tweg', 'twegg', 'twegs', 'twen', 'twenj', 'twenh', 'twed', 'twel', 'twelg', 'twelm', 'twelb', 'twels', 'twelt', 'twelp', 'twelh', 'twem', 'tweb', 'twebs', 'twes', 'twess', 'tweng', 'twej', 'twec', 'twek', 'twet', 'twep', 'tweh', 'twi', 'twig', 'twigg', 'twigs', 'twin', 'twinj', 'twinh', 'twid', 'twil', 'twilg', 'twilm', 'twilb', 'twils', 'twilt', 'twilp', 'twilh', 'twim', 'twib', 'twibs', 'twis', 'twiss', 'twing', 'twij', 'twic', 'twik', 'twit', 'twip', 'twih', 'tyu', 'tyug', 'tyugg', 'tyugs', 'tyun', 'tyunj', 'tyunh', 'tyud', 'tyul', 'tyulg', 'tyulm', 'tyulb', 'tyuls', 'tyult', 'tyulp', 'tyulh', 'tyum', 'tyub', 'tyubs', 'tyus', 'tyuss', 'tyung', 'tyuj', 'tyuc', 'tyuk', 'tyut', 'tyup', 'tyuh', 'teu', 'teug', 'teugg', 'teugs', 'teun', 'teunj', 'teunh', 'teud', 'teul', 'teulg', 'teulm', 'teulb', 'teuls', 'teult', 'teulp', 'teulh', 'teum', 'teub', 'teubs', 'teus', 'teuss', 'teung', 'teuj', 'teuc', 'teuk', 'teut', 'teup', 'teuh', 'tyi', 'tyig', 'tyigg', 'tyigs', 'tyin', 'tyinj', 'tyinh', 'tyid', 'tyil', 'tyilg', 'tyilm', 'tyilb', 'tyils', 'tyilt', 'tyilp', 'tyilh', 'tyim', 'tyib', 'tyibs', 'tyis', 'tyiss', 'tying', 'tyij', 'tyic', 'tyik', 'tyit', 'tyip', 'tyih', 'ti', 'tig', 'tigg', 'tigs', 'tin', 'tinj', 'tinh', 'tid', 'til', 'tilg', 'tilm', 'tilb', 'tils', 'tilt', 'tilp', 'tilh'];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/x002.php\",\"ext\":\"php\",\"size\":1343,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php return ['A', 'a', 'A', 'a', 'E', 'e', 'E', 'e', 'I', 'i', 'I', 'i', 'O', 'o', 'O', 'o', 'R', 'r', 'R', 'r', 'U', 'u', 'U', 'u', 'S', 's', 'T', 't', 'Y', 'y', 'H', 'h', 'N', 'd', 'OU', 'ou', 'Z', 'z', 'A', 'a', 'E', 'e', 'O', 'o', 'O', 'o', 'O', 'o', 'O', 'o', 'Y', 'y', 'l', 'n', 't', 'j', 'db', 'qp', 'A', 'C', 'c', 'L', 'T', 's', 'z', '[?]', '[?]', 'B', 'U', '^', 'E', 'e', 'J', 'j', 'q', 'q', 'R', 'r', 'Y', 'y', 'a', 'a', 'a', 'b', 'o', 'c', 'd', 'd', 'e', '@', '@', 'e', 'e', 'e', 'e', 'j', 'g', 'g', 'g', 'g', 'u', 'Y', 'h', 'h', 'i', 'i', 'I', 'l', 'l', 'l', 'lZ', 'W', 'W', 'm', 'n', 'n', 'n', 'o', 'OE', 'O', 'F', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'R', 'R', 's', 'S', 'j', 'S', 'S', 't', 't', 'u', 'U', 'v', '^', 'w', 'y', 'Y', 'z', 'z', 'Z', 'Z', '?', '?', '?', 'C', '@', 'B', 'E', 'G', 'H', 'j', 'k', 'L', 'q', '?', '?', 'dz', 'dZ', 'dz', 'ts', 'tS', 'tC', 'fN', 'ls', 'lz', 'WW', ']]', 'h', 'h', 'h', 'h', 'j', 'r', 'r', 'r', 'r', 'w', 'y', '\\\\'', '\\\"', '`', '\\\\'', '`', '`', '\\\\'', '?', '?', '<', '>', '^', 'V', '^', 'V', '\\\\'', '-', '\/', '\\\\\\\\', ',', '_', '\\\\\\\\', '\/', ':', '.', '`', '\\\\'', '^', 'V', '+', '-', 'V', '.', '@', ',', '~', '\\\"', 'R', 'X', 'G', 'l', 's', 'x', '?', '', '', '', '', '', '', '', 'V', '=', '\\\"', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]'];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/x0c2.php\",\"ext\":\"php\",\"size\":2154,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php return ['syon', 'syonj', 'syonh', 'syod', 'syol', 'syolg', 'syolm', 'syolb', 'syols', 'syolt', 'syolp', 'syolh', 'syom', 'syob', 'syobs', 'syos', 'syoss', 'syong', 'syoj', 'syoc', 'syok', 'syot', 'syop', 'syoh', 'su', 'sug', 'sugg', 'sugs', 'sun', 'sunj', 'sunh', 'sud', 'sul', 'sulg', 'sulm', 'sulb', 'suls', 'sult', 'sulp', 'sulh', 'sum', 'sub', 'subs', 'sus', 'suss', 'sung', 'suj', 'suc', 'suk', 'sut', 'sup', 'suh', 'sweo', 'sweog', 'sweogg', 'sweogs', 'sweon', 'sweonj', 'sweonh', 'sweod', 'sweol', 'sweolg', 'sweolm', 'sweolb', 'sweols', 'sweolt', 'sweolp', 'sweolh', 'sweom', 'sweob', 'sweobs', 'sweos', 'sweoss', 'sweong', 'sweoj', 'sweoc', 'sweok', 'sweot', 'sweop', 'sweoh', 'swe', 'sweg', 'swegg', 'swegs', 'swen', 'swenj', 'swenh', 'swed', 'swel', 'swelg', 'swelm', 'swelb', 'swels', 'swelt', 'swelp', 'swelh', 'swem', 'sweb', 'swebs', 'swes', 'swess', 'sweng', 'swej', 'swec', 'swek', 'swet', 'swep', 'sweh', 'swi', 'swig', 'swigg', 'swigs', 'swin', 'swinj', 'swinh', 'swid', 'swil', 'swilg', 'swilm', 'swilb', 'swils', 'swilt', 'swilp', 'swilh', 'swim', 'swib', 'swibs', 'swis', 'swiss', 'swing', 'swij', 'swic', 'swik', 'swit', 'swip', 'swih', 'syu', 'syug', 'syugg', 'syugs', 'syun', 'syunj', 'syunh', 'syud', 'syul', 'syulg', 'syulm', 'syulb', 'syuls', 'syult', 'syulp', 'syulh', 'syum', 'syub', 'syubs', 'syus', 'syuss', 'syung', 'syuj', 'syuc', 'syuk', 'syut', 'syup', 'syuh', 'seu', 'seug', 'seugg', 'seugs', 'seun', 'seunj', 'seunh', 'seud', 'seul', 'seulg', 'seulm', 'seulb', 'seuls', 'seult', 'seulp', 'seulh', 'seum', 'seub', 'seubs', 'seus', 'seuss', 'seung', 'seuj', 'seuc', 'seuk', 'seut', 'seup', 'seuh', 'syi', 'syig', 'syigg', 'syigs', 'syin', 'syinj', 'syinh', 'syid', 'syil', 'syilg', 'syilm', 'syilb', 'syils', 'syilt', 'syilp', 'syilh', 'syim', 'syib', 'syibs', 'syis', 'syiss', 'sying', 'syij', 'syic', 'syik', 'syit', 'syip', 'syih', 'si', 'sig', 'sigg', 'sigs', 'sin', 'sinj', 'sinh', 'sid', 'sil', 'silg', 'silm', 'silb', 'sils', 'silt', 'silp', 'silh', 'sim', 'sib', 'sibs', 'sis', 'siss', 'sing', 'sij', 'sic', 'sik', 'sit', 'sip', 'sih', 'ssa', 'ssag', 'ssagg', 'ssags', 'ssan', 'ssanj', 'ssanh', 'ssad'];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/x05e.php\",\"ext\":\"php\",\"size\":2112,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php return ['Za ', 'Bi ', 'Shi ', 'Bu ', 'Ding ', 'Shuai ', 'Fan ', 'Nie ', 'Shi ', 'Fen ', 'Pa ', 'Zhi ', 'Xi ', 'Hu ', 'Dan ', 'Wei ', 'Zhang ', 'Tang ', 'Dai ', 'Ma ', 'Pei ', 'Pa ', 'Tie ', 'Fu ', 'Lian ', 'Zhi ', 'Zhou ', 'Bo ', 'Zhi ', 'Di ', 'Mo ', 'Yi ', 'Yi ', 'Ping ', 'Qia ', 'Juan ', 'Ru ', 'Shuai ', 'Dai ', 'Zheng ', 'Shui ', 'Qiao ', 'Zhen ', 'Shi ', 'Qun ', 'Xi ', 'Bang ', 'Dai ', 'Gui ', 'Chou ', 'Ping ', 'Zhang ', 'Sha ', 'Wan ', 'Dai ', 'Wei ', 'Chang ', 'Sha ', 'Qi ', 'Ze ', 'Guo ', 'Mao ', 'Du ', 'Hou ', 'Zheng ', 'Xu ', 'Mi ', 'Wei ', 'Wo ', 'Fu ', 'Yi ', 'Bang ', 'Ping ', 'Tazuna ', 'Gong ', 'Pan ', 'Huang ', 'Dao ', 'Mi ', 'Jia ', 'Teng ', 'Hui ', 'Zhong ', 'Shan ', 'Man ', 'Mu ', 'Biao ', 'Guo ', 'Ze ', 'Mu ', 'Bang ', 'Zhang ', 'Jiong ', 'Chan ', 'Fu ', 'Zhi ', 'Hu ', 'Fan ', 'Chuang ', 'Bi ', 'Hei ', '[?] ', 'Mi ', 'Qiao ', 'Chan ', 'Fen ', 'Meng ', 'Bang ', 'Chou ', 'Mie ', 'Chu ', 'Jie ', 'Xian ', 'Lan ', 'Gan ', 'Ping ', 'Nian ', 'Qian ', 'Bing ', 'Bing ', 'Xing ', 'Gan ', 'Yao ', 'Huan ', 'You ', 'You ', 'Ji ', 'Yan ', 'Pi ', 'Ting ', 'Ze ', 'Guang ', 'Zhuang ', 'Mo ', 'Qing ', 'Bi ', 'Qin ', 'Dun ', 'Chuang ', 'Gui ', 'Ya ', 'Bai ', 'Jie ', 'Xu ', 'Lu ', 'Wu ', '[?] ', 'Ku ', 'Ying ', 'Di ', 'Pao ', 'Dian ', 'Ya ', 'Miao ', 'Geng ', 'Ci ', 'Fu ', 'Tong ', 'Pang ', 'Fei ', 'Xiang ', 'Yi ', 'Zhi ', 'Tiao ', 'Zhi ', 'Xiu ', 'Du ', 'Zuo ', 'Xiao ', 'Tu ', 'Gui ', 'Ku ', 'Pang ', 'Ting ', 'You ', 'Bu ', 'Ding ', 'Cheng ', 'Lai ', 'Bei ', 'Ji ', 'An ', 'Shu ', 'Kang ', 'Yong ', 'Tuo ', 'Song ', 'Shu ', 'Qing ', 'Yu ', 'Yu ', 'Miao ', 'Sou ', 'Ce ', 'Xiang ', 'Fei ', 'Jiu ', 'He ', 'Hui ', 'Liu ', 'Sha ', 'Lian ', 'Lang ', 'Sou ', 'Jian ', 'Pou ', 'Qing ', 'Jiu ', 'Jiu ', 'Qin ', 'Ao ', 'Kuo ', 'Lou ', 'Yin ', 'Liao ', 'Dai ', 'Lu ', 'Yi ', 'Chu ', 'Chan ', 'Tu ', 'Si ', 'Xin ', 'Miao ', 'Chang ', 'Wu ', 'Fei ', 'Guang ', 'Koc ', 'Kuai ', 'Bi ', 'Qiang ', 'Xie ', 'Lin ', 'Lin ', 'Liao ', 'Lu ', '[?] ', 'Ying ', 'Xian ', 'Ting ', 'Yong ', 'Li ', 'Ting ', 'Yin ', 'Xun ', 'Yan ', 'Ting ', 'Di ', 'Po ', 'Jian ', 'Hui ', 'Nai ', 'Hui ', 'Gong ', 'Nian '];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/x06c.php\",\"ext\":\"php\",\"size\":2087,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php return ['Lu ', 'Mu ', 'Li ', 'Tong ', 'Rong ', 'Chang ', 'Pu ', 'Luo ', 'Zhan ', 'Sao ', 'Zhan ', 'Meng ', 'Luo ', 'Qu ', 'Die ', 'Shi ', 'Di ', 'Min ', 'Jue ', 'Mang ', 'Qi ', 'Pie ', 'Nai ', 'Qi ', 'Dao ', 'Xian ', 'Chuan ', 'Fen ', 'Ri ', 'Nei ', '[?] ', 'Fu ', 'Shen ', 'Dong ', 'Qing ', 'Qi ', 'Yin ', 'Xi ', 'Hai ', 'Yang ', 'An ', 'Ya ', 'Ke ', 'Qing ', 'Ya ', 'Dong ', 'Dan ', 'Lu ', 'Qing ', 'Yang ', 'Yun ', 'Yun ', 'Shui ', 'San ', 'Zheng ', 'Bing ', 'Yong ', 'Dang ', 'Shitamizu ', 'Le ', 'Ni ', 'Tun ', 'Fan ', 'Gui ', 'Ting ', 'Zhi ', 'Qiu ', 'Bin ', 'Ze ', 'Mian ', 'Cuan ', 'Hui ', 'Diao ', 'Yi ', 'Cha ', 'Zhuo ', 'Chuan ', 'Wan ', 'Fan ', 'Dai ', 'Xi ', 'Tuo ', 'Mang ', 'Qiu ', 'Qi ', 'Shan ', 'Pai ', 'Han ', 'Qian ', 'Wu ', 'Wu ', 'Xun ', 'Si ', 'Ru ', 'Gong ', 'Jiang ', 'Chi ', 'Wu ', 'Tsuchi ', '[?] ', 'Tang ', 'Zhi ', 'Chi ', 'Qian ', 'Mi ', 'Yu ', 'Wang ', 'Qing ', 'Jing ', 'Rui ', 'Jun ', 'Hong ', 'Tai ', 'Quan ', 'Ji ', 'Bian ', 'Bian ', 'Gan ', 'Wen ', 'Zhong ', 'Fang ', 'Xiong ', 'Jue ', 'Hang ', 'Niou ', 'Qi ', 'Fen ', 'Xu ', 'Xu ', 'Qin ', 'Yi ', 'Wo ', 'Yun ', 'Yuan ', 'Hang ', 'Yan ', 'Chen ', 'Chen ', 'Dan ', 'You ', 'Dun ', 'Hu ', 'Huo ', 'Qie ', 'Mu ', 'Rou ', 'Mei ', 'Ta ', 'Mian ', 'Wu ', 'Chong ', 'Tian ', 'Bi ', 'Sha ', 'Zhi ', 'Pei ', 'Pan ', 'Zhui ', 'Za ', 'Gou ', 'Liu ', 'Mei ', 'Ze ', 'Feng ', 'Ou ', 'Li ', 'Lun ', 'Cang ', 'Feng ', 'Wei ', 'Hu ', 'Mo ', 'Mei ', 'Shu ', 'Ju ', 'Zan ', 'Tuo ', 'Tuo ', 'Tuo ', 'He ', 'Li ', 'Mi ', 'Yi ', 'Fa ', 'Fei ', 'You ', 'Tian ', 'Zhi ', 'Zhao ', 'Gu ', 'Zhan ', 'Yan ', 'Si ', 'Kuang ', 'Jiong ', 'Ju ', 'Xie ', 'Qiu ', 'Yi ', 'Jia ', 'Zhong ', 'Quan ', 'Bo ', 'Hui ', 'Mi ', 'Ben ', 'Zhuo ', 'Chu ', 'Le ', 'You ', 'Gu ', 'Hong ', 'Gan ', 'Fa ', 'Mao ', 'Si ', 'Hu ', 'Ping ', 'Ci ', 'Fan ', 'Chi ', 'Su ', 'Ning ', 'Cheng ', 'Ling ', 'Pao ', 'Bo ', 'Qi ', 'Si ', 'Ni ', 'Ju ', 'Yue ', 'Zhu ', 'Sheng ', 'Lei ', 'Xuan ', 'Xue ', 'Fu ', 'Pan ', 'Min ', 'Tai ', 'Yang ', 'Ji ', 'Yong ', 'Guan ', 'Beng ', 'Xue ', 'Long ', 'Lu ', '[?] ', 'Bo ', 'Xie ', 'Po ', 'Ze ', 'Jing ', 'Yin '];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/x023.php\",\"ext\":\"php\",\"size\":1795,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php return ['[?]', '[?]', '[?]', '^', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '<', '> ', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]'];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/x024.php\",\"ext\":\"php\",\"size\":1493,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php return ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '', '', '', '', '', '', '', '', '', '', '', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '(1)', '(2)', '(3)', '(4)', '(5)', '(6)', '(7)', '(8)', '(9)', '(10)', '(11)', '(12)', '(13)', '(14)', '(15)', '(16)', '(17)', '(18)', '(19)', '(20)', '1.', '2.', '3.', '4.', '5.', '6.', '7.', '8.', '9.', '10.', '11.', '12.', '13.', '14.', '15.', '16.', '17.', '18.', '19.', '20.', '(a)', '(b)', '(c)', '(d)', '(e)', '(f)', '(g)', '(h)', '(i)', '(j)', '(k)', '(l)', '(m)', '(n)', '(o)', '(p)', '(q)', '(r)', '(s)', '(t)', '(u)', '(v)', '(w)', '(x)', '(y)', '(z)', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '0'];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/x010.php\",\"ext\":\"php\",\"size\":1564,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php return ['k', 'kh', 'g', 'gh', 'ng', 'c', 'ch', 'j', 'jh', 'ny', 'nny', 'tt', 'tth', 'dd', 'ddh', 'nn', 'tt', 'th', 'd', 'dh', 'n', 'p', 'ph', 'b', 'bh', 'm', 'y', 'r', 'l', 'w', 's', 'h', 'll', 'a', '[?]', 'i', 'ii', 'u', 'uu', 'e', '[?]', 'o', 'au', '[?]', 'aa', 'i', 'ii', 'u', 'uu', 'e', 'ai', '[?]', '[?]', '[?]', 'N', '\\\\'', ':', '', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ' \/ ', ' \/\/ ', 'n*', 'r*', 'l*', 'e*', 'sh', 'ss', 'R', 'RR', 'L', 'LL', 'R', 'RR', 'L', 'LL', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', 'A', 'B', 'G', 'D', 'E', 'V', 'Z', 'T`', 'I', 'K', 'L', 'M', 'N', 'O', 'P', 'Zh', 'R', 'S', 'T', 'U', 'P`', 'K`', 'G\\\\'', 'Q', 'Sh', 'Ch`', 'C`', 'Z\\\\'', 'C', 'Ch', 'X', 'J', 'H', 'E', 'Y', 'W', 'Xh', 'OE', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', 'a', 'b', 'g', 'd', 'e', 'v', 'z', 't`', 'i', 'k', 'l', 'm', 'n', 'o', 'p', 'zh', 'r', 's', 't', 'u', 'p`', 'k`', 'g\\\\'', 'q', 'sh', 'ch`', 'c`', 'z\\\\'', 'c', 'ch', 'x', 'j', 'h', 'e', 'y', 'w', 'xh', 'oe', 'f', '[?]', '[?]', '[?]', '[?]', ' \/\/ ', '[?]', '[?]', '[?]'];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/x07f.php\",\"ext\":\"php\",\"size\":2108,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php return ['Zhui ', 'Zi ', 'Ke ', 'Xiang ', 'Jian ', 'Mian ', 'Lan ', 'Ti ', 'Miao ', 'Qi ', 'Yun ', 'Hui ', 'Si ', 'Duo ', 'Duan ', 'Bian ', 'Xian ', 'Gou ', 'Zhui ', 'Huan ', 'Di ', 'Lu ', 'Bian ', 'Min ', 'Yuan ', 'Jin ', 'Fu ', 'Ru ', 'Zhen ', 'Feng ', 'Shuai ', 'Gao ', 'Chan ', 'Li ', 'Yi ', 'Jian ', 'Bin ', 'Piao ', 'Man ', 'Lei ', 'Ying ', 'Suo ', 'Mou ', 'Sao ', 'Xie ', 'Liao ', 'Shan ', 'Zeng ', 'Jiang ', 'Qian ', 'Zao ', 'Huan ', 'Jiao ', 'Zuan ', 'Fou ', 'Xie ', 'Gang ', 'Fou ', 'Que ', 'Fou ', 'Kaakeru ', 'Bo ', 'Ping ', 'Hou ', '[?] ', 'Gang ', 'Ying ', 'Ying ', 'Qing ', 'Xia ', 'Guan ', 'Zun ', 'Tan ', 'Chang ', 'Qi ', 'Weng ', 'Ying ', 'Lei ', 'Tan ', 'Lu ', 'Guan ', 'Wang ', 'Wang ', 'Gang ', 'Wang ', 'Han ', '[?] ', 'Luo ', 'Fu ', 'Mi ', 'Fa ', 'Gu ', 'Zhu ', 'Ju ', 'Mao ', 'Gu ', 'Min ', 'Gang ', 'Ba ', 'Gua ', 'Ti ', 'Juan ', 'Fu ', 'Lin ', 'Yan ', 'Zhao ', 'Zui ', 'Gua ', 'Zhuo ', 'Yu ', 'Zhi ', 'An ', 'Fa ', 'Nan ', 'Shu ', 'Si ', 'Pi ', 'Ma ', 'Liu ', 'Ba ', 'Fa ', 'Li ', 'Chao ', 'Wei ', 'Bi ', 'Ji ', 'Zeng ', 'Tong ', 'Liu ', 'Ji ', 'Juan ', 'Mi ', 'Zhao ', 'Luo ', 'Pi ', 'Ji ', 'Ji ', 'Luan ', 'Yang ', 'Mie ', 'Qiang ', 'Ta ', 'Mei ', 'Yang ', 'You ', 'You ', 'Fen ', 'Ba ', 'Gao ', 'Yang ', 'Gu ', 'Qiang ', 'Zang ', 'Gao ', 'Ling ', 'Yi ', 'Zhu ', 'Di ', 'Xiu ', 'Qian ', 'Yi ', 'Xian ', 'Rong ', 'Qun ', 'Qun ', 'Qian ', 'Huan ', 'Zui ', 'Xian ', 'Yi ', 'Yashinau ', 'Qiang ', 'Xian ', 'Yu ', 'Geng ', 'Jie ', 'Tang ', 'Yuan ', 'Xi ', 'Fan ', 'Shan ', 'Fen ', 'Shan ', 'Lian ', 'Lei ', 'Geng ', 'Nou ', 'Qiang ', 'Chan ', 'Yu ', 'Gong ', 'Yi ', 'Chong ', 'Weng ', 'Fen ', 'Hong ', 'Chi ', 'Chi ', 'Cui ', 'Fu ', 'Xia ', 'Pen ', 'Yi ', 'La ', 'Yi ', 'Pi ', 'Ling ', 'Liu ', 'Zhi ', 'Qu ', 'Xi ', 'Xie ', 'Xiang ', 'Xi ', 'Xi ', 'Qi ', 'Qiao ', 'Hui ', 'Hui ', 'Xiao ', 'Se ', 'Hong ', 'Jiang ', 'Di ', 'Cui ', 'Fei ', 'Tao ', 'Sha ', 'Chi ', 'Zhu ', 'Jian ', 'Xuan ', 'Shi ', 'Pian ', 'Zong ', 'Wan ', 'Hui ', 'Hou ', 'He ', 'He ', 'Han ', 'Ao ', 'Piao ', 'Yi ', 'Lian ', 'Qu ', '[?] ', 'Lin ', 'Pen ', 'Qiao ', 'Ao ', 'Fan ', 'Yi ', 'Hui ', 'Xuan ', 'Dao '];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/x02e.php\",\"ext\":\"php\",\"size\":1853,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php return ['r', 'r.', '[?]', '[?]', '[?]', '[?]', 'T', 'T.', '[?]', 's', '[?]', '[]', '\\\\\\\\', '\/', '[?]', '__', '[?]', '[?]', '>', '%', '[?]', '[?]', '>', '=', '[?]', '\/', '-', '~', '\\\\\\\\', '\/', '~', '~', '|-', '-|', '[?]', '[?]', '[?]', '[?]', '<=', '=>', '((', '))', '[?]', '[?]', '::', '[?]', '?', '\\\\'', 'o', '.', ',', '.', ',', ';', '[?]', '[?]', '[?]', '[?]', '----', '------', 'x', '|', '[?]', '[?]', '=', ',', '\\\"', '`--', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?]', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?] ', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]', '[?]'];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/x029.php\",\"ext\":\"php\",\"size\":1038,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php return ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '{', '} ', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/ascii_language_max_key.php\",\"ext\":\"php\",\"size\":1849,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\nreturn [\\n    'uz'                => 0,\\n    'tk'                => 1,\\n    'th'                => 0,\\n    'ps'                => 0,\\n    'or'                => 0,\\n    'mn'                => 0,\\n    'ko'                => 0,\\n    'ky'                => 0,\\n    'hy'                => 1,\\n    'bn'                => 5,\\n    'be'                => 0,\\n    'am'                => 0,\\n    'ja'                => 0,\\n    'zh'                => 0,\\n    'nl'                => 1,\\n    'it'                => 1,\\n    'mk'                => 1,\\n    'pt'                => 1,\\n    'el__greeklish'     => 2,\\n    'el'                => 2,\\n    'hi'                => 2,\\n    'sv'                => 1,\\n    'tr'                => 1,\\n    'bg'                => 2,\\n    'hu'                => 1,\\n    'my'                => 5,\\n    'hr'                => 2,\\n    'fi'                => 1,\\n    'ka'                => 1,\\n    'ru'                => 1,\\n    'ru__gost_2000_b'   => 1,\\n    'ru__passport_2013' => 1,\\n    'uk'                => 1,\\n    'kk'                => 1,\\n    'cs'                => 1,\\n    'da'                => 1,\\n    'pl'                => 1,\\n    'ro'                => 1,\\n    'eo'                => 1,\\n    'et'                => 1,\\n    'lv'                => 1,\\n    'lt'                => 1,\\n    'no'                => 1,\\n    'vi'                => 1,\\n    'ar'                => 1,\\n    'fa'                => 1,\\n    'sr'                => 1,\\n    'sr__cyr'           => 1,\\n    'sr__lat'           => 1,\\n    'az'                => 1,\\n    'sk'                => 1,\\n    'fr'                => 1,\\n    'fr_at'             => 1,\\n    'fr_ch'             => 1,\\n    'de'                => 1,\\n    'de_at'             => 1,\\n    'de_ch'             => 1,\\n    'en'                => 0,\\n    'latin'             => 3,\\n    ' '                 => 1,\\n    'msword'            => 1,\\n];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/x06e.php\",\"ext\":\"php\",\"size\":2084,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php return ['Ben ', 'Yuan ', 'Wen ', 'Re ', 'Fei ', 'Qing ', 'Yuan ', 'Ke ', 'Ji ', 'She ', 'Yuan ', 'Shibui ', 'Lu ', 'Zi ', 'Du ', '[?] ', 'Jian ', 'Min ', 'Pi ', 'Tani ', 'Yu ', 'Yuan ', 'Shen ', 'Shen ', 'Rou ', 'Huan ', 'Zhu ', 'Jian ', 'Nuan ', 'Yu ', 'Qiu ', 'Ting ', 'Qu ', 'Du ', 'Feng ', 'Zha ', 'Bo ', 'Wo ', 'Wo ', 'Di ', 'Wei ', 'Wen ', 'Ru ', 'Xie ', 'Ce ', 'Wei ', 'Ge ', 'Gang ', 'Yan ', 'Hong ', 'Xuan ', 'Mi ', 'Ke ', 'Mao ', 'Ying ', 'Yan ', 'You ', 'Hong ', 'Miao ', 'Xing ', 'Mei ', 'Zai ', 'Hun ', 'Nai ', 'Kui ', 'Shi ', 'E ', 'Pai ', 'Mei ', 'Lian ', 'Qi ', 'Qi ', 'Mei ', 'Tian ', 'Cou ', 'Wei ', 'Can ', 'Tuan ', 'Mian ', 'Hui ', 'Mo ', 'Xu ', 'Ji ', 'Pen ', 'Jian ', 'Jian ', 'Hu ', 'Feng ', 'Xiang ', 'Yi ', 'Yin ', 'Zhan ', 'Shi ', 'Jie ', 'Cheng ', 'Huang ', 'Tan ', 'Yu ', 'Bi ', 'Min ', 'Shi ', 'Tu ', 'Sheng ', 'Yong ', 'Qu ', 'Zhong ', 'Suei ', 'Jiu ', 'Jiao ', 'Qiou ', 'Yin ', 'Tang ', 'Long ', 'Huo ', 'Yuan ', 'Nan ', 'Ban ', 'You ', 'Quan ', 'Chui ', 'Liang ', 'Chan ', 'Yan ', 'Chun ', 'Nie ', 'Zi ', 'Wan ', 'Shi ', 'Man ', 'Ying ', 'Ratsu ', 'Kui ', '[?] ', 'Jian ', 'Xu ', 'Lu ', 'Gui ', 'Gai ', '[?] ', '[?] ', 'Po ', 'Jin ', 'Gui ', 'Tang ', 'Yuan ', 'Suo ', 'Yuan ', 'Lian ', 'Yao ', 'Meng ', 'Zhun ', 'Sheng ', 'Ke ', 'Tai ', 'Da ', 'Wa ', 'Liu ', 'Gou ', 'Sao ', 'Ming ', 'Zha ', 'Shi ', 'Yi ', 'Lun ', 'Ma ', 'Pu ', 'Wei ', 'Li ', 'Cai ', 'Wu ', 'Xi ', 'Wen ', 'Qiang ', 'Ze ', 'Shi ', 'Su ', 'Yi ', 'Zhen ', 'Sou ', 'Yun ', 'Xiu ', 'Yin ', 'Rong ', 'Hun ', 'Su ', 'Su ', 'Ni ', 'Ta ', 'Shi ', 'Ru ', 'Wei ', 'Pan ', 'Chu ', 'Chu ', 'Pang ', 'Weng ', 'Cang ', 'Mie ', 'He ', 'Dian ', 'Hao ', 'Huang ', 'Xi ', 'Zi ', 'Di ', 'Zhi ', 'Ying ', 'Fu ', 'Jie ', 'Hua ', 'Ge ', 'Zi ', 'Tao ', 'Teng ', 'Sui ', 'Bi ', 'Jiao ', 'Hui ', 'Gun ', 'Yin ', 'Gao ', 'Long ', 'Zhi ', 'Yan ', 'She ', 'Man ', 'Ying ', 'Chun ', 'Lu ', 'Lan ', 'Luan ', '[?] ', 'Bin ', 'Tan ', 'Yu ', 'Sou ', 'Hu ', 'Bi ', 'Biao ', 'Zhi ', 'Jiang ', 'Kou ', 'Shen ', 'Shang ', 'Di ', 'Mi ', 'Ao ', 'Lu ', 'Hu ', 'Hu ', 'You ', 'Chan ', 'Fan ', 'Yong ', 'Gun ', 'Man '];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/x0d5.php\",\"ext\":\"php\",\"size\":2124,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php return ['pyuk', 'pyut', 'pyup', 'pyuh', 'peu', 'peug', 'peugg', 'peugs', 'peun', 'peunj', 'peunh', 'peud', 'peul', 'peulg', 'peulm', 'peulb', 'peuls', 'peult', 'peulp', 'peulh', 'peum', 'peub', 'peubs', 'peus', 'peuss', 'peung', 'peuj', 'peuc', 'peuk', 'peut', 'peup', 'peuh', 'pyi', 'pyig', 'pyigg', 'pyigs', 'pyin', 'pyinj', 'pyinh', 'pyid', 'pyil', 'pyilg', 'pyilm', 'pyilb', 'pyils', 'pyilt', 'pyilp', 'pyilh', 'pyim', 'pyib', 'pyibs', 'pyis', 'pyiss', 'pying', 'pyij', 'pyic', 'pyik', 'pyit', 'pyip', 'pyih', 'pi', 'pig', 'pigg', 'pigs', 'pin', 'pinj', 'pinh', 'pid', 'pil', 'pilg', 'pilm', 'pilb', 'pils', 'pilt', 'pilp', 'pilh', 'pim', 'pib', 'pibs', 'pis', 'piss', 'ping', 'pij', 'pic', 'pik', 'pit', 'pip', 'pih', 'ha', 'hag', 'hagg', 'hags', 'han', 'hanj', 'hanh', 'had', 'hal', 'halg', 'halm', 'halb', 'hals', 'halt', 'halp', 'halh', 'ham', 'hab', 'habs', 'has', 'hass', 'hang', 'haj', 'hac', 'hak', 'hat', 'hap', 'hah', 'hae', 'haeg', 'haegg', 'haegs', 'haen', 'haenj', 'haenh', 'haed', 'hael', 'haelg', 'haelm', 'haelb', 'haels', 'haelt', 'haelp', 'haelh', 'haem', 'haeb', 'haebs', 'haes', 'haess', 'haeng', 'haej', 'haec', 'haek', 'haet', 'haep', 'haeh', 'hya', 'hyag', 'hyagg', 'hyags', 'hyan', 'hyanj', 'hyanh', 'hyad', 'hyal', 'hyalg', 'hyalm', 'hyalb', 'hyals', 'hyalt', 'hyalp', 'hyalh', 'hyam', 'hyab', 'hyabs', 'hyas', 'hyass', 'hyang', 'hyaj', 'hyac', 'hyak', 'hyat', 'hyap', 'hyah', 'hyae', 'hyaeg', 'hyaegg', 'hyaegs', 'hyaen', 'hyaenj', 'hyaenh', 'hyaed', 'hyael', 'hyaelg', 'hyaelm', 'hyaelb', 'hyaels', 'hyaelt', 'hyaelp', 'hyaelh', 'hyaem', 'hyaeb', 'hyaebs', 'hyaes', 'hyaess', 'hyaeng', 'hyaej', 'hyaec', 'hyaek', 'hyaet', 'hyaep', 'hyaeh', 'heo', 'heog', 'heogg', 'heogs', 'heon', 'heonj', 'heonh', 'heod', 'heol', 'heolg', 'heolm', 'heolb', 'heols', 'heolt', 'heolp', 'heolh', 'heom', 'heob', 'heobs', 'heos', 'heoss', 'heong', 'heoj', 'heoc', 'heok', 'heot', 'heop', 'heoh', 'he', 'heg', 'hegg', 'hegs', 'hen', 'henj', 'henh', 'hed', 'hel', 'helg', 'helm', 'helb', 'hels', 'helt', 'help', 'helh', 'hem', 'heb', 'hebs', 'hes', 'hess', 'heng', 'hej', 'hec', 'hek', 'het', 'hep', 'heh'];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/x0b5.php\",\"ext\":\"php\",\"size\":2363,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php return ['dyil', 'dyilg', 'dyilm', 'dyilb', 'dyils', 'dyilt', 'dyilp', 'dyilh', 'dyim', 'dyib', 'dyibs', 'dyis', 'dyiss', 'dying', 'dyij', 'dyic', 'dyik', 'dyit', 'dyip', 'dyih', 'di', 'dig', 'digg', 'digs', 'din', 'dinj', 'dinh', 'did', 'dil', 'dilg', 'dilm', 'dilb', 'dils', 'dilt', 'dilp', 'dilh', 'dim', 'dib', 'dibs', 'dis', 'diss', 'ding', 'dij', 'dic', 'dik', 'dit', 'dip', 'dih', 'dda', 'ddag', 'ddagg', 'ddags', 'ddan', 'ddanj', 'ddanh', 'ddad', 'ddal', 'ddalg', 'ddalm', 'ddalb', 'ddals', 'ddalt', 'ddalp', 'ddalh', 'ddam', 'ddab', 'ddabs', 'ddas', 'ddass', 'ddang', 'ddaj', 'ddac', 'ddak', 'ddat', 'ddap', 'ddah', 'ddae', 'ddaeg', 'ddaegg', 'ddaegs', 'ddaen', 'ddaenj', 'ddaenh', 'ddaed', 'ddael', 'ddaelg', 'ddaelm', 'ddaelb', 'ddaels', 'ddaelt', 'ddaelp', 'ddaelh', 'ddaem', 'ddaeb', 'ddaebs', 'ddaes', 'ddaess', 'ddaeng', 'ddaej', 'ddaec', 'ddaek', 'ddaet', 'ddaep', 'ddaeh', 'ddya', 'ddyag', 'ddyagg', 'ddyags', 'ddyan', 'ddyanj', 'ddyanh', 'ddyad', 'ddyal', 'ddyalg', 'ddyalm', 'ddyalb', 'ddyals', 'ddyalt', 'ddyalp', 'ddyalh', 'ddyam', 'ddyab', 'ddyabs', 'ddyas', 'ddyass', 'ddyang', 'ddyaj', 'ddyac', 'ddyak', 'ddyat', 'ddyap', 'ddyah', 'ddyae', 'ddyaeg', 'ddyaegg', 'ddyaegs', 'ddyaen', 'ddyaenj', 'ddyaenh', 'ddyaed', 'ddyael', 'ddyaelg', 'ddyaelm', 'ddyaelb', 'ddyaels', 'ddyaelt', 'ddyaelp', 'ddyaelh', 'ddyaem', 'ddyaeb', 'ddyaebs', 'ddyaes', 'ddyaess', 'ddyaeng', 'ddyaej', 'ddyaec', 'ddyaek', 'ddyaet', 'ddyaep', 'ddyaeh', 'ddeo', 'ddeog', 'ddeogg', 'ddeogs', 'ddeon', 'ddeonj', 'ddeonh', 'ddeod', 'ddeol', 'ddeolg', 'ddeolm', 'ddeolb', 'ddeols', 'ddeolt', 'ddeolp', 'ddeolh', 'ddeom', 'ddeob', 'ddeobs', 'ddeos', 'ddeoss', 'ddeong', 'ddeoj', 'ddeoc', 'ddeok', 'ddeot', 'ddeop', 'ddeoh', 'dde', 'ddeg', 'ddegg', 'ddegs', 'dden', 'ddenj', 'ddenh', 'dded', 'ddel', 'ddelg', 'ddelm', 'ddelb', 'ddels', 'ddelt', 'ddelp', 'ddelh', 'ddem', 'ddeb', 'ddebs', 'ddes', 'ddess', 'ddeng', 'ddej', 'ddec', 'ddek', 'ddet', 'ddep', 'ddeh', 'ddyeo', 'ddyeog', 'ddyeogg', 'ddyeogs', 'ddyeon', 'ddyeonj', 'ddyeonh', 'ddyeod', 'ddyeol', 'ddyeolg', 'ddyeolm', 'ddyeolb', 'ddyeols', 'ddyeolt', 'ddyeolp', 'ddyeolh', 'ddyeom', 'ddyeob', 'ddyeobs', 'ddyeos', 'ddyeoss', 'ddyeong', 'ddyeoj', 'ddyeoc', 'ddyeok', 'ddyeot', 'ddyeop', 'ddyeoh', 'ddye', 'ddyeg', 'ddyegg', 'ddyegs', 'ddyen', 'ddyenj', 'ddyenh', 'ddyed', 'ddyel', 'ddyelg', 'ddyelm', 'ddyelb'];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/x0b3.php\",\"ext\":\"php\",\"size\":2185,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php return ['dae', 'daeg', 'daegg', 'daegs', 'daen', 'daenj', 'daenh', 'daed', 'dael', 'daelg', 'daelm', 'daelb', 'daels', 'daelt', 'daelp', 'daelh', 'daem', 'daeb', 'daebs', 'daes', 'daess', 'daeng', 'daej', 'daec', 'daek', 'daet', 'daep', 'daeh', 'dya', 'dyag', 'dyagg', 'dyags', 'dyan', 'dyanj', 'dyanh', 'dyad', 'dyal', 'dyalg', 'dyalm', 'dyalb', 'dyals', 'dyalt', 'dyalp', 'dyalh', 'dyam', 'dyab', 'dyabs', 'dyas', 'dyass', 'dyang', 'dyaj', 'dyac', 'dyak', 'dyat', 'dyap', 'dyah', 'dyae', 'dyaeg', 'dyaegg', 'dyaegs', 'dyaen', 'dyaenj', 'dyaenh', 'dyaed', 'dyael', 'dyaelg', 'dyaelm', 'dyaelb', 'dyaels', 'dyaelt', 'dyaelp', 'dyaelh', 'dyaem', 'dyaeb', 'dyaebs', 'dyaes', 'dyaess', 'dyaeng', 'dyaej', 'dyaec', 'dyaek', 'dyaet', 'dyaep', 'dyaeh', 'deo', 'deog', 'deogg', 'deogs', 'deon', 'deonj', 'deonh', 'deod', 'deol', 'deolg', 'deolm', 'deolb', 'deols', 'deolt', 'deolp', 'deolh', 'deom', 'deob', 'deobs', 'deos', 'deoss', 'deong', 'deoj', 'deoc', 'deok', 'deot', 'deop', 'deoh', 'de', 'deg', 'degg', 'degs', 'den', 'denj', 'denh', 'ded', 'del', 'delg', 'delm', 'delb', 'dels', 'delt', 'delp', 'delh', 'dem', 'deb', 'debs', 'des', 'dess', 'deng', 'dej', 'dec', 'dek', 'det', 'dep', 'deh', 'dyeo', 'dyeog', 'dyeogg', 'dyeogs', 'dyeon', 'dyeonj', 'dyeonh', 'dyeod', 'dyeol', 'dyeolg', 'dyeolm', 'dyeolb', 'dyeols', 'dyeolt', 'dyeolp', 'dyeolh', 'dyeom', 'dyeob', 'dyeobs', 'dyeos', 'dyeoss', 'dyeong', 'dyeoj', 'dyeoc', 'dyeok', 'dyeot', 'dyeop', 'dyeoh', 'dye', 'dyeg', 'dyegg', 'dyegs', 'dyen', 'dyenj', 'dyenh', 'dyed', 'dyel', 'dyelg', 'dyelm', 'dyelb', 'dyels', 'dyelt', 'dyelp', 'dyelh', 'dyem', 'dyeb', 'dyebs', 'dyes', 'dyess', 'dyeng', 'dyej', 'dyec', 'dyek', 'dyet', 'dyep', 'dyeh', 'do', 'dog', 'dogg', 'dogs', 'don', 'donj', 'donh', 'dod', 'dol', 'dolg', 'dolm', 'dolb', 'dols', 'dolt', 'dolp', 'dolh', 'dom', 'dob', 'dobs', 'dos', 'doss', 'dong', 'doj', 'doc', 'dok', 'dot', 'dop', 'doh', 'dwa', 'dwag', 'dwagg', 'dwags', 'dwan', 'dwanj', 'dwanh', 'dwad', 'dwal', 'dwalg', 'dwalm', 'dwalb', 'dwals', 'dwalt', 'dwalp', 'dwalh', 'dwam', 'dwab', 'dwabs', 'dwas', 'dwass', 'dwang', 'dwaj', 'dwac', 'dwak', 'dwat', 'dwap', 'dwah', 'dwae', 'dwaeg', 'dwaegg', 'dwaegs'];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/x07b.php\",\"ext\":\"php\",\"size\":2113,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php return ['Mang ', 'Zhu ', 'Utsubo ', 'Du ', 'Ji ', 'Xiao ', 'Ba ', 'Suan ', 'Ji ', 'Zhen ', 'Zhao ', 'Sun ', 'Ya ', 'Zhui ', 'Yuan ', 'Hu ', 'Gang ', 'Xiao ', 'Cen ', 'Pi ', 'Bi ', 'Jian ', 'Yi ', 'Dong ', 'Shan ', 'Sheng ', 'Xia ', 'Di ', 'Zhu ', 'Na ', 'Chi ', 'Gu ', 'Li ', 'Qie ', 'Min ', 'Bao ', 'Tiao ', 'Si ', 'Fu ', 'Ce ', 'Ben ', 'Pei ', 'Da ', 'Zi ', 'Di ', 'Ling ', 'Ze ', 'Nu ', 'Fu ', 'Gou ', 'Fan ', 'Jia ', 'Ge ', 'Fan ', 'Shi ', 'Mao ', 'Po ', 'Sey ', 'Jian ', 'Qiong ', 'Long ', 'Souke ', 'Bian ', 'Luo ', 'Gui ', 'Qu ', 'Chi ', 'Yin ', 'Yao ', 'Xian ', 'Bi ', 'Qiong ', 'Gua ', 'Deng ', 'Jiao ', 'Jin ', 'Quan ', 'Sun ', 'Ru ', 'Fa ', 'Kuang ', 'Zhu ', 'Tong ', 'Ji ', 'Da ', 'Xing ', 'Ce ', 'Zhong ', 'Kou ', 'Lai ', 'Bi ', 'Shai ', 'Dang ', 'Zheng ', 'Ce ', 'Fu ', 'Yun ', 'Tu ', 'Pa ', 'Li ', 'Lang ', 'Ju ', 'Guan ', 'Jian ', 'Han ', 'Tong ', 'Xia ', 'Zhi ', 'Cheng ', 'Suan ', 'Shi ', 'Zhu ', 'Zuo ', 'Xiao ', 'Shao ', 'Ting ', 'Ce ', 'Yan ', 'Gao ', 'Kuai ', 'Gan ', 'Chou ', 'Kago ', 'Gang ', 'Yun ', 'O ', 'Qian ', 'Xiao ', 'Jian ', 'Pu ', 'Lai ', 'Zou ', 'Bi ', 'Bi ', 'Bi ', 'Ge ', 'Chi ', 'Guai ', 'Yu ', 'Jian ', 'Zhao ', 'Gu ', 'Chi ', 'Zheng ', 'Jing ', 'Sha ', 'Zhou ', 'Lu ', 'Bo ', 'Ji ', 'Lin ', 'Suan ', 'Jun ', 'Fu ', 'Zha ', 'Gu ', 'Kong ', 'Qian ', 'Quan ', 'Jun ', 'Chui ', 'Guan ', 'Yuan ', 'Ce ', 'Ju ', 'Bo ', 'Ze ', 'Qie ', 'Tuo ', 'Luo ', 'Dan ', 'Xiao ', 'Ruo ', 'Jian ', 'Xuan ', 'Bian ', 'Sun ', 'Xiang ', 'Xian ', 'Ping ', 'Zhen ', 'Sheng ', 'Hu ', 'Shi ', 'Zhu ', 'Yue ', 'Chun ', 'Lu ', 'Wu ', 'Dong ', 'Xiao ', 'Ji ', 'Jie ', 'Huang ', 'Xing ', 'Mei ', 'Fan ', 'Chui ', 'Zhuan ', 'Pian ', 'Feng ', 'Zhu ', 'Hong ', 'Qie ', 'Hou ', 'Qiu ', 'Miao ', 'Qian ', '[?] ', 'Kui ', 'Sik ', 'Lou ', 'Yun ', 'He ', 'Tang ', 'Yue ', 'Chou ', 'Gao ', 'Fei ', 'Ruo ', 'Zheng ', 'Gou ', 'Nie ', 'Qian ', 'Xiao ', 'Cuan ', 'Gong ', 'Pang ', 'Du ', 'Li ', 'Bi ', 'Zhuo ', 'Chu ', 'Shai ', 'Chi ', 'Zhu ', 'Qiang ', 'Long ', 'Lan ', 'Jian ', 'Bu ', 'Li ', 'Hui ', 'Bi ', 'Di ', 'Cong ', 'Yan ', 'Peng ', 'Sen ', 'Zhuan ', 'Pai ', 'Piao ', 'Dou ', 'Yu ', 'Mie ', 'Zhuan '];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/data\/x000.php\",\"ext\":\"php\",\"size\":2163,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php return ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ' ', '!', '\\\"', '#', '$', '%', '&', '\\\\'', '(', ')', '*', '+', ',', '-', '.', '\/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[', '\\\\\\\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '', 'EUR',  \/\/ \\\"\\\\xc2\\\\x80\\\" => \\\"\\\\xe2\\\\x82\\\\xac\\\" => EURO SIGN\\n    '', ',', 'f', ',,',   \/\/ \\\"\\\\xc2\\\\x84\\\" => \\\"\\\\xe2\\\\x80\\\\x9e\\\" => DOUBLE LOW-9 QUOTATION MARK\\n    '...',  \/\/ \\\"\\\\xc2\\\\x85\\\" => \\\"\\\\xe2\\\\x80\\\\xa6\\\" =>  HORIZONTAL ELLIPSIS\\n    '+', '++',   \/\/ \\\"\\\\xc2\\\\x87\\\" => \\\"\\\\xe2\\\\x80\\\\xa1\\\" => DOUBLE DAGGER\\n    '^', '%0',   \/\/ \\\"\\\\xc2\\\\x89\\\" => \\\"\\\\xe2\\\\x80\\\\xb0\\\" => PER MILLE SIGN\\n    'S', '<', 'OE',   \/\/ \\\"\\\\xc2\\\\x8c\\\" => \\\"\\\\xc5\\\\x92\\\" => LATIN CAPITAL LIGATURE OE\\n    '', 'Z', '', '', '\\\\'',   \/\/ \\\"\\\\xc2\\\\x91\\\" => \\\"\\\\xe2\\\\x80\\\\x98\\\" => LEFT SINGLE QUOTATION MARK\\n    '\\\\'',   \/\/ \\\"\\\\xc2\\\\x92\\\" => \\\"\\\\xe2\\\\x80\\\\x99\\\" => RIGHT SINGLE QUOTATION MARK\\n    '\\\"', '\\\"', '*', '-', '--',   \/\/ \\\"\\\\xc2\\\\x97\\\" => \\\"\\\\xe2\\\\x80\\\\x94\\\" => EM DASH\\n    '~', 'tm', 's', '>', 'oe', '', 'z', 'Y', ' ', '!', 'C\/', 'PS', '$?', 'Y=', '|', 'SS', '\\\"', '(c)', 'a', '<<', '!', '', '(r)', '-', 'deg', '+-', '2', '3', '\\\\'', 'u', 'P', '*', ',', '1', 'o', '>>', '1\/4', '1\/2', '3\/4', '?', 'A', 'A', 'A', 'A', \/\/ Not \\\"AE\\\" - used in languages other than German\\n    'A', 'A', 'AE', 'C', 'E', 'E', 'E', 'E', 'I', 'I', 'I', 'I', 'D', 'N', 'O', 'O', 'O', 'O', \/\/ Not \\\"OE\\\" - used in languages other than German\\n    'O', 'x', 'O', 'U', 'U', 'U', \/\/ Not \\\"UE\\\" - used in languages other than German\\n    'U', 'Y', 'Th', 'ss', 'a', 'a', 'a', 'a', \/\/ Not \\\"ae\\\" - used in languages other than German\\n    'a', 'a', 'ae', 'c', 'e', 'e', 'e', 'e', 'i', 'i', 'i', 'i', 'd', 'n', 'o', 'o', 'o', 'o', \/\/ Not \\\"oe\\\" - used in languages other than German\\n    'o', '\/', 'o', 'u', 'u', 'u', \/\/ Not \\\"ue\\\" - used in languages other than German\\n    'u', 'y', 'th', 'y', ];\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/src\/voku\/helper\/ASCII.php\",\"ext\":\"php\",\"size\":50611,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\nnamespace voku\\\\helper;\\n\\n\/**\\n * ## \ud83c\uddf7\ud83c\uddfa \u0420\u0443\u0441\u0441\u043a\u0438\u043c \u0433\u0440\u0430\u0436\u0434\u0430\u043d\u0430\u043c\\n * \u0412 \u0423\u043a\u0440\u0430\u0438\u043d\u0435 \u0441\u0435\u0439\u0447\u0430\u0441 \u0438\u0434\u0435\u0442 \u0432\u043e\u0439\u043d\u0430. \u0421\u0438\u043b\u0430\u043c\u0438 \u0420\u0424 \u043d\u0430\u043d\u043e\u0441\u044f\u0442\u0441\u044f \u0443\u0434\u0430\u0440\u044b \u043f\u043e \u0433\u0440\u0430\u0436\u0434\u0430\u043d\u0441\u043a\u043e\u0439 \u0438\u043d\u0444\u0440\u0430\u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0435 \u0432 [\u0425\u0430\u0440\u044c\u043a\u043e\u0432\u0435][1], [\u041a\u0438\u0435\u0432\u0435][2], [\u0427\u0435\u0440\u043d\u0438\u0433\u043e\u0432\u0435][3], [\u0421\u0443\u043c\u0430\u0445][4], [\u0418\u0440\u043f\u0435\u043d\u0435][5] \u0438 \u0434\u0435\u0441\u044f\u0442\u043a\u0430\u0445 \u0434\u0440\u0443\u0433\u0438\u0445 \u0433\u043e\u0440\u043e\u0434\u043e\u0432. \u0413\u0438\u0431\u043d\u0443\u0442 \u043b\u044e\u0434\u0438 - \u0438 \u0433\u0440\u0430\u0436\u0434\u0430\u043d\u0441\u043a\u043e\u0435 \u043d\u0430\u0441\u0435\u043b\u0435\u043d\u0438\u0435, \u0438 \u0432\u043e\u0435\u043d\u043d\u044b\u0435, \u0432 \u0442\u043e\u043c \u0447\u0438\u0441\u043b\u0435 \u0440\u043e\u0441\u0441\u0438\u0439\u0441\u043a\u0438\u0435 \u043f\u0440\u0438\u0437\u044b\u0432\u043d\u0438\u043a\u0438, \u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u0431\u0440\u043e\u0441\u0438\u043b\u0438 \u0432\u043e\u0435\u0432\u0430\u0442\u044c. \u0427\u0442\u043e\u0431\u044b \u043b\u0438\u0448\u0438\u0442\u044c \u0441\u043e\u0431\u0441\u0442\u0432\u0435\u043d\u043d\u044b\u0439 \u043d\u0430\u0440\u043e\u0434 \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u043a \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438, \u043f\u0440\u0430\u0432\u0438\u0442\u0435\u043b\u044c\u0441\u0442\u0432\u043e \u0420\u0424 \u0437\u0430\u043f\u0440\u0435\u0442\u0438\u043b\u043e \u043d\u0430\u0437\u044b\u0432\u0430\u0442\u044c \u0432\u043e\u0439\u043d\u0443 \u0432\u043e\u0439\u043d\u043e\u0439, \u0437\u0430\u043a\u0440\u044b\u043b\u043e \u043d\u0435\u0437\u0430\u0432\u0438\u0441\u0438\u043c\u044b\u0435 \u0421\u041c\u0418 \u0438 \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442 \u0441\u0435\u0439\u0447\u0430\u0441 \u0440\u044f\u0434 \u0434\u0438\u043a\u0442\u0430\u0442\u043e\u0440\u0441\u043a\u0438\u0445 \u0437\u0430\u043a\u043e\u043d\u043e\u0432. \u042d\u0442\u0438 \u0437\u0430\u043a\u043e\u043d\u044b \u043f\u0440\u0438\u0437\u0432\u0430\u043d\u044b \u0437\u0430\u0442\u043a\u043d\u0443\u0442\u044c \u0440\u043e\u0442 \u0432\u0441\u0435\u043c, \u043a\u0442\u043e \u043f\u0440\u043e\u0442\u0438\u0432 \u0432\u043e\u0439\u043d\u044b. \u0417\u0430 \u043e\u0431\u044b\u0447\u043d\u044b\u0439 \u043f\u0440\u0438\u0437\u044b\u0432 \u043a \u043c\u0438\u0440\u0443 \u0441\u0435\u0439\u0447\u0430\u0441 \u043c\u043e\u0436\u043d\u043e \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u043b\u0435\u0442 \u0442\u044e\u0440\u044c\u043c\u044b.\\n * \u041d\u0435 \u043c\u043e\u043b\u0447\u0438\u0442\u0435! \u041c\u043e\u043b\u0447\u0430\u043d\u0438\u0435 - \u0437\u043d\u0430\u043a \u0432\u0430\u0448\u0435\u0433\u043e \u0441\u043e\u0433\u043b\u0430\u0441\u0438\u044f \u0441 \u043f\u043e\u043b\u0438\u0442\u0438\u043a\u043e\u0439 \u0440\u043e\u0441\u0441\u0438\u0439\u0441\u043a\u043e\u0433\u043e \u043f\u0440\u0430\u0432\u0438\u0442\u0435\u043b\u044c\u0441\u0442\u0432\u0430.\\n *  **\u0412\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u0441\u0434\u0435\u043b\u0430\u0442\u044c \u0432\u044b\u0431\u043e\u0440 \u041d\u0415 \u041c\u041e\u041b\u0427\u0410\u0422\u042c.**\\n * ---\\n * ## \ud83c\uddfa\ud83c\uddf8 To people of Russia\\n * There is a war in Ukraine right now. The forces of the Russian Federation are attacking civilian infrastructure in [Kharkiv][1], [Kyiv][2], [Chernihiv][3], [Sumy][4], [Irpin][5] and dozens of other cities. People are dying \u2013 both civilians and military servicemen, including Russian conscripts who were thrown into the fighting. In order to deprive its own people of access to information, the government of the Russian Federation has forbidden calling a war a war, shut down independent media and is passing a number of dictatorial laws. These laws are meant to silence all those who are against war. You can be jailed for multiple years for simply calling for peace.\\n * Do not be silent! Silence is a sign that you accept the Russian government's policy.\\n * **You can choose NOT TO BE SILENT.**\\n * ---\\n * - [1] https:\/\/cloudfront-us-east-2.images.arcpublishing.com\/reuters\/P7K2MSZDGFMIJPDD7CI2GIROJI.jpg \\\"Kharkiv under attack\\\"\\n * - [2] https:\/\/gdb.voanews.com\/01bd0000-0aff-0242-fad0-08d9fc92c5b3_cx0_cy5_cw0_w1023_r1_s.jpg \\\"Kyiv under attack\\\"\\n * - [3] https:\/\/ichef.bbci.co.uk\/news\/976\/cpsprodpb\/163DD\/production\/_123510119_hi074310744.jpg \\\"Chernihiv under attack\\\"\\n * - [4] https:\/\/www.youtube.com\/watch?v=8K-bkqKKf2A \\\"Sumy under attack\\\"\\n * - [5] https:\/\/cloudfront-us-east-2.images.arcpublishing.com\/reuters\/K4MTMLEHTRKGFK3GSKAT4GR3NE.jpg \\\"Irpin under attack\\\"\\n *\\n * @psalm-immutable\\n *\/\\nfinal class ASCII\\n{\\n    \/\/\\n    \/\/ INFO: https:\/\/en.wikipedia.org\/wiki\/List_of_ISO_639-1_codes\\n    \/\/\\n\\n    const UZBEK_LANGUAGE_CODE = 'uz';\\n\\n    const TURKMEN_LANGUAGE_CODE = 'tk';\\n\\n    const THAI_LANGUAGE_CODE = 'th';\\n\\n    const PASHTO_LANGUAGE_CODE = 'ps';\\n\\n    const ORIYA_LANGUAGE_CODE = 'or';\\n\\n    const MONGOLIAN_LANGUAGE_CODE = 'mn';\\n\\n    const KOREAN_LANGUAGE_CODE = 'ko';\\n\\n    const KIRGHIZ_LANGUAGE_CODE = 'ky';\\n\\n    const ARMENIAN_LANGUAGE_CODE = 'hy';\\n\\n    const BENGALI_LANGUAGE_CODE = 'bn';\\n\\n    const BELARUSIAN_LANGUAGE_CODE = 'be';\\n\\n    const AMHARIC_LANGUAGE_CODE = 'am';\\n\\n    const JAPANESE_LANGUAGE_CODE = 'ja';\\n\\n    const CHINESE_LANGUAGE_CODE = 'zh';\\n\\n    const DUTCH_LANGUAGE_CODE = 'nl';\\n\\n    const ITALIAN_LANGUAGE_CODE = 'it';\\n\\n    const MACEDONIAN_LANGUAGE_CODE = 'mk';\\n\\n    const PORTUGUESE_LANGUAGE_CODE = 'pt';\\n\\n    const GREEKLISH_LANGUAGE_CODE = 'el__greeklish';\\n\\n    const GREEK_LANGUAGE_CODE = 'el';\\n\\n    const HINDI_LANGUAGE_CODE = 'hi';\\n\\n    const SWEDISH_LANGUAGE_CODE = 'sv';\\n\\n    const TURKISH_LANGUAGE_CODE = 'tr';\\n\\n    const BULGARIAN_LANGUAGE_CODE = 'bg';\\n\\n    const HUNGARIAN_LANGUAGE_CODE = 'hu';\\n\\n    const MYANMAR_LANGUAGE_CODE = 'my';\\n\\n    const CROATIAN_LANGUAGE_CODE = 'hr';\\n\\n    const FINNISH_LANGUAGE_CODE = 'fi';\\n\\n    const GEORGIAN_LANGUAGE_CODE = 'ka';\\n\\n    const RUSSIAN_LANGUAGE_CODE = 'ru';\\n\\n    const RUSSIAN_PASSPORT_2013_LANGUAGE_CODE = 'ru__passport_2013';\\n\\n    const RUSSIAN_GOST_2000_B_LANGUAGE_CODE = 'ru__gost_2000_b';\\n\\n    const UKRAINIAN_LANGUAGE_CODE = 'uk';\\n\\n    const KAZAKH_LANGUAGE_CODE = 'kk';\\n\\n    const CZECH_LANGUAGE_CODE = 'cs';\\n\\n    const DANISH_LANGUAGE_CODE = 'da';\\n\\n    const POLISH_LANGUAGE_CODE = 'pl';\\n\\n    const ROMANIAN_LANGUAGE_CODE = 'ro';\\n\\n    const ESPERANTO_LANGUAGE_CODE = 'eo';\\n\\n    const ESTONIAN_LANGUAGE_CODE = 'et';\\n\\n    const LATVIAN_LANGUAGE_CODE = 'lv';\\n\\n    const LITHUANIAN_LANGUAGE_CODE = 'lt';\\n\\n    const NORWEGIAN_LANGUAGE_CODE = 'no';\\n\\n    const VIETNAMESE_LANGUAGE_CODE = 'vi';\\n\\n    const ARABIC_LANGUAGE_CODE = 'ar';\\n\\n    const PERSIAN_LANGUAGE_CODE = 'fa';\\n\\n    const SERBIAN_LANGUAGE_CODE = 'sr';\\n\\n    const SERBIAN_CYRILLIC_LANGUAGE_CODE = 'sr__cyr';\\n\\n    const SERBIAN_LATIN_LANGUAGE_CODE = 'sr__lat';\\n\\n    const AZERBAIJANI_LANGUAGE_CODE = 'az';\\n\\n    const SLOVAK_LANGUAGE_CODE = 'sk';\\n\\n    const FRENCH_LANGUAGE_CODE = 'fr';\\n\\n    const FRENCH_AUSTRIAN_LANGUAGE_CODE = 'fr_at';\\n\\n    const FRENCH_SWITZERLAND_LANGUAGE_CODE = 'fr_ch';\\n\\n    const GERMAN_LANGUAGE_CODE = 'de';\\n\\n    const GERMAN_AUSTRIAN_LANGUAGE_CODE = 'de_at';\\n\\n    const GERMAN_SWITZERLAND_LANGUAGE_CODE = 'de_ch';\\n\\n    const ENGLISH_LANGUAGE_CODE = 'en';\\n\\n    const EXTRA_LATIN_CHARS_LANGUAGE_CODE = 'latin';\\n\\n    const EXTRA_WHITESPACE_CHARS_LANGUAGE_CODE = ' ';\\n\\n    const EXTRA_MSWORD_CHARS_LANGUAGE_CODE = 'msword';\\n\\n    \/**\\n     * @var array<string, array<string, string>>|null\\n     *\/\\n    private static $ASCII_MAPS;\\n\\n    \/**\\n     * @var array<string, array<string, string>>|null\\n     *\/\\n    private static $ASCII_MAPS_AND_EXTRAS;\\n\\n    \/**\\n     * @var array<string, array<string, string>>|null\\n     *\/\\n    private static $ASCII_EXTRAS;\\n\\n    \/**\\n     * @var array<string, int>|null\\n     *\/\\n    private static $ORD;\\n\\n    \/**\\n     * @var array<string, int>|null\\n     *\/\\n    private static $LANGUAGE_MAX_KEY;\\n\\n    \/**\\n     * url: https:\/\/en.wikipedia.org\/wiki\/Wikipedia:ASCII#ASCII_printable_characters\\n     *\\n     * @var string\\n     *\/\\n    private static $REGEX_ASCII = \\\"[^\\\\x09\\\\x10\\\\x13\\\\x0A\\\\x0D\\\\x20-\\\\x7E]\\\";\\n\\n    \/**\\n     * bidirectional text chars\\n     *\\n     * url: https:\/\/www.w3.org\/International\/questions\/qa-bidi-unicode-controls\\n     *\\n     * @var array<int, string>\\n     *\/\\n    private static $BIDI_UNI_CODE_CONTROLS_TABLE = [\\n        \/\/ LEFT-TO-RIGHT EMBEDDING (use -> dir = \\\"ltr\\\")\\n        8234 => \\\"\\\\xE2\\\\x80\\\\xAA\\\",\\n        \/\/ RIGHT-TO-LEFT EMBEDDING (use -> dir = \\\"rtl\\\")\\n        8235 => \\\"\\\\xE2\\\\x80\\\\xAB\\\",\\n        \/\/ POP DIRECTIONAL FORMATTING \/\/ (use -> <\/bdo>)\\n        8236 => \\\"\\\\xE2\\\\x80\\\\xAC\\\",\\n        \/\/ LEFT-TO-RIGHT OVERRIDE \/\/ (use -> <bdo dir = \\\"ltr\\\">)\\n        8237 => \\\"\\\\xE2\\\\x80\\\\xAD\\\",\\n        \/\/ RIGHT-TO-LEFT OVERRIDE \/\/ (use -> <bdo dir = \\\"rtl\\\">)\\n        8238 => \\\"\\\\xE2\\\\x80\\\\xAE\\\",\\n        \/\/ LEFT-TO-RIGHT ISOLATE \/\/ (use -> dir = \\\"ltr\\\")\\n        8294 => \\\"\\\\xE2\\\\x81\\\\xA6\\\",\\n        \/\/ RIGHT-TO-LEFT ISOLATE \/\/ (use -> dir = \\\"rtl\\\")\\n        8295 => \\\"\\\\xE2\\\\x81\\\\xA7\\\",\\n        \/\/ FIRST STRONG ISOLATE \/\/ (use -> dir = \\\"auto\\\")\\n        8296 => \\\"\\\\xE2\\\\x81\\\\xA8\\\",\\n        \/\/ POP DIRECTIONAL ISOLATE\\n        8297 => \\\"\\\\xE2\\\\x81\\\\xA9\\\",\\n    ];\\n\\n    \/**\\n     * Get all languages from the constants \\\"ASCII::.*LANGUAGE_CODE\\\".\\n     *\\n     * @return array<string, string>\\n     *                                 <p>An associative array where the key is the language code in lowercase\\n     *                                 and the value is the corresponding language string.<\/p>\\n     *\/\\n    public static function getAllLanguages(): array\\n    {\\n        \/\/ init\\n        static $LANGUAGES = [];\\n\\n        if ($LANGUAGES !== []) {\\n            return $LANGUAGES;\\n        }\\n\\n        foreach ((new \\\\ReflectionClass(__CLASS__))->getConstants() as $constant => $lang) {\\n            if (\\\\strpos($constant, 'EXTRA') !== false) {\\n                $LANGUAGES[\\\\strtolower($constant)] = $lang;\\n            } else {\\n                $LANGUAGES[\\\\strtolower(\\\\str_replace('_LANGUAGE_CODE', '', $constant))] = $lang;\\n            }\\n        }\\n\\n        return $LANGUAGES;\\n    }\\n\\n    \/**\\n     * Returns an replacement array for ASCII methods.\\n     *\\n     * EXAMPLE: <code>\\n     * $array = ASCII::charsArray();\\n     * var_dump($array['ru']['\u0431']); \/\/ 'b'\\n     * <\/code>\\n     *\\n     * @param bool $replace_extra_symbols [optional] <p>Add some more replacements e.g. \\\"\u00a3\\\" with \\\" pound \\\".<\/p>\\n     *\\n     * @psalm-pure\\n     *\\n     * @return array<string, array<string , string>>\\n     *                                               <p>An array where the key is the language code, and the value is\\n     *                                               an associative array mapping original characters to their replacements.<\/p>\\n     *\/\\n    public static function charsArray(bool $replace_extra_symbols = false): array\\n    {\\n        if ($replace_extra_symbols) {\\n            self::prepareAsciiAndExtrasMaps();\\n\\n            return self::$ASCII_MAPS_AND_EXTRAS ?? [];\\n        }\\n\\n        self::prepareAsciiMaps();\\n\\n        return self::$ASCII_MAPS ?? [];\\n    }\\n\\n    \/**\\n     * Returns an replacement array for ASCII methods with a mix of multiple languages.\\n     *\\n     * EXAMPLE: <code>\\n     * $array = ASCII::charsArrayWithMultiLanguageValues();\\n     * var_dump($array['b']); \/\/ ['\u03b2', '\u0431', '\u1017', '\u10d1', '\u0628']\\n     * <\/code>\\n     *\\n     * @param bool $replace_extra_symbols [optional] <p>Add some more replacements e.g. \\\"\u00a3\\\" with \\\" pound \\\".<\/p>\\n     *\\n     * @psalm-pure\\n     *\\n     * @return array<string, list<string>>\\n     *                                     <p>An array of replacements.<\/p>\\n     *\/\\n    public static function charsArrayWithMultiLanguageValues(bool $replace_extra_symbols = false): array\\n    {\\n        static $CHARS_ARRAY = [];\\n        $cacheKey = '' . $replace_extra_symbols;\\n\\n        if (isset($CHARS_ARRAY[$cacheKey])) {\\n            return $CHARS_ARRAY[$cacheKey];\\n        }\\n\\n        \/\/ init\\n        $return = [];\\n        $language_all_chars = self::charsArrayWithSingleLanguageValues(\\n            $replace_extra_symbols,\\n            false\\n        );\\n\\n        \/* @noinspection AlterInForeachInspection | ok here *\/\\n        foreach ($language_all_chars as $key => &$value) {\\n            $return[$value][] = $key;\\n        }\\n\\n        $CHARS_ARRAY[$cacheKey] = $return;\\n\\n        return $return;\\n    }\\n\\n    \/**\\n     * Returns an replacement array for ASCII methods with one language.\\n     *\\n     * For example, German will map '\u00e4' to 'ae', while other languages\\n     * will simply return e.g. 'a'.\\n     *\\n     * EXAMPLE: <code>\\n     * $array = ASCII::charsArrayWithOneLanguage('ru');\\n     * $tmpKey = \\\\array_search('yo', $array['replace']);\\n     * echo $array['orig'][$tmpKey]; \/\/ '\u0451'\\n     * <\/code>\\n     *\\n     * @param string $language              [optional] <p>Language of the source string e.g.: en, de_at, or de-ch.\\n     *                                      (default is 'en') | ASCII::*_LANGUAGE_CODE<\/p>\\n     * @param bool   $replace_extra_symbols [optional] <p>Add some more replacements e.g. \\\"\u00a3\\\" with \\\" pound \\\".<\/p>\\n     * @param bool   $asOrigReplaceArray    [optional] <p>TRUE === return {orig: list<string>, replace: list<string>}\\n     *                                      array<\/p>\\n     *\\n     * @psalm-pure\\n     *\\n     * @return ($asOrigReplaceArray is true ? array{orig: list<string>, replace: list<string>} : array<string, string>)\\n     *\\n     * @phpstan-param ASCII::*_LANGUAGE_CODE $language\\n     *\/\\n    public static function charsArrayWithOneLanguage(\\n        string $language = self::ENGLISH_LANGUAGE_CODE,\\n        bool $replace_extra_symbols = false,\\n        bool $asOrigReplaceArray = true\\n    ): array {\\n        $language = self::get_language($language);\\n\\n        \/\/ init\\n        static $CHARS_ARRAY = [];\\n        $cacheKey = '' . $replace_extra_symbols . '-' . $asOrigReplaceArray;\\n\\n        \/\/ check static cache\\n        if (isset($CHARS_ARRAY[$cacheKey][$language])) {\\n            return $CHARS_ARRAY[$cacheKey][$language];\\n        }\\n\\n        if ($replace_extra_symbols) {\\n            self::prepareAsciiAndExtrasMaps();\\n\\n            if (isset(self::$ASCII_MAPS_AND_EXTRAS[$language])) {\\n                $tmpArray = self::$ASCII_MAPS_AND_EXTRAS[$language];\\n\\n                if ($asOrigReplaceArray) {\\n                    $CHARS_ARRAY[$cacheKey][$language] = [\\n                        'orig'    => \\\\array_keys($tmpArray),\\n                        'replace' => \\\\array_values($tmpArray),\\n                    ];\\n                } else {\\n                    $CHARS_ARRAY[$cacheKey][$language] = $tmpArray;\\n                }\\n            } else {\\n                if ($asOrigReplaceArray) {\\n                    $CHARS_ARRAY[$cacheKey][$language] = [\\n                        'orig'    => [],\\n                        'replace' => [],\\n                    ];\\n                } else {\\n                    $CHARS_ARRAY[$cacheKey][$language] = [];\\n                }\\n            }\\n        } else {\\n            self::prepareAsciiMaps();\\n\\n            if (isset(self::$ASCII_MAPS[$language])) {\\n                $tmpArray = self::$ASCII_MAPS[$language];\\n\\n                if ($asOrigReplaceArray) {\\n                    $CHARS_ARRAY[$cacheKey][$language] = [\\n                        'orig'    => \\\\array_keys($tmpArray),\\n                        'replace' => \\\\array_values($tmpArray),\\n                    ];\\n                } else {\\n                    $CHARS_ARRAY[$cacheKey][$language] = $tmpArray;\\n                }\\n            } else {\\n                if ($asOrigReplaceArray) {\\n                    $CHARS_ARRAY[$cacheKey][$language] = [\\n                        'orig'    => [],\\n                        'replace' => [],\\n                    ];\\n                } else {\\n                    $CHARS_ARRAY[$cacheKey][$language] = [];\\n                }\\n            }\\n        }\\n\\n        return $CHARS_ARRAY[$cacheKey][$language] ?? ['orig' => [], 'replace' => []];\\n    }\\n\\n    \/**\\n     * Returns an replacement array for ASCII methods with multiple languages.\\n     *\\n     * EXAMPLE: <code>\\n     * $array = ASCII::charsArrayWithSingleLanguageValues();\\n     * $tmpKey = \\\\array_search('hnaik', $array['replace']);\\n     * echo $array['orig'][$tmpKey]; \/\/ '\u104c'\\n     * <\/code>\\n     *\\n     * @param bool $replace_extra_symbols [optional] <p>Add some more replacements e.g. \\\"\u00a3\\\" with \\\" pound \\\".<\/p>\\n     * @param bool $asOrigReplaceArray    [optional] <p>TRUE === return {orig: list<string>, replace: list<string>}\\n     *                                    array<\/p>\\n     *\\n     * @psalm-pure\\n     *\\n     * @return ($asOrigReplaceArray is true ? array{orig: list<string>, replace: list<string>} : array<string, string>)\\n     *\/\\n    public static function charsArrayWithSingleLanguageValues(\\n        bool $replace_extra_symbols = false,\\n        bool $asOrigReplaceArray = true\\n    ): array {\\n        \/\/ init\\n        static $CHARS_ARRAY = [];\\n        $cacheKey = '' . $replace_extra_symbols . '-' . $asOrigReplaceArray;\\n\\n        if (isset($CHARS_ARRAY[$cacheKey])) {\\n            return $CHARS_ARRAY[$cacheKey];\\n        }\\n\\n        if ($replace_extra_symbols) {\\n            self::prepareAsciiAndExtrasMaps();\\n\\n            \/* @noinspection AlterInForeachInspection | ok here *\/\\n            foreach (self::$ASCII_MAPS_AND_EXTRAS ?? [] as &$map) {\\n                $CHARS_ARRAY[$cacheKey][] = $map;\\n            }\\n        } else {\\n            self::prepareAsciiMaps();\\n\\n            \/* @noinspection AlterInForeachInspection | ok here *\/\\n            foreach (self::$ASCII_MAPS ?? [] as &$map) {\\n                $CHARS_ARRAY[$cacheKey][] = $map;\\n            }\\n        }\\n\\n        $CHARS_ARRAY[$cacheKey] = \\\\array_merge([], ...$CHARS_ARRAY[$cacheKey]);\\n\\n        if ($asOrigReplaceArray) {\\n            $CHARS_ARRAY[$cacheKey] = [\\n                'orig'    => \\\\array_keys($CHARS_ARRAY[$cacheKey]),\\n                'replace' => \\\\array_values($CHARS_ARRAY[$cacheKey]),\\n            ];\\n        }\\n\\n        return $CHARS_ARRAY[$cacheKey];\\n    }\\n\\n    \/**\\n     * Accepts a string and removes all non-UTF-8 characters from it + extras if needed.\\n     *\\n     * @param string $str                         <p>The string to be sanitized.<\/p>\\n     * @param bool   $normalize_whitespace        [optional] <p>Set to true, if you need to normalize the\\n     *                                            whitespace.<\/p>\\n     * @param bool   $normalize_msword            [optional] <p>Set to true, if you need to normalize MS Word chars\\n     *                                            e.g.: \\\"\u2026\\\"\\n     *                                            => \\\"...\\\"<\/p>\\n     * @param bool   $keep_non_breaking_space     [optional] <p>Set to true, to keep non-breaking-spaces, in\\n     *                                            combination with\\n     *                                            $normalize_whitespace<\/p>\\n     * @param bool   $remove_invisible_characters [optional] <p>Set to false, if you not want to remove invisible\\n     *                                            characters e.g.: \\\"\\\\0\\\"<\/p>\\n     *\\n     * @psalm-pure\\n     *\\n     * @return string\\n     *                <p>A clean UTF-8 string.<\/p>\\n     *\/\\n    public static function clean(\\n        string $str,\\n        bool $normalize_whitespace = true,\\n        bool $keep_non_breaking_space = false,\\n        bool $normalize_msword = true,\\n        bool $remove_invisible_characters = true\\n    ): string {\\n        \/\/ http:\/\/stackoverflow.com\/questions\/1401317\/remove-non-utf8-characters-from-string\\n        \/\/ caused connection reset problem on larger strings\\n\\n        $regex = '\/\\n          (\\n            (?: [\\\\x00-\\\\x7F]               # single-byte sequences   0xxxxxxx\\n            |   [\\\\xC0-\\\\xDF][\\\\x80-\\\\xBF]    # double-byte sequences   110xxxxx 10xxxxxx\\n            |   [\\\\xE0-\\\\xEF][\\\\x80-\\\\xBF]{2} # triple-byte sequences   1110xxxx 10xxxxxx * 2\\n            |   [\\\\xF0-\\\\xF7][\\\\x80-\\\\xBF]{3} # quadruple-byte sequence 11110xxx 10xxxxxx * 3\\n            ){1,100}                      # ...one or more times\\n          )\\n        | ( [\\\\x80-\\\\xBF] )                 # invalid byte in range 10000000 - 10111111\\n        | ( [\\\\xC0-\\\\xFF] )                 # invalid byte in range 11000000 - 11111111\\n        \/x';\\n        $str = (string) \\\\preg_replace($regex, '$1', $str);\\n\\n        if ($normalize_whitespace) {\\n            $str = self::normalize_whitespace($str, $keep_non_breaking_space);\\n        }\\n\\n        if ($normalize_msword) {\\n            $str = self::normalize_msword($str);\\n        }\\n\\n        if ($remove_invisible_characters) {\\n            $str = self::remove_invisible_characters($str);\\n        }\\n\\n        return $str;\\n    }\\n\\n    \/**\\n     * Checks if a string is 7 bit ASCII.\\n     *\\n     * EXAMPLE: <code>\\n     * ASCII::is_ascii('\u767d'); \/\/ false\\n     * <\/code>\\n     *\\n     * @param string $str <p>The string to check.<\/p>\\n     *\\n     * @psalm-pure\\n     *\\n     * @return bool\\n     *              <p>\\n     *              <strong>true<\/strong> if it is ASCII<br>\\n     *              <strong>false<\/strong> otherwise\\n     *              <\/p>\\n     *\/\\n    public static function is_ascii(string $str): bool\\n    {\\n        if ($str === '') {\\n            return true;\\n        }\\n\\n        return !\\\\preg_match('\/' . self::$REGEX_ASCII . '\/', $str);\\n    }\\n\\n    \/**\\n     * Returns a string with smart quotes, ellipsis characters, and dashes from\\n     * Windows-1252 (commonly used in Word documents) replaced by their ASCII\\n     * equivalents.\\n     *\\n     * EXAMPLE: <code>\\n     * ASCII::normalize_msword('\u201eAbcdef\u2026\u201d'); \/\/ '\\\"Abcdef...\\\"'\\n     * <\/code>\\n     *\\n     * @param string $str <p>The string to be normalized.<\/p>\\n     *\\n     * @psalm-pure\\n     *\\n     * @return string\\n     *                <p>A string with normalized characters for commonly used chars in Word documents.<\/p>\\n     *\/\\n    public static function normalize_msword(string $str): string\\n    {\\n        if ($str === '') {\\n            return '';\\n        }\\n\\n        static $MSWORD_CACHE = ['orig' => [], 'replace' => []];\\n\\n        if (empty($MSWORD_CACHE['orig'])) {\\n            self::prepareAsciiMaps();\\n\\n            $map = self::$ASCII_MAPS[self::EXTRA_MSWORD_CHARS_LANGUAGE_CODE] ?? [];\\n\\n            $MSWORD_CACHE = [\\n                'orig'    => \\\\array_keys($map),\\n                'replace' => \\\\array_values($map),\\n            ];\\n        }\\n\\n        return \\\\str_replace($MSWORD_CACHE['orig'], $MSWORD_CACHE['replace'], $str);\\n    }\\n\\n    \/**\\n     * Normalize the whitespace.\\n     *\\n     * EXAMPLE: <code>\\n     * ASCII::normalize_whitespace(\\\"abc-\\\\xc2\\\\xa0-\u00f6\u00e4\u00fc-\\\\xe2\\\\x80\\\\xaf-\\\\xE2\\\\x80\\\\xAC\\\", true); \/\/ \\\"abc-\\\\xc2\\\\xa0-\u00f6\u00e4\u00fc- -\\\"\\n     * <\/code>\\n     *\\n     * @param string $str                          <p>The string to be normalized.<\/p>\\n     * @param bool   $keepNonBreakingSpace         [optional] <p>Set to true, to keep non-breaking-spaces.<\/p>\\n     * @param bool   $keepBidiUnicodeControls      [optional] <p>Set to true, to keep non-printable (for the web)\\n     *                                             bidirectional text chars.<\/p>\\n     * @param bool   $normalize_control_characters [optional] <p>Set to true, to convert e.g. LINE-, PARAGRAPH-SEPARATOR with \\\"\\\\n\\\" and LINE TABULATION with \\\"\\\\t\\\".<\/p>\\n     *\\n     * @psalm-pure\\n     *\\n     * @return string\\n     *                <p>A string with normalized whitespace.<\/p>\\n     *\/\\n    public static function normalize_whitespace(\\n        string $str,\\n        bool $keepNonBreakingSpace = false,\\n        bool $keepBidiUnicodeControls = false,\\n        bool $normalize_control_characters = false\\n    ): string {\\n        if ($str === '') {\\n            return '';\\n        }\\n\\n        static $WHITESPACE_CACHE = [];\\n        $cacheKey = (int) $keepNonBreakingSpace;\\n\\n        if ($normalize_control_characters) {\\n            $str = \\\\str_replace(\\n                [\\n                    \\\"\\\\x0d\\\\x0c\\\",     \/\/ 'END OF LINE'\\n                    \\\"\\\\xe2\\\\x80\\\\xa8\\\", \/\/ 'LINE SEPARATOR'\\n                    \\\"\\\\xe2\\\\x80\\\\xa9\\\", \/\/ 'PARAGRAPH SEPARATOR'\\n                    \\\"\\\\x0c\\\",         \/\/ 'FORM FEED' \/\/ \\\"\\\\f\\\"\\n                    \\\"\\\\x0b\\\",         \/\/ 'VERTICAL TAB' \/\/ \\\"\\\\v\\\"\\n                ],\\n                [\\n                    \\\"\\\\n\\\",\\n                    \\\"\\\\n\\\",\\n                    \\\"\\\\n\\\",\\n                    \\\"\\\\n\\\",\\n                    \\\"\\\\t\\\",\\n                ],\\n                $str\\n            );\\n        }\\n\\n        if (!isset($WHITESPACE_CACHE[$cacheKey])) {\\n            self::prepareAsciiMaps();\\n\\n            $WHITESPACE_CACHE[$cacheKey] = self::$ASCII_MAPS[self::EXTRA_WHITESPACE_CHARS_LANGUAGE_CODE] ?? [];\\n\\n            if ($keepNonBreakingSpace) {\\n                unset($WHITESPACE_CACHE[$cacheKey][\\\"\\\\xc2\\\\xa0\\\"]);\\n            }\\n\\n            $WHITESPACE_CACHE[$cacheKey] = array_keys($WHITESPACE_CACHE[$cacheKey]);\\n        }\\n\\n        if (!$keepBidiUnicodeControls) {\\n            static $BIDI_UNICODE_CONTROLS_CACHE = null;\\n\\n            if ($BIDI_UNICODE_CONTROLS_CACHE === null) {\\n                $BIDI_UNICODE_CONTROLS_CACHE = self::$BIDI_UNI_CODE_CONTROLS_TABLE;\\n            }\\n\\n            $str = \\\\str_replace($BIDI_UNICODE_CONTROLS_CACHE, '', $str);\\n        }\\n\\n        return \\\\str_replace($WHITESPACE_CACHE[$cacheKey], ' ', $str);\\n    }\\n\\n    \/**\\n     * Remove invisible characters from a string.\\n     *\\n     * This prevents malicious code injection through null bytes or other control characters.\\n     *\\n     * copy&past from https:\/\/github.com\/bcit-ci\/CodeIgniter\/blob\/develop\/system\/core\/Common.php\\n     *\\n     * @param string $str\\n     * @param bool   $url_encoded\\n     * @param string $replacement\\n     * @param bool   $keep_basic_control_characters\\n     *\\n     * @psalm-pure\\n     *\\n     * @return string\\n     *\/\\n    public static function remove_invisible_characters(\\n        string $str,\\n        bool $url_encoded = false,\\n        string $replacement = '',\\n        bool $keep_basic_control_characters = true\\n    ): string {\\n        \/\/ init\\n        $non_displayables = [];\\n\\n        \/\/ every control character except:\\n        \/\/ - newline (dec 10),\\n        \/\/ - carriage return (dec 13),\\n        \/\/ - horizontal tab (dec 09)\\n        if ($url_encoded) {\\n            $non_displayables[] = '\/%0[0-8bcefBCEF]\/'; \/\/ url encoded 00-08, 11, 12, 14, 15\\n            $non_displayables[] = '\/%1[0-9a-fA-F]\/'; \/\/ url encoded 16-31\\n        }\\n\\n        if ($keep_basic_control_characters) {\\n            $non_displayables[] = '\/[\\\\x00-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]+\/S'; \/\/ 00-08, 11, 12, 14-31, 127\\n        } else {\\n            $str = self::normalize_whitespace($str, false, false, true);\\n            $non_displayables[] = '\/[^\\\\P{C}\\\\s]\/u';\\n        }\\n\\n        do {\\n            $str = (string) \\\\preg_replace($non_displayables, $replacement, $str, -1, $count);\\n        } while ($count !== 0);\\n\\n        return $str;\\n    }\\n\\n    \/**\\n     * WARNING: This method will return broken characters and is only for special cases.\\n     *\\n     * Convert two UTF-8 encoded strings to a single-byte strings suitable for\\n     * functions that need the same string length after the conversion.\\n     *\\n     * The function simply uses (and updates) a tailored dynamic encoding\\n     * (in\/out map parameter) where non-ascii characters are remapped to\\n     * the range [128-255] in order of appearance.\\n     *\\n     * @return array{0: string, 1: string}\\n     *\/\\n    public static function to_ascii_remap(string $str1, string $str2): array\\n    {\\n        $charMap = [];\\n        $str1 = self::to_ascii_remap_intern($str1, $charMap);\\n        $str2 = self::to_ascii_remap_intern($str2, $charMap);\\n\\n        return [$str1, $str2];\\n    }\\n\\n    \/**\\n     * Returns an ASCII version of the string. A set of non-ASCII characters are\\n     * replaced with their closest ASCII counterparts, and the rest are removed\\n     * by default. The language or locale of the source string can be supplied\\n     * for language-specific transliteration in any of the following formats:\\n     * en, en_GB, or en-GB. For example, passing \\\"de\\\" results in \\\"\u00e4\u00f6\u00fc\\\" mapping\\n     * to \\\"aeoeue\\\" rather than \\\"aou\\\" as in other languages.\\n     *\\n     * EXAMPLE: <code>\\n     * ASCII::to_ascii('\ufffdD\u00fcsseldorf\ufffd', 'en'); \/\/ Dusseldorf\\n     * <\/code>\\n     *\\n     * @param string    $str                       <p>The input string.<\/p>\\n     * @param string    $language                  [optional] <p>Language of the source string.\\n     *                                             (default is 'en') | ASCII::*_LANGUAGE_CODE<\/p>\\n     * @param bool      $remove_unsupported_chars  [optional] <p>Whether to remove the\\n     *                                             unsupported characters.<\/p>\\n     * @param bool      $replace_extra_symbols     [optional]  <p>Add some more replacements e.g. \\\"\u00a3\\\" with \\\" pound\\n     *                                             \\\".<\/p>\\n     * @param bool      $use_transliterate         [optional]  <p>Use ASCII::to_transliterate() for unknown chars.<\/p>\\n     * @param bool      $replace_single_chars_only [optional]  <p>Single char replacement is better for the\\n     *                                             performance, but some languages need to replace more than one char\\n     *                                             at the same time. If FALSE === auto-setting, depended on the\\n     *                                             language<\/p>\\n     *\\n     * @psalm-pure\\n     *\\n     * @return string\\n     *                <p>A string that contains only ASCII characters.<\/p>\\n     *\\n     * @phpstan-param ASCII::*_LANGUAGE_CODE $language\\n     *\/\\n    public static function to_ascii(\\n        string $str,\\n        string $language = self::ENGLISH_LANGUAGE_CODE,\\n        bool $remove_unsupported_chars = true,\\n        bool $replace_extra_symbols = false,\\n        bool $use_transliterate = false,\\n        bool $replace_single_chars_only = false\\n    ): string {\\n        if ($str === '') {\\n            return '';\\n        }\\n\\n        \/** @phpstan-var ASCII::*_LANGUAGE_CODE $language - hack for phpstan *\/\\n        $language = self::get_language($language);\\n\\n        static $EXTRA_SYMBOLS_CACHE = null;\\n\\n        static $REPLACE_HELPER_CACHE = [];\\n        $cacheKey = $language . '-' . $replace_extra_symbols;\\n\\n        if (!isset($REPLACE_HELPER_CACHE[$cacheKey])) {\\n            $langAll = self::charsArrayWithSingleLanguageValues($replace_extra_symbols, false);\\n\\n            $langSpecific = self::charsArrayWithOneLanguage($language, $replace_extra_symbols, false);\\n\\n            if ($langSpecific === []) {\\n                $REPLACE_HELPER_CACHE[$cacheKey] = $langAll;\\n            } else {\\n                $REPLACE_HELPER_CACHE[$cacheKey] = \\\\array_merge([], $langAll, $langSpecific);\\n            }\\n        }\\n\\n        if (\\n            $replace_extra_symbols\\n            &&\\n            $EXTRA_SYMBOLS_CACHE === null\\n        ) {\\n            $EXTRA_SYMBOLS_CACHE = [];\\n            foreach (self::$ASCII_EXTRAS ?? [] as $extrasDataTmp) {\\n                foreach ($extrasDataTmp as $extrasDataKeyTmp => $extrasDataValueTmp) {\\n                    $EXTRA_SYMBOLS_CACHE[$extrasDataKeyTmp] = $extrasDataKeyTmp;\\n                }\\n            }\\n            $EXTRA_SYMBOLS_CACHE = \\\\implode('', $EXTRA_SYMBOLS_CACHE);\\n        }\\n\\n        $charDone = [];\\n        if (\\\\preg_match_all('\/' . self::$REGEX_ASCII . ($replace_extra_symbols ? '|[' . $EXTRA_SYMBOLS_CACHE . ']' : '') . '\/u', $str, $matches)) {\\n            if (!$replace_single_chars_only) {\\n                if (self::$LANGUAGE_MAX_KEY === null) {\\n                    self::$LANGUAGE_MAX_KEY = self::getData('ascii_language_max_key');\\n                }\\n\\n                $maxKeyLength = self::$LANGUAGE_MAX_KEY[$language] ?? 0;\\n\\n                if ($maxKeyLength >= 5) {\\n                    foreach ($matches[0] as $keyTmp => $char) {\\n                        if (isset($matches[0][$keyTmp + 4])) {\\n                            $fiveChars = $matches[0][$keyTmp + 0] . $matches[0][$keyTmp + 1] . $matches[0][$keyTmp + 2] . $matches[0][$keyTmp + 3] . $matches[0][$keyTmp + 4];\\n                        } else {\\n                            $fiveChars = null;\\n                        }\\n                        if (\\n                            $fiveChars\\n                            &&\\n                            !isset($charDone[$fiveChars])\\n                            &&\\n                            isset($REPLACE_HELPER_CACHE[$cacheKey][$fiveChars])\\n                            &&\\n                            \\\\strpos($str, $fiveChars) !== false\\n                        ) {\\n                            \/\/ DEBUG\\n                            \/\/\\\\var_dump($str, $fiveChars, $REPLACE_HELPER_CACHE[$cacheKey][$fiveChars]);\\n\\n                            $charDone[$fiveChars] = true;\\n                            $str = \\\\str_replace($fiveChars, $REPLACE_HELPER_CACHE[$cacheKey][$fiveChars], $str);\\n\\n                            \/\/ DEBUG\\n                            \/\/\\\\var_dump($str, \\\"\\\\n\\\");\\n                        }\\n                    }\\n                }\\n\\n                if ($maxKeyLength >= 4) {\\n                    foreach ($matches[0] as $keyTmp => $char) {\\n                        if (isset($matches[0][$keyTmp + 3])) {\\n                            $fourChars = $matches[0][$keyTmp + 0] . $matches[0][$keyTmp + 1] . $matches[0][$keyTmp + 2] . $matches[0][$keyTmp + 3];\\n                        } else {\\n                            $fourChars = null;\\n                        }\\n                        if (\\n                            $fourChars\\n                            &&\\n                            !isset($charDone[$fourChars])\\n                            &&\\n                            isset($REPLACE_HELPER_CACHE[$cacheKey][$fourChars])\\n                            &&\\n                            \\\\strpos($str, $fourChars) !== false\\n                        ) {\\n                            \/\/ DEBUG\\n                            \/\/\\\\var_dump($str, $fourChars, $REPLACE_HELPER_CACHE[$cacheKey][$fourChars]);\\n\\n                            $charDone[$fourChars] = true;\\n                            $str = \\\\str_replace($fourChars, $REPLACE_HELPER_CACHE[$cacheKey][$fourChars], $str);\\n\\n                            \/\/ DEBUG\\n                            \/\/\\\\var_dump($str, \\\"\\\\n\\\");\\n                        }\\n                    }\\n                }\\n\\n                foreach ($matches[0] as $keyTmp => $char) {\\n                    if (isset($matches[0][$keyTmp + 2])) {\\n                        $threeChars = $matches[0][$keyTmp + 0] . $matches[0][$keyTmp + 1] . $matches[0][$keyTmp + 2];\\n                    } else {\\n                        $threeChars = null;\\n                    }\\n                    if (\\n                        $threeChars\\n                        &&\\n                        !isset($charDone[$threeChars])\\n                        &&\\n                        isset($REPLACE_HELPER_CACHE[$cacheKey][$threeChars])\\n                        &&\\n                        \\\\strpos($str, $threeChars) !== false\\n                    ) {\\n                        \/\/ DEBUG\\n                        \/\/\\\\var_dump($str, $threeChars, $REPLACE_HELPER_CACHE[$cacheKey][$threeChars]);\\n\\n                        $charDone[$threeChars] = true;\\n                        $str = \\\\str_replace($threeChars, $REPLACE_HELPER_CACHE[$cacheKey][$threeChars], $str);\\n\\n                        \/\/ DEBUG\\n                        \/\/\\\\var_dump($str, \\\"\\\\n\\\");\\n                    }\\n                }\\n\\n                foreach ($matches[0] as $keyTmp => $char) {\\n                    if (isset($matches[0][$keyTmp + 1])) {\\n                        $twoChars = $matches[0][$keyTmp + 0] . $matches[0][$keyTmp + 1];\\n                    } else {\\n                        $twoChars = null;\\n                    }\\n                    if (\\n                        $twoChars\\n                        &&\\n                        !isset($charDone[$twoChars])\\n                        &&\\n                        isset($REPLACE_HELPER_CACHE[$cacheKey][$twoChars])\\n                        &&\\n                        \\\\strpos($str, $twoChars) !== false\\n                    ) {\\n                        \/\/ DEBUG\\n                        \/\/\\\\var_dump($str, $twoChars, $REPLACE_HELPER_CACHE[$cacheKey][$twoChars]);\\n\\n                        $charDone[$twoChars] = true;\\n                        $str = \\\\str_replace($twoChars, $REPLACE_HELPER_CACHE[$cacheKey][$twoChars], $str);\\n\\n                        \/\/ DEBUG\\n                        \/\/\\\\var_dump($str, \\\"\\\\n\\\");\\n                    }\\n                }\\n            }\\n\\n            foreach ($matches[0] as $char) {\\n                if (\\n                    !isset($charDone[$char])\\n                    &&\\n                    isset($REPLACE_HELPER_CACHE[$cacheKey][$char])\\n                    &&\\n                    \\\\strpos($str, $char) !== false\\n                ) {\\n                    \/\/ DEBUG\\n                    \/\/\\\\var_dump($str, $char, $REPLACE_HELPER_CACHE[$cacheKey][$char]);\\n\\n                    $charDone[$char] = true;\\n                    $str = \\\\str_replace($char, $REPLACE_HELPER_CACHE[$cacheKey][$char], $str);\\n\\n                    \/\/ DEBUG\\n                    \/\/\\\\var_dump($str, \\\"\\\\n\\\");\\n                }\\n            }\\n        }\\n\\n        if (!isset(self::$ASCII_MAPS[$language])) {\\n            $use_transliterate = true;\\n        }\\n\\n        if ($use_transliterate) {\\n            $str = self::to_transliterate($str, null, false);\\n        }\\n\\n        if ($remove_unsupported_chars) {\\n            $str = (string) \\\\str_replace([\\\"\\\\n\\\\r\\\", \\\"\\\\n\\\", \\\"\\\\r\\\", \\\"\\\\t\\\"], ' ', $str);\\n            $str = (string) \\\\preg_replace('\/' . self::$REGEX_ASCII . '\/', '', $str);\\n        }\\n\\n        return $str;\\n    }\\n\\n    \/**\\n     * Convert given string to safe filename (and keep string case).\\n     *\\n     * EXAMPLE: <code>\\n     * ASCII::to_filename('\u05e9\u05d3\u05d2\u05e9\u05d3\u05d2.png', true)); \/\/ 'shdgshdg.png'\\n     * <\/code>\\n     *\\n     * @param string $str               <p>The string input.<\/p>\\n     * @param bool   $use_transliterate <p>ASCII::to_transliterate() is used by default - unsafe characters are\\n     *                                  simply replaced with hyphen otherwise.<\/p>\\n     * @param string $fallback_char     <p>The fallback character. - \\\"-\\\" is the default<\/p>\\n     *\\n     * @psalm-pure\\n     *\\n     * @return string\\n     *                <p>A string that contains only safe characters for a filename.<\/p>\\n     *\/\\n    public static function to_filename(\\n        string $str,\\n        bool $use_transliterate = true,\\n        string $fallback_char = '-'\\n    ): string {\\n        if ($use_transliterate) {\\n            $str = self::to_transliterate($str, $fallback_char);\\n        }\\n\\n        $fallback_char_escaped = \\\\preg_quote($fallback_char, '\/');\\n\\n        $str = (string) \\\\preg_replace(\\n            [\\n                '\/[^' . $fallback_char_escaped . '.\\\\\\\\-a-zA-Z\\\\d\\\\\\\\s]\/', \/\/ 1) remove un-needed chars\\n                '\/\\\\s+\/u',                                             \/\/ 2) convert spaces to $fallback_char\\n                '\/[' . $fallback_char_escaped . ']+\/u',               \/\/ 3) remove double $fallback_char's\\n            ],\\n            [\\n                '',\\n                $fallback_char,\\n                $fallback_char,\\n            ],\\n            $str\\n        );\\n\\n        return \\\\trim($str, $fallback_char);\\n    }\\n\\n    \/**\\n     * Converts a string into a URL-friendly slug.\\n     *\\n     * - This includes replacing non-ASCII characters with their closest ASCII equivalents, removing remaining\\n     *   non-ASCII and non-alphanumeric characters, and replacing whitespace with $separator.\\n     * - The separator defaults to a single dash, and the string is also converted to lowercase.\\n     * - The language of the source string can also be supplied for language-specific transliteration.\\n     *\\n     * @param string                $str                   <p>The string input.<\/p>\\n     * @param string                $separator             [optional] <p>The string used to replace whitespace.<\/p>\\n     * @param string                $language              [optional] <p>Language of the source string.\\n     *                                                     (default is 'en') | ASCII::*_LANGUAGE_CODE<\/p>\\n     * @param array<string, string> $replacements          [optional] <p>A map of replaceable strings.<\/p>\\n     * @param bool                  $replace_extra_symbols [optional] <p>Add some more replacements e.g. \\\"\u00a3\\\" with \\\"\\n     *                                                     pound \\\".<\/p>\\n     * @param bool                  $use_str_to_lower      [optional] <p>Use \\\"string to lower\\\" for the input.<\/p>\\n     * @param bool                  $use_transliterate     [optional] <p>Use ASCII::to_transliterate() for unknown\\n     *                                                     chars.<\/p>\\n     * @psalm-pure\\n     *\\n     * @return string\\n     *                <p>The URL-friendly slug.<\/p>\\n     *\\n     * @phpstan-param ASCII::*_LANGUAGE_CODE $language\\n     *\/\\n    public static function to_slugify(\\n        string $str,\\n        string $separator = '-',\\n        string $language = self::ENGLISH_LANGUAGE_CODE,\\n        array $replacements = [],\\n        bool $replace_extra_symbols = false,\\n        bool $use_str_to_lower = true,\\n        bool $use_transliterate = false\\n    ): string {\\n        if ($str === '') {\\n            return '';\\n        }\\n\\n        foreach ($replacements as $from => $to) {\\n            $str = \\\\str_replace($from, $to, $str);\\n        }\\n\\n        $str = self::to_ascii(\\n            $str,\\n            $language,\\n            false,\\n            $replace_extra_symbols,\\n            $use_transliterate\\n        );\\n\\n        $str = \\\\str_replace('@', $separator, $str);\\n\\n        $str = (string) \\\\preg_replace(\\n            '\/[^a-zA-Z\\\\\\\\d\\\\\\\\s\\\\\\\\-_' . \\\\preg_quote($separator, '\/') . ']\/',\\n            '',\\n            $str\\n        );\\n\\n        if ($use_str_to_lower) {\\n            $str = \\\\strtolower($str);\\n        }\\n\\n        $str = (string) \\\\preg_replace('\/^[\\\\'\\\\\\\\s]+|[\\\\'\\\\\\\\s]+$\/', '', $str);\\n        $str = (string) \\\\preg_replace('\/\\\\\\\\B([A-Z])\/', '-\\\\1', $str);\\n        $str = (string) \\\\preg_replace('\/[\\\\\\\\-_\\\\\\\\s]+\/', $separator, $str);\\n\\n        $l = \\\\strlen($separator);\\n        if ($l && \\\\strpos($str, $separator) === 0) {\\n            $str = (string) \\\\substr($str, $l);\\n        }\\n\\n        if (\\\\substr($str, -$l) === $separator) {\\n            $str = (string) \\\\substr($str, 0, \\\\strlen($str) - $l);\\n        }\\n\\n        return $str;\\n    }\\n\\n    \/**\\n     * Returns an ASCII version of the string. A set of non-ASCII characters are\\n     * replaced with their closest ASCII counterparts, and the rest are removed\\n     * unless instructed otherwise.\\n     *\\n     * EXAMPLE: <code>\\n     * ASCII::to_transliterate('d\u00e9j\u00e0 \u03c3\u03c3\u03c2 i\u0131ii'); \/\/ 'deja sss iiii'\\n     * <\/code>\\n     *\\n     * @param string      $str     <p>The input string.<\/p>\\n     * @param string|null $unknown [optional] <p>Character use if character unknown. (default is '?')\\n     *                             But you can also use NULL to keep the unknown chars.<\/p>\\n     * @param bool        $strict  [optional] <p>Use \\\"transliterator_transliterate()\\\" from PHP-Intl\\n     *\\n     * @psalm-pure\\n     *\\n     * @return string\\n     *                <p>A String that contains only ASCII characters.<\/p>\\n     *\/\\n    public static function to_transliterate(\\n        string $str,\\n        $unknown = '?',\\n        bool $strict = false\\n    ): string {\\n        static $UTF8_TO_TRANSLIT = null;\\n\\n        static $TRANSLITERATOR = null;\\n\\n        static $SUPPORT_INTL = null;\\n\\n        if ($str === '') {\\n            return '';\\n        }\\n\\n        if ($SUPPORT_INTL === null) {\\n            $SUPPORT_INTL = \\\\extension_loaded('intl');\\n        }\\n\\n        \/\/ check if we only have ASCII, first (better performance)\\n        $str_tmp = $str;\\n        if (self::is_ascii($str)) {\\n            return $str;\\n        }\\n\\n        $str = self::clean($str);\\n\\n        \/\/ check again if we only have ASCII, now ...\\n        if (\\n            $str_tmp !== $str\\n            &&\\n            self::is_ascii($str)\\n        ) {\\n            return $str;\\n        }\\n\\n        if (\\n            $strict\\n            &&\\n            $SUPPORT_INTL === true\\n        ) {\\n            if (!isset($TRANSLITERATOR)) {\\n                \/\/ INFO: see \\\"*-Latin\\\" rules via \\\"transliterator_list_ids()\\\"\\n                $TRANSLITERATOR = \\\\transliterator_create('NFKC; [:Nonspacing Mark:] Remove; NFKC; Any-Latin; Latin-ASCII;');\\n            }\\n\\n            \/\/ INFO: https:\/\/unicode.org\/cldr\/utility\/character.jsp\\n            $str_tmp = \\\\transliterator_transliterate($TRANSLITERATOR, $str);\\n\\n            if ($str_tmp !== false) {\\n                \/\/ check again if we only have ASCII, now ...\\n                if (\\n                    $str_tmp !== $str\\n                    &&\\n                    self::is_ascii($str_tmp)\\n                ) {\\n                    return $str_tmp;\\n                }\\n\\n                $str = $str_tmp;\\n            }\\n        }\\n\\n        if (self::$ORD === null) {\\n            self::$ORD = self::getData('ascii_ord');\\n        }\\n\\n        \\\\preg_match_all('\/.|[^\\\\x00]$\/us', $str, $array_tmp);\\n        $chars = $array_tmp[0];\\n        $ord = null;\\n        $str_tmp = '';\\n        foreach ($chars as &$c) {\\n            $ordC0 = self::$ORD[$c[0]];\\n\\n            if ($ordC0 >= 0 && $ordC0 <= 127) {\\n                $str_tmp .= $c;\\n\\n                continue;\\n            }\\n\\n            $ordC1 = self::$ORD[$c[1]];\\n\\n            \/\/ ASCII - next please\\n            if ($ordC0 >= 192 && $ordC0 <= 223) {\\n                $ord = ($ordC0 - 192) * 64 + ($ordC1 - 128);\\n            }\\n\\n            if ($ordC0 >= 224) {\\n                $ordC2 = self::$ORD[$c[2]];\\n\\n                if ($ordC0 <= 239) {\\n                    $ord = ($ordC0 - 224) * 4096 + ($ordC1 - 128) * 64 + ($ordC2 - 128);\\n                }\\n\\n                if ($ordC0 >= 240) {\\n                    $ordC3 = self::$ORD[$c[3]];\\n\\n                    if ($ordC0 <= 247) {\\n                        $ord = ($ordC0 - 240) * 262144 + ($ordC1 - 128) * 4096 + ($ordC2 - 128) * 64 + ($ordC3 - 128);\\n                    }\\n\\n                    \/\/ We only process valid UTF-8 chars (<= 4 byte), so we don't need this code here ...\\n                    \/*\\n                    if ($ordC0 >= 248) {\\n                        $ordC4 = self::$ORD[$c[4]];\\n\\n                        if ($ordC0 <= 251) {\\n                            $ord = ($ordC0 - 248) * 16777216 + ($ordC1 - 128) * 262144 + ($ordC2 - 128) * 4096 + ($ordC3 - 128) * 64 + ($ordC4 - 128);\\n                        }\\n\\n                        if ($ordC0 >= 252) {\\n                            $ordC5 = self::$ORD[$c[5]];\\n\\n                            if ($ordC0 <= 253) {\\n                                $ord = ($ordC0 - 252) * 1073741824 + ($ordC1 - 128) * 16777216 + ($ordC2 - 128) * 262144 + ($ordC3 - 128) * 4096 + ($ordC4 - 128) * 64 + ($ordC5 - 128);\\n                            }\\n                        }\\n                    }\\n                     *\/\\n                }\\n            }\\n\\n            if (\\n                $ordC0 === 254\\n                ||\\n                $ordC0 === 255\\n                ||\\n                $ord === null\\n            ) {\\n                $str_tmp .= $unknown ?? $c;\\n\\n                continue;\\n            }\\n\\n            $bank = $ord >> 8;\\n            if (!isset($UTF8_TO_TRANSLIT[$bank])) {\\n                $UTF8_TO_TRANSLIT[$bank] = self::getDataIfExists(\\\\sprintf('x%03x', $bank));\\n            }\\n\\n            $new_char = $ord & 255;\\n\\n            if (isset($UTF8_TO_TRANSLIT[$bank][$new_char])) {\\n                \/\/ keep for debugging\\n                \/*\\n                echo \\\"file: \\\" . sprintf('x%02x', $bank) . \\\"\\\\n\\\";\\n                echo \\\"char: \\\" . $c . \\\"\\\\n\\\";\\n                echo \\\"ord: \\\" . $ord . \\\"\\\\n\\\";\\n                echo \\\"new_char: \\\" . $new_char . \\\"\\\\n\\\";\\n                echo \\\"new_char: \\\" . mb_chr($new_char) . \\\"\\\\n\\\";\\n                echo \\\"ascii: \\\" . $UTF8_TO_TRANSLIT[$bank][$new_char] . \\\"\\\\n\\\";\\n                echo \\\"bank:\\\" . $bank . \\\"\\\\n\\\\n\\\";\\n                 *\/\\n\\n                $new_char = $UTF8_TO_TRANSLIT[$bank][$new_char];\\n\\n                \/* @noinspection PhpStatementHasEmptyBodyInspection *\/\\n                if ($unknown === null && $new_char === '') {\\n                    \/\/ nothing\\n                } elseif (\\n                    $new_char === '[?]'\\n                    ||\\n                    $new_char === '[?] '\\n                ) {\\n                    $c = $unknown ?? $c;\\n                } else {\\n                    $c = $new_char;\\n                }\\n            } else {\\n                \/\/ keep for debugging missing chars\\n                \/*\\n                echo \\\"file: \\\" . sprintf('x%02x', $bank) . \\\"\\\\n\\\";\\n                echo \\\"char: \\\" . $c . \\\"\\\\n\\\";\\n                echo \\\"ord: \\\" . $ord . \\\"\\\\n\\\";\\n                echo \\\"new_char: \\\" . $new_char . \\\"\\\\n\\\";\\n                echo \\\"new_char: \\\" . mb_chr($new_char) . \\\"\\\\n\\\";\\n                echo \\\"bank:\\\" . $bank . \\\"\\\\n\\\\n\\\";\\n                 *\/\\n\\n                $c = $unknown ?? $c;\\n            }\\n\\n            $str_tmp .= $c;\\n        }\\n\\n        return $str_tmp;\\n    }\\n\\n    \/**\\n     * WARNING: This method will return broken characters and is only for special cases.\\n     *\\n     * Convert a UTF-8 encoded string to a single-byte string suitable for\\n     * functions that need the same string length after the conversion.\\n     *\\n     * The function simply uses (and updates) a tailored dynamic encoding\\n     * (in\/out map parameter) where non-ascii characters are remapped to\\n     * the range [128-255] in order of appearance.\\n     *\\n     * Thus, it supports up to 128 different multibyte code points max over\\n     * the whole set of strings sharing this encoding.\\n     *\\n     * Source: https:\/\/github.com\/KEINOS\/mb_levenshtein\\n     *\\n     * @param string $str <p>UTF-8 string to be converted to extended ASCII.<\/p>\\n     * @param array  $map <p>Internal-Map of code points to ASCII characters.<\/p>\\n     *\\n     * @return string\\n     *                <p>Mapped broken string.<\/p>\\n     *\\n     * @phpstan-param array<string, string> $map\\n     *\/\\n    private static function to_ascii_remap_intern(string $str, array &$map): string\\n    {\\n        \/\/ find all utf-8 characters\\n        $matches = [];\\n        if (!\\\\preg_match_all('\/[\\\\xC0-\\\\xF7][\\\\x80-\\\\xBF]+\/', $str, $matches)) {\\n            return $str; \/\/ plain ascii string\\n        }\\n\\n        \/\/ update the encoding map with the characters not already met\\n        $mapCount = \\\\count($map);\\n        foreach ($matches[0] as $mbc) {\\n            if (!isset($map[$mbc])) {\\n                $map[$mbc] = \\\\chr(128 + $mapCount);\\n                ++$mapCount;\\n            }\\n        }\\n\\n        \/\/ finally, remap non-ascii characters\\n        return \\\\strtr($str, $map);\\n    }\\n\\n    \/**\\n     * Get the language from a string.\\n     *\\n     * e.g.: de_at -> de_at\\n     *       de_DE -> de\\n     *       DE_DE -> de\\n     *       de-de -> de\\n     *\\n     * @return string\\n     *\/\\n    private static function get_language(string $language)\\n    {\\n        if ($language === '') {\\n            return '';\\n        }\\n\\n        if (\\n            \\\\strpos($language, '_') === false\\n            &&\\n            \\\\strpos($language, '-') === false\\n        ) {\\n            return \\\\strtolower($language);\\n        }\\n\\n        $language = \\\\str_replace('-', '_', \\\\strtolower($language));\\n\\n        $regex = '\/(?<first>[a-z]+)_\\\\g{first}\/';\\n\\n        return (string) \\\\preg_replace($regex, '$1', $language);\\n    }\\n\\n    \/**\\n     * Get data from \\\"\/data\/*.php\\\".\\n     *\\n     * @return array<array-key,mixed>\\n     *\/\\n    private static function getData(string $file)\\n    {\\n        return include __DIR__ . '\/data\/' . $file . '.php';\\n    }\\n\\n    \/**\\n     * Get data from \\\"\/data\/*.php\\\".\\n     *\\n     * @return array<array-key,mixed>\\n     *\/\\n    private static function getDataIfExists(string $file): array\\n    {\\n        $file = __DIR__ . '\/data\/' . $file . '.php';\\n        if (\\\\is_file($file)) {\\n            return include $file;\\n        }\\n\\n        return [];\\n    }\\n\\n    \/**\\n     * @return void\\n     *\/\\n    private static function prepareAsciiAndExtrasMaps()\\n    {\\n        if (self::$ASCII_MAPS_AND_EXTRAS === null) {\\n            self::prepareAsciiMaps();\\n            self::prepareAsciiExtras();\\n\\n            self::$ASCII_MAPS_AND_EXTRAS = \\\\array_merge_recursive(\\n                self::$ASCII_MAPS ?? [],\\n                self::$ASCII_EXTRAS ?? []\\n            );\\n        }\\n    }\\n\\n    \/**\\n     * @return void\\n     *\/\\n    private static function prepareAsciiMaps()\\n    {\\n        if (self::$ASCII_MAPS === null) {\\n            self::$ASCII_MAPS = self::getData('ascii_by_languages');\\n        }\\n    }\\n\\n    \/**\\n     * @return void\\n     *\/\\n    private static function prepareAsciiExtras()\\n    {\\n        if (self::$ASCII_EXTRAS === null) {\\n            self::$ASCII_EXTRAS = self::getData('ascii_extras_by_languages');\\n        }\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/voku\/portable-ascii\/LICENSE.txt\",\"ext\":\"txt\",\"size\":1058,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"Copyright (C) 2019 Lars Moelleken\\n\\nPermission is hereby granted, free of charge, to any person obtaining a copy\\nof this software and associated documentation files (the \\\"Software\\\"), to deal\\nin the Software without restriction, including without limitation the rights\\nto use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\\ncopies of the Software, and to permit persons to whom the Software is\\nfurnished to do so, subject to the following conditions:\\n\\nThe above copyright notice and this permission notice shall be included in\\nall copies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\nTHE SOFTWARE.\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/phpoption\/phpoption\/src\/PhpOption\/Some.php\",\"ext\":\"php\",\"size\":3319,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/*\\n * Copyright 2012 Johannes M. Schmitt <schmittjoh@gmail.com>\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n * http:\/\/www.apache.org\/licenses\/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n *\/\\n\\nnamespace PhpOption;\\n\\nuse ArrayIterator;\\n\\n\/**\\n * @template T\\n *\\n * @extends Option<T>\\n *\/\\nfinal class Some extends Option\\n{\\n    \/** @var T *\/\\n    private $value;\\n\\n    \/**\\n     * @param T $value\\n     *\/\\n    public function __construct($value)\\n    {\\n        $this->value = $value;\\n    }\\n\\n    \/**\\n     * @template U\\n     *\\n     * @param U $value\\n     *\\n     * @return Some<U>\\n     *\/\\n    public static function create($value): self\\n    {\\n        return new self($value);\\n    }\\n\\n    public function isDefined(): bool\\n    {\\n        return true;\\n    }\\n\\n    public function isEmpty(): bool\\n    {\\n        return false;\\n    }\\n\\n    public function get()\\n    {\\n        return $this->value;\\n    }\\n\\n    public function getOrElse($default)\\n    {\\n        return $this->value;\\n    }\\n\\n    public function getOrCall($callable)\\n    {\\n        return $this->value;\\n    }\\n\\n    public function getOrThrow(\\\\Exception $ex)\\n    {\\n        return $this->value;\\n    }\\n\\n    public function orElse(Option $else)\\n    {\\n        return $this;\\n    }\\n\\n    public function ifDefined($callable)\\n    {\\n        $this->forAll($callable);\\n    }\\n\\n    public function forAll($callable)\\n    {\\n        $callable($this->value);\\n\\n        return $this;\\n    }\\n\\n    public function map($callable)\\n    {\\n        return new self($callable($this->value));\\n    }\\n\\n    public function flatMap($callable)\\n    {\\n        \/** @var mixed *\/\\n        $rs = $callable($this->value);\\n        if (!$rs instanceof Option) {\\n            throw new \\\\RuntimeException('Callables passed to flatMap() must return an Option. Maybe you should use map() instead?');\\n        }\\n\\n        return $rs;\\n    }\\n\\n    public function filter($callable)\\n    {\\n        if (true === $callable($this->value)) {\\n            return $this;\\n        }\\n\\n        return None::create();\\n    }\\n\\n    public function filterNot($callable)\\n    {\\n        if (false === $callable($this->value)) {\\n            return $this;\\n        }\\n\\n        return None::create();\\n    }\\n\\n    public function select($value)\\n    {\\n        if ($this->value === $value) {\\n            return $this;\\n        }\\n\\n        return None::create();\\n    }\\n\\n    public function reject($value)\\n    {\\n        if ($this->value === $value) {\\n            return None::create();\\n        }\\n\\n        return $this;\\n    }\\n\\n    \/**\\n     * @return ArrayIterator<int, T>\\n     *\/\\n    public function getIterator(): ArrayIterator\\n    {\\n        return new ArrayIterator([$this->value]);\\n    }\\n\\n    public function foldLeft($initialValue, $callable)\\n    {\\n        return $callable($initialValue, $this->value);\\n    }\\n\\n    public function foldRight($initialValue, $callable)\\n    {\\n        return $callable($this->value, $initialValue);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/phpoption\/phpoption\/src\/PhpOption\/LazyOption.php\",\"ext\":\"php\",\"size\":4082,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/*\\n * Copyright 2012 Johannes M. Schmitt <schmittjoh@gmail.com>\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n * http:\/\/www.apache.org\/licenses\/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n *\/\\n\\nnamespace PhpOption;\\n\\nuse Traversable;\\n\\n\/**\\n * @template T\\n *\\n * @extends Option<T>\\n *\/\\nfinal class LazyOption extends Option\\n{\\n    \/** @var callable(mixed...):(Option<T>) *\/\\n    private $callback;\\n\\n    \/** @var array<int, mixed> *\/\\n    private $arguments;\\n\\n    \/** @var Option<T>|null *\/\\n    private $option;\\n\\n    \/**\\n     * @template S\\n     * @param callable(mixed...):(Option<S>) $callback\\n     * @param array<int, mixed>              $arguments\\n     *\\n     * @return LazyOption<S>\\n     *\/\\n    public static function create($callback, array $arguments = []): self\\n    {\\n        return new self($callback, $arguments);\\n    }\\n\\n    \/**\\n     * @param callable(mixed...):(Option<T>) $callback\\n     * @param array<int, mixed>              $arguments\\n     *\/\\n    public function __construct($callback, array $arguments = [])\\n    {\\n        if (!is_callable($callback)) {\\n            throw new \\\\InvalidArgumentException('Invalid callback given');\\n        }\\n\\n        $this->callback = $callback;\\n        $this->arguments = $arguments;\\n    }\\n\\n    public function isDefined(): bool\\n    {\\n        return $this->option()->isDefined();\\n    }\\n\\n    public function isEmpty(): bool\\n    {\\n        return $this->option()->isEmpty();\\n    }\\n\\n    public function get()\\n    {\\n        return $this->option()->get();\\n    }\\n\\n    public function getOrElse($default)\\n    {\\n        return $this->option()->getOrElse($default);\\n    }\\n\\n    public function getOrCall($callable)\\n    {\\n        return $this->option()->getOrCall($callable);\\n    }\\n\\n    public function getOrThrow(\\\\Exception $ex)\\n    {\\n        return $this->option()->getOrThrow($ex);\\n    }\\n\\n    public function orElse(Option $else)\\n    {\\n        return $this->option()->orElse($else);\\n    }\\n\\n    public function ifDefined($callable)\\n    {\\n        $this->option()->forAll($callable);\\n    }\\n\\n    public function forAll($callable)\\n    {\\n        return $this->option()->forAll($callable);\\n    }\\n\\n    public function map($callable)\\n    {\\n        return $this->option()->map($callable);\\n    }\\n\\n    public function flatMap($callable)\\n    {\\n        return $this->option()->flatMap($callable);\\n    }\\n\\n    public function filter($callable)\\n    {\\n        return $this->option()->filter($callable);\\n    }\\n\\n    public function filterNot($callable)\\n    {\\n        return $this->option()->filterNot($callable);\\n    }\\n\\n    public function select($value)\\n    {\\n        return $this->option()->select($value);\\n    }\\n\\n    public function reject($value)\\n    {\\n        return $this->option()->reject($value);\\n    }\\n\\n    \/**\\n     * @return Traversable<T>\\n     *\/\\n    public function getIterator(): Traversable\\n    {\\n        return $this->option()->getIterator();\\n    }\\n\\n    public function foldLeft($initialValue, $callable)\\n    {\\n        return $this->option()->foldLeft($initialValue, $callable);\\n    }\\n\\n    public function foldRight($initialValue, $callable)\\n    {\\n        return $this->option()->foldRight($initialValue, $callable);\\n    }\\n\\n    \/**\\n     * @return Option<T>\\n     *\/\\n    private function option(): Option\\n    {\\n        if (null === $this->option) {\\n            \/** @var mixed *\/\\n            $option = call_user_func_array($this->callback, $this->arguments);\\n            if ($option instanceof Option) {\\n                $this->option = $option;\\n            } else {\\n                throw new \\\\RuntimeException(sprintf('Expected instance of %s', Option::class));\\n            }\\n        }\\n\\n        return $this->option;\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/phpoption\/phpoption\/src\/PhpOption\/None.php\",\"ext\":\"php\",\"size\":2514,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/*\\n * Copyright 2012 Johannes M. Schmitt <schmittjoh@gmail.com>\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n * http:\/\/www.apache.org\/licenses\/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n *\/\\n\\nnamespace PhpOption;\\n\\nuse EmptyIterator;\\n\\n\/**\\n * @extends Option<mixed>\\n *\/\\nfinal class None extends Option\\n{\\n    \/** @var None|null *\/\\n    private static $instance;\\n\\n    \/**\\n     * @return None\\n     *\/\\n    public static function create(): self\\n    {\\n        if (null === self::$instance) {\\n            self::$instance = new self();\\n        }\\n\\n        return self::$instance;\\n    }\\n\\n    public function get()\\n    {\\n        throw new \\\\RuntimeException('None has no value.');\\n    }\\n\\n    public function getOrCall($callable)\\n    {\\n        return $callable();\\n    }\\n\\n    public function getOrElse($default)\\n    {\\n        return $default;\\n    }\\n\\n    public function getOrThrow(\\\\Exception $ex)\\n    {\\n        throw $ex;\\n    }\\n\\n    public function isEmpty(): bool\\n    {\\n        return true;\\n    }\\n\\n    public function isDefined(): bool\\n    {\\n        return false;\\n    }\\n\\n    public function orElse(Option $else)\\n    {\\n        return $else;\\n    }\\n\\n    public function ifDefined($callable)\\n    {\\n        \/\/ Just do nothing in that case.\\n    }\\n\\n    public function forAll($callable)\\n    {\\n        return $this;\\n    }\\n\\n    public function map($callable)\\n    {\\n        return $this;\\n    }\\n\\n    public function flatMap($callable)\\n    {\\n        return $this;\\n    }\\n\\n    public function filter($callable)\\n    {\\n        return $this;\\n    }\\n\\n    public function filterNot($callable)\\n    {\\n        return $this;\\n    }\\n\\n    public function select($value)\\n    {\\n        return $this;\\n    }\\n\\n    public function reject($value)\\n    {\\n        return $this;\\n    }\\n\\n    public function getIterator(): EmptyIterator\\n    {\\n        return new EmptyIterator();\\n    }\\n\\n    public function foldLeft($initialValue, $callable)\\n    {\\n        return $initialValue;\\n    }\\n\\n    public function foldRight($initialValue, $callable)\\n    {\\n        return $initialValue;\\n    }\\n\\n    private function __construct()\\n    {\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/phpoption\/phpoption\/src\/PhpOption\/Option.php\",\"ext\":\"php\",\"size\":13357,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/*\\n * Copyright 2012 Johannes M. Schmitt <schmittjoh@gmail.com>\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n * http:\/\/www.apache.org\/licenses\/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n *\/\\n\\nnamespace PhpOption;\\n\\nuse ArrayAccess;\\nuse IteratorAggregate;\\n\\n\/**\\n * @template T\\n *\\n * @implements IteratorAggregate<T>\\n *\/\\nabstract class Option implements IteratorAggregate\\n{\\n    \/**\\n     * Creates an option given a return value.\\n     *\\n     * This is intended for consuming existing APIs and allows you to easily\\n     * convert them to an option. By default, we treat ``null`` as the None\\n     * case, and everything else as Some.\\n     *\\n     * @template S\\n     *\\n     * @param S $value     The actual return value.\\n     * @param S $noneValue The value which should be considered \\\"None\\\"; null by\\n     *                     default.\\n     *\\n     * @return Option<S>\\n     *\/\\n    public static function fromValue($value, $noneValue = null)\\n    {\\n        if ($value === $noneValue) {\\n            return None::create();\\n        }\\n\\n        return new Some($value);\\n    }\\n\\n    \/**\\n     * Creates an option from an array's value.\\n     *\\n     * If the key does not exist in the array, the array is not actually an\\n     * array, or the array's value at the given key is null, None is returned.\\n     * Otherwise, Some is returned wrapping the value at the given key.\\n     *\\n     * @template S\\n     *\\n     * @param array<string|int,S>|ArrayAccess<string|int,S>|null $array A potential array or \\\\ArrayAccess value.\\n     * @param string|int|null                                    $key   The key to check.\\n     *\\n     * @return Option<S>\\n     *\/\\n    public static function fromArraysValue($array, $key)\\n    {\\n        if ($key === null || !(is_array($array) || $array instanceof ArrayAccess) || !isset($array[$key])) {\\n            return None::create();\\n        }\\n\\n        return new Some($array[$key]);\\n    }\\n\\n    \/**\\n     * Creates a lazy-option with the given callback.\\n     *\\n     * This is also a helper constructor for lazy-consuming existing APIs where\\n     * the return value is not yet an option. By default, we treat ``null`` as\\n     * None case, and everything else as Some.\\n     *\\n     * @template S\\n     *\\n     * @param callable $callback  The callback to evaluate.\\n     * @param array    $arguments The arguments for the callback.\\n     * @param S        $noneValue The value which should be considered \\\"None\\\";\\n    *                             null by default.\\n     *\\n     * @return LazyOption<S>\\n     *\/\\n    public static function fromReturn($callback, array $arguments = [], $noneValue = null)\\n    {\\n        return new LazyOption(static function () use ($callback, $arguments, $noneValue) {\\n            \/** @var mixed *\/\\n            $return = call_user_func_array($callback, $arguments);\\n\\n            if ($return === $noneValue) {\\n                return None::create();\\n            }\\n\\n            return new Some($return);\\n        });\\n    }\\n\\n    \/**\\n     * Option factory, which creates new option based on passed value.\\n     *\\n     * If value is already an option, it simply returns. If value is callable,\\n     * LazyOption with passed callback created and returned. If Option\\n     * returned from callback, it returns directly. On other case value passed\\n     * to Option::fromValue() method.\\n     *\\n     * @template S\\n     *\\n     * @param Option<S>|callable|S $value\\n     * @param S                    $noneValue Used when $value is mixed or\\n     *                                        callable, for None-check.\\n     *\\n     * @return Option<S>|LazyOption<S>\\n     *\/\\n    public static function ensure($value, $noneValue = null)\\n    {\\n        if ($value instanceof self) {\\n            return $value;\\n        } elseif (is_callable($value)) {\\n            return new LazyOption(static function () use ($value, $noneValue) {\\n                \/** @var mixed *\/\\n                $return = $value();\\n\\n                if ($return instanceof self) {\\n                    return $return;\\n                } else {\\n                    return self::fromValue($return, $noneValue);\\n                }\\n            });\\n        } else {\\n            return self::fromValue($value, $noneValue);\\n        }\\n    }\\n\\n    \/**\\n     * Lift a function so that it accepts Option as parameters.\\n     *\\n     * We return a new closure that wraps the original callback. If any of the\\n     * parameters passed to the lifted function is empty, the function will\\n     * return a value of None. Otherwise, we will pass all parameters to the\\n     * original callback and return the value inside a new Option, unless an\\n     * Option is returned from the function, in which case, we use that.\\n     *\\n     * @template S\\n     *\\n     * @param callable $callback\\n     * @param mixed    $noneValue\\n     *\\n     * @return callable\\n     *\/\\n    public static function lift($callback, $noneValue = null)\\n    {\\n        return static function () use ($callback, $noneValue) {\\n            \/** @var array<int, mixed> *\/\\n            $args = func_get_args();\\n\\n            $reduced_args = array_reduce(\\n                $args,\\n                \/** @param bool $status *\/\\n                static function ($status, self $o) {\\n                    return $o->isEmpty() ? true : $status;\\n                },\\n                false\\n            );\\n            \/\/ if at least one parameter is empty, return None\\n            if ($reduced_args) {\\n                return None::create();\\n            }\\n\\n            $args = array_map(\\n                \/** @return T *\/\\n                static function (self $o) {\\n                    \/\/ it is safe to do so because the fold above checked\\n                    \/\/ that all arguments are of type Some\\n                    \/** @var T *\/\\n                    return $o->get();\\n                },\\n                $args\\n            );\\n\\n            return self::ensure(call_user_func_array($callback, $args), $noneValue);\\n        };\\n    }\\n\\n    \/**\\n     * Returns the value if available, or throws an exception otherwise.\\n     *\\n     * @throws \\\\RuntimeException If value is not available.\\n     *\\n     * @return T\\n     *\/\\n    abstract public function get();\\n\\n    \/**\\n     * Returns the value if available, or the default value if not.\\n     *\\n     * @template S\\n     *\\n     * @param S $default\\n     *\\n     * @return T|S\\n     *\/\\n    abstract public function getOrElse($default);\\n\\n    \/**\\n     * Returns the value if available, or the results of the callable.\\n     *\\n     * This is preferable over ``getOrElse`` if the computation of the default\\n     * value is expensive.\\n     *\\n     * @template S\\n     *\\n     * @param callable():S $callable\\n     *\\n     * @return T|S\\n     *\/\\n    abstract public function getOrCall($callable);\\n\\n    \/**\\n     * Returns the value if available, or throws the passed exception.\\n     *\\n     * @param \\\\Exception $ex\\n     *\\n     * @return T\\n     *\/\\n    abstract public function getOrThrow(\\\\Exception $ex);\\n\\n    \/**\\n     * Returns true if no value is available, false otherwise.\\n     *\\n     * @return bool\\n     *\/\\n    abstract public function isEmpty();\\n\\n    \/**\\n     * Returns true if a value is available, false otherwise.\\n     *\\n     * @return bool\\n     *\/\\n    abstract public function isDefined();\\n\\n    \/**\\n     * Returns this option if non-empty, or the passed option otherwise.\\n     *\\n     * This can be used to try multiple alternatives, and is especially useful\\n     * with lazy evaluating options:\\n     *\\n     * ```php\\n     *     $repo->findSomething()\\n     *         ->orElse(new LazyOption(array($repo, 'findSomethingElse')))\\n     *         ->orElse(new LazyOption(array($repo, 'createSomething')));\\n     * ```\\n     *\\n     * @param Option<T> $else\\n     *\\n     * @return Option<T>\\n     *\/\\n    abstract public function orElse(self $else);\\n\\n    \/**\\n     * This is similar to map() below except that the return value has no meaning;\\n     * the passed callable is simply executed if the option is non-empty, and\\n     * ignored if the option is empty.\\n     *\\n     * In all cases, the return value of the callable is discarded.\\n     *\\n     * ```php\\n     *     $comment->getMaybeFile()->ifDefined(function($file) {\\n     *         \/\/ Do something with $file here.\\n     *     });\\n     * ```\\n     *\\n     * If you're looking for something like ``ifEmpty``, you can use ``getOrCall``\\n     * and ``getOrElse`` in these cases.\\n     *\\n     * @deprecated Use forAll() instead.\\n     *\\n     * @param callable(T):mixed $callable\\n     *\\n     * @return void\\n     *\/\\n    abstract public function ifDefined($callable);\\n\\n    \/**\\n     * This is similar to map() except that the return value of the callable has no meaning.\\n     *\\n     * The passed callable is simply executed if the option is non-empty, and ignored if the\\n     * option is empty. This method is preferred for callables with side-effects, while map()\\n     * is intended for callables without side-effects.\\n     *\\n     * @param callable(T):mixed $callable\\n     *\\n     * @return Option<T>\\n     *\/\\n    abstract public function forAll($callable);\\n\\n    \/**\\n     * Applies the callable to the value of the option if it is non-empty,\\n     * and returns the return value of the callable wrapped in Some().\\n     *\\n     * If the option is empty, then the callable is not applied.\\n     *\\n     * ```php\\n     *     (new Some(\\\"foo\\\"))->map('strtoupper')->get(); \/\/ \\\"FOO\\\"\\n     * ```\\n     *\\n     * @template S\\n     *\\n     * @param callable(T):S $callable\\n     *\\n     * @return Option<S>\\n     *\/\\n    abstract public function map($callable);\\n\\n    \/**\\n     * Applies the callable to the value of the option if it is non-empty, and\\n     * returns the return value of the callable directly.\\n     *\\n     * In contrast to ``map``, the return value of the callable is expected to\\n     * be an Option itself; it is not automatically wrapped in Some().\\n     *\\n     * @template S\\n     *\\n     * @param callable(T):Option<S> $callable must return an Option\\n     *\\n     * @return Option<S>\\n     *\/\\n    abstract public function flatMap($callable);\\n\\n    \/**\\n     * If the option is empty, it is returned immediately without applying the callable.\\n     *\\n     * If the option is non-empty, the callable is applied, and if it returns true,\\n     * the option itself is returned; otherwise, None is returned.\\n     *\\n     * @param callable(T):bool $callable\\n     *\\n     * @return Option<T>\\n     *\/\\n    abstract public function filter($callable);\\n\\n    \/**\\n     * If the option is empty, it is returned immediately without applying the callable.\\n     *\\n     * If the option is non-empty, the callable is applied, and if it returns false,\\n     * the option itself is returned; otherwise, None is returned.\\n     *\\n     * @param callable(T):bool $callable\\n     *\\n     * @return Option<T>\\n     *\/\\n    abstract public function filterNot($callable);\\n\\n    \/**\\n     * If the option is empty, it is returned immediately.\\n     *\\n     * If the option is non-empty, and its value does not equal the passed value\\n     * (via a shallow comparison ===), then None is returned. Otherwise, the\\n     * Option is returned.\\n     *\\n     * In other words, this will filter all but the passed value.\\n     *\\n     * @param T $value\\n     *\\n     * @return Option<T>\\n     *\/\\n    abstract public function select($value);\\n\\n    \/**\\n     * If the option is empty, it is returned immediately.\\n     *\\n     * If the option is non-empty, and its value does equal the passed value (via\\n     * a shallow comparison ===), then None is returned; otherwise, the Option is\\n     * returned.\\n     *\\n     * In other words, this will let all values through except the passed value.\\n     *\\n     * @param T $value\\n     *\\n     * @return Option<T>\\n     *\/\\n    abstract public function reject($value);\\n\\n    \/**\\n     * Binary operator for the initial value and the option's value.\\n     *\\n     * If empty, the initial value is returned. If non-empty, the callable\\n     * receives the initial value and the option's value as arguments.\\n     *\\n     * ```php\\n     *\\n     *     $some = new Some(5);\\n     *     $none = None::create();\\n     *     $result = $some->foldLeft(1, function($a, $b) { return $a + $b; }); \/\/ int(6)\\n     *     $result = $none->foldLeft(1, function($a, $b) { return $a + $b; }); \/\/ int(1)\\n     *\\n     *     \/\/ This can be used instead of something like the following:\\n     *     $option = Option::fromValue($integerOrNull);\\n     *     $result = 1;\\n     *     if ( ! $option->isEmpty()) {\\n     *         $result += $option->get();\\n     *     }\\n     * ```\\n     *\\n     * @template S\\n     *\\n     * @param S                $initialValue\\n     * @param callable(S, T):S $callable\\n     *\\n     * @return S\\n     *\/\\n    abstract public function foldLeft($initialValue, $callable);\\n\\n    \/**\\n     * foldLeft() but with reversed arguments for the callable.\\n     *\\n     * @template S\\n     *\\n     * @param S                $initialValue\\n     * @param callable(T, S):S $callable\\n     *\\n     * @return S\\n     *\/\\n    abstract public function foldRight($initialValue, $callable);\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/automattic\/jetpack-autoloader\/SECURITY.md\",\"ext\":\"md\",\"size\":2506,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"# Security Policy\\n\\nFull details of the Automattic Security Policy can be found on [automattic.com](https:\/\/automattic.com\/security\/).\\n\\n## Supported Versions\\n\\nGenerally, only the latest version of Jetpack and its associated plugins have continued support. If a critical vulnerability is found in the current version of a plugin, we may opt to backport any patches to previous versions. \\n\\n## Reporting a Vulnerability\\n\\nOur HackerOne program covers the below plugin software, as well as a variety of related projects and infrastructure:\\n\\n* [Jetpack](https:\/\/jetpack.com\/)\\n* Jetpack Backup\\n* Jetpack Boost\\n* Jetpack CRM\\n* Jetpack Protect\\n* Jetpack Search\\n* Jetpack Social\\n* Jetpack VideoPress\\n\\n**For responsible disclosure of security issues and to be eligible for our bug bounty program, please submit your report via the [HackerOne](https:\/\/hackerone.com\/automattic) portal.**\\n\\nOur most critical targets are:\\n\\n* Jetpack and the Jetpack composer packages (all within this repo)\\n* Jetpack.com -- the primary marketing site.\\n* cloud.jetpack.com -- a management site.\\n* wordpress.com -- the shared management site for both Jetpack and WordPress.com sites.\\n\\nFor more targets, see the `In Scope` section on [HackerOne](https:\/\/hackerone.com\/automattic).\\n\\n_Please note that the **WordPress software is a separate entity** from Automattic. Please report vulnerabilities for WordPress through [the WordPress Foundation's HackerOne page](https:\/\/hackerone.com\/wordpress)._\\n\\n## Guidelines\\n\\nWe're committed to working with security researchers to resolve the vulnerabilities they discover. You can help us by following these guidelines:\\n\\n*   Follow [HackerOne's disclosure guidelines](https:\/\/www.hackerone.com\/disclosure-guidelines).\\n*   Pen-testing Production:\\n    *   Please **setup a local environment** instead whenever possible. Most of our code is open source (see above).\\n    *   If that's not possible, **limit any data access\/modification** to the bare minimum necessary to reproduce a PoC.\\n    *   **_Don't_ automate form submissions!** That's very annoying for us, because it adds extra work for the volunteers who manage those systems, and reduces the signal\/noise ratio in our communication channels.\\n    *   To be eligible for a bounty, all of these guidelines must be followed.\\n*   Be Patient - Give us a reasonable time to correct the issue before you disclose the vulnerability.\\n\\nWe also expect you to comply with all applicable laws. You're responsible to pay any taxes associated with your bounties.\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/automattic\/jetpack-autoloader\/CHANGELOG.md\",\"ext\":\"md\",\"size\":18625,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"# Changelog\\n\\nAll notable changes to this project will be documented in this file.\\n\\nThe format is based on [Keep a Changelog](https:\/\/keepachangelog.com\/en\/1.0.0\/)\\nand this project adheres to [Semantic Versioning](https:\/\/semver.org\/spec\/v2.0.0.html).\\n\\n## [5.0.9] - 2025-07-28\\n### Changed\\n- Exclude development files from production build of the package. [#44456]\\n\\n## [5.0.8] - 2025-06-23\\n### Fixed\\n- Autoloader: Prevent double slash in autoloader path. [#44030]\\n\\n## [5.0.7] - 2025-04-28\\n### Changed\\n- Internal updates.\\n\\n## [5.0.6] - 2025-03-31\\n### Changed\\n- Internal updates.\\n\\n## [5.0.5] - 2025-03-21\\n### Changed\\n- Internal updates.\\n\\n## [5.0.4] - 2025-03-17\\n### Changed\\n- Internal updates.\\n\\n## [5.0.3] - 2025-03-12\\n### Changed\\n- Internal updates.\\n\\n## [5.0.2] - 2025-02-24\\n### Changed\\n- Internal updates.\\n\\n## [5.0.1] - 2025-01-20\\n### Changed\\n- Code: Use function-style exit() and die() with a default status code of 0. [#41167]\\n\\n## [5.0.0] - 2024-11-25\\n### Removed\\n- Drop support for Composer <2.2. [#40297]\\n- Remove support for WordPress 6.5 and earlier. [#40200]\\n\\n## [4.0.0] - 2024-11-14\\n### Removed\\n- General: Update minimum PHP version to 7.2. [#40147]\\n\\n## [3.1.3] - 2024-11-04\\n### Added\\n- Enable test coverage. [#39961]\\n\\n## [3.1.2] - 2024-10-15\\n### Changed\\n- Internal updates.\\n\\n## [3.1.1] - 2024-10-10\\n### Changed\\n- Internal updates.\\n\\n## [3.1.0] - 2024-09-06\\n### Added\\n- Add logic for debugging issues caused by conflicting Composer autoloaders, enabled by setting the `JETPACK_AUTOLOAD_DEBUG_CONFLICTING_LOADERS` constant. [#38995]\\n- Add logic for debugging issues caused by early class loads, enabled by setting the `JETPACK_AUTOLOAD_DEBUG_EARLY_LOADS` constant. [#38995]\\n\\n## [3.0.10] - 2024-08-26\\n### Changed\\n- Updated package dependencies. [#39004]\\n\\n## [3.0.9] - 2024-07-10\\n### Fixed\\n- Avoid a deprecation notice in `Autoloader_Locator::find_latest_autoloader()`. [#38245]\\n\\n## [3.0.8] - 2024-05-29\\n### Fixed\\n- `AutoloadGenerator::__construct` no longer pretends `$io` is nullable. That never worked. [#37608]\\n\\n## [3.0.7] - 2024-05-06\\n### Fixed\\n- Avoid deprecation notices when plugin path is null. [#37174]\\n\\n## [3.0.6] - 2024-04-22\\n### Changed\\n- Internal updates.\\n\\n## [3.0.5] - 2024-04-11\\n### Changed\\n- Internal updates.\\n\\n## [3.0.4] - 2024-03-18\\n### Changed\\n- Internal updates.\\n\\n## [3.0.3] - 2024-03-14\\n### Changed\\n- Internal updates.\\n\\n## [3.0.2] - 2023-11-21\\n\\n## [3.0.1] - 2023-11-21\\n\\n## [3.0.0] - 2023-11-20\\n### Changed\\n- Updated required PHP version to >= 7.0. [#34192]\\n\\n## [2.12.0] - 2023-09-28\\n### Added\\n- Add an `AutoloadGenerator::VERSION` constant, and use that for the autoloader's version in preference to whatever Composer has. [#33156]\\n\\n## [2.11.23] - 2023-09-19\\n\\n- Minor internal updates.\\n\\n## [2.11.22] - 2023-08-23\\n### Changed\\n- Updated package dependencies. [#32605]\\n\\n## [2.11.21] - 2023-05-22\\n### Added\\n- Set keywords in `composer.json`. [#30756]\\n\\n## [2.11.20] - 2023-05-11\\n\\n- Updated package dependencies\\n\\n## [2.11.19] - 2023-04-25\\n### Fixed\\n- Fix example in README [#30225]\\n\\n## [2.11.18] - 2023-03-28\\n### Changed\\n- Minor internal updates.\\n\\n## [2.11.17] - 2023-03-27\\n### Fixed\\n- Don't error when processing packages specifying missing PSR paths. [#29669]\\n\\n## [2.11.16] - 2023-02-20\\n### Changed\\n- Minor internal updates.\\n\\n## [2.11.15] - 2023-01-11\\n### Changed\\n- Updated package dependencies.\\n\\n## [2.11.14] - 2022-12-19\\n### Changed\\n- Use `Composer\\\\ClassMapGenerator\\\\ClassMapGenerator` when available (i.e. with composer 2.4). [#27812]\\n\\n### Fixed\\n- Declare fields for PHP 8.2 compatibility. [#27949]\\n\\n## [2.11.13] - 2022-12-02\\n### Changed\\n- Updated package dependencies. [#27688]\\n\\n## [2.11.12] - 2022-11-22\\n### Changed\\n- Updated package dependencies. [#27043]\\n\\n## [2.11.11] - 2022-10-25\\n### Changed\\n- Sort data in generated `vendor\/composer\/jetpack_autoload_classmap.php` to avoid spurious diffs. [#26929]\\n\\n## [2.11.10] - 2022-10-05\\n\\n- Tests: Clear `COMPOSER_AUTH` environment variable when running Composer for tests. [#26404]\\n\\n## [2.11.9] - 2022-09-27\\n### Fixed\\n- Tests: Clear `COMPOSER_AUTH` environment variable when running Composer for tests. [#26404]\\n\\n## [2.11.8] - 2022-09-20\\n### Fixed\\n- Tests: skip test if it requires a version of Composer not compatible with the running version of PHP. [#26143]\\n\\n## [2.11.7] - 2022-07-26\\n### Changed\\n- Updated package dependencies. [#25158]\\n\\n## [2.11.6] - 2022-06-21\\n### Changed\\n- Renaming `master` to `trunk`.\\n\\n## [2.11.5] - 2022-05-18\\n### Fixed\\n- Fix new PHPCS sniffs. [#24366]\\n\\n## [2.11.4] - 2022-04-26\\n### Changed\\n- Updated package dependencies.\\n\\n## [2.11.3] - 2022-04-19\\n### Changed\\n- PHPCS: Fix `WordPress.Security.ValidatedSanitizedInput`\\n\\n## [2.11.2] - 2022-03-29\\n### Changed\\n- Microperformance: Use === null instead of is_null\\n\\n## [2.11.1] - 2022-03-08\\n### Removed\\n- Removed the Upgrade Handler.\\n\\n## [2.11.0] - 2022-03-08\\n### Added\\n- On plugin update, pre-load all (non-PSR-4) classes from the plugin to avoid mid-upgrade fatals.\\n\\n## [2.10.13] - 2022-03-01\\n### Fixed\\n- Fix tests for upstream phpunit change.\\n\\n## [2.10.12] - 2022-01-25\\n### Changed\\n- Updated package dependencies.\\n\\n## [2.10.11] - 2022-01-04\\n### Changed\\n- Switch to pcov for code coverage.\\n- Updated package dependencies\\n\\n## [2.10.10] - 2021-11-16\\n### Added\\n- Soft return if autoloader chain is not available.\\n\\n## [2.10.9] - 2021-11-02\\n### Changed\\n- Set `convertDeprecationsToExceptions` true in PHPUnit config.\\n\\n## [2.10.8] - 2021-10-13\\n### Changed\\n- Updated package dependencies.\\n\\n## [2.10.7] - 2021-10-07\\n### Changed\\n- Updated package dependencies\\n\\n## [2.10.6] - 2021-09-28\\n### Changed\\n- Updated package dependencies.\\n\\n## [2.10.5] - 2021-08-31\\n### Changed\\n- Run composer update on test-php command instead of phpunit\\n- Tests: update PHPUnit polyfills dependency (yoast\/phpunit-polyfills).\\n\\n## [2.10.4] - 2021-08-10\\n### Changed\\n- Updated package dependencies.\\n\\n## [2.10.3] - 2021-05-25\\n### Changed\\n- Updated package dependencies.\\n\\n## [2.10.2] - 2021-04-27\\n### Changed\\n- Updated package dependencies.\\n\\n## [2.10.1] - 2021-03-30\\n### Added\\n- Composer alias for dev-master, to improve dependencies\\n- Tests: Added code coverage transformation\\n\\n### Changed\\n- Update package dependencies.\\n\\n### Fixed\\n- Fix coverage test\\n- Fix uninstallation fatal\\n- Update tests for changed composer 2.0.9 hash.\\n- Use `composer update` rather than `install` in scripts, as composer.lock isn't checked in.\\n\\n## [2.10.0] - 2021-02-09\\n\\n- Autoloader: test suite refactor\\n\\n## [2.9.1] - 2021-02-05\\n\\n- CI: Make tests more generic\\n- Autoloader: stricter type-checking on WP functions\\n- Autoloader: prevent transitive plugin execution\\n\\n## [2.9.0] - 2021-01-25\\n\\n- Autoloader: revised latest autoloader inclusion semantics\\n- Add mirror-repo information to all current composer packages\\n- Monorepo: Reorganize all projects\\n- Autoloader: Don't cache deactivating plugins\\n\\n## [2.8.0] - 2020-12-18\\n\\n## [2.7.1] - 2020-12-18\\n\\n- Autoloader: Added realpath resolution to plugin paths\\n\\n## [2.7.0] - 2020-12-08\\n\\n- Autoloader: Preemptively load unknown plugins from cache\\n- Removed unwanted dot\\n- Pin dependencies\\n- Packages: Update for PHP 8 testing\\n\\n## [2.6.0] - 2020-11-19\\n\\n- Autoloader: AutoloadGenerator no longer extends Composer's AutoloadGenerator class\\n- Autoloader: Reuse an existing autoloader suffix if available\\n- Updated PHPCS: Packages and Debugger\\n\\n## [2.5.0] - 2020-10-08\\n\\n- Autoloader: remove the defined('JETPACK_AUTOLOAD_DEV') checks from the tests\\n\\n## [2.4.0] - 2020-09-28\\n\\n- Autoloader: remove the plugins_loaded bullet point from the README\\n- Packages: avoid PHPCS warnings\\n- Autoloader: add PSR-0 support\\n- Autoloader: Detect filtering of active_plugins\\n- Autoloader: Support unoptimized PSR-4\\n\\n## [2.3.0] - 2020-08-21\\n\\n- Autoloader: remove the plugin update hook\\n\\n## [2.2.0] - 2020-08-14\\n\\n- Autoloader: don't reset the autoloader version during plugin update\\n- CI: Try collect js coverage\\n\\n## [2.1.0] - 2020-07-27\\n\\n- Autoloader: convert '\\\\' directory separators to '\/' in plugin paths\\n- Autoloader: Avoid a PHP warning when an empty string is passed to `is_directory_plugin()`.\\n- Autoloader: Tests: Use a string with define\\n\\n## [2.0.2] - 2020-07-09\\n\\n- Autoloader: Avoid a PHP warning when an empty string is passed to `is_directory_plugin()`.\\n\\n## [2.0.1] - 2020-07-02\\n\\n- Autoloader: Tests: Use a string with define\\n\\n## [2.0.0] - 2020-06-29\\n\\n## [2.0.0-beta] - 2020-06-29\\n\\n- Autoloader: Support Composer v2.0\\n- Autoloader: use paths to identify plugins instead of the directories\\n- Autoloader: fix the fatal that occurs during plugin update\\n- Autoloader: add fallback check for plugin path in mu-plugins\\n- Autoloader: use JETPACK__PLUGIN_DIR when looking for the jetpack plugin directory.\\n- Feature Branch: Update the Autoloader\\n- PHPCS: Clean up the packages\\n- PHPCS Updates after WPCS 2.3\\n\\n## [1.7.0] - 2020-04-23\\n\\n- Jetpack: Move comment notification override back to the constructor\\n\\n## [1.6.0] - 2020-03-26\\n\\n- Autoloader: Remove file check to improve performance.\\n\\n## [1.5.0] - 2020-02-25\\n\\n- Jetpack: instantiate manager object if it's null\\n\\n## [1.4.1] - 2020-02-14\\n\\n- Autoloader: Load only latest version of autoload files to avoid conflicts.\\n\\n## [1.4.0] - 2020-01-23\\n\\n- Autoloader: Remove the ignored classes\\n\\n## [1.3.8] - 2020-01-14\\n\\n- Trying to add deterministic initialization.\\n- Autoloader: Remove Manager_Interface and Plugin\\\\Tracking from ignored list\\n- Autoloader: Remove Jetpack_IXR_Client from ignore list\\n\\n## [1.3.7] - 2019-12-10\\n\\n## [1.3.6] - 2019-12-09\\n\\n- Autoloader: Use long-form sytax for array\\n\\n## [1.3.5] - 2019-11-26\\n\\n- Fix\/php notice status\\n\\n## [1.3.4] - 2019-11-08\\n\\n- Deprecate Jetpack::is_development_mode() in favor of the packaged Status()-&gt;is_development_mode()\\n\\n## [1.3.3] - 2019-10-28\\n\\n- Packages: Add gitattributes files to all packages that need th\u2026\\n\\n## [1.3.2] - 2019-09-24\\n\\n- Autoloader: Cover scenarios where composer\/autoload_files.php\u2026\\n\\n## [1.3.1] - 2019-09-20\\n\\n- Docs: Unify usage of @package phpdoc tags\\n\\n## [1.3.0] - 2019-09-14\\n\\n- Fix for empty namespaces. #13459\\n- Connection: Move the Jetpack IXR client to the package\\n- Adds full connection cycle capability to the Connection package.\\n- Jetpack 7.5: Back compatibility package\\n\\n## [1.2.0] - 2019-06-24\\n\\n- Jetpack DNA: Add full classmap support to Autoloader\\n- Move Jetpack_Sync_Main from legacy to PSR-4\\n\\n## [1.1.0] - 2019-06-19\\n\\n- Packages: Move autoloader tests to the package\\n- DNA: Move Jetpack Usage tracking to its own file\\n- Jetpack DNA: More isolation of Tracks Package\\n- Autoloader: Ignore XMLRPC_Connector if called too early\\n- Autoloader: Ignore Jetpack_Signature if called too early\\n\\n## 1.0.0 - 2019-06-11\\n\\n- Add Custom Autoloader\\n\\n[5.0.9]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v5.0.8...v5.0.9\\n[5.0.8]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v5.0.7...v5.0.8\\n[5.0.7]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v5.0.6...v5.0.7\\n[5.0.6]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v5.0.5...v5.0.6\\n[5.0.5]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v5.0.4...v5.0.5\\n[5.0.4]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v5.0.3...v5.0.4\\n[5.0.3]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v5.0.2...v5.0.3\\n[5.0.2]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v5.0.1...v5.0.2\\n[5.0.1]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v5.0.0...v5.0.1\\n[5.0.0]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v4.0.0...v5.0.0\\n[4.0.0]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v3.1.3...v4.0.0\\n[3.1.3]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v3.1.2...v3.1.3\\n[3.1.2]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v3.1.1...v3.1.2\\n[3.1.1]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v3.1.0...v3.1.1\\n[3.1.0]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v3.0.10...v3.1.0\\n[3.0.10]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v3.0.9...v3.0.10\\n[3.0.9]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v3.0.8...v3.0.9\\n[3.0.8]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v3.0.7...v3.0.8\\n[3.0.7]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v3.0.6...v3.0.7\\n[3.0.6]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v3.0.5...v3.0.6\\n[3.0.5]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v3.0.4...v3.0.5\\n[3.0.4]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v3.0.3...v3.0.4\\n[3.0.3]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v3.0.2...v3.0.3\\n[3.0.2]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v3.0.1...v3.0.2\\n[3.0.1]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v3.0.0...v3.0.1\\n[3.0.0]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.12.0...v3.0.0\\n[2.12.0]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.11.23...v2.12.0\\n[2.11.23]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.11.22...v2.11.23\\n[2.11.22]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.11.21...v2.11.22\\n[2.11.21]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.11.20...v2.11.21\\n[2.11.20]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.11.19...v2.11.20\\n[2.11.19]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.11.18...v2.11.19\\n[2.11.18]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.11.17...v2.11.18\\n[2.11.17]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.11.16...v2.11.17\\n[2.11.16]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.11.15...v2.11.16\\n[2.11.15]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.11.14...v2.11.15\\n[2.11.14]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.11.13...v2.11.14\\n[2.11.13]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.11.12...v2.11.13\\n[2.11.12]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.11.11...v2.11.12\\n[2.11.11]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.11.10...v2.11.11\\n[2.11.10]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.11.9...v2.11.10\\n[2.11.9]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.11.8...v2.11.9\\n[2.11.8]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.11.7...v2.11.8\\n[2.11.7]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.11.6...v2.11.7\\n[2.11.6]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.11.5...v2.11.6\\n[2.11.5]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.11.4...v2.11.5\\n[2.11.4]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.11.3...v2.11.4\\n[2.11.3]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.11.2...v2.11.3\\n[2.11.2]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.11.1...v2.11.2\\n[2.11.1]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.11.0...v2.11.1\\n[2.11.0]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.10.13...v2.11.0\\n[2.10.13]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.10.12...v2.10.13\\n[2.10.12]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.10.11...v2.10.12\\n[2.10.11]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.10.10...v2.10.11\\n[2.10.10]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.10.9...v2.10.10\\n[2.10.9]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.10.8...v2.10.9\\n[2.10.8]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.10.7...v2.10.8\\n[2.10.7]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.10.6...v2.10.7\\n[2.10.6]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.10.5...v2.10.6\\n[2.10.5]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.10.4...v2.10.5\\n[2.10.4]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.10.3...v2.10.4\\n[2.10.3]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.10.2...v2.10.3\\n[2.10.2]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.10.1...v2.10.2\\n[2.10.1]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.10.0...v2.10.1\\n[2.10.0]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.9.1...v2.10.0\\n[2.9.1]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.9.0...v2.9.1\\n[2.9.0]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.8.0...v2.9.0\\n[2.8.0]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.7.1...v2.8.0\\n[2.7.1]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.7.0...v2.7.1\\n[2.7.0]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.6.0...v2.7.0\\n[2.6.0]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.5.0...v2.6.0\\n[2.5.0]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.4.0...v2.5.0\\n[2.4.0]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.3.0...v2.4.0\\n[2.3.0]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.2.0...v2.3.0\\n[2.2.0]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.1.0...v2.2.0\\n[2.1.0]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.0.2...v2.1.0\\n[2.0.2]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.0.1...v2.0.2\\n[2.0.1]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.0.0...v2.0.1\\n[2.0.0]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v2.0.0-beta...v2.0.0\\n[2.0.0-beta]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v1.7.0...v2.0.0-beta\\n[1.7.0]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v1.6.0...v1.7.0\\n[1.6.0]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v1.5.0...v1.6.0\\n[1.5.0]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v1.4.1...v1.5.0\\n[1.4.1]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v1.4.0...v1.4.1\\n[1.4.0]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v1.3.8...v1.4.0\\n[1.3.8]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v1.3.7...v1.3.8\\n[1.3.7]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v1.3.6...v1.3.7\\n[1.3.6]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v1.3.5...v1.3.6\\n[1.3.5]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v1.3.4...v1.3.5\\n[1.3.4]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v1.3.3...v1.3.4\\n[1.3.3]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v1.3.2...v1.3.3\\n[1.3.2]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v1.3.1...v1.3.2\\n[1.3.1]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v1.3.0...v1.3.1\\n[1.3.0]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v1.2.0...v1.3.0\\n[1.2.0]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v1.1.0...v1.2.0\\n[1.1.0]: https:\/\/github.com\/Automattic\/jetpack-autoloader\/compare\/v1.0.0...v1.1.0\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/automattic\/jetpack-autoloader\/src\/AutoloadGenerator.php\",\"ext\":\"php\",\"size\":13649,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Autoloader Generator.\\n *\\n * @package automattic\/jetpack-autoloader\\n *\/\\n\\nnamespace Automattic\\\\Jetpack\\\\Autoloader;\\n\\nuse Composer\\\\Composer;\\nuse Composer\\\\Config;\\nuse Composer\\\\Installer\\\\InstallationManager;\\nuse Composer\\\\IO\\\\IOInterface;\\nuse Composer\\\\Package\\\\PackageInterface;\\nuse Composer\\\\Repository\\\\InstalledRepositoryInterface;\\nuse Composer\\\\Util\\\\Filesystem;\\nuse Composer\\\\Util\\\\PackageSorter;\\n\\n\/**\\n * Class AutoloadGenerator.\\n *\/\\nclass AutoloadGenerator {\\n\\n\\tconst VERSION = '5.0.9';\\n\\n\\t\/**\\n\\t * IO object.\\n\\t *\\n\\t * @var IOInterface IO object.\\n\\t *\/\\n\\tprivate $io;\\n\\n\\t\/**\\n\\t * The filesystem utility.\\n\\t *\\n\\t * @var Filesystem\\n\\t *\/\\n\\tprivate $filesystem;\\n\\n\\t\/**\\n\\t * Instantiate an AutoloadGenerator object.\\n\\t *\\n\\t * @param IOInterface $io IO object.\\n\\t *\/\\n\\tpublic function __construct( IOInterface $io ) {\\n\\t\\t$this->io         = $io;\\n\\t\\t$this->filesystem = new Filesystem();\\n\\t}\\n\\n\\t\/**\\n\\t * Dump the Jetpack autoloader files.\\n\\t *\\n\\t * @param Composer                     $composer The Composer object.\\n\\t * @param Config                       $config Config object.\\n\\t * @param InstalledRepositoryInterface $localRepo Installed Repository object.\\n\\t * @param PackageInterface             $mainPackage Main Package object.\\n\\t * @param InstallationManager          $installationManager Manager for installing packages.\\n\\t * @param string                       $targetDir Path to the current target directory.\\n\\t * @param bool                         $scanPsrPackages Whether or not PSR packages should be converted to a classmap.\\n\\t * @param string                       $suffix The autoloader suffix.\\n\\t *\/\\n\\tpublic function dump(\\n\\t\\tComposer $composer,\\n\\t\\tConfig $config,\\n\\t\\tInstalledRepositoryInterface $localRepo,\\n\\t\\tPackageInterface $mainPackage,\\n\\t\\tInstallationManager $installationManager,\\n\\t\\t$targetDir,\\n\\t\\t$scanPsrPackages = false,\\n\\t\\t$suffix = null\\n\\t) {\\n\\t\\t$this->filesystem->ensureDirectoryExists( $config->get( 'vendor-dir' ) );\\n\\n\\t\\t$packageMap = $composer->getAutoloadGenerator()->buildPackageMap( $installationManager, $mainPackage, $localRepo->getCanonicalPackages() );\\n\\t\\t$autoloads  = $this->parseAutoloads( $packageMap, $mainPackage );\\n\\n\\t\\t\/\/ Convert the autoloads into a format that the manifest generator can consume more easily.\\n\\t\\t$basePath           = $this->filesystem->normalizePath( realpath( getcwd() ) );\\n\\t\\t$vendorPath         = $this->filesystem->normalizePath( realpath( $config->get( 'vendor-dir' ) ) );\\n\\t\\t$processedAutoloads = $this->processAutoloads( $autoloads, $scanPsrPackages, $vendorPath, $basePath );\\n\\t\\tunset( $packageMap, $autoloads );\\n\\n\\t\\t\/\/ Make sure none of the legacy files remain that can lead to problems with the autoloader.\\n\\t\\t$this->removeLegacyFiles( $vendorPath );\\n\\n\\t\\t\/\/ Write all of the files now that we're done.\\n\\t\\t$this->writeAutoloaderFiles( $vendorPath . '\/jetpack-autoloader\/', $suffix );\\n\\t\\t$this->writeManifests( $vendorPath . '\/' . $targetDir, $processedAutoloads );\\n\\n\\t\\tif ( ! $scanPsrPackages ) {\\n\\t\\t\\t$this->io->writeError( '<warning>You are generating an unoptimized autoloader. If this is a production build, consider using the -o option.<\/warning>' );\\n\\t\\t}\\n\\t}\\n\\n\\t\/**\\n\\t * Compiles an ordered list of namespace => path mappings\\n\\t *\\n\\t * @param  array            $packageMap  Array of array(package, installDir-relative-to-composer.json).\\n\\t * @param  PackageInterface $mainPackage Main package instance.\\n\\t *\\n\\t * @return array The list of path mappings.\\n\\t *\/\\n\\tpublic function parseAutoloads( array $packageMap, PackageInterface $mainPackage ) {\\n\\t\\t$rootPackageMap = array_shift( $packageMap );\\n\\n\\t\\t$sortedPackageMap   = $this->sortPackageMap( $packageMap );\\n\\t\\t$sortedPackageMap[] = $rootPackageMap;\\n\\t\\tarray_unshift( $packageMap, $rootPackageMap );\\n\\n\\t\\t$psr0     = $this->parseAutoloadsType( $packageMap, 'psr-0', $mainPackage );\\n\\t\\t$psr4     = $this->parseAutoloadsType( $packageMap, 'psr-4', $mainPackage );\\n\\t\\t$classmap = $this->parseAutoloadsType( array_reverse( $sortedPackageMap ), 'classmap', $mainPackage );\\n\\t\\t$files    = $this->parseAutoloadsType( $sortedPackageMap, 'files', $mainPackage );\\n\\n\\t\\tkrsort( $psr0 );\\n\\t\\tkrsort( $psr4 );\\n\\n\\t\\treturn array(\\n\\t\\t\\t'psr-0'    => $psr0,\\n\\t\\t\\t'psr-4'    => $psr4,\\n\\t\\t\\t'classmap' => $classmap,\\n\\t\\t\\t'files'    => $files,\\n\\t\\t);\\n\\t}\\n\\n\\t\/**\\n\\t * Sorts packages by dependency weight\\n\\t *\\n\\t * Packages of equal weight retain the original order\\n\\t *\\n\\t * @param  array $packageMap The package map.\\n\\t *\\n\\t * @return array\\n\\t *\/\\n\\tprotected function sortPackageMap( array $packageMap ) {\\n\\t\\t$packages = array();\\n\\t\\t$paths    = array();\\n\\n\\t\\tforeach ( $packageMap as $item ) {\\n\\t\\t\\tlist( $package, $path ) = $item;\\n\\t\\t\\t$name                   = $package->getName();\\n\\t\\t\\t$packages[ $name ]      = $package;\\n\\t\\t\\t$paths[ $name ]         = $path;\\n\\t\\t}\\n\\n\\t\\t$sortedPackages = PackageSorter::sortPackages( $packages );\\n\\n\\t\\t$sortedPackageMap = array();\\n\\n\\t\\tforeach ( $sortedPackages as $package ) {\\n\\t\\t\\t$name               = $package->getName();\\n\\t\\t\\t$sortedPackageMap[] = array( $packages[ $name ], $paths[ $name ] );\\n\\t\\t}\\n\\n\\t\\treturn $sortedPackageMap;\\n\\t}\\n\\n\\t\/**\\n\\t * Returns the file identifier.\\n\\t *\\n\\t * @param PackageInterface $package The package instance.\\n\\t * @param string           $path The path.\\n\\t *\/\\n\\tprotected function getFileIdentifier( PackageInterface $package, $path ) {\\n\\t\\treturn md5( $package->getName() . ':' . $path );\\n\\t}\\n\\n\\t\/**\\n\\t * Returns the path code for the given path.\\n\\t *\\n\\t * @param Filesystem $filesystem The filesystem instance.\\n\\t * @param string     $basePath The base path.\\n\\t * @param string     $vendorPath The vendor path.\\n\\t * @param string     $path The path.\\n\\t *\\n\\t * @return string The path code.\\n\\t *\/\\n\\tprotected function getPathCode( Filesystem $filesystem, $basePath, $vendorPath, $path ) {\\n\\t\\tif ( ! $filesystem->isAbsolutePath( $path ) ) {\\n\\t\\t\\t$path = $basePath . '\/' . $path;\\n\\t\\t}\\n\\t\\t$path = $filesystem->normalizePath( $path );\\n\\n\\t\\t$baseDir = '';\\n\\t\\tif ( 0 === strpos( $path . '\/', $vendorPath . '\/' ) ) {\\n\\t\\t\\t$path    = substr( $path, strlen( $vendorPath ) );\\n\\t\\t\\t$baseDir = '$vendorDir';\\n\\n\\t\\t\\tif ( false !== $path ) {\\n\\t\\t\\t\\t$baseDir .= ' . ';\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t$path = $filesystem->normalizePath( $filesystem->findShortestPath( $basePath, $path, true ) );\\n\\t\\t\\tif ( ! $filesystem->isAbsolutePath( $path ) ) {\\n\\t\\t\\t\\t$baseDir = '$baseDir . ';\\n\\t\\t\\t\\t$path    = '\/' . $path;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( strpos( $path, '.phar' ) !== false ) {\\n\\t\\t\\t$baseDir = \\\"'phar:\/\/' . \\\" . $baseDir;\\n\\t\\t}\\n\\n\\t\\t\/\/ phpcs:ignore WordPress.PHP.DevelopmentFunctions.error_log_var_export\\n\\t\\treturn $baseDir . ( ( false !== $path ) ? var_export( $path, true ) : '' );\\n\\t}\\n\\n\\t\/**\\n\\t * This function differs from the composer parseAutoloadsType in that beside returning the path.\\n\\t * It also return the path and the version of a package.\\n\\t *\\n\\t * Supports PSR-4, PSR-0, and classmap parsing.\\n\\t *\\n\\t * @param array            $packageMap Map of all the packages.\\n\\t * @param string           $type Type of autoloader to use.\\n\\t * @param PackageInterface $mainPackage Instance of the Package Object.\\n\\t *\\n\\t * @return array\\n\\t *\/\\n\\tprotected function parseAutoloadsType( array $packageMap, $type, PackageInterface $mainPackage ) {\\n\\t\\t$autoloads = array();\\n\\n\\t\\tforeach ( $packageMap as $item ) {\\n\\t\\t\\tlist($package, $installPath) = $item;\\n\\t\\t\\t$autoload                    = $package->getAutoload();\\n\\t\\t\\t$version                     = $package->getVersion(); \/\/ Version of the class comes from the package - should we try to parse it?\\n\\n\\t\\t\\t\/\/ Store our own actual package version, not \\\"dev-trunk\\\" or whatever.\\n\\t\\t\\tif ( $package->getName() === 'automattic\/jetpack-autoloader' ) {\\n\\t\\t\\t\\t$version = self::VERSION;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( $package === $mainPackage ) {\\n\\t\\t\\t\\t$autoload = array_merge_recursive( $autoload, $package->getDevAutoload() );\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( null !== $package->getTargetDir() && $package !== $mainPackage ) {\\n\\t\\t\\t\\t$installPath = substr( $installPath, 0, -strlen( '\/' . $package->getTargetDir() ) );\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( in_array( $type, array( 'psr-4', 'psr-0' ), true ) && isset( $autoload[ $type ] ) && is_array( $autoload[ $type ] ) ) {\\n\\t\\t\\t\\tforeach ( $autoload[ $type ] as $namespace => $paths ) {\\n\\t\\t\\t\\t\\t$paths = is_array( $paths ) ? $paths : array( $paths );\\n\\t\\t\\t\\t\\tforeach ( $paths as $path ) {\\n\\t\\t\\t\\t\\t\\t$relativePath              = empty( $installPath ) ? ( empty( $path ) ? '.' : $path ) : $installPath . '\/' . $path;\\n\\t\\t\\t\\t\\t\\t$autoloads[ $namespace ][] = array(\\n\\t\\t\\t\\t\\t\\t\\t'path'    => $relativePath,\\n\\t\\t\\t\\t\\t\\t\\t'version' => $version,\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( 'classmap' === $type && isset( $autoload['classmap'] ) && is_array( $autoload['classmap'] ) ) {\\n\\t\\t\\t\\tforeach ( $autoload['classmap'] as $paths ) {\\n\\t\\t\\t\\t\\t$paths = is_array( $paths ) ? $paths : array( $paths );\\n\\t\\t\\t\\t\\tforeach ( $paths as $path ) {\\n\\t\\t\\t\\t\\t\\t$relativePath = empty( $installPath ) ? ( empty( $path ) ? '.' : $path ) : $installPath . '\/' . $path;\\n\\t\\t\\t\\t\\t\\t$autoloads[]  = array(\\n\\t\\t\\t\\t\\t\\t\\t'path'    => $relativePath,\\n\\t\\t\\t\\t\\t\\t\\t'version' => $version,\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif ( 'files' === $type && isset( $autoload['files'] ) && is_array( $autoload['files'] ) ) {\\n\\t\\t\\t\\tforeach ( $autoload['files'] as $paths ) {\\n\\t\\t\\t\\t\\t$paths = is_array( $paths ) ? $paths : array( $paths );\\n\\t\\t\\t\\t\\tforeach ( $paths as $path ) {\\n\\t\\t\\t\\t\\t\\t$relativePath = empty( $installPath ) ? ( empty( $path ) ? '.' : $path ) : $installPath . '\/' . $path;\\n\\t\\t\\t\\t\\t\\t$autoloads[ $this->getFileIdentifier( $package, $path ) ] = array(\\n\\t\\t\\t\\t\\t\\t\\t'path'    => $relativePath,\\n\\t\\t\\t\\t\\t\\t\\t'version' => $version,\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $autoloads;\\n\\t}\\n\\n\\t\/**\\n\\t * Given Composer's autoloads this will convert them to a version that we can use to generate the manifests.\\n\\t *\\n\\t * When the $scanPsrPackages argument is true, PSR-4 namespaces are converted to classmaps. When $scanPsrPackages\\n\\t * is false, PSR-4 namespaces are not converted to classmaps.\\n\\t *\\n\\t * PSR-0 namespaces are always converted to classmaps.\\n\\t *\\n\\t * @param array  $autoloads The autoloads we want to process.\\n\\t * @param bool   $scanPsrPackages Whether or not PSR-4 packages should be converted to a classmap.\\n\\t * @param string $vendorPath The path to the vendor directory.\\n\\t * @param string $basePath The path to the current directory.\\n\\t *\\n\\t * @return array $processedAutoloads\\n\\t *\/\\n\\tprivate function processAutoloads( $autoloads, $scanPsrPackages, $vendorPath, $basePath ) {\\n\\t\\t$processor = new AutoloadProcessor(\\n\\t\\t\\tfunction ( $path, $excludedClasses, $namespace ) use ( $basePath ) {\\n\\t\\t\\t\\t$dir = $this->filesystem->normalizePath(\\n\\t\\t\\t\\t\\t$this->filesystem->isAbsolutePath( $path ) ? $path : $basePath . '\/' . $path\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\/\/ Composer 2.4 changed the name of the class.\\n\\t\\t\\t\\tif ( class_exists( \\\\Composer\\\\ClassMapGenerator\\\\ClassMapGenerator::class ) ) {\\n\\t\\t\\t\\t\\tif ( ! is_dir( $dir ) && ! is_file( $dir ) ) {\\n\\t\\t\\t\\t\\t\\treturn array();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t$generator = new \\\\Composer\\\\ClassMapGenerator\\\\ClassMapGenerator();\\n\\t\\t\\t\\t\\t$generator->scanPaths( $dir, $excludedClasses, 'classmap', empty( $namespace ) ? null : $namespace );\\n\\t\\t\\t\\t\\treturn $generator->getClassMap()->getMap();\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn \\\\Composer\\\\Autoload\\\\ClassMapGenerator::createMap(\\n\\t\\t\\t\\t\\t$dir,\\n\\t\\t\\t\\t\\t$excludedClasses,\\n\\t\\t\\t\\t\\tnull, \/\/ Don't pass the IOInterface since the normal autoload generation will have reported already.\\n\\t\\t\\t\\t\\tempty( $namespace ) ? null : $namespace\\n\\t\\t\\t\\t);\\n\\t\\t\\t},\\n\\t\\t\\tfunction ( $path ) use ( $basePath, $vendorPath ) {\\n\\t\\t\\t\\treturn $this->getPathCode( $this->filesystem, $basePath, $vendorPath, $path );\\n\\t\\t\\t}\\n\\t\\t);\\n\\n\\t\\treturn array(\\n\\t\\t\\t'psr-4'    => $processor->processPsr4Packages( $autoloads, $scanPsrPackages ),\\n\\t\\t\\t'classmap' => $processor->processClassmap( $autoloads, $scanPsrPackages ),\\n\\t\\t\\t'files'    => $processor->processFiles( $autoloads ),\\n\\t\\t);\\n\\t}\\n\\n\\t\/**\\n\\t * Removes all of the legacy autoloader files so they don't cause any problems.\\n\\t *\\n\\t * @param string $outDir The directory legacy files are written to.\\n\\t *\/\\n\\tprivate function removeLegacyFiles( $outDir ) {\\n\\t\\t$files = array(\\n\\t\\t\\t'autoload_functions.php',\\n\\t\\t\\t'class-autoloader-handler.php',\\n\\t\\t\\t'class-classes-handler.php',\\n\\t\\t\\t'class-files-handler.php',\\n\\t\\t\\t'class-plugins-handler.php',\\n\\t\\t\\t'class-version-selector.php',\\n\\t\\t);\\n\\t\\tforeach ( $files as $file ) {\\n\\t\\t\\t$this->filesystem->remove( $outDir . '\/' . $file );\\n\\t\\t}\\n\\t}\\n\\n\\t\/**\\n\\t * Writes all of the autoloader files to disk.\\n\\t *\\n\\t * @param string $outDir The directory to write to.\\n\\t * @param string $suffix The unique autoloader suffix.\\n\\t *\/\\n\\tprivate function writeAutoloaderFiles( $outDir, $suffix ) {\\n\\t\\t$this->io->writeError( \\\"<info>Generating jetpack autoloader ($outDir)<\/info>\\\" );\\n\\n\\t\\t\/\/ We will remove all autoloader files to generate this again.\\n\\t\\t$this->filesystem->emptyDirectory( $outDir );\\n\\n\\t\\t\/\/ Write the autoloader files.\\n\\t\\tAutoloadFileWriter::copyAutoloaderFiles( $this->io, $outDir, $suffix );\\n\\t}\\n\\n\\t\/**\\n\\t * Writes all of the manifest files to disk.\\n\\t *\\n\\t * @param string $outDir The directory to write to.\\n\\t * @param array  $processedAutoloads The processed autoloads.\\n\\t *\/\\n\\tprivate function writeManifests( $outDir, $processedAutoloads ) {\\n\\t\\t$this->io->writeError( \\\"<info>Generating jetpack autoloader manifests ($outDir)<\/info>\\\" );\\n\\n\\t\\t$manifestFiles = array(\\n\\t\\t\\t'classmap' => 'jetpack_autoload_classmap.php',\\n\\t\\t\\t'psr-4'    => 'jetpack_autoload_psr4.php',\\n\\t\\t\\t'files'    => 'jetpack_autoload_filemap.php',\\n\\t\\t);\\n\\n\\t\\tforeach ( $manifestFiles as $key => $file ) {\\n\\t\\t\\t\/\/ Make sure the file doesn't exist so it isn't there if we don't write it.\\n\\t\\t\\t$this->filesystem->remove( $outDir . '\/' . $file );\\n\\t\\t\\tif ( empty( $processedAutoloads[ $key ] ) ) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$content = ManifestGenerator::buildManifest( $key, $file, $processedAutoloads[ $key ] );\\n\\t\\t\\tif ( empty( $content ) ) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( file_put_contents( $outDir . '\/' . $file, $content ) ) {\\n\\t\\t\\t\\t$this->io->writeError( \\\"  <info>Generated: $file<\/info>\\\" );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t$this->io->writeError( \\\"  <error>Error: $file<\/error>\\\" );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/automattic\/jetpack-autoloader\/src\/autoload.php\",\"ext\":\"php\",\"size\":123,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/* HEADER *\/ \/\/ phpcs:ignore\\n\\nrequire_once __DIR__ . '\/jetpack-autoloader\/class-autoloader.php';\\nAutoloader::init();\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/automattic\/jetpack-autoloader\/src\/class-container.php\",\"ext\":\"php\",\"size\":4719,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/* HEADER *\/ \/\/ phpcs:ignore\\n\\n\/**\\n * This class manages the files and dependencies of the autoloader.\\n *\/\\nclass Container {\\n\\n\\t\/**\\n\\t * Since each autoloader's class files exist within their own namespace we need a map to\\n\\t * convert between the local class and a shared key. Note that no version checking is\\n\\t * performed on these dependencies and the first autoloader to register will be the\\n\\t * one that is utilized.\\n\\t *\/\\n\\tconst SHARED_DEPENDENCY_KEYS = array(\\n\\t\\tHook_Manager::class => 'Hook_Manager',\\n\\t);\\n\\n\\t\/**\\n\\t * A map of all the dependencies we've registered with the container and created.\\n\\t *\\n\\t * @var array\\n\\t *\/\\n\\tprotected $dependencies;\\n\\n\\t\/**\\n\\t * The constructor.\\n\\t *\/\\n\\tpublic function __construct() {\\n\\t\\t$this->dependencies = array();\\n\\n\\t\\t$this->register_shared_dependencies();\\n\\t\\t$this->register_dependencies();\\n\\t\\t$this->initialize_globals();\\n\\t}\\n\\n\\t\/**\\n\\t * Gets a dependency out of the container.\\n\\t *\\n\\t * @param string $class The class to fetch.\\n\\t *\\n\\t * @return mixed\\n\\t * @throws \\\\InvalidArgumentException When a class that isn't registered with the container is fetched.\\n\\t *\/\\n\\tpublic function get( $class ) {\\n\\t\\tif ( ! isset( $this->dependencies[ $class ] ) ) {\\n\\t\\t\\tthrow new \\\\InvalidArgumentException( \\\"Class '$class' is not registered with the container.\\\" );\\n\\t\\t}\\n\\n\\t\\treturn $this->dependencies[ $class ];\\n\\t}\\n\\n\\t\/**\\n\\t * Registers all of the dependencies that are shared between all instances of the autoloader.\\n\\t *\/\\n\\tprivate function register_shared_dependencies() {\\n\\t\\tglobal $jetpack_autoloader_container_shared;\\n\\t\\tif ( ! isset( $jetpack_autoloader_container_shared ) ) {\\n\\t\\t\\t$jetpack_autoloader_container_shared = array();\\n\\t\\t}\\n\\n\\t\\t$key = self::SHARED_DEPENDENCY_KEYS[ Hook_Manager::class ];\\n\\t\\tif ( ! isset( $jetpack_autoloader_container_shared[ $key ] ) ) {\\n\\t\\t\\trequire_once __DIR__ . '\/class-hook-manager.php';\\n\\t\\t\\t$jetpack_autoloader_container_shared[ $key ] = new Hook_Manager();\\n\\t\\t}\\n\\t\\t$this->dependencies[ Hook_Manager::class ] = &$jetpack_autoloader_container_shared[ $key ];\\n\\t}\\n\\n\\t\/**\\n\\t * Registers all of the dependencies with the container.\\n\\t *\/\\n\\tprivate function register_dependencies() {\\n\\t\\trequire_once __DIR__ . '\/class-path-processor.php';\\n\\t\\t$this->dependencies[ Path_Processor::class ] = new Path_Processor();\\n\\n\\t\\trequire_once __DIR__ . '\/class-plugin-locator.php';\\n\\t\\t$this->dependencies[ Plugin_Locator::class ] = new Plugin_Locator(\\n\\t\\t\\t$this->get( Path_Processor::class )\\n\\t\\t);\\n\\n\\t\\trequire_once __DIR__ . '\/class-version-selector.php';\\n\\t\\t$this->dependencies[ Version_Selector::class ] = new Version_Selector();\\n\\n\\t\\trequire_once __DIR__ . '\/class-autoloader-locator.php';\\n\\t\\t$this->dependencies[ Autoloader_Locator::class ] = new Autoloader_Locator(\\n\\t\\t\\t$this->get( Version_Selector::class )\\n\\t\\t);\\n\\n\\t\\trequire_once __DIR__ . '\/class-php-autoloader.php';\\n\\t\\t$this->dependencies[ PHP_Autoloader::class ] = new PHP_Autoloader();\\n\\n\\t\\trequire_once __DIR__ . '\/class-manifest-reader.php';\\n\\t\\t$this->dependencies[ Manifest_Reader::class ] = new Manifest_Reader(\\n\\t\\t\\t$this->get( Version_Selector::class )\\n\\t\\t);\\n\\n\\t\\trequire_once __DIR__ . '\/class-plugins-handler.php';\\n\\t\\t$this->dependencies[ Plugins_Handler::class ] = new Plugins_Handler(\\n\\t\\t\\t$this->get( Plugin_Locator::class ),\\n\\t\\t\\t$this->get( Path_Processor::class )\\n\\t\\t);\\n\\n\\t\\trequire_once __DIR__ . '\/class-autoloader-handler.php';\\n\\t\\t$this->dependencies[ Autoloader_Handler::class ] = new Autoloader_Handler(\\n\\t\\t\\t$this->get( PHP_Autoloader::class ),\\n\\t\\t\\t$this->get( Hook_Manager::class ),\\n\\t\\t\\t$this->get( Manifest_Reader::class ),\\n\\t\\t\\t$this->get( Version_Selector::class )\\n\\t\\t);\\n\\n\\t\\trequire_once __DIR__ . '\/class-latest-autoloader-guard.php';\\n\\t\\t$this->dependencies[ Latest_Autoloader_Guard::class ] = new Latest_Autoloader_Guard(\\n\\t\\t\\t$this->get( Plugins_Handler::class ),\\n\\t\\t\\t$this->get( Autoloader_Handler::class ),\\n\\t\\t\\t$this->get( Autoloader_Locator::class )\\n\\t\\t);\\n\\n\\t\\t\/\/ Register any classes that we will use elsewhere.\\n\\t\\trequire_once __DIR__ . '\/class-version-loader.php';\\n\\t\\trequire_once __DIR__ . '\/class-shutdown-handler.php';\\n\\t}\\n\\n\\t\/**\\n\\t * Initializes any of the globals needed by the autoloader.\\n\\t *\/\\n\\tprivate function initialize_globals() {\\n\\t\\t\/*\\n\\t\\t * This global was retired in version 2.9. The value is set to 'false' to maintain\\n\\t\\t * compatibility with older versions of the autoloader.\\n\\t\\t *\/\\n\\t\\tglobal $jetpack_autoloader_including_latest;\\n\\t\\t$jetpack_autoloader_including_latest = false;\\n\\n\\t\\t\/\/ Not all plugins can be found using the locator. In cases where a plugin loads the autoloader\\n\\t\\t\/\/ but was not discoverable, we will record them in this array to track them as \\\"active\\\".\\n\\t\\tglobal $jetpack_autoloader_activating_plugins_paths;\\n\\t\\tif ( ! isset( $jetpack_autoloader_activating_plugins_paths ) ) {\\n\\t\\t\\t$jetpack_autoloader_activating_plugins_paths = array();\\n\\t\\t}\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/automattic\/jetpack-autoloader\/src\/class-plugin-locator.php\",\"ext\":\"php\",\"size\":4426,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/* HEADER *\/ \/\/ phpcs:ignore\\n\\n\/**\\n * This class scans the WordPress installation to find active plugins.\\n *\/\\nclass Plugin_Locator {\\n\\n\\t\/**\\n\\t * The path processor for finding plugin paths.\\n\\t *\\n\\t * @var Path_Processor\\n\\t *\/\\n\\tprivate $path_processor;\\n\\n\\t\/**\\n\\t * The constructor.\\n\\t *\\n\\t * @param Path_Processor $path_processor The Path_Processor instance.\\n\\t *\/\\n\\tpublic function __construct( $path_processor ) {\\n\\t\\t$this->path_processor = $path_processor;\\n\\t}\\n\\n\\t\/**\\n\\t * Finds the path to the current plugin.\\n\\t *\\n\\t * @return string $path The path to the current plugin.\\n\\t *\\n\\t * @throws \\\\RuntimeException If the current plugin does not have an autoloader.\\n\\t *\/\\n\\tpublic function find_current_plugin() {\\n\\t\\t\/\/ Escape from `vendor\/__DIR__` to root plugin directory.\\n\\t\\t$plugin_directory = dirname( __DIR__, 2 );\\n\\n\\t\\t\/\/ Use the path processor to ensure that this is an autoloader we're referencing.\\n\\t\\t$path = $this->path_processor->find_directory_with_autoloader( $plugin_directory, array() );\\n\\t\\tif ( false === $path ) {\\n\\t\\t\\tthrow new \\\\RuntimeException( 'Failed to locate plugin ' . $plugin_directory );\\n\\t\\t}\\n\\n\\t\\treturn $path;\\n\\t}\\n\\n\\t\/**\\n\\t * Checks a given option for plugin paths.\\n\\t *\\n\\t * @param string $option_name  The option that we want to check for plugin information.\\n\\t * @param bool   $site_option  Indicates whether or not we want to check the site option.\\n\\t *\\n\\t * @return array $plugin_paths The list of absolute paths we've found.\\n\\t *\/\\n\\tpublic function find_using_option( $option_name, $site_option = false ) {\\n\\t\\t$raw = $site_option ? get_site_option( $option_name ) : get_option( $option_name );\\n\\t\\tif ( false === $raw ) {\\n\\t\\t\\treturn array();\\n\\t\\t}\\n\\n\\t\\treturn $this->convert_plugins_to_paths( $raw );\\n\\t}\\n\\n\\t\/**\\n\\t * Checks for plugins in the `action` request parameter.\\n\\t *\\n\\t * @param string[] $allowed_actions The actions that we're allowed to return plugins for.\\n\\t *\\n\\t * @return array $plugin_paths The list of absolute paths we've found.\\n\\t *\/\\n\\tpublic function find_using_request_action( $allowed_actions ) {\\n\\t\\t\/**\\n\\t\\t * Note: we're not actually checking the nonce here because it's too early\\n\\t\\t * in the execution. The pluggable functions are not yet loaded to give\\n\\t\\t * plugins a chance to plug their versions. Therefore we're doing the bare\\n\\t\\t * minimum: checking whether the nonce exists and it's in the right place.\\n\\t\\t * The request will fail later if the nonce doesn't pass the check.\\n\\t\\t *\/\\n\\t\\tif ( empty( $_REQUEST['_wpnonce'] ) ) {\\n\\t\\t\\treturn array();\\n\\t\\t}\\n\\n\\t\\t\/\/ phpcs:ignore WordPress.Security.ValidatedSanitizedInput.InputNotSanitized -- Validated just below.\\n\\t\\t$action = isset( $_REQUEST['action'] ) ? wp_unslash( $_REQUEST['action'] ) : false;\\n\\t\\tif ( ! in_array( $action, $allowed_actions, true ) ) {\\n\\t\\t\\treturn array();\\n\\t\\t}\\n\\n\\t\\t$plugin_slugs = array();\\n\\t\\tswitch ( $action ) {\\n\\t\\t\\tcase 'activate':\\n\\t\\t\\tcase 'deactivate':\\n\\t\\t\\t\\tif ( empty( $_REQUEST['plugin'] ) ) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\/\/ phpcs:ignore WordPress.Security.ValidatedSanitizedInput.InputNotSanitized -- Validated by convert_plugins_to_paths.\\n\\t\\t\\t\\t$plugin_slugs[] = wp_unslash( $_REQUEST['plugin'] );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 'activate-selected':\\n\\t\\t\\tcase 'deactivate-selected':\\n\\t\\t\\t\\tif ( empty( $_REQUEST['checked'] ) ) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\/\/ phpcs:ignore WordPress.Security.ValidatedSanitizedInput.InputNotSanitized -- Validated by convert_plugins_to_paths.\\n\\t\\t\\t\\t$plugin_slugs = wp_unslash( $_REQUEST['checked'] );\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\treturn $this->convert_plugins_to_paths( $plugin_slugs );\\n\\t}\\n\\n\\t\/**\\n\\t * Given an array of plugin slugs or paths, this will convert them to absolute paths and filter\\n\\t * out the plugins that are not directory plugins. Note that array keys will also be included\\n\\t * if they are plugin paths!\\n\\t *\\n\\t * @param string[] $plugins Plugin paths or slugs to filter.\\n\\t *\\n\\t * @return string[]\\n\\t *\/\\n\\tprivate function convert_plugins_to_paths( $plugins ) {\\n\\t\\tif ( ! is_array( $plugins ) || empty( $plugins ) ) {\\n\\t\\t\\treturn array();\\n\\t\\t}\\n\\n\\t\\t\/\/ We're going to look for plugins in the standard directories.\\n\\t\\t$path_constants = array( WP_PLUGIN_DIR, WPMU_PLUGIN_DIR );\\n\\n\\t\\t$plugin_paths = array();\\n\\t\\tforeach ( $plugins as $key => $value ) {\\n\\t\\t\\t$path = $this->path_processor->find_directory_with_autoloader( $key, $path_constants );\\n\\t\\t\\tif ( $path ) {\\n\\t\\t\\t\\t$plugin_paths[] = $path;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$path = $this->path_processor->find_directory_with_autoloader( $value, $path_constants );\\n\\t\\t\\tif ( $path ) {\\n\\t\\t\\t\\t$plugin_paths[] = $path;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $plugin_paths;\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/automattic\/jetpack-autoloader\/src\/class-manifest-reader.php\",\"ext\":\"php\",\"size\":2491,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/* HEADER *\/ \/\/ phpcs:ignore\\n\\n\/**\\n * This class reads autoloader manifest files.\\n *\/\\nclass Manifest_Reader {\\n\\n\\t\/**\\n\\t * The Version_Selector object.\\n\\t *\\n\\t * @var Version_Selector\\n\\t *\/\\n\\tprivate $version_selector;\\n\\n\\t\/**\\n\\t * The constructor.\\n\\t *\\n\\t * @param Version_Selector $version_selector The Version_Selector object.\\n\\t *\/\\n\\tpublic function __construct( $version_selector ) {\\n\\t\\t$this->version_selector = $version_selector;\\n\\t}\\n\\n\\t\/**\\n\\t * Reads all of the manifests in the given plugin paths.\\n\\t *\\n\\t * @param array  $plugin_paths  The paths to the plugins we're loading the manifest in.\\n\\t * @param string $manifest_path The path that we're loading the manifest from in each plugin.\\n\\t * @param array  $path_map The path map to add the contents of the manifests to.\\n\\t *\\n\\t * @return array $path_map The path map we've built using the manifests in each plugin.\\n\\t *\/\\n\\tpublic function read_manifests( $plugin_paths, $manifest_path, &$path_map ) {\\n\\t\\t$file_paths = array_map(\\n\\t\\t\\tfunction ( $path ) use ( $manifest_path ) {\\n\\t\\t\\t\\treturn trailingslashit( $path ) . $manifest_path;\\n\\t\\t\\t},\\n\\t\\t\\t$plugin_paths\\n\\t\\t);\\n\\n\\t\\tforeach ( $file_paths as $path ) {\\n\\t\\t\\t$this->register_manifest( $path, $path_map );\\n\\t\\t}\\n\\n\\t\\treturn $path_map;\\n\\t}\\n\\n\\t\/**\\n\\t * Registers a plugin's manifest file with the path map.\\n\\t *\\n\\t * @param string $manifest_path The absolute path to the manifest that we're loading.\\n\\t * @param array  $path_map The path map to add the contents of the manifest to.\\n\\t *\/\\n\\tprotected function register_manifest( $manifest_path, &$path_map ) {\\n\\t\\tif ( ! is_readable( $manifest_path ) ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t$manifest = require $manifest_path;\\n\\t\\tif ( ! is_array( $manifest ) ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tforeach ( $manifest as $key => $data ) {\\n\\t\\t\\t$this->register_record( $key, $data, $path_map );\\n\\t\\t}\\n\\t}\\n\\n\\t\/**\\n\\t * Registers an entry from the manifest in the path map.\\n\\t *\\n\\t * @param string $key The identifier for the entry we're registering.\\n\\t * @param array  $data The data for the entry we're registering.\\n\\t * @param array  $path_map The path map to add the contents of the manifest to.\\n\\t *\/\\n\\tprotected function register_record( $key, $data, &$path_map ) {\\n\\t\\tif ( isset( $path_map[ $key ]['version'] ) ) {\\n\\t\\t\\t$selected_version = $path_map[ $key ]['version'];\\n\\t\\t} else {\\n\\t\\t\\t$selected_version = null;\\n\\t\\t}\\n\\n\\t\\tif ( $this->version_selector->is_version_update_required( $selected_version, $data['version'] ) ) {\\n\\t\\t\\t$path_map[ $key ] = array(\\n\\t\\t\\t\\t'version' => $data['version'],\\n\\t\\t\\t\\t'path'    => $data['path'],\\n\\t\\t\\t);\\n\\t\\t}\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/automattic\/jetpack-autoloader\/src\/class-plugins-handler.php\",\"ext\":\"php\",\"size\":5689,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/* HEADER *\/ \/\/ phpcs:ignore\\n\\n\/**\\n * This class handles locating and caching all of the active plugins.\\n *\/\\nclass Plugins_Handler {\\n\\t\/**\\n\\t * The transient key for plugin paths.\\n\\t *\/\\n\\tconst TRANSIENT_KEY = 'jetpack_autoloader_plugin_paths';\\n\\n\\t\/**\\n\\t * The locator for finding plugins in different locations.\\n\\t *\\n\\t * @var Plugin_Locator\\n\\t *\/\\n\\tprivate $plugin_locator;\\n\\n\\t\/**\\n\\t * The processor for transforming cached paths.\\n\\t *\\n\\t * @var Path_Processor\\n\\t *\/\\n\\tprivate $path_processor;\\n\\n\\t\/**\\n\\t * The constructor.\\n\\t *\\n\\t * @param Plugin_Locator $plugin_locator The locator for finding active plugins.\\n\\t * @param Path_Processor $path_processor The processor for transforming cached paths.\\n\\t *\/\\n\\tpublic function __construct( $plugin_locator, $path_processor ) {\\n\\t\\t$this->plugin_locator = $plugin_locator;\\n\\t\\t$this->path_processor = $path_processor;\\n\\t}\\n\\n\\t\/**\\n\\t * Gets all of the active plugins we can find.\\n\\t *\\n\\t * @param bool $include_deactivating When true, plugins deactivating this request will be considered active.\\n\\t * @param bool $record_unknown When true, the current plugin will be marked as active and recorded when unknown.\\n\\t *\\n\\t * @return string[]\\n\\t *\/\\n\\tpublic function get_active_plugins( $include_deactivating, $record_unknown ) {\\n\\t\\tglobal $jetpack_autoloader_activating_plugins_paths;\\n\\n\\t\\t\/\/ We're going to build a unique list of plugins from a few different sources\\n\\t\\t\/\/ to find all of our \\\"active\\\" plugins. While we need to return an integer\\n\\t\\t\/\/ array, we're going to use an associative array internally to reduce\\n\\t\\t\/\/ the amount of time that we're going to spend checking uniqueness\\n\\t\\t\/\/ and merging different arrays together to form the output.\\n\\t\\t$active_plugins = array();\\n\\n\\t\\t\/\/ Make sure that plugins which have activated this request are considered as \\\"active\\\" even though\\n\\t\\t\/\/ they probably won't be present in any option.\\n\\t\\tif ( is_array( $jetpack_autoloader_activating_plugins_paths ) ) {\\n\\t\\t\\tforeach ( $jetpack_autoloader_activating_plugins_paths as $path ) {\\n\\t\\t\\t\\t$active_plugins[ $path ] = $path;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t\/\/ This option contains all of the plugins that have been activated.\\n\\t\\t$plugins = $this->plugin_locator->find_using_option( 'active_plugins' );\\n\\t\\tforeach ( $plugins as $path ) {\\n\\t\\t\\t$active_plugins[ $path ] = $path;\\n\\t\\t}\\n\\n\\t\\t\/\/ This option contains all of the multisite plugins that have been activated.\\n\\t\\tif ( is_multisite() ) {\\n\\t\\t\\t$plugins = $this->plugin_locator->find_using_option( 'active_sitewide_plugins', true );\\n\\t\\t\\tforeach ( $plugins as $path ) {\\n\\t\\t\\t\\t$active_plugins[ $path ] = $path;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t\/\/ These actions contain plugins that are being activated\/deactivated during this request.\\n\\t\\t$plugins = $this->plugin_locator->find_using_request_action( array( 'activate', 'activate-selected', 'deactivate', 'deactivate-selected' ) );\\n\\t\\tforeach ( $plugins as $path ) {\\n\\t\\t\\t$active_plugins[ $path ] = $path;\\n\\t\\t}\\n\\n\\t\\t\/\/ When the current plugin isn't considered \\\"active\\\" there's a problem.\\n\\t\\t\/\/ Since we're here, the plugin is active and currently being loaded.\\n\\t\\t\/\/ We can support this case (mu-plugins and non-standard activation)\\n\\t\\t\/\/ by adding the current plugin to the active list and marking it\\n\\t\\t\/\/ as an unknown (activating) plugin. This also has the benefit\\n\\t\\t\/\/ of causing a reset because the active plugins list has\\n\\t\\t\/\/ been changed since it was saved in the global.\\n\\t\\t$current_plugin = $this->plugin_locator->find_current_plugin();\\n\\t\\tif ( $record_unknown && ! in_array( $current_plugin, $active_plugins, true ) ) {\\n\\t\\t\\t$active_plugins[ $current_plugin ]             = $current_plugin;\\n\\t\\t\\t$jetpack_autoloader_activating_plugins_paths[] = $current_plugin;\\n\\t\\t}\\n\\n\\t\\t\/\/ When deactivating plugins aren't desired we should entirely remove them from the active list.\\n\\t\\tif ( ! $include_deactivating ) {\\n\\t\\t\\t\/\/ These actions contain plugins that are being deactivated during this request.\\n\\t\\t\\t$plugins = $this->plugin_locator->find_using_request_action( array( 'deactivate', 'deactivate-selected' ) );\\n\\t\\t\\tforeach ( $plugins as $path ) {\\n\\t\\t\\t\\tunset( $active_plugins[ $path ] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t\/\/ Transform the array so that we don't have to worry about the keys interacting with other array types later.\\n\\t\\treturn array_values( $active_plugins );\\n\\t}\\n\\n\\t\/**\\n\\t * Gets all of the cached plugins if there are any.\\n\\t *\\n\\t * @return string[]\\n\\t *\/\\n\\tpublic function get_cached_plugins() {\\n\\t\\t$cached = get_transient( self::TRANSIENT_KEY );\\n\\t\\tif ( ! is_array( $cached ) || empty( $cached ) ) {\\n\\t\\t\\treturn array();\\n\\t\\t}\\n\\n\\t\\t\/\/ We need to expand the tokens to an absolute path for this webserver.\\n\\t\\treturn array_map( array( $this->path_processor, 'untokenize_path_constants' ), $cached );\\n\\t}\\n\\n\\t\/**\\n\\t * Saves the plugin list to the cache.\\n\\t *\\n\\t * @param array $plugins The plugin list to save to the cache.\\n\\t *\/\\n\\tpublic function cache_plugins( $plugins ) {\\n\\t\\t\/\/ We store the paths in a tokenized form so that that webservers with different absolute paths don't break.\\n\\t\\t$plugins = array_map( array( $this->path_processor, 'tokenize_path_constants' ), $plugins );\\n\\n\\t\\tset_transient( self::TRANSIENT_KEY, $plugins );\\n\\t}\\n\\n\\t\/**\\n\\t * Checks to see whether or not the plugin list given has changed when compared to the\\n\\t * shared `$jetpack_autoloader_cached_plugin_paths` global. This allows us to deal\\n\\t * with cases where the active list may change due to filtering..\\n\\t *\\n\\t * @param string[] $plugins The plugins list to check against the global cache.\\n\\t *\\n\\t * @return bool True if the plugins have changed, otherwise false.\\n\\t *\/\\n\\tpublic function have_plugins_changed( $plugins ) {\\n\\t\\tglobal $jetpack_autoloader_cached_plugin_paths;\\n\\n\\t\\tif ( $jetpack_autoloader_cached_plugin_paths !== $plugins ) {\\n\\t\\t\\t$jetpack_autoloader_cached_plugin_paths = $plugins;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/automattic\/jetpack-autoloader\/src\/class-version-selector.php\",\"ext\":\"php\",\"size\":1651,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/* HEADER *\/ \/\/ phpcs:ignore\\n\\n\/**\\n * Used to select package versions.\\n *\/\\nclass Version_Selector {\\n\\n\\t\/**\\n\\t * Checks whether the selected package version should be updated. Composer development\\n\\t * package versions ('9999999-dev' or versions that start with 'dev-') are favored\\n\\t * when the JETPACK_AUTOLOAD_DEV constant is set to true.\\n\\t *\\n\\t * @param String $selected_version The currently selected package version.\\n\\t * @param String $compare_version The package version that is being evaluated to\\n\\t *                                determine if the version needs to be updated.\\n\\t *\\n\\t * @return bool Returns true if the selected package version should be updated,\\n\\t *                 else false.\\n\\t *\/\\n\\tpublic function is_version_update_required( $selected_version, $compare_version ) {\\n\\t\\t$use_dev_versions = defined( 'JETPACK_AUTOLOAD_DEV' ) && JETPACK_AUTOLOAD_DEV;\\n\\n\\t\\tif ( $selected_version === null ) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tif ( $use_dev_versions && $this->is_dev_version( $selected_version ) ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tif ( $this->is_dev_version( $compare_version ) ) {\\n\\t\\t\\tif ( $use_dev_versions ) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( version_compare( $selected_version, $compare_version, '<' ) ) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\t\/**\\n\\t * Checks whether the given package version is a development version.\\n\\t *\\n\\t * @param String $version The package version.\\n\\t *\\n\\t * @return bool True if the version is a dev version, else false.\\n\\t *\/\\n\\tpublic function is_dev_version( $version ) {\\n\\t\\tif ( 'dev-' === substr( $version, 0, 4 ) || '9999999-dev' === $version ) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/automattic\/jetpack-autoloader\/src\/class-php-autoloader.php\",\"ext\":\"php\",\"size\":3483,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/* HEADER *\/ \/\/ phpcs:ignore\\n\\n\/**\\n * This class handles management of the actual PHP autoloader.\\n *\/\\nclass PHP_Autoloader {\\n\\n\\t\/**\\n\\t * Registers the autoloader with PHP so that it can begin autoloading classes.\\n\\t *\\n\\t * @param Version_Loader $version_loader The class loader to use in the autoloader.\\n\\t *\/\\n\\tpublic function register_autoloader( $version_loader ) {\\n\\t\\t\/\/ Make sure no other autoloaders are registered.\\n\\t\\t$this->unregister_autoloader();\\n\\n\\t\\t\/\/ Set the global so that it can be used to load classes.\\n\\t\\tglobal $jetpack_autoloader_loader;\\n\\t\\t$jetpack_autoloader_loader = $version_loader;\\n\\n\\t\\t\/\/ Ensure that the autoloader is first to avoid contention with others.\\n\\t\\tspl_autoload_register( array( self::class, 'load_class' ), true, true );\\n\\t}\\n\\n\\t\/**\\n\\t * Unregisters the active autoloader so that it will no longer autoload classes.\\n\\t *\/\\n\\tpublic function unregister_autoloader() {\\n\\t\\t\/\/ Remove any v2 autoloader that we've already registered.\\n\\t\\t$autoload_chain = spl_autoload_functions();\\n\\t\\tif ( ! $autoload_chain ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tforeach ( $autoload_chain as $autoloader ) {\\n\\t\\t\\t\/\/ We can identify a v2 autoloader using the namespace.\\n\\t\\t\\t$namespace_check = null;\\n\\n\\t\\t\\t\/\/ Functions are recorded as strings.\\n\\t\\t\\tif ( is_string( $autoloader ) ) {\\n\\t\\t\\t\\t$namespace_check = $autoloader;\\n\\t\\t\\t} elseif ( is_array( $autoloader ) && is_string( $autoloader[0] ) ) {\\n\\t\\t\\t\\t\/\/ Static method calls have the class as the first array element.\\n\\t\\t\\t\\t$namespace_check = $autoloader[0];\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t\/\/ Since the autoloader has only ever been a function or a static method we don't currently need to check anything else.\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t\/\/ Check for the namespace without the generated suffix.\\n\\t\\t\\tif ( 'Automattic\\\\\\\\Jetpack\\\\\\\\Autoloader\\\\\\\\jp' === substr( $namespace_check, 0, 32 ) ) {\\n\\t\\t\\t\\tspl_autoload_unregister( $autoloader );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t\/\/ Clear the global now that the autoloader has been unregistered.\\n\\t\\tglobal $jetpack_autoloader_loader;\\n\\t\\t$jetpack_autoloader_loader = null;\\n\\t}\\n\\n\\t\/**\\n\\t * Loads a class file if one could be found.\\n\\t *\\n\\t * Note: This function is static so that the autoloader can be easily unregistered. If\\n\\t * it was a class method we would have to unwrap the object to check the namespace.\\n\\t *\\n\\t * @param string $class_name The name of the class to autoload.\\n\\t *\\n\\t * @return bool Indicates whether or not a class file was loaded.\\n\\t *\/\\n\\tpublic static function load_class( $class_name ) {\\n\\t\\tglobal $jetpack_autoloader_loader;\\n\\t\\tif ( ! isset( $jetpack_autoloader_loader ) ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t$file = $jetpack_autoloader_loader->find_class_file( $class_name );\\n\\t\\tif ( ! isset( $file ) ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t\/\/ A common source of strange and confusing problems is when a vendor\\n\\t\\t\/\/ file is autoloaded before all plugins have had a chance to register\\n\\t\\t\/\/ with the autoloader. Detect that, if a development constant is set.\\n\\t\\tif ( defined( 'JETPACK_AUTOLOAD_DEBUG_EARLY_LOADS' ) && JETPACK_AUTOLOAD_DEBUG_EARLY_LOADS &&\\n\\t\\t\\t( strpos( $file, '\/vendor\/' ) !== false || strpos( $file, '\/jetpack_vendor\/' ) !== false ) &&\\n\\t\\t\\tis_callable( 'did_action' ) && ! did_action( 'plugins_loaded' )\\n\\t\\t) {\\n\\t\\t\\t\/\/ phpcs:ignore WordPress.PHP.DevelopmentFunctions.error_log_wp_debug_backtrace_summary -- This is a debug log message.\\n\\t\\t\\t$msg = \\\"Jetpack Autoloader: Autoloading `$class_name` before the plugins_loaded hook may cause strange and confusing problems. \\\" . wp_debug_backtrace_summary( '', 1 );\\n\\t\\t\\twp_trigger_error( '', $msg );\\n\\t\\t}\\n\\n\\t\\trequire $file;\\n\\t\\treturn true;\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/automattic\/jetpack-autoloader\/src\/CustomAutoloaderPlugin.php\",\"ext\":\"php\",\"size\":5728,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Custom Autoloader Composer Plugin, hooks into composer events to generate the custom autoloader.\\n *\\n * @package automattic\/jetpack-autoloader\\n *\/\\n\\nnamespace Automattic\\\\Jetpack\\\\Autoloader;\\n\\nuse Composer\\\\Composer;\\nuse Composer\\\\EventDispatcher\\\\EventSubscriberInterface;\\nuse Composer\\\\IO\\\\IOInterface;\\nuse Composer\\\\Plugin\\\\PluginInterface;\\nuse Composer\\\\Script\\\\Event;\\nuse Composer\\\\Script\\\\ScriptEvents;\\n\\n\/**\\n * Class CustomAutoloaderPlugin.\\n *\\n * @package automattic\/jetpack-autoloader\\n *\/\\nclass CustomAutoloaderPlugin implements PluginInterface, EventSubscriberInterface {\\n\\n\\t\/**\\n\\t * IO object.\\n\\t *\\n\\t * @var IOInterface IO object.\\n\\t *\/\\n\\tprivate $io;\\n\\n\\t\/**\\n\\t * Composer object.\\n\\t *\\n\\t * @var Composer Composer object.\\n\\t *\/\\n\\tprivate $composer;\\n\\n\\t\/**\\n\\t * Do nothing.\\n\\t *\\n\\t * @param Composer    $composer Composer object.\\n\\t * @param IOInterface $io IO object.\\n\\t *\/\\n\\tpublic function activate( Composer $composer, IOInterface $io ) { \/\/ phpcs:ignore VariableAnalysis.CodeAnalysis.VariableAnalysis.UnusedVariable\\n\\t\\t$this->composer = $composer;\\n\\t\\t$this->io       = $io;\\n\\t}\\n\\n\\t\/**\\n\\t * Do nothing.\\n\\t * phpcs:disable VariableAnalysis.CodeAnalysis.VariableAnalysis.UnusedVariable\\n\\t *\\n\\t * @param Composer    $composer Composer object.\\n\\t * @param IOInterface $io IO object.\\n\\t *\/\\n\\tpublic function deactivate( Composer $composer, IOInterface $io ) {\\n\\t\\t\/*\\n\\t\\t * Intentionally left empty. This is a PluginInterface method.\\n\\t\\t * phpcs:enable VariableAnalysis.CodeAnalysis.VariableAnalysis.UnusedVariable\\n\\t\\t *\/\\n\\t}\\n\\n\\t\/**\\n\\t * Do nothing.\\n\\t * phpcs:disable VariableAnalysis.CodeAnalysis.VariableAnalysis.UnusedVariable\\n\\t *\\n\\t * @param Composer    $composer Composer object.\\n\\t * @param IOInterface $io IO object.\\n\\t *\/\\n\\tpublic function uninstall( Composer $composer, IOInterface $io ) {\\n\\t\\t\/*\\n\\t\\t * Intentionally left empty. This is a PluginInterface method.\\n\\t\\t * phpcs:enable VariableAnalysis.CodeAnalysis.VariableAnalysis.UnusedVariable\\n\\t\\t *\/\\n\\t}\\n\\n\\t\/**\\n\\t * Tell composer to listen for events and do something with them.\\n\\t *\\n\\t * @return array List of subscribed events.\\n\\t *\/\\n\\tpublic static function getSubscribedEvents() {\\n\\t\\treturn array(\\n\\t\\t\\tScriptEvents::POST_AUTOLOAD_DUMP => 'postAutoloadDump',\\n\\t\\t);\\n\\t}\\n\\n\\t\/**\\n\\t * Generate the custom autolaoder.\\n\\t *\\n\\t * @param Event $event Script event object.\\n\\t *\/\\n\\tpublic function postAutoloadDump( Event $event ) {\\n\\t\\t\/\/ When the autoloader is not required by the root package we don't want to execute it.\\n\\t\\t\/\/ This prevents unwanted transitive execution that generates unused autoloaders or\\n\\t\\t\/\/ at worst throws fatal executions.\\n\\t\\tif ( ! $this->isRequiredByRoot() ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t$config = $this->composer->getConfig();\\n\\n\\t\\tif ( 'vendor' !== $config->raw()['config']['vendor-dir'] ) {\\n\\t\\t\\t$this->io->writeError( \\\"\\\\n<error>An error occurred while generating the autoloader files:\\\", true );\\n\\t\\t\\t$this->io->writeError( 'The project\\\\'s composer.json or composer environment set a non-default vendor directory.', true );\\n\\t\\t\\t$this->io->writeError( 'The default composer vendor directory must be used.<\/error>', true );\\n\\t\\t\\texit( 0 );\\n\\t\\t}\\n\\n\\t\\t$installationManager = $this->composer->getInstallationManager();\\n\\t\\t$repoManager         = $this->composer->getRepositoryManager();\\n\\t\\t$localRepo           = $repoManager->getLocalRepository();\\n\\t\\t$package             = $this->composer->getPackage();\\n\\t\\t$optimize            = $event->getFlags()['optimize'];\\n\\t\\t$suffix              = $this->determineSuffix();\\n\\n\\t\\t$generator = new AutoloadGenerator( $this->io );\\n\\t\\t$generator->dump( $this->composer, $config, $localRepo, $package, $installationManager, 'composer', $optimize, $suffix );\\n\\t}\\n\\n\\t\/**\\n\\t * Determine the suffix for the autoloader class.\\n\\t *\\n\\t * Reuses an existing suffix from vendor\/autoload_packages.php or vendor\/autoload.php if possible.\\n\\t *\\n\\t * @return string Suffix.\\n\\t *\/\\n\\tprivate function determineSuffix() {\\n\\t\\t$config     = $this->composer->getConfig();\\n\\t\\t$vendorPath = $config->get( 'vendor-dir' );\\n\\n\\t\\t\/\/ Command line.\\n\\t\\t$suffix = $config->get( 'autoloader-suffix' );\\n\\t\\tif ( $suffix ) {\\n\\t\\t\\treturn $suffix;\\n\\t\\t}\\n\\n\\t\\t\/\/ Reuse our own suffix, if any.\\n\\t\\tif ( is_readable( $vendorPath . '\/autoload_packages.php' ) ) {\\n\\t\\t\\t$content = file_get_contents( $vendorPath . '\/autoload_packages.php' );\\n\\t\\t\\tif ( preg_match( '\/^namespace Automattic\\\\\\\\\\\\\\\\Jetpack\\\\\\\\\\\\\\\\Autoloader\\\\\\\\\\\\\\\\jp([^;\\\\s]+?)(?:\\\\\\\\\\\\\\\\al[^;\\\\s]+)?;\/m', $content, $match ) ) {\\n\\t\\t\\t\\treturn $match[1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t\/\/ Reuse Composer's suffix, if any.\\n\\t\\tif ( is_readable( $vendorPath . '\/autoload.php' ) ) {\\n\\t\\t\\t$content = file_get_contents( $vendorPath . '\/autoload.php' );\\n\\t\\t\\tif ( preg_match( '{ComposerAutoloaderInit([^:\\\\s]+)::}', $content, $match ) ) {\\n\\t\\t\\t\\treturn $match[1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t\/\/ Generate a random suffix.\\n\\t\\treturn md5( uniqid( '', true ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Checks to see whether or not the root package is the one that required the autoloader.\\n\\t *\\n\\t * @return bool\\n\\t *\/\\n\\tprivate function isRequiredByRoot() {\\n\\t\\t$package  = $this->composer->getPackage();\\n\\t\\t$requires = $package->getRequires();\\n\\t\\tif ( ! is_array( $requires ) ) { \/\/ @phan-suppress-current-line PhanRedundantCondition -- Earlier Composer versions may not have guaranteed this.\\n\\t\\t\\t$requires = array();\\n\\t\\t}\\n\\t\\t$devRequires = $package->getDevRequires();\\n\\t\\tif ( ! is_array( $devRequires ) ) { \/\/ @phan-suppress-current-line PhanRedundantCondition -- Earlier Composer versions may not have guaranteed this.\\n\\t\\t\\t$devRequires = array();\\n\\t\\t}\\n\\t\\t$requires = array_merge( $requires, $devRequires );\\n\\n\\t\\tif ( empty( $requires ) ) {\\n\\t\\t\\t$this->io->writeError( \\\"\\\\n<error>The package is not required and this should never happen?<\/error>\\\", true );\\n\\t\\t\\texit( 0 );\\n\\t\\t}\\n\\n\\t\\tforeach ( $requires as $require ) {\\n\\t\\t\\tif ( 'automattic\/jetpack-autoloader' === $require->getTarget() ) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/automattic\/jetpack-autoloader\/src\/class-autoloader-locator.php\",\"ext\":\"php\",\"size\":1972,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/* HEADER *\/ \/\/ phpcs:ignore\\n\\nuse Automattic\\\\Jetpack\\\\Autoloader\\\\AutoloadGenerator;\\n\\n\/**\\n * This class locates autoloaders.\\n *\/\\nclass Autoloader_Locator {\\n\\n\\t\/**\\n\\t * The object for comparing autoloader versions.\\n\\t *\\n\\t * @var Version_Selector\\n\\t *\/\\n\\tprivate $version_selector;\\n\\n\\t\/**\\n\\t * The constructor.\\n\\t *\\n\\t * @param Version_Selector $version_selector The version selector object.\\n\\t *\/\\n\\tpublic function __construct( $version_selector ) {\\n\\t\\t$this->version_selector = $version_selector;\\n\\t}\\n\\n\\t\/**\\n\\t * Finds the path to the plugin with the latest autoloader.\\n\\t *\\n\\t * @param array  $plugin_paths An array of plugin paths.\\n\\t * @param string $latest_version The latest version reference. @phan-output-reference.\\n\\t *\\n\\t * @return string|null\\n\\t *\/\\n\\tpublic function find_latest_autoloader( $plugin_paths, &$latest_version ) {\\n\\t\\t$latest_plugin = null;\\n\\n\\t\\tforeach ( $plugin_paths as $plugin_path ) {\\n\\t\\t\\t$version = $this->get_autoloader_version( $plugin_path );\\n\\t\\t\\tif ( ! $version || ! $this->version_selector->is_version_update_required( $latest_version, $version ) ) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$latest_version = $version;\\n\\t\\t\\t$latest_plugin  = $plugin_path;\\n\\t\\t}\\n\\n\\t\\treturn $latest_plugin;\\n\\t}\\n\\n\\t\/**\\n\\t * Gets the path to the autoloader.\\n\\t *\\n\\t * @param string $plugin_path The path to the plugin.\\n\\t *\\n\\t * @return string\\n\\t *\/\\n\\tpublic function get_autoloader_path( $plugin_path ) {\\n\\t\\treturn trailingslashit( $plugin_path ) . 'vendor\/autoload_packages.php';\\n\\t}\\n\\n\\t\/**\\n\\t * Gets the version for the autoloader.\\n\\t *\\n\\t * @param string $plugin_path The path to the plugin.\\n\\t *\\n\\t * @return string|null\\n\\t *\/\\n\\tpublic function get_autoloader_version( $plugin_path ) {\\n\\t\\t$classmap = trailingslashit( $plugin_path ) . 'vendor\/composer\/jetpack_autoload_classmap.php';\\n\\t\\tif ( ! file_exists( $classmap ) ) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\t$classmap = require $classmap;\\n\\t\\tif ( isset( $classmap[ AutoloadGenerator::class ] ) ) {\\n\\t\\t\\treturn $classmap[ AutoloadGenerator::class ]['version'];\\n\\t\\t}\\n\\n\\t\\treturn null;\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/automattic\/jetpack-autoloader\/src\/ManifestGenerator.php\",\"ext\":\"php\",\"size\":3137,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Manifest Generator.\\n *\\n * @package automattic\/jetpack-autoloader\\n *\/\\n\\n\/\/ phpcs:disable WordPress.PHP.DevelopmentFunctions.error_log_var_export\\n\\nnamespace Automattic\\\\Jetpack\\\\Autoloader;\\n\\n\/**\\n * Class ManifestGenerator.\\n *\/\\nclass ManifestGenerator {\\n\\n\\t\/**\\n\\t * Builds a manifest file for the given autoloader type.\\n\\t *\\n\\t * @param string $autoloaderType The type of autoloader to build a manifest for.\\n\\t * @param string $fileName The filename of the manifest.\\n\\t * @param array  $content The manifest content to generate using.\\n\\t *\\n\\t * @return string|null $manifestFile\\n\\t * @throws \\\\InvalidArgumentException When an invalid autoloader type is given.\\n\\t *\/\\n\\tpublic static function buildManifest( $autoloaderType, $fileName, $content ) {\\n\\t\\tif ( empty( $content ) ) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\tswitch ( $autoloaderType ) {\\n\\t\\t\\tcase 'classmap':\\n\\t\\t\\tcase 'files':\\n\\t\\t\\t\\treturn self::buildStandardManifest( $fileName, $content );\\n\\t\\t\\tcase 'psr-4':\\n\\t\\t\\t\\treturn self::buildPsr4Manifest( $fileName, $content );\\n\\t\\t}\\n\\n\\t\\tthrow new \\\\InvalidArgumentException( 'An invalid manifest type of ' . $autoloaderType . ' was passed!' );\\n\\t}\\n\\n\\t\/**\\n\\t * Builds the contents for the standard manifest file.\\n\\t *\\n\\t * @param string $fileName The filename we are building.\\n\\t * @param array  $manifestData The formatted data for the manifest.\\n\\t *\\n\\t * @return string|null $manifestFile\\n\\t *\/\\n\\tprivate static function buildStandardManifest( $fileName, $manifestData ) {\\n\\t\\t$fileContent = PHP_EOL;\\n\\t\\tforeach ( $manifestData as $key => $data ) {\\n\\t\\t\\t$key          = var_export( $key, true );\\n\\t\\t\\t$versionCode  = var_export( $data['version'], true );\\n\\t\\t\\t$fileContent .= <<<MANIFEST_CODE\\n\\t$key => array(\\n\\t\\t'version' => $versionCode,\\n\\t\\t'path'    => {$data['path']}\\n\\t),\\nMANIFEST_CODE;\\n\\t\\t\\t$fileContent .= PHP_EOL;\\n\\t\\t}\\n\\n\\t\\treturn self::buildFile( $fileName, $fileContent );\\n\\t}\\n\\n\\t\/**\\n\\t * Builds the contents for the PSR-4 manifest file.\\n\\t *\\n\\t * @param string $fileName The filename we are building.\\n\\t * @param array  $namespaces The formatted PSR-4 data for the manifest.\\n\\t *\\n\\t * @return string|null $manifestFile\\n\\t *\/\\n\\tprivate static function buildPsr4Manifest( $fileName, $namespaces ) {\\n\\t\\t$fileContent = PHP_EOL;\\n\\t\\tforeach ( $namespaces as $namespace => $data ) {\\n\\t\\t\\t$namespaceCode = var_export( $namespace, true );\\n\\t\\t\\t$versionCode   = var_export( $data['version'], true );\\n\\t\\t\\t$pathCode      = 'array( ' . implode( ', ', $data['path'] ) . ' )';\\n\\t\\t\\t$fileContent  .= <<<MANIFEST_CODE\\n\\t$namespaceCode => array(\\n\\t\\t'version' => $versionCode,\\n\\t\\t'path'    => $pathCode\\n\\t),\\nMANIFEST_CODE;\\n\\t\\t\\t$fileContent  .= PHP_EOL;\\n\\t\\t}\\n\\n\\t\\treturn self::buildFile( $fileName, $fileContent );\\n\\t}\\n\\n\\t\/**\\n\\t * Generate the PHP that will be used in the file.\\n\\t *\\n\\t * @param string $fileName The filename we are building.\\n\\t * @param string $content The content to be written into the file.\\n\\t *\\n\\t * @return string $fileContent\\n\\t *\/\\n\\tprivate static function buildFile( $fileName, $content ) {\\n\\t\\treturn <<<INCLUDE_FILE\\n<?php\\n\\n\/\/ This file `$fileName` was auto generated by automattic\/jetpack-autoloader.\\n\\n\\\\$vendorDir = dirname(__DIR__);\\n\\\\$baseDir   = dirname(\\\\$vendorDir);\\n\\nreturn array($content);\\n\\nINCLUDE_FILE;\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/automattic\/jetpack-autoloader\/src\/class-latest-autoloader-guard.php\",\"ext\":\"php\",\"size\":5778,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/* HEADER *\/ \/\/ phpcs:ignore\\n\\n\/**\\n * This class ensures that we're only executing the latest autoloader.\\n *\/\\nclass Latest_Autoloader_Guard {\\n\\n\\t\/**\\n\\t * The Plugins_Handler instance.\\n\\t *\\n\\t * @var Plugins_Handler\\n\\t *\/\\n\\tprivate $plugins_handler;\\n\\n\\t\/**\\n\\t * The Autoloader_Handler instance.\\n\\t *\\n\\t * @var Autoloader_Handler\\n\\t *\/\\n\\tprivate $autoloader_handler;\\n\\n\\t\/**\\n\\t * The Autoloader_locator instance.\\n\\t *\\n\\t * @var Autoloader_Locator\\n\\t *\/\\n\\tprivate $autoloader_locator;\\n\\n\\t\/**\\n\\t * The constructor.\\n\\t *\\n\\t * @param Plugins_Handler    $plugins_handler    The Plugins_Handler instance.\\n\\t * @param Autoloader_Handler $autoloader_handler The Autoloader_Handler instance.\\n\\t * @param Autoloader_Locator $autoloader_locator The Autoloader_Locator instance.\\n\\t *\/\\n\\tpublic function __construct( $plugins_handler, $autoloader_handler, $autoloader_locator ) {\\n\\t\\t$this->plugins_handler    = $plugins_handler;\\n\\t\\t$this->autoloader_handler = $autoloader_handler;\\n\\t\\t$this->autoloader_locator = $autoloader_locator;\\n\\t}\\n\\n\\t\/**\\n\\t * Indicates whether or not the autoloader should be initialized. Note that this function\\n\\t * has the side-effect of actually loading the latest autoloader in the event that this\\n\\t * is not it.\\n\\t *\\n\\t * @param string   $current_plugin             The current plugin we're checking.\\n\\t * @param string[] $plugins                    The active plugins to check for autoloaders in.\\n\\t * @param bool     $was_included_by_autoloader Indicates whether or not this autoloader was included by another.\\n\\t *\\n\\t * @return bool True if we should stop initialization, otherwise false.\\n\\t *\/\\n\\tpublic function should_stop_init( $current_plugin, $plugins, $was_included_by_autoloader ) {\\n\\t\\tglobal $jetpack_autoloader_latest_version;\\n\\n\\t\\t\/\/ We need to reset the autoloader when the plugins change because\\n\\t\\t\/\/ that means the autoloader was generated with a different list.\\n\\t\\tif ( $this->plugins_handler->have_plugins_changed( $plugins ) ) {\\n\\t\\t\\t$this->autoloader_handler->reset_autoloader();\\n\\t\\t}\\n\\n\\t\\t\/\/ When the latest autoloader has already been found we don't need to search for it again.\\n\\t\\t\/\/ We should take care however because this will also trigger if the autoloader has been\\n\\t\\t\/\/ included by an older one.\\n\\t\\tif ( isset( $jetpack_autoloader_latest_version ) && ! $was_included_by_autoloader ) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\t$latest_plugin = $this->autoloader_locator->find_latest_autoloader( $plugins, $jetpack_autoloader_latest_version );\\n\\t\\tif ( isset( $latest_plugin ) && $latest_plugin !== $current_plugin ) {\\n\\t\\t\\trequire $this->autoloader_locator->get_autoloader_path( $latest_plugin );\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\t\/**\\n\\t * Check for conflicting autoloaders.\\n\\t *\\n\\t * A common source of strange and confusing problems is when another plugin\\n\\t * registers a Composer autoloader at a higher priority that us. If enabled,\\n\\t * check for this problem and warn about it.\\n\\t *\\n\\t * Called from the plugins_loaded hook.\\n\\t *\\n\\t * @since 3.1.0\\n\\t * @return void\\n\\t *\/\\n\\tpublic function check_for_conflicting_autoloaders() {\\n\\t\\tif ( ! defined( 'JETPACK_AUTOLOAD_DEBUG_CONFLICTING_LOADERS' ) || ! JETPACK_AUTOLOAD_DEBUG_CONFLICTING_LOADERS ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tglobal $jetpack_autoloader_loader;\\n\\t\\tif ( ! isset( $jetpack_autoloader_loader ) ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t$prefixes = array();\\n\\t\\tforeach ( ( $jetpack_autoloader_loader->get_class_map() ?? array() ) as $classname => $data ) {\\n\\t\\t\\t$parts = explode( '\\\\\\\\', trim( $classname, '\\\\\\\\' ) );\\n\\t\\t\\tarray_pop( $parts );\\n\\t\\t\\twhile ( $parts ) {\\n\\t\\t\\t\\t$prefixes[ implode( '\\\\\\\\', $parts ) . '\\\\\\\\' ] = true;\\n\\t\\t\\t\\tarray_pop( $parts );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tforeach ( ( $jetpack_autoloader_loader->get_psr4_map() ?? array() ) as $prefix => $data ) {\\n\\t\\t\\t$parts = explode( '\\\\\\\\', trim( $prefix, '\\\\\\\\' ) );\\n\\t\\t\\twhile ( $parts ) {\\n\\t\\t\\t\\t$prefixes[ implode( '\\\\\\\\', $parts ) . '\\\\\\\\' ] = true;\\n\\t\\t\\t\\tarray_pop( $parts );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t$autoload_chain = spl_autoload_functions();\\n\\t\\tif ( ! $autoload_chain ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tforeach ( $autoload_chain as $autoloader ) {\\n\\t\\t\\t\/\/ No need to check anything after us.\\n\\t\\t\\tif ( is_array( $autoloader ) && is_string( $autoloader[0] ) && substr( $autoloader[0], 0, strlen( __NAMESPACE__ ) + 1 ) === __NAMESPACE__ . '\\\\\\\\' ) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\t\/\/ We can check Composer autoloaders easily enough.\\n\\t\\t\\tif ( is_array( $autoloader ) && $autoloader[0] instanceof \\\\Composer\\\\Autoload\\\\ClassLoader && is_callable( array( $autoloader[0], 'getPrefixesPsr4' ) ) ) {\\n\\t\\t\\t\\t$composer_autoloader = $autoloader[0];\\n\\t\\t\\t\\tforeach ( $composer_autoloader->getClassMap() as $classname => $path ) {\\n\\t\\t\\t\\t\\tif ( $jetpack_autoloader_loader->find_class_file( $classname ) ) {\\n\\t\\t\\t\\t\\t\\t$msg = \\\"A Composer autoloader is registered with a higher priority than the Jetpack Autoloader and would also handle some of the classes we handle (e.g. $classname => $path). This may cause strange and confusing problems.\\\";\\n\\t\\t\\t\\t\\t\\twp_trigger_error( '', $msg );\\n\\t\\t\\t\\t\\t\\tcontinue 2;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tforeach ( $composer_autoloader->getPrefixesPsr4() as $prefix => $paths ) {\\n\\t\\t\\t\\t\\tif ( isset( $prefixes[ $prefix ] ) ) {\\n\\t\\t\\t\\t\\t\\t$path = array_pop( $paths );\\n\\t\\t\\t\\t\\t\\t$msg  = \\\"A Composer autoloader is registered with a higher priority than the Jetpack Autoloader and would also handle some of the namespaces we handle (e.g. $prefix => $path). This may cause strange and confusing problems.\\\";\\n\\t\\t\\t\\t\\t\\twp_trigger_error( '', $msg );\\n\\t\\t\\t\\t\\t\\tcontinue 2;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tforeach ( $composer_autoloader->getPrefixes() as $prefix => $paths ) {\\n\\t\\t\\t\\t\\tif ( isset( $prefixes[ $prefix ] ) ) {\\n\\t\\t\\t\\t\\t\\t$path = array_pop( $paths );\\n\\t\\t\\t\\t\\t\\t$msg  = \\\"A Composer autoloader is registered with a higher priority than the Jetpack Autoloader and would also handle some of the namespaces we handle (e.g. $prefix => $path). This may cause strange and confusing problems.\\\";\\n\\t\\t\\t\\t\\t\\twp_trigger_error( '', $msg );\\n\\t\\t\\t\\t\\t\\tcontinue 2;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/automattic\/jetpack-autoloader\/src\/AutoloadFileWriter.php\",\"ext\":\"php\",\"size\":2575,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Autoloader file writer.\\n *\\n * @package automattic\/jetpack-autoloader\\n *\/\\n\\nnamespace Automattic\\\\Jetpack\\\\Autoloader;\\n\\nuse Composer\\\\IO\\\\IOInterface;\\n\\n\/**\\n * Class AutoloadFileWriter.\\n *\/\\nclass AutoloadFileWriter {\\n\\n\\t\/**\\n\\t * The file comment to use.\\n\\t *\/\\n\\tconst COMMENT = <<<AUTOLOADER_COMMENT\\n\/**\\n * This file was automatically generated by automattic\/jetpack-autoloader.\\n *\\n * @package automattic\/jetpack-autoloader\\n *\/\\n\\nAUTOLOADER_COMMENT;\\n\\n\\t\/**\\n\\t * Copies autoloader files and replaces any placeholders in them.\\n\\t *\\n\\t * @param IOInterface|null $io An IO for writing to.\\n\\t * @param string           $outDir The directory to place the autoloader files in.\\n\\t * @param string           $suffix The suffix to use in the autoloader's namespace.\\n\\t *\/\\n\\tpublic static function copyAutoloaderFiles( $io, $outDir, $suffix ) {\\n\\t\\t$renameList = array(\\n\\t\\t\\t'autoload.php' => '..\/autoload_packages.php',\\n\\t\\t);\\n\\t\\t$ignoreList = array(\\n\\t\\t\\t'AutoloadGenerator.php',\\n\\t\\t\\t'AutoloadProcessor.php',\\n\\t\\t\\t'CustomAutoloaderPlugin.php',\\n\\t\\t\\t'ManifestGenerator.php',\\n\\t\\t\\t'AutoloadFileWriter.php',\\n\\t\\t);\\n\\n\\t\\t\/\/ Copy all of the autoloader files.\\n\\t\\t$files = scandir( __DIR__ );\\n\\t\\tforeach ( $files as $file ) {\\n\\t\\t\\t\/\/ Only PHP files will be copied.\\n\\t\\t\\tif ( substr( $file, -4 ) !== '.php' ) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( in_array( $file, $ignoreList, true ) ) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$newFile = $renameList[ $file ] ?? $file;\\n\\t\\t\\t$content = self::prepareAutoloaderFile( $file, $suffix );\\n\\n\\t\\t\\t$written = file_put_contents( $outDir . '\/' . $newFile, $content );\\n\\t\\t\\tif ( $io ) {\\n\\t\\t\\t\\tif ( $written ) {\\n\\t\\t\\t\\t\\t$io->writeError( \\\"  <info>Generated: $newFile<\/info>\\\" );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t$io->writeError( \\\"  <error>Error: $newFile<\/error>\\\" );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t\/**\\n\\t * Prepares an autoloader file to be written to the destination.\\n\\t *\\n\\t * @param String $filename a file to prepare.\\n\\t * @param String $suffix   Unique suffix used in the namespace.\\n\\t *\\n\\t * @return string\\n\\t *\/\\n\\tprivate static function prepareAutoloaderFile( $filename, $suffix ) {\\n\\t\\t$header  = self::COMMENT;\\n\\t\\t$header .= PHP_EOL;\\n\\t\\tif ( $suffix === 'Current' ) {\\n\\t\\t\\t\/\/ Unit testing.\\n\\t\\t\\t$header .= 'namespace Automattic\\\\Jetpack\\\\Autoloader\\\\jpCurrent;';\\n\\t\\t} else {\\n\\t\\t\\t$header .= 'namespace Automattic\\\\Jetpack\\\\Autoloader\\\\jp' . $suffix . '\\\\al' . preg_replace( '\/[^0-9a-zA-Z]\/', '_', AutoloadGenerator::VERSION ) . ';';\\n\\t\\t}\\n\\t\\t$header .= PHP_EOL . PHP_EOL;\\n\\n\\t\\t$sourceLoader  = fopen( __DIR__ . '\/' . $filename, 'r' );\\n\\t\\t$file_contents = stream_get_contents( $sourceLoader );\\n\\t\\treturn str_replace(\\n\\t\\t\\t'\/* HEADER *\/',\\n\\t\\t\\t$header,\\n\\t\\t\\t$file_contents\\n\\t\\t);\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/automattic\/jetpack-autoloader\/src\/class-hook-manager.php\",\"ext\":\"php\",\"size\":1955,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/* HEADER *\/ \/\/ phpcs:ignore\\n\\n\/**\\n * Allows the latest autoloader to register hooks that can be removed when the autoloader is reset.\\n *\/\\nclass Hook_Manager {\\n\\n\\t\/**\\n\\t * An array containing all of the hooks that we've registered.\\n\\t *\\n\\t * @var array\\n\\t *\/\\n\\tprivate $registered_hooks;\\n\\n\\t\/**\\n\\t * The constructor.\\n\\t *\/\\n\\tpublic function __construct() {\\n\\t\\t$this->registered_hooks = array();\\n\\t}\\n\\n\\t\/**\\n\\t * Adds an action to WordPress and registers it internally.\\n\\t *\\n\\t * @param string   $tag           The name of the action which is hooked.\\n\\t * @param callable $callable      The function to call.\\n\\t * @param int      $priority      Used to specify the priority of the action.\\n\\t * @param int      $accepted_args Used to specify the number of arguments the callable accepts.\\n\\t *\/\\n\\tpublic function add_action( $tag, $callable, $priority = 10, $accepted_args = 1 ) {\\n\\t\\t$this->registered_hooks[ $tag ][] = array(\\n\\t\\t\\t'priority' => $priority,\\n\\t\\t\\t'callable' => $callable,\\n\\t\\t);\\n\\n\\t\\tadd_action( $tag, $callable, $priority, $accepted_args );\\n\\t}\\n\\n\\t\/**\\n\\t * Adds a filter to WordPress and registers it internally.\\n\\t *\\n\\t * @param string   $tag           The name of the filter which is hooked.\\n\\t * @param callable $callable      The function to call.\\n\\t * @param int      $priority      Used to specify the priority of the filter.\\n\\t * @param int      $accepted_args Used to specify the number of arguments the callable accepts.\\n\\t *\/\\n\\tpublic function add_filter( $tag, $callable, $priority = 10, $accepted_args = 1 ) {\\n\\t\\t$this->registered_hooks[ $tag ][] = array(\\n\\t\\t\\t'priority' => $priority,\\n\\t\\t\\t'callable' => $callable,\\n\\t\\t);\\n\\n\\t\\tadd_filter( $tag, $callable, $priority, $accepted_args );\\n\\t}\\n\\n\\t\/**\\n\\t * Removes all of the registered hooks.\\n\\t *\/\\n\\tpublic function reset() {\\n\\t\\tforeach ( $this->registered_hooks as $tag => $hooks ) {\\n\\t\\t\\tforeach ( $hooks as $hook ) {\\n\\t\\t\\t\\tremove_filter( $tag, $hook['callable'], $hook['priority'] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t$this->registered_hooks = array();\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/automattic\/jetpack-autoloader\/src\/AutoloadProcessor.php\",\"ext\":\"php\",\"size\":5049,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Autoload Processor.\\n *\\n * @package automattic\/jetpack-autoloader\\n *\/\\n\\nnamespace Automattic\\\\Jetpack\\\\Autoloader;\\n\\n\/**\\n * Class AutoloadProcessor.\\n *\/\\nclass AutoloadProcessor {\\n\\n\\t\/**\\n\\t * A callable for scanning a directory for all of its classes.\\n\\t *\\n\\t * @var callable\\n\\t *\/\\n\\tprivate $classmapScanner;\\n\\n\\t\/**\\n\\t * A callable for transforming a path into one to be used in code.\\n\\t *\\n\\t * @var callable\\n\\t *\/\\n\\tprivate $pathCodeTransformer;\\n\\n\\t\/**\\n\\t * The constructor.\\n\\t *\\n\\t * @param callable $classmapScanner A callable for scanning a directory for all of its classes.\\n\\t * @param callable $pathCodeTransformer A callable for transforming a path into one to be used in code.\\n\\t *\/\\n\\tpublic function __construct( $classmapScanner, $pathCodeTransformer ) {\\n\\t\\t$this->classmapScanner     = $classmapScanner;\\n\\t\\t$this->pathCodeTransformer = $pathCodeTransformer;\\n\\t}\\n\\n\\t\/**\\n\\t * Processes the classmap autoloads into a relative path format including the version for each file.\\n\\t *\\n\\t * @param array $autoloads The autoloads we are processing.\\n\\t * @param bool  $scanPsrPackages Whether or not PSR packages should be converted to a classmap.\\n\\t *\\n\\t * @return array|null $processed\\n\\t * @phan-param array{classmap:?array{path:string,version:string}[],psr-4:?array<string,array{path:string,version:string}[]>,psr-0:?array<string,array{path:string,version:string}[]>} $autoloads\\n\\t *\/\\n\\tpublic function processClassmap( $autoloads, $scanPsrPackages ) {\\n\\t\\t\/\/ We can't scan PSR packages if we don't actually have any.\\n\\t\\tif ( empty( $autoloads['psr-4'] ) ) {\\n\\t\\t\\t$scanPsrPackages = false;\\n\\t\\t}\\n\\n\\t\\tif ( empty( $autoloads['classmap'] ) && ! $scanPsrPackages ) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\t$excludedClasses = null;\\n\\t\\tif ( ! empty( $autoloads['exclude-from-classmap'] ) ) {\\n\\t\\t\\t$excludedClasses = '{(' . implode( '|', $autoloads['exclude-from-classmap'] ) . ')}';\\n\\t\\t}\\n\\n\\t\\t$processed = array();\\n\\n\\t\\tif ( $scanPsrPackages ) {\\n\\t\\t\\tforeach ( $autoloads['psr-4'] as $namespace => $sources ) {\\n\\t\\t\\t\\t$namespace = empty( $namespace ) ? null : $namespace;\\n\\n\\t\\t\\t\\tforeach ( $sources as $source ) {\\n\\t\\t\\t\\t\\t$classmap = call_user_func( $this->classmapScanner, $source['path'], $excludedClasses, $namespace );\\n\\n\\t\\t\\t\\t\\tforeach ( $classmap as $class => $path ) {\\n\\t\\t\\t\\t\\t\\t$processed[ $class ] = array(\\n\\t\\t\\t\\t\\t\\t\\t'version' => $source['version'],\\n\\t\\t\\t\\t\\t\\t\\t'path'    => call_user_func( $this->pathCodeTransformer, $path ),\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t\/*\\n\\t\\t * PSR-0 namespaces are converted to classmaps for both optimized and unoptimized autoloaders because any new\\n\\t\\t * development should use classmap or PSR-4 autoloading.\\n\\t\\t *\/\\n\\t\\tif ( ! empty( $autoloads['psr-0'] ) ) {\\n\\t\\t\\tforeach ( $autoloads['psr-0'] as $namespace => $sources ) {\\n\\t\\t\\t\\t$namespace = empty( $namespace ) ? null : $namespace;\\n\\n\\t\\t\\t\\tforeach ( $sources as $source ) {\\n\\t\\t\\t\\t\\t$classmap = call_user_func( $this->classmapScanner, $source['path'], $excludedClasses, $namespace );\\n\\t\\t\\t\\t\\tforeach ( $classmap as $class => $path ) {\\n\\t\\t\\t\\t\\t\\t$processed[ $class ] = array(\\n\\t\\t\\t\\t\\t\\t\\t'version' => $source['version'],\\n\\t\\t\\t\\t\\t\\t\\t'path'    => call_user_func( $this->pathCodeTransformer, $path ),\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( ! empty( $autoloads['classmap'] ) ) {\\n\\t\\t\\tforeach ( $autoloads['classmap'] as $package ) {\\n\\t\\t\\t\\t$classmap = call_user_func( $this->classmapScanner, $package['path'], $excludedClasses, null );\\n\\n\\t\\t\\t\\tforeach ( $classmap as $class => $path ) {\\n\\t\\t\\t\\t\\t$processed[ $class ] = array(\\n\\t\\t\\t\\t\\t\\t'version' => $package['version'],\\n\\t\\t\\t\\t\\t\\t'path'    => call_user_func( $this->pathCodeTransformer, $path ),\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tksort( $processed );\\n\\n\\t\\treturn $processed;\\n\\t}\\n\\n\\t\/**\\n\\t * Processes the PSR-4 autoloads into a relative path format including the version for each file.\\n\\t *\\n\\t * @param array $autoloads The autoloads we are processing.\\n\\t * @param bool  $scanPsrPackages Whether or not PSR packages should be converted to a classmap.\\n\\t *\\n\\t * @return array|null $processed\\n\\t *\/\\n\\tpublic function processPsr4Packages( $autoloads, $scanPsrPackages ) {\\n\\t\\tif ( $scanPsrPackages || empty( $autoloads['psr-4'] ) ) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\t$processed = array();\\n\\n\\t\\tforeach ( $autoloads['psr-4'] as $namespace => $packages ) {\\n\\t\\t\\t$namespace = empty( $namespace ) ? null : $namespace;\\n\\t\\t\\t$paths     = array();\\n\\n\\t\\t\\tforeach ( $packages as $package ) {\\n\\t\\t\\t\\t$paths[] = call_user_func( $this->pathCodeTransformer, $package['path'] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t$processed[ $namespace ] = array(\\n\\t\\t\\t\\t'version' => $package['version'],\\n\\t\\t\\t\\t'path'    => $paths,\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\treturn $processed;\\n\\t}\\n\\n\\t\/**\\n\\t * Processes the file autoloads into a relative format including the version for each file.\\n\\t *\\n\\t * @param array $autoloads The autoloads we are processing.\\n\\t *\\n\\t * @return array|null $processed\\n\\t *\/\\n\\tpublic function processFiles( $autoloads ) {\\n\\t\\tif ( empty( $autoloads['files'] ) ) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\t$processed = array();\\n\\n\\t\\tforeach ( $autoloads['files'] as $file_id => $package ) {\\n\\t\\t\\t$processed[ $file_id ] = array(\\n\\t\\t\\t\\t'version' => $package['version'],\\n\\t\\t\\t\\t'path'    => call_user_func( $this->pathCodeTransformer, $package['path'] ),\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\treturn $processed;\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/automattic\/jetpack-autoloader\/src\/class-autoloader.php\",\"ext\":\"php\",\"size\":4147,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/* HEADER *\/ \/\/ phpcs:ignore\\n\\n\/**\\n * This class handles management of the actual PHP autoloader.\\n *\/\\nclass Autoloader {\\n\\n\\t\/**\\n\\t * Checks to see whether or not the autoloader should be initialized and then initializes it if so.\\n\\t *\\n\\t * @param Container|null $container The container we want to use for autoloader initialization. If none is given\\n\\t *                                  then a container will be created automatically.\\n\\t *\/\\n\\tpublic static function init( $container = null ) {\\n\\t\\t\/\/ The container holds and manages the lifecycle of our dependencies\\n\\t\\t\/\/ to make them easier to work with and increase flexibility.\\n\\t\\tif ( ! isset( $container ) ) {\\n\\t\\t\\trequire_once __DIR__ . '\/class-container.php';\\n\\t\\t\\t$container = new Container();\\n\\t\\t}\\n\\n\\t\\t\/\/ phpcs:disable Generic.Commenting.DocComment.MissingShort\\n\\n\\t\\t\/** @var Autoloader_Handler $autoloader_handler *\/\\n\\t\\t$autoloader_handler = $container->get( Autoloader_Handler::class );\\n\\n\\t\\t\/\/ If the autoloader is already initializing it means that it has included us as the latest.\\n\\t\\t$was_included_by_autoloader = $autoloader_handler->is_initializing();\\n\\n\\t\\t\/** @var Plugin_Locator $plugin_locator *\/\\n\\t\\t$plugin_locator = $container->get( Plugin_Locator::class );\\n\\n\\t\\t\/** @var Plugins_Handler $plugins_handler *\/\\n\\t\\t$plugins_handler = $container->get( Plugins_Handler::class );\\n\\n\\t\\t\/\/ The current plugin is the one that we are attempting to initialize here.\\n\\t\\t$current_plugin = $plugin_locator->find_current_plugin();\\n\\n\\t\\t\/\/ The active plugins are those that we were able to discover on the site. This list will not\\n\\t\\t\/\/ include mu-plugins, those activated by code, or those who are hidden by filtering. We also\\n\\t\\t\/\/ want to take care to not consider the current plugin unknown if it was included by an\\n\\t\\t\/\/ autoloader. This avoids the case where a plugin will be marked \\\"active\\\" while deactivated\\n\\t\\t\/\/ due to it having the latest autoloader.\\n\\t\\t$active_plugins = $plugins_handler->get_active_plugins( true, ! $was_included_by_autoloader );\\n\\n\\t\\t\/\/ The cached plugins are all of those that were active or discovered by the autoloader during a previous request.\\n\\t\\t\/\/ Note that it's possible this list will include plugins that have since been deactivated, but after a request\\n\\t\\t\/\/ the cache should be updated and the deactivated plugins will be removed.\\n\\t\\t$cached_plugins = $plugins_handler->get_cached_plugins();\\n\\n\\t\\t\/\/ We combine the active list and cached list to preemptively load classes for plugins that are\\n\\t\\t\/\/ presently unknown but will be loaded during the request. While this may result in us considering packages in\\n\\t\\t\/\/ deactivated plugins there shouldn't be any problems as a result and the eventual consistency is sufficient.\\n\\t\\t$all_plugins = array_merge( $active_plugins, $cached_plugins );\\n\\n\\t\\t\/\/ In particular we also include the current plugin to address the case where it is the latest autoloader\\n\\t\\t\/\/ but also unknown (and not cached). We don't want it in the active list because we don't know that it\\n\\t\\t\/\/ is active but we need it in the all plugins list so that it is considered by the autoloader.\\n\\t\\t$all_plugins[] = $current_plugin;\\n\\n\\t\\t\/\/ We require uniqueness in the array to avoid processing the same plugin more than once.\\n\\t\\t$all_plugins = array_values( array_unique( $all_plugins ) );\\n\\n\\t\\t\/** @var Latest_Autoloader_Guard $guard *\/\\n\\t\\t$guard = $container->get( Latest_Autoloader_Guard::class );\\n\\t\\tif ( $guard->should_stop_init( $current_plugin, $all_plugins, $was_included_by_autoloader ) ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t\/\/ Initialize the autoloader using the handler now that we're ready.\\n\\t\\t$autoloader_handler->activate_autoloader( $all_plugins );\\n\\n\\t\\t\/** @var Hook_Manager $hook_manager *\/\\n\\t\\t$hook_manager = $container->get( Hook_Manager::class );\\n\\n\\t\\t\/\/ Register a shutdown handler to clean up the autoloader.\\n\\t\\t$hook_manager->add_action( 'shutdown', new Shutdown_Handler( $plugins_handler, $cached_plugins, $was_included_by_autoloader ) );\\n\\n\\t\\t\/\/ Register a plugins_loaded handler to check for conflicting autoloaders.\\n\\t\\t$hook_manager->add_action( 'plugins_loaded', array( $guard, 'check_for_conflicting_autoloaders' ), 1 );\\n\\n\\t\\t\/\/ phpcs:enable Generic.Commenting.DocComment.MissingShort\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/automattic\/jetpack-autoloader\/src\/class-version-loader.php\",\"ext\":\"php\",\"size\":4288,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/* HEADER *\/ \/\/ phpcs:ignore\\n\\n\/**\\n * This class loads other classes based on given parameters.\\n *\/\\nclass Version_Loader {\\n\\n\\t\/**\\n\\t * The Version_Selector object.\\n\\t *\\n\\t * @var Version_Selector\\n\\t *\/\\n\\tprivate $version_selector;\\n\\n\\t\/**\\n\\t * A map of available classes and their version and file path.\\n\\t *\\n\\t * @var array\\n\\t *\/\\n\\tprivate $classmap;\\n\\n\\t\/**\\n\\t * A map of PSR-4 namespaces and their version and directory path.\\n\\t *\\n\\t * @var array\\n\\t *\/\\n\\tprivate $psr4_map;\\n\\n\\t\/**\\n\\t * A map of all the files that we should load.\\n\\t *\\n\\t * @var array\\n\\t *\/\\n\\tprivate $filemap;\\n\\n\\t\/**\\n\\t * The constructor.\\n\\t *\\n\\t * @param Version_Selector $version_selector The Version_Selector object.\\n\\t * @param array            $classmap The verioned classmap to load using.\\n\\t * @param array            $psr4_map The versioned PSR-4 map to load using.\\n\\t * @param array            $filemap The versioned filemap to load.\\n\\t *\/\\n\\tpublic function __construct( $version_selector, $classmap, $psr4_map, $filemap ) {\\n\\t\\t$this->version_selector = $version_selector;\\n\\t\\t$this->classmap         = $classmap;\\n\\t\\t$this->psr4_map         = $psr4_map;\\n\\t\\t$this->filemap          = $filemap;\\n\\t}\\n\\n\\t\/**\\n\\t * Fetch the classmap.\\n\\t *\\n\\t * @since 3.1.0\\n\\t * @return array<string, array>\\n\\t *\/\\n\\tpublic function get_class_map() {\\n\\t\\treturn $this->classmap;\\n\\t}\\n\\n\\t\/**\\n\\t * Fetch the psr-4 mappings.\\n\\t *\\n\\t * @since 3.1.0\\n\\t * @return array<string, array>\\n\\t *\/\\n\\tpublic function get_psr4_map() {\\n\\t\\treturn $this->psr4_map;\\n\\t}\\n\\n\\t\/**\\n\\t * Finds the file path for the given class.\\n\\t *\\n\\t * @param string $class_name The class to find.\\n\\t *\\n\\t * @return string|null $file_path The path to the file if found, null if no class was found.\\n\\t *\/\\n\\tpublic function find_class_file( $class_name ) {\\n\\t\\t$data = $this->select_newest_file(\\n\\t\\t\\t$this->classmap[ $class_name ] ?? null,\\n\\t\\t\\t$this->find_psr4_file( $class_name )\\n\\t\\t);\\n\\t\\tif ( ! isset( $data ) ) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\treturn $data['path'];\\n\\t}\\n\\n\\t\/**\\n\\t * Load all of the files in the filemap.\\n\\t *\/\\n\\tpublic function load_filemap() {\\n\\t\\tif ( empty( $this->filemap ) ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tforeach ( $this->filemap as $file_identifier => $file_data ) {\\n\\t\\t\\tif ( empty( $GLOBALS['__composer_autoload_files'][ $file_identifier ] ) ) {\\n\\t\\t\\t\\trequire_once $file_data['path'];\\n\\n\\t\\t\\t\\t$GLOBALS['__composer_autoload_files'][ $file_identifier ] = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t\/**\\n\\t * Compares different class sources and returns the newest.\\n\\t *\\n\\t * @param array|null $classmap_data The classmap class data.\\n\\t * @param array|null $psr4_data The PSR-4 class data.\\n\\t *\\n\\t * @return array|null $data\\n\\t *\/\\n\\tprivate function select_newest_file( $classmap_data, $psr4_data ) {\\n\\t\\tif ( ! isset( $classmap_data ) ) {\\n\\t\\t\\treturn $psr4_data;\\n\\t\\t} elseif ( ! isset( $psr4_data ) ) {\\n\\t\\t\\treturn $classmap_data;\\n\\t\\t}\\n\\n\\t\\tif ( $this->version_selector->is_version_update_required( $classmap_data['version'], $psr4_data['version'] ) ) {\\n\\t\\t\\treturn $psr4_data;\\n\\t\\t}\\n\\n\\t\\treturn $classmap_data;\\n\\t}\\n\\n\\t\/**\\n\\t * Finds the file for a given class in a PSR-4 namespace.\\n\\t *\\n\\t * @param string $class_name The class to find.\\n\\t *\\n\\t * @return array|null $data The version and path path to the file if found, null otherwise.\\n\\t *\/\\n\\tprivate function find_psr4_file( $class_name ) {\\n\\t\\tif ( empty( $this->psr4_map ) ) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\t\/\/ Don't bother with classes that have no namespace.\\n\\t\\t$class_index = strrpos( $class_name, '\\\\\\\\' );\\n\\t\\tif ( ! $class_index ) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\t$class_for_path = str_replace( '\\\\\\\\', '\/', $class_name );\\n\\n\\t\\t\/\/ Search for the namespace by iteratively cutting off the last segment until\\n\\t\\t\/\/ we find a match. This allows us to check the most-specific namespaces\\n\\t\\t\/\/ first as well as minimize the amount of time spent looking.\\n\\t\\tfor (\\n\\t\\t\\t$class_namespace = substr( $class_name, 0, $class_index );\\n\\t\\t\\t! empty( $class_namespace );\\n\\t\\t\\t$class_namespace = substr( $class_namespace, 0, strrpos( $class_namespace, '\\\\\\\\' ) )\\n\\t\\t) {\\n\\t\\t\\t$namespace = $class_namespace . '\\\\\\\\';\\n\\t\\t\\tif ( ! isset( $this->psr4_map[ $namespace ] ) ) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\t$data = $this->psr4_map[ $namespace ];\\n\\n\\t\\t\\tforeach ( $data['path'] as $path ) {\\n\\t\\t\\t\\t$path .= '\/' . substr( $class_for_path, strlen( $namespace ) ) . '.php';\\n\\t\\t\\t\\tif ( file_exists( $path ) ) {\\n\\t\\t\\t\\t\\treturn array(\\n\\t\\t\\t\\t\\t\\t'version' => $data['version'],\\n\\t\\t\\t\\t\\t\\t'path'    => $path,\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn null;\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/automattic\/jetpack-autoloader\/src\/class-path-processor.php\",\"ext\":\"php\",\"size\":5505,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/* HEADER *\/ \/\/ phpcs:ignore\\n\\n\/**\\n * This class handles dealing with paths for the autoloader.\\n *\/\\nclass Path_Processor {\\n\\t\/**\\n\\t * Given a path this will replace any of the path constants with a token to represent it.\\n\\t *\\n\\t * @param string $path The path we want to process.\\n\\t *\\n\\t * @return string The tokenized path.\\n\\t *\/\\n\\tpublic function tokenize_path_constants( $path ) {\\n\\t\\t$path = wp_normalize_path( $path );\\n\\n\\t\\t$constants = $this->get_normalized_constants();\\n\\t\\tforeach ( $constants as $constant => $constant_path ) {\\n\\t\\t\\t$len = strlen( $constant_path );\\n\\t\\t\\tif ( substr( $path, 0, $len ) !== $constant_path ) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn substr_replace( $path, '{{' . $constant . '}}', 0, $len );\\n\\t\\t}\\n\\n\\t\\treturn $path;\\n\\t}\\n\\n\\t\/**\\n\\t * Given a path this will replace any of the path constant tokens with the expanded path.\\n\\t *\\n\\t * @param string $tokenized_path The path we want to process.\\n\\t *\\n\\t * @return string The expanded path.\\n\\t *\/\\n\\tpublic function untokenize_path_constants( $tokenized_path ) {\\n\\t\\t$tokenized_path = wp_normalize_path( $tokenized_path );\\n\\n\\t\\t$constants = $this->get_normalized_constants();\\n\\t\\tforeach ( $constants as $constant => $constant_path ) {\\n\\t\\t\\t$constant = '{{' . $constant . '}}';\\n\\n\\t\\t\\t$len = strlen( $constant );\\n\\t\\t\\tif ( substr( $tokenized_path, 0, $len ) !== $constant ) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn $this->get_real_path( substr_replace( $tokenized_path, $constant_path, 0, $len ) );\\n\\t\\t}\\n\\n\\t\\treturn $tokenized_path;\\n\\t}\\n\\n\\t\/**\\n\\t * Given a file and an array of places it might be, this will find the absolute path and return it.\\n\\t *\\n\\t * @param string $file The plugin or theme file to resolve.\\n\\t * @param array  $directories_to_check The directories we should check for the file if it isn't an absolute path.\\n\\t *\\n\\t * @return string|false Returns the absolute path to the directory, otherwise false.\\n\\t *\/\\n\\tpublic function find_directory_with_autoloader( $file, $directories_to_check ) {\\n\\t\\t$file = wp_normalize_path( $file );\\n\\n\\t\\tif ( ! $this->is_absolute_path( $file ) ) {\\n\\t\\t\\t$file = $this->find_absolute_plugin_path( $file, $directories_to_check );\\n\\t\\t\\tif ( ! isset( $file ) ) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t\/\/ We need the real path for consistency with __DIR__ paths.\\n\\t\\t$file = $this->get_real_path( $file );\\n\\n\\t\\t\/\/ phpcs:disable WordPress.PHP.NoSilencedErrors.Discouraged\\n\\t\\t$directory = @is_file( $file ) ? dirname( $file ) : $file;\\n\\t\\tif ( ! @is_file( $directory . '\/vendor\/composer\/jetpack_autoload_classmap.php' ) ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t\/\/ phpcs:enable WordPress.PHP.NoSilencedErrors.Discouraged\\n\\n\\t\\treturn $directory;\\n\\t}\\n\\n\\t\/**\\n\\t * Fetches an array of normalized paths keyed by the constant they came from.\\n\\t *\\n\\t * @return string[] The normalized paths keyed by the constant.\\n\\t *\/\\n\\tprivate function get_normalized_constants() {\\n\\t\\t$raw_constants = array(\\n\\t\\t\\t\/\/ Order the constants from most-specific to least-specific.\\n\\t\\t\\t'WP_PLUGIN_DIR',\\n\\t\\t\\t'WPMU_PLUGIN_DIR',\\n\\t\\t\\t'WP_CONTENT_DIR',\\n\\t\\t\\t'ABSPATH',\\n\\t\\t);\\n\\n\\t\\t$constants = array();\\n\\t\\tforeach ( $raw_constants as $raw ) {\\n\\t\\t\\tif ( ! defined( $raw ) ) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$path = wp_normalize_path( constant( $raw ) );\\n\\t\\t\\tif ( isset( $path ) ) {\\n\\t\\t\\t\\t$constants[ $raw ] = $path;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $constants;\\n\\t}\\n\\n\\t\/**\\n\\t * Indicates whether or not a path is absolute.\\n\\t *\\n\\t * @param string $path The path to check.\\n\\t *\\n\\t * @return bool True if the path is absolute, otherwise false.\\n\\t *\/\\n\\tprivate function is_absolute_path( $path ) {\\n\\t\\tif ( empty( $path ) || 0 === strlen( $path ) || '.' === $path[0] ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t\/\/ Absolute paths on Windows may begin with a drive letter.\\n\\t\\tif ( preg_match( '\/^[a-zA-Z]:[\\\\\/\\\\\\\\\\\\\\\\]\/', $path ) ) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\t\/\/ A path starting with \/ or \\\\ is absolute; anything else is relative.\\n\\t\\treturn ( '\/' === $path[0] || '\\\\\\\\' === $path[0] );\\n\\t}\\n\\n\\t\/**\\n\\t * Given a file and a list of directories to check, this method will try to figure out\\n\\t * the absolute path to the file in question.\\n\\t *\\n\\t * @param string $normalized_path The normalized path to the plugin or theme file to resolve.\\n\\t * @param array  $directories_to_check The directories we should check for the file if it isn't an absolute path.\\n\\t *\\n\\t * @return string|null The absolute path to the plugin file, otherwise null.\\n\\t *\/\\n\\tprivate function find_absolute_plugin_path( $normalized_path, $directories_to_check ) {\\n\\t\\t\/\/ We're only able to find the absolute path for plugin\/theme PHP files.\\n\\t\\tif ( ! is_string( $normalized_path ) || '.php' !== substr( $normalized_path, -4 ) ) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\tforeach ( $directories_to_check as $directory ) {\\n\\t\\t\\t$normalized_check = wp_normalize_path( trailingslashit( $directory ) ) . $normalized_path;\\n\\t\\t\\t\/\/ phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged\\n\\t\\t\\tif ( @is_file( $normalized_check ) ) {\\n\\t\\t\\t\\treturn $normalized_check;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn null;\\n\\t}\\n\\n\\t\/**\\n\\t * Given a path this will figure out the real path that we should be using.\\n\\t *\\n\\t * @param string $path The path to resolve.\\n\\t *\\n\\t * @return string The resolved path.\\n\\t *\/\\n\\tprivate function get_real_path( $path ) {\\n\\t\\t\/\/ We want to resolve symbolic links for consistency with __DIR__ paths.\\n\\t\\t\/\/ phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged\\n\\t\\t$real_path = @realpath( $path );\\n\\t\\tif ( false === $real_path ) {\\n\\t\\t\\t\/\/ Let the autoloader deal with paths that don't exist.\\n\\t\\t\\t$real_path = $path;\\n\\t\\t}\\n\\n\\t\\t\/\/ Using realpath will make it platform-specific so we must normalize it after.\\n\\t\\tif ( $path !== $real_path ) {\\n\\t\\t\\t$real_path = wp_normalize_path( $real_path );\\n\\t\\t}\\n\\n\\t\\treturn $real_path;\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/automattic\/jetpack-autoloader\/src\/class-autoloader-handler.php\",\"ext\":\"php\",\"size\":4405,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/* HEADER *\/ \/\/ phpcs:ignore\\n\\nuse Automattic\\\\Jetpack\\\\Autoloader\\\\AutoloadGenerator;\\n\\n\/**\\n * This class selects the package version for the autoloader.\\n *\/\\nclass Autoloader_Handler {\\n\\n\\t\/**\\n\\t * The PHP_Autoloader instance.\\n\\t *\\n\\t * @var PHP_Autoloader\\n\\t *\/\\n\\tprivate $php_autoloader;\\n\\n\\t\/**\\n\\t * The Hook_Manager instance.\\n\\t *\\n\\t * @var Hook_Manager\\n\\t *\/\\n\\tprivate $hook_manager;\\n\\n\\t\/**\\n\\t * The Manifest_Reader instance.\\n\\t *\\n\\t * @var Manifest_Reader\\n\\t *\/\\n\\tprivate $manifest_reader;\\n\\n\\t\/**\\n\\t * The Version_Selector instance.\\n\\t *\\n\\t * @var Version_Selector\\n\\t *\/\\n\\tprivate $version_selector;\\n\\n\\t\/**\\n\\t * The constructor.\\n\\t *\\n\\t * @param PHP_Autoloader   $php_autoloader The PHP_Autoloader instance.\\n\\t * @param Hook_Manager     $hook_manager The Hook_Manager instance.\\n\\t * @param Manifest_Reader  $manifest_reader The Manifest_Reader instance.\\n\\t * @param Version_Selector $version_selector The Version_Selector instance.\\n\\t *\/\\n\\tpublic function __construct( $php_autoloader, $hook_manager, $manifest_reader, $version_selector ) {\\n\\t\\t$this->php_autoloader   = $php_autoloader;\\n\\t\\t$this->hook_manager     = $hook_manager;\\n\\t\\t$this->manifest_reader  = $manifest_reader;\\n\\t\\t$this->version_selector = $version_selector;\\n\\t}\\n\\n\\t\/**\\n\\t * Checks to see whether or not an autoloader is currently in the process of initializing.\\n\\t *\\n\\t * @return bool\\n\\t *\/\\n\\tpublic function is_initializing() {\\n\\t\\t\/\/ If no version has been set it means that no autoloader has started initializing yet.\\n\\t\\tglobal $jetpack_autoloader_latest_version;\\n\\t\\tif ( ! isset( $jetpack_autoloader_latest_version ) ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t\/\/ When the version is set but the classmap is not it ALWAYS means that this is the\\n\\t\\t\/\/ latest autoloader and is being included by an older one.\\n\\t\\tglobal $jetpack_packages_classmap;\\n\\t\\tif ( empty( $jetpack_packages_classmap ) ) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\t\/\/ Version 2.4.0 added a new global and altered the reset semantics. We need to check\\n\\t\\t\/\/ the other global as well since it may also point at initialization.\\n\\t\\t\/\/ Note: We don't need to check for the class first because every autoloader that\\n\\t\\t\/\/ will set the latest version global requires this class in the classmap.\\n\\t\\t$replacing_version = $jetpack_packages_classmap[ AutoloadGenerator::class ]['version'];\\n\\t\\tif ( $this->version_selector->is_dev_version( $replacing_version ) || version_compare( $replacing_version, '2.4.0.0', '>=' ) ) {\\n\\t\\t\\tglobal $jetpack_autoloader_loader;\\n\\t\\t\\tif ( ! isset( $jetpack_autoloader_loader ) ) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\t\/**\\n\\t * Activates an autoloader using the given plugins and activates it.\\n\\t *\\n\\t * @param string[] $plugins The plugins to initialize the autoloader for.\\n\\t *\/\\n\\tpublic function activate_autoloader( $plugins ) {\\n\\t\\tglobal $jetpack_packages_psr4;\\n\\t\\t$jetpack_packages_psr4 = array();\\n\\t\\t$this->manifest_reader->read_manifests( $plugins, 'vendor\/composer\/jetpack_autoload_psr4.php', $jetpack_packages_psr4 );\\n\\n\\t\\tglobal $jetpack_packages_classmap;\\n\\t\\t$jetpack_packages_classmap = array();\\n\\t\\t$this->manifest_reader->read_manifests( $plugins, 'vendor\/composer\/jetpack_autoload_classmap.php', $jetpack_packages_classmap );\\n\\n\\t\\tglobal $jetpack_packages_filemap;\\n\\t\\t$jetpack_packages_filemap = array();\\n\\t\\t$this->manifest_reader->read_manifests( $plugins, 'vendor\/composer\/jetpack_autoload_filemap.php', $jetpack_packages_filemap );\\n\\n\\t\\t$loader = new Version_Loader(\\n\\t\\t\\t$this->version_selector,\\n\\t\\t\\t$jetpack_packages_classmap,\\n\\t\\t\\t$jetpack_packages_psr4,\\n\\t\\t\\t$jetpack_packages_filemap\\n\\t\\t);\\n\\n\\t\\t$this->php_autoloader->register_autoloader( $loader );\\n\\n\\t\\t\/\/ Now that the autoloader is active we can load the filemap.\\n\\t\\t$loader->load_filemap();\\n\\t}\\n\\n\\t\/**\\n\\t * Resets the active autoloader and all related global state.\\n\\t *\/\\n\\tpublic function reset_autoloader() {\\n\\t\\t$this->php_autoloader->unregister_autoloader();\\n\\t\\t$this->hook_manager->reset();\\n\\n\\t\\t\/\/ Clear all of the autoloader globals so that older autoloaders don't do anything strange.\\n\\t\\tglobal $jetpack_autoloader_latest_version;\\n\\t\\t$jetpack_autoloader_latest_version = null;\\n\\n\\t\\tglobal $jetpack_packages_classmap;\\n\\t\\t$jetpack_packages_classmap = array(); \/\/ Must be array to avoid exceptions in old autoloaders!\\n\\n\\t\\tglobal $jetpack_packages_psr4;\\n\\t\\t$jetpack_packages_psr4 = array(); \/\/ Must be array to avoid exceptions in old autoloaders!\\n\\n\\t\\tglobal $jetpack_packages_filemap;\\n\\t\\t$jetpack_packages_filemap = array(); \/\/ Must be array to avoid exceptions in old autoloaders!\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/automattic\/jetpack-autoloader\/src\/class-shutdown-handler.php\",\"ext\":\"php\",\"size\":2691,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/* HEADER *\/ \/\/ phpcs:ignore\\n\\n\/**\\n * This class handles the shutdown of the autoloader.\\n *\/\\nclass Shutdown_Handler {\\n\\n\\t\/**\\n\\t * The Plugins_Handler instance.\\n\\t *\\n\\t * @var Plugins_Handler\\n\\t *\/\\n\\tprivate $plugins_handler;\\n\\n\\t\/**\\n\\t * The plugins cached by this autoloader.\\n\\t *\\n\\t * @var string[]\\n\\t *\/\\n\\tprivate $cached_plugins;\\n\\n\\t\/**\\n\\t * Indicates whether or not this autoloader was included by another.\\n\\t *\\n\\t * @var bool\\n\\t *\/\\n\\tprivate $was_included_by_autoloader;\\n\\n\\t\/**\\n\\t * Constructor.\\n\\t *\\n\\t * @param Plugins_Handler $plugins_handler The Plugins_Handler instance to use.\\n\\t * @param string[]        $cached_plugins The plugins cached by the autoloaer.\\n\\t * @param bool            $was_included_by_autoloader Indicates whether or not the autoloader was included by another.\\n\\t *\/\\n\\tpublic function __construct( $plugins_handler, $cached_plugins, $was_included_by_autoloader ) {\\n\\t\\t$this->plugins_handler            = $plugins_handler;\\n\\t\\t$this->cached_plugins             = $cached_plugins;\\n\\t\\t$this->was_included_by_autoloader = $was_included_by_autoloader;\\n\\t}\\n\\n\\t\/**\\n\\t * Handles the shutdown of the autoloader.\\n\\t *\/\\n\\tpublic function __invoke() {\\n\\t\\t\/\/ Don't save a broken cache if an error happens during some plugin's initialization.\\n\\t\\tif ( ! did_action( 'plugins_loaded' ) ) {\\n\\t\\t\\t\/\/ Ensure that the cache is emptied to prevent consecutive failures if the cache is to blame.\\n\\t\\t\\tif ( ! empty( $this->cached_plugins ) ) {\\n\\t\\t\\t\\t$this->plugins_handler->cache_plugins( array() );\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t\/\/ Load the active plugins fresh since the list we pulled earlier might not contain\\n\\t\\t\/\/ plugins that were activated but did not reset the autoloader. This happens\\n\\t\\t\/\/ when a plugin is in the cache but not \\\"active\\\" when the autoloader loads.\\n\\t\\t\/\/ We also want to make sure that plugins which are deactivating are not\\n\\t\\t\/\/ considered \\\"active\\\" so that they will be removed from the cache now.\\n\\t\\ttry {\\n\\t\\t\\t$active_plugins = $this->plugins_handler->get_active_plugins( false, ! $this->was_included_by_autoloader );\\n\\t\\t} catch ( \\\\Exception $ex ) {\\n\\t\\t\\t\/\/ When the package is deleted before shutdown it will throw an exception.\\n\\t\\t\\t\/\/ In the event this happens we should erase the cache.\\n\\t\\t\\tif ( ! empty( $this->cached_plugins ) ) {\\n\\t\\t\\t\\t$this->plugins_handler->cache_plugins( array() );\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t\/\/ The paths should be sorted for easy comparisons with those loaded from the cache.\\n\\t\\t\/\/ Note we don't need to sort the cached entries because they're already sorted.\\n\\t\\tsort( $active_plugins );\\n\\n\\t\\t\/\/ We don't want to waste time saving a cache that hasn't changed.\\n\\t\\tif ( $this->cached_plugins === $active_plugins ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t$this->plugins_handler->cache_plugins( $active_plugins );\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/automattic\/jetpack-autoloader\/LICENSE.txt\",\"ext\":\"txt\",\"size\":18416,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"This program is free software; you can redistribute it and\/or modify\\nit under the terms of the GNU General Public License as published by\\nthe Free Software Foundation; either version 2 of the License, or\\n(at your option) any later version.\\n\\nThis program is distributed in the hope that it will be useful,\\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\nGNU General Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License\\nalong with this program; if not, write to the Free Software\\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\\n\\n\\n===================================\\n\\n\\nGNU GENERAL PUBLIC LICENSE\\n   Version 2, June 1991\\n\\nCopyright (C) 1989, 1991 Free Software Foundation, Inc.,\\n51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\\nEveryone is permitted to copy and distribute verbatim copies\\nof this license document, but changing it is not allowed.\\n\\n\\t\\tPreamble\\n\\nThe licenses for most software are designed to take away your\\nfreedom to share and change it.  By contrast, the GNU General Public\\nLicense is intended to guarantee your freedom to share and change free\\nsoftware--to make sure the software is free for all its users.  This\\nGeneral Public License applies to most of the Free Software\\nFoundation's software and to any other program whose authors commit to\\nusing it.  (Some other Free Software Foundation software is covered by\\nthe GNU Lesser General Public License instead.)  You can apply it to\\nyour programs, too.\\n\\nWhen we speak of free software, we are referring to freedom, not\\nprice.  Our General Public Licenses are designed to make sure that you\\nhave the freedom to distribute copies of free software (and charge for\\nthis service if you wish), that you receive source code or can get it\\nif you want it, that you can change the software or use pieces of it\\nin new free programs; and that you know you can do these things.\\n\\nTo protect your rights, we need to make restrictions that forbid\\nanyone to deny you these rights or to ask you to surrender the rights.\\nThese restrictions translate to certain responsibilities for you if you\\ndistribute copies of the software, or if you modify it.\\n\\nFor example, if you distribute copies of such a program, whether\\ngratis or for a fee, you must give the recipients all the rights that\\nyou have.  You must make sure that they, too, receive or can get the\\nsource code.  And you must show them these terms so they know their\\nrights.\\n\\nWe protect your rights with two steps: (1) copyright the software, and\\n(2) offer you this license which gives you legal permission to copy,\\ndistribute and\/or modify the software.\\n\\nAlso, for each author's protection and ours, we want to make certain\\nthat everyone understands that there is no warranty for this free\\nsoftware.  If the software is modified by someone else and passed on, we\\nwant its recipients to know that what they have is not the original, so\\nthat any problems introduced by others will not reflect on the original\\nauthors' reputations.\\n\\nFinally, any free program is threatened constantly by software\\npatents.  We wish to avoid the danger that redistributors of a free\\nprogram will individually obtain patent licenses, in effect making the\\nprogram proprietary.  To prevent this, we have made it clear that any\\npatent must be licensed for everyone's free use or not licensed at all.\\n\\nThe precise terms and conditions for copying, distribution and\\nmodification follow.\\n\\nGNU GENERAL PUBLIC LICENSE\\nTERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\\n\\n0. This License applies to any program or other work which contains\\na notice placed by the copyright holder saying it may be distributed\\nunder the terms of this General Public License.  The \\\"Program\\\", below,\\nrefers to any such program or work, and a \\\"work based on the Program\\\"\\nmeans either the Program or any derivative work under copyright law:\\nthat is to say, a work containing the Program or a portion of it,\\neither verbatim or with modifications and\/or translated into another\\nlanguage.  (Hereinafter, translation is included without limitation in\\nthe term \\\"modification\\\".)  Each licensee is addressed as \\\"you\\\".\\n\\nActivities other than copying, distribution and modification are not\\ncovered by this License; they are outside its scope.  The act of\\nrunning the Program is not restricted, and the output from the Program\\nis covered only if its contents constitute a work based on the\\nProgram (independent of having been made by running the Program).\\nWhether that is true depends on what the Program does.\\n\\n1. You may copy and distribute verbatim copies of the Program's\\nsource code as you receive it, in any medium, provided that you\\nconspicuously and appropriately publish on each copy an appropriate\\ncopyright notice and disclaimer of warranty; keep intact all the\\nnotices that refer to this License and to the absence of any warranty;\\nand give any other recipients of the Program a copy of this License\\nalong with the Program.\\n\\nYou may charge a fee for the physical act of transferring a copy, and\\nyou may at your option offer warranty protection in exchange for a fee.\\n\\n2. You may modify your copy or copies of the Program or any portion\\nof it, thus forming a work based on the Program, and copy and\\ndistribute such modifications or work under the terms of Section 1\\nabove, provided that you also meet all of these conditions:\\n\\na) You must cause the modified files to carry prominent notices\\nstating that you changed the files and the date of any change.\\n\\nb) You must cause any work that you distribute or publish, that in\\nwhole or in part contains or is derived from the Program or any\\npart thereof, to be licensed as a whole at no charge to all third\\nparties under the terms of this License.\\n\\nc) If the modified program normally reads commands interactively\\nwhen run, you must cause it, when started running for such\\ninteractive use in the most ordinary way, to print or display an\\nannouncement including an appropriate copyright notice and a\\nnotice that there is no warranty (or else, saying that you provide\\na warranty) and that users may redistribute the program under\\nthese conditions, and telling the user how to view a copy of this\\nLicense.  (Exception: if the Program itself is interactive but\\ndoes not normally print such an announcement, your work based on\\nthe Program is not required to print an announcement.)\\n\\nThese requirements apply to the modified work as a whole.  If\\nidentifiable sections of that work are not derived from the Program,\\nand can be reasonably considered independent and separate works in\\nthemselves, then this License, and its terms, do not apply to those\\nsections when you distribute them as separate works.  But when you\\ndistribute the same sections as part of a whole which is a work based\\non the Program, the distribution of the whole must be on the terms of\\nthis License, whose permissions for other licensees extend to the\\nentire whole, and thus to each and every part regardless of who wrote it.\\n\\nThus, it is not the intent of this section to claim rights or contest\\nyour rights to work written entirely by you; rather, the intent is to\\nexercise the right to control the distribution of derivative or\\ncollective works based on the Program.\\n\\nIn addition, mere aggregation of another work not based on the Program\\nwith the Program (or with a work based on the Program) on a volume of\\na storage or distribution medium does not bring the other work under\\nthe scope of this License.\\n\\n3. You may copy and distribute the Program (or a work based on it,\\nunder Section 2) in object code or executable form under the terms of\\nSections 1 and 2 above provided that you also do one of the following:\\n\\na) Accompany it with the complete corresponding machine-readable\\nsource code, which must be distributed under the terms of Sections\\n1 and 2 above on a medium customarily used for software interchange; or,\\n\\nb) Accompany it with a written offer, valid for at least three\\nyears, to give any third party, for a charge no more than your\\ncost of physically performing source distribution, a complete\\nmachine-readable copy of the corresponding source code, to be\\ndistributed under the terms of Sections 1 and 2 above on a medium\\ncustomarily used for software interchange; or,\\n\\nc) Accompany it with the information you received as to the offer\\nto distribute corresponding source code.  (This alternative is\\nallowed only for noncommercial distribution and only if you\\nreceived the program in object code or executable form with such\\nan offer, in accord with Subsection b above.)\\n\\nThe source code for a work means the preferred form of the work for\\nmaking modifications to it.  For an executable work, complete source\\ncode means all the source code for all modules it contains, plus any\\nassociated interface definition files, plus the scripts used to\\ncontrol compilation and installation of the executable.  However, as a\\nspecial exception, the source code distributed need not include\\nanything that is normally distributed (in either source or binary\\nform) with the major components (compiler, kernel, and so on) of the\\noperating system on which the executable runs, unless that component\\nitself accompanies the executable.\\n\\nIf distribution of executable or object code is made by offering\\naccess to copy from a designated place, then offering equivalent\\naccess to copy the source code from the same place counts as\\ndistribution of the source code, even though third parties are not\\ncompelled to copy the source along with the object code.\\n\\n4. You may not copy, modify, sublicense, or distribute the Program\\nexcept as expressly provided under this License.  Any attempt\\notherwise to copy, modify, sublicense or distribute the Program is\\nvoid, and will automatically terminate your rights under this License.\\nHowever, parties who have received copies, or rights, from you under\\nthis License will not have their licenses terminated so long as such\\nparties remain in full compliance.\\n\\n5. You are not required to accept this License, since you have not\\nsigned it.  However, nothing else grants you permission to modify or\\ndistribute the Program or its derivative works.  These actions are\\nprohibited by law if you do not accept this License.  Therefore, by\\nmodifying or distributing the Program (or any work based on the\\nProgram), you indicate your acceptance of this License to do so, and\\nall its terms and conditions for copying, distributing or modifying\\nthe Program or works based on it.\\n\\n6. Each time you redistribute the Program (or any work based on the\\nProgram), the recipient automatically receives a license from the\\noriginal licensor to copy, distribute or modify the Program subject to\\nthese terms and conditions.  You may not impose any further\\nrestrictions on the recipients' exercise of the rights granted herein.\\nYou are not responsible for enforcing compliance by third parties to\\nthis License.\\n\\n7. If, as a consequence of a court judgment or allegation of patent\\ninfringement or for any other reason (not limited to patent issues),\\nconditions are imposed on you (whether by court order, agreement or\\notherwise) that contradict the conditions of this License, they do not\\nexcuse you from the conditions of this License.  If you cannot\\ndistribute so as to satisfy simultaneously your obligations under this\\nLicense and any other pertinent obligations, then as a consequence you\\nmay not distribute the Program at all.  For example, if a patent\\nlicense would not permit royalty-free redistribution of the Program by\\nall those who receive copies directly or indirectly through you, then\\nthe only way you could satisfy both it and this License would be to\\nrefrain entirely from distribution of the Program.\\n\\nIf any portion of this section is held invalid or unenforceable under\\nany particular circumstance, the balance of the section is intended to\\napply and the section as a whole is intended to apply in other\\ncircumstances.\\n\\nIt is not the purpose of this section to induce you to infringe any\\npatents or other property right claims or to contest validity of any\\nsuch claims; this section has the sole purpose of protecting the\\nintegrity of the free software distribution system, which is\\nimplemented by public license practices.  Many people have made\\ngenerous contributions to the wide range of software distributed\\nthrough that system in reliance on consistent application of that\\nsystem; it is up to the author\/donor to decide if he or she is willing\\nto distribute software through any other system and a licensee cannot\\nimpose that choice.\\n\\nThis section is intended to make thoroughly clear what is believed to\\nbe a consequence of the rest of this License.\\n\\n8. If the distribution and\/or use of the Program is restricted in\\ncertain countries either by patents or by copyrighted interfaces, the\\noriginal copyright holder who places the Program under this License\\nmay add an explicit geographical distribution limitation excluding\\nthose countries, so that distribution is permitted only in or among\\ncountries not thus excluded.  In such case, this License incorporates\\nthe limitation as if written in the body of this License.\\n\\n9. The Free Software Foundation may publish revised and\/or new versions\\nof the General Public License from time to time.  Such new versions will\\nbe similar in spirit to the present version, but may differ in detail to\\naddress new problems or concerns.\\n\\nEach version is given a distinguishing version number.  If the Program\\nspecifies a version number of this License which applies to it and \\\"any\\nlater version\\\", you have the option of following the terms and conditions\\neither of that version or of any later version published by the Free\\nSoftware Foundation.  If the Program does not specify a version number of\\nthis License, you may choose any version ever published by the Free Software\\nFoundation.\\n\\n10. If you wish to incorporate parts of the Program into other free\\nprograms whose distribution conditions are different, write to the author\\nto ask for permission.  For software which is copyrighted by the Free\\nSoftware Foundation, write to the Free Software Foundation; we sometimes\\nmake exceptions for this.  Our decision will be guided by the two goals\\nof preserving the free status of all derivatives of our free software and\\nof promoting the sharing and reuse of software generally.\\n\\n\\t\\tNO WARRANTY\\n\\n11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND\/OR OTHER PARTIES\\nPROVIDE THE PROGRAM \\\"AS IS\\\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\\nREPAIR OR CORRECTION.\\n\\n12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND\/OR\\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\\nPOSSIBILITY OF SUCH DAMAGES.\\n\\n END OF TERMS AND CONDITIONS\\n\\nHow to Apply These Terms to Your New Programs\\n\\nIf you develop a new program, and you want it to be of the greatest\\npossible use to the public, the best way to achieve this is to make it\\nfree software which everyone can redistribute and change under these terms.\\n\\nTo do so, attach the following notices to the program.  It is safest\\nto attach them to the start of each source file to most effectively\\nconvey the exclusion of warranty; and each file should have at least\\nthe \\\"copyright\\\" line and a pointer to where the full notice is found.\\n\\n<one line to give the program's name and a brief idea of what it does.>\\nCopyright (C) <year>  <name of author>\\n\\nThis program is free software; you can redistribute it and\/or modify\\nit under the terms of the GNU General Public License as published by\\nthe Free Software Foundation; either version 2 of the License, or\\n(at your option) any later version.\\n\\nThis program is distributed in the hope that it will be useful,\\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\nGNU General Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License along\\nwith this program; if not, write to the Free Software Foundation, Inc.,\\n51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\\n\\nAlso add information on how to contact you by electronic and paper mail.\\n\\nIf the program is interactive, make it output a short notice like this\\nwhen it starts in an interactive mode:\\n\\nGnomovision version 69, Copyright (C) year name of author\\nGnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\\nThis is free software, and you are welcome to redistribute it\\nunder certain conditions; type `show c' for details.\\n\\nThe hypothetical commands `show w' and `show c' should show the appropriate\\nparts of the General Public License.  Of course, the commands you use may\\nbe called something other than `show w' and `show c'; they could even be\\nmouse-clicks or menu items--whatever suits your program.\\n\\nYou should also get your employer (if you work as a programmer) or your\\nschool, if any, to sign a \\\"copyright disclaimer\\\" for the program, if\\nnecessary.  Here is a sample; alter the names:\\n\\nYoyodyne, Inc., hereby disclaims all copyright interest in the program\\n`Gnomovision' (which makes passes at compilers) written by James Hacker.\\n\\n<signature of Ty Coon>, 1 April 1989\\nTy Coon, President of Vice\\n\\nThis General Public License does not permit incorporating your program into\\nproprietary programs.  If your program is a subroutine library, you may\\nconsider it more useful to permit linking proprietary applications with the\\nlibrary.  If this is what you want to do, use the GNU Lesser General\\nPublic License instead of this License.\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/class-pipeline.php\",\"ext\":\"php\",\"size\":5337,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Pipeline class file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support;\\n\\nuse Closure;\\nuse Mantle\\\\Contracts\\\\Container;\\nuse Mantle\\\\Contracts\\\\Pipeline as PipelineContract;\\nuse Mantle\\\\Support\\\\Traits\\\\Makeable;\\nuse RuntimeException;\\nuse Throwable;\\n\\n\/**\\n * Middleware Pipeline\\n *\/\\nclass Pipeline implements PipelineContract {\\n\\tuse Makeable;\\n\\n\\t\/**\\n\\t * The object being passed through the pipeline.\\n\\t *\\n\\t * @var mixed\\n\\t *\/\\n\\tprotected $passable;\\n\\n\\t\/**\\n\\t * The array of class pipes.\\n\\t *\\n\\t * @var array<mixed>\\n\\t *\/\\n\\tprotected $pipes = [];\\n\\n\\t\/**\\n\\t * The method to call on each pipe.\\n\\t *\\n\\t * @var string\\n\\t *\/\\n\\tprotected $method = 'handle';\\n\\n\\t\/**\\n\\t * Create a new class instance.\\n\\t *\\n\\t * @param Container|null $container Container instance.\\n\\t *\/\\n\\tpublic function __construct( protected ?Container $container = null ) {\\n\\t}\\n\\n\\t\/**\\n\\t * Set the object being sent through the pipeline.\\n\\t *\\n\\t * @param mixed $passable Data to send through the pipeline.\\n\\t *\/\\n\\tpublic function send( $passable ): static {\\n\\t\\t$this->passable = $passable;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the array of pipes.\\n\\t *\\n\\t * @param  array<callable>|null $pipes\\n\\t *\/\\n\\tpublic function through( $pipes ): static {\\n\\t\\t$this->pipes = is_array( $pipes ) ? $pipes : func_get_args();\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the method to call on the pipes.\\n\\t *\\n\\t * @param  string $method\\n\\t *\/\\n\\tpublic function via( $method ): static {\\n\\t\\t$this->method = $method;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Run the pipeline with a final destination callback.\\n\\t *\\n\\t * @param  \\\\Closure $destination\\n\\t * @return mixed\\n\\t *\/\\n\\tpublic function then( Closure $destination ) {\\n\\t\\t$pipeline = array_reduce(\\n\\t\\t\\tarray_reverse( $this->pipes() ),\\n\\t\\t\\t$this->carry(),\\n\\t\\t\\t$this->prepare_destination( $destination )\\n\\t\\t);\\n\\n\\t\\treturn $pipeline( $this->passable );\\n\\t}\\n\\n\\t\/**\\n\\t * Run the pipeline and return the result.\\n\\t *\\n\\t * @return mixed\\n\\t *\/\\n\\tpublic function thenReturn() {\\n\\t\\treturn $this->then( fn ( $passable ) => $passable );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the final piece of the Closure onion.\\n\\t *\\n\\t * @param  \\\\Closure $destination\\n\\t * @return \\\\Closure\\n\\t *\/\\n\\tprotected function prepare_destination( Closure $destination ) {\\n\\t\\treturn function ( $passable ) use ( $destination ) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\treturn $destination( $passable );\\n\\t\\t\\t} catch ( Throwable $e ) {\\n\\t\\t\\t\\treturn $this->handle_exception( $passable, $e );\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n\\n\\t\/**\\n\\t * Get a Closure that represents a slice of the application onion.\\n\\t *\\n\\t * @return \\\\Closure\\n\\t *\/\\n\\tprotected function carry() {\\n\\t\\treturn fn ( $stack, $pipe ) => function ( $passable ) use ( $stack, $pipe ) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tif ( is_callable( $pipe ) ) {\\n\\t\\t\\t\\t\\t\/\/ If the pipe is a callable, then we will call it directly, but otherwise we\\n\\t\\t\\t\\t\\t\/\/ will resolve the pipes out of the dependency container and call it with\\n\\t\\t\\t\\t\\t\/\/ the appropriate method and arguments, returning the results back out.\\n\\t\\t\\t\\t\\treturn $pipe( $passable, $stack );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( ! is_object( $pipe ) ) {\\n\\t\\t\\t\\t\\t[ $name, $parameters] = $this->parse_pipe_string( $pipe );\\n\\n\\t\\t\\t\\t\\t\/\/ If the pipe is a string we will parse the string and resolve the class out\\n\\t\\t\\t\\t\\t\/\/ of the dependency injection container. We can then build a callable and\\n\\t\\t\\t\\t\\t\/\/ execute the pipe function giving in the parameters that are required.\\n\\t\\t\\t\\t\\t$pipe = $this->get_container()->make( $name );\\n\\n\\t\\t\\t\\t\\t$parameters = array_merge( [ $passable, $stack ], $parameters );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\/\/ If the pipe is already an object we'll just make a callable and pass it to\\n\\t\\t\\t\\t\\t\/\/ the pipe as-is. There is no need to do any extra parsing and formatting\\n\\t\\t\\t\\t\\t\/\/ since the object we're given was already a fully instantiated object.\\n\\t\\t\\t\\t\\t$parameters = [ $passable, $stack ];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t$carry = method_exists( $pipe, $this->method )\\n\\t\\t\\t\\t\\t? $pipe->{$this->method}( ...$parameters )\\n\\t\\t\\t\\t\\t: $pipe( ...$parameters );\\n\\n\\t\\t\\t\\treturn $this->handle_carry( $carry );\\n\\t\\t\\t} catch ( Throwable $e ) {\\n\\t\\t\\t\\treturn $this->handle_exception( $passable, $e );\\n\\t\\t\\t}\\n\\t\\t}; \/\/ phpcs:ignore Generic.CodeAnalysis.EmptyPHPStatement.SemicolonWithoutCodeDetected\\n\\t}\\n\\n\\t\/**\\n\\t * Parse full pipe string to get name and parameters.\\n\\t *\\n\\t * @param  string $pipe\\n\\t * @return array{0: string, 1: array<mixed>}\\n\\t *\/\\n\\tprotected function parse_pipe_string( $pipe ): array {\\n\\t\\t[$name, $parameters] = array_pad( explode( ':', $pipe, 2 ), 2, [] );\\n\\n\\t\\tif ( is_string( $parameters ) ) {\\n\\t\\t\\t$parameters = explode( ',', $parameters );\\n\\t\\t}\\n\\n\\t\\treturn [ $name, $parameters ];\\n\\t}\\n\\n\\t\/**\\n\\t * Get the array of configured pipes.\\n\\t *\\n\\t * @return array<mixed>\\n\\t *\/\\n\\tprotected function pipes() {\\n\\t\\treturn $this->pipes;\\n\\t}\\n\\n\\t\/**\\n\\t * Get the container instance.\\n\\t *\\n\\t * @throws RuntimeException Thrown on missing container instance.\\n\\t *\/\\n\\tprotected function get_container(): Container {\\n\\t\\tif ( ! isset( $this->container ) ) {\\n\\t\\t\\tthrow new RuntimeException( 'A container instance has not been passed to the Pipeline.' );\\n\\t\\t}\\n\\n\\t\\treturn $this->container;\\n\\t}\\n\\n\\t\/**\\n\\t * Handle the value returned from each pipe before passing it to the next.\\n\\t *\\n\\t * @param  mixed $carry\\n\\t * @return mixed\\n\\t *\/\\n\\tprotected function handle_carry( $carry ) {\\n\\t\\treturn $carry;\\n\\t}\\n\\n\\t\/**\\n\\t * Handle the given exception.\\n\\t *\\n\\t * @param mixed     $passable Passable object.\\n\\t * @param Throwable $e Exception thrown.\\n\\t *\\n\\t * @throws Throwable Thrown when an exception is passed.\\n\\t *\/\\n\\tprotected function handle_exception( $passable, Throwable $e ): never {\\n\\t\\tthrow $e;\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/class-uri-query-string.php\",\"ext\":\"php\",\"size\":2641,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Uri_Query_String class file\\n *\\n * @package mantle\\n *\/\\n\\nnamespace Mantle\\\\Support;\\n\\nuse Mantle\\\\Contracts\\\\Support\\\\Arrayable;\\nuse League\\\\Uri\\\\QueryString;\\nuse Stringable;\\n\\nuse function Mantle\\\\Support\\\\Helpers\\\\data_get;\\n\\n\/**\\n * URI Query String\\n *\\n * Manage the query string of Uri.\\n *\/\\nclass Uri_Query_String implements Arrayable, Stringable {\\n\\n\\t\/**\\n\\t * Parsed query string.\\n\\t *\\n\\t * @var array<string, mixed>\\n\\t *\/\\n\\tprotected array $parsed_query;\\n\\n\\t\/**\\n\\t * Create a new URI query string instance.\\n\\t *\\n\\t * @param Uri $uri The URI instance containing the query string.\\n\\t *\/\\n\\tpublic function __construct( protected Uri $uri ) {\\n\\t\\t$this->parsed_query = QueryString::extract( $this->uri->get_uri()->getQuery() );\\n\\t}\\n\\n\\t\/**\\n\\t * Retrieve a value from the query string.\\n\\t *\\n\\t * @param string $property Property name to retrieve.\\n\\t * @param mixed  $default  Default value to return if the property does not exist.\\n\\t *\/\\n\\tpublic function get( string $property, mixed $default = null ): mixed {\\n\\t\\treturn data_get( $this->parsed_query, $property, $default );\\n\\t}\\n\\n\\t\/**\\n\\t * Retrieved a value from the query string as Mixed_Data object.\\n\\t *\\n\\t * @param string $property Property name to retrieve.\\n\\t * @param mixed  $default   Default value to return if the property does not exist.\\n\\t *\/\\n\\tpublic function mixed( string $property, mixed $default = null ): Mixed_Data {\\n\\t\\treturn Mixed_Data::of( $this->get( $property, $default ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Retrieve all values from the query string as an array.\\n\\t *\\n\\t * @return array<string, mixed>\\n\\t *\/\\n\\tpublic function all(): array {\\n\\t\\treturn $this->parsed_query;\\n\\t}\\n\\n\\t\/**\\n\\t * Convert the query string to an array.\\n\\t *\\n\\t * @return array<string, mixed>\\n\\t *\/\\n\\tpublic function to_array(): array {\\n\\t\\treturn $this->parsed_query;\\n\\t}\\n\\n\\t\/**\\n\\t * Check if a property exists in the query string.\\n\\t *\\n\\t * @param string $property Property name to check for existence.\\n\\t *\/\\n\\tpublic function has( string $property ): bool {\\n\\t\\treturn array_key_exists( $property, $this->parsed_query );\\n\\t}\\n\\n\\t\/**\\n\\t * Check if the query string is missing a property.\\n\\t *\\n\\t * @param string $property Property name to check for absence.\\n\\t *\/\\n\\tpublic function missing( string $property ): bool {\\n\\t\\treturn ! $this->has( $property );\\n\\t}\\n\\n\\t\/**\\n\\t * Retrieve the query string value.\\n\\t *\/\\n\\tpublic function value(): string {\\n\\t\\treturn (string) $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Get the URL decoded version of the query string.\\n\\t *\/\\n\\tpublic function decode(): string {\\n\\t\\treturn rawurldecode( (string) $this );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the string representation of the query string.\\n\\t *\/\\n\\tpublic function __toString(): string {\\n\\t\\treturn (string) $this->uri->get_uri()->getQuery();\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/trait-forward-calls.php\",\"ext\":\"php\",\"size\":1501,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Forward_Calls trait file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support;\\n\\nuse BadMethodCallException;\\nuse Error;\\n\\n\/**\\n * Trait to forward calls to a method in an object.\\n *\/\\ntrait Forward_Calls {\\n\\t\/**\\n\\t * Forward a method call to the given object.\\n\\t *\\n\\t * @param mixed        $object Object to use.\\n\\t * @param string       $method Method to call.\\n\\t * @param array<mixed> $parameters Method parameters.\\n\\t *\\n\\t * @throws \\\\BadMethodCallException Thrown on method exception.\\n\\t * @throws \\\\Error Thrown on method exception.\\n\\t *\/\\n\\tprotected function forward_call_to( mixed $object, string $method, array $parameters ): mixed {\\n\\t\\ttry {\\n\\t\\t\\treturn $object->{ $method }( ...$parameters );\\n\\t\\t} catch ( Error | BadMethodCallException $e ) {\\n\\t\\t\\t$pattern = '~^Call to undefined method (?P<class>[^:]+)::(?P<method>[^\\\\(]+)\\\\(\\\\)$~';\\n\\n\\t\\t\\tif ( ! preg_match( $pattern, $e->getMessage(), $matches ) ) {\\n\\t\\t\\t\\tthrow $e;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (\\n\\t\\t\\t\\t$object::class !== $matches['class']\\n\\t\\t\\t\\t|| $matches['method'] !== $method\\n\\t\\t\\t) {\\n\\t\\t\\t\\tthrow $e;\\n\\t\\t\\t}\\n\\n\\t\\t\\tstatic::throw_bad_method_call_exception( $method );\\n\\t\\t}\\n\\t}\\n\\n\\t\/**\\n\\t * Throw a bad method call exception for the given method.\\n\\t *\\n\\t * @param string $method Method name.\\n\\t *\\n\\t * @throws \\\\BadMethodCallException Thrown on invalid method call.\\n\\t *\/\\n\\tprotected static function throw_bad_method_call_exception( string $method ): never {\\n\\t\\tthrow new BadMethodCallException(\\n\\t\\t\\tsprintf(\\n\\t\\t\\t\\t'Call to undefined method %s::%s()',\\n\\t\\t\\t\\tstatic::class,\\n\\t\\t\\t\\t$method\\n\\t\\t\\t)\\n\\t\\t);\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/internal\/class-html-helpers.php\",\"ext\":\"php\",\"size\":2609,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Crawler_Helpers class file\\n *\\n * phpcs:disable\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support\\\\Internal;\\n\\n\/**\\n * Helpers that exist in Symfony's DomCrawler but are not accessible because\\n * they are private.\\n *\\n * These methods are kept as-is and not converted to WordPress-style code to\\n * make updating them easier.\\n *\\n * @access private\\n *\/\\nreadonly class HTML_Helpers {\\n\\t\/**\\n\\t * Helper function for getting a body element\\n\\t * from an HTML fragment\\n\\t *\\n\\t * @access private\\n\\t *\\n\\t * @param string $html A fragment of HTML code\\n\\t * @param string $charset\\n\\t * @return \\\\DOMNode The body node containing child nodes created from the HTML fragment\\n\\t *\/\\n\\tpublic static function get_body_node_from_html_fragment( $html, string $charset = 'UTF-8' ): \\\\DOMNode {\\n\\t\\t$html = '<html><body>' . $html . '<\/body><\/html>';\\n\\n\\t\\treturn self::parseXhtml( $html, $charset )->getElementsByTagName( 'body' )->item( 0 );\\n\\t}\\n\\n\\t\/**\\n\\t * Function originally taken from Symfony\\\\Component\\\\DomCrawler\\\\Crawler\\n\\t * (c) Fabien Potencier <fabien@symfony.com>\\n\\t * License: MIT\\n\\t *\\n\\t * @access private\\n\\t *\/\\n\\tprivate static function parseXhtml( string $htmlContent, string $charset = 'UTF-8' ): \\\\DOMDocument {\\n\\t\\t$htmlContent = self::convertToHtmlEntities( $htmlContent, $charset );\\n\\n\\t\\t$internalErrors = libxml_use_internal_errors( true );\\n\\n\\t\\t$dom                  = new \\\\DOMDocument( '1.0', $charset );\\n\\t\\t$dom->validateOnParse = true;\\n\\n\\t\\tif ( '' !== trim( $htmlContent ) ) {\\n\\t\\t\\t\/\/ PHP DOMDocument->loadHTML method tends to \\\"eat\\\" closing tags in html strings within script elements\\n\\t\\t\\t\/\/ Option LIBXML_SCHEMA_CREATE seems to prevent this\\n\\t\\t\\t\/\/ see https:\/\/stackoverflow.com\/questions\/24575136\/domdocument-removes-html-tags-in-javascript-string.\\n\\t\\t\\t@$dom->loadHTML( $htmlContent, \\\\LIBXML_SCHEMA_CREATE );\\n\\t\\t}\\n\\n\\t\\tlibxml_use_internal_errors( $internalErrors );\\n\\n\\t\\treturn $dom;\\n\\t}\\n\\n\\t\/**\\n\\t * Converts charset to HTML-entities to ensure valid parsing.\\n\\t *\\n\\t * @throws \\\\Exception Thrown on internal error.\\n\\t * @access private\\n\\t *\/\\n\\tprivate static function convertToHtmlEntities( string $htmlContent, string $charset = 'UTF-8' ): string {\\n\\t\\tset_error_handler( static fn () => throw new \\\\Exception() );\\n\\n\\t\\ttry {\\n\\t\\t\\treturn mb_encode_numericentity( $htmlContent, [ 0x80, 0x10FFFF, 0, 0x1FFFFF ], $charset );\\n\\t\\t} catch ( \\\\Exception | \\\\ValueError ) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t$htmlContent = iconv( $charset, 'UTF-8', $htmlContent );\\n\\t\\t\\t\\t\\t$htmlContent = mb_encode_numericentity( $htmlContent, [ 0x80, 0x10FFFF, 0, 0x1FFFFF ], 'UTF-8' );\\n\\t\\t\\t} catch ( \\\\Exception | \\\\ValueError ) {}\\n\\n\\t\\t\\treturn $htmlContent;\\n\\t\\t} finally {\\n\\t\\t\\trestore_error_handler();\\n\\t\\t}\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/class-collection.php\",\"ext\":\"php\",\"size\":37396,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Collections class file.\\n *\\n * phpcs:disable Squiz.Commenting.FunctionComment.MissingParamComment, Squiz.Commenting.FunctionComment.MissingParamTag\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support;\\n\\nuse ArrayAccess;\\nuse ArrayIterator;\\nuse Mantle\\\\Contracts\\\\Support\\\\Arrayable;\\nuse Mantle\\\\Database\\\\Model;\\nuse Mantle\\\\Support\\\\Traits\\\\Enumerates_Values;\\nuse stdClass;\\nuse Traversable;\\n\\nuse function Mantle\\\\Support\\\\Helpers\\\\data_get;\\nuse function Mantle\\\\Support\\\\Helpers\\\\value;\\n\\n\/**\\n * Collection\\n *\\n * @template TKey of array-key = array-key\\n * @template TValue = mixed\\n *\\n * @implements \\\\ArrayAccess<TKey, TValue>\\n * @implements \\\\Mantle\\\\Support\\\\Enumerable<TKey, TValue>\\n *\/\\nclass Collection implements ArrayAccess, Enumerable {\\n\\t\/**\\n\\t * The enumerated values trait.\\n\\t *\\n\\t * @use Enumerates_Values<TKey, TValue>\\n\\t *\/\\n\\tuse Enumerates_Values;\\n\\n\\t\/**\\n\\t * The items contained in the collection.\\n\\t *\\n\\t * @var array<TKey, TValue>\\n\\t *\/\\n\\tprotected $items = [];\\n\\n\\t\/**\\n\\t * Create a new collection.\\n\\t *\\n\\t * @param iterable<TKey, TValue> $items\\n\\t * @return void\\n\\t *\/\\n\\tpublic function __construct( $items = [] ) {\\n\\t\\t$this->items = $this->get_arrayable_items( $items );\\n\\t}\\n\\n\\t\/**\\n\\t * Create a new collection from some known WordPress object.\\n\\t *\\n\\t * Falls back to the normal constructor if $value is unrecognized.\\n\\t *\\n\\t * @template TValueFrom\\n\\t *\\n\\t * @param iterable<array-key, TValueFrom>|\\\\WP_Query $value\\n\\t * @return static<int, TValueFrom>\\n\\t *\/\\n\\tpublic static function from( $value ) {\\n\\t\\tglobal $post;\\n\\t\\tif ( $value instanceof \\\\WP_Query ) {\\n\\t\\t\\t$items = [];\\n\\t\\t\\twhile ( $value->have_posts() ) {\\n\\t\\t\\t\\t$value->the_post();\\n\\n\\t\\t\\t\\t$model = Model\\\\Post::find( $post );\\n\\n\\t\\t\\t\\tif ( $model instanceof \\\\Mantle\\\\Database\\\\Model\\\\Post ) {\\n\\t\\t\\t\\t\\t$items[] = $model;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn new static( $items );\\n\\t\\t}\\n\\n\\t\\treturn ( new static( $value ) )->values();\\n\\t}\\n\\n\\t\/**\\n\\t * Create a new collection by invoking the callback a given amount of times.\\n\\t *\\n\\t * @template TTimesValue\\n\\t *\\n\\t * @param  int                               $number\\n\\t * @param  (callable(int): TTimesValue)|null $callback\\n\\t * @return static<int, TTimesValue>\\n\\t *\/\\n\\tpublic static function times( $number, ?callable $callback = null ) {\\n\\t\\tif ( $number < 1 ) {\\n\\t\\t\\treturn new static();\\n\\t\\t}\\n\\n\\t\\tif ( is_null( $callback ) ) {\\n\\t\\t\\treturn new static( range( 1, $number ) );\\n\\t\\t}\\n\\n\\t\\treturn ( new static( range( 1, $number ) ) )->map( $callback );\\n\\t}\\n\\n\\t\/**\\n\\t * Get all of the items in the collection.\\n\\t *\\n\\t * @return array<TKey, TValue>\\n\\t *\/\\n\\tpublic function all() {\\n\\t\\treturn $this->items;\\n\\t}\\n\\n\\t\/**\\n\\t * Get the average value of a given key.\\n\\t *\\n\\t * @param  (callable(TValue): float|int)|string|null $callback\\n\\t *\/\\n\\tpublic function avg( $callback = null ): int|float|null {\\n\\t\\t$callback = $this->value_retriever( $callback );\\n\\n\\t\\t$items = $this->map(\\n\\t\\t\\tfn ( $value ) => $callback( $value ),\\n\\t\\t)->filter(\\n\\t\\t\\tfn ( $value ) => ! is_null( $value ),\\n\\t\\t);\\n\\n\\t\\t$count = $items->count();\\n\\n\\t\\tif ( $count ) {\\n\\t\\t\\treturn $items->sum() \/ $count;\\n\\t\\t}\\n\\n\\t\\treturn null;\\n\\t}\\n\\n\\t\/**\\n\\t * Get the median of a given key.\\n\\t *\\n\\t * @param  string|array<array-key, string>|null $key\\n\\t * @return float|int|null\\n\\t *\/\\n\\tpublic function median( $key = null ) {\\n\\t\\t$values = ( isset( $key ) ? $this->pluck( $key ) : $this )\\n\\t\\t\\t->filter(\\n\\t\\t\\t\\tfn ( $item ) => ! is_null( $item )\\n\\t\\t\\t)->sort()->values();\\n\\n\\n\\t\\t$count = $values->count();\\n\\n\\t\\tif ( 0 === $count ) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\t$middle = (int) ( $count \/ 2 );\\n\\n\\t\\tif ( $count % 2 !== 0 ) {\\n\\t\\t\\treturn $values->get( $middle );\\n\\t\\t}\\n\\n\\t\\treturn ( new static(\\n\\t\\t\\t[\\n\\t\\t\\t\\t$values->get( $middle - 1 ),\\n\\t\\t\\t\\t$values->get( $middle ),\\n\\t\\t\\t]\\n\\t\\t) )->average();\\n\\t}\\n\\n\\t\/**\\n\\t * Get the mode of a given key.\\n\\t *\\n\\t * @param  string|array<array-key, string>|null $key\\n\\t * @return array<int, float|int>|null\\n\\t *\/\\n\\tpublic function mode( $key = null ) {\\n\\t\\tif ( $this->count() === 0 ) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\t$collection = isset( $key ) ? $this->pluck( $key ) : $this;\\n\\n\\t\\t$counts = new self();\\n\\n\\t\\t$collection->each(\\n\\t\\t\\tfunction ( $value ) use ( $counts ): void {\\n\\t\\t\\t\\t$counts[ $value ] = isset( $counts[ $value ] ) ? $counts[ $value ] + 1 : 1;\\n\\t\\t\\t}\\n\\t\\t);\\n\\n\\t\\t$sorted = $counts->sort();\\n\\n\\t\\t$highest_value = $sorted->last();\\n\\n\\t\\treturn $sorted->filter(\\n\\t\\t\\tfn ( $value ) => $value == $highest_value \/\/ phpcs:ignore WordPress.PHP.StrictComparisons.LooseComparison, Universal.Operators.StrictComparisons.LooseEqual\\n\\t\\t)->sort()->keys()->all();\\n\\t}\\n\\n\\t\/**\\n\\t * Collapse the collection of items into a single array.\\n\\t *\\n\\t * @return static<int, mixed>\\n\\t *\/\\n\\tpublic function collapse() {\\n\\t\\treturn new static( Arr::collapse( $this->items ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if an item exists in the collection.\\n\\t *\\n\\t * @param  (callable(TValue, TKey): bool)|TValue|string $key\\n\\t * @param  mixed                                        $operator\\n\\t * @param  mixed                                        $value\\n\\t * @return bool\\n\\t *\/\\n\\tpublic function contains( $key, $operator = null, $value = null ) {\\n\\t\\tif ( func_num_args() === 1 ) {\\n\\t\\t\\tif ( $this->use_as_callable( $key ) ) {\\n\\t\\t\\t\\t$placeholder = new stdClass();\\n\\n\\t\\t\\t\\treturn $this->first( $key, $placeholder ) !== $placeholder;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn in_array( $key, $this->items ); \/\/ phpcs:ignore WordPress.PHP.StrictInArray.MissingTrueStrict\\n\\t\\t}\\n\\n\\t\\treturn $this->contains( $this->operator_for_where( ...func_get_args() ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if an item exists, using strict comparison.\\n\\t *\\n\\t * @param  (callable(TValue): bool)|TValue|array-key $key\\n\\t * @param  TValue|null                               $value\\n\\t * @return bool\\n\\t *\/\\n\\tpublic function contains_strict( $key, $value = null ) {\\n\\t\\tif ( func_num_args() === 2 ) {\\n\\t\\t\\treturn $this->contains( fn ( $item ) => data_get( $item, $key ) === $value );\\n\\t\\t}\\n\\n\\t\\tif ( $this->use_as_callable( $key ) ) {\\n\\t\\t\\treturn ! is_null( $this->first( $key ) );\\n\\t\\t}\\n\\n\\t\\t\\treturn in_array( $key, $this->items, true );\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if an item is not contained in the collection.\\n\\t *\\n\\t * @param  mixed $key\\n\\t * @param  mixed $operator\\n\\t * @param  mixed $value\\n\\t *\/\\n\\tpublic function doesnt_contain( $key, $operator = null, $value = null ): bool {\\n\\t\\treturn ! $this->contains( ...func_get_args() );\\n\\t}\\n\\n\\t\/**\\n\\t * Cross join with the given lists, returning all possible permutations.\\n\\t *\\n\\t * @template TCrossJoinKey of array-key\\n\\t * @template TCrossJoinValue\\n\\t *\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<TCrossJoinKey, TCrossJoinValue>|iterable<TCrossJoinKey, TCrossJoinValue> ...$lists\\n\\t * @return static<int, array<int, TValue|TCrossJoinValue>>\\n\\t *\/\\n\\tpublic function cross_join( ...$lists ) {\\n\\t\\treturn new static(\\n\\t\\t\\tArr::cross_join(\\n\\t\\t\\t\\t$this->items,\\n\\t\\t\\t\\t...array_map( [ $this, 'get_arrayable_items' ], $lists )\\n\\t\\t\\t)\\n\\t\\t);\\n\\t}\\n\\n\\t\/**\\n\\t * Get the items in the collection that are not present in the given items.\\n\\t *\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<array-key, TValue>|iterable<array-key, TValue> $items\\n\\t * @return static\\n\\t *\/\\n\\tpublic function diff( $items ) {\\n\\t\\treturn new static( array_diff( $this->items, $this->get_arrayable_items( $items ) ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the items in the collection that are not present in the given items, using the callback.\\n\\t *\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<array-key, TValue>|iterable<array-key, TValue> $items\\n\\t * @param  callable(TValue, TValue): int                                                      $callback\\n\\t * @return static\\n\\t *\/\\n\\tpublic function diff_using( $items, callable $callback ) {\\n\\t\\treturn new static( array_udiff( $this->items, $this->get_arrayable_items( $items ), $callback ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the items in the collection whose keys and values are not present in the given items.\\n\\t *\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<TKey, TValue>|iterable<TKey, TValue> $items\\n\\t * @return static\\n\\t *\/\\n\\tpublic function diff_assoc( $items ) {\\n\\t\\treturn new static( array_diff_assoc( $this->items, $this->get_arrayable_items( $items ) ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the items in the collection whose keys and values are not present in the given items, using the callback.\\n\\t *\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<TKey, TValue>|iterable<TKey, TValue> $items\\n\\t * @param  callable(TKey, TKey): int                                                $callback\\n\\t * @return static\\n\\t *\/\\n\\tpublic function diff_assoc_using( $items, callable $callback ) {\\n\\t\\treturn new static( array_diff_uassoc( $this->items, $this->get_arrayable_items( $items ), $callback ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the items in the collection whose keys are not present in the given items.\\n\\t *\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<TKey, TValue>|iterable<TKey, TValue> $items\\n\\t * @return static\\n\\t *\/\\n\\tpublic function diff_keys( $items ) {\\n\\t\\treturn new static( array_diff_key( $this->items, $this->get_arrayable_items( $items ) ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the items in the collection whose keys are not present in the given items, using the callback.\\n\\t *\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<TKey, TValue>|iterable<TKey, TValue> $items\\n\\t * @param  callable(TKey, TKey): int                                                $callback\\n\\t * @return static\\n\\t *\/\\n\\tpublic function diff_keys_using( $items, callable $callback ) {\\n\\t\\treturn new static( array_diff_ukey( $this->items, $this->get_arrayable_items( $items ), $callback ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Retrieve duplicate items from the collection.\\n\\t *\\n\\t * @param  (callable(TValue): bool)|string|null $callback\\n\\t * @param    bool                                 $strict\\n\\t * @return static\\n\\t *\/\\n\\tpublic function duplicates( $callback = null, $strict = false ) {\\n\\t\\t$items = $this->map( $this->value_retriever( $callback ) );\\n\\n\\t\\t$unique_items = $items->unique( null, $strict );\\n\\n\\t\\t$compare = $this->duplicate_comparator( $strict );\\n\\n\\t\\t$duplicates = new static();\\n\\n\\t\\tforeach ( $items as $key => $value ) {\\n\\t\\t\\tif ( $unique_items->is_not_empty() && $compare( $value, $unique_items->first() ) ) {\\n\\t\\t\\t\\t$unique_items->shift();\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t$duplicates[ $key ] = $value;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $duplicates;\\n\\t}\\n\\n\\t\/**\\n\\t * Retrieve duplicate items from the collection using strict comparison.\\n\\t *\\n\\t * @param  (callable(TValue): bool)|string|null $callback\\n\\t * @return static\\n\\t *\/\\n\\tpublic function duplicates_strict( $callback = null ) {\\n\\t\\treturn $this->duplicates( $callback, true );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the comparison function to detect duplicates.\\n\\t *\\n\\t * @param    bool $strict\\n\\t * @return callable(TValue, TValue): bool\\n\\t *\/\\n\\tprotected function duplicate_comparator( $strict ) {\\n\\t\\tif ( $strict ) {\\n\\t\\t\\treturn fn ( $a, $b ) => $a == $b; \/\/ phpcs:ignore WordPress.PHP.StrictComparisons.LooseComparison, Universal.Operators.StrictComparisons.LooseEqual\\n\\t\\t}\\n\\n\\t\\treturn fn ( $a, $b ) => $a === $b;\\n\\t}\\n\\n\\t\/**\\n\\t * Get all items except for those with the specified keys.\\n\\t *\\n\\t * @param  \\\\Mantle\\\\Support\\\\Enumerable<array-key, TKey>|array<array-key, TKey>|string $keys\\n\\t * @return static\\n\\t *\/\\n\\tpublic function except( $keys ) {\\n\\t\\tif ( $keys instanceof Enumerable ) {\\n\\t\\t\\t$keys = $keys->all();\\n\\t\\t} elseif ( ! is_array( $keys ) ) {\\n\\t\\t\\t$keys = func_get_args();\\n\\t\\t}\\n\\n\\t\\treturn new static( Arr::except( $this->items, $keys ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Run a filter over each of the items.\\n\\t *\\n\\t * @param (callable(TValue, TKey): bool)|null $callback\\n\\t * @return static\\n\\t *\/\\n\\tpublic function filter( ?callable $callback = null ) {\\n\\t\\tif ( $callback ) {\\n\\t\\t\\treturn new static( Arr::where( $this->items, $callback ) );\\n\\t\\t}\\n\\n\\t\\treturn new static( array_filter( $this->items ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the first item from the collection passing the given truth test.\\n\\t *\\n\\t * @template TFirstDefault\\n\\t *\\n\\t * @param  (callable(TValue, TKey): bool)|null       $callback\\n\\t * @param  TFirstDefault|(\\\\Closure(): TFirstDefault) $default\\n\\t * @return TValue|TFirstDefault\\n\\t *\/\\n\\tpublic function first( ?callable $callback = null, $default = null ): mixed {\\n\\t\\treturn Arr::first( $this->items, $callback, $default );\\n\\t}\\n\\n\\t\/**\\n\\t * Get a flattened array of the items in the collection.\\n\\t *\\n\\t * @param  int|float $depth\\n\\t * @return static<int, mixed>\\n\\t *\/\\n\\tpublic function flatten( int|float $depth = INF ) {\\n\\t\\treturn new static( Arr::flatten( $this->items, $depth ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Flip the items in the collection.\\n\\t *\\n\\t * @return static<int|string, TKey>\\n\\t *\/\\n\\tpublic function flip() {\\n\\t\\treturn new static( array_flip( $this->items ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Remove an item from the collection by key.\\n\\t *\\n\\t * @param  TKey|array<array-key, TKey> $keys\\n\\t * @return static\\n\\t *\/\\n\\tpublic function forget( $keys ) {\\n\\t\\tforeach ( (array) $keys as $key ) {\\n\\t\\t\\t$this->offsetUnset( $key );\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Get an item from the collection by key.\\n\\t *\\n\\t * @template TGetDefault\\n\\t *\\n\\t * @param  TKey                                  $key\\n\\t * @param  TGetDefault|(\\\\Closure(): TGetDefault) $default\\n\\t * @return TValue|TGetDefault\\n\\t *\/\\n\\tpublic function get( $key, $default = null ) {\\n\\t\\tif ( $this->offsetExists( $key ) ) {\\n\\t\\t\\treturn $this->items[ $key ];\\n\\t\\t}\\n\\n\\t\\treturn value( $default );\\n\\t}\\n\\n\\t\/**\\n\\t * Group an associative array by a field or using a callback.\\n\\t *\\n\\t * @param  (callable(TValue, TKey): array-key)|array<mixed>|string $group_by The field or callback to group by.\\n\\t * @param  bool                                                    $preserve_keys Whether to preserve the keys of the original array.\\n\\t * @return static<array-key, static<array-key, TValue>>\\n\\t *\/\\n\\tpublic function group_by( $group_by, $preserve_keys = false ) {\\n\\t\\tif ( ! $this->use_as_callable( $group_by ) && is_array( $group_by ) ) {\\n\\t\\t\\t$next_groups = $group_by;\\n\\n\\t\\t\\t$group_by = array_shift( $next_groups );\\n\\t\\t}\\n\\n\\t\\t$group_by = $this->value_retriever( $group_by );\\n\\n\\t\\t$results = [];\\n\\n\\t\\tforeach ( $this->items as $key => $value ) {\\n\\t\\t\\t$group_keys = $group_by( $value, $key );\\n\\n\\t\\t\\tif ( ! is_array( $group_keys ) ) {\\n\\t\\t\\t\\t$group_keys = [ $group_keys ];\\n\\t\\t\\t}\\n\\n\\t\\t\\tforeach ( $group_keys as $group_key ) {\\n\\t\\t\\t\\t$group_key = is_bool( $group_key ) ? (int) $group_key : $group_key;\\n\\n\\t\\t\\t\\tif ( ! array_key_exists( $group_key, $results ) ) {\\n\\t\\t\\t\\t\\t$results[ $group_key ] = new static();\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t$results[ $group_key ]->offsetSet( $preserve_keys ? $key : null, $value );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t$result = new static( $results );\\n\\n\\t\\tif ( ! empty( $next_groups ) ) {\\n\\t\\t\\treturn $result->map->group_by( $next_groups, $preserve_keys ); \/\/ @phpstan-ignore-line undefined method\\n\\t\\t}\\n\\n\\t\\treturn $result;\\n\\t}\\n\\n\\t\/**\\n\\t * Key an associative array by a field or using a callback.\\n\\t *\\n\\t * @param  (callable(TValue, TKey): array-key)|string[]|string $key_by The field or callback to key by.\\n\\t * @return static<array-key, TValue>\\n\\t *\/\\n\\tpublic function key_by( $key_by ) {\\n\\t\\t$key_by = $this->value_retriever( $key_by );\\n\\n\\t\\t$results = [];\\n\\n\\t\\tforeach ( $this->items as $key => $item ) {\\n\\t\\t\\t$resolved_key = $key_by( $item, $key );\\n\\n\\t\\t\\tif ( is_object( $resolved_key ) ) {\\n\\t\\t\\t\\t$resolved_key = (string) $resolved_key;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$results[ $resolved_key ] = $item;\\n\\t\\t}\\n\\n\\t\\treturn new static( $results );\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if an item exists in the collection by key.\\n\\t *\\n\\t * @param  TKey|array<array-key, TKey> $key\\n\\t *\/\\n\\tpublic function has( $key ): bool {\\n\\t\\t$keys = is_array( $key ) ? $key : func_get_args();\\n\\n\\t\\tforeach ( $keys as $key ) {\\n\\t\\t\\tif ( ! $this->offsetExists( $key ) ) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\\n\\n\\t\/**\\n\\t * Concatenate values of a given key as a string.\\n\\t *\\n\\t * @param callable|string|null $value\\n\\t * @param string|null          $glue\\n\\t *\/\\n\\tpublic function implode( $value, $glue = null ): string {\\n\\t\\tif ( $this->use_as_callable( $value ) ) {\\n\\t\\t\\treturn implode( $glue ?? '', $this->map( $value )->all() );\\n\\t\\t}\\n\\n\\t\\t$first = $this->first();\\n\\n\\t\\tif ( is_array( $first ) || ( is_object( $first ) && ! $first instanceof \\\\Stringable ) ) {\\n\\t\\t\\treturn implode( $glue ?? '', $this->pluck( $value )->all() );\\n\\t\\t}\\n\\n\\t\\treturn implode( $value ?? '', $this->items );\\n\\t}\\n\\n\\t\/**\\n\\t * Concatenate values of a given key as a string and returns a stringable class.\\n\\t *\\n\\t * @param callable|string|null $value\\n\\t * @param string|null          $glue\\n\\t *\/\\n\\tpublic function implode_str( $value, $glue = null ): Stringable {\\n\\t\\treturn new Stringable( $this->implode( $value, $glue ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Intersect the collection with the given items.\\n\\t *\\n\\t * @param \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<TKey, TValue>|iterable<TKey, TValue> $items\\n\\t * @return static\\n\\t *\/\\n\\tpublic function intersect( $items ) {\\n\\t\\treturn new static( array_intersect( $this->items, $this->get_arrayable_items( $items ) ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Intersect the collection with the given items with additional index check.\\n\\t *\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<TKey, TValue>|iterable<TKey, TValue> $items\\n\\t * @return static\\n\\t *\/\\n\\tpublic function intersect_assoc( $items ) {\\n\\t\\treturn new static( array_intersect_assoc( $this->items, $this->get_arrayable_items( $items ) ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Intersect the collection with the given items with additional index check, using the callback.\\n\\t *\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<array-key, TValue>|iterable<array-key, TValue> $items\\n\\t * @param  callable(TValue, TValue): int                                                      $callback\\n\\t * @return static\\n\\t *\/\\n\\tpublic function intersect_assoc_using( $items, callable $callback ) {\\n\\t\\treturn new static( array_intersect_uassoc( $this->items, $this->get_arrayable_items( $items ), $callback ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Intersect the collection with the given items by key.\\n\\t *\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<TKey, TValue>|iterable<TKey, TValue> $items\\n\\t * @return static\\n\\t *\/\\n\\tpublic function intersect_by_keys( $items ) {\\n\\t\\treturn new static(\\n\\t\\t\\tarray_intersect_key(\\n\\t\\t\\t\\t$this->items,\\n\\t\\t\\t\\t$this->get_arrayable_items( $items )\\n\\t\\t\\t)\\n\\t\\t);\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if the collection is empty or not.\\n\\t *\/\\n\\tpublic function is_empty(): bool {\\n\\t\\treturn empty( $this->items );\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if the collection contains a single item.\\n\\t *\/\\n\\tpublic function contains_one_item(): bool {\\n\\t\\treturn $this->count() === 1;\\n\\t}\\n\\n\\t\/**\\n\\t * Join all items from the collection using a string. The final items can use a separate glue string.\\n\\t *\\n\\t * @param    string $glue\\n\\t * @param    string $final_glue\\n\\t * @return string\\n\\t *\/\\n\\tpublic function join( $glue, $final_glue = '' ) {\\n\\t\\tif ( '' === $final_glue ) {\\n\\t\\t\\treturn $this->implode( $glue );\\n\\t\\t}\\n\\n\\t\\t$count = $this->count();\\n\\n\\t\\tif ( 0 === $count ) {\\n\\t\\t\\treturn '';\\n\\t\\t}\\n\\n\\t\\tif ( 1 === $count ) {\\n\\t\\t\\treturn $this->last();\\n\\t\\t}\\n\\n\\t\\t$collection = new static( $this->items );\\n\\n\\t\\t$final_item = $collection->pop();\\n\\n\\t\\treturn $collection->implode( $glue ) . $final_glue . $final_item;\\n\\t}\\n\\n\\t\/**\\n\\t * Get the keys of the collection items.\\n\\t *\\n\\t * @return static<int, TKey>\\n\\t *\/\\n\\tpublic function keys() {\\n\\t\\treturn new static( array_keys( $this->items ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the last item from the collection.\\n\\t *\\n\\t * @template TLastDefault\\n\\t *\\n\\t * @param  (callable(TValue, TKey): bool)|null     $callback\\n\\t * @param  TLastDefault|(\\\\Closure(): TLastDefault) $default\\n\\t * @return TValue|TLastDefault\\n\\t *\/\\n\\tpublic function last( ?callable $callback = null, $default = null ): mixed {\\n\\t\\treturn Arr::last( $this->items, $callback, $default );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the values of a given key.\\n\\t *\\n\\t * @param  string|int|array<array-key, string> $value\\n\\t * @param  string|null                         $key\\n\\t * @return static<array-key, mixed>\\n\\t *\/\\n\\tpublic function pluck( $value, $key = null ) {\\n\\t\\treturn new static( Arr::pluck( $this->items, $value, $key ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Run a map over each of the items.\\n\\t *\\n\\t * @template TMapValue\\n\\t *\\n\\t * @param  callable(TValue, TKey): TMapValue $callback\\n\\t * @return static<TKey, TMapValue>\\n\\t *\/\\n\\tpublic function map( callable $callback ) {\\n\\t\\t$keys = array_keys( $this->items );\\n\\n\\t\\t$items = array_map( $callback, $this->items, $keys );\\n\\n\\t\\treturn new static( array_combine( $keys, $items ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Run a dictionary map over the items.\\n\\t *\\n\\t * The callback should return an associative array with a single key\/value pair.\\n\\t *\\n\\t * @template TMapToDictionaryKey of array-key\\n\\t * @template TMapToDictionaryValue\\n\\t *\\n\\t * @param  callable(TValue, TKey): array<TMapToDictionaryKey, TMapToDictionaryValue> $callback\\n\\t * @return static<TMapToDictionaryKey, array<int, TMapToDictionaryValue>>\\n\\t *\/\\n\\tpublic function map_to_dictionary( callable $callback ) {\\n\\t\\t$dictionary = [];\\n\\n\\t\\tforeach ( $this->items as $key => $item ) {\\n\\t\\t\\t$pair = $callback( $item, $key );\\n\\n\\t\\t\\tif ( ! $pair || ! is_array( $pair ) ) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$key = key( $pair );\\n\\n\\t\\t\\t$value = reset( $pair );\\n\\n\\t\\t\\tif ( ! isset( $dictionary[ $key ] ) ) {\\n\\t\\t\\t\\t$dictionary[ $key ] = [];\\n\\t\\t\\t}\\n\\n\\t\\t\\t$dictionary[ $key ][] = $value;\\n\\t\\t}\\n\\n\\t\\treturn new static( $dictionary );\\n\\t}\\n\\n\\t\/**\\n\\t * Run an associative map over each of the items.\\n\\t *\\n\\t * The callback should return an associative array with a single key\/value pair.\\n\\t *\\n\\t * @template TMapWithKeysKey of array-key\\n\\t * @template TMapWithKeysValue\\n\\t *\\n\\t * @param  callable(TValue, TKey): array<TMapWithKeysKey, TMapWithKeysValue> $callback\\n\\t * @return static<TMapWithKeysKey, TMapWithKeysValue>\\n\\t *\/\\n\\tpublic function map_with_keys( callable $callback ) {\\n\\t\\t$result = [];\\n\\n\\t\\tforeach ( $this->items as $key => $value ) {\\n\\t\\t\\t$assoc = $callback( $value, $key );\\n\\n\\t\\t\\tif ( ! is_array( $assoc ) ) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tforeach ( $assoc as $map_key => $map_value ) {\\n\\t\\t\\t\\t$result[ $map_key ] = $map_value;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn new static( $result );\\n\\t}\\n\\n\\t\/**\\n\\t * Merge the collection with the given items.\\n\\t *\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<TKey, TValue>|iterable<TKey, TValue> $items\\n\\t * @return static\\n\\t *\/\\n\\tpublic function merge( $items ) {\\n\\t\\treturn new static( array_merge( $this->items, $this->get_arrayable_items( $items ) ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Recursively merge the collection with the given items.\\n\\t *\\n\\t * @template TMergeRecursiveValue\\n\\t *\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<TKey, TMergeRecursiveValue>|iterable<TKey, TMergeRecursiveValue> $items\\n\\t * @return static<TKey, TValue|TMergeRecursiveValue>\\n\\t *\/\\n\\tpublic function merge_recursive( $items ) {\\n\\t\\treturn new static( array_merge_recursive( $this->items, $this->get_arrayable_items( $items ) ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Create a collection by using this collection for keys and another for its values.\\n\\t *\\n\\t * @template TCombineValue\\n\\t *\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<array-key, TCombineValue>|iterable<array-key, TCombineValue> $values\\n\\t * @return static<TValue, TCombineValue>\\n\\t *\/\\n\\tpublic function combine( $values ) {\\n\\t\\treturn new static( array_combine( $this->all(), $this->get_arrayable_items( $values ) ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Union the collection with the given items.\\n\\t *\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<TKey, TValue>|iterable<TKey, TValue> $items\\n\\t * @return static\\n\\t *\/\\n\\tpublic function union( $items ) {\\n\\t\\treturn new static( $this->items + $this->get_arrayable_items( $items ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Create a new collection consisting of every n-th element.\\n\\t *\\n\\t * @param    int $step\\n\\t * @param    int $offset\\n\\t * @return static\\n\\t *\/\\n\\tpublic function nth( $step, $offset = 0 ) {\\n\\t\\t$new = [];\\n\\n\\t\\t$position = 0;\\n\\n\\t\\tforeach ( $this->items as $item ) {\\n\\t\\t\\tif ( $position % $step === $offset ) {\\n\\t\\t\\t\\t$new[] = $item;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$position++;\\n\\t\\t}\\n\\n\\t\\treturn new static( $new );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the items with the specified keys.\\n\\t *\\n\\t * @param  \\\\Mantle\\\\Support\\\\Enumerable<array-key, TKey>|array<array-key, TKey>|string|null $keys\\n\\t * @return static\\n\\t *\/\\n\\tpublic function only( $keys ) {\\n\\t\\tif ( is_null( $keys ) ) {\\n\\t\\t\\treturn new static( $this->items );\\n\\t\\t}\\n\\n\\t\\tif ( $keys instanceof Enumerable ) {\\n\\t\\t\\t$keys = $keys->all();\\n\\t\\t}\\n\\n\\t\\t$keys = is_array( $keys ) ? $keys : func_get_args();\\n\\n\\t\\treturn new static( Arr::only( $this->items, $keys ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the items in an collection of arrays with filtered child keys.\\n\\t *\\n\\t * @param TKey[]|TKey|static<int, TKey> $keys The keys to filter by.\\n\\t * @return static<TKey, array>\\n\\t *\/\\n\\tpublic function only_children( $keys ) {\\n\\t\\tif ( empty( $keys ) ) {\\n\\t\\t\\treturn new static( $this->items );\\n\\t\\t}\\n\\n\\t\\tif ( $keys instanceof Arrayable ) {\\n\\t\\t\\t$keys = $keys->to_array();\\n\\t\\t}\\n\\n\\t\\t$keys = is_array( $keys ) ? $keys : func_get_args();\\n\\n\\t\\treturn $this->map(\\n\\t\\t\\tfn ( $item ) => Arr::only( (array) $item, $keys ),\\n\\t\\t);\\n\\t}\\n\\n\\t\/**\\n\\t * Get and remove the last item from the collection.\\n\\t *\\n\\t * @return static<int, TValue>|TValue|null\\n\\t *\/\\n\\tpublic function pop(): mixed {\\n\\t\\treturn array_pop( $this->items );\\n\\t}\\n\\n\\t\/**\\n\\t * Push an item onto the beginning of the collection.\\n\\t *\\n\\t * To push multiple items onto the beginning of the collection, use `prepend_many()`.\\n\\t *\\n\\t * @param  TValue          $value\\n\\t * @param  int|string|null $key Array key to use for the value, optional.\\n\\t *\/\\n\\tpublic function prepend( mixed $value, int|string|null $key = null ): static {\\n\\t\\t$this->items = Arr::prepend( $this->items, $value, $key );\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Push one or more items onto the beginning of the collection.\\n\\t *\\n\\t * @param  TValue ...$values\\n\\t *\/\\n\\tpublic function prepend_many( ...$values ): static {\\n\\t\\tarray_unshift( $this->items, ...$values );\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Push one or more items onto the end of the collection.\\n\\t *\\n\\t * @param  TValue ...$values\\n\\t *\/\\n\\tpublic function push( ...$values ): static {\\n\\t\\tforeach ( $values as $value ) {\\n\\t\\t\\t$this->items[] = $value;\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Push all of the given items onto the collection.\\n\\t *\\n\\t * @param  iterable<array-key, TValue> $source\\n\\t * @return static\\n\\t *\/\\n\\tpublic function concat( $source ) {\\n\\t\\t$result = new static( $this );\\n\\n\\t\\tforeach ( $source as $item ) {\\n\\t\\t\\t$result->push( $item );\\n\\t\\t}\\n\\n\\t\\treturn $result;\\n\\t}\\n\\n\\t\/**\\n\\t * Get and remove an item from the collection.\\n\\t *\\n\\t * @template TPullDefault\\n\\t *\\n\\t * @param  TKey                                    $key\\n\\t * @param  TPullDefault|(\\\\Closure(): TPullDefault) $default\\n\\t * @return TValue|TPullDefault\\n\\t *\/\\n\\tpublic function pull( $key, $default = null ) {\\n\\t\\treturn Arr::pull( $this->items, $key, $default );\\n\\t}\\n\\n\\t\/**\\n\\t * Put an item in the collection by key.\\n\\t *\\n\\t * @param    TKey   $key\\n\\t * @param    TValue $value\\n\\t * @return static\\n\\t *\/\\n\\tpublic function put( $key, $value ) {\\n\\t\\t$this->offsetSet( $key, $value );\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Get one or a specified number of items randomly from the collection.\\n\\t *\\n\\t * @param  (callable(self<TKey, TValue>): int)|int|null $number\\n\\t * @return static<int, TValue>|TValue\\n\\t *\\n\\t * @throws \\\\InvalidArgumentException Throws on number larger than collection length.\\n\\t *\/\\n\\tpublic function random( $number = null ) {\\n\\t\\tif ( is_null( $number ) ) {\\n\\t\\t\\treturn Arr::random( $this->items );\\n\\t\\t}\\n\\n\\t\\treturn new static( Arr::random( $this->items, $number ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Reduce the collection to a single value.\\n\\t *\\n\\t * @template TReduceInitial\\n\\t * @template TReduceReturnType\\n\\t *\\n\\t * @param  callable(TReduceInitial|TReduceReturnType, TValue, TKey): TReduceReturnType $callback\\n\\t * @param  TReduceInitial                                                              $initial\\n\\t * @return TReduceReturnType|TReduceInitial\\n\\t *\/\\n\\tpublic function reduce( callable $callback, $initial = null ) {\\n\\t\\t$result = $initial;\\n\\n\\t\\tforeach ( $this as $key => $value ) {\\n\\t\\t\\t$result = $callback( $result, $value, $key );\\n\\t\\t}\\n\\n\\t\\treturn $result;\\n\\t}\\n\\n\\t\/**\\n\\t * Replace the collection items with the given items.\\n\\t *\\n\\t * @param \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<TKey, TValue>|iterable<TKey, TValue> $items\\n\\t * @return static\\n\\t *\/\\n\\tpublic function replace( $items ) {\\n\\t\\treturn new static( array_replace( $this->items, $this->get_arrayable_items( $items ) ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Recursively replace the collection items with the given items.\\n\\t *\\n\\t * @param \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<TKey, TValue>|iterable<TKey, TValue> $items\\n\\t * @return static\\n\\t *\/\\n\\tpublic function replace_recursive( $items ) {\\n\\t\\treturn new static( array_replace_recursive( $this->items, $this->get_arrayable_items( $items ) ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Reverse items order.\\n\\t *\\n\\t * @return static\\n\\t *\/\\n\\tpublic function reverse() {\\n\\t\\treturn new static( array_reverse( $this->items, true ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Search the collection for a given value and return the corresponding key if successful.\\n\\t *\\n\\t * @param  TValue|(callable(TValue,TKey): bool) $value\\n\\t * @param  bool                                 $strict\\n\\t * @return TKey|bool\\n\\t *\/\\n\\tpublic function search( $value, $strict = false ) {\\n\\t\\tif ( ! $this->use_as_callable( $value ) ) {\\n\\t\\t\\treturn array_search( $value, $this->items, $strict ); \/\/ phpcs:ignore WordPress.PHP.StrictInArray.MissingTrueStrict\\n\\t\\t}\\n\\n\\t\\tforeach ( $this->items as $key => $item ) {\\n\\t\\t\\tif ( $value( $item, $key ) ) {\\n\\t\\t\\t\\treturn $key;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\t\/**\\n\\t * Get and remove the first item from the collection.\\n\\t *\\n\\t * @return TValue|null\\n\\t *\/\\n\\tpublic function shift(): mixed {\\n\\t\\treturn array_shift( $this->items );\\n\\t}\\n\\n\\t\/**\\n\\t * Shuffle the items in the collection.\\n\\t *\\n\\t * @param    int|null $seed\\n\\t * @return static\\n\\t *\/\\n\\tpublic function shuffle( $seed = null ) {\\n\\t\\treturn new static( Arr::shuffle( $this->items, $seed ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Skip the first {$count} items.\\n\\t *\\n\\t * @param    int $count\\n\\t * @return static\\n\\t *\/\\n\\tpublic function skip( $count ) {\\n\\t\\treturn $this->slice( $count );\\n\\t}\\n\\n\\t\/**\\n\\t * Slice the underlying collection array.\\n\\t *\\n\\t * @param    int      $offset\\n\\t * @param    int|null $length\\n\\t * @return static\\n\\t *\/\\n\\tpublic function slice( $offset, $length = null ) {\\n\\t\\treturn new static( array_slice( $this->items, $offset, $length, true ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Split a collection into a certain number of groups.\\n\\t *\\n\\t * @param  int $number_of_groups\\n\\t * @return static<int, static>\\n\\t *\/\\n\\tpublic function split( $number_of_groups ) {\\n\\t\\tif ( $this->is_empty() ) {\\n\\t\\t\\treturn new static();\\n\\t\\t}\\n\\n\\t\\t$groups = new static();\\n\\n\\t\\t$group_size = floor( $this->count() \/ $number_of_groups );\\n\\n\\t\\t$remain = $this->count() % $number_of_groups;\\n\\n\\t\\t$start = 0;\\n\\n\\t\\tfor ( $i = 0; $i < $number_of_groups; $i++ ) {\\n\\t\\t\\t$size = $group_size;\\n\\n\\t\\t\\tif ( $i < $remain ) {\\n\\t\\t\\t\\t$size++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( $size !== 0.0 ) {\\n\\t\\t\\t\\t$groups->push( new static( array_slice( $this->items, $start, (int) $size ) ) );\\n\\n\\t\\t\\t\\t$start += $size;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $groups;\\n\\t}\\n\\n\\t\/**\\n\\t * Chunk the collection into chunks of the given size.\\n\\t *\\n\\t * @param  int $size\\n\\t * @return static<int, static>\\n\\t *\/\\n\\tpublic function chunk( $size ) {\\n\\t\\tif ( $size <= 0 ) {\\n\\t\\t\\treturn new static();\\n\\t\\t}\\n\\n\\t\\t$chunks = [];\\n\\n\\t\\tforeach ( array_chunk( $this->items, $size, true ) as $chunk ) {\\n\\t\\t\\t$chunks[] = new static( $chunk );\\n\\t\\t}\\n\\n\\t\\treturn new static( $chunks );\\n\\t}\\n\\n\\t\/**\\n\\t * Sort through each item with a callback.\\n\\t *\\n\\t * @param  (callable(TValue, TValue): int)|null|int $callback\\n\\t * @return static\\n\\t *\/\\n\\tpublic function sort( $callback = null ) {\\n\\t\\t$items = $this->items;\\n\\n\\t\\t$callback && is_callable( $callback )\\n\\t\\t\\t? uasort( $items, $callback )\\n\\t\\t\\t: asort( $items, $callback ?? SORT_REGULAR );\\n\\n\\t\\treturn new static( $items );\\n\\t}\\n\\n\\t\/**\\n\\t * Sort items in descending order.\\n\\t *\\n\\t * @param    int $options\\n\\t * @return static\\n\\t *\/\\n\\tpublic function sort_desc( $options = SORT_REGULAR ) {\\n\\t\\t$items = $this->items;\\n\\n\\t\\tarsort( $items, $options );\\n\\n\\t\\treturn new static( $items );\\n\\t}\\n\\n\\t\/**\\n\\t * Sort the collection using the given callback.\\n\\t *\\n\\t * @param  array<array-key, (callable(TValue, TValue): mixed)|(callable(TValue, TKey): mixed)|string|array{string, string}>|(callable(TValue, TKey): mixed)|string $callback\\n\\t * @param    int                                                                                                                                                     $options\\n\\t * @param    bool                                                                                                                                                    $descending\\n\\t * @return static\\n\\t *\/\\n\\tpublic function sort_by( $callback, $options = SORT_REGULAR, $descending = false ) {\\n\\t\\t$results = [];\\n\\n\\t\\t$callback = $this->value_retriever( $callback );\\n\\n\\t\\t\/\/ First we will loop through the items and get the comparator from a callback\\n\\t\\t\/\/ function which we were given. Then, we will sort the returned values and\\n\\t\\t\/\/ and grab the corresponding values for the sorted keys from this array.\\n\\t\\tforeach ( $this->items as $key => $value ) {\\n\\t\\t\\t$results[ $key ] = $callback( $value, $key );\\n\\t\\t}\\n\\n\\t\\t$descending ? arsort( $results, $options )\\n\\t\\t\\t\\t\\t\\t\\t: asort( $results, $options );\\n\\n\\t\\t\/\/ Once we have sorted all of the keys in the array, we will loop through them\\n\\t\\t\/\/ and grab the corresponding model so we can set the underlying items list\\n\\t\\t\/\/ to the sorted version. Then we'll just return the collection instance.\\n\\t\\tforeach ( array_keys( $results ) as $key ) {\\n\\t\\t\\t$results[ $key ] = $this->items[ $key ];\\n\\t\\t}\\n\\n\\t\\treturn new static( $results );\\n\\t}\\n\\n\\t\/**\\n\\t * Sort the collection in descending order using the given callback.\\n\\t *\\n\\t * @param  array<array-key, (callable(TValue, TValue): mixed)|(callable(TValue, TKey): mixed)|string|array{string, string}>|(callable(TValue, TKey): mixed)|string $callback\\n\\t * @param    int                                                                                                                                                     $options\\n\\t * @return static\\n\\t *\/\\n\\tpublic function sort_by_desc( $callback, $options = SORT_REGULAR ) {\\n\\t\\treturn $this->sort_by( $callback, $options, true );\\n\\t}\\n\\n\\t\/**\\n\\t * Sort the collection keys.\\n\\t *\\n\\t * @param    int  $options\\n\\t * @param    bool $descending\\n\\t * @return static\\n\\t *\/\\n\\tpublic function sort_keys( $options = SORT_REGULAR, $descending = false ) {\\n\\t\\t$items = $this->items;\\n\\n\\t\\t$descending ? krsort( $items, $options ) : ksort( $items, $options );\\n\\n\\t\\treturn new static( $items );\\n\\t}\\n\\n\\t\/**\\n\\t * Sort the collection keys in descending order.\\n\\t *\\n\\t * @param    int $options\\n\\t * @return static\\n\\t *\/\\n\\tpublic function sort_keys_desc( $options = SORT_REGULAR ) {\\n\\t\\treturn $this->sort_keys( $options, true );\\n\\t}\\n\\n\\t\/**\\n\\t * Splice a portion of the underlying collection array.\\n\\t *\\n\\t * @param    int                      $offset\\n\\t * @param    int|null                 $length\\n\\t * @param    array<array-key, TValue> $replacement\\n\\t * @return static\\n\\t *\/\\n\\tpublic function splice( $offset, $length = null, $replacement = [] ) {\\n\\t\\tif ( func_num_args() === 1 ) {\\n\\t\\t\\treturn new static( array_splice( $this->items, $offset ) );\\n\\t\\t}\\n\\n\\t\\treturn new static( array_splice( $this->items, $offset, $length, $replacement ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Take the first or last {$limit} items.\\n\\t *\\n\\t * @param    int $limit\\n\\t * @return static\\n\\t *\/\\n\\tpublic function take( $limit ) {\\n\\t\\tif ( $limit < 0 ) {\\n\\t\\t\\treturn $this->slice( $limit, abs( $limit ) );\\n\\t\\t}\\n\\n\\t\\treturn $this->slice( 0, $limit );\\n\\t}\\n\\n\\t\/**\\n\\t * Transform each item in the collection using a callback.\\n\\t *\\n\\t * @param  callable(TValue, TKey): TValue $callback\\n\\t * @return static\\n\\t *\/\\n\\tpublic function transform( callable $callback ) {\\n\\t\\t$this->items = $this->map( $callback )->all();\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Reset the keys on the underlying array.\\n\\t *\\n\\t * @return static<int, TValue>\\n\\t *\/\\n\\tpublic function values() {\\n\\t\\treturn new static( array_values( $this->items ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Zip the collection together with one or more arrays.\\n\\t *\\n\\t * E.g. new Collection([1, 2, 3])->zip([4, 5, 6]);\\n\\t *          => [[1, 4], [2, 5], [3, 6]]\\n\\t *\\n\\t * @template TZipValue\\n\\t *\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<array-key, TZipValue>|iterable<array-key, TZipValue> ...$items\\n\\t * @return static<int, static<TKey, TValue|TZipValue>>\\n\\t *\/\\n\\tpublic function zip( ...$items ) {\\n\\t\\t$arrayable_items = array_map(\\n\\t\\t\\tfn ( iterable|\\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable $items ) => $this->get_arrayable_items( $items ),\\n\\t\\t\\t$items,\\n\\t\\t);\\n\\n\\t\\t$params = array_merge(\\n\\t\\t\\t[\\n\\t\\t\\t\\tfn () => new static( func_get_args() ),\\n\\t\\t\\t\\t$this->items,\\n\\t\\t\\t],\\n\\t\\t\\t$arrayable_items\\n\\t\\t);\\n\\n\\t\\treturn new static( array_map( ...$params ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Trim all values in the collection.\\n\\t *\\n\\t * @param  string $char_list Characters to trim, optional.\\n\\t * @return static<TKey, string>\\n\\t *\/\\n\\tpublic function trim( string $char_list = \\\"\\\\n\\\\r\\\\t\\\\v\\\\x00\\\" ) {\\n\\t\\treturn new static( $this->map( fn ( $item ) => trim( (string) $item, $char_list ) ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Pad collection to the specified length with a value.\\n\\t *\\n\\t * @template TPadValue\\n\\t *\\n\\t * @param  int       $size\\n\\t * @param  TPadValue $value\\n\\t * @return static<int, TValue|TPadValue>\\n\\t *\/\\n\\tpublic function pad( $size, $value ) {\\n\\t\\treturn new static( array_pad( $this->items, $size, $value ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Get an iterator for the items.\\n\\t *\\n\\t * @return \\\\ArrayIterator\\n\\t *\/\\n\\tpublic function getIterator(): Traversable {\\n\\t\\treturn new ArrayIterator( $this->items );\\n\\t}\\n\\n\\t\/**\\n\\t * Count the number of items in the collection.\\n\\t *\/\\n\\tpublic function count(): int {\\n\\t\\treturn count( $this->items );\\n\\t}\\n\\n\\t\/**\\n\\t * Add an item to the collection.\\n\\t *\\n\\t * @param  TValue $item\\n\\t * @return static\\n\\t *\/\\n\\tpublic function add( $item ) {\\n\\t\\t$this->items[] = $item;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Get a base Support collection instance from this collection.\\n\\t *\\n\\t * @return \\\\Mantle\\\\Support\\\\Collection\\n\\t *\/\\n\\tpublic function to_base() {\\n\\t\\treturn new self( $this );\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if an item exists at an offset.\\n\\t *\\n\\t * @param mixed $key\\n\\t *\/\\n\\tpublic function offsetExists( mixed $key ): bool {\\n\\t\\treturn array_key_exists( $key, $this->items );\\n\\t}\\n\\n\\t\/**\\n\\t * Get an item at a given offset.\\n\\t *\\n\\t * @param  mixed $key\\n\\t *\/\\n\\tpublic function offsetGet( mixed $key ): mixed {\\n\\t\\treturn $this->items[ $key ];\\n\\t}\\n\\n\\t\/**\\n\\t * Set the item at a given offset.\\n\\t *\\n\\t * @param    mixed $key\\n\\t * @param    mixed $value\\n\\t *\/\\n\\tpublic function offsetSet( mixed $key, mixed $value ): void {\\n\\t\\tif ( is_null( $key ) ) {\\n\\t\\t\\t$this->items[] = $value;\\n\\t\\t} else {\\n\\t\\t\\t$this->items[ $key ] = $value;\\n\\t\\t}\\n\\t}\\n\\n\\t\/**\\n\\t * Unset the item at a given offset.\\n\\t *\\n\\t * @param mixed $key\\n\\t *\/\\n\\tpublic function offsetUnset( mixed $key ): void {\\n\\t\\tunset( $this->items[ $key ] );\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/attributes\/class-filter.php\",\"ext\":\"php\",\"size\":562,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Filter class file\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support\\\\Attributes;\\n\\nuse Attribute;\\n\\n\/**\\n * Hook Filter Attribute\\n *\\n * Used to hook a method to an WordPress hook at a specific priority.\\n *\/\\n#[Attribute( Attribute::IS_REPEATABLE | Attribute::TARGET_METHOD | Attribute::TARGET_FUNCTION )]\\nclass Filter {\\n\\t\/**\\n\\t * Constructor.\\n\\t *\\n\\t * @param string $hook_name Hook name.\\n\\t * @param int    $priority Priority, defaults to 10.\\n\\t *\/\\n\\tpublic function __construct( public readonly string $hook_name, public readonly int $priority = 10 ) {}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/attributes\/hookable\/class-hookable-allow-legacy-duplicate-registration.php\",\"ext\":\"php\",\"size\":1048,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Allow_Legacy_Duplicate_Registration class file\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support\\\\Attributes\\\\Hookable;\\n\\n\/**\\n * Allow for legacy duplicate registration of hooks using Hookable.\\n *\\n * Before Mantle v1.6, the Hookable trait would allow for duplicate registration\\n * of hooks for a class method if the method name used the `on_{hook}` or\\n * `action_{hook}` naming convention and the method used the `Action` or\\n * `Filter` attribute. If it had the same priority it would be deduplicated.\\n * With v1.6, if a method had a `Action` or `Filter` attribute at all, it would\\n * completely ignore the method name for hook registration consideration.\\n *\\n * This attribute allows for the legacy behavior to be restored, where the\\n * method name won't be ignored when an attribute is present on the method. This\\n * can cause duplicate hook registration.\\n *\\n * This will be removed with Mantle v2.0.\\n *\\n * @see \\\\Mantle\\\\Support\\\\Traits\\\\Hookable\\n *\/\\n#[\\\\Attribute( \\\\Attribute::TARGET_CLASS )]\\nclass Allow_Legacy_Duplicate_Registration {}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/attributes\/class-action.php\",\"ext\":\"php\",\"size\":346,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Action class file\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support\\\\Attributes;\\n\\nuse Attribute;\\n\\n\/**\\n * Hook Action Attribute\\n *\\n * Used to hook a method to an WordPress hook at a specific priority.\\n *\/\\n#[Attribute( Attribute::IS_REPEATABLE | Attribute::TARGET_METHOD | Attribute::TARGET_FUNCTION )]\\nclass Action extends Filter {}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/autoload.php\",\"ext\":\"php\",\"size\":149,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Autoloaded File for Mantle Support\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support;\\n\\nrequire_once __DIR__ . '\/helpers\/helpers.php';\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/class-html.php\",\"ext\":\"php\",\"size\":23211,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * HTML class file\\n *\\n * phpcs:disable WordPress.NamingConventions.ValidVariableName.UsedPropertyNotSnakeCase\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support;\\n\\nuse DOMDocument;\\nuse DOMElement;\\nuse DOMNode;\\nuse DOMNodeList;\\nuse InvalidArgumentException;\\nuse Mantle\\\\Contracts\\\\Support\\\\Htmlable;\\nuse Mantle\\\\Support\\\\Traits\\\\Conditionable;\\nuse Mantle\\\\Support\\\\Traits\\\\Macroable;\\nuse Mantle\\\\Support\\\\Traits\\\\Tappable;\\nuse Symfony\\\\Component\\\\DomCrawler\\\\Crawler as SymfonyCrawler;\\nuse Mantle\\\\Support\\\\Internal\\\\HTML_Helpers as Helpers;\\nuse Mantle\\\\Testing\\\\Concerns\\\\Element_Assertions;\\nuse Override;\\n\\nuse function Mantle\\\\Support\\\\Helpers\\\\classname;\\nuse function Mantle\\\\Support\\\\Helpers\\\\stringable;\\n\\n\/**\\n * HTML class for parsing and manipulating HTML documents.\\n *\\n * This class extends the Symfony DomHTML and provides additional\\n * methods for querying and modifying HTML elements using CSS selectors\\n * and XPath expressions. It also includes methods for setting and\\n * removing attributes, adding and removing classes, and modifying\\n * elements using callback functions.\\n *\\n * Inspired by {@see https:\/\/github.com\/wasinger\/htmlpagedom}.\\n *\\n * @link https:\/\/symfony.com\/doc\/current\/components\/dom_crawler.html\\n *\/\\nclass HTML extends SymfonyCrawler implements Htmlable {\\n\\tuse Conditionable;\\n\\tuse Element_Assertions;\\n\\tuse HTML\\\\Assertions;\\n\\tuse Macroable;\\n\\tuse Tappable;\\n\\n\\t\/**\\n\\t * The internal root element name used when importing html fragments.\\n\\t * *\/\\n\\tprivate const FRAGMENT_ROOT_TAGNAME = '_root';\\n\\n\\t\/**\\n\\t * Get an HTML object from a variety of types.\\n\\t *\\n\\t * @param string|\\\\Symfony\\\\Component\\\\DomCrawler\\\\Crawler|DOMNode|DOMNodeList<DOMNode> $content\\n\\t *\/\\n\\tpublic static function create( string|\\\\Symfony\\\\Component\\\\DomCrawler\\\\Crawler|DOMNode|DOMNodeList $content ): static {\\n\\t\\treturn match ( true ) {\\n\\t\\t\\t$content instanceof static => $content,\\n\\t\\t\\t$content instanceof SymfonyCrawler => new static( iterator_to_array( $content ) ),\\n\\t\\t\\tdefault => new static( $content ),\\n\\t\\t};\\n\\t}\\n\\n\\t\/**\\n\\t * Convert the HTML instance to an HTML string.\\n\\t *\/\\n\\tpublic function to_html(): string {\\n\\t\\tif ( $this->is_html_document() ) {\\n\\t\\t\\treturn $this->get_dom_document()->saveHTML();\\n\\t\\t}\\n\\n\\t\\t$doc  = new \\\\DOMDocument( '1.0', 'UTF-8' );\\n\\t\\t$root = $doc->appendChild( $doc->createElement( self::FRAGMENT_ROOT_TAGNAME ) );\\n\\n\\t\\tforeach ( $this as $node ) {\\n\\t\\t\\t$root->appendChild( $doc->importNode( $node, true ) );\\n\\t\\t}\\n\\n\\t\\t$html = trim( $doc->saveHTML() );\\n\\n\\t\\treturn preg_replace( '@^<' . self::FRAGMENT_ROOT_TAGNAME . '[^>]*>|<\/' . self::FRAGMENT_ROOT_TAGNAME . '>$@', '', $html );\\n\\t}\\n\\n\\t\/**\\n\\t * Adds a node to the current list of nodes.\\n\\t *\\n\\t * This method uses the appropriate specialized add*() method based\\n\\t * on the type of the argument.\\n\\t *\\n\\t * @param \\\\DOMNodeList<DOMNode>|\\\\DOMNode|array<mixed>|string|HTML|null $node A node.\\n\\t *\/\\n\\t#[Override]\\n\\tpublic function add( \\\\DOMNodeList|\\\\DOMNode|array|string|SymfonyCrawler|null $node ): void {\\n\\t\\tif ( $node instanceof SymfonyCrawler ) {\\n\\t\\t\\tforeach ( $node as $childnode ) {\\n\\t\\t\\t\\t$this->addNode( $childnode );\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tparent::add( $node );\\n\\t\\t}\\n\\t}\\n\\n\\t\/**\\n\\t * Query the document for all elements matching a CSS selector.\\n\\t *\\n\\t * @param string $selector\\n\\t *\/\\n\\tpublic function get_by_selector( string $selector ): static {\\n\\t\\treturn $this->filter( $selector );\\n\\t}\\n\\n\\t\/**\\n\\t * Query the document for a single element matching a CSS selector.\\n\\t *\\n\\t * @param string $id The id to match (without the #).\\n\\t *\/\\n\\tpublic function first_by_id( string $id ): static {\\n\\t\\tif ( '#' === $id[0] ) {\\n\\t\\t\\t$id = substr( $id, 1 );\\n\\t\\t}\\n\\n\\t\\treturn $this->filter( \\\"#{$id}\\\" )->first();\\n\\t}\\n\\n\\t\/**\\n\\t * Query the document for a single element using a tag name.\\n\\t *\\n\\t * @param string $tag The tag name to match.\\n\\t *\/\\n\\tpublic function first_by_tag( string $tag ): static {\\n\\t\\treturn $this->filter( $tag )->first();\\n\\t}\\n\\n\\t\/**\\n\\t * Query the document for a single element using a class name.\\n\\t *\\n\\t * @param string $test_id The test ID.\\n\\t *\/\\n\\tpublic function first_by_testid( string $test_id ): static {\\n\\t\\treturn $this->filter( \\\"[data-testid=\\\\\\\"{$test_id}\\\\\\\"]\\\" )->first();\\n\\t}\\n\\n\\t\/**\\n\\t * Query the document for a single element using a CSS selector.\\n\\t *\\n\\t * @param string $selector The CSS selector to match.\\n\\t *\/\\n\\tpublic function first_by_selector( string $selector ): static {\\n\\t\\treturn $this->filter( $selector )->first();\\n\\t}\\n\\n\\t\/**\\n\\t * Retrieve all elements matching an XPath expression.\\n\\t *\\n\\t * @param string $xpath XPath expression to match.\\n\\t *\/\\n\\tpublic function get_by_xpath( string $xpath ): static {\\n\\t\\treturn $this->filterXPath( $xpath );\\n\\t}\\n\\n\\t\/**\\n\\t * Retrieve all elements matching a specific tag name.\\n\\t *\\n\\t * @param string $tag The tag name to match.\\n\\t *\/\\n\\tpublic function get_by_tag( string $tag ): static {\\n\\t\\treturn $this->filter( $tag );\\n\\t}\\n\\n\\t\/**\\n\\t * Retrieve all elements matching a specific test ID (data-testid) attribute.\\n\\t *\\n\\t * @param string $test_id The test ID.\\n\\t *\/\\n\\tpublic function get_by_testid( string $test_id ): static {\\n\\t\\treturn $this->filter( \\\"[data-testid=\\\\\\\"{$test_id}\\\\\\\"]\\\" );\\n\\t}\\n\\n\\t\/**\\n\\t * Query the document for a single element using an XPath expression.\\n\\t *\\n\\t * @param string $xpath\\n\\t *\/\\n\\tpublic function first_by_xpath( string $xpath ): static {\\n\\t\\treturn $this->filterXPath( $xpath )->first();\\n\\t}\\n\\n\\t\/**\\n\\t * Get the tag name of the first element in the HTML instance.\\n\\t *\/\\n\\tpublic function tag_name(): string {\\n\\t\\treturn $this->nodeName();\\n\\t}\\n\\n\\t\/**\\n\\t * Modify the elements using a callback function.\\n\\t *\\n\\t * @param callable $callback A callback function that receives the matched element and its index.\\n\\t * @phpstan-param callable(HTML $crawler, int $i): (DOMNode|string|HTML|null) $callback\\n\\t *\/\\n\\tpublic function modify( callable $callback ): static {\\n\\t\\t$this->each( function ( HTML $item, int $index ) use ( $callback ): HTML {\\n\\t\\t\\t$result = $callback( $item, $index );\\n\\n\\t\\t\\t\/\/ If the callback returns null, we can assume the callback modified the\\n\\t\\t\\t\/\/ node and we can return it as-is.\\n\\t\\t\\tif ( null === $result || $result instanceof static ) {\\n\\t\\t\\t\\treturn $item;\\n\\t\\t\\t}\\n\\n\\t\\t\\t\/\/ Convert the result to a DOMNode if it's a string.\\n\\t\\t\\tif ( is_string( $result ) ) {\\n\\t\\t\\t\\t$result = ( new static( $result ) )->getNode( 0 );\\n\\t\\t\\t}\\n\\n\\t\\t\\t\/\/ If the callback did return something and it's a DOMNode we'll assume\\n\\t\\t\\t\/\/ they want to replace the node with the new one.\\n\\t\\t\\tif ( $result instanceof DOMNode ) {\\n\\t\\t\\t\\t\/\/ If the new node is the same as the existing one, return the item.\\n\\t\\t\\t\\tif ( $result === $item->getNode( 0 ) ) {\\n\\t\\t\\t\\t\\treturn $item;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t$node = $item->getNode( 0 );\\n\\n\\t\\t\\t\\t$node->parentNode->replaceChild( static::import_new_node( $result, $node ), $node );\\n\\n\\t\\t\\t\\treturn $item;\\n\\t\\t\\t}\\n\\n\\t\\t\\tthrow new InvalidArgumentException( 'Callback must return null or a DOMNode instance.' );\\n\\t\\t} );\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set an attribute for all elements in the HTML instance.\\n\\t *\\n\\t * @param string $name  The name of the attribute to set.\\n\\t * @param string $value The value to set for the attribute.\\n\\t *\/\\n\\tpublic function set_attribute( string $name, string $value ): static {\\n\\t\\tforeach ( $this as $node ) {\\n\\t\\t\\tif ( $node instanceof DOMElement ) {\\n\\t\\t\\t\\t$node->setAttribute( $name, $value );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Get the value of an attribute for the first element in the HTML instance.\\n\\t *\\n\\t * @param string      $name    The name of the attribute to retrieve.\\n\\t * @param string|null $default The default value to return if the attribute is not found.\\n\\t *\/\\n\\tpublic function get_attribute( string $name, ?string $default = null ): ?string {\\n\\t\\treturn $this->attr( $name, $default );\\n\\t}\\n\\n\\t\/**\\n\\t * Set a data attribute for all elements in the HTML instance.\\n\\t *\\n\\t * @param string $name  The name of the data attribute to set (without \\\"data-\\\" prefix).\\n\\t * @param string $value The value to set for the data attribute.\\n\\t *\/\\n\\tpublic function set_data( string $name, string $value ): static {\\n\\t\\treturn $this->set_attribute( \\\"data-{$name}\\\", $value );\\n\\t}\\n\\n\\t\/**\\n\\t * Remove an attribute from all elements in the HTML instance.\\n\\t *\\n\\t * @param string $name\\n\\t *\/\\n\\tpublic function remove_attribute( string $name ): static {\\n\\t\\tforeach ( $this as $node ) {\\n\\t\\t\\tif ( $node instanceof DOMElement ) {\\n\\t\\t\\t\\t$node->removeAttribute( $name );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Remove a data attribute from all elements in the HTML instance.\\n\\t *\\n\\t * @param string $name The name of the data attribute to remove (without \\\"data-\\\" prefix).\\n\\t *\/\\n\\tpublic function remove_data( string $name ): static {\\n\\t\\treturn $this->remove_attribute( \\\"data-{$name}\\\" );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the value of a data attribute for the first element in the HTML instance.\\n\\t *\\n\\t * @param string $name The name of the data attribute to retrieve (without \\\"data-\\\" prefix).\\n\\t * @return string|null The value of the data attribute, or null if not found.\\n\\t *\/\\n\\tpublic function get_data( string $name ): ?string {\\n\\t\\treturn $this->attr( \\\"data-{$name}\\\" );\\n\\t}\\n\\n\\t\/**\\n\\t * Add a class to all elements in the HTML instance.\\n\\t *\\n\\t * @param string ...$class\\n\\t *\/\\n\\tpublic function add_class( string ...$class ): static {\\n\\t\\t$class = Arr::wrap( $class );\\n\\n\\t\\tforeach ( $this as $node ) {\\n\\t\\t\\tif ( $node instanceof DOMElement ) {\\n\\t\\t\\t\\t$node->setAttribute( 'class', classname( $node->getAttribute( 'class' ), ...$class ) );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Remove a class from all elements in the HTML instance.\\n\\t *\\n\\t * @param string ...$class Class names to remove from the elements.\\n\\t *\/\\n\\tpublic function remove_class( string ...$class ): static {\\n\\t\\t$class = Arr::wrap( $class );\\n\\n\\t\\tforeach ( $this as $node ) {\\n\\t\\t\\tif ( ! $node instanceof DOMElement ) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$existing = stringable( $node->getAttribute( 'class' ) )->explode( ' ' );\\n\\n\\t\\t\\t\/\/ Remove the classes from the existing class list.\\n\\t\\t\\t$value = $existing->diff( $class )->implode( ' ' );\\n\\n\\t\\t\\tif ( empty( $value ) ) {\\n\\t\\t\\t\\t$node->removeAttribute( 'class' );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t$node->setAttribute( 'class', $value );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Check if any of the elements in the HTML instance have a specific class.\\n\\t *\\n\\t * @param string ...$class Class names to check for.\\n\\t *\/\\n\\tpublic function has_class( string ...$class ): bool {\\n\\t\\t$class = Arr::wrap( $class );\\n\\n\\t\\tforeach ( $this as $node ) {\\n\\t\\t\\tif ( $node instanceof DOMElement ) {\\n\\t\\t\\t\\t$existing = stringable( $node->getAttribute( 'class' ) )->explode( ' ' );\\n\\n\\t\\t\\t\\tif ( $existing->intersect( $class )->count() === count( $class ) ) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\t\/**\\n\\t * Check if any of the elements in the HTML instance have any of the\\n\\t * specified classes.\\n\\t *\\n\\t * @param string ...$class Class names to check for.\\n\\t *\/\\n\\tpublic function has_any_class( string ...$class ): bool {\\n\\t\\t$class = Arr::wrap( $class );\\n\\n\\t\\tforeach ( $this as $node ) {\\n\\t\\t\\tif ( $node instanceof DOMElement ) {\\n\\t\\t\\t\\t$existing = stringable( $node->getAttribute( 'class' ) )->explode( ' ' );\\n\\n\\t\\t\\t\\tif ( $existing->intersect( $class )->is_not_empty() ) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\t\/**\\n\\t * Remove all elements matching a given CSS selector from the document.\\n\\t *\\n\\t * @param string $selector CSS selector to match.\\n\\t *\/\\n\\tpublic function remove( string $selector ): static {\\n\\t\\t$this->filter( $selector )->each( function ( HTML $item ): void {\\n\\t\\t\\t$node = $item->getNode( 0 );\\n\\n\\t\\t\\tif ( $node instanceof \\\\DOMNode && $node->parentNode instanceof \\\\DOMNode ) {\\n\\t\\t\\t\\t$node->parentNode->removeChild( $node );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Prepend a new element to all elements in the HTML instance.\\n\\t *\\n\\t * @throws InvalidArgumentException If the provided element is invalid.\\n\\t *\\n\\t * @param string|HTML|DOMNode $element\\n\\t *\/\\n\\tpublic function prepend( string|HTML|DOMNode $element ): static {\\n\\t\\t$content = self::create( $element );\\n\\t\\t$nodes   = [];\\n\\n\\t\\tforeach ( $this as $node ) {\\n\\t\\t\\t$ref_node = $node->firstChild;\\n\\n\\t\\t\\tforeach ( $content as $new_node ) {\\n\\t\\t\\t\\t$new_node = static::import_new_node( $new_node, $node );\\n\\n\\t\\t\\t\\tif ( ! $ref_node instanceof \\\\DOMNode ) {\\n\\t\\t\\t\\t\\t$node->appendChild( $new_node );\\n\\t\\t\\t\\t} elseif ( $ref_node !== $new_node ) {\\n\\t\\t\\t\\t\\t$node->insertBefore( $new_node, $ref_node );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t$nodes[] = $new_node;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t$content->clear();\\n\\t\\t$content->add( $nodes );\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Append a new element to all elements in the HTML instance.\\n\\t *\\n\\t * @throws InvalidArgumentException If the provided element is invalid.\\n\\t *\\n\\t * @param string|HTML|DOMNode $element\\n\\t *\/\\n\\tpublic function append( string|HTML|DOMNode $element ): static {\\n\\t\\t$element = self::create( $element );\\n\\t\\t$nodes   = [];\\n\\n\\t\\tforeach ( $this as $node ) {\\n\\t\\t\\tforeach ( $element as $new_node ) {\\n\\t\\t\\t\\t$new_node = static::import_new_node( $new_node, $node );\\n\\n\\t\\t\\t\\t$node->appendChild( $new_node );\\n\\n\\t\\t\\t\\t$nodes[] = $new_node;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t$element->clear();\\n\\t\\t$element->add( $nodes );\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Insert content, specified by the parameter, after each element in the set of matched elements.\\n\\t *\\n\\t * @param string|self|DOMNode|DOMNodeList<DOMNode> $content\\n\\t *\/\\n\\tpublic function after( string|self|DOMNode|DOMNodeList $content ): static {\\n\\t\\t$content = self::create( $content );\\n\\t\\t$nodes   = [];\\n\\n\\t\\tforeach ( $this as $node ) {\\n\\t\\t\\t$ref_node = $node->nextSibling;\\n\\n\\t\\t\\tforeach ( $content as $new_node ) {\\n\\t\\t\\t\\t$new_node = static::import_new_node( $new_node, $node );\\n\\n\\t\\t\\t\\tif ( ! $ref_node instanceof \\\\DOMNode ) {\\n\\t\\t\\t\\t\\t$node->parentNode->appendChild( $new_node );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t$node->parentNode->insertBefore( $new_node, $ref_node );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t$nodes[] = $new_node;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t$content->clear();\\n\\t\\t$content->add( $nodes );\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Insert content, specified by the parameter, before each element in the set of matched elements.\\n\\t *\\n\\t * @param string|self|DOMNode|DOMNodeList<DOMNode> $content\\n\\t *\/\\n\\tpublic function before( string|self|DOMNode|DOMNodeList $content ): static {\\n\\t\\t$content = self::create( $content );\\n\\t\\t$nodes   = [];\\n\\n\\t\\tforeach ( $this as $node ) {\\n\\t\\t\\tforeach ( $content as $newnode ) {\\n\\t\\t\\t\\tif ( $node !== $newnode ) {\\n\\t\\t\\t\\t\\t$newnode = static::import_new_node( $newnode, $node );\\n\\n\\t\\t\\t\\t\\t$node->parentNode->insertBefore( $newnode, $node );\\n\\n\\t\\t\\t\\t\\t$nodes[] = $newnode;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t$content->clear();\\n\\t\\t$content->add( $nodes );\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Retrieve the next elements but not including the current in the HTML\\n\\t * instance after the callback matches.\\n\\t *\\n\\t * @param callable $callback Callback to determine when to stop skipping elements.\\n\\t * @phpstan-param callable(HTML $crawler): bool $callback\\n\\t * @param bool     $include Whether to include the current\/first element in the result.\\n\\t *\/\\n\\tpublic function next_until( callable $callback, bool $include = false ): static {\\n\\t\\t$matched = false;\\n\\t\\t$crawler = new static( null );\\n\\n\\t\\tforeach ( $this as $node ) {\\n\\t\\t\\tif ( ! $node instanceof DOMElement ) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( $matched ) {\\n\\t\\t\\t\\t$crawler->add( $node );\\n\\t\\t\\t} elseif ( $callback( new static( $node ) ) ) {\\n\\t\\t\\t\\t$matched = true;\\n\\n\\t\\t\\t\\tif ( $include ) {\\n\\t\\t\\t\\t\\t$crawler->add( $node );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $crawler;\\n\\t}\\n\\n\\t\/**\\n\\t * Retrieve all elements until the callback matches, but not including the matched element.\\n\\t *\\n\\t * @param callable $callback Callback to determine when to stop adding elements.\\n\\t * @phpstan-param callable(HTML $crawler): bool $callback\\n\\t * @param bool     $include Whether to include the current\/last element in the result.\\n\\t *\/\\n\\tpublic function previous_until( callable $callback, bool $include = false ): static {\\n\\t\\t$crawler = new static( null );\\n\\n\\t\\tforeach ( $this as $node ) {\\n\\t\\t\\tif ( ! $node instanceof DOMElement ) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$matches = $callback( new static( $node ) );\\n\\n\\t\\t\\tif ( ! $matches || $include ) {\\n\\t\\t\\t\\t$crawler->add( $node );\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( $matches ) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $crawler;\\n\\t}\\n\\n\\t\/**\\n\\t * Wrap all the elements in the HTML instance with a specified wrapping element.\\n\\t *\\n\\t * @throws InvalidArgumentException If the wrapping element is invalid.\\n\\t *\\n\\t * @param string|HTML|DOMNode $element The wrapping element to use. Can be a string, a HTML instance, or a DOMNode.\\n\\t *\/\\n\\tpublic function wrap( string|HTML|DOMNode $element ): static {\\n\\t\\t$element = $this->resolve_mixed_argument( $element );\\n\\n\\t\\tif ( is_null( $element ) ) {\\n\\t\\t\\tthrow new InvalidArgumentException( 'Invalid wrapping element provided.' );\\n\\t\\t}\\n\\n\\t\\t\/\/ Bail out if there are no nodes to wrap.\\n\\t\\tif ( ! $this->has_nodes() ) {\\n\\t\\t\\treturn $this;\\n\\t\\t}\\n\\n\\t\\tforeach ( $this as $node ) {\\n\\t\\t\\tif ( ! $node instanceof DOMElement ) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$new_node = static::import_new_node( $element, $node );\\n\\n\\t\\t\\t$node->parentNode->insertBefore( $new_node, $node );\\n\\t\\t\\t$new_node->appendChild( $node );\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Wrap all elements that match the HTML instance with a single wrapping\\n\\t * element.\\n\\t *\\n\\t * Example:\\n\\t *\\n\\t * Before wrapping:\\n\\t *\\n\\t * ```php\\n\\t * <div>\\n\\t *   <h3>Title<\/h3>\\n\\t *   <p>Content<\/p>\\n\\t *   <p>More content<\/p>\\n\\t *   <p>Even more content<\/p>\\n\\t * <\/div>\\n\\t * ```\\n\\t *\\n\\t * After wrapping 'p' elements with `<div class=\\\"wrapper\\\">`:\\n\\t *\\n\\t * ```php\\n\\t * <div>\\n\\t *  <h3>Title<\/h3>\\n\\t *  <div class=\\\"wrapper\\\">\\n\\t *      <p>Content<\/p>\\n\\t *      <p>More content<\/p>\\n\\t *      <p>Even more content<\/p>\\n\\t *  <\/div>\\n\\t * <\/div>\\n\\t * ```\\n\\t *\\n\\t * @throws InvalidArgumentException If the wrapping element is invalid.\\n\\t * @param string|HTML|DOMNode $element\\n\\t *\/\\n\\tpublic function wrap_all( string|HTML|DOMNode $element ): static {\\n\\t\\t$element = $this->resolve_mixed_argument( $element );\\n\\n\\t\\tif ( is_null( $element ) ) {\\n\\t\\t\\tthrow new InvalidArgumentException( 'Invalid wrapping element provided.' );\\n\\t\\t}\\n\\n\\t\\t\/\/ Bail out if there are no nodes to wrap.\\n\\t\\tif ( ! $this->has_nodes() ) {\\n\\t\\t\\treturn $this;\\n\\t\\t}\\n\\n\\t\\t$parent = $this->getNode( 0 )?->parentNode;\\n\\n\\t\\tif ( $parent instanceof DOMDocument ) {\\n\\t\\t\\tthrow new InvalidArgumentException( 'Cannot wrap nodes that are direct children of a DOMDocument' );\\n\\t\\t}\\n\\n\\t\\tforeach ( $this as $node ) {\\n\\t\\t\\tif ( $node->parentNode !== $parent ) {\\n\\t\\t\\t\\tthrow new InvalidArgumentException( 'Nodes to be wrapped with wrap_all() must all have the same parent' );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t\/\/ Create a new wrapping element and insert it before the first node.\\n\\t\\t$new_node = static::import_new_node( $element, $this->getNode( 0 ) );\\n\\t\\t$parent->insertBefore( $new_node, $this->getNode( 0 ) );\\n\\n\\t\\tforeach ( $this as $node ) {\\n\\t\\t\\t$new_node->appendChild( $node );\\n\\t\\t}\\n\\n\\t\\t\/\/ Remove the wrapping element if it has no child nodes after wrapping.\\n\\t\\tif ( ! $parent->hasChildNodes() ) {\\n\\t\\t\\t$parent->parentNode->removeChild( $parent );\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Wrap all the inner content of the elements in the HTML instance with a\\n\\t * specified wrapping element.\\n\\t *\\n\\t * @throws InvalidArgumentException If the wrapping element is invalid.\\n\\t *\\n\\t * @param string|HTML|DOMNode $element The wrapping element to use.\\n\\t *\/\\n\\tpublic function wrap_inner( string|HTML|DOMNode $element ): static {\\n\\t\\t$element = $this->resolve_mixed_argument( $element );\\n\\n\\t\\tif ( is_null( $element ) ) {\\n\\t\\t\\tthrow new InvalidArgumentException( 'Invalid wrapping element provided.' );\\n\\t\\t}\\n\\n\\t\\tforeach ( $this as $node ) {\\n\\t\\t\\t( new static( $node->childNodes ) )->wrap_all( $element );\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Empty the content of all elements in the HTML instance.\\n\\t *\\n\\t * This method sets the nodeValue of each element to an empty string,\\n\\t * effectively removing all child nodes and text content.\\n\\t *\/\\n\\tpublic function empty(): static {\\n\\t\\tforeach ( $this as $node ) {\\n\\t\\t\\t$node->nodeValue = '';\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Check if the HTML instance has any nodes.\\n\\t *\/\\n\\tpublic function has_nodes(): bool {\\n\\t\\treturn $this->count() > 0;\\n\\t}\\n\\n\\t\/**\\n\\t * Dump the HTML representation of the HTML instance.\\n\\t *\/\\n\\tpublic function dump(): static {\\n\\t\\tdump( $this->to_html() );\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Dump the HTML representation of the HTML instance and stop execution.\\n\\t *\/\\n\\tpublic function dd(): never {\\n\\t\\tdd( $this->to_html() );\\n\\t}\\n\\n\\t\/**\\n\\t * Check if the first node in the HTML instance is an HTML document.\\n\\t *\/\\n\\tpublic function is_html_document(): bool {\\n\\t\\t$node = $this->getNode( 0 );\\n\\t\\treturn ( $node instanceof \\\\DOMElement\\n\\t\\t\\t&& $node->ownerDocument instanceof \\\\DOMDocument\\n\\t\\t\\t&& $node->ownerDocument->documentElement === $node\\n\\t\\t\\t&& $node->nodeName === 'html'\\n\\t\\t);\\n\\t}\\n\\n\\t\/**\\n\\t * Get ownerDocument of the first element.\\n\\t *\/\\n\\tpublic function get_dom_document(): ?DOMDocument {\\n\\t\\t$node = $this->getNode( 0 );\\n\\n\\t\\treturn $node instanceof \\\\DOMElement && $node->ownerDocument instanceof DOMDocument\\n\\t\\t\\t? $node->ownerDocument\\n\\t\\t\\t: null;\\n\\t}\\n\\n\\t\/**\\n\\t * Adds HTML\/XML content to the HtmlPageHTML object (but not to the DOM of an already attached node).\\n\\t *\\n\\t * Function overridden from HTML because HTML fragments are always added as complete documents there\\n\\t *\\n\\t * @param string      $content A string to parse as HTML\/XML.\\n\\t * @param null|string $type    The content type of the string.\\n\\t *\/\\n\\t#[Override]\\n\\tpublic function addContent( string $content, ?string $type = null ): void {\\n\\t\\tif ( empty( $type ) ) {\\n\\t\\t\\t$type = 'text\/html;charset=UTF-8';\\n\\t\\t}\\n\\n\\t\\t\/\/ The string contains no <html> Tag => no complete document but an HTML fragment.\\n\\t\\tif ( str_starts_with( $type, 'text\/html' ) && ! preg_match( '\/<html\\\\b[^>]*>\/i', $content ) ) {\\n\\t\\t\\t$this->add_html_fragment( $content );\\n\\t\\t} else {\\n\\t\\t\\tparent::addContent( $content, $type );\\n\\t\\t}\\n\\t}\\n\\n\\t\/**\\n\\t * Adds an HTML fragment to the HTML object.\\n\\t *\\n\\t * This method parses the provided HTML fragment and appends its child nodes\\n\\t * to the root of the current HTML instance.\\n\\t *\\n\\t * @param string $content The HTML fragment to add.\\n\\t * @param string $charset The character set to use for parsing (default: 'UTF-8').\\n\\t *\/\\n\\tpublic function add_html_fragment( string $content, string $charset = 'UTF-8' ): void {\\n\\t\\t$document                     = new \\\\DOMDocument( '1.0', $charset );\\n\\t\\t$document->preserveWhiteSpace = false;\\n\\n\\t\\t$root      = $document->appendChild( $document->createElement( self::FRAGMENT_ROOT_TAGNAME ) );\\n\\t\\t$body_node = Helpers::get_body_node_from_html_fragment( $content, $charset );\\n\\n\\t\\tforeach ( $body_node->childNodes as $child ) {\\n\\t\\t\\t$inode = $root->appendChild( $document->importNode( $child, true ) );\\n\\n\\t\\t\\t$this->addNode( $inode );\\n\\t\\t}\\n\\t}\\n\\n\\t\/**\\n\\t * Import a new node into the existing document and replace the existing node.\\n\\t *\\n\\t * @param DOMNode $new_node The new node to import.\\n\\t * @param DOMNode $existing_node The existing node to replace.\\n\\t * @param bool    $clone Whether to clone the new node if it belongs to the same document.\\n\\t *\/\\n\\tprotected static function import_new_node( DOMNode $new_node, DOMNode $existing_node, bool $clone = false ): DOMNode {\\n\\t\\tif ( $new_node->ownerDocument !== $existing_node->ownerDocument ) {\\n\\t\\t\\t$existing_node->ownerDocument->preserveWhiteSpace = false;\\n\\n\\t\\t\\t$new_node = $existing_node->ownerDocument->importNode( $new_node, true );\\n\\t\\t} elseif ( $clone ) {\\n\\t\\t\\t$new_node = $new_node->cloneNode( true );\\n\\t\\t}\\n\\n\\t\\treturn $new_node;\\n\\t}\\n\\n\\t\/**\\n\\t * Resolve the wrapping element to a DOMNode.\\n\\t *\\n\\t * @param string|HTML|DOMNode $wrapping_element The wrapping element to resolve.\\n\\t *\/\\n\\tprotected function resolve_mixed_argument( string|HTML|DOMNode $wrapping_element ): ?DOMNode {\\n\\t\\tif ( is_string( $wrapping_element ) ) {\\n\\t\\t\\treturn ( new static( $wrapping_element ) )->getNode( 0 );\\n\\t\\t}\\n\\n\\t\\tif ( $wrapping_element instanceof HTML ) {\\n\\t\\t\\treturn $wrapping_element->getNode( 0 );\\n\\t\\t}\\n\\n\\t\\treturn $wrapping_element;\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/class-arr.php\",\"ext\":\"php\",\"size\":15716,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Arr class file.\\n *\\n * @package Mantle\\n *\\n * phpcs:disable VariableAnalysis.CodeAnalysis.VariableAnalysis.VariableRedeclaration\\n *\/\\n\\nnamespace Mantle\\\\Support;\\n\\nuse ArrayAccess;\\nuse InvalidArgumentException;\\nuse Mantle\\\\Support\\\\Helpers;\\n\\n\/**\\n * Array Helpers\\n *\/\\nclass Arr {\\n\\n\\t\/**\\n\\t * Determine whether the given value is array accessible.\\n\\t *\\n\\t * @param  mixed $value Value to check.\\n\\t *\/\\n\\tpublic static function accessible( $value ): bool {\\n\\t\\treturn is_array( $value ) || $value instanceof ArrayAccess;\\n\\t}\\n\\n\\t\/**\\n\\t * Add an element to an array using \\\"dot\\\" notation if it doesn't exist.\\n\\t *\\n\\t * @param  array<mixed> $array Array to check.\\n\\t * @param  string       $key Key to check.\\n\\t * @param  mixed        $value Value to use.\\n\\t * @return array<mixed>\\n\\t *\/\\n\\tpublic static function add( array $array, string $key, $value ): array {\\n\\t\\tif ( is_null( static::get( $array, $key ) ) ) {\\n\\t\\t\\tstatic::set( $array, $key, $value );\\n\\t\\t}\\n\\n\\t\\treturn $array;\\n\\t}\\n\\n\\t\/**\\n\\t * Collapse an array of arrays into a single array.\\n\\t *\\n\\t * @param iterable<mixed> $array Array to use.\\n\\t * @return array<mixed>\\n\\t *\/\\n\\tpublic static function collapse( $array ): array {\\n\\t\\t$results = [];\\n\\n\\t\\tforeach ( $array as $values ) {\\n\\t\\t\\tif ( $values instanceof \\\\Mantle\\\\Support\\\\Collection ) {\\n\\t\\t\\t\\t$values = $values->all();\\n\\t\\t\\t} elseif ( ! is_array( $values ) ) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$results[] = $values;\\n\\t\\t}\\n\\n\\t\\treturn array_merge( [], ...$results );\\n\\t}\\n\\n\\t\/**\\n\\t * Cross join the given arrays, returning all possible permutations.\\n\\t *\\n\\t * @param  iterable<array<mixed>> ...$arrays Arrays to join.\\n\\t * @return array<mixed>\\n\\t *\/\\n\\tpublic static function cross_join( ...$arrays ): array {\\n\\t\\t$results = [ [] ];\\n\\n\\t\\tforeach ( $arrays as $index => $array ) {\\n\\t\\t\\t$append = [];\\n\\n\\t\\t\\tforeach ( $results as $result ) {\\n\\t\\t\\t\\tforeach ( $array as $item ) {\\n\\t\\t\\t\\t\\t$result[ $index ] = $item;\\n\\n\\t\\t\\t\\t\\t$append[] = $result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t$results = $append;\\n\\t\\t}\\n\\n\\t\\treturn $results;\\n\\t}\\n\\n\\t\/**\\n\\t * Divide an array into two arrays. One with keys and the other with values.\\n\\t *\\n\\t * @param  array<mixed> $array Array to divide.\\n\\t * @return array<mixed>\\n\\t *\/\\n\\tpublic static function divide( $array ): array {\\n\\t\\treturn [ array_keys( $array ), array_values( $array ) ];\\n\\t}\\n\\n\\t\/**\\n\\t * Flatten a multi-dimensional associative array with dots.\\n\\t *\\n\\t * @param iterable<mixed> $array Array to process.\\n\\t * @param  string          $prepend String to prepend, optional.\\n\\t * @return array<mixed>\\n\\t *\/\\n\\tpublic static function dot( $array, string $prepend = '' ): array {\\n\\t\\t$results = [];\\n\\n\\t\\tforeach ( $array as $key => $value ) {\\n\\t\\t\\tif ( is_array( $value ) && ! empty( $value ) ) {\\n\\t\\t\\t\\t$results = array_merge( $results, static::dot( $value, $prepend . $key . '.' ) );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t$results[ $prepend . $key ] = $value;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $results;\\n\\t}\\n\\n\\t\/**\\n\\t * Get all of the given array except for a specified array of keys.\\n\\t *\\n\\t * @param  array<mixed>    $array Array to process.\\n\\t * @param  string[]|string $keys Keys to filter by.\\n\\t * @return array<mixed>\\n\\t *\/\\n\\tpublic static function except( array $array, $keys ): array {\\n\\t\\tstatic::forget( $array, $keys );\\n\\n\\t\\treturn $array;\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if the given key exists in the provided array.\\n\\t *\\n\\t * @param  \\\\ArrayAccess|array<mixed> $array Array to process.\\n\\t * @param  string|int                $key Key to check if it exists.\\n\\t *\/\\n\\tpublic static function exists( $array, $key ): bool {\\n\\t\\tif ( $array instanceof ArrayAccess ) {\\n\\t\\t\\treturn $array->offsetExists( $key );\\n\\t\\t}\\n\\n\\t\\treturn array_key_exists( $key, $array );\\n\\t}\\n\\n\\t\/**\\n\\t * Return the first element in an array passing a given truth test.\\n\\t *\\n\\t * @param iterable<mixed> $array Array to process.\\n\\t * @param  callable|null   $callback Callback filter on, optional.\\n\\t * @param  mixed           $default Default value.\\n\\t *\/\\n\\tpublic static function first( $array, ?callable $callback = null, $default = null ): mixed {\\n\\t\\tif ( is_null( $callback ) ) {\\n\\t\\t\\tif ( empty( $array ) ) {\\n\\t\\t\\t\\treturn Helpers\\\\value( $default );\\n\\t\\t\\t}\\n\\n\\t\\t\\tforeach ( $array as $item ) {\\n\\t\\t\\t\\treturn $item;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tforeach ( $array as $key => $value ) {\\n\\t\\t\\tif ( $callback( $value, $key ) ) {\\n\\t\\t\\t\\treturn $value;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn Helpers\\\\value( $default );\\n\\t}\\n\\n\\t\/**\\n\\t * Return the last element in an array passing a given truth test.\\n\\t *\\n\\t * @param  array<mixed>  $array Array to process.\\n\\t * @param  callable|null $callback Callback to filter by, optional.\\n\\t * @param  mixed         $default Default value.\\n\\t *\/\\n\\tpublic static function last( $array, ?callable $callback = null, $default = null ): mixed {\\n\\t\\tif ( is_null( $callback ) ) {\\n\\t\\t\\treturn empty( $array ) ? Helpers\\\\value( $default ) : end( $array );\\n\\t\\t}\\n\\n\\t\\treturn static::first( array_reverse( $array, true ), $callback, $default );\\n\\t}\\n\\n\\t\/**\\n\\t * Flatten a multi-dimensional array into a single level.\\n\\t *\\n\\t * @param iterable<mixed> $array Array to process.\\n\\t * @param  int|float       $depth Depth to handle.\\n\\t * @return array<mixed>\\n\\t *\/\\n\\tpublic static function flatten( iterable $array, int|float $depth = INF ): array {\\n\\t\\t$result = [];\\n\\n\\t\\tforeach ( $array as $item ) {\\n\\t\\t\\t$item = $item instanceof Collection ? $item->all() : $item;\\n\\n\\t\\t\\tif ( ! is_array( $item ) ) {\\n\\t\\t\\t\\t$result[] = $item;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t$values = 1 === $depth\\n\\t\\t\\t\\t\\t? array_values( $item )\\n\\t\\t\\t\\t\\t: static::flatten( $item, $depth - 1 );\\n\\n\\t\\t\\t\\tforeach ( $values as $value ) {\\n\\t\\t\\t\\t\\t$result[] = $value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $result;\\n\\t}\\n\\n\\t\/**\\n\\t * Remove one or many array items from a given array using \\\"dot\\\" notation.\\n\\t *\\n\\t * @param  array<mixed>    $array Array to handle.\\n\\t * @param  string[]|string $keys Keys to use.\\n\\t *\/\\n\\tpublic static function forget( &$array, $keys ): void {\\n\\t\\t$original = &$array;\\n\\n\\t\\t$keys = (array) $keys;\\n\\n\\t\\tif ( $keys === [] ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tforeach ( $keys as $key ) {\\n\\t\\t\\t\/\/ if the exact key exists in the top-level, remove it.\\n\\t\\t\\tif ( static::exists( $array, $key ) ) {\\n\\t\\t\\t\\tunset( $array[ $key ] );\\n\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$parts = explode( '.', (string) $key );\\n\\n\\t\\t\\t\/\/ Clean up before each pass.\\n\\t\\t\\t$array = &$original;\\n\\n\\t\\t\\twhile ( count( $parts ) > 1 ) { \/\/ phpcs:ignore Squiz.PHP.DisallowSizeFunctionsInLoops.Found\\n\\t\\t\\t\\t$part = array_shift( $parts );\\n\\n\\t\\t\\t\\tif ( isset( $array[ $part ] ) && is_array( $array[ $part ] ) ) {\\n\\t\\t\\t\\t\\t$array = &$array[ $part ];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcontinue 2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tunset( $array[ array_shift( $parts ) ] );\\n\\t\\t}\\n\\t}\\n\\n\\t\/**\\n\\t * Get an item from an array using \\\"dot\\\" notation.\\n\\t *\\n\\t * @param  \\\\ArrayAccess|array<mixed> $array Array to process.\\n\\t * @param  string|int|null           $key Key to retrieve.\\n\\t * @param  mixed                     $default Default value.\\n\\t *\/\\n\\tpublic static function get( $array, $key, $default = null ): mixed {\\n\\t\\tif ( ! static::accessible( $array ) ) {\\n\\t\\t\\treturn Helpers\\\\value( $default );\\n\\t\\t}\\n\\n\\t\\tif ( is_null( $key ) ) {\\n\\t\\t\\treturn $array;\\n\\t\\t}\\n\\n\\t\\tif ( static::exists( $array, $key ) ) {\\n\\t\\t\\treturn $array[ $key ];\\n\\t\\t}\\n\\n\\t\\tif ( strpos( $key, '.' ) === false ) {\\n\\t\\t\\treturn $array[ $key ] ?? Helpers\\\\value( $default );\\n\\t\\t}\\n\\n\\t\\tforeach ( explode( '.', $key ) as $segment ) {\\n\\t\\t\\tif ( static::accessible( $array ) && static::exists( $array, $segment ) ) {\\n\\t\\t\\t\\t$array = $array[ $segment ];\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn Helpers\\\\value( $default );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $array;\\n\\t}\\n\\n\\t\/**\\n\\t * Check if an item or items exist in an array using \\\"dot\\\" notation.\\n\\t *\\n\\t * @param  \\\\ArrayAccess|array<mixed> $array Array to process.\\n\\t * @param  string|string[]           $keys Key to check.\\n\\t *\/\\n\\tpublic static function has( $array, $keys ): bool {\\n\\t\\t$keys = (array) $keys;\\n\\n\\t\\tif ( ! $array || [] === $keys ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tforeach ( $keys as $key ) {\\n\\t\\t\\t$sub_key_array = $array;\\n\\n\\t\\t\\tif ( static::exists( $array, $key ) ) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tforeach ( explode( '.', (string) $key ) as $segment ) {\\n\\t\\t\\t\\tif ( static::accessible( $sub_key_array ) && static::exists( $sub_key_array, $segment ) ) {\\n\\t\\t\\t\\t\\t$sub_key_array = $sub_key_array[ $segment ];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if any of the keys exist in an array using \\\"dot\\\" notation.\\n\\t *\\n\\t * @param  \\\\ArrayAccess|array<mixed> $array Array to process.\\n\\t * @param  string|string[]           $keys Keys to check.\\n\\t *\/\\n\\tpublic static function has_any( $array, $keys ): bool {\\n\\t\\tif ( empty( $keys ) ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t$keys = (array) $keys;\\n\\n\\t\\tif ( empty( $array ) ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tforeach ( $keys as $key ) {\\n\\t\\t\\tif ( static::has( $array, $key ) ) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\t\/**\\n\\t * Determines if an array is associative.\\n\\t *\\n\\t * An array is \\\"associative\\\" if it doesn't have sequential numerical keys beginning with zero.\\n\\t *\\n\\t * @param  array<mixed> $array Array to process.\\n\\t *\/\\n\\tpublic static function is_assoc( array $array ): bool {\\n\\t\\t$keys = array_keys( $array );\\n\\n\\t\\treturn array_keys( $keys ) !== $keys;\\n\\t}\\n\\n\\t\/**\\n\\t * Get a subset of the items from the given array.\\n\\t *\\n\\t * @param  array<mixed>        $array Array to process.\\n\\t * @param  array<mixed>|string $keys Keys to process by.\\n\\t * @return array<mixed>\\n\\t *\/\\n\\tpublic static function only( array $array, array|string $keys ): array {\\n\\t\\treturn array_intersect_key( $array, array_flip( (array) $keys ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Pluck an array of values from an array.\\n\\t *\\n\\t * @param iterable<mixed>          $array Array to process.\\n\\t * @param  string|array<mixed>      $value Values to pluck.\\n\\t * @param  string|array<mixed>|null $key Key to use.\\n\\t * @return array<mixed>\\n\\t *\/\\n\\tpublic static function pluck( $array, $value, $key = null ): array {\\n\\t\\t$results = [];\\n\\n\\t\\t[ $value, $key ] = static::explode_pluck_parameters( $value, $key );\\n\\n\\t\\tforeach ( $array as $item ) {\\n\\t\\t\\t$item_value = Helpers\\\\data_get( $item, $value );\\n\\n\\t\\t\\t\/\/ If the key is \\\"null\\\", we will just append the value to the array and keep\\n\\t\\t\\t\/\/ looping. Otherwise we will key the array using the value of the key we\\n\\t\\t\\t\/\/ received from the developer. Then we'll return the final array form.\\n\\t\\t\\tif ( is_null( $key ) ) {\\n\\t\\t\\t\\t$results[] = $item_value;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t$item_key = Helpers\\\\data_get( $item, $key );\\n\\n\\t\\t\\t\\tif ( is_object( $item_key ) && method_exists( $item_key, '__toString' ) ) {\\n\\t\\t\\t\\t\\t$item_key = (string) $item_key;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t$results[ $item_key ] = $item_value;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $results;\\n\\t}\\n\\n\\t\/**\\n\\t * Explode the \\\"value\\\" and \\\"key\\\" arguments passed to \\\"pluck\\\".\\n\\t *\\n\\t * @param  string|array<mixed>  $value Value to pluck.\\n\\t * @param  string|string[]|null $key Key to use.\\n\\t * @return array<mixed>\\n\\t *\/\\n\\tprotected static function explode_pluck_parameters( $value, $key ): array {\\n\\t\\t$value = is_string( $value ) ? explode( '.', $value ) : $value;\\n\\n\\t\\t$key = is_null( $key ) || is_array( $key ) ? $key : explode( '.', $key );\\n\\n\\t\\treturn [ $value, $key ];\\n\\t}\\n\\n\\t\/**\\n\\t * Push an item onto the beginning of an array.\\n\\t *\\n\\t * @param  array<mixed>    $array Array to process.\\n\\t * @param  mixed           $value Item value.\\n\\t * @param  int|string|null $key Item key to use, optional.\\n\\t * @return array<mixed>\\n\\t *\/\\n\\tpublic static function prepend( array $array, mixed $value, int|string|null $key = null ): array {\\n\\t\\tif ( is_null( $key ) ) {\\n\\t\\t\\tarray_unshift( $array, $value );\\n\\t\\t} else {\\n\\t\\t\\t$array = [ $key => $value ] + $array;\\n\\t\\t}\\n\\n\\t\\treturn $array;\\n\\t}\\n\\n\\t\/**\\n\\t * Get a value from the array, and remove it.\\n\\t *\\n\\t * @param  array<mixed> $array Array to process.\\n\\t * @param  string       $key Key to pull by.\\n\\t * @param  mixed        $default Default value.\\n\\t * @return mixed\\n\\t *\/\\n\\tpublic static function pull( array &$array, $key, $default = null ) {\\n\\t\\t$value = static::get( $array, $key, $default );\\n\\n\\t\\tstatic::forget( $array, $key );\\n\\n\\t\\treturn $value;\\n\\t}\\n\\n\\t\/**\\n\\t * Get one or a specified number of random values from an array.\\n\\t *\\n\\t * @param  array<mixed> $array Array to process.\\n\\t * @param  int|null     $number Number to pull.\\n\\t * @return mixed\\n\\t *\\n\\t * @throws InvalidArgumentException Thrown when the requested number of items is greater\\n\\t *                                   than the length of the array.\\n\\t *\/\\n\\tpublic static function random( array $array, ?int $number = null ) {\\n\\t\\t$requested = is_null( $number ) ? 1 : $number;\\n\\n\\t\\t$count = count( $array );\\n\\n\\t\\tif ( $requested > $count ) {\\n\\t\\t\\tthrow new InvalidArgumentException(\\n\\t\\t\\t\\t\\\"You requested {$requested} items, but there are only {$count} items available.\\\"\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\tif ( is_null( $number ) ) {\\n\\t\\t\\treturn $array[ array_rand( $array ) ];\\n\\t\\t}\\n\\n\\t\\tif ( 0 === $number ) {\\n\\t\\t\\treturn [];\\n\\t\\t}\\n\\n\\t\\t$keys = array_rand( $array, $number );\\n\\n\\t\\t$results = [];\\n\\n\\t\\tforeach ( (array) $keys as $key ) {\\n\\t\\t\\t$results[] = $array[ $key ];\\n\\t\\t}\\n\\n\\t\\treturn $results;\\n\\t}\\n\\n\\t\/**\\n\\t * Set an array item to a given value using \\\"dot\\\" notation.\\n\\t *\\n\\t * If no key is given to the method, the entire array will be replaced.\\n\\t *\\n\\t * @param  array<mixed> $array Array to process.\\n\\t * @param  string|null  $key Key to set.\\n\\t * @param  mixed        $value Value to set.\\n\\t * @return array<mixed>\\n\\t *\/\\n\\tpublic static function set( array &$array, ?string $key, mixed $value ): array {\\n\\t\\tif ( is_null( $key ) ) {\\n\\t\\t\\t$array = $value;\\n\\t\\t\\treturn $array;\\n\\t\\t}\\n\\n\\t\\t$keys = explode( '.', $key );\\n\\n\\t\\tforeach ( $keys as $i => $key ) {\\n\\t\\t\\tif ( count( $keys ) === 1 ) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tunset( $keys[ $i ] );\\n\\n\\t\\t\\t\/\/ If the key doesn't exist at this depth, we will just create an empty array\\n\\t\\t\\t\/\/ to hold the next value, allowing us to create the arrays to hold final\\n\\t\\t\\t\/\/ values at the correct depth. Then we'll keep digging into the array.\\n\\t\\t\\tif ( ! isset( $array[ $key ] ) || ! is_array( $array[ $key ] ) ) {\\n\\t\\t\\t\\t$array[ $key ] = [];\\n\\t\\t\\t}\\n\\n\\t\\t\\t$array = &$array[ $key ];\\n\\t\\t}\\n\\n\\t\\t$array[ array_shift( $keys ) ] = $value;\\n\\n\\t\\treturn $array;\\n\\t}\\n\\n\\t\/**\\n\\t * Shuffle the given array and return the result.\\n\\t *\\n\\t * @param  array<mixed> $array Array to process.\\n\\t * @param  int          $seed Seed to use.\\n\\t * @return array<mixed>\\n\\t *\/\\n\\tpublic static function shuffle( $array, ?int $seed = null ) {\\n\\t\\tif ( is_null( $seed ) ) {\\n\\t\\t\\tshuffle( $array );\\n\\t\\t} else {\\n\\t\\t\\tmt_srand( $seed ); \/\/ phpcs:ignore WordPress.WP.AlternativeFunctions.rand_seeding_mt_srand\\n\\t\\t\\tshuffle( $array );\\n\\t\\t\\tmt_srand(); \/\/ phpcs:ignore WordPress.WP.AlternativeFunctions.rand_seeding_mt_srand\\n\\t\\t}\\n\\n\\t\\treturn $array;\\n\\t}\\n\\n\\t\/**\\n\\t * Sort the array using the given callback or \\\"dot\\\" notation.\\n\\t *\\n\\t * @param  array<mixed>         $array Array to sort.\\n\\t * @param  callable|string|null $callback Callback to sort by.\\n\\t * @return array<mixed>\\n\\t *\/\\n\\tpublic static function sort( $array, $callback = null ) {\\n\\t\\treturn Collection::make( $array )->sort_by( $callback )->all();\\n\\t}\\n\\n\\t\/**\\n\\t * Recursively sort an array by keys and values.\\n\\t *\\n\\t * @param  array<mixed> $array Array to process.\\n\\t * @return array<mixed>\\n\\t *\/\\n\\tpublic static function sort_recursive( $array ) {\\n\\t\\tforeach ( $array as &$value ) {\\n\\t\\t\\tif ( is_array( $value ) ) {\\n\\t\\t\\t\\t$value = static::sort_recursive( $value );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( static::is_assoc( $array ) ) {\\n\\t\\t\\tksort( $array );\\n\\t\\t} else {\\n\\t\\t\\tsort( $array );\\n\\t\\t}\\n\\n\\t\\treturn $array;\\n\\t}\\n\\n\\t\/**\\n\\t * Convert the array into a query string.\\n\\t *\\n\\t * @param  array<mixed> $array Array to process.\\n\\t *\/\\n\\tpublic static function query( $array ): string {\\n\\t\\treturn http_build_query( $array, '', '&', PHP_QUERY_RFC3986 );\\n\\t}\\n\\n\\t\/**\\n\\t * Filter the array using the given callback.\\n\\t *\\n\\t * @param  array<mixed> $array Array to process.\\n\\t * @param  callable     $callback Callback to filter by.\\n\\t * @return array<mixed>\\n\\t *\/\\n\\tpublic static function where( $array, callable $callback ): array {\\n\\t\\treturn array_filter( $array, $callback, ARRAY_FILTER_USE_BOTH );\\n\\t}\\n\\n\\t\/**\\n\\t * If the given value is not an array and not null, wrap it in one.\\n\\t *\\n\\t * @param  mixed $value Value to wrap by.\\n\\t * @return array<mixed>\\n\\t *\/\\n\\tpublic static function wrap( mixed $value ): array {\\n\\t\\tif ( is_null( $value ) ) {\\n\\t\\t\\treturn [];\\n\\t\\t}\\n\\n\\t\\treturn is_array( $value ) ? $value : [ $value ];\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/class-environment.php\",\"ext\":\"php\",\"size\":2461,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Environment class file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support;\\n\\nuse PhpOption\\\\Option;\\nuse Dotenv\\\\Repository\\\\RepositoryBuilder;\\nuse Dotenv\\\\Repository\\\\RepositoryInterface;\\nuse PhpOption\\\\Some;\\n\\nuse function Mantle\\\\Support\\\\Helpers\\\\value;\\n\\n\/**\\n * Storage of environment variables for the application.\\n *\/\\nclass Environment {\\n\\t\/**\\n\\t * Variable repository.\\n\\t *\/\\n\\tprotected static ?RepositoryInterface $repository = null;\\n\\n\\t\/**\\n\\t * Get the environment repository instance.\\n\\t *\/\\n\\tpublic static function get_repository(): RepositoryInterface {\\n\\t\\tif ( ! isset( static::$repository ) ) {\\n\\t\\t\\t$builder = RepositoryBuilder::createWithDefaultAdapters();\\n\\n\\t\\t\\tstatic::$repository = $builder->immutable()->make();\\n\\t\\t}\\n\\n\\t\\treturn static::$repository;\\n\\t}\\n\\n\\t\/**\\n\\t * Clear the environment repository instance.\\n\\t *\/\\n\\tpublic static function clear(): void {\\n\\t\\tstatic::$repository = null;\\n\\t}\\n\\n\\t\/**\\n\\t * Get the value of an environment variable.\\n\\t *\\n\\t * @param string $key Variable to retrieve.\\n\\t * @param mixed  $default Default value. Supports a closure callback.\\n\\t *\/\\n\\tpublic static function get( string $key, mixed $default = null ): mixed {\\n\\t\\t$value = Option::fromValue( static::get_repository()->get( $key ) );\\n\\n\\t\\t\/\/ Fallback to the VIP environment variable if the key is not found.\\n\\t\\tif ( $value instanceof \\\\PhpOption\\\\None ) {\\n\\t\\t\\t$constant     = strtoupper( $key );\\n\\t\\t\\t$vip_constant = \\\"VIP_ENV_VAR_{$key}\\\";\\n\\n\\t\\t\\tif ( defined( $vip_constant ) ) {\\n\\t\\t\\t\\t$value = new Some( constant( $vip_constant ) );\\n\\t\\t\\t} elseif ( defined( $constant ) ) {\\n\\t\\t\\t\\t$value = new Some( constant( $constant ) );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $value\\n\\t\\t->map(\\n\\t\\t\\tfunction ( $value ) {\\n\\t\\t\\t\\tswitch ( strtolower( (string) $value ) ) {\\n\\t\\t\\t\\t\\tcase 'true':\\n\\t\\t\\t\\t\\tcase '(true)':\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\tcase 'false':\\n\\t\\t\\t\\t\\tcase '(false)':\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\tcase 'empty':\\n\\t\\t\\t\\t\\tcase '(empty)':\\n\\t\\t\\t\\t\\t\\treturn '';\\n\\t\\t\\t\\t\\tcase 'null':\\n\\t\\t\\t\\t\\tcase '(null)':\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( preg_match( '\/\\\\A([\\\\'\\\"])(.*)\\\\1\\\\z\/', (string) $value, $matches ) ) {\\n\\t\\t\\t\\t\\treturn $matches[2];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn $value;\\n\\t\\t\\t}\\n\\t\\t)\\n\\t\\t->getOrCall( fn () => value( $default ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the value of an environment variable as a Mixed_Data object.\\n\\t *\\n\\t * @param string $key Variable to retrieve.\\n\\t * @param mixed  $default Default value. Supports a closure callback.\\n\\t *\/\\n\\tpublic static function get_mixed( string $key, mixed $default = null ): Mixed_Data {\\n\\t\\treturn Mixed_Data::of( static::get( $key, $default ) );\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/class-pluralizer.php\",\"ext\":\"php\",\"size\":2692,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Str class file\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support;\\n\\nuse Doctrine\\\\Inflector\\\\Inflector;\\nuse Doctrine\\\\Inflector\\\\InflectorFactory;\\n\\n\/**\\n * Interface with Doctrine Inflector to pluralize and singularize words.\\n *\/\\nclass Pluralizer {\\n\\n\\t\/**\\n\\t * The cached inflector instance.\\n\\t *\/\\n\\tprotected static ?Inflector $inflector = null;\\n\\n\\t\/**\\n\\t * The language that should be used by the inflector.\\n\\t *\\n\\t * @var string\\n\\t *\/\\n\\tprotected static $language = 'english';\\n\\n\\t\/**\\n\\t * Uncountable non-nouns word forms.\\n\\t *\\n\\t * Contains words supported by Doctrine\/Inflector\/Rules\/English\/Uninflected.php\\n\\t *\\n\\t * @var string[]\\n\\t *\/\\n\\tpublic static $uncountable = [\\n\\t\\t'recommended',\\n\\t\\t'related',\\n\\t];\\n\\n\\t\/**\\n\\t * Get the plural form of an English word.\\n\\t *\\n\\t * @param  string                      $value\\n\\t * @param  int|array<mixed>|\\\\Countable $count\\n\\t *\/\\n\\tpublic static function plural( string $value, int|array|\\\\Countable $count = 2 ): string {\\n\\t\\tif ( is_countable( $count ) ) {\\n\\t\\t\\t$count = count( $count );\\n\\t\\t}\\n\\n\\t\\tif ( abs( $count ) === 1 || static::uncountable( $value ) || preg_match( '\/^(.*)[A-Za-z0-9\\\\x{0080}-\\\\x{FFFF}]$\/u', $value ) === 0 ) {\\n\\t\\t\\treturn $value;\\n\\t\\t}\\n\\n\\t\\t$plural = static::inflector()->pluralize( $value );\\n\\n\\t\\treturn static::match_case( $plural, $value );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the singular form of an English word.\\n\\t *\\n\\t * @param  string $value\\n\\t *\/\\n\\tpublic static function singular( string $value ): string {\\n\\t\\t$singular = static::inflector()->singularize( $value );\\n\\n\\t\\treturn static::match_case( $singular, $value );\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if the given value is uncountable.\\n\\t *\\n\\t * @param  string $value\\n\\t *\/\\n\\tprotected static function uncountable( $value ): bool {\\n\\t\\treturn in_array( strtolower( $value ), static::$uncountable, true );\\n\\t}\\n\\n\\t\/**\\n\\t * Attempt to match the case on two strings.\\n\\t *\\n\\t * @param  string $value\\n\\t * @param  string $comparison\\n\\t *\/\\n\\tprotected static function match_case( string $value, string $comparison ): string {\\n\\t\\t$functions = [ 'mb_strtolower', 'mb_strtoupper', 'ucfirst', 'ucwords' ];\\n\\n\\t\\tforeach ( $functions as $function ) {\\n\\t\\t\\tif ( $function( $comparison ) === $comparison ) {\\n\\t\\t\\t\\treturn $function( $value );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $value;\\n\\t}\\n\\n\\t\/**\\n\\t * Get the inflector instance.\\n\\t *\/\\n\\tpublic static function inflector(): Inflector {\\n\\t\\tif ( ! isset( static::$inflector ) ) {\\n\\t\\t\\tstatic::$inflector = InflectorFactory::createForLanguage( static::$language )->build();\\n\\t\\t}\\n\\n\\t\\treturn static::$inflector;\\n\\t}\\n\\n\\t\/**\\n\\t * Specify the language that should be used by the inflector.\\n\\t *\\n\\t * @param  string $language\\n\\t *\/\\n\\tpublic static function use_language( string $language ): void {\\n\\t\\tstatic::$language = $language;\\n\\n\\t\\tstatic::$inflector = null;\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/class-uri.php\",\"ext\":\"php\",\"size\":9355,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Uri class file\\n *\\n * @package mantle\\n *\/\\n\\nnamespace Mantle\\\\Support;\\n\\nuse Mantle\\\\Contracts\\\\Support\\\\Htmlable;\\nuse Mantle\\\\Support\\\\Traits\\\\Conditionable;\\nuse Mantle\\\\Support\\\\Traits\\\\Macroable;\\nuse Mantle\\\\Support\\\\Traits\\\\Tappable;\\nuse League\\\\Uri\\\\Contracts\\\\UriInterface;\\nuse League\\\\Uri\\\\Uri as LeagueUri;\\nuse Symfony\\\\Component\\\\HttpFoundation\\\\RedirectResponse;\\nuse SensitiveParameter;\\nuse Stringable;\\n\\nuse function Mantle\\\\Support\\\\Helpers\\\\data_set;\\n\\n\/**\\n * Uri Support Class\\n *\\n * This class provides a fluent interface for working with URIs, including\\n * methods for retrieving and manipulating various components of a URI such as\\n * scheme, host, path, query parameters, and fragments. It also supports\\n * creating URIs from the current request, merging query parameters, and\\n * generating redirect responses.\\n *\/\\nclass Uri implements Htmlable, Stringable {\\n\\tuse Conditionable;\\n\\tuse Macroable;\\n\\tuse Tappable;\\n\\n\\t\/**\\n\\t * The URI instance.\\n\\t *\/\\n\\tprotected UriInterface $uri;\\n\\n\\t\/**\\n\\t * Create a new parsed URI instance from the current request.\\n\\t *\/\\n\\tpublic static function current(): static {\\n\\t\\treturn new static( LeagueUri::fromServer( $_SERVER ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Create a new parsed URI instance.\\n\\t *\\n\\t * @param UriInterface|Stringable|string $uri The URI to parse. If a Stringable object is provided, it will be converted to a string.\\n\\t *\/\\n\\tpublic function __construct( UriInterface|Stringable|string $uri = '' ) {\\n\\t\\t$this->uri = $uri instanceof UriInterface ? $uri : LeagueUri::new( (string) $uri );\\n\\t}\\n\\n\\t\/**\\n\\t * Create a new URI instance.\\n\\t *\\n\\t * @param UriInterface|Stringable|string $uri The URI to parse. If a Stringable object is provided, it will be converted to a string.\\n\\t *\/\\n\\tpublic static function of( UriInterface|Stringable|string $uri = '' ): static {\\n\\t\\treturn new static( $uri );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the URI's scheme.\\n\\t *\/\\n\\tpublic function scheme(): ?string {\\n\\t\\treturn $this->uri->getScheme();\\n\\t}\\n\\n\\t\/**\\n\\t * Get the user from the URI.\\n\\t *\\n\\t * @param bool $with_password Whether to include the password in the returned string.\\n\\t *\/\\n\\tpublic function user( bool $with_password = false ): ?string {\\n\\t\\treturn $with_password\\n\\t\\t\\t? $this->uri->getUserInfo()\\n\\t\\t\\t: $this->uri->getUsername();\\n\\t}\\n\\n\\t\/**\\n\\t * Get the password from the URI.\\n\\t *\/\\n\\tpublic function password(): ?string {\\n\\t\\treturn $this->uri->getPassword();\\n\\t}\\n\\n\\t\/**\\n\\t * Get the URI's host.\\n\\t *\/\\n\\tpublic function host(): ?string {\\n\\t\\treturn $this->uri->getHost();\\n\\t}\\n\\n\\t\/**\\n\\t * Get the URI's port.\\n\\t *\/\\n\\tpublic function port(): ?int {\\n\\t\\treturn $this->uri->getPort();\\n\\t}\\n\\n\\t\/**\\n\\t * Get the URI's path always with a leading slash.\\n\\t *\\n\\t * Empty or missing paths are returned as a single \\\"\/\\\".\\n\\t *\/\\n\\tpublic function path(): ?string {\\n\\t\\t$path = $this->uri->getPath();\\n\\n\\t\\treturn empty( $path ) ? '\/' : $path;\\n\\t}\\n\\n\\t\/**\\n\\t * Get the URI's path segments.\\n\\t *\\n\\t * Empty or missing paths are returned as an empty collection.\\n\\t *\/\\n\\tpublic function path_segments(): Collection {\\n\\t\\t$path = trim( (string) $this->path(), '\/' );\\n\\n\\t\\treturn empty( $path ) ? new Collection() : new Collection( explode( '\/', $path ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the URI's query string.\\n\\t *\/\\n\\tpublic function query(): Uri_Query_String {\\n\\t\\treturn new Uri_Query_String( $this );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the URI's fragment.\\n\\t *\/\\n\\tpublic function fragment(): ?string {\\n\\t\\treturn $this->uri->getFragment();\\n\\t}\\n\\n\\t\/**\\n\\t * Specify the scheme of the URI.\\n\\t *\\n\\t * @param Stringable|string $scheme The scheme to set in the URI.\\n\\t *\/\\n\\tpublic function with_scheme( Stringable|string $scheme ): static {\\n\\t\\treturn new static( $this->uri->withScheme( $scheme ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Specify the user and password for the URI.\\n\\t *\\n\\t * @param Stringable|string|null $user The user to set in the URI.\\n\\t * @param Stringable|string|null $password The password to set in the URI.\\n\\t *\/\\n\\tpublic function with_user( Stringable|string|null $user, #[SensitiveParameter] Stringable|string|null $password = null ): static {\\n\\t\\treturn new static( $this->uri->withUserInfo( $user, $password ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Specify the host of the URI.\\n\\t *\\n\\t * @param Stringable|string $host The host to set in the URI.\\n\\t *\/\\n\\tpublic function with_host( Stringable|string $host ): static {\\n\\t\\treturn new static( $this->uri->withHost( $host ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Specify the port of the URI.\\n\\t *\\n\\t * @param int|null $port The port to set in the URI. If null, the port will be removed.\\n\\t *\/\\n\\tpublic function with_port( ?int $port ): static {\\n\\t\\treturn new static( $this->uri->withPort( $port ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Specify the path of the URI.\\n\\t *\\n\\t * @param Stringable|string $path The path to set in the URI.\\n\\t *\/\\n\\tpublic function with_path( Stringable|string $path ): static {\\n\\t\\treturn new static( $this->uri->withPath( Str::start( (string) $path, '\/' ) ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Merge new query parameters into the URI.\\n\\t *\\n\\t * @param array<string, mixed> $query\\n\\t * @param bool                 $merge Whether to merge the new query parameters with the\\n\\t *                                    existing ones. If true, existing parameters will be\\n\\t *                                    preserved and new ones will be added. If false, the\\n\\t *                                    existing query parameters will be replaced with the new\\n\\t *                                    ones.\\n\\t *\/\\n\\tpublic function with_query( array $query, bool $merge = true ): static {\\n\\t\\tif ( $merge ) {\\n\\t\\t\\t$merged_query = $this->query()->all();\\n\\n\\t\\t\\tforeach ( $query as $key => $value ) {\\n\\t\\t\\t\\tdata_set( $merged_query, $key, $value );\\n\\t\\t\\t}\\n\\n\\t\\t\\t$new_query = $merged_query;\\n\\t\\t} else {\\n\\t\\t\\t$new_query = [];\\n\\n\\t\\t\\tforeach ( $query as $key => $value ) {\\n\\t\\t\\t\\tdata_set( $new_query, $key, $value );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn new static( $this->uri->withQuery( Arr::query( $new_query ) ?: null ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Merge new query parameters into the URI if they are not already in the query string.\\n\\t *\\n\\t * @param array<string, mixed> $query\\n\\t *\/\\n\\tpublic function with_query_if_missing( array $query ): static {\\n\\t\\t$current = $this->query();\\n\\n\\t\\tforeach ( array_keys( $query ) as $key ) {\\n\\t\\t\\tif ( ! $current->missing( $key ) ) {\\n\\t\\t\\t\\tArr::forget( $query, $key );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $this->with_query( $query );\\n\\t}\\n\\n\\t\/**\\n\\t * Push a value onto the end of a query string parameter that is a list.\\n\\t *\\n\\t * @param string $key The key of the query parameter.\\n\\t * @param mixed  $value The value to push onto the query parameter.\\n\\t *\/\\n\\tpublic function push_onto_query( string $key, mixed $value ): static {\\n\\t\\t$current = data_get( $this->query()->all(), $key );\\n\\n\\t\\t$values = Arr::wrap( $value );\\n\\n\\t\\treturn $this->with_query( [\\n\\t\\t\\t$key => match ( true ) {\\n\\t\\t\\t\\tis_array( $current ) && array_is_list( $current ) => array_values( array_unique( [ ...$current, ...$values ] ) ),\\n\\t\\t\\t\\tis_array( $current ) => [ ...$current, ...$values ],\\n\\t\\t\\t\\t! is_null( $current ) => [ $current, ...$values ],\\n\\t\\t\\t\\tdefault => $values,\\n\\t\\t\\t},\\n\\t\\t] );\\n\\t}\\n\\n\\t\/**\\n\\t * Remove the given query parameters from the URI.\\n\\t *\\n\\t * @param array<string, string>|string|null $keys\\n\\t *\/\\n\\tpublic function without_query( array|string|null $keys = null ): static {\\n\\t\\tif ( is_null( $keys ) ) {\\n\\t\\t\\treturn $this->replace_query( [] );\\n\\t\\t}\\n\\n\\t\\treturn $this->replace_query( Arr::except( $this->query()->all(), $keys ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Specify new query parameters for the URI.\\n\\t *\\n\\t * @param array<string, string> $query\\n\\t *\/\\n\\tpublic function replace_query( array $query ): static {\\n\\t\\treturn $this->with_query( $query, merge: false );\\n\\t}\\n\\n\\t\/**\\n\\t * Specify the fragment of the URI.\\n\\t *\\n\\t * @param string $fragment The fragment to set in the URI.\\n\\t *\/\\n\\tpublic function with_fragment( string $fragment ): static {\\n\\t\\treturn new static( $this->uri->withFragment( $fragment ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Create a redirect HTTP response for the given URI.\\n\\t *\\n\\t * @param  int                   $status HTTP status code for the redirect. Default is 302 (Found).\\n\\t * @param  array<string, string> $headers Additional headers to include in the response.\\n\\t *\/\\n\\tpublic function redirect( int $status = 302, array $headers = [] ): RedirectResponse {\\n\\t\\treturn new RedirectResponse( $this->value(), $status, $headers );\\n\\t}\\n\\n\\t\/**\\n\\t * Create an HTTP response that represents the object.\\n\\t *\\n\\t * @param mixed $request The request object.\\n\\t *\/\\n\\tpublic function to_response( $request ): RedirectResponse {\\n\\t\\treturn new RedirectResponse( $this->value() );\\n\\t}\\n\\n\\t\/**\\n\\t * Get content as a string of HTML.\\n\\t *\/\\n\\tpublic function to_html(): string {\\n\\t\\treturn $this->value();\\n\\t}\\n\\n\\t\/**\\n\\t * Get the decoded string representation of the URI.\\n\\t *\/\\n\\tpublic function decode(): string {\\n\\t\\tif ( empty( $this->query()->to_array() ) ) {\\n\\t\\t\\treturn $this->value();\\n\\t\\t}\\n\\n\\t\\treturn Str::replace( Str::after( $this->value(), '?' ), $this->query()->decode(), $this->value() );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the string representation of the URI.\\n\\t *\/\\n\\tpublic function value(): string {\\n\\t\\treturn (string) $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if the URI is currently an empty string.\\n\\t *\/\\n\\tpublic function is_empty(): bool {\\n\\t\\treturn trim( $this->value() ) === '';\\n\\t}\\n\\n\\t\/**\\n\\t * Dump the string representation of the URI.\\n\\t *\\n\\t * @param  mixed ...$args\\n\\t * @return $this\\n\\t *\/\\n\\tpublic function dump( ...$args ): static {\\n\\t\\tdump( $this->value(), ...$args );\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Get the underlying URI instance.\\n\\t *\/\\n\\tpublic function get_uri(): UriInterface {\\n\\t\\treturn $this->uri;\\n\\t}\\n\\n\\t\/**\\n\\t * Get the string representation of the URI.\\n\\t *\/\\n\\tpublic function __toString(): string {\\n\\t\\treturn $this->uri->toString();\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/class-higher-order-collection-proxy.php\",\"ext\":\"php\",\"size\":1095,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Higher_Order_Collection_Proxy class file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support;\\n\\n\/**\\n * Higher Order Collection Proxy\\n *\\n * @mixin Enumerable\\n *\/\\nclass Higher_Order_Collection_Proxy {\\n\\t\/**\\n\\t * Create a new proxy instance.\\n\\t *\\n\\t * @param  Enumerable $collection The collection being operated on.\\n\\t * @param  string     $method     The method being proxied.\\n\\t * @return void\\n\\t *\/\\n\\tpublic function __construct( protected Enumerable $collection, protected string $method ) {}\\n\\n\\t\/**\\n\\t * Proxy accessing an attribute onto the collection items.\\n\\t *\\n\\t * @param  string $key\\n\\t *\/\\n\\tpublic function __get( string $key ): mixed {\\n\\t\\treturn $this->collection->{ $this->method }(\\n\\t\\t\\tfn ( $value ) => is_array( $value ) ? $value[ $key ] : $value->{$key}\\n\\t\\t);\\n\\t}\\n\\n\\t\/**\\n\\t * Proxy a method call onto the collection items.\\n\\t *\\n\\t * @param  string       $method\\n\\t * @param  array<mixed> $parameters\\n\\t *\/\\n\\tpublic function __call( string $method, array $parameters ): mixed {\\n\\t\\treturn $this->collection->{ $this->method }(\\n\\t\\t\\tfn ( $value ) => $value->{ $method }( ...$parameters )\\n\\t\\t);\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/traits\/trait-makeable.php\",\"ext\":\"php\",\"size\":329,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Makeable trait file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support\\\\Traits;\\n\\ntrait Makeable {\\n\\t\/**\\n\\t * Create a new static instance from arguments.\\n\\t *\\n\\t * @param mixed ...$arguments Arguments to make from.\\n\\t *\/\\n\\tpublic static function make( ...$arguments ): static {\\n\\t\\treturn new static( ...$arguments );\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/traits\/trait-conditionable.php\",\"ext\":\"php\",\"size\":2047,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Conditionable trait file.\\n *\\n * phpcs:disable Squiz.Commenting.FunctionComment\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support\\\\Traits;\\n\\nuse Closure;\\nuse Mantle\\\\Support\\\\Higher_Order_When_Proxy;\\n\\n\/**\\n * Allow a class to conditionally invoke a method fluently.\\n *\\n * A method can use the trait to invoke a method conditionally upon itself.\\n *\/\\ntrait Conditionable {\\n\\t\/**\\n\\t * Apply the callback if the given \\\"value\\\" is (or resolves to) truthy.\\n\\t *\\n\\t * @template TWhenParameter\\n\\t * @template TWhenReturnType\\n\\t *\\n\\t * @param  (\\\\Closure($this): TWhenParameter)|TWhenParameter  $value\\n\\t * @param  (callable($this, TWhenParameter): TWhenReturnType)|null  $callback\\n\\t * @param  (callable($this, TWhenParameter): TWhenReturnType)|null  $default\\n\\t * @return static|TWhenReturnType\\n\\t *\/\\n\\tpublic function when( $value, ?callable $callback = null, ?callable $default = null ) {\\n\\t\\t$value = $value instanceof Closure ? $value( $this ) : $value;\\n\\n\\t\\tif ( func_num_args() === 1 ) {\\n\\t\\t\\treturn new Higher_Order_When_Proxy( $this, $value );\\n\\t\\t}\\n\\n\\t\\tif ( $value ) {\\n\\t\\t\\treturn $callback( $this, $value ) ?? $this;\\n\\t\\t}\\n\\n\\t\\tif ( $default ) {\\n\\t\\t\\treturn $default( $this, $value ) ?? $this;\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Apply the callback if the given \\\"value\\\" is (or resolves to) falsy.\\n\\t *\\n\\t * @template TUnlessParameter\\n\\t * @template TUnlessReturnType\\n\\t *\\n\\t * @param  (\\\\Closure( $this): TUnlessParameter)|TUnlessParameter  $value\\n\\t * @param  (callable( $this, TUnlessParameter): TUnlessReturnType)|null  $callback\\n\\t * @param  (callable( $this, TUnlessParameter): TUnlessReturnType)|null  $default\\n\\t * @return static|TUnlessReturnType\\n\\t *\/\\n\\tpublic function unless( $value, ?callable $callback = null, ?callable $default = null ) {\\n\\t\\t$value = $value instanceof Closure ? $value( $this ) : $value;\\n\\n\\t\\tif ( func_num_args() === 1 ) {\\n\\t\\t\\treturn new Higher_Order_When_Proxy( $this, ! $value );\\n\\t\\t}\\n\\n\\t\\tif ( ! $value ) {\\n\\t\\t\\treturn $callback( $this, $value ) ?? $this;\\n\\t\\t}\\n\\n\\t\\tif ( $default ) {\\n\\t\\t\\treturn $default( $this, $value ) ?? $this;\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/traits\/trait-hookable.php\",\"ext\":\"php\",\"size\":7082,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Hookable trait file\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support\\\\Traits;\\n\\nuse Mantle\\\\Support\\\\Attributes\\\\Action;\\nuse Mantle\\\\Support\\\\Attributes\\\\Filter;\\nuse Mantle\\\\Support\\\\Attributes\\\\Hookable\\\\Allow_Legacy_Duplicate_Registration;\\nuse Mantle\\\\Support\\\\Collection;\\nuse Mantle\\\\Support\\\\Service_Provider;\\nuse Mantle\\\\Support\\\\Str;\\nuse ReflectionAttribute;\\nuse ReflectionClass;\\nuse ReflectionMethod;\\nuse RuntimeException;\\n\\nuse function Mantle\\\\Support\\\\Helpers\\\\collect;\\n\\n\/**\\n * Register all hooks on a class.\\n *\\n * Collects all of the `Action`\/`Filter` attribute methods as well as the\\n * `on_{hook}` and `on_{hook}_at_{priority}` methods and registers them with the\\n * respective WordPress hooks.\\n *\\n * Attributes are the preferred way to register hooks but the method naming\\n * convention to define the hook name is still supported for backwards\\n * compatibility.\\n *\\n * @phpstan-type HookItem array{type: string, hook: string, method: string, priority: int}\\n *\/\\ntrait Hookable {\\n\\t\/**\\n\\t * Flag to determine if the hooks have been registered.\\n\\t *\/\\n\\tprotected bool $hooks_registered = false;\\n\\n\\t\/**\\n\\t * Reflection class instance.\\n\\t *\/\\n\\tprivate ReflectionClass $reflection;\\n\\n\\t\/**\\n\\t * Constructor (can be overridden by the trait user).\\n\\t *\/\\n\\tpublic function __construct() {\\n\\t\\t$this->register_hooks();\\n\\t}\\n\\n\\t\/**\\n\\t * Boot all actions and attribute methods on the service provider.\\n\\t *\\n\\t * Collects all of the `on_{hook}`, `on_{hook}_at_{priority}`,\\n\\t * `action__{hook}`, and `filter__{hook}` methods as well as the attribute\\n\\t * based `#[Action]` and `#[Filter]` methods and registers them with the\\n\\t * respective WordPress hooks.\\n\\t *\/\\n\\tprotected function register_hooks(): void {\\n\\t\\tif ( $this->hooks_registered ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t$this->reflection = new ReflectionClass( static::class );\\n\\n\\t\\t$this->collect_action_methods()\\n\\t\\t\\t->merge( $this->collect_attribute_hooks() )\\n\\t\\t\\t->unique()\\n\\t\\t\\t->each(\\n\\t\\t\\t\\tfunction ( array $item ): void {\\n\\t\\t\\t\\t\\tif ( $this->use_event_dispatcher() ) {\\n\\t\\t\\t\\t\\t\\tif ( 'action' === $item['type'] ) {\\n\\t\\t\\t\\t\\t\\t\\t\\\\Mantle\\\\Support\\\\Helpers\\\\add_action( $item['hook'], [ $this, $item['method'] ], $item['priority'] );\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\\\Mantle\\\\Support\\\\Helpers\\\\add_filter( $item['hook'], [ $this, $item['method'] ], $item['priority'] );\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\/\/ Use the default WordPress action\/filter methods.\\n\\t\\t\\t\\t\\tif ( 'action' === $item['type'] ) {\\n\\t\\t\\t\\t\\t\\t\\\\add_action( $item['hook'], [ $this, $item['method'] ], $item['priority'], 999 );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\\\add_filter( $item['hook'], [ $this, $item['method'] ], $item['priority'], 999 );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t},\\n\\t\\t\\t);\\n\\n\\t\\t$this->hooks_registered = true;\\n\\t}\\n\\n\\t\/**\\n\\t * Collect all action methods from the service provider.\\n\\t *\\n\\t * @phpstan-return Collection<int, HookItem>\\n\\t *\/\\n\\tprivate function collect_action_methods(): Collection {\\n\\t\\t\/\/ Determine if the legacy attribute is on the class to allow for duplicate\\n\\t\\t\/\/ hook registration when a action method has an attribute.\\n\\t\\t$has_legacy_attribute = collect(\\n\\t\\t\\t( $this->reflection )->getAttributes( Allow_Legacy_Duplicate_Registration::class ),\\n\\t\\t)->is_not_empty();\\n\\n\\t\\treturn collect( get_class_methods( static::class ) )\\n\\t\\t\\t->filter(\\n\\t\\t\\t\\tstatic fn ( string $method ) => Str::starts_with( $method, [ 'on_', 'action__', 'filter__' ] )\\n\\t\\t\\t)\\n\\t\\t\\t->map(\\n\\t\\t\\t\\tfunction ( string $method ) use ( $has_legacy_attribute ): ?array {\\n\\t\\t\\t\\t\\t$reflection_method = $this->reflection->getMethod( $method );\\n\\n\\t\\t\\t\\t\\tif ( ! $reflection_method->isPublic() ) {\\n\\t\\t\\t\\t\\t\\t$this->fire_doing_it_wrong( $reflection_method );\\n\\n\\t\\t\\t\\t\\t\\treturn null;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\/\/ Check if the method has any Action or Filter attributes. If it does\\n\\t\\t\\t\\t\\t\/\/ and the legacy attribute is not present on the class, ignore the\\n\\t\\t\\t\\t\\t\/\/ method name.\\n\\t\\t\\t\\t\\tif (\\n\\t\\t\\t\\t\\t\\t! $has_legacy_attribute\\n\\t\\t\\t\\t\\t\\t&& collect( $reflection_method->getAttributes( Filter::class, ReflectionAttribute::IS_INSTANCEOF ) )->is_not_empty()\\n\\t\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\t\\treturn null;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t$type = match ( true ) {\\n\\t\\t\\t\\t\\t\\tStr::starts_with( $method, 'filter__' ) => 'filter',\\n\\t\\t\\t\\t\\t\\tdefault => 'action',\\n\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\t$hook = match ( true ) {\\n\\t\\t\\t\\t\\t\\tStr::starts_with( $method, 'on_' ) => Str::after( $method, 'on_' ),\\n\\t\\t\\t\\t\\t\\tdefault => Str::after( $method, $type . '__' ),\\n\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\t$priority = 10;\\n\\n\\t\\t\\t\\t\\tif ( Str::contains( $hook, '_at_' ) ) {\\n\\t\\t\\t\\t\\t\\t\/\/ Strip the priority from the hook name.\\n\\t\\t\\t\\t\\t\\t$priority = (int) Str::after_last( $hook, '_at_' );\\n\\t\\t\\t\\t\\t\\t$hook     = Str::before_last( $hook, '_at_' );\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn [\\n\\t\\t\\t\\t\\t\\t'type'     => $type,\\n\\t\\t\\t\\t\\t\\t'hook'     => $hook,\\n\\t\\t\\t\\t\\t\\t'method'   => $method,\\n\\t\\t\\t\\t\\t\\t'priority' => $priority,\\n\\t\\t\\t\\t\\t];\\n\\t\\t\\t\\t}\\n\\t\\t\\t)\\n\\t\\t\\t->filter()\\n\\t\\t\\t->values();\\n\\t}\\n\\n\\t\/**\\n\\t * Collect all attribute actions on the service provider.\\n\\t *\\n\\t * Allow methods with the `#[Action]` attribute to automatically register\\n\\t * WordPress hooks.\\n\\t *\\n\\t * @phpstan-return Collection<int, HookItem>\\n\\t *\/\\n\\tprivate function collect_attribute_hooks(): Collection {\\n\\t\\t$items = new Collection();\\n\\n\\t\\tforeach ( $this->reflection->getMethods() as $method ) {\\n\\t\\t\\tforeach ( $method->getAttributes( Action::class ) as $attribute ) {\\n\\t\\t\\t\\tif ( ! $method->isPublic() ) {\\n\\t\\t\\t\\t\\t$this->fire_doing_it_wrong( $method );\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t$instance = $attribute->newInstance();\\n\\n\\t\\t\\t\\t$items->push(\\n\\t\\t\\t\\t\\t[\\n\\t\\t\\t\\t\\t\\t'type'     => 'action',\\n\\t\\t\\t\\t\\t\\t'hook'     => $instance->hook_name,\\n\\t\\t\\t\\t\\t\\t'method'   => $method->getName(),\\n\\t\\t\\t\\t\\t\\t'priority' => $instance->priority,\\n\\t\\t\\t\\t\\t]\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\n\\t\\t\\tforeach ( $method->getAttributes( Filter::class ) as $attribute ) {\\n\\t\\t\\t\\tif ( ! $method->isPublic() ) {\\n\\t\\t\\t\\t\\t$this->fire_doing_it_wrong( $method );\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t$instance = $attribute->newInstance();\\n\\n\\t\\t\\t\\t$items->push(\\n\\t\\t\\t\\t\\t[\\n\\t\\t\\t\\t\\t\\t'type'     => 'filter',\\n\\t\\t\\t\\t\\t\\t'hook'     => $instance->hook_name,\\n\\t\\t\\t\\t\\t\\t'method'   => $method->getName(),\\n\\t\\t\\t\\t\\t\\t'priority' => $instance->priority,\\n\\t\\t\\t\\t\\t]\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $items;\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if the service provider should use the event dispatcher or the\\n\\t * core WordPress hooks.\\n\\t *\\n\\t * By default, it is only enabled if the class is an instance of the\\n\\t * `Service_Provider` class. For external uses of this trait, the event\\n\\t * dispatcher won't be used.\\n\\t *\/\\n\\tpublic function use_event_dispatcher(): bool {\\n\\t\\treturn class_exists( Service_Provider::class ) && $this instanceof Service_Provider;\\n\\t}\\n\\n\\t\/**\\n\\t * Fire a _doing_it_wrong() notice when a method that is trying to be\\n\\t * registered as a hook callback is not public.\\n\\t *\\n\\t * For local development, throw an exception to help the developer\\n\\t * identify the issue.\\n\\t *\\n\\t * @throws RuntimeException Thrown only in local development.\\n\\t *\\n\\t * @param ReflectionMethod $method The hook callback method.\\n\\t *\/\\n\\tprotected function fire_doing_it_wrong( ReflectionMethod $method ): void {\\n\\t\\t$message = sprintf(\\n\\t\\t\\t\/* translators: %s: method name. *\/\\n\\t\\t\\t__( 'The method %s must be public to be registered as a hook callback.', 'mantle' ),\\n\\t\\t\\t$method->getName()\\n\\t\\t);\\n\\n\\t\\tif ( 'local' === wp_get_environment_type() ) {\\n\\t\\t\\tthrow new RuntimeException( $message );\\n\\t\\t}\\n\\n\\t\\t_doing_it_wrong( esc_html( static::class . '::' . $method->getName() ), esc_html( $message ), '1.0.0' );\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/traits\/trait-singleton.php\",\"ext\":\"php\",\"size\":518,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Singleton trait file\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support\\\\Traits;\\n\\n\/**\\n * Make a class into a singleton.\\n *\/\\ntrait Singleton {\\n\\t\/**\\n\\t * Existing instances.\\n\\t *\\n\\t * @var array<mixed>\\n\\t *\/\\n\\tprotected static $instances = [];\\n\\n\\t\/**\\n\\t * Get class instance.\\n\\t *\\n\\t * @return static\\n\\t *\/\\n\\tpublic static function instance() {\\n\\t\\t$class = static::class;\\n\\n\\t\\tif ( ! isset( static::$instances[ $class ] ) ) {\\n\\t\\t\\tstatic::$instances[ $class ] = new static();\\n\\t\\t}\\n\\n\\t\\treturn self::$instances[ $class ];\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/traits\/trait-loads-classes.php\",\"ext\":\"php\",\"size\":1628,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Loads_Classes trait file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support\\\\Traits;\\n\\nuse Mantle\\\\Filesystem\\\\Filesystem;\\nuse Symfony\\\\Component\\\\Finder\\\\Finder;\\nuse Symfony\\\\Component\\\\Finder\\\\SplFileInfo;\\nuse function Mantle\\\\Support\\\\Helpers\\\\collect;\\n\\n\/**\\n * Trait for loading classes\\n *\/\\ntrait Loads_Classes {\\n\\t\/**\\n\\t * Retrieves expected classes from a folder in a respective namespace.\\n\\t *\\n\\t * @param string $path Path to load.\\n\\t * @param string $root_namespace Root namespace for the files.\\n\\t * @return string[]\\n\\t *\/\\n\\tpublic static function classes_from_path( string $path, string $root_namespace ): array {\\n\\t\\t$classes = [];\\n\\n\\t\\tforeach ( ( new Finder() )->name( '*.php' )->in( $path ) as $file ) {\\n\\t\\t\\t$class = static::classname_from_path( $file, $root_namespace );\\n\\n\\t\\t\\tif ( $class ) {\\n\\t\\t\\t\\t$classes[] = $class;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $classes;\\n\\t}\\n\\n\\t\/**\\n\\t * Retrieve the class name from a file.\\n\\t *\\n\\t * @param SplFileInfo $file File instance.\\n\\t * @param string      $root_namespace Root namespace.\\n\\t *\/\\n\\tpublic static function classname_from_path( SplFileInfo $file, string $root_namespace ): ?string {\\n\\t\\t\/\/ Append the relative path as a namespace to the root namespace.\\n\\t\\t\\t\\t\\t\\t\\t\\t$relative_path = $file->getRelativePath();\\n\\t\\t\\t\\t\\t\\t\\t\\t\/\/ Append the relative path as a namespace to the root namespace.\\n\\t\\tif ( $relative_path !== '' && $relative_path !== '0' ) {\\n\\t\\t\\t$root_namespace .= '\\\\\\\\' . str_replace( '\/', '\\\\\\\\', $relative_path );\\n\\t\\t}\\n\\n\\t\\t$class_name = $root_namespace . '\\\\\\\\' . ( new Filesystem() )->guess_class_name( $file->getRealPath() );\\n\\n\\t\\tif ( class_exists( $class_name ) ) {\\n\\t\\t\\treturn $class_name;\\n\\t\\t}\\n\\n\\t\\treturn null;\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/traits\/trait-macroable.php\",\"ext\":\"php\",\"size\":2633,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Macroable class file.\\n *\\n * @package Mantle\\n *\/\\n\\n\/\/ phpcs:disable Squiz.Commenting.FunctionComment.MissingParamComment\\n\/\/ phpcs:ignoreFile: WordPressVIPMinimum.Variables.VariableAnalysis.StaticInsideClosure\\n\\nnamespace Mantle\\\\Support\\\\Traits;\\n\\nuse BadMethodCallException;\\nuse Closure;\\nuse ReflectionClass;\\nuse ReflectionMethod;\\n\\ntrait Macroable {\\n\\t\/**\\n\\t * The registered string macros.\\n\\t *\\n\\t * @var array<mixed>\\n\\t *\/\\n\\tprotected static $macros = [];\\n\\n\\t\/**\\n\\t * Register a custom macro.\\n\\t *\\n\\t * @param string          $name\\n\\t * @param object|callable $macro\\n\\t *\/\\n\\tpublic static function macro( $name, $macro ): void {\\n\\t\\tstatic::$macros[ $name ] = $macro;\\n\\t}\\n\\n\\t\/**\\n\\t * Mix another object into the class.\\n\\t *\\n\\t * @param object $mixin\\n\\t * @param bool   $replace\\n\\t *\\n\\t *\\n\\t * @throws \\\\ReflectionException\\n\\t *\/\\n\\tpublic static function mixin( $mixin, $replace = true ): void {\\n\\t\\t$methods = ( new ReflectionClass( $mixin ) )->getMethods(\\n\\t\\t\\tReflectionMethod::IS_PUBLIC | ReflectionMethod::IS_PROTECTED\\n\\t\\t);\\n\\n\\t\\tforeach ( $methods as $method ) {\\n\\t\\t\\tif ( $replace || ! static::has_macro( $method->name ) ) {\\n\\t\\t\\t\\tstatic::macro( $method->name, $method->invoke( $mixin ) );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t\/**\\n\\t * Checks if macro is registered.\\n\\t *\\n\\t * @param string $name\\n\\t *\/\\n\\tpublic static function has_macro( $name ): bool {\\n\\t\\treturn isset( static::$macros[ $name ] );\\n\\t}\\n\\n\\t\/**\\n\\t\\t\\t\\t * Dynamically handle calls to the class.\\n\\t\\t\\t\\t *\\n\\t\\t\\t\\t * @param string $method\\n\\t\\t\\t\\t * @param array<mixed>  $parameters\\n\\t\\t\\t\\t *\\n\\t\\t\\t\\t *\\n\\t\\t\\t\\t * @throws \\\\BadMethodCallException\\n\\t\\t\\t\\t *\/\\n\\t\\t\\t\\tpublic static function __callStatic( string $method, array $parameters ): mixed {\\n\\t\\tif ( ! static::has_macro( $method ) ) {\\n\\t\\t\\tthrow new BadMethodCallException( sprintf(\\n\\t\\t\\t\\t'Method %s::%s does not exist.', static::class, $method\\n\\t\\t\\t) );\\n\\t\\t}\\n\\n\\t\\t$macro = static::$macros[ $method ];\\n\\n\\t\\tif ( $macro instanceof Closure ) {\\n\\t\\t\\treturn call_user_func_array( Closure::bind( $macro, null, static::class ), $parameters );\\n\\t\\t}\\n\\n\\t\\treturn $macro( ...$parameters );\\n\\t}\\n\\n\\t\/**\\n\\t\\t\\t\\t * Dynamically handle calls to the class.\\n\\t\\t\\t\\t *\\n\\t\\t\\t\\t * @param string $method\\n\\t\\t\\t\\t * @param array<mixed>  $parameters\\n\\t\\t\\t\\t *\\n\\t\\t\\t\\t *\\n\\t\\t\\t\\t * @throws \\\\BadMethodCallException\\n\\t\\t\\t\\t *\/\\n\\t\\t\\t\\tpublic function __call( string $method, array $parameters ): mixed {\\n\\t\\tif ( ! static::has_macro( $method ) ) {\\n\\t\\t\\tthrow new BadMethodCallException( sprintf(\\n\\t\\t\\t\\t'Method %s::%s does not exist.', static::class, $method\\n\\t\\t\\t) );\\n\\t\\t}\\n\\n\\t\\t$macro = static::$macros[ $method ];\\n\\n\\t\\tif ( $macro instanceof Closure ) {\\n\\t\\t\\treturn call_user_func_array( $macro->bindTo( $this, static::class ), $parameters );\\n\\t\\t}\\n\\n\\t\\treturn $macro( ...$parameters );\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/traits\/trait-tappable.php\",\"ext\":\"php\",\"size\":438,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Tappable trait.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support\\\\Traits;\\n\\nuse function Mantle\\\\Support\\\\Helpers\\\\tap;\\n\\n\/**\\n * Tappable Trait.\\n *\/\\ntrait Tappable {\\n\\t\/**\\n\\t * Call the given Closure with this instance then return the instance.\\n\\t *\\n\\t * @param  callable|null $callback\\n\\t * @return static|\\\\Mantle\\\\Support\\\\Higher_Order_Tap_Proxy\\n\\t *\/\\n\\tpublic function tap( $callback = null ) {\\n\\t\\treturn tap( $this, $callback );\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/traits\/trait-enumerates-values.php\",\"ext\":\"php\",\"size\":25640,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Enumerates_Values trait file.\\n *\\n * phpcs:disable Generic.CodeAnalysis.UnusedFunctionParameter.FoundAfterLastUsed\\n * phpcs:disable Squiz.Commenting.FunctionComment.MissingParamComment\\n * phpcs:disable Squiz.Commenting.FunctionComment.ParamNameNoMatch\\n * phpcs:disable Squiz.Commenting.FunctionComment.MissingParamTag\\n * phpcs:disable WordPress.PHP.StrictInArray.MissingTrueStrict\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support\\\\Traits;\\n\\nuse Closure;\\nuse Exception;\\nuse Mantle\\\\Contracts\\\\Support\\\\Arrayable;\\nuse Mantle\\\\Contracts\\\\Support\\\\Jsonable;\\nuse Mantle\\\\Support\\\\Arr;\\nuse Mantle\\\\Support\\\\Collection;\\nuse Mantle\\\\Support\\\\Enumerable;\\nuse JsonSerializable;\\nuse Mantle\\\\Support\\\\Higher_Order_Collection_Proxy;\\nuse Symfony\\\\Component\\\\VarDumper\\\\VarDumper;\\nuse Traversable;\\n\\nuse function Mantle\\\\Support\\\\Helpers\\\\data_get;\\n\\n\/**\\n * Enumerate_Values trait.\\n *\\n * @template TKey of array-key\\n * @template TValue\\n *\\n * @property-read Higher_Order_Collection_Proxy $average\\n * @property-read Higher_Order_Collection_Proxy $avg\\n * @property-read Higher_Order_Collection_Proxy $contains\\n * @property-read Higher_Order_Collection_Proxy $each\\n * @property-read Higher_Order_Collection_Proxy $every\\n * @property-read Higher_Order_Collection_Proxy $filter\\n * @property-read Higher_Order_Collection_Proxy $first\\n * @property-read Higher_Order_Collection_Proxy $flat_map\\n * @property-read Higher_Order_Collection_Proxy $group_by\\n * @property-read Higher_Order_Collection_Proxy $key_by\\n * @property-read Higher_Order_Collection_Proxy $map\\n * @property-read Higher_Order_Collection_Proxy $max\\n * @property-read Higher_Order_Collection_Proxy $min\\n * @property-read Higher_Order_Collection_Proxy $partition\\n * @property-read Higher_Order_Collection_Proxy $reject\\n * @property-read Higher_Order_Collection_Proxy $some\\n * @property-read Higher_Order_Collection_Proxy $sort_by\\n * @property-read Higher_Order_Collection_Proxy $sort_by_desc\\n * @property-read Higher_Order_Collection_Proxy $sum\\n * @property-read Higher_Order_Collection_Proxy $unique\\n * @property-read Higher_Order_Collection_Proxy $until\\n *\/\\ntrait Enumerates_Values {\\n\\tuse Conditionable;\\n\\n\\t\/**\\n\\t * The methods that can be proxied.\\n\\t *\\n\\t * @var array<string>\\n\\t *\/\\n\\tprotected static $proxies = [\\n\\t\\t'average',\\n\\t\\t'avg',\\n\\t\\t'contains',\\n\\t\\t'each',\\n\\t\\t'every',\\n\\t\\t'filter',\\n\\t\\t'first',\\n\\t\\t'flat_map',\\n\\t\\t'group_by',\\n\\t\\t'key_by',\\n\\t\\t'map',\\n\\t\\t'max',\\n\\t\\t'min',\\n\\t\\t'partition',\\n\\t\\t'reject',\\n\\t\\t'skip_until',\\n\\t\\t'skip_while',\\n\\t\\t'some',\\n\\t\\t'sort_by',\\n\\t\\t'sort_by_desc',\\n\\t\\t'sum',\\n\\t\\t'take_until',\\n\\t\\t'take_while',\\n\\t\\t'unique',\\n\\t\\t'until',\\n\\t];\\n\\n\\t\/**\\n\\t * Create a new collection instance if the value isn't one already.\\n\\t *\\n\\t * @template TMakeKey of array-key\\n\\t * @template TMakeValue\\n\\t *\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<TMakeKey, TMakeValue>|iterable<TMakeKey, TMakeValue>|null $items\\n\\t * @return static<TMakeKey, TMakeValue>\\n\\t *\/\\n\\tpublic static function make( $items = [] ) {\\n\\t\\treturn new static( $items );\\n\\t}\\n\\n\\t\/**\\n\\t * Wrap the given value in a collection if applicable.\\n\\t *\\n\\t * @template TWrapValue\\n\\t *\\n\\t * @param  iterable<array-key, TWrapValue>|TWrapValue $value\\n\\t * @return static<array-key, TWrapValue>\\n\\t *\/\\n\\tpublic static function wrap( $value ): static {\\n\\t\\treturn $value instanceof Enumerable\\n\\t\\t\\t? new static( $value )\\n\\t\\t\\t: new static( Arr::wrap( $value ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the underlying items from the given collection if applicable.\\n\\t *\\n\\t * @template TUnwrapKey of array-key\\n\\t * @template TUnwrapValue\\n\\t *\\n\\t * @param  array<TUnwrapKey, TUnwrapValue>|static<TUnwrapKey, TUnwrapValue> $value\\n\\t * @return array<TUnwrapKey, TUnwrapValue>\\n\\t *\/\\n\\tpublic static function unwrap( $value ) {\\n\\t\\treturn $value instanceof Enumerable ? $value->all() : $value;\\n\\t}\\n\\n\\t\/**\\n\\t * Alias for the \\\"avg\\\" method.\\n\\t *\\n\\t * @param  callable|string|null $callback\\n\\t * @return mixed\\n\\t *\/\\n\\tpublic function average( $callback = null ) {\\n\\t\\treturn $this->avg( $callback );\\n\\t}\\n\\n\\t\/**\\n\\t * Alias for the \\\"contains\\\" method.\\n\\t *\\n\\t * @param  mixed $key\\n\\t * @param  mixed $operator\\n\\t * @param  mixed $value\\n\\t * @return bool\\n\\t *\/\\n\\tpublic function some( $key, $operator = null, $value = null ) {\\n\\t\\treturn $this->contains( ...func_get_args() );\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if an item exists, using strict comparison.\\n\\t *\\n\\t * @param  mixed $key\\n\\t * @param  mixed $value\\n\\t * @return bool\\n\\t *\/\\n\\tpublic function contains_strict( $key, $value = null ) {\\n\\t\\tif ( func_num_args() === 2 ) {\\n\\t\\t\\treturn $this->contains(\\n\\t\\t\\t\\tfn ( $item ) => data_get( $item, $key ) === $value\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\tif ( $this->use_as_callable( $key ) ) {\\n\\t\\t\\treturn ! is_null( $this->first( $key ) );\\n\\t\\t}\\n\\n\\t\\tforeach ( $this as $item ) {\\n\\t\\t\\tif ( $item === $key ) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\t\/**\\n\\t * Dump the items and end the script.\\n\\t *\\n\\t * @param  mixed ...$args\\n\\t *\/\\n\\tpublic function dd( ...$args ): never {\\n\\t\\t$this->dump( ...$args );\\n\\n\\t\\texit( 1 );\\n\\t}\\n\\n\\t\/**\\n\\t * Dump the items.\\n\\t *\/\\n\\tpublic function dump(): static {\\n\\t\\t( new static( func_get_args() ) )\\n\\t\\t\\t->push( $this->all() )\\n\\t\\t\\t->each(\\n\\t\\t\\t\\tfn ( $item ) => VarDumper::dump( $item ),\\n\\t\\t\\t);\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Execute a callback over each item.\\n\\t *\\n\\t * @param  callable(TValue, TKey): mixed $callback\\n\\t * @return static\\n\\t *\/\\n\\tpublic function each( callable $callback ) {\\n\\t\\tforeach ( $this as $key => $item ) {\\n\\t\\t\\tif ( $callback( $item, $key ) === false ) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Execute a callback over each nested chunk of items.\\n\\t *\\n\\t * @param  callable(array<TKey, TValue>): mixed $callback\\n\\t * @return static\\n\\t *\/\\n\\tpublic function each_spread( callable $callback ) {\\n\\t\\treturn $this->each(\\n\\t\\t\\tfunction ( $chunk, $key ) use ( $callback ) {\\n\\t\\t\\t\\t$chunk[] = $key;\\n\\n\\t\\t\\t\\treturn $callback( ...$chunk );\\n\\t\\t\\t}\\n\\t\\t);\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if all items pass the given truth test.\\n\\t *\\n\\t * @param  (callable(TValue, TKey): bool)|TValue|string $key\\n\\t * @param  mixed                                        $operator\\n\\t * @param  mixed                                        $value\\n\\t * @return bool\\n\\t *\/\\n\\tpublic function every( $key, $operator = null, $value = null ) {\\n\\t\\tif ( func_num_args() === 1 ) {\\n\\t\\t\\t$callback = $this->value_retriever( $key );\\n\\n\\t\\t\\tforeach ( $this as $k => $v ) {\\n\\t\\t\\t\\tif ( ! $callback( $v, $k ) ) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\treturn $this->every( $this->operator_for_where( ...func_get_args() ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the first item by the given key value pair.\\n\\t *\\n\\t * @param  string $key\\n\\t * @param  mixed  $operator\\n\\t * @param  mixed  $value\\n\\t * @return TValue|null\\n\\t *\/\\n\\tpublic function first_where( $key, $operator = null, $value = null ) {\\n\\t\\treturn $this->first( $this->operator_for_where( ...func_get_args() ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if the collection is not empty.\\n\\t *\/\\n\\tpublic function is_not_empty(): bool {\\n\\t\\treturn ! $this->is_empty();\\n\\t}\\n\\n\\t\/**\\n\\t * Run a map over each nested chunk of items.\\n\\t *\\n\\t * @template TMapSpreadValue\\n\\t *\\n\\t * @param  callable(mixed): TMapSpreadValue $callback\\n\\t * @return static<TKey, TMapSpreadValue>\\n\\t *\/\\n\\tpublic function map_spread( callable $callback ) {\\n\\t\\treturn $this->map(\\n\\t\\t\\tfunction ( $chunk, $key ) use ( $callback ) {\\n\\t\\t\\t\\t$chunk[] = $key;\\n\\n\\t\\t\\t\\treturn $callback( ...$chunk );\\n\\t\\t\\t}\\n\\t\\t);\\n\\t}\\n\\n\\t\/**\\n\\t * Run a grouping map over the items.\\n\\t *\\n\\t * The callback should return an associative array with a single key\/value pair.\\n\\t *\\n\\t * @template TMapToGroupsKey of array-key\\n\\t * @template TMapToGroupsValue\\n\\t *\\n\\t * @param  callable(TValue, TKey): array<TMapToGroupsKey, TMapToGroupsValue> $callback\\n\\t * @return static<TMapToGroupsKey, static<int, TMapToGroupsValue>>\\n\\t *\/\\n\\tpublic function map_to_groups( callable $callback ) {\\n\\t\\t$groups = $this->map_to_dictionary( $callback );\\n\\n\\t\\treturn $groups->map( [ $this, 'make' ] ); \/\/ @phpstan-ignore-line return.type\\n\\t}\\n\\n\\t\/**\\n\\t * Map a collection and flatten the result by a single level.\\n\\t *\\n\\t * @template TFlatMapKey of array-key\\n\\t * @template TFlatMapValue\\n\\t *\\n\\t * @param  callable(TValue, TKey): (\\\\Illuminate\\\\Support\\\\Collection<TFlatMapKey, TFlatMapValue>|array<TFlatMapKey, TFlatMapValue>) $callback\\n\\t * @return static<TFlatMapKey, TFlatMapValue>\\n\\t *\/\\n\\tpublic function flat_map( callable $callback ) {\\n\\t\\treturn $this->map( $callback )->collapse();\\n\\t}\\n\\n\\t\/**\\n\\t * Map the values into a new class.\\n\\t *\\n\\t * @template TMapIntoValue\\n\\t *\\n\\t * @param  class-string<TMapIntoValue> $class\\n\\t * @return static<TKey, TMapIntoValue>\\n\\t *\/\\n\\tpublic function map_into( $class ) {\\n\\t\\treturn $this->map(\\n\\t\\t\\tfn ( $value, $key ) => new $class( $value, $key )\\n\\t\\t);\\n\\t}\\n\\n\\t\/**\\n\\t * Get the min value of a given key.\\n\\t *\\n\\t * @param  (callable(TValue):mixed)|string|null $callback\\n\\t * @return mixed\\n\\t *\/\\n\\tpublic function min( $callback = null ) {\\n\\t\\t$callback = $this->value_retriever( $callback );\\n\\n\\t\\treturn $this->map(\\n\\t\\t\\tfn ( $value ) => $callback( $value )\\n\\t\\t)->filter(\\n\\t\\t\\tfn ( $value ) => ! is_null( $value )\\n\\t\\t)->reduce(\\n\\t\\t\\tfn ( $result, $value ) => is_null( $result ) || $value < $result ? $value : $result\\n\\t\\t);\\n\\t}\\n\\n\\t\/**\\n\\t * Get the max value of a given key.\\n\\t *\\n\\t * @param  (callable(TValue):mixed)|string|null $callback\\n\\t * @return mixed\\n\\t *\/\\n\\tpublic function max( $callback = null ) {\\n\\t\\t$callback = $this->value_retriever( $callback );\\n\\n\\t\\treturn $this->filter(\\n\\t\\t\\tfn ( $value ) => ! is_null( $value )\\n\\t\\t)->reduce(\\n\\t\\t\\tfunction ( $result, $item ) use ( $callback ) {\\n\\t\\t\\t\\t$value = $callback( $item );\\n\\n\\t\\t\\t\\treturn is_null( $result ) || $value > $result ? $value : $result;\\n\\t\\t\\t}\\n\\t\\t);\\n\\t}\\n\\n\\t\/**\\n\\t * \\\"Paginate\\\" the collection by slicing it into a smaller collection.\\n\\t *\\n\\t * @param  int $page\\n\\t * @param  int $per_page\\n\\t * @return static\\n\\t *\/\\n\\tpublic function for_page( $page, $per_page ) {\\n\\t\\t$offset = max( 0, ( $page - 1 ) * $per_page );\\n\\n\\t\\treturn $this->slice( $offset, $per_page );\\n\\t}\\n\\n\\t\/**\\n\\t * Partition the collection into two arrays using the given callback or key.\\n\\t *\\n\\t * @param  (callable(TValue, TKey): bool)|TValue|string $key\\n\\t * @param  TValue|string|null                           $operator\\n\\t * @param  TValue|null                                  $value\\n\\t * @return static<int, static<TKey, TValue>>\\n\\t *\/\\n\\tpublic function partition( $key, $operator = null, $value = null ) {\\n\\t\\t$passed = [];\\n\\t\\t$failed = [];\\n\\n\\t\\t$callback = func_num_args() === 1\\n\\t\\t\\t? $this->value_retriever( $key )\\n\\t\\t\\t: $this->operator_for_where( ...func_get_args() );\\n\\n\\t\\tforeach ( $this as $key => $item ) {\\n\\t\\t\\tif ( $callback( $item, $key ) ) {\\n\\t\\t\\t\\t$passed[ $key ] = $item;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t$failed[ $key ] = $item;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn new static( [\\n\\t\\t\\tnew static( $passed ),\\n\\t\\t\\tnew static( $failed ),\\n\\t\\t] );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the sum of the given values.\\n\\t *\\n\\t * @param  (callable(TValue): mixed)|string|null $callback\\n\\t * @return mixed\\n\\t *\/\\n\\tpublic function sum( $callback = null ) {\\n\\t\\t$callback = is_null( $callback ) ? fn ( $value ) => $value : $this->value_retriever( $callback );\\n\\n\\t\\treturn $this->reduce(\\n\\t\\t\\tfn ( $result, $item ) => $result + $callback( $item ),\\n\\t\\t\\t0\\n\\t\\t);\\n\\t}\\n\\n\\t\/**\\n\\t * Apply the callback if the collection is empty.\\n\\t *\\n\\t * @template TWhenEmptyReturnType\\n\\t *\\n\\t * @param  (callable( $this): TWhenEmptyReturnType)  $callback The callback to apply.\\n\\t * @param  (callable( $this): TWhenEmptyReturnType)|null  $default The callback to apply if the collection is not empty.\\n\\t * @return static|TWhenEmptyReturnType\\n\\t *\/\\n\\tpublic function when_empty( callable $callback, ?callable $default = null ) {\\n\\t\\treturn $this->when( $this->is_empty(), $callback, $default );\\n\\t}\\n\\n\\t\/**\\n\\t * Apply the callback if the collection is not empty.\\n\\t *\\n\\t * @template TWhenNotEmptyReturnType\\n\\t *\\n\\t * @param  callable(  $this): TWhenNotEmptyReturnType  $callback The callback to apply.\\n\\t * @param  (callable( $this): TWhenNotEmptyReturnType)|null  $default The callback to apply if the collection is empty.\\n\\t * @return static|TWhenNotEmptyReturnType\\n\\t *\/\\n\\tpublic function when_not_empty( callable $callback, ?callable $default = null ) {\\n\\t\\treturn $this->when( $this->is_not_empty(), $callback, $default );\\n\\t}\\n\\n\\t\/**\\n\\t * Apply the callback unless the collection is empty.\\n\\t *\\n\\t * @template TUnlessEmptyReturnType\\n\\t *\\n\\t * @param  callable(  $this): TUnlessEmptyReturnType  $callback The callback to apply.\\n\\t * @param  (callable( $this): TUnlessEmptyReturnType)|null  $default The callback to apply if the collection is empty.\\n\\t * @return static|TUnlessEmptyReturnType\\n\\t *\/\\n\\tpublic function unless_empty( callable $callback, ?callable $default = null ) {\\n\\t\\treturn $this->when_not_empty( $callback, $default );\\n\\t}\\n\\n\\t\/**\\n\\t * Apply the callback unless the collection is not empty.\\n\\t *\\n\\t * @template TUnlessNotEmptyReturnType\\n\\t *\\n\\t * @param  callable(  $this): TUnlessNotEmptyReturnType  $callback The callback to apply.\\n\\t * @param  (callable( $this): TUnlessNotEmptyReturnType)|null  $default The callback to apply if the collection is not empty.\\n\\t * @return static|TUnlessNotEmptyReturnType\\n\\t *\/\\n\\tpublic function unless_not_empty( callable $callback, ?callable $default = null ) {\\n\\t\\treturn $this->when_empty( $callback, $default );\\n\\t}\\n\\n\\t\/**\\n\\t * Filter items by the given key value pair.\\n\\t *\\n\\t * @param  string|null $key\\n\\t * @param  mixed       $operator\\n\\t * @param  mixed       $value\\n\\t * @return static\\n\\t *\/\\n\\tpublic function where( ?string $key, $operator = null, $value = null ) {\\n\\t\\treturn $this->filter( $this->operator_for_where( ...func_get_args() ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Filter items where the given key is not null.\\n\\t *\\n\\t * @param  string|null $key\\n\\t * @return static\\n\\t *\/\\n\\tpublic function where_null( ?string $key = null ) {\\n\\t\\treturn $this->where_strict( $key, null );\\n\\t}\\n\\n\\t\/**\\n\\t * Filter items where the given key is null.\\n\\t *\\n\\t * @param  string|null $key\\n\\t * @return static\\n\\t *\/\\n\\tpublic function where_not_null( ?string $key = null ) {\\n\\t\\treturn $this->where( $key, '!==', null );\\n\\t}\\n\\n\\t\/**\\n\\t * Filter items by the given key value pair using strict comparison.\\n\\t *\\n\\t * @param  string|null $key\\n\\t * @param  mixed       $value\\n\\t * @return static\\n\\t *\/\\n\\tpublic function where_strict( ?string $key, mixed $value ) {\\n\\t\\treturn $this->where( $key, '===', $value );\\n\\t}\\n\\n\\t\/**\\n\\t * Filter items by the given key value pair.\\n\\t *\\n\\t * @param  string                                                                 $key The key to check.\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<int, string>|iterable<int, string> $values Values to search for.\\n\\t * @param  bool                                                                   $strict Whether to use strict comparison.\\n\\t * @return static\\n\\t *\/\\n\\tpublic function where_in( string $key, Arrayable|iterable $values, bool $strict = false ) {\\n\\t\\t$values = $this->get_arrayable_items( $values );\\n\\n\\t\\treturn $this->filter(\\n\\t\\t\\tfn ( $item ) => in_array( data_get( $item, $key ), $values, $strict ) \/\/ phpcs:ignore WordPress.PHP.StrictInArray.MissingTrueStrict\\n\\t\\t);\\n\\t}\\n\\n\\t\/**\\n\\t * Filter items by the given key value pair using strict comparison.\\n\\t *\\n\\t * @param  string                                                                 $key The key to check.\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<int, string>|iterable<int, string> $values Values to search for.\\n\\t * @return static\\n\\t *\/\\n\\tpublic function where_in_strict( string $key, Arrayable|iterable $values ) {\\n\\t\\treturn $this->where_in( $key, $values, true );\\n\\t}\\n\\n\\t\/**\\n\\t * Filter items such that the value of the given key is between the given values.\\n\\t *\\n\\t * @param  string                                                                 $key The key to check.\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<int, string>|iterable<int, string> $values Values to search for.\\n\\t * @return static\\n\\t *\/\\n\\tpublic function where_between( string $key, Arrayable|iterable $values ) {\\n\\t\\treturn $this->where( $key, '>=', reset( $values ) )->where( $key, '<=', end( $values ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Filter items such that the value of the given key is not between the given values.\\n\\t *\\n\\t * @param  string                                                                 $key The key to check.\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<int, string>|iterable<int, string> $values Values to search against.\\n\\t * @return static\\n\\t *\/\\n\\tpublic function where_not_between( string $key, Arrayable|iterable $values ) {\\n\\t\\treturn $this->filter(\\n\\t\\t\\tfn ( $item ) => data_get( $item, $key ) < reset( $values ) || data_get( $item, $key ) > end( $values )\\n\\t\\t);\\n\\t}\\n\\n\\t\/**\\n\\t * Filter items by the given key value pair.\\n\\t *\\n\\t * @param  string                                                                 $key The key to check.\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<int, string>|iterable<int, string> $values Values to search against.\\n\\t * @param  bool                                                                   $strict Whether to use strict comparison.\\n\\t * @return static\\n\\t *\/\\n\\tpublic function where_not_in( string $key, Arrayable|iterable $values, bool $strict = false ) {\\n\\t\\t$values = $this->get_arrayable_items( $values );\\n\\n\\t\\treturn $this->reject(\\n\\t\\t\\tfn ( $item ) => in_array( data_get( $item, $key ), $values, $strict ) \/\/ phpcs:ignore WordPress.PHP.StrictInArray.MissingTrueStrict\\n\\t\\t);\\n\\t}\\n\\n\\t\/**\\n\\t * Filter items by the given key value pair using strict comparison.\\n\\t *\\n\\t * @param  string                                                                 $key The key to check.\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<int, string>|iterable<int, string> $values Values to search against.\\n\\t * @return static\\n\\t *\/\\n\\tpublic function where_not_in_strict( string $key, Arrayable|iterable $values ) {\\n\\t\\treturn $this->where_not_in( $key, $values, true );\\n\\t}\\n\\n\\t\/**\\n\\t * Filter the items, removing any items that don't match the given type.\\n\\t *\\n\\t * @template TWhereInstanceOf\\n\\t *\\n\\t * @param  class-string<TWhereInstanceOf>|array<class-string<TWhereInstanceOf>> $type\\n\\t * @return static<TKey, TWhereInstanceOf>\\n\\t *\/\\n\\tpublic function where_instance_of( string|array $type ) {\\n\\t\\t\/\/ @phpstan-ignore return.type\\n\\t\\treturn $this->filter(\\n\\t\\t\\tfn ( $value ) => $value instanceof $type,\\n\\t\\t);\\n\\t}\\n\\n\\t\/**\\n\\t * Pass the collection to the given callback and return the result.\\n\\t *\\n\\t * @template TPipeReturnType\\n\\t *\\n\\t * @param  callable( $this): TPipeReturnType  $callback The callback to pass the collection to.\\n\\t * @return TPipeReturnType\\n\\t *\/\\n\\tpublic function pipe( callable $callback ) {\\n\\t\\treturn $callback( $this );\\n\\t}\\n\\n\\t\/**\\n\\t * Pass the collection to the given callback and then return it.\\n\\t *\\n\\t * @param  callable( $this): mixed  $callback The callback to pass the collection to.\\n\\t * @return static\\n\\t *\/\\n\\tpublic function tap( callable $callback ) {\\n\\t\\t$callback( clone $this );\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Create a collection of all elements that do not pass a given truth test.\\n\\t *\\n\\t * @param  callable|mixed $callback\\n\\t * @return static\\n\\t *\/\\n\\tpublic function reject( $callback = true ) {\\n\\t\\t$use_as_callable = $this->use_as_callable( $callback );\\n\\n\\t\\treturn $this->filter(\\n\\t\\t\\tfn ( $value, $key ) => $use_as_callable\\n\\t\\t\\t\\t? ! $callback( $value, $key )\\n\\t\\t\\t\\t: $value != $callback \/\/ phpcs:ignore Universal.Operators.StrictComparisons.LooseNotEqual, WordPress.PHP.StrictComparisons.LooseComparison\\n\\t\\t);\\n\\t}\\n\\n\\t\/**\\n\\t * Return only unique items from the collection array.\\n\\t *\\n\\t * @param  (callable(TValue, TKey): mixed)|string|null $key\\n\\t * @param  bool                                        $strict\\n\\t * @return static\\n\\t *\/\\n\\tpublic function unique( $key = null, $strict = false ) {\\n\\t\\t$callback = $this->value_retriever( $key );\\n\\n\\t\\t$exists = [];\\n\\n\\t\\treturn $this->reject(\\n\\t\\t\\tfunction ( $item, $key ) use ( $callback, $strict, &$exists ) {\\n\\t\\t\\t\\t$id = $callback( $item, $key );\\n\\t\\t\\t\\tif ( in_array( $id, $exists, $strict ) ) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t$exists[] = $id;\\n\\t\\t\\t}\\n\\t\\t);\\n\\t}\\n\\n\\t\/**\\n\\t * Return only unique items from the collection array using strict comparison.\\n\\t *\\n\\t * @param  (callable(TValue, TKey): mixed)|string|null $key\\n\\t * @return static\\n\\t *\/\\n\\tpublic function unique_strict( $key = null ) {\\n\\t\\treturn $this->unique( $key, true );\\n\\t}\\n\\n\\t\/**\\n\\t * Collect the values into a collection.\\n\\t *\\n\\t * @return \\\\Mantle\\\\Support\\\\Collection<TKey, TValue>\\n\\t *\/\\n\\tpublic function collect() {\\n\\t\\treturn new Collection( $this->all() );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the collection of items as a plain array.\\n\\t *\\n\\t * @return array<TKey, TValue>\\n\\t *\/\\n\\tpublic function to_array() {\\n\\t\\treturn $this->map(\\n\\t\\t\\tfn ( $value ) => $value instanceof Arrayable ? $value->to_array() : $value,\\n\\t\\t)->all();\\n\\t}\\n\\n\\t\/**\\n\\t * Alias for the \\\"to_array\\\" method.\\n\\t *\\n\\t * @return array<TKey, TValue>\\n\\t *\/\\n\\tpublic function toArray() { \/\/ phpcs:ignore WordPress.NamingConventions.ValidFunctionName.MethodNameInvalid\\n\\t\\treturn $this->to_array();\\n\\t}\\n\\n\\t\/**\\n\\t * Convert the object into something JSON serializable.\\n\\t *\\n\\t * @return array<TKey, TValue>\\n\\t *\/\\n\\tpublic function json_serialize(): mixed { \/\/ phpcs:ignore WordPress.NamingConventions.ValidFunctionName.MethodNameInvalid\\n\\t\\treturn array_map(\\n\\t\\t\\tfn ( $value ): mixed => match ( true ) {\\n\\t\\t\\t\\t$value instanceof JsonSerializable => $value->jsonSerialize(),\\n\\t\\t\\t\\t$value instanceof Jsonable => json_decode( $value->to_json(), true ),\\n\\t\\t\\t\\t$value instanceof Arrayable => $value->to_array(),\\n\\t\\t\\t\\tdefault => $value,\\n\\t\\t\\t},\\n\\t\\t\\t$this->all()\\n\\t\\t);\\n\\t}\\n\\n\\t\/**\\n\\t * Alias to json_serialize().\\n\\t *\\n\\t * @return array<TKey, TValue>\\n\\t *\/\\n\\tpublic function jsonSerialize(): mixed { \/\/ phpcs:ignore WordPress.NamingConventions.ValidFunctionName.MethodNameInvalid\\n\\t\\treturn $this->json_serialize();\\n\\t}\\n\\n\\t\/**\\n\\t * Get the collection of items as JSON.\\n\\t *\\n\\t * @param  int $options\\n\\t * @return string\\n\\t *\/\\n\\tpublic function to_json( $options = 0 ) {\\n\\t\\treturn json_encode( $this->jsonSerialize(), $options ); \/\/ phpcs:ignore WordPress.WP.AlternativeFunctions.json_encode_json_encode\\n\\t}\\n\\n\\t\/**\\n\\t * Count the number of items in the collection using a given truth test.\\n\\t *\\n\\t * @param  callable|null $callback\\n\\t * @return static\\n\\t *\/\\n\\tpublic function count_by( $callback = null ) {\\n\\t\\tif ( is_null( $callback ) ) {\\n\\t\\t\\t$callback = fn ( $value ) => $value;\\n\\t\\t}\\n\\n\\t\\treturn new static(\\n\\t\\t\\t$this->group_by( $callback )->map(\\n\\t\\t\\t\\tfn ( $value ) => $value->count()\\n\\t\\t\\t)\\n\\t\\t);\\n\\t}\\n\\n\\t\/**\\n\\t * Convert the collection to its string representation.\\n\\t *\\n\\t * @return string\\n\\t *\/\\n\\tpublic function __toString() {\\n\\t\\treturn $this->to_json();\\n\\t}\\n\\n\\t\/**\\n\\t * Add a method to the list of proxied methods.\\n\\t *\\n\\t * @param  string $method\\n\\t *\/\\n\\tpublic static function proxy( $method ): void {\\n\\t\\tstatic::$proxies[] = $method; \/\/ phpcs:ignore WordPressVIPMinimum.Variables.VariableAnalysis.StaticOutsideClass\\n\\t}\\n\\n\\t\/**\\n\\t * Dynamically access collection proxies.\\n\\t *\\n\\t * @param  string $key\\n\\t * @return mixed\\n\\t *\\n\\t * @throws \\\\Exception Throw on nonexistent property keys.\\n\\t *\/\\n\\tpublic function __get( $key ) {\\n\\t\\tif ( ! in_array( $key, static::$proxies ) ) { \/\/ phpcs:ignore WordPressVIPMinimum.Variables.VariableAnalysis.StaticOutsideClass\\n\\t\\t\\tthrow new Exception( \\\"Property [{$key}] does not exist on this collection instance.\\\" );\\n\\t\\t}\\n\\n\\t\\treturn new Higher_Order_Collection_Proxy( $this, $key );\\n\\t}\\n\\n\\t\/**\\n\\t * Results array of items from Collection or Arrayable.\\n\\t *\\n\\t * @param  mixed $items\\n\\t * @return array<TKey, TValue>\\n\\t *\/\\n\\tprotected function get_arrayable_items( $items ) {\\n\\t\\treturn match ( true ) {\\n\\t\\t\\tis_array( $items ) => $items,\\n\\t\\t\\t$items instanceof Enumerable => $items->all(),\\n\\t\\t\\t$items instanceof Arrayable => $items->to_array(),\\n\\t\\t\\t$items instanceof Jsonable => json_decode( $items->to_json(), true ),\\n\\t\\t\\t$items instanceof JsonSerializable => (array) $items->jsonSerialize(),\\n\\t\\t\\t$items instanceof Traversable => iterator_to_array( $items ),\\n\\t\\t\\tdefault => (array) $items,\\n\\t\\t};\\n\\t}\\n\\n\\t\/**\\n\\t * Get an operator checker callback.\\n\\t *\\n\\t * @param  string|null $key\\n\\t * @param  string|null $operator\\n\\t * @param  mixed       $value\\n\\t * @return \\\\Closure\\n\\t *\/\\n\\tprotected function operator_for_where( ?string $key, ?string $operator = null, mixed $value = null ) {\\n\\t\\tif ( func_num_args() === 1 ) {\\n\\t\\t\\t$value = true;\\n\\n\\t\\t\\t$operator = '=';\\n\\t\\t}\\n\\n\\t\\tif ( func_num_args() === 2 ) {\\n\\t\\t\\t$value = $operator;\\n\\n\\t\\t\\t$operator = '=';\\n\\t\\t}\\n\\n\\t\\treturn function ( $item ) use ( $key, $operator, $value ) {\\n\\t\\t\\t$retrieved = data_get( $item, $key );\\n\\n\\t\\t\\t$strings = array_filter(\\n\\t\\t\\t\\t[ $retrieved, $value ],\\n\\t\\t\\t\\tfn ( $value ) => is_string( $value ) || ( is_object( $value ) && method_exists( $value, '__toString' ) )\\n\\t\\t\\t);\\n\\n\\t\\t\\tif ( count( $strings ) < 2 && count( array_filter( [ $retrieved, $value ], 'is_object' ) ) === 1 ) {\\n\\t\\t\\t\\treturn in_array( $operator, [ '!=', '<>', '!==' ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\tswitch ( $operator ) {\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\tcase '=':\\n\\t\\t\\t\\tcase '==':\\n\\t\\t\\t\\t\\treturn $retrieved == $value; \/\/ phpcs:ignore Universal.Operators.StrictComparisons.LooseEqual\\n\\t\\t\\t\\tcase '!=':\\n\\t\\t\\t\\tcase '<>':\\n\\t\\t\\t\\t\\treturn $retrieved !== $value;\\n\\t\\t\\t\\tcase '<':\\n\\t\\t\\t\\t\\treturn $retrieved < $value;\\n\\t\\t\\t\\tcase '>':\\n\\t\\t\\t\\t\\treturn $retrieved > $value;\\n\\t\\t\\t\\tcase '<=':\\n\\t\\t\\t\\t\\treturn $retrieved <= $value;\\n\\t\\t\\t\\tcase '>=':\\n\\t\\t\\t\\t\\treturn $retrieved >= $value;\\n\\t\\t\\t\\tcase '===':\\n\\t\\t\\t\\t\\treturn $retrieved === $value;\\n\\t\\t\\t\\tcase '!==':\\n\\t\\t\\t\\t\\treturn $retrieved !== $value;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if the given value is callable, but not a string.\\n\\t *\\n\\t * @param  mixed $value\\n\\t *\/\\n\\tprotected function use_as_callable( mixed $value ): bool {\\n\\t\\treturn ! is_string( $value ) && is_callable( $value );\\n\\t}\\n\\n\\t\/**\\n\\t * Get a value retrieving callback.\\n\\t *\\n\\t * @param  callable|string|null $value\\n\\t *\/\\n\\tprotected function value_retriever( callable|string|null $value ): callable {\\n\\t\\tif ( $this->use_as_callable( $value ) ) {\\n\\t\\t\\treturn $value;\\n\\t\\t}\\n\\n\\t\\treturn fn ( $item ) => data_get( $item, $value );\\n\\t}\\n\\n\\t\/**\\n\\t * Make a function to check an item's equality.\\n\\t *\\n\\t * @param  mixed $value\\n\\t *\/\\n\\tprotected function equality( mixed $value ): Closure {\\n\\t\\treturn fn ( $item ) => $item === $value;\\n\\t}\\n\\n\\t\/**\\n\\t * Make a function using another function, by negating its result.\\n\\t *\\n\\t * @param  \\\\Closure $callback\\n\\t *\/\\n\\tprotected function negate( Closure $callback ): Closure {\\n\\t\\treturn fn ( ...$params ) => ! $callback( ...$params );\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/interface-enumerable.php\",\"ext\":\"php\",\"size\":25855,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Enumerable interface file.\\n *\\n * @package Mantle\\n *\/\\n\\n\/\/ phpcs:disable Squiz.Commenting.FunctionComment\\n\\n\/\/ phpcs:disable Squiz.Commenting.ClassComment.Missing\\n\\nnamespace Mantle\\\\Support;\\n\\nuse Countable;\\nuse Mantle\\\\Contracts\\\\Support\\\\Arrayable;\\nuse Mantle\\\\Contracts\\\\Support\\\\Jsonable;\\nuse IteratorAggregate;\\nuse JsonSerializable;\\n\\n\/**\\n * Enumerable interface.\\n *\\n * @template TKey of array-key = array-key\\n * @template TValue = mixed\\n *\\n * @extends \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<TKey, TValue>\\n * @extends \\\\IteratorAggregate<TKey, TValue>\\n *\/\\ninterface Enumerable extends Arrayable, Countable, IteratorAggregate, Jsonable, JsonSerializable {\\n\\t\/**\\n\\t * Create a new collection instance if the value isn't one already.\\n\\t *\\n\\t * @template TMakeKey of array-key\\n\\t * @template TMakeValue\\n\\t *\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<TMakeKey, TMakeValue>|iterable<TMakeKey, TMakeValue>|null  $items\\n\\t * @return static<TMakeKey, TMakeValue>\\n\\t *\/\\n\\tpublic static function make( $items = [] );\\n\\n\\t\/**\\n\\t * Create a new instance by invoking the callback a given amount of times.\\n\\t *\\n\\t * @param  int           $number\\n\\t * @param  callable|null $callback\\n\\t * @return static\\n\\t *\/\\n\\tpublic static function times( $number, ?callable $callback = null );\\n\\n\\t\/**\\n\\t * Wrap the given value in a collection if applicable.\\n\\t *\\n\\t * @template TWrapValue\\n\\t *\\n\\t * @param  iterable<array-key, TWrapValue>|TWrapValue  $value\\n\\t * @return static<array-key, TWrapValue>\\n\\t *\/\\n\\tpublic static function wrap( $value );\\n\\n\\t\/**\\n\\t * Get the underlying items from the given collection if applicable.\\n\\t *\\n\\t * @template TUnwrapKey of array-key\\n\\t * @template TUnwrapValue\\n\\t *\\n\\t * @param  array<TUnwrapKey, TUnwrapValue>|static<TUnwrapKey, TUnwrapValue>  $value\\n\\t * @return array<TUnwrapKey, TUnwrapValue>\\n\\t *\/\\n\\tpublic static function unwrap( $value );\\n\\n\\t\/**\\n\\t * Get all items in the enumerable.\\n\\t *\\n\\t * @return array<mixed>\\n\\t *\/\\n\\tpublic function all();\\n\\n\\t\/**\\n\\t * Alias for the \\\"avg\\\" method.\\n\\t *\\n\\t * @param  (callable(TValue): float|int)|string|null  $callback\\n\\t * @return float|int|null\\n\\t *\/\\n\\tpublic function average( $callback = null );\\n\\n\\t\/**\\n\\t * Get the median of a given key.\\n\\t *\\n\\t * @param  string|array<array-key, string>|null  $key\\n\\t * @return float|int|null\\n\\t *\/\\n\\tpublic function median( $key = null );\\n\\n\\t\/**\\n\\t * Get the mode of a given key.\\n\\t *\\n\\t * @param  string|array<array-key, string>|null  $key\\n\\t * @return array<int, float|int>|null\\n\\t *\/\\n\\tpublic function mode( $key = null );\\n\\n\\t\/**\\n\\t * Collapse the items into a single enumerable.\\n\\t *\\n\\t * @return static<int, mixed>\\n\\t *\/\\n\\tpublic function collapse();\\n\\n\\t\/**\\n\\t * Alias for the \\\"contains\\\" method.\\n\\t *\\n\\t * @param  (callable(TValue, TKey): bool)|TValue|string  $key\\n\\t * @param  mixed $operator\\n\\t * @param  mixed $value\\n\\t * @return bool\\n\\t *\/\\n\\tpublic function some( $key, $operator = null, $value = null );\\n\\n\\t\/**\\n\\t * Determine if an item exists, using strict comparison.\\n\\t *\\n\\t * @param  (callable(TValue, TKey): bool)|TValue|string  $key\\n\\t * @param  mixed $value\\n\\t * @return bool\\n\\t *\/\\n\\tpublic function contains_strict( $key, $value = null );\\n\\n\\t\/**\\n\\t * Get the average value of a given key.\\n\\t *\\n\\t * @param  callable|string|null $callback\\n\\t * @return mixed\\n\\t *\/\\n\\tpublic function avg( $callback = null );\\n\\n\\t\/**\\n\\t * Determine if an item exists in the enumerable.\\n\\t *\\n\\t * @param  (callable(TValue, TKey): bool)|TValue|string  $key\\n\\t * @param  mixed $operator\\n\\t * @param  mixed $value\\n\\t * @return bool\\n\\t *\/\\n\\tpublic function contains( $key, $operator = null, $value = null );\\n\\n\\t\/**\\n\\t * Dump the collection and end the script.\\n\\t *\\n\\t * @param  mixed ...$args\\n\\t *\/\\n\\tpublic function dd( ...$args ): never;\\n\\n\\t\/**\\n\\t * Dump the collection.\\n\\t *\\n\\t * @return static\\n\\t *\/\\n\\tpublic function dump();\\n\\n\\t\/**\\n\\t * Get the items that are not present in the given items.\\n\\t *\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<array-key, TValue>|iterable<array-key, TValue>  $items\\n\\t * @return static\\n\\t *\/\\n\\tpublic function diff( $items );\\n\\n\\t\/**\\n\\t * Get the items that are not present in the given items, using the callback.\\n\\t *\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<array-key, TValue>|iterable<array-key, TValue>  $items\\n\\t * @param  callable(TValue, TValue): int  $callback\\n\\t * @return static\\n\\t *\/\\n\\tpublic function diff_using( $items, callable $callback );\\n\\n\\t\/**\\n\\t * Get the items whose keys and values are not present in the given items.\\n\\t *\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<TKey, TValue>|iterable<TKey, TValue>  $items\\n\\t * @return static\\n\\t *\/\\n\\tpublic function diff_assoc( $items );\\n\\n\\t\/**\\n\\t * Get the items whose keys and values are not present in the given items, using the callback.\\n\\t *\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<TKey, TValue>|iterable<TKey, TValue>  $items\\n\\t * @param  callable(TValue, TValue): int  $callback\\n\\t * @return static\\n\\t *\/\\n\\tpublic function diff_assoc_using( $items, callable $callback );\\n\\n\\t\/**\\n\\t * Get the items whose keys are not present in the given items.\\n\\t *\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<TKey, TValue>|iterable<TKey, TValue>  $items\\n\\t * @return static\\n\\t *\/\\n\\tpublic function diff_keys( $items );\\n\\n\\t\/**\\n\\t * Get the items whose keys are not present in the given items, using the callback.\\n\\t *\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<TKey, TValue>|iterable<TKey, TValue>  $items\\n\\t * @param  callable $callback\\n\\t * @return static\\n\\t *\/\\n\\tpublic function diff_keys_using( $items, callable $callback );\\n\\n\\t\/**\\n\\t * Retrieve duplicate items.\\n\\t *\\n\\t * @param  (callable(TValue): bool)|string|null  $callback\\n\\t * @param  bool          $strict\\n\\t * @return static\\n\\t *\/\\n\\tpublic function duplicates( $callback = null, $strict = false );\\n\\n\\t\/**\\n\\t * Retrieve duplicate items using strict comparison.\\n\\t *\\n\\t * @param  (callable(TValue): bool)|string|null  $callback\\n\\t * @return static\\n\\t *\/\\n\\tpublic function duplicates_strict( $callback = null );\\n\\n\\t\/**\\n\\t * Execute a callback over each item.\\n\\t *\\n\\t * @param  callable(TValue, TKey): mixed  $callback\\n\\t * @return static\\n\\t *\/\\n\\tpublic function each( callable $callback );\\n\\n\\t\/**\\n\\t * Execute a callback over each nested chunk of items.\\n\\t *\\n\\t * @param  callable $callback\\n\\t * @return static\\n\\t *\/\\n\\tpublic function each_spread( callable $callback );\\n\\n\\t\/**\\n\\t * Determine if all items pass the given truth test.\\n\\t *\\n\\t * @param  (callable(TValue, TKey): bool)|TValue|string  $key\\n\\t * @param  mixed           $operator\\n\\t * @param  mixed           $value\\n\\t * @return bool\\n\\t *\/\\n\\tpublic function every( $key, $operator = null, $value = null );\\n\\n\\t\/**\\n\\t * Get all items except for those with the specified keys.\\n\\t *\\n\\t * @param  \\\\Mantle\\\\Support\\\\Enumerable<array-key, TKey>|array<array-key, TKey>  $keys\\n\\t * @return static\\n\\t *\/\\n\\tpublic function except( $keys );\\n\\n\\t\/**\\n\\t * Run a filter over each of the items.\\n\\t *\\n\\t * @param  (callable(TValue): bool)|null  $callback\\n\\t * @return static\\n\\t *\/\\n\\tpublic function filter( ?callable $callback = null );\\n\\n\\t\/**\\n\\t * Apply the callback if the value is truthy.\\n\\t *\\n\\t * @template TWhenParameter\\n\\t * @template TWhenReturnType\\n\\t *\\n\\t * @param  (\\\\Closure($this): TWhenParameter)|TWhenParameter  $value\\n\\t * @param  (callable($this, TWhenParameter): TWhenReturnType)|null  $callback\\n\\t * @param  (callable($this, TWhenParameter): TWhenReturnType)|null  $default\\n\\t * @return static|TWhenReturnType\\n\\t *\/\\n\\tpublic function when( $value, ?callable $callback = null, ?callable $default = null );\\n\\n\\t\/**\\n\\t * Apply the callback if the collection is empty.\\n\\t *\\n\\t * @template TWhenEmptyReturnType\\n\\t *\\n\\t * @param  (callable($this): TWhenEmptyReturnType)  $callback\\n\\t * @param  (callable($this): TWhenEmptyReturnType)|null  $default\\n\\t * @return static|TWhenEmptyReturnType\\n\\t *\/\\n\\tpublic function when_empty( callable $callback, ?callable $default = null );\\n\\n\\t\/**\\n\\t * Apply the callback if the collection is not empty.\\n\\t *\\n\\t * @template TWhenEmptyReturnType\\n\\t *\\n\\t * @param  (callable($this): TWhenEmptyReturnType)  $callback\\n\\t * @param  (callable($this): TWhenEmptyReturnType)|null  $default\\n\\t * @return static|TWhenEmptyReturnType\\n\\t *\/\\n\\tpublic function when_not_empty( callable $callback, ?callable $default = null );\\n\\n\\t\/**\\n\\t * Apply the callback if the value is falsy.\\n\\t *\\n\\t * @template TUnlessParameter\\n\\t * @template TUnlessReturnType\\n\\t *\\n\\t * @param  (\\\\Closure( $this): TUnlessParameter)|TUnlessParameter  $value\\n\\t * @param  (callable( $this, TUnlessParameter): TUnlessReturnType)|null  $callback\\n\\t * @param  (callable( $this, TUnlessParameter): TUnlessReturnType)|null  $default\\n\\t * @return static|TUnlessReturnType\\n\\t *\/\\n\\tpublic function unless( $value, ?callable $callback = null, ?callable $default = null );\\n\\n\\t\/**\\n\\t * Apply the callback unless the collection is empty.\\n\\t *\\n\\t * @template TUnlessEmptyReturnType\\n\\t *\\n\\t * @param  callable($this): TUnlessEmptyReturnType  $callback\\n\\t * @param  (callable($this): TUnlessEmptyReturnType)|null  $default\\n\\t * @return static|TUnlessEmptyReturnType\\n\\t *\/\\n\\tpublic function unless_empty( callable $callback, ?callable $default = null );\\n\\n\\t\/**\\n\\t * Apply the callback unless the collection is not empty.\\n\\t *\\n\\t * @template TUnlessNotEmptyReturnType\\n\\t *\\n\\t * @param  callable($this): TUnlessNotEmptyReturnType  $callback\\n\\t * @param  (callable($this): TUnlessNotEmptyReturnType)|null  $default\\n\\t * @return static|TUnlessNotEmptyReturnType\\n\\t *\/\\n\\tpublic function unless_not_empty( callable $callback, ?callable $default = null );\\n\\n\\t\/**\\n\\t * Filter items by the given key value pair.\\n\\t *\\n\\t * @param  string $key\\n\\t * @param  mixed  $operator\\n\\t * @param  mixed  $value\\n\\t * @return static\\n\\t *\/\\n\\tpublic function where( string $key, $operator = null, $value = null );\\n\\n\\t\/**\\n\\t * Filter items by the given key value pair using strict comparison.\\n\\t *\\n\\t * @param  string $key\\n\\t * @param  mixed  $value\\n\\t * @return static\\n\\t *\/\\n\\tpublic function where_strict( string $key, mixed $value );\\n\\n\\t\/**\\n\\t * Filter items by the given key value pair.\\n\\t *\\n\\t * @param  string $key\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<int, string>|iterable<int, string>  $values\\n\\t * @param  bool   $strict\\n\\t * @return static\\n\\t *\/\\n\\tpublic function where_in( string $key, Arrayable|iterable $values, bool $strict = false );\\n\\n\\t\/**\\n\\t * Filter items by the given key value pair using strict comparison.\\n\\t *\\n\\t * @param  string $key\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<int, string>|iterable<int, string>  $values\\n\\t * @return static\\n\\t *\/\\n\\tpublic function where_in_strict( string $key, Arrayable|iterable $values );\\n\\n\\t\/**\\n\\t * Filter items such that the value of the given key is between the given values.\\n\\t *\\n\\t * @param  string $key\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<int, string>|iterable<int, string>  $values\\n\\t * @return static\\n\\t *\/\\n\\tpublic function where_between( string $key, Arrayable|iterable $values );\\n\\n\\t\/**\\n\\t * Filter items such that the value of the given key is not between the given values.\\n\\t *\\n\\t * @param  string $key\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<int, string>|iterable<int, string>  $values\\n\\t * @return static\\n\\t *\/\\n\\tpublic function where_not_between( string $key, Arrayable|iterable $values );\\n\\n\\t\/**\\n\\t * Filter items by the given key value pair.\\n\\t *\\n\\t * @param  string $key\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<int, string>|iterable<int, string>  $values\\n\\t * @param  bool   $strict\\n\\t * @return static\\n\\t *\/\\n\\tpublic function where_not_in( string $key, Arrayable|iterable $values, bool $strict = false );\\n\\n\\t\/**\\n\\t * Filter items by the given key value pair using strict comparison.\\n\\t *\\n\\t * @param  string $key\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<int, string>|iterable<int, string>  $values\\n\\t * @return static\\n\\t *\/\\n\\tpublic function where_not_in_strict( string $key, Arrayable|iterable $values );\\n\\n\\t\/**\\n\\t * Filter the items, removing any items that don't match the given type.\\n\\t *\\n\\t * @template TWhereInstanceOf\\n\\t *\\n\\t * @param  class-string<TWhereInstanceOf>|array<class-string<TWhereInstanceOf>>  $type\\n\\t * @return static<TKey, TWhereInstanceOf>\\n\\t *\/\\n\\tpublic function where_instance_of( array|string $type );\\n\\n\\t\/**\\n\\t * Get the first item from the enumerable passing the given truth test.\\n\\t *\\n\\t * @template TFirstDefault\\n\\t *\\n\\t * @param  (callable(TValue,TKey): bool)|null  $callback\\n\\t * @param  TFirstDefault|(\\\\Closure(): TFirstDefault)  $default\\n\\t * @return TValue|TFirstDefault\\n\\t *\/\\n\\tpublic function first( ?callable $callback = null, $default = null );\\n\\n\\t\/**\\n\\t * Get the first item by the given key value pair.\\n\\t *\\n\\t * @param  string $key\\n\\t * @param  mixed  $operator\\n\\t * @param  mixed  $value\\n\\t * @return TValue|null\\n\\t *\/\\n\\tpublic function first_where( $key, $operator = null, $value = null );\\n\\n\\t\/**\\n\\t * Flip the values with their keys.\\n\\t *\\n\\t * @return static<int|string, TKey>\\n\\t *\/\\n\\tpublic function flip();\\n\\n\\t\/**\\n\\t * Get an item from the collection by key.\\n\\t *\\n\\t * @template TGetDefault\\n\\t *\\n\\t * @param  TKey  $key\\n\\t * @param  TGetDefault|(\\\\Closure(): TGetDefault)  $default\\n\\t * @return TValue|TGetDefault\\n\\t *\/\\n\\tpublic function get( $key, $default = null );\\n\\n\\t\/**\\n\\t * Group an associative array by a field or using a callback.\\n\\t *\\n\\t * @param  (callable(TValue, TKey): array-key)|array<mixed>|string $group_by The field or callback to group by.\\n\\t * @param  bool                                             $preserve_keys Whether to preserve the keys of the original array.\\n\\t * @return static<array-key, static<array-key, TValue>>\\n\\t *\/\\n\\tpublic function group_by( $group_by, $preserve_keys = false );\\n\\n\\t\/**\\n\\t * Key an associative array by a field or using a callback.\\n\\t *\\n\\t * @param  (callable(TValue, TKey): array-key)|string[]|string  $key_by\\n\\t * @return static<array-key, TValue>\\n\\t *\/\\n\\tpublic function key_by( $key_by );\\n\\n\\t\/**\\n\\t * Determine if an item exists in the collection by key.\\n\\t *\\n\\t * @param  TKey|array<array-key, TKey>  $key\\n\\t * @return bool\\n\\t *\/\\n\\tpublic function has( $key );\\n\\n\\t\/**\\n\\t * Concatenate values of a given key as a string.\\n\\t *\\n\\t * @param  string      $value\\n\\t * @param  string|null $glue\\n\\t * @return string\\n\\t *\/\\n\\tpublic function implode( $value, $glue = null );\\n\\n\\t\/**\\n\\t * Intersect the collection with the given items.\\n\\t *\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable|iterable  $items\\n\\t * @return static\\n\\t *\/\\n\\tpublic function intersect( $items );\\n\\n\\t\/**\\n\\t * Intersect the collection with the given items by key.\\n\\t *\\n\\t * @param   \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable|iterable  $items\\n\\t * @return static\\n\\t *\/\\n\\tpublic function intersect_by_keys( $items );\\n\\n\\t\/**\\n\\t * Determine if the collection is empty or not.\\n\\t *\\n\\t * @return bool\\n\\t *\/\\n\\tpublic function is_empty();\\n\\n\\t\/**\\n\\t * Determine if the collection is not empty.\\n\\t *\\n\\t * @return bool\\n\\t *\/\\n\\tpublic function is_not_empty();\\n\\n\\t\/**\\n\\t * Join all items from the collection using a string. The final items can use a separate glue string.\\n\\t *\\n\\t * @param  string $glue\\n\\t * @param  string $final_glue\\n\\t * @return string\\n\\t *\/\\n\\tpublic function join( $glue, $final_glue = '' );\\n\\n\\t\/**\\n\\t * Get the keys of the collection items.\\n\\t *\\n\\t * @return static\\n\\t *\/\\n\\tpublic function keys();\\n\\n\\t\/**\\n\\t * Get the last item from the collection.\\n\\t *\\n\\t * @template TLastDefault\\n\\t *\\n\\t * @param  (callable(TValue, TKey): bool)|null  $callback\\n\\t * @param  TLastDefault|(\\\\Closure(): TLastDefault)  $default\\n\\t * @return TValue|TLastDefault\\n\\t *\/\\n\\tpublic function last( ?callable $callback = null, $default = null );\\n\\n\\t\/**\\n\\t * Run a map over each of the items.\\n\\t *\\n\\t * @template TMapValue\\n\\t *\\n\\t * @param  callable(TValue, TKey): TMapValue  $callback\\n\\t * @return static<TKey, TMapValue>\\n\\t *\/\\n\\tpublic function map( callable $callback );\\n\\n\\t\/**\\n\\t * Run a map over each nested chunk of items.\\n\\t *\\n\\t * @param  callable $callback\\n\\t * @return static\\n\\t *\/\\n\\tpublic function map_spread( callable $callback );\\n\\n\\t\/**\\n\\t * Run a dictionary map over the items.\\n\\t *\\n\\t * The callback should return an associative array with a single key\/value pair.\\n\\t *\\n\\t * @template TMapToDictionaryKey of array-key\\n\\t * @template TMapToDictionaryValue\\n\\t *\\n\\t * @param  callable(TValue, TKey): array<TMapToDictionaryKey, TMapToDictionaryValue>  $callback\\n\\t * @return static<TMapToDictionaryKey, array<int, TMapToDictionaryValue>>\\n\\t *\/\\n\\tpublic function map_to_dictionary( callable $callback );\\n\\n\\t\/**\\n\\t * Run a grouping map over the items.\\n\\t *\\n\\t * The callback should return an associative array with a single key\/value pair.\\n\\t *\/\\n\\tpublic function map_to_groups( callable $callback );\\n\\n\\t\/**\\n\\t * Run an associative map over each of the items.\\n\\t *\\n\\t * The callback should return an associative array with a single key\/value pair.\\n\\t *\\n\\t * @template TMapWithKeysKey of array-key\\n\\t * @template TMapWithKeysValue\\n\\t *\\n\\t * @param  callable(TValue, TKey): array<TMapWithKeysKey, TMapWithKeysValue>  $callback\\n\\t * @return static<TMapWithKeysKey, TMapWithKeysValue>\\n\\t *\/\\n\\tpublic function map_with_keys( callable $callback );\\n\\n\\t\/**\\n\\t * Map a collection and flatten the result by a single level.\\n\\t *\\n\\t * @template TFlatMapKey of array-key\\n\\t * @template TFlatMapValue\\n\\t *\\n\\t * @param  callable(TValue, TKey): (\\\\Illuminate\\\\Support\\\\Collection<TFlatMapKey, TFlatMapValue>|array<TFlatMapKey, TFlatMapValue>)  $callback\\n\\t * @return static<TFlatMapKey, TFlatMapValue>\\n\\t *\/\\n\\tpublic function flat_map( callable $callback );\\n\\n\\t\/**\\n\\t * Map the values into a new class.\\n\\t *\\n\\t * @template TMapIntoValue\\n\\t *\\n\\t * @param  class-string<TMapIntoValue>  $class\\n\\t * @return static<TKey, TMapIntoValue>\\n\\t *\/\\n\\tpublic function map_into( $class );\\n\\n\\t\/**\\n\\t * Merge the collection with the given items.\\n\\t *\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<TKey, TValue>|iterable<TKey, TValue>  $items\\n\\t * @return static\\n\\t *\/\\n\\tpublic function merge( $items );\\n\\n\\t\/**\\n\\t * Recursively merge the collection with the given items.\\n\\t *\\n\\t * @template TMergeRecursiveValue\\n\\t *\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<TKey, TMergeRecursiveValue>|iterable<TKey, TMergeRecursiveValue>  $items\\n\\t * @return static<TKey, TValue|TMergeRecursiveValue>\\n\\t *\/\\n\\tpublic function merge_recursive( $items );\\n\\n\\t\/**\\n\\t * Create a collection by using this collection for keys and another for its values.\\n\\t *\\n\\t * @template TCombineValue\\n\\t *\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<array-key, TCombineValue>|iterable<array-key, TCombineValue>  $values\\n\\t * @return static<TValue, TCombineValue>\\n\\t *\/\\n\\tpublic function combine( $values );\\n\\n\\t\/**\\n\\t * Union the collection with the given items.\\n\\t *\\n\\t * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<TKey, TValue>|iterable<TKey, TValue>  $items\\n\\t * @return static\\n\\t *\/\\n\\tpublic function union( $items );\\n\\n\\t\/**\\n\\t * Get the min value of a given key.\\n\\t *\\n\\t * @param  (callable(TValue):mixed)|string|null  $callback\\n\\t * @return mixed\\n\\t *\/\\n\\tpublic function min( $callback = null );\\n\\n\\t\/**\\n\\t * Get the max value of a given key.\\n\\t *\\n\\t * @param  (callable(TValue):mixed)|string|null  $callback\\n\\t * @return mixed\\n\\t *\/\\n\\tpublic function max( $callback = null );\\n\\n\\t\/**\\n\\t * Create a new collection consisting of every n-th element.\\n\\t *\\n\\t * @param  int $step\\n\\t * @param  int $offset\\n\\t * @return static\\n\\t *\/\\n\\tpublic function nth( $step, $offset = 0 );\\n\\n\\t\/**\\n\\t * Get the items with the specified keys.\\n\\t *\\n\\t * @param  \\\\Mantle\\\\Support\\\\Enumerable<array-key, TKey>|array<array-key, TKey>|string  $keys\\n\\t * @return static\\n\\t *\/\\n\\tpublic function only( $keys );\\n\\n\\t\/**\\n\\t * \\\"Paginate\\\" the collection by slicing it into a smaller collection.\\n\\t *\\n\\t * @param  int $page\\n\\t * @param  int $per_page\\n\\t * @return static\\n\\t *\/\\n\\tpublic function for_page( $page, $per_page );\\n\\n\\t\/**\\n\\t * Partition the collection into two arrays using the given callback or key.\\n\\t *\/\\n\\tpublic function partition( $key, $operator = null, $value = null );\\n\\n\\t\/**\\n\\t * Push all of the given items onto the collection.\\n\\t *\\n\\t * @param  iterable<array-key, TValue>  $source\\n\\t * @return static\\n\\t *\/\\n\\tpublic function concat( $source );\\n\\n\\t\/**\\n\\t * Get one or a specified number of items randomly from the collection.\\n\\t *\\n\\t * @param  int|null $number\\n\\t * @return static|mixed\\n\\t *\\n\\t * @throws \\\\InvalidArgumentException\\n\\t *\/\\n\\tpublic function random( $number = null );\\n\\n\\t\/**\\n\\t * Reduce the collection to a single value.\\n\\t *\\n\\t * @template TReduceInitial\\n\\t * @template TReduceReturnType\\n\\t *\\n\\t * @param  callable(TReduceInitial|TReduceReturnType, TValue, TKey): TReduceReturnType  $callback\\n\\t * @param  TReduceInitial  $initial\\n\\t * @return TReduceReturnType\\n\\t *\/\\n\\tpublic function reduce( callable $callback, $initial = null );\\n\\n\\t\/**\\n\\t * Replace the collection items with the given items.\\n\\t *\\n\\t * @param  mixed $items\\n\\t * @return static\\n\\t *\/\\n\\tpublic function replace( $items );\\n\\n\\t\/**\\n\\t * Recursively replace the collection items with the given items.\\n\\t *\\n\\t * @param  mixed $items\\n\\t * @return static\\n\\t *\/\\n\\tpublic function replace_recursive( $items );\\n\\n\\t\/**\\n\\t * Reverse items order.\\n\\t *\\n\\t * @return static\\n\\t *\/\\n\\tpublic function reverse();\\n\\n\\t\/**\\n\\t * Search the collection for a given value and return the corresponding key if successful.\\n\\t *\\n\\t * @param  TValue|callable(TValue,TKey): bool  $value\\n\\t * @param  bool  $strict\\n\\t * @return TKey|bool\\n\\t *\/\\n\\tpublic function search( $value, $strict = false );\\n\\n\\t\/**\\n\\t * Shuffle the items in the collection.\\n\\t *\\n\\t * @param  int|null $seed\\n\\t * @return static\\n\\t *\/\\n\\tpublic function shuffle( $seed = null );\\n\\n\\t\/**\\n\\t * Skip the first {$count} items.\\n\\t *\\n\\t * @param  int $count\\n\\t * @return static\\n\\t *\/\\n\\tpublic function skip( $count );\\n\\n\\t\/**\\n\\t * Get a slice of items from the enumerable.\\n\\t *\\n\\t * @param  int      $offset\\n\\t * @param  int|null $length\\n\\t * @return static\\n\\t *\/\\n\\tpublic function slice( $offset, $length = null );\\n\\n\\t\/**\\n\\t * Split a collection into a certain number of groups.\\n\\t *\\n\\t * @param  int $number_of_groups\\n\\t * @return static<int, static>\\n\\t *\/\\n\\tpublic function split( $number_of_groups );\\n\\n\\t\/**\\n\\t * Chunk the collection into chunks of the given size.\\n\\t *\\n\\t * @param  int $size\\n\\t * @return static<int, static>\\n\\t *\/\\n\\tpublic function chunk( $size );\\n\\n\\t\/**\\n\\t * Sort through each item with a callback.\\n\\t *\\n\\t * @param  (callable(TValue, TValue): int)|null|int  $callback\\n\\t * @return static\\n\\t *\/\\n\\tpublic function sort( $callback = null );\\n\\n\\t\/**\\n\\t * Sort items in descending order.\\n\\t *\\n\\t * @param  int $options\\n\\t * @return static\\n\\t *\/\\n\\tpublic function sort_desc( $options = SORT_REGULAR );\\n\\n\\t\/**\\n\\t * Sort the collection using the given callback.\\n\\t *\\n\\t * @param  array<array-key, (callable(TValue, TValue): mixed)|(callable(TValue, TKey): mixed)|string|array{string, string}>|(callable(TValue, TKey): mixed)|string  $callback\\n\\t * @param  int             $options\\n\\t * @param  bool            $descending\\n\\t * @return static\\n\\t *\/\\n\\tpublic function sort_by( $callback, $options = SORT_REGULAR, $descending = false );\\n\\n\\t\/**\\n\\t * Sort the collection in descending order using the given callback.\\n\\t *\\n\\t * @param  array<array-key, (callable(TValue, TValue): mixed)|(callable(TValue, TKey): mixed)|string|array{string, string}>|(callable(TValue, TKey): mixed)|string  $callback\\n\\t * @param  int             $options\\n\\t * @return static\\n\\t *\/\\n\\tpublic function sort_by_desc( $callback, $options = SORT_REGULAR );\\n\\n\\t\/**\\n\\t * Sort the collection keys.\\n\\t *\\n\\t * @param  int  $options\\n\\t * @param  bool $descending\\n\\t * @return static\\n\\t *\/\\n\\tpublic function sort_keys( $options = SORT_REGULAR, $descending = false );\\n\\n\\t\/**\\n\\t * Sort the collection keys in descending order.\\n\\t *\\n\\t * @param  int $options\\n\\t * @return static\\n\\t *\/\\n\\tpublic function sort_keys_desc( $options = SORT_REGULAR );\\n\\n\\t\/**\\n\\t * Get the sum of the given values.\\n\\t *\\n\\t * @param  (callable(TValue): mixed)|string|null  $callback\\n\\t * @return mixed\\n\\t *\/\\n\\tpublic function sum( $callback = null );\\n\\n\\t\/**\\n\\t * Take the first or last {$limit} items.\\n\\t *\\n\\t * @param  int $limit\\n\\t * @return static\\n\\t *\/\\n\\tpublic function take( $limit );\\n\\n\\t\/**\\n\\t * Pass the collection to the given callback and then return it.\\n\\t *\\n\\t * @param  callable(TValue): mixed  $callback\\n\\t * @return static\\n\\t *\/\\n\\tpublic function tap( callable $callback );\\n\\n\\t\/**\\n\\t * Pass the enumerable to the given callback and return the result.\\n\\t *\\n\\t * @template TPipeReturnType\\n\\t *\\n\\t * @param  callable($this): TPipeReturnType  $callback\\n\\t * @return TPipeReturnType\\n\\t *\/\\n\\tpublic function pipe( callable $callback );\\n\\n\\t\/**\\n\\t * Get the values of a given key.\\n\\t *\\n\\t * @param  string|array $value\\n\\t * @param  string|null  $key\\n\\t * @return static\\n\\t *\/\\n\\tpublic function pluck( $value, $key = null );\\n\\n\\t\/**\\n\\t * Create a collection of all elements that do not pass a given truth test.\\n\\t *\\n\\t * @param  (callable(TValue, TKey): bool)|bool|TValue  $callback\\n\\t * @return static\\n\\t *\/\\n\\tpublic function reject( $callback = true );\\n\\n\\t\/**\\n\\t * Return only unique items from the collection array.\\n\\t *\\n\\t * @param  (callable(TValue, TKey): mixed)|string|null  $key\\n\\t * @param  bool                 $strict\\n\\t * @return static\\n\\t *\/\\n\\tpublic function unique( $key = null, $strict = false );\\n\\n\\t\/**\\n\\t * Return only unique items from the collection array using strict comparison.\\n\\t *\\n\\t * @param  (callable(TValue, TKey): mixed)|string|null  $key\\n\\t * @return static\\n\\t *\/\\n\\tpublic function unique_strict( $key = null );\\n\\n\\t\/**\\n\\t * Reset the keys on the underlying array.\\n\\t *\\n\\t * @return static\\n\\t *\/\\n\\tpublic function values();\\n\\n\\t\/**\\n\\t * Pad collection to the specified length with a value.\\n\\t *\\n\\t * @template TPadValue\\n\\t *\\n\\t * @param  int  $size\\n\\t * @param  TPadValue  $value\\n\\t * @return static<int, TValue|TPadValue>\\n\\t *\/\\n\\tpublic function pad( $size, $value );\\n\\n\\t\/**\\n\\t * Count the number of items in the collection using a given truth test.\\n\\t *\\n\\t * @param  (callable(TValue, TKey): array-key)|string|null  $countBy\\n\\t * @return static<array-key, int>\\n\\t *\/\\n\\tpublic function count_by( $callback = null );\\n\\n\\t\/**\\n\\t * Collect the values into a collection.\\n\\t *\\n\\t * @return \\\\Mantle\\\\Support\\\\Collection<TKey, TValue>\\n\\t *\/\\n\\tpublic function collect();\\n\\n\\t\/**\\n\\t * Convert the collection to its string representation.\\n\\t *\\n\\t * @return string\\n\\t *\/\\n\\tpublic function __toString();\\n\\n\\t\/**\\n\\t * Add a method to the list of proxied methods.\\n\\t *\\n\\t * @param  string $method\\n\\t * @return void\\n\\t *\/\\n\\tpublic static function proxy( $method );\\n\\n\\t\/**\\n\\t * Dynamically access collection proxies.\\n\\t *\\n\\t * @param  string $key\\n\\t * @return mixed\\n\\t *\\n\\t * @throws \\\\Exception\\n\\t *\/\\n\\tpublic function __get( $key );\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/class-str.php\",\"ext\":\"php\",\"size\":33462,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Str class file\\n *\\n * phpcs:disable WordPress.PHP.YodaConditions.NotYoda\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support;\\n\\nuse JsonException;\\nuse League\\\\CommonMark\\\\Environment\\\\Environment;\\nuse League\\\\CommonMark\\\\Extension\\\\GithubFlavoredMarkdownExtension;\\nuse League\\\\CommonMark\\\\Extension\\\\InlinesOnly\\\\InlinesOnlyExtension;\\nuse League\\\\CommonMark\\\\GithubFlavoredMarkdownConverter;\\nuse League\\\\CommonMark\\\\MarkdownConverter;\\nuse Mantle\\\\Support\\\\Traits\\\\Macroable;\\nuse Ramsey\\\\Uuid\\\\Uuid;\\nuse Ramsey\\\\Uuid\\\\UuidFactory;\\nuse Ramsey\\\\Uuid\\\\UuidInterface;\\nuse Traversable;\\nuse voku\\\\helper\\\\ASCII;\\n\\nuse function Mantle\\\\Support\\\\Helpers\\\\collect;\\n\\n\/**\\n * String Support class\\n *\/\\nclass Str {\\n\\tuse Macroable;\\n\\n\\t\/**\\n\\t * The cache of snake-cased words.\\n\\t *\\n\\t * @var array<mixed>\\n\\t *\/\\n\\tprotected static $snake_cache = [];\\n\\n\\t\/**\\n\\t * The cache of camel-cased words.\\n\\t *\\n\\t * @var array<mixed>\\n\\t *\/\\n\\tprotected static $camel_cache = [];\\n\\n\\t\/**\\n\\t * The cache of studly-cased words.\\n\\t *\\n\\t * @var array<mixed>\\n\\t *\/\\n\\tprotected static $studly_cache = [];\\n\\n\\t\/**\\n\\t * The callback that should be used to generate random strings.\\n\\t *\\n\\t * @var callable|null\\n\\t *\/\\n\\tprotected static $random_string_factory;\\n\\n\\t\/**\\n\\t * Get a new stringable object from the given string.\\n\\t *\\n\\t * @param  string $string\\n\\t *\/\\n\\tpublic static function of( $string ): Stringable {\\n\\t\\treturn new Stringable( $string );\\n\\t}\\n\\n\\t\/**\\n\\t * Return the remainder of a string after the first occurrence of a given value.\\n\\t *\\n\\t * @param  string $subject\\n\\t * @param  string $search\\n\\t * @return string\\n\\t *\/\\n\\tpublic static function after( $subject, $search ) {\\n\\t\\treturn $search === '' ? $subject : array_reverse( explode( $search, $subject, 2 ) )[0];\\n\\t}\\n\\n\\t\/**\\n\\t * Return the remainder of a string after the last occurrence of a given value.\\n\\t *\\n\\t * @param  string $subject\\n\\t * @param  string $search\\n\\t * @return string\\n\\t *\/\\n\\tpublic static function after_last( $subject, $search ) {\\n\\t\\tif ( $search === '' ) {\\n\\t\\t\\treturn $subject;\\n\\t\\t}\\n\\n\\t\\t$position = strrpos( $subject, (string) $search );\\n\\n\\t\\tif ( $position === false ) {\\n\\t\\t\\treturn $subject;\\n\\t\\t}\\n\\n\\t\\treturn substr( $subject, $position + strlen( $search ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Transliterate a UTF-8 value to ASCII.\\n\\t *\\n\\t * @param  string|null $value\\n\\t * @param  string      $language\\n\\t *\/\\n\\tpublic static function ascii( ?string $value, string $language = 'en' ): string {\\n\\t\\treturn ASCII::to_ascii( (string) $value, $language );\\n\\t}\\n\\n\\t\/**\\n\\t * Transliterate a string to its closest ASCII representation.\\n\\t *\\n\\t * @param  string      $string\\n\\t * @param  string|null $unknown\\n\\t * @param  bool        $strict\\n\\t *\/\\n\\tpublic static function transliterate( string $string, ?string $unknown = '?', bool $strict = false ): string {\\n\\t\\treturn ASCII::to_transliterate( $string, $unknown, $strict );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the portion of a string before the first occurrence of a given value.\\n\\t *\\n\\t * @param  string $subject\\n\\t * @param  string $search\\n\\t *\/\\n\\tpublic static function before( string $subject, string $search ): string {\\n\\t\\tif ( '' === $search ) {\\n\\t\\t\\treturn $subject;\\n\\t\\t}\\n\\n\\t\\t$result = strstr( $subject, $search, true );\\n\\n\\t\\treturn $result === false ? $subject : $result;\\n\\t}\\n\\n\\t\/**\\n\\t * Get the portion of a string before the last occurrence of a given value.\\n\\t *\\n\\t * @param  string $subject\\n\\t * @param  string $search\\n\\t *\/\\n\\tpublic static function before_last( string $subject, string $search ): string {\\n\\t\\tif ( $search === '' ) {\\n\\t\\t\\treturn $subject;\\n\\t\\t}\\n\\n\\t\\t$pos = mb_strrpos( $subject, $search );\\n\\n\\t\\tif ( $pos === false ) {\\n\\t\\t\\treturn $subject;\\n\\t\\t}\\n\\n\\t\\treturn static::substr( $subject, 0, $pos );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the portion of a string between two given values.\\n\\t *\\n\\t * @param  string $subject\\n\\t * @param  string $from\\n\\t * @param  string $to\\n\\t *\/\\n\\tpublic static function between( string $subject, string $from, string $to ): string {\\n\\t\\tif ( $from === '' || $to === '' ) {\\n\\t\\t\\treturn $subject;\\n\\t\\t}\\n\\n\\t\\treturn static::before_last( static::after( $subject, $from ), $to );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the smallest possible portion of a string between two given values.\\n\\t *\\n\\t * @param  string $subject\\n\\t * @param  string $from\\n\\t * @param  string $to\\n\\t *\/\\n\\tpublic static function between_first( string $subject, string $from, string $to ): string {\\n\\t\\tif ( $from === '' || $to === '' ) {\\n\\t\\t\\treturn $subject;\\n\\t\\t}\\n\\n\\t\\treturn static::before( static::after( $subject, $from ), $to );\\n\\t}\\n\\n\\t\/**\\n\\t * Convert a value to camel case.\\n\\t *\\n\\t * @param  string $value\\n\\t *\/\\n\\tpublic static function camel( string $value ): string {\\n\\t\\treturn static::$camel_cache[ $value ] ?? ( static::$camel_cache[ $value ] = lcfirst( static::studly( $value ) ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the character at the specified index.\\n\\t *\\n\\t * @param  string $subject\\n\\t * @param  int    $index\\n\\t * @return string|false\\n\\t *\/\\n\\tpublic static function char_at( string $subject, int $index ): false|string {\\n\\t\\t$length = mb_strlen( $subject );\\n\\n\\t\\tif ( $index < 0 ? $index < -$length : $index > $length - 1 ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\treturn mb_substr( $subject, $index, 1 );\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if a given string contains a given substring.\\n\\t *\\n\\t * @param  string                  $haystack\\n\\t * @param  string|iterable<string> $needles\\n\\t * @param  bool                    $ignore_case\\n\\t *\/\\n\\tpublic static function contains( $haystack, $needles, $ignore_case = false ): bool {\\n\\t\\tif ( $ignore_case ) {\\n\\t\\t\\t$haystack = mb_strtolower( $haystack );\\n\\t\\t}\\n\\n\\t\\tif ( ! is_iterable( $needles ) ) {\\n\\t\\t\\t$needles = (array) $needles;\\n\\t\\t}\\n\\n\\t\\tforeach ( $needles as $needle ) {\\n\\t\\t\\tif ( $ignore_case ) {\\n\\t\\t\\t\\t$needle = mb_strtolower( $needle );\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( $needle !== '' && str_contains( $haystack, $needle ) ) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if a given string contains all array values.\\n\\t *\\n\\t * @param  string           $haystack\\n\\t * @param  iterable<string> $needles\\n\\t * @param  bool             $ignore_case\\n\\t *\/\\n\\tpublic static function contains_all( $haystack, $needles, bool $ignore_case = false ): bool {\\n\\t\\tforeach ( $needles as $needle ) {\\n\\t\\t\\tif ( ! static::contains( $haystack, $needle, $ignore_case ) ) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if a given string ends with a given substring.\\n\\t *\\n\\t * @param  string                  $haystack\\n\\t * @param  string|iterable<string> $needles\\n\\t *\/\\n\\tpublic static function ends_with( $haystack, $needles ): bool {\\n\\t\\tif ( ! is_iterable( $needles ) ) {\\n\\t\\t\\t$needles = (array) $needles;\\n\\t\\t}\\n\\n\\t\\tforeach ( $needles as $needle ) {\\n\\t\\t\\tif ( (string) $needle !== '' && str_ends_with( $haystack, $needle ) ) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\t\/**\\n\\t * Extracts an excerpt from text that matches the first instance of a phrase.\\n\\t *\\n\\t * @param  string                                 $text\\n\\t * @param  string                                 $phrase\\n\\t * @param  array{radius?: int, omission?: string} $options\\n\\t *\/\\n\\tpublic static function excerpt( string $text, string $phrase = '', array $options = [] ): ?string {\\n\\t\\t$radius   = $options['radius'] ?? 100;\\n\\t\\t$omission = $options['omission'] ?? '...';\\n\\n\\t\\tpreg_match( '\/^(.*?)(' . preg_quote( $phrase, null ) . ')(.*)$\/iu', $text, $matches );\\n\\n\\t\\tif ( empty( $matches ) ) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\t$start = ltrim( $matches[1] );\\n\\n\\t\\t$start = str( mb_substr( $start, max( mb_strlen( $start, 'UTF-8' ) - $radius, 0 ), $radius, 'UTF-8' ) )->ltrim()->unless(\\n\\t\\t\\tfn ( $start_with_radius ) => $start_with_radius->exactly( $start ),\\n\\t\\t\\tfn ( $start_with_radius ) => $start_with_radius->prepend( $omission ),\\n\\t\\t);\\n\\n\\t\\t$end = rtrim( $matches[3] );\\n\\n\\t\\t$end = str( mb_substr( $end, 0, $radius, 'UTF-8' ) )->rtrim()->unless(\\n\\t\\t\\tfn ( $end_with_radius ) => $end_with_radius->exactly( $end ),\\n\\t\\t\\tfn ( $end_with_radius ) => $end_with_radius->append( $omission ),\\n\\t\\t);\\n\\n\\t\\treturn $start->append( $matches[2], $end )->toString();\\n\\t}\\n\\n\\t\/**\\n\\t * Cap a string with a single instance of a given value.\\n\\t *\\n\\t * @param  string $value\\n\\t * @param  string $cap\\n\\t * @return string\\n\\t *\/\\n\\tpublic static function finish( $value, string $cap ) {\\n\\t\\t$quoted = preg_quote( $cap, '\/' );\\n\\n\\t\\treturn preg_replace( '\/(?:' . $quoted . ')+$\/u', '', $value ) . $cap;\\n\\t}\\n\\n\\t\/**\\n\\t * Wrap the string with the given strings.\\n\\t *\\n\\t * @param  string      $value\\n\\t * @param  string      $before\\n\\t * @param  string|null $after\\n\\t *\/\\n\\tpublic static function wrap( string $value, string $before, $after = null ): string {\\n\\t\\treturn $before . $value . ( $after ??= $before );\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if a given string matches a given pattern.\\n\\t *\\n\\t * @param  string|iterable<string> $pattern\\n\\t * @param  string                  $value\\n\\t *\/\\n\\tpublic static function is( string|iterable $pattern, ?string $value ): bool {\\n\\t\\tif ( ! is_iterable( $pattern ) ) {\\n\\t\\t\\t$pattern = [ $pattern ];\\n\\t\\t}\\n\\n\\t\\tforeach ( $pattern as $pattern ) {\\n\\t\\t\\t\/\/ If the given value is an exact match we can of course return true right\\n\\t\\t\\t\/\/ from the beginning. Otherwise, we will translate asterisks and do an\\n\\t\\t\\t\/\/ actual pattern match against the two strings to see if they match.\\n\\t\\t\\tif ( $pattern === $value ) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$pattern = (string) $pattern;\\n\\t\\t\\t$pattern = preg_quote( $pattern, '#' );\\n\\n\\t\\t\\t\/\/ Asterisks are translated into zero-or-more regular expression wildcards\\n\\t\\t\\t\/\/ to make it convenient to check if the strings starts with the given\\n\\t\\t\\t\/\/ pattern such as \\\"library\/*\\\", making any string check convenient.\\n\\t\\t\\t$pattern = str_replace( '\\\\*', '.*', $pattern );\\n\\n\\t\\t\\tif ( preg_match( '#^' . $pattern . '\\\\z#u', (string) $value ) === 1 ) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if a given string is 7 bit ASCII.\\n\\t *\\n\\t * @param  string $value\\n\\t *\/\\n\\tpublic static function is_ascii( $value ): bool {\\n\\t\\treturn ASCII::is_ascii( (string) $value );\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if a given string is valid JSON.\\n\\t *\\n\\t * @param  string $value\\n\\t *\/\\n\\tpublic static function is_json( $value ): bool {\\n\\t\\tif ( ! is_string( $value ) ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\ttry {\\n\\t\\t\\tjson_decode( $value, true, 512, JSON_THROW_ON_ERROR );\\n\\t\\t} catch ( JsonException ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if a given string is a valid UUID.\\n\\t *\\n\\t * @param  string $value\\n\\t * @return bool\\n\\t *\/\\n\\tpublic static function is_uuid( $value ) {\\n\\t\\tif ( ! is_string( $value ) ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\treturn preg_match( '\/^[\\\\da-f]{8}-[\\\\da-f]{4}-[\\\\da-f]{4}-[\\\\da-f]{4}-[\\\\da-f]{12}$\/iD', $value ) > 0;\\n\\t}\\n\\n\\t\/**\\n\\t * Convert a string to kebab case (hyphen case).\\n\\t *\\n\\t * @param  string $value\\n\\t * @return string\\n\\t *\/\\n\\tpublic static function kebab( $value ) {\\n\\t\\treturn static::snake( $value, '-' );\\n\\t}\\n\\n\\t\/**\\n\\t * Return the length of the given string.\\n\\t *\\n\\t * @param  string      $value\\n\\t * @param  string|null $encoding\\n\\t *\/\\n\\tpublic static function length( $value, $encoding = null ): int {\\n\\t\\treturn mb_strlen( $value, $encoding );\\n\\t}\\n\\n\\t\/**\\n\\t * Limit the number of characters in a string.\\n\\t *\\n\\t * @param  string $value\\n\\t * @param  int    $limit\\n\\t * @param  string $end\\n\\t * @return string\\n\\t *\/\\n\\tpublic static function limit( $value, $limit = 100, string $end = '...' ) {\\n\\t\\tif ( mb_strwidth( $value, 'UTF-8' ) <= $limit ) {\\n\\t\\t\\treturn $value;\\n\\t\\t}\\n\\n\\t\\treturn rtrim( mb_strimwidth( $value, 0, $limit, '', 'UTF-8' ) ) . $end;\\n\\t}\\n\\n\\t\/**\\n\\t * Convert the given string to lower-case.\\n\\t *\\n\\t * @param  string $value\\n\\t *\/\\n\\tpublic static function lower( $value ): string {\\n\\t\\treturn mb_strtolower( $value, 'UTF-8' );\\n\\t}\\n\\n\\t\/**\\n\\t * Limit the number of words in a string.\\n\\t *\\n\\t * @param  string $value\\n\\t * @param  int    $words\\n\\t * @param  string $end\\n\\t * @return string\\n\\t *\/\\n\\tpublic static function words( $value, $words = 100, string $end = '...' ) {\\n\\t\\tpreg_match( '\/^\\\\s*+(?:\\\\S++\\\\s*+){1,' . $words . '}\/u', $value, $matches );\\n\\n\\t\\tif ( ! isset( $matches[0] ) || static::length( $value ) === static::length( $matches[0] ) ) {\\n\\t\\t\\treturn $value;\\n\\t\\t}\\n\\n\\t\\treturn rtrim( $matches[0] ) . $end;\\n\\t}\\n\\n\\t\/**\\n\\t * Converts GitHub flavored Markdown into HTML.\\n\\t *\\n\\t * @param  string       $string\\n\\t * @param  array<mixed> $options Options for the Markdown environment.\\n\\t *\/\\n\\tpublic static function markdown( string $string, array $options = [] ): string {\\n\\t\\t$converter = new GithubFlavoredMarkdownConverter( $options );\\n\\n\\t\\treturn (string) $converter->convert( $string );\\n\\t}\\n\\n\\t\/**\\n\\t * Converts inline Markdown into HTML.\\n\\t *\\n\\t * @param  string       $string\\n\\t * @param  array<mixed> $options Options for the Markdown environment.\\n\\t *\/\\n\\tpublic static function inline_markdown( string $string, array $options = [] ): string {\\n\\t\\t$environment = new Environment( $options );\\n\\n\\t\\t$environment->addExtension( new GithubFlavoredMarkdownExtension() );\\n\\t\\t$environment->addExtension( new InlinesOnlyExtension() );\\n\\n\\t\\t$converter = new MarkdownConverter( $environment );\\n\\n\\t\\treturn (string) $converter->convert( $string );\\n\\t}\\n\\n\\t\/**\\n\\t * Masks a portion of a string with a repeated character.\\n\\t *\\n\\t * @param  string   $string\\n\\t * @param  string   $character\\n\\t * @param  int      $index\\n\\t * @param  int|null $length\\n\\t * @param  string   $encoding\\n\\t * @return string\\n\\t *\/\\n\\tpublic static function mask( $string, $character, $index, $length = null, $encoding = 'UTF-8' ) {\\n\\t\\tif ( '' === $character ) {\\n\\t\\t\\treturn $string;\\n\\t\\t}\\n\\n\\t\\t$segment = mb_substr( $string, $index, $length, $encoding );\\n\\n\\t\\tif ( '' === $segment ) {\\n\\t\\t\\treturn $string;\\n\\t\\t}\\n\\n\\t\\t$strlen      = mb_strlen( $string, $encoding );\\n\\t\\t$start_index = $index;\\n\\n\\t\\tif ( $index < 0 ) {\\n\\t\\t\\t$start_index = $index < -$strlen ? 0 : $strlen + $index;\\n\\t\\t}\\n\\n\\t\\t$start       = mb_substr( $string, 0, $start_index, $encoding );\\n\\t\\t$segment_len = mb_strlen( $segment, $encoding );\\n\\t\\t$end         = mb_substr( $string, $start_index + $segment_len );\\n\\n\\t\\treturn $start . str_repeat( mb_substr( $character, 0, 1, $encoding ), $segment_len ) . $end;\\n\\t}\\n\\n\\t\/**\\n\\t * Get the string matching the given pattern.\\n\\t *\\n\\t * @param  string $pattern\\n\\t * @param  string $subject\\n\\t *\/\\n\\tpublic static function match( $pattern, $subject ): string {\\n\\t\\tpreg_match( $pattern, $subject, $matches );\\n\\n\\t\\tif ( $matches === [] ) {\\n\\t\\t\\treturn '';\\n\\t\\t}\\n\\n\\t\\treturn $matches[1] ?? $matches[0];\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if a given string matches a given pattern.\\n\\t *\\n\\t * @param  string|iterable<string> $pattern\\n\\t * @param  string                  $value\\n\\t *\/\\n\\tpublic static function is_match( $pattern, $value ): bool {\\n\\t\\t$value = (string) $value;\\n\\n\\t\\tif ( ! is_iterable( $pattern ) ) {\\n\\t\\t\\t$pattern = [ $pattern ];\\n\\t\\t}\\n\\n\\t\\tforeach ( $pattern as $pattern ) {\\n\\t\\t\\t$pattern = (string) $pattern;\\n\\n\\t\\t\\tif ( preg_match( $pattern, $value ) === 1 ) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\t\/**\\n\\t * Get the string matching the given pattern.\\n\\t *\\n\\t * @param  string $pattern\\n\\t * @param  string $subject\\n\\t *\/\\n\\tpublic static function match_all( $pattern, $subject ): Collection {\\n\\t\\tpreg_match_all( $pattern, $subject, $matches );\\n\\n\\t\\tif ( empty( $matches[0] ) ) {\\n\\t\\t\\treturn collect();\\n\\t\\t}\\n\\n\\t\\treturn collect( $matches[1] ?? $matches[0] );\\n\\t}\\n\\n\\t\/**\\n\\t * Pad both sides of a string with another.\\n\\t *\\n\\t * @param  string $value\\n\\t * @param  int    $length\\n\\t * @param  string $pad\\n\\t *\/\\n\\tpublic static function pad_both( string $value, $length, $pad = ' ' ): string {\\n\\t\\t$short       = max( 0, $length - mb_strlen( $value ) );\\n\\t\\t$short_left  = (int) floor( $short \/ 2 );\\n\\t\\t$short_right = (int) ceil( $short \/ 2 );\\n\\n\\t\\treturn mb_substr( str_repeat( $pad, $short_left ), 0, $short_left ) .\\n\\t\\t$value .\\n\\t\\tmb_substr( str_repeat( $pad, $short_right ), 0, $short_right );\\n\\t}\\n\\n\\t\/**\\n\\t * Pad the left side of a string with another.\\n\\t *\\n\\t * @param  string $value\\n\\t * @param  int    $length\\n\\t * @param  string $pad\\n\\t *\/\\n\\tpublic static function pad_left( string $value, $length, $pad = ' ' ): string {\\n\\t\\t$short = max( 0, $length - mb_strlen( $value ) );\\n\\n\\t\\treturn mb_substr( str_repeat( $pad, $short ), 0, $short ) . $value;\\n\\t}\\n\\n\\t\/**\\n\\t * Pad the right side of a string with another.\\n\\t *\\n\\t * @param  string $value\\n\\t * @param  int    $length\\n\\t * @param  string $pad\\n\\t *\/\\n\\tpublic static function pad_right( string $value, $length, $pad = ' ' ): string {\\n\\t\\t$short = max( 0, $length - mb_strlen( $value ) );\\n\\n\\t\\treturn $value . mb_substr( str_repeat( $pad, $short ), 0, $short );\\n\\t}\\n\\n\\t\/**\\n\\t * Parse a Class[@]method style callback into class and method.\\n\\t *\\n\\t * @param  string      $callback\\n\\t * @param  string|null $default\\n\\t * @return array<int, string|null>\\n\\t *\/\\n\\tpublic static function parse_callback( $callback, $default = null ) {\\n\\t\\treturn static::contains( $callback, '@' ) ? explode( '@', $callback, 2 ) : [ $callback, $default ];\\n\\t}\\n\\n\\t\/**\\n\\t * Get the plural form of an English word.\\n\\t *\\n\\t * @param  string                      $value\\n\\t * @param  int|array<mixed>|\\\\Countable $count\\n\\t *\/\\n\\tpublic static function plural( string $value, int|array|\\\\Countable $count = 2 ): string {\\n\\t\\treturn Pluralizer::plural( $value, $count );\\n\\t}\\n\\n\\t\/**\\n\\t * Pluralize the last word of an English, studly caps case string.\\n\\t *\\n\\t * @param  string                      $value\\n\\t * @param  int|array<mixed>|\\\\Countable $count\\n\\t *\/\\n\\tpublic static function plural_studly( $value, int|array|\\\\Countable $count = 2 ): string {\\n\\t\\t$parts = preg_split( '\/(.)(?=[A-Z])\/u', $value, -1, PREG_SPLIT_DELIM_CAPTURE );\\n\\n\\t\\t$last_word = array_pop( $parts );\\n\\n\\t\\treturn implode( '', $parts ) . self::plural( $last_word, $count );\\n\\t}\\n\\n\\t\/**\\n\\t * Generate a random, secure password.\\n\\t *\\n\\t * @param  int  $length\\n\\t * @param  bool $letters\\n\\t * @param  bool $numbers\\n\\t * @param  bool $symbols\\n\\t * @param  bool $spaces\\n\\t *\/\\n\\tpublic static function password( $length = 32, $letters = true, $numbers = true, $symbols = true, $spaces = false ): string {\\n\\t\\treturn ( new Collection() )\\n\\t\\t->when(\\n\\t\\t\\t$letters,\\n\\t\\t\\tfn ( $c ) => $c->merge(\\n\\t\\t\\t\\t[\\n\\t\\t\\t\\t\\t'a',\\n\\t\\t\\t\\t\\t'b',\\n\\t\\t\\t\\t\\t'c',\\n\\t\\t\\t\\t\\t'd',\\n\\t\\t\\t\\t\\t'e',\\n\\t\\t\\t\\t\\t'f',\\n\\t\\t\\t\\t\\t'g',\\n\\t\\t\\t\\t\\t'h',\\n\\t\\t\\t\\t\\t'i',\\n\\t\\t\\t\\t\\t'j',\\n\\t\\t\\t\\t\\t'k',\\n\\t\\t\\t\\t\\t'l',\\n\\t\\t\\t\\t\\t'm',\\n\\t\\t\\t\\t\\t'n',\\n\\t\\t\\t\\t\\t'o',\\n\\t\\t\\t\\t\\t'p',\\n\\t\\t\\t\\t\\t'q',\\n\\t\\t\\t\\t\\t'r',\\n\\t\\t\\t\\t\\t's',\\n\\t\\t\\t\\t\\t't',\\n\\t\\t\\t\\t\\t'u',\\n\\t\\t\\t\\t\\t'v',\\n\\t\\t\\t\\t\\t'w',\\n\\t\\t\\t\\t\\t'x',\\n\\t\\t\\t\\t\\t'y',\\n\\t\\t\\t\\t\\t'z',\\n\\t\\t\\t\\t\\t'A',\\n\\t\\t\\t\\t\\t'B',\\n\\t\\t\\t\\t\\t'C',\\n\\t\\t\\t\\t\\t'D',\\n\\t\\t\\t\\t\\t'E',\\n\\t\\t\\t\\t\\t'F',\\n\\t\\t\\t\\t\\t'G',\\n\\t\\t\\t\\t\\t'H',\\n\\t\\t\\t\\t\\t'I',\\n\\t\\t\\t\\t\\t'J',\\n\\t\\t\\t\\t\\t'K',\\n\\t\\t\\t\\t\\t'L',\\n\\t\\t\\t\\t\\t'M',\\n\\t\\t\\t\\t\\t'N',\\n\\t\\t\\t\\t\\t'O',\\n\\t\\t\\t\\t\\t'P',\\n\\t\\t\\t\\t\\t'Q',\\n\\t\\t\\t\\t\\t'R',\\n\\t\\t\\t\\t\\t'S',\\n\\t\\t\\t\\t\\t'T',\\n\\t\\t\\t\\t\\t'U',\\n\\t\\t\\t\\t\\t'V',\\n\\t\\t\\t\\t\\t'W',\\n\\t\\t\\t\\t\\t'X',\\n\\t\\t\\t\\t\\t'Y',\\n\\t\\t\\t\\t\\t'Z',\\n\\t\\t\\t\\t]\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\t->when(\\n\\t\\t\\t$numbers,\\n\\t\\t\\tfn ( $c ) => $c->merge(\\n\\t\\t\\t\\t[\\n\\t\\t\\t\\t\\t'0',\\n\\t\\t\\t\\t\\t'1',\\n\\t\\t\\t\\t\\t'2',\\n\\t\\t\\t\\t\\t'3',\\n\\t\\t\\t\\t\\t'4',\\n\\t\\t\\t\\t\\t'5',\\n\\t\\t\\t\\t\\t'6',\\n\\t\\t\\t\\t\\t'7',\\n\\t\\t\\t\\t\\t'8',\\n\\t\\t\\t\\t\\t'9',\\n\\t\\t\\t\\t]\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\t->when(\\n\\t\\t\\t$symbols,\\n\\t\\t\\tfn ( $c ) => $c->merge(\\n\\t\\t\\t\\t[\\n\\t\\t\\t\\t\\t'~',\\n\\t\\t\\t\\t\\t'!',\\n\\t\\t\\t\\t\\t'#',\\n\\t\\t\\t\\t\\t'$',\\n\\t\\t\\t\\t\\t'%',\\n\\t\\t\\t\\t\\t'^',\\n\\t\\t\\t\\t\\t'&',\\n\\t\\t\\t\\t\\t'*',\\n\\t\\t\\t\\t\\t'(',\\n\\t\\t\\t\\t\\t')',\\n\\t\\t\\t\\t\\t'-',\\n\\t\\t\\t\\t\\t'_',\\n\\t\\t\\t\\t\\t'.',\\n\\t\\t\\t\\t\\t',',\\n\\t\\t\\t\\t\\t'<',\\n\\t\\t\\t\\t\\t'>',\\n\\t\\t\\t\\t\\t'?',\\n\\t\\t\\t\\t\\t'\/',\\n\\t\\t\\t\\t\\t'\\\\\\\\',\\n\\t\\t\\t\\t\\t'{',\\n\\t\\t\\t\\t\\t'}',\\n\\t\\t\\t\\t\\t'[',\\n\\t\\t\\t\\t\\t']',\\n\\t\\t\\t\\t\\t'|',\\n\\t\\t\\t\\t\\t':',\\n\\t\\t\\t\\t\\t';',\\n\\t\\t\\t\\t]\\n\\t\\t\\t)\\n\\t\\t)\\n\\t\\t->when( $spaces, fn ( $c ) => $c->merge( [ ' ' ] ) )\\n\\t\\t->pipe( fn ( $c ) => Collection::times( $length, fn () => $c[ random_int( 0, $c->count() - 1 ) ] ) ) \/\/ phpcs:ignore VariableAnalysis.CodeAnalysis.VariableAnalysis.UndefinedVariable, Generic.CodeAnalysis.AssignmentInCondition.FoundInWhileCondition\\n\\t\\t->implode( '' );\\n\\t}\\n\\n\\t\/**\\n\\t * Generate a more truly \\\"random\\\" alpha-numeric string.\\n\\t *\\n\\t * @param  int $length\\n\\t * @return string\\n\\t *\/\\n\\tpublic static function random( $length = 16 ) {\\n\\t\\treturn ( static::$random_string_factory ?? function ( $length ): string {\\n\\t\\t\\t$string = '';\\n\\n\\t\\t\\twhile ( ( $len = strlen( $string ) ) < $length ) { \/\/ phpcs:ignore WordPress.CodeAnalysis.AssignmentInCondition.FoundInWhileCondition, Generic.CodeAnalysis.AssignmentInCondition.FoundInWhileCondition, Squiz.PHP.DisallowSizeFunctionsInLoops.Found\\n\\t\\t\\t\\t$size = $length - $len;\\n\\n\\t\\t\\t\\t$bytes_size = (int) ceil( $size \/ 3 ) * 3;\\n\\n\\t\\t\\t\\t$bytes = random_bytes( $bytes_size );\\n\\n\\t\\t\\t\\t$string .= substr( str_replace( [ '\/', '+', '=' ], '', base64_encode( $bytes ) ), 0, $size );\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn $string;\\n\\t\\t} )( $length );\\n\\t}\\n\\n\\t\/**\\n\\t * Set the callable that will be used to generate random strings.\\n\\t *\\n\\t * @param  callable|null $factory\\n\\t *\/\\n\\tpublic static function create_random_strings_using( ?callable $factory = null ): void {\\n\\t\\tstatic::$random_string_factory = $factory;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the sequence that will be used to generate random strings.\\n\\t *\\n\\t * @param  string[]      $sequence\\n\\t * @param  callable|null $when_missing\\n\\t *\/\\n\\tpublic static function create_random_strings_using_sequence( array $sequence, $when_missing = null ): void {\\n\\t\\t$next = 0;\\n\\n\\t\\t$when_missing ??= function ( $length ) use ( &$next ) {\\n\\t\\t\\t$factory_cache = static::$random_string_factory;\\n\\n\\t\\t\\tstatic::$random_string_factory = null;\\n\\n\\t\\t\\t$random_string = static::random( $length );\\n\\n\\t\\t\\tstatic::$random_string_factory = $factory_cache;\\n\\n\\t\\t\\t$next++;\\n\\n\\t\\t\\treturn $random_string;\\n\\t\\t};\\n\\n\\t\\tstatic::create_random_strings_using(\\n\\t\\t\\tfunction ( $length ) use ( &$next, $sequence, $when_missing ) {\\n\\t\\t\\t\\tif ( array_key_exists( $next, $sequence ) ) {\\n\\t\\t\\t\\t\\treturn $sequence[ $next++ ];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn $when_missing( $length );\\n\\t\\t\\t}\\n\\t\\t);\\n\\t}\\n\\n\\t\/**\\n\\t * Indicate that random strings should be created normally and not using a custom factory.\\n\\t *\/\\n\\tpublic static function create_random_strings_normally(): void {\\n\\t\\tstatic::$random_string_factory = null;\\n\\t}\\n\\n\\t\/**\\n\\t * Repeat the given string.\\n\\t *\\n\\t * @param  string $string\\n\\t * @param  int    $times\\n\\t *\/\\n\\tpublic static function repeat( string $string, int $times ): string {\\n\\t\\treturn str_repeat( $string, $times );\\n\\t}\\n\\n\\t\/**\\n\\t * Replace a given value in the string sequentially with an array.\\n\\t *\\n\\t * @param  string           $search\\n\\t * @param  iterable<string> $replace\\n\\t * @param  string           $subject\\n\\t * @return string\\n\\t *\/\\n\\tpublic static function replace_array( $search, $replace, $subject ) {\\n\\t\\tif ( $replace instanceof Traversable ) {\\n\\t\\t\\t$replace = collect( $replace )->all();\\n\\t\\t}\\n\\n\\t\\t$segments = explode( $search, $subject );\\n\\n\\t\\t$result = array_shift( $segments );\\n\\n\\t\\tforeach ( $segments as $segment ) {\\n\\t\\t\\t$result .= ( array_shift( $replace ) ?? $search ) . $segment;\\n\\t\\t}\\n\\n\\t\\treturn $result;\\n\\t}\\n\\n\\t\/**\\n\\t * Replace the given value in the given string.\\n\\t *\\n\\t * @param  string|iterable<string> $search\\n\\t * @param  string|iterable<string> $replace\\n\\t * @param  string|iterable<string> $subject\\n\\t * @param  bool                    $case_sensitive\\n\\t * @return string|array<string>\\n\\t *\/\\n\\tpublic static function replace( $search, $replace, $subject, bool $case_sensitive = true ): string|array {\\n\\t\\tif ( $search instanceof Traversable ) {\\n\\t\\t\\t$search = collect( $search )->all();\\n\\t\\t}\\n\\n\\t\\tif ( $replace instanceof Traversable ) {\\n\\t\\t\\t$replace = collect( $replace )->all();\\n\\t\\t}\\n\\n\\t\\tif ( $subject instanceof Traversable ) {\\n\\t\\t\\t$subject = collect( $subject )->all();\\n\\t\\t}\\n\\n\\t\\treturn $case_sensitive\\n\\t\\t\\t\\t? str_replace( $search, $replace, $subject )\\n\\t\\t\\t\\t: str_ireplace( $search, $replace, $subject );\\n\\t}\\n\\n\\t\/**\\n\\t * Replace the first occurrence of a given value in the string.\\n\\t *\\n\\t * @param  string $search\\n\\t * @param  string $replace\\n\\t * @param  string $subject\\n\\t * @return string\\n\\t *\/\\n\\tpublic static function replace_first( $search, $replace, $subject ) {\\n\\t\\t$search = (string) $search;\\n\\n\\t\\tif ( '' === $search ) {\\n\\t\\t\\treturn $subject;\\n\\t\\t}\\n\\n\\t\\t$position = strpos( $subject, $search );\\n\\n\\t\\tif ( false !== $position ) {\\n\\t\\t\\treturn substr_replace( $subject, $replace, $position, strlen( $search ) );\\n\\t\\t}\\n\\n\\t\\treturn $subject;\\n\\t}\\n\\n\\t\/**\\n\\t * Replace the last occurrence of a given value in the string.\\n\\t *\\n\\t * @param  string $search\\n\\t * @param  string $replace\\n\\t * @param  string $subject\\n\\t * @return string\\n\\t *\/\\n\\tpublic static function replace_last( $search, $replace, $subject ) {\\n\\t\\tif ( '' === $search ) {\\n\\t\\t\\treturn $subject;\\n\\t\\t}\\n\\n\\t\\t$position = strrpos( $subject, $search );\\n\\n\\t\\tif ( $position !== false ) {\\n\\t\\t\\treturn substr_replace( $subject, $replace, $position, strlen( $search ) );\\n\\t\\t}\\n\\n\\t\\treturn $subject;\\n\\t}\\n\\n\\t\/**\\n\\t * Remove any occurrence of the given string in the subject.\\n\\t *\\n\\t * @param  string|iterable<string> $search\\n\\t * @param  string                  $subject\\n\\t * @param  bool                    $case_sensitive\\n\\t * @return string|array<string>\\n\\t *\/\\n\\tpublic static function remove( $search, $subject, bool $case_sensitive = true ): string|array {\\n\\t\\tif ( $search instanceof Traversable ) {\\n\\t\\t\\t$search = collect( $search )->all();\\n\\t\\t}\\n\\n\\t\\treturn $case_sensitive\\n\\t\\t\\t\\t\\t? str_replace( $search, '', $subject )\\n\\t\\t\\t\\t\\t: str_ireplace( $search, '', $subject );\\n\\t}\\n\\n\\t\/**\\n\\t * Reverse the given string.\\n\\t *\\n\\t * @param  string $value\\n\\t *\/\\n\\tpublic static function reverse( string $value ): string {\\n\\t\\treturn implode( '', array_reverse( mb_str_split( $value ) ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Begin a string with a single instance of a given value.\\n\\t *\\n\\t * @param  string $value\\n\\t * @param  string $prefix\\n\\t * @return string\\n\\t *\/\\n\\tpublic static function start( $value, string $prefix ) {\\n\\t\\t$quoted = preg_quote( $prefix, '\/' );\\n\\n\\t\\treturn $prefix . preg_replace( '\/^(?:' . $quoted . ')+\/u', '', $value );\\n\\t}\\n\\n\\t\/**\\n\\t * Convert the given string to upper-case.\\n\\t *\\n\\t * @param  string $value\\n\\t *\/\\n\\tpublic static function upper( $value ): string {\\n\\t\\treturn mb_strtoupper( $value, 'UTF-8' );\\n\\t}\\n\\n\\t\/**\\n\\t * Convert the given string to title case.\\n\\t *\\n\\t * @param  string $value\\n\\t *\/\\n\\tpublic static function title( string $value ): string {\\n\\t\\treturn mb_convert_case( $value, MB_CASE_TITLE, 'UTF-8' );\\n\\t}\\n\\n\\t\/**\\n\\t * Convert the given string to title case for each word.\\n\\t *\\n\\t * @param  string $value\\n\\t *\/\\n\\tpublic static function headline( string $value ): string {\\n\\t\\t$parts = explode( ' ', $value );\\n\\n\\t\\t$parts = count( $parts ) > 1\\n\\t\\t\\t? array_map( [ static::class, 'title' ], $parts )\\n\\t\\t\\t: array_map( [ static::class, 'title' ], static::ucsplit( implode( '_', $parts ) ) );\\n\\n\\t\\t$collapsed = static::replace( [ '-', '_', ' ' ], '_', implode( '_', $parts ) );\\n\\n\\t\\treturn implode( ' ', array_filter( explode( '_', $collapsed ) ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the singular form of an English word.\\n\\t *\\n\\t * @param  string $value\\n\\t *\/\\n\\tpublic static function singular( string $value ): string {\\n\\t\\treturn Pluralizer::singular( $value );\\n\\t}\\n\\n\\t\/**\\n\\t * Generate a URL friendly \\\"slug\\\" from a given string.\\n\\t *\\n\\t * @param  string|null           $title\\n\\t * @param  string                $separator\\n\\t * @param  string|null           $language\\n\\t * @param  array<string, string> $dictionary\\n\\t *\/\\n\\tpublic static function slug( ?string $title, string $separator = '-', ?string $language = 'en', array $dictionary = [ '@' => 'at' ] ): string {\\n\\t\\t$title = $language ? static::ascii( $title, $language ) : $title;\\n\\n\\t\\t\/\/ Convert all dashes\/underscores into separator.\\n\\t\\t$flip = '-' === $separator ? '_' : '-';\\n\\n\\t\\t$title = preg_replace( '![' . preg_quote( $flip, null ) . ']+!u', $separator, (string) $title );\\n\\n\\t\\t\/\/ Replace dictionary words.\\n\\t\\tforeach ( $dictionary as $key => $value ) {\\n\\t\\t\\t$dictionary[ $key ] = $separator . $value . $separator;\\n\\t\\t}\\n\\n\\t\\t$title = str_replace( array_keys( $dictionary ), array_values( $dictionary ), (string) $title );\\n\\n\\t\\t\/\/ Remove all characters that are not the separator, letters, numbers, or whitespace.\\n\\t\\t$title = preg_replace( '![^' . preg_quote( $separator, null ) . '\\\\pL\\\\pN\\\\s]+!u', '', static::lower( $title ) );\\n\\n\\t\\t\/\/ Replace all separator characters and whitespace by a single separator.\\n\\t\\t$title = preg_replace( '![' . preg_quote( $separator, null ) . '\\\\s]+!u', $separator, (string) $title );\\n\\n\\t\\treturn trim( (string) $title, $separator );\\n\\t}\\n\\n\\t\/**\\n\\t * Convert a string to snake case.\\n\\t *\\n\\t * @param  string $value\\n\\t * @param  string $delimiter\\n\\t * @return string\\n\\t *\/\\n\\tpublic static function snake( $value, string $delimiter = '_' ) {\\n\\t\\t$key = $value;\\n\\n\\t\\tif ( isset( static::$snake_cache[ $key ][ $delimiter ] ) ) {\\n\\t\\t\\treturn static::$snake_cache[ $key ][ $delimiter ];\\n\\t\\t}\\n\\n\\t\\tif ( ! ctype_lower( $value ) ) {\\n\\t\\t\\t$value = preg_replace( '\/\\\\s+\/u', '', ucwords( $value ) );\\n\\n\\t\\t\\t$value = static::lower( preg_replace( '\/(.)(?=[A-Z])\/u', '$1' . $delimiter, (string) $value ) );\\n\\t\\t}\\n\\n\\t\\treturn static::$snake_cache[ $key ][ $delimiter ] = $value;\\n\\t}\\n\\n\\t\/**\\n\\t * Remove all \\\"extra\\\" blank space from the given string.\\n\\t *\\n\\t * @param  string $value\\n\\t * @return string\\n\\t *\/\\n\\tpublic static function squish( $value ): ?string {\\n\\t\\treturn preg_replace( '~(\\\\s|\\\\x{3164}|\\\\x{1160})+~u', ' ', (string) preg_replace( '~^[\\\\s\\\\x{FEFF}]+|[\\\\s\\\\x{FEFF}]+$~u', '', $value ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if a given string starts with a given substring.\\n\\t *\\n\\t * @param  string                  $haystack\\n\\t * @param  string|iterable<string> $needles\\n\\t *\/\\n\\tpublic static function starts_with( $haystack, $needles ): bool {\\n\\t\\tif ( ! is_iterable( $needles ) ) {\\n\\t\\t\\t$needles = [ $needles ];\\n\\t\\t}\\n\\n\\t\\tforeach ( $needles as $needle ) {\\n\\t\\t\\tif ( '' !== (string) $needle && str_starts_with( $haystack, $needle ) ) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\t\/**\\n\\t * Convert a value to studly caps case.\\n\\t *\\n\\t * @param  string $value\\n\\t * @return string\\n\\t *\/\\n\\tpublic static function studly( $value ) {\\n\\t\\t$key = $value;\\n\\n\\t\\tif ( isset( static::$studly_cache[ $key ] ) ) {\\n\\t\\t\\treturn static::$studly_cache[ $key ];\\n\\t\\t}\\n\\n\\t\\t$words = explode( ' ', static::replace( [ '-', '_' ], ' ', $value ) );\\n\\n\\t\\t$study_words = array_map( fn ( string $word ) => static::ucfirst( $word ), $words );\\n\\n\\t\\treturn static::$studly_cache[ $key ] = implode( '', $study_words );\\n\\t}\\n\\n\\t\/**\\n\\t * Convert a value to studly caps case while preserving spaces as underscores.\\n\\t *\\n\\t * @param string $value Value to studly.\\n\\t *\/\\n\\tpublic static function studly_underscore( $value ): string {\\n\\t\\t$value = ucwords( str_replace( [ '-', '_' ], ' ', $value ) );\\n\\t\\treturn str_replace( ' ', '_', $value );\\n\\t}\\n\\n\\t\/**\\n\\t * Returns the portion of the string specified by the start and length parameters.\\n\\t *\\n\\t * @param  string   $string\\n\\t * @param  int      $start\\n\\t * @param  int|null $length\\n\\t * @param  string   $encoding\\n\\t *\/\\n\\tpublic static function substr( $string, $start, $length = null, $encoding = 'UTF-8' ): string {\\n\\t\\treturn mb_substr( $string, $start, $length, $encoding );\\n\\t}\\n\\n\\t\/**\\n\\t * Returns the number of substring occurrences.\\n\\t *\\n\\t * @param  string   $haystack\\n\\t * @param  string   $needle\\n\\t * @param  int      $offset\\n\\t * @param  int|null $length\\n\\t *\/\\n\\tpublic static function substr_count( $haystack, $needle, $offset = 0, $length = null ): int {\\n\\t\\tif ( ! is_null( $length ) ) {\\n\\t\\t\\treturn substr_count( $haystack, $needle, $offset, $length );\\n\\t\\t}\\n\\n\\t\\treturn substr_count( $haystack, $needle, $offset );\\n\\t}\\n\\n\\t\/**\\n\\t * Replace text within a portion of a string.\\n\\t *\\n\\t * @param  string|string[] $string\\n\\t * @param  string|string[] $replace\\n\\t * @param  int|int[]       $offset\\n\\t * @param  int|int[]|null  $length\\n\\t * @return string|string[]\\n\\t *\/\\n\\tpublic static function substr_replace( $string, $replace, $offset = 0, $length = null ): array|string {\\n\\t\\tif ( is_null( $length ) ) {\\n\\t\\t\\t$length = strlen( $string );\\n\\t\\t}\\n\\n\\t\\treturn substr_replace( $string, $replace, $offset, $length );\\n\\t}\\n\\n\\t\/**\\n\\t * Swap multiple keywords in a string with other keywords.\\n\\t *\\n\\t * @param  array<string, string> $map\\n\\t * @param  string                $subject\\n\\t *\/\\n\\tpublic static function swap( array $map, $subject ): string {\\n\\t\\treturn strtr( $subject, $map );\\n\\t}\\n\\n\\t\/**\\n\\t * Make a string's first character lowercase.\\n\\t *\\n\\t * @param  string $string\\n\\t *\/\\n\\tpublic static function lcfirst( $string ): string {\\n\\t\\treturn static::lower( static::substr( $string, 0, 1 ) ) . static::substr( $string, 1 );\\n\\t}\\n\\n\\t\/**\\n\\t * Make a string's first character uppercase.\\n\\t *\\n\\t * @param  string $string\\n\\t *\/\\n\\tpublic static function ucfirst( $string ): string {\\n\\t\\treturn static::upper( static::substr( $string, 0, 1 ) ) . static::substr( $string, 1 );\\n\\t}\\n\\n\\t\/**\\n\\t * Split a string into pieces by uppercase characters.\\n\\t *\\n\\t * @param  string $string\\n\\t * @return string[]\\n\\t *\/\\n\\tpublic static function ucsplit( $string ) {\\n\\t\\treturn preg_split( '\/(?=\\\\p{Lu})\/u', $string, -1, PREG_SPLIT_NO_EMPTY );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the number of words a string contains.\\n\\t *\\n\\t * @param  string      $string\\n\\t * @param  string|null $characters\\n\\t *\/\\n\\tpublic static function word_count( $string, $characters = null ): int {\\n\\t\\treturn str_word_count( $string, 0, $characters );\\n\\t}\\n\\n\\t\/**\\n\\t * Generate a UUID (version 4).\\n\\t *\/\\n\\tpublic static function uuid(): UuidInterface {\\n\\t\\treturn Uuid::uuid4();\\n\\t}\\n\\n\\t\/**\\n\\t * Get the line number for a match from a character position.\\n\\t *\\n\\t * Useful inside of a regex match to determine the line number of the\\n\\t * matched pair.\\n\\t *\\n\\t * The character position can be retrieved when matching against a string\\n\\t * by passing `PREG_OFFSET_CAPTURE` to `preg_match_all()` as a flag.\\n\\t *\\n\\t * @param string $contents Contents used to match against.\\n\\t * @param int    $char_pos Character position.\\n\\t *\/\\n\\tpublic static function line_number( string $contents, int $char_pos ): int {\\n\\t\\t[ $before ] = str_split( $contents, $char_pos );\\n\\t\\treturn strlen( $before ) - strlen( str_replace( PHP_EOL, '', $before ) ) + 1;\\n\\t}\\n\\n\\t\/**\\n\\t * Add a trailing slash to a string.\\n\\t *\\n\\t * @param string $string String to trail.\\n\\t *\/\\n\\tpublic static function trailing_slash( string $string ): string {\\n\\t\\treturn rtrim( $string, '\/' ) . '\/';\\n\\t}\\n\\n\\t\/**\\n\\t * Remove a trailing slash from a string.\\n\\t *\\n\\t * @param string $string String to untrail.\\n\\t *\/\\n\\tpublic static function untrailing_slash( string $string ): string {\\n\\t\\treturn rtrim( $string, '\/' );\\n\\t}\\n\\n\\t\/**\\n\\t * Add a preceding slash to a string.\\n\\t *\\n\\t * @param string $string String to proceed.\\n\\t *\/\\n\\tpublic static function preceding_slash( string $string ): string {\\n\\t\\treturn '\/' . static::unpreceding_slash( $string );\\n\\t}\\n\\n\\t\/**\\n\\t * Remove a preceding slash from a string.\\n\\t *\\n\\t * @param string $string String to proceed.\\n\\t *\/\\n\\tpublic static function unpreceding_slash( string $string ): string {\\n\\t\\treturn ltrim( $string, '\/\\\\\\\\' );\\n\\t}\\n\\n\\t\/**\\n\\t * Remove all strings from the casing caches.\\n\\t *\/\\n\\tpublic static function flush_cache(): void {\\n\\t\\tstatic::$snake_cache  = [];\\n\\t\\tstatic::$camel_cache  = [];\\n\\t\\tstatic::$studly_cache = [];\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/class-string-replacements.php\",\"ext\":\"php\",\"size\":2512,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * String_Replacements class file\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support;\\n\\n\/**\\n * Collects pairs of strings to search and replace.\\n *\/\\nclass String_Replacements {\\n\\t\/**\\n\\t * Collected strings to search for.\\n\\t *\\n\\t * @var string[]|string[][]\\n\\t *\/\\n\\tprotected $search = [];\\n\\n\\t\/**\\n\\t * Collected strings to replace found search values.\\n\\t *\\n\\t * @var string[]|string[][]\\n\\t *\/\\n\\tprotected $replace = [];\\n\\n\\t\/**\\n\\t * Number of search-replace pairs collected.\\n\\t *\\n\\t * @var int\\n\\t *\/\\n\\tprotected $length = 0;\\n\\n\\t\/**\\n\\t * Whether only individual strings have been added and thus can be passed to\\n\\t * \\\\str_replace() as arrays of strings.\\n\\t *\\n\\t * @var bool\\n\\t *\/\\n\\tprotected $only_strings = true;\\n\\n\\t\/**\\n\\t * Add a search\/replace pair.\\n\\t *\\n\\t * @param string|string[] $search  The value or values being searched for.\\n\\t * @param string|string[] $replace The value or values that replaces found $search values.\\n\\t *\/\\n\\tpublic function add( $search, $replace ): void {\\n\\t\\t\/\/ Allow passing the results of expressions that might not generate different values.\\n\\t\\tif ( $search === $replace ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( $this->only_strings && ( ! \\\\is_string( $search ) || ! \\\\is_string( $replace ) ) ) {\\n\\t\\t\\t$this->only_strings = false;\\n\\t\\t}\\n\\n\\t\\t$this->search[]  = $search;\\n\\t\\t$this->replace[] = $replace;\\n\\t\\t$this->length++;\\n\\t}\\n\\n\\t\/**\\n\\t * Apply the search\/replace pairs to a subject using \\\\str_replace().\\n\\t *\\n\\t * @param string|string[] $subject String or strings to alter.\\n\\t * @return string|string[] Altered string or strings.\\n\\t *\/\\n\\tpublic function replace( $subject ) {\\n\\t\\treturn $this->apply( $subject, '\\\\str_replace' );\\n\\t}\\n\\n\\t\/**\\n\\t * Apply the search\/replace pairs to a subject using \\\\str_ireplace().\\n\\t *\\n\\t * @param string|string[] $subject String or strings to alter.\\n\\t * @return string|string[] Altered string or strings.\\n\\t *\/\\n\\tpublic function ireplace( $subject ) {\\n\\t\\treturn $this->apply( $subject, '\\\\str_ireplace' );\\n\\t}\\n\\n\\t\/**\\n\\t * Wrapper to apply the \\\\str_*() function to the subject.\\n\\t *\\n\\t * @param string|string[] $subject  Subject.\\n\\t * @param callable        $callable \\\\str_replace() or \\\\str_ireplace().\\n\\t * @return string|string[] Altered string or strings.\\n\\t *\/\\n\\tprivate function apply( $subject, callable $callable ) {\\n\\t\\tif ( ! $this->length ) {\\n\\t\\t\\treturn $subject;\\n\\t\\t}\\n\\n\\t\\tif ( $this->only_strings ) {\\n\\t\\t\\treturn $callable( $this->search, $this->replace, $subject );\\n\\t\\t}\\n\\n\\t\\tfor ( $i = 0; $i < $this->length; $i++ ) {\\n\\t\\t\\t$subject = $callable( $this->search[ $i ], $this->replace[ $i ], $subject );\\n\\t\\t}\\n\\n\\t\\treturn $subject;\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/class-stringable.php\",\"ext\":\"php\",\"size\":27998,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Stringable class file\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support;\\n\\nuse ArrayAccess;\\nuse Closure;\\nuse Carbon\\\\Carbon as Date;\\nuse Mantle\\\\Support\\\\Traits\\\\Conditionable;\\nuse Mantle\\\\Support\\\\Traits\\\\Macroable;\\nuse JsonSerializable;\\nuse Mantle\\\\Support\\\\Traits\\\\Makeable;\\nuse Mantle\\\\Support\\\\Traits\\\\Tappable;\\nuse Symfony\\\\Component\\\\VarDumper\\\\VarDumper;\\n\\nuse function Mantle\\\\Support\\\\Helpers\\\\collect;\\n\\n\/**\\n * Stringable Class\\n *\\n * Allows for the chaining of string methods.\\n *\\n * @implements ArrayAccess<int, string>\\n *\/\\nclass Stringable implements ArrayAccess, JsonSerializable, \\\\Stringable {\\n\\tuse Conditionable;\\n\\tuse Macroable;\\n\\tuse Makeable;\\n\\tuse Tappable;\\n\\n\\t\/**\\n\\t * The underlying string value.\\n\\t *\/\\n\\tprotected string $value = '';\\n\\n\\t\/**\\n\\t * Create a new instance of the class.\\n\\t *\\n\\t * @param  string $value\\n\\t * @return void\\n\\t *\/\\n\\tpublic function __construct( $value = '' ) {\\n\\t\\t$this->value = (string) $value;\\n\\t}\\n\\n\\t\/**\\n\\t * Return the remainder of a string after the first occurrence of a given value.\\n\\t *\\n\\t * @param  string $search\\n\\t *\/\\n\\tpublic function after( $search ): static {\\n\\t\\treturn new static( Str::after( $this->value, $search ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Return the remainder of a string after the last occurrence of a given value.\\n\\t *\\n\\t * @param  string $search\\n\\t *\/\\n\\tpublic function after_last( $search ): static {\\n\\t\\treturn new static( Str::after_last( $this->value, $search ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Append the given values to the string.\\n\\t *\\n\\t * @param  array<string>|string ...$values\\n\\t *\/\\n\\tpublic function append( ...$values ): static {\\n\\t\\treturn new static( $this->value . implode( '', $values ) ); \/\/ @phpstan-ignore-line implode expects array<string>\\n\\t}\\n\\n\\t\/**\\n\\t * Append a new line to the string.\\n\\t *\\n\\t * @param  int $count\\n\\t *\/\\n\\tpublic function newLine( $count = 1 ): static {\\n\\t\\treturn $this->append( str_repeat( PHP_EOL, $count ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Transliterate a UTF-8 value to ASCII.\\n\\t *\\n\\t * @param  string $language\\n\\t *\/\\n\\tpublic function ascii( string $language = 'en' ): static {\\n\\t\\treturn new static( Str::ascii( $this->value, $language ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the trailing name component of the path.\\n\\t *\\n\\t * @param  string $suffix\\n\\t *\/\\n\\tpublic function basename( string $suffix = '' ): static {\\n\\t\\treturn new static( basename( $this->value, $suffix ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the character at the specified index.\\n\\t *\\n\\t * @param  int $index\\n\\t * @return string|false\\n\\t *\/\\n\\tpublic function char_at( int $index ): string|false {\\n\\t\\treturn Str::char_at( $this->value, $index );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the basename of the class path.\\n\\t *\/\\n\\tpublic function class_basename(): static {\\n\\t\\treturn new static( class_basename( $this->value ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the portion of a string before the first occurrence of a given value.\\n\\t *\\n\\t * @param  string $search\\n\\t *\/\\n\\tpublic function before( string $search ): static {\\n\\t\\treturn new static( Str::before( $this->value, $search ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the portion of a string before the last occurrence of a given value.\\n\\t *\\n\\t * @param  string $search\\n\\t *\/\\n\\tpublic function before_last( string $search ): static {\\n\\t\\treturn new static( Str::before_last( $this->value, $search ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the portion of a string between two given values.\\n\\t *\\n\\t * @param  string $from\\n\\t * @param  string $to\\n\\t *\/\\n\\tpublic function between( string $from, string $to ): static {\\n\\t\\treturn new static( Str::between( $this->value, $from, $to ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the smallest possible portion of a string between two given values.\\n\\t *\\n\\t * @param  string $from\\n\\t * @param  string $to\\n\\t *\/\\n\\tpublic function between_first( string $from, string $to ): static {\\n\\t\\treturn new static( Str::between_first( $this->value, $from, $to ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Convert a value to camel case.\\n\\t *\/\\n\\tpublic function camel(): static {\\n\\t\\treturn new static( Str::camel( $this->value ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if a given string contains a given substring.\\n\\t *\\n\\t * @param  string|iterable<string> $needles\\n\\t * @param  bool                    $ignore_case\\n\\t *\/\\n\\tpublic function contains( string|iterable $needles, bool $ignore_case = false ): bool {\\n\\t\\treturn Str::contains( $this->value, $needles, $ignore_case );\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if a given string contains all array values.\\n\\t *\\n\\t * @param  iterable<string> $needles\\n\\t * @param  bool             $ignore_case\\n\\t *\/\\n\\tpublic function contains_all( string|iterable $needles, bool $ignore_case = false ): bool {\\n\\t\\treturn Str::contains_all( $this->value, $needles, $ignore_case );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the parent directory's path.\\n\\t *\\n\\t * @param  int $levels\\n\\t *\/\\n\\tpublic function dirname( int $levels = 1 ): static {\\n\\t\\treturn new static( dirname( $this->value, $levels ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Alias to ends_with().\\n\\t *\\n\\t * @param  string|iterable<string>|mixed $needles\\n\\t *\/\\n\\tpublic function endsWith( mixed $needles ): bool {\\n\\t\\treturn $this->ends_with( $needles );\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if a given string ends with a given substring.\\n\\t *\\n\\t * @param  string|iterable<string>|mixed $needles\\n\\t *\/\\n\\tpublic function ends_with( mixed $needles ): bool {\\n\\t\\treturn Str::ends_with( $this->value, $needles );\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if the string is an exact match with the given value.\\n\\t *\\n\\t * @param mixed $value\\n\\t *\/\\n\\tpublic function exactly( mixed $value ): bool {\\n\\t\\tif ( $value instanceof Stringable ) {\\n\\t\\t\\t$value = $value->toString();\\n\\t\\t}\\n\\n\\t\\treturn $this->value === $value;\\n\\t}\\n\\n\\t\/**\\n\\t * Extracts an excerpt from text that matches the first instance of a phrase.\\n\\t *\\n\\t * @param  string       $phrase\\n\\t * @param  array<mixed> $options\\n\\t *\/\\n\\tpublic function excerpt( string $phrase = '', array $options = [] ): ?string {\\n\\t\\treturn Str::excerpt( $this->value, $phrase, $options );\\n\\t}\\n\\n\\t\/**\\n\\t * Explode the string into an array.\\n\\t *\\n\\t * @param  string $delimiter\\n\\t * @param  int    $limit\\n\\t * @return Collection<int, string>\\n\\t *\/\\n\\tpublic function explode( string $delimiter, int $limit = PHP_INT_MAX ): Collection {\\n\\t\\treturn collect( explode( $delimiter, $this->value, $limit ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Split a string using a regular expression or by length.\\n\\t *\\n\\t * @param  string|int $pattern\\n\\t * @param  int        $limit\\n\\t * @param  int        $flags\\n\\t * @return Collection<int, mixed>\\n\\t *\/\\n\\tpublic function split( string|int $pattern, int $limit = -1, int $flags = 0 ) {\\n\\t\\tif ( filter_var( $pattern, FILTER_VALIDATE_INT ) !== false ) {\\n\\t\\t\\treturn collect( mb_str_split( $this->value, $pattern ) );\\n\\t\\t}\\n\\n\\t\\t$segments = preg_split( $pattern, $this->value, $limit, $flags );\\n\\n\\t\\treturn empty( $segments ) ? collect() : collect( $segments );\\n\\t}\\n\\n\\t\/**\\n\\t * Cap a string with a single instance of a given value.\\n\\t *\\n\\t * @param  string $cap\\n\\t *\/\\n\\tpublic function finish( string $cap ): static {\\n\\t\\treturn new static( Str::finish( $this->value, $cap ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Ensure the string has a single trailing slash.\\n\\t *\/\\n\\tpublic function trailingSlash(): static {\\n\\t\\treturn new static( Str::trailing_slash( $this->value ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Remove a trailing slash from the string.\\n\\t *\/\\n\\tpublic function untrailingSlash(): static {\\n\\t\\treturn new static( Str::untrailing_slash( $this->value ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Remove a trailing string from the string.\\n\\t *\\n\\t * @param  string $cap\\n\\t *\/\\n\\tpublic function untrailing( string $cap ): static {\\n\\t\\treturn new static( rtrim( $this->value, $cap ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if a given string matches a given pattern.\\n\\t *\\n\\t * @param  string|iterable<string> $pattern\\n\\t *\/\\n\\tpublic function is( string|iterable $pattern ): bool {\\n\\t\\treturn Str::is( $pattern, $this->value );\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if a given string is 7 bit ASCII.\\n\\t *\/\\n\\tpublic function is_ascii(): bool {\\n\\t\\treturn Str::is_ascii( $this->value );\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if a given string is valid JSON.\\n\\t *\/\\n\\tpublic function is_json(): bool {\\n\\t\\treturn Str::is_json( $this->value );\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if a given string is a valid UUID.\\n\\t *\\n\\t * @return bool\\n\\t *\/\\n\\tpublic function is_uuid() {\\n\\t\\treturn Str::is_uuid( $this->value );\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if the given string is empty.\\n\\t *\/\\n\\tpublic function is_empty(): bool {\\n\\t\\treturn '' === $this->value;\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if the given string is not empty.\\n\\t *\/\\n\\tpublic function is_not_empty(): bool {\\n\\t\\treturn ! $this->is_empty();\\n\\t}\\n\\n\\t\/**\\n\\t * Convert a string to kebab case.\\n\\t *\/\\n\\tpublic function kebab(): static {\\n\\t\\treturn new static( Str::kebab( $this->value ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Return the length of the given string.\\n\\t *\\n\\t * @param  string|null $encoding\\n\\t *\/\\n\\tpublic function length( $encoding = null ): int {\\n\\t\\treturn Str::length( $this->value, $encoding );\\n\\t}\\n\\n\\t\/**\\n\\t * Limit the number of characters in a string.\\n\\t *\\n\\t * @param  int    $limit\\n\\t * @param  string $end\\n\\t *\/\\n\\tpublic function limit( $limit = 100, string $end = '...' ): static {\\n\\t\\treturn new static( Str::limit( $this->value, $limit, $end ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Convert the given string to lower-case.\\n\\t *\/\\n\\tpublic function lower(): static {\\n\\t\\treturn new static( Str::lower( $this->value ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Convert GitHub flavored Markdown into HTML.\\n\\t *\\n\\t * @param  array<mixed> $options\\n\\t *\/\\n\\tpublic function markdown( array $options = [] ): static {\\n\\t\\treturn new static( Str::markdown( $this->value, $options ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Convert inline Markdown into HTML.\\n\\t *\\n\\t * @param  array<mixed> $options\\n\\t *\/\\n\\tpublic function inline_markdown( array $options = [] ): static {\\n\\t\\treturn new static( Str::inline_markdown( $this->value, $options ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Masks a portion of a string with a repeated character.\\n\\t *\\n\\t * @param  string   $character\\n\\t * @param  int      $index\\n\\t * @param  int|null $length\\n\\t * @param  string   $encoding\\n\\t *\/\\n\\tpublic function mask( $character, $index, $length = null, $encoding = 'UTF-8' ): static {\\n\\t\\treturn new static( Str::mask( $this->value, $character, $index, $length, $encoding ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the string matching the given pattern.\\n\\t *\\n\\t * @param  string $pattern\\n\\t *\/\\n\\tpublic function match( $pattern ): static {\\n\\t\\treturn new static( Str::match( $pattern, $this->value ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if a given string matches a given pattern.\\n\\t *\\n\\t * @param  string|iterable<string> $pattern\\n\\t *\/\\n\\tpublic function is_match( $pattern ): bool {\\n\\t\\treturn Str::is_match( $pattern, $this->value );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the string matching the given pattern.\\n\\t *\\n\\t * @param  string $pattern\\n\\t *\/\\n\\tpublic function match_all( $pattern ): Collection {\\n\\t\\treturn Str::match_all( $pattern, $this->value );\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if the string matches the given pattern.\\n\\t *\\n\\t * @param  string $pattern\\n\\t *\/\\n\\tpublic function test( $pattern ): bool {\\n\\t\\treturn $this->is_match( $pattern );\\n\\t}\\n\\n\\t\/**\\n\\t * Pad both sides of the string with another.\\n\\t *\\n\\t * @param  int    $length\\n\\t * @param  string $pad\\n\\t *\/\\n\\tpublic function pad_both( $length, $pad = ' ' ): static {\\n\\t\\treturn new static( Str::pad_both( $this->value, $length, $pad ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Pad the left side of the string with another.\\n\\t *\\n\\t * @param  int    $length\\n\\t * @param  string $pad\\n\\t *\/\\n\\tpublic function pad_left( $length, $pad = ' ' ): static {\\n\\t\\treturn new static( Str::pad_left( $this->value, $length, $pad ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Pad the right side of the string with another.\\n\\t *\\n\\t * @param  int    $length\\n\\t * @param  string $pad\\n\\t *\/\\n\\tpublic function pad_right( $length, $pad = ' ' ): static {\\n\\t\\treturn new static( Str::pad_right( $this->value, $length, $pad ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Parse a Class@method style callback into class and method.\\n\\t *\\n\\t * @param  string|null $default\\n\\t * @return array<int, string|null>\\n\\t *\/\\n\\tpublic function parse_callback( $default = null ) {\\n\\t\\treturn Str::parse_callback( $this->value, $default );\\n\\t}\\n\\n\\t\/**\\n\\t * Call the given callback and return a new string.\\n\\t *\\n\\t * @param  callable $callback\\n\\t *\/\\n\\tpublic function pipe( callable $callback ): static {\\n\\t\\treturn new static( $callback( $this ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the plural form of an English word.\\n\\t *\\n\\t * @param  int|array<mixed>|\\\\Countable $count\\n\\t *\/\\n\\tpublic function plural( int|array|\\\\Countable $count = 2 ): static {\\n\\t\\treturn new static( Str::plural( $this->value, $count ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Pluralize the last word of an English, studly caps case string.\\n\\t *\\n\\t * @param  int|array<mixed>|\\\\Countable $count\\n\\t *\/\\n\\tpublic function plural_studly( int|array|\\\\Countable $count = 2 ): static {\\n\\t\\treturn new static( Str::plural_studly( $this->value, $count ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Prepend the given values to the string.\\n\\t *\\n\\t * @param  string ...$values\\n\\t *\/\\n\\tpublic function prepend( ...$values ): static {\\n\\t\\treturn new static( implode( '', $values ) . $this->value );\\n\\t}\\n\\n\\t\/**\\n\\t * Remove any occurrence of the given string in the subject.\\n\\t *\\n\\t * @param  string|iterable<string> $search\\n\\t * @param  bool                    $case_sensitive\\n\\t *\/\\n\\tpublic function remove( $search, bool $case_sensitive = true ): static {\\n\\t\\treturn new static( Str::remove( $search, $this->value, $case_sensitive ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Reverse the string.\\n\\t *\/\\n\\tpublic function reverse(): static {\\n\\t\\treturn new static( Str::reverse( $this->value ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Repeat the string.\\n\\t *\\n\\t * @param  int $times\\n\\t *\/\\n\\tpublic function repeat( int $times ): static {\\n\\t\\treturn new static( str_repeat( $this->value, $times ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Replace the given value in the given string.\\n\\t *\\n\\t * @param  string|iterable<string> $search\\n\\t * @param  string|iterable<string> $replace\\n\\t * @param  bool                    $case_sensitive\\n\\t *\/\\n\\tpublic function replace( $search, $replace, bool $case_sensitive = true ): static {\\n\\t\\treturn new static( Str::replace( $search, $replace, $this->value, $case_sensitive ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Replace a given value in the string sequentially with an array.\\n\\t *\\n\\t * @param  string           $search\\n\\t * @param  iterable<string> $replace\\n\\t *\/\\n\\tpublic function replace_array( $search, $replace ): static {\\n\\t\\treturn new static( Str::replace_array( $search, $replace, $this->value ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Replace the first occurrence of a given value in the string.\\n\\t *\\n\\t * @param  string $search\\n\\t * @param  string $replace\\n\\t *\/\\n\\tpublic function replace_first( $search, $replace ): static {\\n\\t\\treturn new static( Str::replace_first( $search, $replace, $this->value ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Replace the last occurrence of a given value in the string.\\n\\t *\\n\\t * @param  string $search\\n\\t * @param  string $replace\\n\\t *\/\\n\\tpublic function replace_last( $search, $replace ): static {\\n\\t\\treturn new static( Str::replace_last( $search, $replace, $this->value ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Replace the patterns matching the given regular expression.\\n\\t *\\n\\t * @param  string          $pattern\\n\\t * @param  \\\\Closure|string $replace\\n\\t * @param  int             $limit\\n\\t *\/\\n\\tpublic function replace_matches( $pattern, $replace, $limit = -1 ): static {\\n\\t\\tif ( $replace instanceof Closure ) {\\n\\t\\t\\treturn new static( preg_replace_callback( $pattern, $replace, $this->value, $limit ) );\\n\\t\\t}\\n\\n\\t\\treturn new static( preg_replace( $pattern, $replace, $this->value, $limit ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Parse input from a string to a collection, according to a format.\\n\\t *\\n\\t * @param  string $format\\n\\t *\/\\n\\tpublic function scan( $format ): Collection {\\n\\t\\treturn collect( sscanf( $this->value, $format ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Remove all \\\"extra\\\" blank space from the given string.\\n\\t *\/\\n\\tpublic function squish(): static {\\n\\t\\treturn new static( Str::squish( $this->value ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Begin a string with a single instance of a given value.\\n\\t *\\n\\t * @param  string $prefix\\n\\t *\/\\n\\tpublic function start( string $prefix ): static {\\n\\t\\treturn new static( Str::start( $this->value, $prefix ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Strip HTML and PHP tags from the given string.\\n\\t *\\n\\t * @param  string[]|string $allowed_tags\\n\\t *\/\\n\\tpublic function strip_tags( array|string|null $allowed_tags = null ): static {\\n\\t\\treturn new static( strip_tags( $this->value, $allowed_tags ) ); \/\/ phpcs:ignore WordPressVIPMinimum.Functions.StripTags.StripTagsTwoParameters\\n\\t}\\n\\n\\t\/**\\n\\t * Convert the given string to upper-case.\\n\\t *\/\\n\\tpublic function upper(): static {\\n\\t\\treturn new static( Str::upper( $this->value ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Convert the given string to title case.\\n\\t *\/\\n\\tpublic function title(): static {\\n\\t\\treturn new static( Str::title( $this->value ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Convert the given string to title case for each word.\\n\\t *\/\\n\\tpublic function headline(): static {\\n\\t\\treturn new static( Str::headline( $this->value ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the singular form of an English word.\\n\\t *\/\\n\\tpublic function singular(): static {\\n\\t\\treturn new static( Str::singular( $this->value ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Generate a URL friendly \\\"slug\\\" from a given string.\\n\\t *\\n\\t * @param  string                $separator\\n\\t * @param  string|null           $language\\n\\t * @param  array<string, string> $dictionary\\n\\t *\/\\n\\tpublic function slug( string $separator = '-', ?string $language = 'en', array $dictionary = [ '@' => 'at' ] ): static {\\n\\t\\treturn new static( Str::slug( $this->value, $separator, $language, $dictionary ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Alias for slug().\\n\\t *\\n\\t * @param string                $separator Default is '-'.\\n\\t * @param string                $language  Default is 'en'.\\n\\t * @param array<string, string> $dictionary Default is [ '@' => 'at' ].\\n\\t *\/\\n\\tpublic function slugify( string $separator = '-', ?string $language = 'en', array $dictionary = [ '@' => 'at' ] ): static {\\n\\t\\treturn $this->slug( $separator, $language, $dictionary );\\n\\t}\\n\\n\\t\/**\\n\\t * Convert a string to snake case.\\n\\t *\\n\\t * @param  string $delimiter\\n\\t *\/\\n\\tpublic function snake( string $delimiter = '_' ): static {\\n\\t\\treturn new static( Str::snake( $this->value, $delimiter ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if a given string starts with a given substring.\\n\\t *\\n\\t * @param  string|iterable<string> $needles\\n\\t *\/\\n\\tpublic function startsWith( $needles ): bool {\\n\\t\\treturn Str::starts_with( $this->value, $needles );\\n\\t}\\n\\n\\t\/**\\n\\t * Convert a value to studly caps case.\\n\\t *\/\\n\\tpublic function studly(): static {\\n\\t\\treturn new static( Str::studly( $this->value ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Convert a value to studly caps case using underscores.\\n\\t *\/\\n\\tpublic function studlyUnderscore(): static {\\n\\t\\treturn new static( Str::studly_underscore( $this->value ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Returns the portion of the string specified by the start and length parameters.\\n\\t *\\n\\t * @param  int      $start\\n\\t * @param  int|null $length\\n\\t * @param  string   $encoding\\n\\t *\/\\n\\tpublic function substr( $start, $length = null, $encoding = 'UTF-8' ): static {\\n\\t\\treturn new static( Str::substr( $this->value, $start, $length, $encoding ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Returns the number of substring occurrences.\\n\\t *\\n\\t * @param  string   $needle\\n\\t * @param  int      $offset\\n\\t * @param  int|null $length\\n\\t *\/\\n\\tpublic function substr_count( $needle, $offset = 0, $length = null ): int {\\n\\t\\treturn Str::substr_count( $this->value, $needle, $offset, $length );\\n\\t}\\n\\n\\t\/**\\n\\t * Replace text within a portion of a string.\\n\\t *\\n\\t * @param  string|string[] $replace\\n\\t * @param  int|int[]       $offset\\n\\t * @param  int|int[]|null  $length\\n\\t *\/\\n\\tpublic function substr_replace( $replace, $offset = 0, $length = null ): static {\\n\\t\\treturn new static( Str::substr_replace( $this->value, $replace, $offset, $length ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Swap multiple keywords in a string with other keywords.\\n\\t *\\n\\t * @param  array<mixed> $map\\n\\t *\/\\n\\tpublic function swap( array $map ): static {\\n\\t\\treturn new static( strtr( $this->value, $map ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Trim the string of the given characters.\\n\\t *\\n\\t * @param  string $characters\\n\\t *\/\\n\\tpublic function trim( $characters = null ): static {\\n\\t\\treturn new static( trim( ...array_merge( [ $this->value ], func_get_args() ) ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Left trim the string of the given characters.\\n\\t *\\n\\t * @param  string $characters\\n\\t *\/\\n\\tpublic function ltrim( $characters = null ): static {\\n\\t\\treturn new static( ltrim( ...array_merge( [ $this->value ], func_get_args() ) ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Right trim the string of the given characters.\\n\\t *\\n\\t * @param  string $characters\\n\\t *\/\\n\\tpublic function rtrim( $characters = null ): static {\\n\\t\\treturn new static( rtrim( ...array_merge( [ $this->value ], func_get_args() ) ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Make a string's first character lowercase.\\n\\t *\/\\n\\tpublic function lcfirst(): static {\\n\\t\\treturn new static( Str::lcfirst( $this->value ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Make a string's first character uppercase.\\n\\t *\/\\n\\tpublic function ucfirst(): static {\\n\\t\\treturn new static( Str::ucfirst( $this->value ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Split a string by uppercase characters.\\n\\t *\\n\\t * @return Collection<int, string>\\n\\t *\/\\n\\tpublic function ucsplit(): Collection {\\n\\t\\treturn collect( Str::ucsplit( $this->value ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Execute the given callback if the string contains a given substring.\\n\\t *\\n\\t * @param  string|iterable<string> $needles\\n\\t * @param  callable                $callback\\n\\t * @param  callable|null           $default\\n\\t * @return static\\n\\t *\/\\n\\tpublic function when_contains( string|iterable $needles, ?callable $callback, ?callable $default = null ) {\\n\\t\\treturn $this->when( $this->contains( $needles ), $callback, $default );\\n\\t}\\n\\n\\t\/**\\n\\t * Execute the given callback if the string contains all array values.\\n\\t *\\n\\t * @param  array<string> $needles\\n\\t * @param  callable      $callback\\n\\t * @param  callable|null $default\\n\\t * @return static\\n\\t *\/\\n\\tpublic function when_contains_all( array $needles, ?callable $callback, ?callable $default = null ) {\\n\\t\\treturn $this->when( $this->contains_all( $needles ), $callback, $default );\\n\\t}\\n\\n\\t\/**\\n\\t * Execute the given callback if the string is empty.\\n\\t *\\n\\t * @param  callable      $callback\\n\\t * @param  callable|null $default\\n\\t * @return static\\n\\t *\/\\n\\tpublic function when_empty( ?callable $callback, ?callable $default = null ) {\\n\\t\\treturn $this->when( $this->is_empty(), $callback, $default );\\n\\t}\\n\\n\\t\/**\\n\\t * Execute the given callback if the string is not empty.\\n\\t *\\n\\t * @param  callable      $callback\\n\\t * @param  callable|null $default\\n\\t * @return static\\n\\t *\/\\n\\tpublic function when_not_empty( ?callable $callback, ?callable $default = null ) {\\n\\t\\treturn $this->when( $this->is_not_empty(), $callback, $default );\\n\\t}\\n\\n\\t\/**\\n\\t * Execute the given callback if the string ends with a given substring.\\n\\t *\\n\\t * @param  string|iterable<string> $needles\\n\\t * @param  callable                $callback\\n\\t * @param  callable|null           $default\\n\\t * @return static\\n\\t *\/\\n\\tpublic function when_ends_with( $needles, ?callable $callback, ?callable $default = null ) {\\n\\t\\treturn $this->when( $this->ends_with( $needles ), $callback, $default );\\n\\t}\\n\\n\\t\/**\\n\\t * Execute the given callback if the string is an exact match with the given value.\\n\\t *\\n\\t * @param  string        $value\\n\\t * @param  callable      $callback\\n\\t * @param  callable|null $default\\n\\t * @return static\\n\\t *\/\\n\\tpublic function when_exactly( $value, ?callable $callback, ?callable $default = null ) {\\n\\t\\treturn $this->when( $this->exactly( $value ), $callback, $default );\\n\\t}\\n\\n\\t\/**\\n\\t * Execute the given callback if the string is not an exact match with the given value.\\n\\t *\\n\\t * @param  string        $value\\n\\t * @param  callable      $callback\\n\\t * @param  callable|null $default\\n\\t * @return static\\n\\t *\/\\n\\tpublic function when_not_exactly( $value, ?callable $callback, ?callable $default = null ) {\\n\\t\\treturn $this->when( ! $this->exactly( $value ), $callback, $default );\\n\\t}\\n\\n\\t\/**\\n\\t * Execute the given callback if the string matches a given pattern.\\n\\t *\\n\\t * @param  string|iterable<string> $pattern\\n\\t * @param  callable                $callback\\n\\t * @param  callable|null           $default\\n\\t * @return static\\n\\t *\/\\n\\tpublic function when_is( string|iterable $pattern, ?callable $callback, ?callable $default = null ) {\\n\\t\\treturn $this->when( $this->is( $pattern ), $callback, $default );\\n\\t}\\n\\n\\t\/**\\n\\t * Execute the given callback if the string is 7 bit ASCII.\\n\\t *\\n\\t * @param  callable      $callback\\n\\t * @param  callable|null $default\\n\\t * @return static\\n\\t *\/\\n\\tpublic function when_is_ascii( ?callable $callback, ?callable $default = null ) {\\n\\t\\treturn $this->when( $this->is_ascii(), $callback, $default );\\n\\t}\\n\\n\\t\/**\\n\\t * Execute the given callback if the string is a valid UUID.\\n\\t *\\n\\t * @param  callable      $callback\\n\\t * @param  callable|null $default\\n\\t * @return static\\n\\t *\/\\n\\tpublic function when_is_uuid( ?callable $callback, ?callable $default = null ) {\\n\\t\\treturn $this->when( $this->is_uuid(), $callback, $default );\\n\\t}\\n\\n\\t\/**\\n\\t * Execute the given callback if the string starts with a given substring.\\n\\t *\\n\\t * @param  string|iterable<string> $needles\\n\\t * @param  callable                $callback\\n\\t * @param  callable|null           $default\\n\\t * @return static\\n\\t *\/\\n\\tpublic function when_starts_with( $needles, ?callable $callback, ?callable $default = null ) {\\n\\t\\treturn $this->when( $this->startsWith( $needles ), $callback, $default );\\n\\t}\\n\\n\\t\/**\\n\\t * Execute the given callback if the string matches the given pattern.\\n\\t *\\n\\t * @param  string        $pattern\\n\\t * @param  callable      $callback\\n\\t * @param  callable|null $default\\n\\t * @return static\\n\\t *\/\\n\\tpublic function when_test( $pattern, ?callable $callback, ?callable $default = null ) {\\n\\t\\treturn $this->when( $this->test( $pattern ), $callback, $default );\\n\\t}\\n\\n\\t\/**\\n\\t * Limit the number of words in a string.\\n\\t *\\n\\t * @param  int    $words\\n\\t * @param  string $end\\n\\t *\/\\n\\tpublic function words( $words = 100, string $end = '...' ): static {\\n\\t\\treturn new static( Str::words( $this->value, $words, $end ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the number of words a string contains.\\n\\t *\\n\\t * @param  string|null $characters\\n\\t *\/\\n\\tpublic function word_count( $characters = null ): int {\\n\\t\\treturn Str::word_count( $this->value, $characters );\\n\\t}\\n\\n\\t\/**\\n\\t * Wrap the string with the given strings.\\n\\t *\\n\\t * @param  string      $before\\n\\t * @param  string|null $after\\n\\t *\/\\n\\tpublic function wrap( string $before, $after = null ): static {\\n\\t\\treturn new static( Str::wrap( $this->value, $before, $after ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Dump the string.\\n\\t *\/\\n\\tpublic function dump(): static {\\n\\t\\tVarDumper::dump( $this->value );\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Dump the string and end the script.\\n\\t *\/\\n\\tpublic function dd(): never {\\n\\t\\t$this->dump();\\n\\n\\t\\texit( 1 );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the underlying string value.\\n\\t *\/\\n\\tpublic function value(): string {\\n\\t\\treturn $this->toString();\\n\\t}\\n\\n\\t\/**\\n\\t * Get the underlying string value.\\n\\t *\/\\n\\tpublic function toString(): string {\\n\\t\\treturn $this->value;\\n\\t}\\n\\n\\t\/**\\n\\t * Get the underlying string value as an integer.\\n\\t *\/\\n\\tpublic function to_integer(): int {\\n\\t\\treturn intval( $this->value );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the underlying string value as a float.\\n\\t *\/\\n\\tpublic function to_float(): float {\\n\\t\\treturn floatval( $this->value );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the underlying string value as a boolean.\\n\\t *\\n\\t * Returns true when value is \\\"1\\\", \\\"true\\\", \\\"on\\\", and \\\"yes\\\". Otherwise, returns false.\\n\\t *\/\\n\\tpublic function to_boolean(): bool {\\n\\t\\treturn filter_var( $this->value, FILTER_VALIDATE_BOOLEAN );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the underlying string value as a Carbon instance.\\n\\t *\\n\\t * @param  string|null $format\\n\\t * @param  string|null $tz\\n\\t * @return \\\\Carbon\\\\Carbon\\n\\t *\/\\n\\tpublic function to_date( $format = null, $tz = null ): ?\\\\Carbon\\\\Carbon {\\n\\t\\tif ( is_null( $format ) ) {\\n\\t\\t\\treturn Date::parse( $this->value, $tz ?: wp_timezone() );\\n\\t\\t}\\n\\n\\t\\treturn Date::createFromFormat( $format, $this->value, $tz ?: wp_timezone() );\\n\\t}\\n\\n\\t\/**\\n\\t * Convert the object to a string when JSON encoded.\\n\\t *\/\\n\\tpublic function jsonSerialize(): string {\\n\\t\\treturn $this->__toString();\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if the given offset exists.\\n\\t *\\n\\t * @param  mixed $offset\\n\\t *\/\\n\\tpublic function offsetExists( mixed $offset ): bool {\\n\\t\\treturn isset( $this->value[ $offset ] );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the value at the given offset.\\n\\t *\\n\\t * @param  mixed $offset\\n\\t *\/\\n\\tpublic function offsetGet( mixed $offset ): string {\\n\\t\\treturn $this->value[ $offset ];\\n\\t}\\n\\n\\t\/**\\n\\t * Set the value at the given offset.\\n\\t *\\n\\t * @param  mixed $offset\\n\\t * @param  mixed $value\\n\\t *\/\\n\\tpublic function offsetSet( mixed $offset, mixed $value ): void {\\n\\t\\t$this->value[ $offset ] = $value;\\n\\t}\\n\\n\\t\/**\\n\\t * Unset the value at the given offset.\\n\\t *\\n\\t * @param  mixed $offset\\n\\t *\/\\n\\tpublic function offsetUnset( mixed $offset ): void {\\n\\t\\tunset( $this->value[ $offset ] );\\n\\t}\\n\\n\\t\/**\\n\\t * Proxy dynamic properties onto methods.\\n\\t *\\n\\t * @param  string $key\\n\\t * @return mixed\\n\\t *\/\\n\\tpublic function __get( $key ) {\\n\\t\\treturn $this->{$key}();\\n\\t}\\n\\n\\t\/**\\n\\t * Get the raw string value.\\n\\t *\/\\n\\tpublic function __toString(): string {\\n\\t\\treturn $this->value;\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/class-mixed-data.php\",\"ext\":\"php\",\"size\":996,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Mixed_Data class file\\n *\\n * @package mantle-framework\\n *\/\\n\\nnamespace Mantle\\\\Support;\\n\\nuse ArrayAccess;\\nuse Mantle\\\\Contracts\\\\Support\\\\Jsonable;\\n\\n\/**\\n * Fluent class for manipulating mixed data as type-safe objects.\\n *\/\\nclass Mixed_Data implements ArrayAccess, Jsonable, \\\\JsonSerializable, \\\\Stringable {\\n\\tuse Interacts_With_Data;\\n\\n\\t\/**\\n\\t * Create a new instance of the class from mixed data.\\n\\t *\\n\\t * @param mixed $data Mixed data.\\n\\t *\/\\n\\tpublic static function of( mixed $data ): static {\\n\\t\\treturn new static( $data );\\n\\t}\\n\\n\\t\/**\\n\\t * Create a new instance of the class.\\n\\t *\\n\\t * @param mixed $value Value.\\n\\t *\/\\n\\tpublic static function create( mixed $value ): static {\\n\\t\\treturn new static( $value );\\n\\t}\\n\\n\\t\/**\\n\\t * Constructor\\n\\t *\\n\\t * @param mixed $value Value.\\n\\t * @param bool  $throw Optional. Whether to throw an exception if the value is not a compatible type.\\n\\t *\/\\n\\tpublic function __construct( mixed $value, bool $throw = false ) {\\n\\t\\t$this->throw = $throw;\\n\\t\\t$this->value = $value;\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/class-higher-order-tap-proxy.php\",\"ext\":\"php\",\"size\":671,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * This file contains the Higher_Order_Tap_Proxy class\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support;\\n\\n\/**\\n * Tap proxy.\\n *\/\\nclass Higher_Order_Tap_Proxy {\\n\\t\/**\\n\\t * Create a new tap proxy instance.\\n\\t *\\n\\t * @param mixed $target The target being tapped.\\n\\t *\/\\n\\tpublic function __construct( public mixed $target ) {}\\n\\n\\t\/**\\n\\t * Dynamically pass method calls to the target.\\n\\t *\\n\\t * @param string       $method     Method to call.\\n\\t * @param array<mixed> $parameters Params to provide to the method.\\n\\t * @return mixed\\n\\t *\/\\n\\tpublic function __call( string $method, array $parameters ) {\\n\\t\\t$this->target->{$method}( ...$parameters );\\n\\n\\t\\treturn $this->target;\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/class-higher-order-when-proxy.php\",\"ext\":\"php\",\"size\":1036,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Higher_Order_When_Proxy class file\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support;\\n\\n\/**\\n * Higher Order When Proxy\\n *\\n * Allow a higher-order proxy that can be used conditionally.\\n *\/\\nclass Higher_Order_When_Proxy {\\n\\n\\t\/**\\n\\t * Create a new proxy instance.\\n\\t *\\n\\t * @param  mixed $target The target being conditionally operated on.\\n\\t * @param  bool  $condition The condition for proxying.\\n\\t * @return void\\n\\t *\/\\n\\tpublic function __construct( protected mixed $target, protected bool $condition ) {}\\n\\n\\t\/**\\n\\t * Proxy accessing an attribute onto the target.\\n\\t *\\n\\t * @param  string $key The attribute key.\\n\\t *\/\\n\\tpublic function __get( string $key ): mixed {\\n\\t\\treturn $this->condition\\n\\t\\t\\t? $this->target->{$key}\\n\\t\\t\\t: $this->target;\\n\\t}\\n\\n\\t\/**\\n\\t * Proxy a method call on the target.\\n\\t *\\n\\t * @param  string       $method\\n\\t * @param  array<mixed> $parameters\\n\\t *\/\\n\\tpublic function __call( string $method, array $parameters ): mixed {\\n\\t\\treturn $this->condition\\n\\t\\t\\t? $this->target->{$method}( ...$parameters )\\n\\t\\t\\t: $this->target;\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/class-service-provider.php\",\"ext\":\"php\",\"size\":5575,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Service_Provider class file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support;\\n\\nuse Mantle\\\\Console\\\\Application as Console_Application;\\nuse Mantle\\\\Console\\\\Command;\\nuse Mantle\\\\Container\\\\Container;\\nuse Mantle\\\\Contracts\\\\Application;\\nuse Mantle\\\\Support\\\\Traits\\\\Hookable;\\nuse Psr\\\\Log\\\\{LoggerAwareInterface, LoggerAwareTrait};\\n\\nuse function Mantle\\\\Support\\\\Helpers\\\\collect;\\n\\n\/**\\n * Application Service Provider\\n *\/\\nabstract class Service_Provider implements LoggerAwareInterface {\\n\\tuse Hookable;\\n\\tuse LoggerAwareTrait;\\n\\n\\t\/**\\n\\t * The paths that should be published.\\n\\t *\\n\\t * @var array<class-string<Service_Provider>, string[]>\\n\\t *\/\\n\\tpublic static array $publishes = [];\\n\\n\\t\/**\\n\\t * The paths that should be published by group.\\n\\t *\\n\\t * @var array<string, string[]>\\n\\t *\/\\n\\tpublic static array $publish_tags = [];\\n\\n\\t\/**\\n\\t * The application instance.\\n\\t *\/\\n\\tprotected Application $app;\\n\\n\\t\/**\\n\\t * Commands to register.\\n\\t * Register commands through `Service_Provider::add_command()`.\\n\\t *\\n\\t * @var \\\\Mantle\\\\Console\\\\Command[]\\n\\t *\/\\n\\tprotected array $commands;\\n\\n\\t\/**\\n\\t * Create a new service provider instance.\\n\\t *\\n\\t * @param Application $app Application Instance.\\n\\t *\/\\n\\tpublic function __construct( Application $app ) {\\n\\t\\t$this->app = $app;\\n\\t}\\n\\n\\t\/**\\n\\t * Register the service provider.\\n\\t *\\n\\t * @phpstan-ignore missingType.return\\n\\t *\/\\n\\tpublic function register() {}\\n\\n\\t\/**\\n\\t * Boot the service provider.\\n\\t *\\n\\t * @phpstan-ignore missingType.return\\n\\t *\/\\n\\tpublic function boot() {}\\n\\n\\t\/**\\n\\t * Bootstrap services.\\n\\t *\/\\n\\tpublic function boot_provider(): void {\\n\\t\\tif ( isset( $this->app['log'] ) ) {\\n\\t\\t\\t$this->setLogger( $this->app['log']->driver() );\\n\\t\\t}\\n\\n\\t\\t$this->register_hooks();\\n\\t\\t$this->boot();\\n\\t}\\n\\n\\t\/**\\n\\t * Register a console command.\\n\\t *\\n\\t * @param Command[]|string[]|Command|string $command Command instance or class name to register.\\n\\t *\/\\n\\tpublic function add_command( array|string|Command|\\\\Symfony\\\\Component\\\\Console\\\\Command\\\\Command $command ): Service_Provider {\\n\\t\\tConsole_Application::starting(\\n\\t\\t\\tfn ( Console_Application $console ) => $console->resolve_commands( $command )\\n\\t\\t);\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Setup an after resolving listener, or fire immediately if already resolved.\\n\\t *\\n\\t * @param  string   $name Abstract name.\\n\\t * @param  callable $callback Callback.\\n\\t *\/\\n\\tprotected function call_after_resolving( string $name, callable $callback ): void {\\n\\t\\t$this->app->after_resolving( $name, $callback );\\n\\n\\t\\tif ( $this->app->resolved( $name ) ) {\\n\\t\\t\\t$callback( $this->app->make( $name ), $this->app );\\n\\t\\t}\\n\\t}\\n\\n\\t\/**\\n\\t * Register paths to be published by the publish command.\\n\\t *\\n\\t * @param string[]                  $paths Paths to publish.\\n\\t * @param string|array<string>|null $tags Tags to publish.\\n\\t *\/\\n\\tpublic function publishes( array $paths, $tags = null ): void {\\n\\t\\t$class = static::class;\\n\\n\\t\\tif ( ! array_key_exists( $class, static::$publishes ) ) {\\n\\t\\t\\tstatic::$publishes[ $class ] = [];\\n\\t\\t}\\n\\n\\t\\tstatic::$publishes[ $class ] = array_merge( static::$publishes[ $class ], $paths );\\n\\n\\t\\tforeach ( (array) $tags as $tag ) {\\n\\t\\t\\tif ( ! array_key_exists( $tag, static::$publish_tags ) ) {\\n\\t\\t\\t\\tstatic::$publish_tags[ $tag ] = [];\\n\\t\\t\\t}\\n\\n\\t\\t\\tstatic::$publish_tags[ $tag ] = array_merge(\\n\\t\\t\\t\\tstatic::$publish_tags[ $tag ],\\n\\t\\t\\t\\t$paths,\\n\\t\\t\\t);\\n\\t\\t}\\n\\t}\\n\\n\\t\/**\\n\\t * Get the service providers available for publishing.\\n\\t *\\n\\t * @return array<class-string<Service_Provider>>\\n\\t *\/\\n\\tpublic static function publishable_providers(): array {\\n\\t\\treturn array_keys( static::$publishes );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the groups available for publishing.\\n\\t *\\n\\t * @return string[]\\n\\t *\/\\n\\tpublic static function publishable_tags(): array {\\n\\t\\treturn array_keys( static::$publish_tags );\\n\\t}\\n\\n\\t\/**\\n\\t * Load routes from the given path.\\n\\t *\\n\\t * @param string $path Path to routes file.\\n\\t *\/\\n\\tpublic function load_routes_from( string $path ): void {\\n\\t\\trequire $path; \/\/ phpcs:ignore WordPressVIPMinimum.Files.IncludingFile.UsingVariable\\n\\t}\\n\\n\\t\/**\\n\\t * Load views from the given path.\\n\\t *\\n\\t * @param string $path Path to views directory.\\n\\t * @param string $alias Alias to register views under.\\n\\t *\/\\n\\tpublic function load_views_from( string $path, string $alias ): void {\\n\\t\\t$this->call_after_resolving(\\n\\t\\t\\t'view.loader',\\n\\t\\t\\tfn ( \\\\Mantle\\\\Http\\\\View\\\\View_Finder $finder ) => $finder->add_path( $path, $alias ),\\n\\t\\t);\\n\\t}\\n\\n\\t\/**\\n\\t * Get the paths to publish.\\n\\t *\\n\\t * Passing both a provider and a tag will return all paths that are\\n\\t * published by that provider and tag.\\n\\t *\\n\\t * @param  class-string<Service_Provider>|array<class-string<Service_Provider>>|null $providers The service provider class name.\\n\\t * @param  string|array<string>|null                                                 $tags      The tag name.\\n\\t * @return array<string, string> The paths to publish. Index is the source path, value is the destination path.\\n\\t *\/\\n\\tpublic static function paths_to_publish( array|string|null $providers = null, array|string|null $tags = null ): array {\\n\\t\\tif ( ! $providers && ! $tags ) {\\n\\t\\t\\treturn [];\\n\\t\\t}\\n\\n\\t\\t$provider_paths = collect();\\n\\t\\t$tag_paths      = collect();\\n\\n\\t\\tif ( $providers ) {\\n\\t\\t\\tforeach ( (array) $providers as $item ) {\\n\\t\\t\\t\\t$provider_paths = $provider_paths->merge( static::$publishes[ $item ] ?? [] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( $tags ) {\\n\\t\\t\\tforeach ( (array) $tags as $item ) {\\n\\t\\t\\t\\t$tag_paths = $tag_paths->merge( static::$publish_tags[ $item ] ?? [] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn match ( true ) {\\n\\t\\t\\t! empty( $providers ) && ! empty( $tags ) => $provider_paths->intersect_by_keys( $tag_paths )->all(),\\n\\t\\t\\t! empty( $providers ) => $provider_paths->all(),\\n\\t\\t\\t! empty( $tags ) => $tag_paths->all(),\\n\\t\\t\\tdefault => [],\\n\\t\\t};\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/class-object-metadata.php\",\"ext\":\"php\",\"size\":2606,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Object_Metadata class file\\n *\\n * @package mantle-framework\\n *\/\\n\\nnamespace Mantle\\\\Support;\\n\\nuse ArrayAccess;\\nuse InvalidArgumentException;\\nuse Mantle\\\\Contracts\\\\Support\\\\Jsonable;\\n\\n\/**\\n * Fluent class for retrieving object meta data as type-safe objects.\\n *\\n * Supports all meta data objects in WordPress: posts, terms, users, and comments.\\n *\/\\nclass Object_Metadata implements ArrayAccess, Jsonable, \\\\JsonSerializable, \\\\Stringable {\\n\\tuse Interacts_With_Data;\\n\\n\\t\/**\\n\\t * Retrieve metadata from the database.\\n\\t *\\n\\t * @param string|null $meta_type Meta type.\\n\\t * @param int|null    $object_id Object ID.\\n\\t * @param string|null $meta_key Meta key.\\n\\t *\/\\n\\tpublic static function of( ?string $meta_type, ?int $object_id, ?string $meta_key ): static {\\n\\t\\t$value = get_metadata( $meta_type, $object_id, $meta_key, true );\\n\\n\\t\\treturn new static( $meta_type, $object_id, $meta_key, $value );\\n\\t}\\n\\n\\t\/**\\n\\t * Create a new instance of the class.\\n\\t *\\n\\t * @param mixed $value Value.\\n\\t *\/\\n\\tpublic static function create( mixed $value ): static {\\n\\t\\treturn new static( null, null, null, $value );\\n\\t}\\n\\n\\t\/**\\n\\t * Constructor\\n\\t *\\n\\t * @param string|null $meta_type Meta type.\\n\\t * @param int|null    $object_id Object ID.\\n\\t * @param string|null $meta_key Meta key.\\n\\t * @param mixed       $value Meta value.\\n\\t * @param bool        $throw Whether to throw an exception if the metadata is not a compatible type.\\n\\t *\/\\n\\tpublic function __construct( protected readonly ?string $meta_type, protected readonly ?int $object_id, protected readonly ?string $meta_key, mixed $value, bool $throw = false ) {\\n\\t\\t$this->throw = $throw;\\n\\t\\t$this->value = $value;\\n\\t}\\n\\n\\t\/**\\n\\t * Save the meta data.\\n\\t *\\n\\t * @throws InvalidArgumentException If the object is retrieving sub-property of a metadata and the meta type is not passed.\\n\\t *\/\\n\\tpublic function save(): static {\\n\\t\\tif ( ! $this->meta_type || ! $this->object_id || ! $this->meta_key ) {\\n\\t\\t\\tthrow new InvalidArgumentException( 'Unable to save sub-property of an metadata.' );\\n\\t\\t}\\n\\n\\t\\tupdate_metadata( $this->meta_type, $this->object_id, $this->meta_key, $this->value );\\n\\n\\t\\t$this->value = get_metadata( $this->meta_type, $this->object_id, $this->meta_key, true );\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Delete the option.\\n\\t *\\n\\t * @throws InvalidArgumentException If the option is a sub-property of an option.\\n\\t *\/\\n\\tpublic function delete(): void {\\n\\t\\tif ( ! $this->meta_type || ! $this->object_id || ! $this->meta_key ) {\\n\\t\\t\\tthrow new InvalidArgumentException( 'Unable to delete option on a sub-property of an option.' );\\n\\t\\t}\\n\\n\\t\\tdelete_metadata( $this->meta_type, $this->object_id, $this->meta_key );\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/helpers\/helpers.php\",\"ext\":\"php\",\"size\":686,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Helper Functions for the Framework\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support\\\\Helpers;\\n\\n\/\/ Bail early if the helper functions are already loaded.\\nif ( function_exists( __NAMESPACE__ . '\\\\invalid_hook_removal' ) ) {\\n\\treturn;\\n}\\n\\nrequire_once __DIR__ . '\/internals.php';\\nrequire_once __DIR__ . '\/helpers-array.php';\\nrequire_once __DIR__ . '\/helpers-core-objects.php';\\nrequire_once __DIR__ . '\/helpers-environment.php';\\nrequire_once __DIR__ . '\/helpers-general.php';\\nrequire_once __DIR__ . '\/helpers-log.php';\\nrequire_once __DIR__ . '\/helpers-meta-data.php';\\nrequire_once __DIR__ . '\/helpers-rest-api.php';\\nrequire_once __DIR__ . '\/helpers-validated-hook-removal.php';\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/helpers\/helpers-log.php\",\"ext\":\"php\",\"size\":813,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * This file contains assorted log helpers.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support\\\\Helpers;\\n\\nuse Psr\\\\Log\\\\LoggerInterface;\\n\\n\/**\\n * Write some information to the log.\\n *\\n * @param  string       $message Log message.\\n * @param  array<mixed> $context Log context.\\n *\/\\nfunction info( string $message, array $context = [] ): void {\\n\\tapp( 'log' )->info( $message, $context );\\n}\\n\\n\/**\\n * Send a message to the logger.\\n *\\n * If no parameters are passed, the logger instance is returned.\\n *\\n * @param  string|null  $message Log message, optional.\\n * @param  array<mixed> $context Log context, optional.\\n *\/\\nfunction logger( ?string $message = null, array $context = [] ): ?LoggerInterface {\\n\\tif ( is_null( $message ) ) {\\n\\t\\treturn app( 'log' );\\n\\t}\\n\\n\\treturn app( 'log' )->debug( $message, $context );\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/helpers\/helpers-array.php\",\"ext\":\"php\",\"size\":4011,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Array helpers\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support\\\\Helpers;\\n\\nuse Mantle\\\\Support;\\n\\n\/**\\n * Return the default value of the given value.\\n *\\n * @param mixed $value Value to check.\\n *\/\\nfunction value( mixed $value ): mixed {\\n\\treturn $value instanceof \\\\Closure ? $value() : $value;\\n}\\n\\n\/**\\n * Get an item from an array or object using \\\"dot\\\" notation.\\n *\\n * @param  mixed                        $target Target to get from.\\n * @param  string|array<mixed>|int|null $key Key to retrieve.\\n * @param  mixed                        $default Default value.\\n *\/\\nfunction data_get( mixed $target, string|array|int|null $key, mixed $default = null ): mixed {\\n\\tif ( is_null( $key ) ) {\\n\\t\\treturn $target;\\n\\t}\\n\\n\\t$key = is_array( $key ) ? $key : explode( '.', $key );\\n\\n\\tforeach ( $key as $i => $segment ) {\\n\\t\\tunset( $key[ $i ] );\\n\\n\\t\\tif ( is_null( $segment ) ) {\\n\\t\\t\\treturn $target;\\n\\t\\t}\\n\\n\\t\\tif ( '*' === $segment ) {\\n\\t\\t\\tif ( $target instanceof \\\\Mantle\\\\Support\\\\Collection ) {\\n\\t\\t\\t\\t\\t$target = $target->all();\\n\\t\\t\\t} elseif ( ! is_array( $target ) ) {\\n\\t\\t\\t\\t\\treturn value( $default );\\n\\t\\t\\t}\\n\\n\\t\\t\\t$result = [];\\n\\n\\t\\t\\tforeach ( $target as $item ) {\\n\\t\\t\\t\\t$result[] = data_get( $item, $key );\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn in_array( '*', $key, true ) ? Support\\\\Arr::collapse( $result ) : $result;\\n\\t\\t}\\n\\n\\t\\tif ( Support\\\\Arr::accessible( $target ) && Support\\\\Arr::exists( $target, $segment ) ) {\\n\\t\\t\\t$target = $target[ $segment ];\\n\\t\\t} elseif ( is_object( $target ) && isset( $target->{$segment} ) ) {\\n\\t\\t\\t$target = $target->{$segment};\\n\\t\\t} else {\\n\\t\\t\\treturn value( $default );\\n\\t\\t}\\n\\t}\\n\\n\\treturn $target;\\n}\\n\\n\/**\\n * Set an item on an array or object using dot notation.\\n *\\n * @param  mixed               $target Array to update.\\n * @param  string|array<mixed> $key Key to set.\\n * @param  mixed               $value Value to set.\\n * @param  bool                $overwrite Flag to overwrite the existing value.\\n *\/\\nfunction data_set( mixed &$target, string|array $key, mixed $value, bool $overwrite = true ): mixed {\\n\\t$segments = is_array( $key ) ? $key : explode( '.', $key );\\n\\t$segment  = array_shift( $segments );\\n\\n\\tif ( '*' === $segment ) {\\n\\t\\tif ( ! Support\\\\Arr::accessible( $target ) ) {\\n\\t\\t\\t$target = [];\\n\\t\\t}\\n\\n\\t\\tif ( $segments !== [] ) {\\n\\t\\t\\tforeach ( $target as &$inner ) {\\n\\t\\t\\t\\tdata_set( $inner, $segments, $value, $overwrite );\\n\\t\\t\\t}\\n\\t\\t} elseif ( $overwrite ) {\\n\\t\\t\\tforeach ( $target as &$inner ) {\\n\\t\\t\\t\\t$inner = $value;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} elseif ( Support\\\\Arr::accessible( $target ) ) {\\n\\t\\tif ( $segments !== [] ) {\\n\\t\\t\\tif ( ! Support\\\\Arr::exists( $target, $segment ) ) {\\n\\t\\t\\t\\t$target[ $segment ] = [];\\n\\t\\t\\t}\\n\\n\\t\\t\\tdata_set( $target[ $segment ], $segments, $value, $overwrite );\\n\\t\\t} elseif ( $overwrite || ! Support\\\\Arr::exists( $target, $segment ) ) {\\n\\t\\t\\t$target[ $segment ] = $value;\\n\\t\\t}\\n\\t} elseif ( is_object( $target ) ) {\\n\\t\\tif ( $segments !== [] ) {\\n\\t\\t\\tif ( ! isset( $target->{$segment} ) ) {\\n\\t\\t\\t\\t$target->{$segment} = [];\\n\\t\\t\\t}\\n\\n\\t\\t\\tdata_set( $target->{$segment}, $segments, $value, $overwrite );\\n\\t\\t} elseif ( $overwrite || ! isset( $target->{$segment} ) ) {\\n\\t\\t\\t$target->{$segment} = $value;\\n\\t\\t}\\n\\t} else {\\n\\t\\t$target = [];\\n\\n\\t\\tif ( $segments !== [] ) {\\n\\t\\t\\tdata_set( $target[ $segment ], $segments, $value, $overwrite );\\n\\t\\t} elseif ( $overwrite ) {\\n\\t\\t\\t$target[ $segment ] = $value;\\n\\t\\t}\\n\\t}\\n\\n\\treturn $target;\\n}\\n\\n\/**\\n * Fill in data where it's missing.\\n *\\n * @param mixed               $target Subject to fill into.\\n * @param string|array<mixed> $key    Key(s) to fill.\\n * @param mixed               $value  Value with which to fill.\\n *\/\\nfunction data_fill( mixed &$target, string|array $key, mixed $value ): mixed {\\n\\treturn data_set( $target, $key, $value, false );\\n}\\n\\n\/**\\n * Get the first element of an array. Useful for method chaining.\\n *\\n * @param array<mixed> $array Array from which to get first element.\\n *\/\\nfunction head( array $array ): mixed {\\n\\treturn reset( $array );\\n}\\n\\n\/**\\n * Get the last element from an array.\\n *\\n * @param array<mixed> $array Array from which to get last element.\\n *\/\\nfunction last( array $array ): mixed {\\n\\treturn end( $array );\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/helpers\/internals.php\",\"ext\":\"php\",\"size\":1058,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Internal functions for helpers.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support\\\\Helpers;\\n\\n\/**\\n * Mark a hook as incorrectly removed.\\n *\\n * Internals are not subject to semantic-versioning constraints.\\n *\\n * @param array<mixed> $args Array with the arguments for {@see remove_filter()}.\\n *\/\\nfunction invalid_hook_removal( array $args ): void {\\n\\t\/\/ PHPCS does not recognize the [ $arg1, $arg2 ] syntax.\\n\\t[$hook, $callable] = $args;\\n\\n\\t$function_name = get_callable_fqn( $callable );\\n\\n\\tif ( $function_name !== '' && $function_name !== '0' ) {\\n\\t\\t\\\\_doing_it_wrong(\\n\\t\\t\\t__FUNCTION__,\\n\\t\\t\\t\\\\esc_html(\\n\\t\\t\\t\\t\\\\sprintf(\\n\\t\\t\\t\\t\\t\/* translators: 1: function name, 2: hook name *\/\\n\\t\\t\\t\\t\\t\\\\__( 'Failed to remove \\\"%1$s\\\" from %2$s!', 'mantle' ),\\n\\t\\t\\t\\t\\t$function_name,\\n\\t\\t\\t\\t\\t$hook\\n\\t\\t\\t\\t)\\n\\t\\t\\t),\\n\\t\\t\\t'',\\n\\t\\t);\\n\\t}\\n\\n\\tif ( $function_name === '' || $function_name === '0' ) {\\n\\t\\t\\\\_doing_it_wrong(\\n\\t\\t\\t__FUNCTION__,\\n\\t\\t\\t\\\\esc_html(\\n\\t\\t\\t\\t\\\\sprintf(\\n\\t\\t\\t\\t\\t\/* translators: 1: hook name *\/\\n\\t\\t\\t\\t\\t\\\\__( 'Failed to remove function from %1$s!', 'mantle' ),\\n\\t\\t\\t\\t\\t$hook\\n\\t\\t\\t\\t)\\n\\t\\t\\t),\\n\\t\\t\\t'',\\n\\t\\t);\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/helpers\/helpers-general.php\",\"ext\":\"php\",\"size\":15064,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * This file contains assorted helpers\\n *\\n * @phpcs:disable Squiz.Commenting.FunctionComment\\n *\\n * @package Mantle\\n *\/\\n\\n\/\/ phpcs:disable Squiz.Commenting.FunctionComment.MissingParamComment\\n\\nnamespace Mantle\\\\Support\\\\Helpers;\\n\\nuse Countable;\\nuse Exception;\\nuse Mantle\\\\Container\\\\Container;\\nuse Mantle\\\\Events\\\\Dispatcher;\\nuse Mantle\\\\Support\\\\Collection;\\nuse Mantle\\\\Support\\\\Higher_Order_Tap_Proxy;\\nuse Mantle\\\\Support\\\\HTML;\\nuse Mantle\\\\Support\\\\Str;\\nuse Mantle\\\\Support\\\\Stringable;\\nuse Mantle\\\\Support\\\\Uri;\\nuse Throwable;\\n\\n\/**\\n * Determine if the given value is \\\"blank\\\".\\n *\\n * @param mixed $value Value to check.\\n *\/\\nfunction blank( $value ): bool {\\n\\tif ( is_null( $value ) ) {\\n\\t\\treturn true;\\n\\t}\\n\\n\\tif ( is_string( $value ) ) {\\n\\t\\treturn trim( $value ) === '';\\n\\t}\\n\\n\\tif ( is_numeric( $value ) || is_bool( $value ) ) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\tif ( $value instanceof Countable ) {\\n\\t\\treturn count( $value ) === 0;\\n\\t}\\n\\n\\treturn empty( $value );\\n}\\n\\n\/**\\n * Get the class \\\"basename\\\" of the given object \/ class.\\n *\\n * @param string|object $class Class or object to basename.\\n *\/\\nfunction class_basename( string|object $class ): string {\\n\\t$class = is_object( $class ) ? $class::class : $class;\\n\\n\\treturn basename( str_replace( '\\\\\\\\', '\/', $class ) );\\n}\\n\\n\/**\\n * Returns all traits used by a class, its parent classes and trait of their traits.\\n *\\n * @param object|string $class Class or object to analyze.\\n * @return array<string>\\n *\/\\nfunction class_uses_recursive( string|object $class ): array {\\n\\tif ( is_object( $class ) ) {\\n\\t\\t$class = $class::class;\\n\\t}\\n\\n\\t$results = [];\\n\\n\\tforeach ( array_reverse( class_parents( $class ) ) + [ $class => $class ] as $class ) {\\n\\t\\t$results += trait_uses_recursive( $class );\\n\\t}\\n\\n\\treturn array_unique( $results );\\n}\\n\\n\/**\\n * Wrap a string in backticks.\\n *\\n * @param string $string The string.\\n * @return string $string The wrapped string.\\n *\/\\nfunction backtickit( string $string ): string {\\n\\treturn \\\"`{$string}`\\\";\\n}\\n\\n\/**\\n * Translate a callable into a readable string.\\n *\\n * Many props to Query Monitor's \\\\QM_Util::populate_callback().\\n *\\n * Internals are not subject to semantic-versioning constraints.\\n *\\n * @param mixed $callable The plugin callback.\\n * @return string The readable function name, or an empty string if untranslatable.\\n *\/\\nfunction get_callable_fqn( mixed $callable ): string {\\n\\t$function_name = '';\\n\\n\\tif ( \\\\is_string( $callable ) ) {\\n\\t\\t$function_name = $callable . '()';\\n\\t}\\n\\n\\tif ( \\\\is_array( $callable ) ) {\\n\\t\\t$class  = '';\\n\\t\\t$access = '';\\n\\n\\t\\tif ( \\\\is_object( $callable[0] ) ) {\\n\\t\\t\\t$class  = $callable[0]::class;\\n\\t\\t\\t$access = '->';\\n\\t\\t}\\n\\n\\t\\tif ( \\\\is_string( $callable[0] ) ) {\\n\\t\\t\\t$class  = $callable[0];\\n\\t\\t\\t$access = '::';\\n\\t\\t}\\n\\n\\t\\tif ( $class && $access ) {\\n\\t\\t\\t$function_name = $class . $access . $callable[1] . '()';\\n\\t\\t}\\n\\t}\\n\\n\\tif ( \\\\is_object( $callable ) ) {\\n\\t\\t$function_name = $callable::class;\\n\\n\\t\\tif ( ! ( $callable instanceof \\\\Closure ) ) {\\n\\t\\t\\t$function_name .= '->__invoke()';\\n\\t\\t}\\n\\t}\\n\\n\\treturn $function_name;\\n}\\n\\n\/**\\n * Create a collection from the given value.\\n *\\n * @template TKey of array-key = string|int\\n * @template TValue of mixed = mixed\\n *\\n * @param  \\\\Mantle\\\\Contracts\\\\Support\\\\Arrayable<TKey, TValue>|iterable<TKey, TValue>|null $value Value to convert to a collection.\\n * @return \\\\Mantle\\\\Support\\\\Collection<TKey, TValue>\\n *\/\\nfunction collect( $value = [] ): Collection {\\n\\treturn new Collection( $value );\\n}\\n\\n\/**\\n * Determine if a value is \\\"filled\\\".\\n *\\n * @param mixed $value Value to check.\\n *\/\\nfunction filled( mixed $value ): bool {\\n\\treturn ! blank( $value );\\n}\\n\\n\/**\\n * Get an item from an object using \\\"dot\\\" notation.\\n *\\n * @param object      $object Object from which to get an item.\\n * @param string|null $key Key path at which to get the value.\\n * @param mixed       $default Default value to return on failure.\\n *\\n * @return mixed\\n *\/\\nfunction object_get( $object, $key, $default = null ) {\\n\\tif ( is_null( $key ) || trim( $key ) === '' ) {\\n\\t\\treturn $object;\\n\\t}\\n\\n\\tforeach ( explode( '.', $key ) as $segment ) {\\n\\t\\tif ( ! is_object( $object ) || ! isset( $object->{$segment} ) ) {\\n\\t\\t\\treturn value( $default );\\n\\t\\t}\\n\\n\\t\\t$object = $object->{$segment};\\n\\t}\\n\\n\\treturn $object;\\n}\\n\\n\/**\\n * Replace a given pattern with each value in the array in sequentially.\\n *\\n * @param string $pattern Pattern for which to search.\\n * @param array<string>  $replacements Strings in which to replace sequentially.\\n * @param string $subject Subject in which to search\/replace.\\n *\\n * @return string\\n *\/\\nfunction preg_replace_array( $pattern, array $replacements, $subject ): ?string {\\n\\treturn preg_replace_callback(\\n\\t\\t$pattern,\\n\\t\\tfunction () use ( &$replacements ) {\\n\\t\\t\\tforeach ( $replacements as $replacement ) {\\n\\t\\t\\t\\treturn array_shift( $replacements );\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\t$subject\\n\\t);\\n}\\n\\n\/**\\n * Retry an operation a given number of times.\\n *\\n * @param int           $times Number of times to retry.\\n * @param callable      $callback Callable to try.\\n * @param int           $sleep Number of milliseconds to sleep between tries.\\n * @param callable|null $when Callable against which to check the thrown\\n *                                exception to determine if a retry should not\\n *                                occur.\\n *\\n * @return mixed\\n * @throws \\\\Exception If the callable throws an exception, it is rethrown when\\n *                    the retry limit is hit or when `$when` says so.\\n *\/\\nfunction retry( $times, callable $callback, $sleep = 0, $when = null ) {\\n\\t$attempts = 0;\\n\\n\\t\/\/ phpcs:ignore Generic.PHP.DiscourageGoto.Found\\n\\tbeginning:\\n\\t$attempts++;\\n\\t$times--;\\n\\n\\ttry {\\n\\t\\treturn $callback( $attempts );\\n\\t} catch ( Exception $e ) {\\n\\t\\tif ( $times < 1 || ( $when && ! $when( $e ) ) ) {\\n\\t\\t\\tthrow $e;\\n\\t\\t}\\n\\n\\t\\tif ( $sleep ) {\\n\\t\\t\\tusleep( $sleep * 1000 );\\n\\t\\t}\\n\\n\\t\\t\/\/ phpcs:ignore Generic.PHP.DiscourageGoto.Found\\n\\t\\tgoto beginning;\\n\\t}\\n\\n\\treturn null;\\n}\\n\\n\/**\\n * Get a new stringable object from the given string.\\n *\\n * @param string $string\\n *\/\\nfunction str( string $string = '' ): Stringable {\\n\\treturn Str::of( $string );\\n}\\n\\n\/**\\n * Alias to `str()`.\\n *\\n * @param string $string\\n *\/\\nfunction stringable( string $string = '' ): Stringable {\\n\\treturn Str::of( $string );\\n}\\n\\n\/**\\n * Create a new Uri object from the given URI string.\\n * If no URI is provided, it will capture the current request URI.\\n *\\n * @param string|null $uri The URI to create the Uri object from. Defaults to the current request URI.\\n *\/\\nfunction uri( ?string $uri = null ): Uri {\\n\\treturn $uri ? Uri::of( $uri ) : Uri::current();\\n}\\n\\n\/**\\n * Call the given Closure with the given value then return the value.\\n *\\n * @param mixed         $value Value to provide to the callback and return.\\n * @param callable|null $callback Callable to tap.\\n *\\n * @return mixed\\n *\/\\nfunction tap( $value, $callback = null ) {\\n\\tif ( is_null( $callback ) ) {\\n\\t\\treturn new Higher_Order_Tap_Proxy( $value );\\n\\t}\\n\\n\\t$callback( $value );\\n\\n\\treturn $value;\\n}\\n\\n\/**\\n * Throw the given exception if the given condition is true.\\n *\\n * @param mixed                               $condition Condition to check.\\n * @param \\\\Throwable|class-string<\\\\Throwable> $exception Exception to throw.\\n * @param array<mixed>                               ...$parameters Params to pass to a new $exception if\\n *                                         $exception is a string (classname).\\n * @throws \\\\Throwable `$exception` is thrown if `$condition` is not met.\\n *\/\\nfunction throw_if( mixed $condition, string|Throwable $exception, ...$parameters ): mixed {\\n\\tif ( $condition ) {\\n\\t\\t$e = is_string( $exception ) ? new $exception( ...$parameters ) : $exception;\\n\\n\\t\\tthrow $e;\\n\\t}\\n\\n\\treturn $condition;\\n}\\n\\n\/**\\n * Throw the given exception unless the given condition is true.\\n *\\n * @param mixed             $condition Condition to check.\\n * @param \\\\Throwable|class-string<\\\\Throwable> $exception Exception to throw.\\n * @param array<mixed>             ...$parameters Params to pass to a new $exception if\\n *                                         $exception is a string (classname).\\n *\\n * @throws \\\\Throwable `$exception` is thrown unless `$condition` is not met.\\n *\/\\nfunction throw_unless( mixed $condition, string|Throwable $exception, ...$parameters ): mixed {\\n\\tif ( ! $condition ) {\\n\\t\\t$e = is_string( $exception ) ? new $exception( ...$parameters ) : $exception;\\n\\n\\t\\tthrow $e;\\n\\t}\\n\\n\\treturn $condition;\\n}\\n\\n\/**\\n * Returns all traits used by a trait and its traits.\\n *\\n * @param class-string $trait Trait to check.\\n *\\n * @return array<string>\\n *\/\\nfunction trait_uses_recursive( string $trait ): array|false {\\n\\t$traits = class_uses( $trait );\\n\\n\\tforeach ( $traits as $trait ) {\\n\\t\\t$traits += trait_uses_recursive( $trait );\\n\\t}\\n\\n\\treturn $traits;\\n}\\n\\n\/**\\n * Transform the given value if it is present.\\n *\\n * @param mixed    $value Value to check.\\n * @param callable $callback Callable to pass `$value`.\\n * @param mixed    $default Fallback if `$value` is not filled. May be a\\n *                           callable which accepts `$value`, or it may be any\\n *                           other value which is returned directly.\\n *\\n * @return mixed|null\\n *\/\\nfunction transform( mixed $value, callable $callback, $default = null ): mixed {\\n\\tif ( filled( $value ) ) {\\n\\t\\treturn $callback( $value );\\n\\t}\\n\\n\\tif ( is_callable( $default ) ) {\\n\\t\\treturn $default( $value );\\n\\t}\\n\\n\\treturn $default;\\n}\\n\\n\/**\\n * Return the given value, optionally passed through the given callback.\\n *\\n * @param mixed         $value Value to return.\\n * @param callable|null $callback Callable to pass `$value` through.\\n *\/\\nfunction with( mixed $value, ?callable $callback = null ): mixed {\\n\\treturn is_null( $callback ) ? $value : $callback( $value );\\n}\\n\\n\/**\\n * Manage the concatenation of class names based on conditions.\\n *\\n * A port of the classnames npm package.\\n *\\n * @param mixed ...$args Class names to concatenate.\\n *\/\\nfunction classname( ...$args ): string {\\n\\t$classes = [];\\n\\n\\tforeach ( $args as $arg ) {\\n\\t\\tif ( is_string( $arg ) ) {\\n\\t\\t\\t$classes[] = $arg;\\n\\t\\t} elseif ( is_array( $arg ) ) {\\n\\t\\t\\tif ( array_is_list( $arg ) ) {\\n\\t\\t\\t\\t$classes[] = classname( ...$arg );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tforeach ( $arg as $key => $value ) {\\n\\t\\t\\t\\t\\t\/\/ If the key is numeric, it's a value. Otherwise, check if it's truthy.\\n\\t\\t\\t\\t\\tif ( is_int( $key ) ) {\\n\\t\\t\\t\\t\\t\\t$classes[] = $value;\\n\\t\\t\\t\\t\\t} elseif ( $value ) {\\n\\t\\t\\t\\t\\t\\t$classes[] = $key;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} elseif ( is_object( $arg ) ) {\\n\\t\\t\\t$classes[] = classname( ...class_uses_recursive( $arg ) );\\n\\t\\t} elseif ( is_int( $arg ) ) {\\n\\t\\t\\t$classes[] = (string) $arg;\\n\\t\\t} elseif ( is_bool( $arg ) ) {\\n\\t\\t\\t$classes[] = $arg ? 'true' : 'false';\\n\\t\\t}\\n\\t}\\n\\n\\treturn collect( $classes )->filter()->implode_str( ' ' )->trim();\\n}\\n\\n\/**\\n * Display the class names based on conditions.\\n *\\n * @param mixed ...$args Class names to concatenate.\\n *\/\\nfunction the_classnames( ...$args ): void {\\n\\techo esc_attr( classname( ...$args ) );\\n}\\n\\n\/**\\n * Create a new HTML instance.\\n *\\n * @param string $html The HTML string to test.\\n *\/\\nfunction html_string( string $html ): HTML {\\n\\treturn new HTML( $html );\\n}\\n\\n\/**\\n * Capture the output of a callback.\\n *\\n * @param callable $callback\\n *\/\\nfunction capture( callable $callback ): string {\\n\\tob_start();\\n\\t$callback();\\n\\treturn ob_get_clean();\\n}\\n\\n\/**\\n * Add a WordPress action with type-hint support.\\n *\\n * @param string   $action Action to listen to.\\n * @param callable $callback Callback to invoke.\\n * @param int      $priority\\n *\/\\nfunction add_action( string $hook, callable $callable, int $priority = 10 ): void {\\n\\tif ( ! class_exists( Dispatcher::class ) ) {\\n\\t\\t\\\\add_action( $hook, $callable, $priority, 99 );\\n\\t} else {\\n\\t\\tContainer::get_instance()->make( Dispatcher::class )->listen( $hook, $callable, $priority );\\n\\t}\\n}\\n\\n\/**\\n * Add a WordPress filter with type-hint support.\\n *\\n * @param string   $action Action to listen to.\\n * @param callable $callback Callback to invoke.\\n * @param int      $priority\\n *\/\\nfunction add_filter( string $hook, callable $callable, int $priority = 10 ): void {\\n\\tif ( ! class_exists( Dispatcher::class ) ) {\\n\\t\\t\\\\add_filter( $hook, $callable, $priority, 99 );\\n\\t} else {\\n\\t\\tContainer::get_instance()->make( Dispatcher::class )->listen( $hook, $callable, $priority );\\n\\t}\\n}\\n\\n\/**\\n * Dispatch an event and call the listeners.\\n *\\n * @param  string|object  $event Event object.\\n * @param  mixed          ...$payload Event payload.\\n *\/\\nfunction event( string|object $event, mixed ...$payload ): mixed {\\n\\treturn Container::get_instance()->make( 'events' )->dispatch( $event, ...$payload );\\n}\\n\\n\/**\\n * Fire a callback if a hook was fired or is being fired. Otherwise, defer the\\n * callback until the hook was fired.\\n *\\n * @param string $hook Hook to check for.\\n * @param callable $callable Callable to invoke.\\n * @param int $priority Hook priority.\\n *\/\\nfunction hook_callable( string $hook, callable $callable, int $priority = 10 ): void {\\n\\tif ( ! did_action( $hook ) && ! doing_action( $hook ) ) {\\n\\t\\t\\\\add_action( $hook, fn () => $callable(), $priority );\\n\\t} else {\\n\\t\\t$callable();\\n\\t}\\n}\\n\\n\/**\\n * Validates a file name and path against an allowed set of rules.\\n *\\n * A return value of `1` means the file path contains directory traversal.\\n *\\n * A return value of `3` means the file is not in the allowed files list.\\n *\\n * @see validate_file() in WordPress core.\\n *\\n * @param string   $file          File path.\\n * @param string[] $allowed_files Optional. Array of allowed files. Default empty array.\\n * @return int 0 means nothing is wrong, greater than 0 means something was wrong.\\n *\/\\nfunction validate_file( $file, $allowed_files = [] ) {\\n\\t\/\/ Proxy back to the core function if it exists, allowing Windows drive paths.\\n\\tif ( function_exists( 'validate_file' ) ) {\\n\\t\\t$retval = \\\\validate_file( $file, $allowed_files );\\n\\t\\treturn in_array( $retval, [ 0, 2 ], true ) ? 0 : $retval;\\n\\t}\\n\\n\\tif ( ! is_scalar( $file ) || '' === $file ) { \/\/ @phpstan-ignore-line function.alreadyNarrowedType\\n\\t\\treturn 0;\\n\\t}\\n\\n\\t\/\/ `..\/` on its own is not allowed:\\n\\tif ( '..\/' === $file ) {\\n\\t\\treturn 1;\\n\\t}\\n\\n\\t\/\/ More than one occurrence of `..\/` is not allowed.\\n\\tif ( preg_match_all( '#\\\\.\\\\.\/#', $file, $matches, PREG_SET_ORDER ) && ( count( $matches ) > 1 ) ) {\\n\\t\\treturn 1;\\n\\t}\\n\\n\\t\/\/ `..\/` which does not occur at the end of the path is not allowed.\\n\\tif ( str_contains( $file, '..\/' ) && '..\/' !== mb_substr( $file, -3, 3 ) ) {\\n\\t\\treturn 1;\\n\\t}\\n\\n\\t\/\/ Files not in the allowed file list are not allowed.\\n\\tif ( ! empty( $allowed_files ) && ! in_array( $file, $allowed_files, true ) ) {\\n\\t\\treturn 3;\\n\\t}\\n\\n\\t\/\/ Absolute Windows drive paths ARE allowed.\\n\\treturn 0;\\n}\\n\\n\/**\\n * Defer the execution of a function until after the response is sent to the\\n * page.\\n *\\n * When used outside of the Mantle Framework, the callback will be added to the\\n * 'shutdown' hook after sending the response to the client.\\n *\\n * @param callable $callback Callback to defer.\\n *\/\\nfunction defer( callable $callback ): void {\\n\\tif ( ! function_exists( 'app' ) ) {\\n\\t\\t\\\\add_action(\\n\\t\\t\\t'shutdown',\\n\\t\\t\\tfunction () use ( $callback ): void {\\n\\t\\t\\t\\tif ( function_exists( 'fastcgi_finish_request' ) ) {\\n\\t\\t\\t\\t\\tfastcgi_finish_request();\\n\\t\\t\\t\\t} elseif ( function_exists( 'litespeed_finish_request' ) ) {\\n\\t\\t\\t\\t\\tlitespeed_finish_request();\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t$callback();\\n\\t\\t\\t},\\n\\t\\t);\\n\\n\\t\\treturn;\\n\\t}\\n\\n\\tapp()->terminating( $callback );\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/helpers\/helpers-validated-hook-removal.php\",\"ext\":\"php\",\"size\":850,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Validated hook removal functions\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support\\\\Helpers;\\n\\n\/**\\n * Remove a function from a filter, and trigger a notice if removal fails.\\n *\\n * @param mixed ...$args Arguments for {@see remove_filter()}.\\n * @return bool Whether the function was removed.\\n *\/\\nfunction remove_filter_validated( ...$args ) {\\n\\t$result = \\\\remove_filter( ...$args );\\n\\n\\tif ( false === $result ) {\\n\\t\\tinvalid_hook_removal( $args );\\n\\t}\\n\\n\\treturn $result;\\n}\\n\\n\/**\\n * Remove a function from an action, and trigger a notice if removal fails.\\n *\\n * @param mixed ...$args Arguments for {@see remove_action()}.\\n * @return bool Whether the function was removed.\\n *\/\\nfunction remove_action_validated( ...$args ) {\\n\\t$result = \\\\remove_action( ...$args );\\n\\n\\tif ( false === $result ) {\\n\\t\\tinvalid_hook_removal( $args );\\n\\t}\\n\\n\\treturn $result;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/helpers\/helpers-rest-api.php\",\"ext\":\"php\",\"size\":4361,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * REST API schema functions\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support\\\\Helpers;\\n\\n\/**\\n * Eases writing and reading schema with defaults and requirements.\\n *\\n * Ensures that all schema have a type, description, context, and default, and\\n * that the schema keys are ordered consistently.\\n *\\n * @throws \\\\BadFunctionCallException For unmet requirements.\\n * @throws \\\\InvalidArgumentException For incorrect argument types.\\n *\\n * @param string|array<mixed> $description Attribute description or schema array.\\n * @param array<mixed>        $args        Remaining schema definition, if any.\\n * @return array<mixed> Completed schema definition.\\n *\/\\nfunction fill_rest_schema( $description, array $args = [] ): array {\\n\\t\/\/ Pass a string to use it as the description and get all the defaults.\\n\\tif ( \\\\is_string( $description ) ) {\\n\\t\\t$args['description'] = $description;\\n\\t}\\n\\n\\tif ( \\\\is_array( $description ) && ! $args ) {\\n\\t\\t$args = $description;\\n\\t}\\n\\n\\t$args = \\\\array_merge(\\n\\t\\t[\\n\\t\\t\\t'context' => [\\n\\t\\t\\t\\t'view',\\n\\t\\t\\t],\\n\\t\\t],\\n\\t\\t$args\\n\\t);\\n\\n\\tif ( empty( $args['description'] ) ) {\\n\\t\\tthrow new \\\\BadFunctionCallException( \\\\__( 'Please supply a description.', 'mantle' ) );\\n\\t}\\n\\n\\tif ( ! \\\\is_array( $args['context'] ) ) {\\n\\t\\t\/*\\n\\t\\t * This value is not cast to an array to avoid reinforcing any\\n\\t\\t * impression that the API supports a string context.\\n\\t\\t *\/\\n\\t\\tthrow new \\\\InvalidArgumentException(\\n\\t\\t\\t\\\\sprintf(\\n\\t\\t\\t\\t\/* translators: 1: $context, 2: PHP type *\/\\n\\t\\t\\t\\t\\\\__( '%1$s must be of type %2$s', 'mantle' ),\\n\\t\\t\\t\\tbacktickit( '$context' ),\\n\\t\\t\\t\\t\\\\gettype( [] )\\n\\t\\t\\t)\\n\\t\\t);\\n\\t}\\n\\n\\t\/\/ 'object' is inferred if properties are referenced.\\n\\tif ( isset( $args['properties'] ) || isset( $args['additionalProperties'] ) ) {\\n\\t\\t$args['type'] = 'object';\\n\\t}\\n\\n\\t\/\/ At last, the default.\\n\\tif ( empty( $args['type'] ) ) {\\n\\t\\t$args['type'] = 'string';\\n\\t}\\n\\n\\t$args['default'] = default_from_rest_schema( $args );\\n\\n\\tif ( 'array' === $args['type'] ) {\\n\\t\\tif ( empty( $args['items'] ) ) {\\n\\t\\t\\tthrow new \\\\BadFunctionCallException( \\\\__( 'Please supply schema for the array items.', 'mantle' ) );\\n\\t\\t}\\n\\n\\t\\tif ( empty( $args['items']['type'] ) ) {\\n\\t\\t\\tthrow new \\\\BadFunctionCallException( \\\\__( 'Please supply types for the array items.', 'mantle' ) );\\n\\t\\t}\\n\\t}\\n\\n\\tif ( 'object' === $args['type'] ) {\\n\\t\\tif ( empty( $args['properties'] ) ) {\\n\\t\\t\\t$args['additionalProperties'] = true;\\n\\t\\t} elseif ( ! isset( $args['additionalProperties'] ) ) {\\n\\t\\t\\t\/\/ 'additionalProperties' must be explicitly allowed if at least one property is declared.\\n\\t\\t\\t$args['additionalProperties'] = false;\\n\\t\\t}\\n\\t}\\n\\n\\t\/**\\n\\t * Filters the completed schema definition.\\n\\t *\\n\\t * @param array $args The schema definition array.\\n\\t *\/\\n\\t$args = apply_filters( 'mantle_fill_rest_schema', $args );\\n\\n\\t\\\\ksort( $args );\\n\\n\\treturn $args;\\n}\\n\\n\/**\\n * Get a default value for the provided schema's type and properties.\\n *\\n * @throws \\\\InvalidArgumentException For unmet requirements.\\n *\\n * @param array<mixed> $schema Schema.\\n * @return mixed Default based on the schema.\\n *\/\\nfunction default_from_rest_schema( array $schema ) {\\n\\tif ( \\\\array_key_exists( 'default', $schema ) ) {\\n\\t\\treturn $schema['default'];\\n\\t}\\n\\n\\t$default = null;\\n\\n\\tif ( empty( $schema['type'] ) ) {\\n\\t\\treturn $default;\\n\\t}\\n\\n\\tif ( \\\\is_array( $schema['type'] ) && \\\\count( $schema['type'] ) > 1 ) {\\n\\t\\tthrow new \\\\InvalidArgumentException(\\n\\t\\t\\t\/* translators: %s: 'default' *\/\\n\\t\\t\\t\\\\__( 'Please supply a `default` for schema with multiple types.', 'mantle' ),\\n\\t\\t);\\n\\t}\\n\\n\\tif ( 'string' === $schema['type'] ) {\\n\\t\\t$default = (string) $default;\\n\\t}\\n\\n\\tif ( 'integer' === $schema['type'] ) {\\n\\t\\t$default = (int) $default;\\n\\t}\\n\\n\\tif ( 'number' === $schema['type'] ) {\\n\\t\\t$default = (float) $default;\\n\\t}\\n\\n\\tif ( 'array' === $schema['type'] ) {\\n\\t\\t$default = (array) $default;\\n\\t}\\n\\n\\t\/*\\n\\t * Objects in the REST API are represented in PHP as associative arrays,\\n\\t * which are then encoded in JSON as objects. The exception is an object\\n\\t * with no properties, which must be a PHP object because empty PHP arrays\\n\\t * are encoded in JSON as arrays.\\n\\t *\/\\n\\tif ( 'object' === $schema['type'] ) {\\n\\t\\t$default = (array) $default;\\n\\n\\t\\tif ( isset( $schema['properties'] ) && \\\\is_array( $schema['properties'] ) ) {\\n\\t\\t\\tforeach ( $schema['properties'] as $property => $subschema ) {\\n\\t\\t\\t\\t$default[ $property ] = default_from_rest_schema( $subschema );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( $default === [] ) {\\n\\t\\t\\t$default = (object) $default;\\n\\t\\t}\\n\\t}\\n\\n\\treturn $default;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/helpers\/helpers-environment.php\",\"ext\":\"php\",\"size\":671,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Environment helpers.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support\\\\Helpers;\\n\\n\/**\\n * Check if we are on a hosted environment\\n *\/\\nfunction is_hosted_env(): bool {\\n\\treturn app()->is_environment( 'production' );\\n}\\n\\n\/**\\n * Check if the current environment is a local developer environment.\\n *\/\\nfunction is_local_env(): bool {\\n\\treturn app()->is_environment( 'local' );\\n}\\n\\n\/**\\n * Determine if the current request is from WP-CLI.\\n *\/\\nfunction is_wp_cli(): bool {\\n\\treturn defined( 'WP_CLI' ) && WP_CLI;\\n}\\n\\n\/**\\n * Determine if we are unit testing with Mantle.\\n *\/\\nfunction is_unit_testing(): bool {\\n\\treturn defined( 'MANTLE_IS_TESTING' ) && MANTLE_IS_TESTING;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/helpers\/helpers-meta-data.php\",\"ext\":\"php\",\"size\":1863,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Contains helpers for working with meta meta\/option data.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support\\\\Helpers;\\n\\nuse Mantle\\\\Support\\\\Mixed_Data;\\nuse Mantle\\\\Support\\\\Object_Metadata;\\nuse Mantle\\\\Support\\\\Option;\\n\\n\/**\\n * Get the value of an option from the database in a fluent and type-safe manner.\\n *\\n * @param string $option Option name.\\n * @param mixed  $default Default value. Default is null.\\n *\/\\nfunction option( string $option, mixed $default = null ): Option {\\n\\treturn Option::of( $option, $default );\\n}\\n\\n\/**\\n * Retrieve an object metadata instance for a post's meta data.\\n *\\n * @param int    $post_id Post ID.\\n * @param string $meta_key Meta key.\\n *\/\\nfunction post_meta( int $post_id, string $meta_key ): Object_Metadata {\\n\\treturn Object_Metadata::of( 'post', $post_id, $meta_key );\\n}\\n\\n\/**\\n * Retrieve an object metadata instance for a term's meta data.\\n *\\n * @param int    $term_id Term ID.\\n * @param string $meta_key Meta key.\\n *\/\\nfunction term_meta( int $term_id, string $meta_key ): Object_Metadata {\\n\\treturn Object_Metadata::of( 'term', $term_id, $meta_key );\\n}\\n\\n\/**\\n * Retrieve an object metadata instance for a user's meta data.\\n *\\n * @param int    $user_id User ID.\\n * @param string $meta_key Meta key.\\n *\/\\nfunction user_meta( int $user_id, string $meta_key ): Object_Metadata {\\n\\treturn Object_Metadata::of( 'user', $user_id, $meta_key );\\n}\\n\\n\/**\\n * Retrieve a metadata instance for a comment's meta data.\\n *\\n * @param int    $comment_id Comment ID.\\n * @param string $meta_key Meta key.\\n *\/\\nfunction comment_meta( int $comment_id, string $meta_key ): Object_Metadata {\\n\\treturn Object_Metadata::of( 'comment', $comment_id, $meta_key );\\n}\\n\\n\/**\\n * Manage and manipulate mixed data in a type-safe manner.\\n *\\n * @param mixed $value Value to be wrapped.\\n *\/\\nfunction mixed( mixed $value ): Mixed_Data {\\n\\treturn Mixed_Data::of( $value );\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/helpers\/helpers-core-objects.php\",\"ext\":\"php\",\"size\":3625,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Nullable Core Objects functions\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support\\\\Helpers;\\n\\n\/**\\n * Nullable wrapper for `get_post()`.\\n *\\n * @param int|\\\\WP_Post|null $post   Post ID or post object.\\n * @param string            $output Provided for compatibility with the\\n *                                  `get_post()` signature.\\n * @param string            $filter Type of filter to apply.\\n * @return null|\\\\WP_Post Post object or null.\\n *\/\\nfunction get_post_object( $post = null, string $output = \\\\OBJECT, string $filter = 'raw' ): ?\\\\WP_Post {\\n\\t$object = \\\\get_post( $post, $output, $filter );\\n\\n\\treturn ( $object instanceof \\\\WP_Post ) ? $object : null;\\n}\\n\\n\/**\\n * Nullable wrapper for `get_term()`.\\n *\\n * @param int|\\\\WP_Term|object $term     Term ID, database object, or term\\n *                                      object.\\n * @param string              $taxonomy Taxonomy name that $term is part of.\\n * @param string              $output   Provided for compatibility with the\\n *                                      `get_term()` signature.\\n * @param string              $filter   Type of filter to apply.\\n * @return null|\\\\WP_Term Term object or null.\\n *\/\\nfunction get_term_object( $term, string $taxonomy = '', string $output = \\\\OBJECT, string $filter = 'raw' ): ?\\\\WP_Term {\\n\\t$object = \\\\get_term( $term, $taxonomy, $output, $filter );\\n\\n\\treturn ( $object instanceof \\\\WP_Term ) ? $object : null;\\n}\\n\\n\/**\\n * Nullable wrapper for `get_term_by()`.\\n *\\n * @param string     $field    Either 'slug', 'name', 'id', or\\n *                             'term_taxonomy_id'.\\n * @param string|int $value    Search for this term value.\\n * @param string     $taxonomy Taxonomy name. Optional, if $field is\\n *                             'term_taxonomy_id'.\\n * @param string     $output   Provided for compatibility with the\\n *                             `get_term_by()` signature.\\n * @param string     $filter   Type of filter to apply.\\n * @return null|\\\\WP_Term Term object or null.\\n *\/\\nfunction get_term_object_by( string $field, $value, string $taxonomy = '', string $output = \\\\OBJECT, string $filter = 'raw' ): ?\\\\WP_Term {\\n\\t$object = \\\\get_term_by( $field, $value, $taxonomy, $output, $filter );\\n\\n\\treturn ( $object instanceof \\\\WP_Term ) ? $object : null;\\n}\\n\\n\/**\\n * Nullable wrapper for `get_comment()`.\\n *\\n * @param \\\\WP_Comment|string|int $comment Comment to retrieve.\\n * @return null|\\\\WP_Comment Comment object or null.\\n *\/\\nfunction get_comment_object( $comment ): ?\\\\WP_Comment {\\n\\t$object = \\\\get_comment( $comment );\\n\\n\\treturn ( $object instanceof \\\\WP_Comment ) ? $object : null;\\n}\\n\\n\/**\\n * Nullable wrapper for `get_userdata()`.\\n *\\n * @param \\\\WP_User|int $user User ID\/object.\\n * @return null|\\\\WP_User User object or null.\\n *\/\\nfunction get_user_object( $user ): ?\\\\WP_User {\\n\\tif ( $user instanceof \\\\WP_User ) {\\n\\t\\treturn $user;\\n\\t}\\n\\n\\t$object = \\\\get_userdata( (int) $user );\\n\\n\\treturn ( $object instanceof \\\\WP_User ) ? $object : null;\\n}\\n\\n\/**\\n * Nullable wrapper for `get_user_by()`.\\n *\\n * @param string     $field Either 'id', 'ID', 'slug', 'email', or 'login'.\\n * @param int|string $value Search for this user value.\\n * @return null|\\\\WP_User User object or null.\\n *\/\\nfunction get_user_object_by( string $field, $value ): ?\\\\WP_User {\\n\\t$object = \\\\get_user_by( $field, $value );\\n\\n\\treturn ( $object instanceof \\\\WP_User ) ? $object : null;\\n}\\n\\n\/**\\n * Nullable wrapper for `get_site()`.\\n *\\n * @param \\\\WP_Site|int|null $site Site to retrieve.\\n * @return null|\\\\WP_Site Site object or null.\\n *\/\\nfunction get_site_object( $site = null ): ?\\\\WP_Site {\\n\\t$object = \\\\get_site( $site );\\n\\n\\treturn ( $object instanceof \\\\WP_Site ) ? $object : null;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/trait-interacts-with-data.php\",\"ext\":\"php\",\"size\":9598,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Interacts_With_Data trait file\\n *\\n * phpcs:disable WordPress.NamingConventions.ValidFunctionName.MethodNameInvalid\\n *\\n * @package mantle-framework\\n *\/\\n\\nnamespace Mantle\\\\Support;\\n\\nuse Carbon\\\\Carbon;\\nuse Carbon\\\\Exceptions\\\\InvalidFormatException;\\nuse DateTimeZone;\\nuse InvalidArgumentException;\\nuse Mantle\\\\Support\\\\Traits\\\\Conditionable;\\nuse Mantle\\\\Support\\\\Traits\\\\Macroable;\\nuse Mantle\\\\Support\\\\Traits\\\\Tappable;\\n\\nuse function Mantle\\\\Support\\\\Helpers\\\\data_get;\\nuse function Mantle\\\\Support\\\\Helpers\\\\data_set;\\nuse function Mantle\\\\Support\\\\Helpers\\\\value;\\n\\n\/**\\n * Fluent class for retrieving data as type-safe objects.\\n *\/\\ntrait Interacts_With_Data {\\n\\tuse Conditionable;\\n\\tuse Macroable;\\n\\tuse Tappable;\\n\\n\\t\/**\\n\\t * Whether to throw an exception if the value is not a compatible type.\\n\\t *\/\\n\\tprotected bool $throw = false;\\n\\n\\t\/**\\n\\t * Value.\\n\\t *\/\\n\\tprotected mixed $value;\\n\\n\\t\/**\\n\\t * Create a new instance of the class.\\n\\t *\\n\\t * @param mixed $value Value.\\n\\t *\/\\n\\tabstract public static function create( mixed $value ): static;\\n\\n\\t\/**\\n\\t * Retrieve the value as a string.\\n\\t *\\n\\t * @throws InvalidArgumentException If the value is not scalar and $throw is true.\\n\\t *\/\\n\\tpublic function string(): string {\\n\\t\\tif ( ! is_scalar( $this->value ) && $this->throw ) {\\n\\t\\t\\tthrow new InvalidArgumentException( 'Value is not scalar and cannot be cast to a string.' );\\n\\t\\t}\\n\\n\\t\\treturn (string) $this->value;\\n\\t}\\n\\n\\t\/**\\n\\t * Retrieve the value as a Stringable object.\\n\\t *\/\\n\\tpublic function stringable(): Stringable {\\n\\t\\treturn new Stringable( $this->string() );\\n\\t}\\n\\n\\t\/**\\n\\t * Retrieve the value as an integer.\\n\\t *\\n\\t * @throws InvalidArgumentException If the value is not numeric and $throw is true.\\n\\t *\/\\n\\tpublic function int(): int {\\n\\t\\tif ( ! is_numeric( $this->value ) && $this->throw ) {\\n\\t\\t\\tthrow new InvalidArgumentException( 'Value is not numeric and cannot be cast to an integer.' );\\n\\t\\t}\\n\\n\\t\\treturn (int) $this->value;\\n\\t}\\n\\n\\t\/**\\n\\t * Alias for int().\\n\\t *\/\\n\\tpublic function integer(): int {\\n\\t\\treturn $this->int();\\n\\t}\\n\\n\\t\/**\\n\\t * Retrieve the value as a float.\\n\\t *\\n\\t * @throws InvalidArgumentException If the value is not numeric and $throw is true.\\n\\t *\/\\n\\tpublic function float(): float {\\n\\t\\tif ( ! is_numeric( $this->value ) && $this->throw ) {\\n\\t\\t\\tthrow new InvalidArgumentException( 'Value is not numeric and cannot be cast to a float.' );\\n\\t\\t}\\n\\n\\t\\treturn (float) $this->value;\\n\\t}\\n\\n\\t\/**\\n\\t * Retrieve the value as a boolean.\\n\\t *\/\\n\\tpublic function bool(): bool {\\n\\t\\tif ( is_bool( $this->value ) ) {\\n\\t\\t\\treturn $this->value;\\n\\t\\t}\\n\\n\\t\\tif ( function_exists( 'wp_validate_boolean' ) ) {\\n\\t\\t\\treturn wp_validate_boolean( $this->value );\\n\\t\\t}\\n\\n\\t\\tif ( is_string( $this->value ) && 'false' === strtolower( $this->value ) ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\treturn (bool) $this->value;\\n\\t}\\n\\n\\t\/**\\n\\t * Check if the value is truthy.\\n\\t *\\n\\t * \\\"truthy\\\" means that the value will evaluate to be \\\"true\\\" when used in an if\\n\\t * statement. For example, 0 or '0' will evaluate to false, while '1', 'true',\\n\\t * or 'a random string' will evaluate to true.\\n\\t *\/\\n\\tpublic function truthy(): bool {\\n\\t\\treturn (bool) $this->value;\\n\\t}\\n\\n\\t\/**\\n\\t * Alias for bool().\\n\\t *\/\\n\\tpublic function boolean(): bool {\\n\\t\\treturn $this->bool();\\n\\t}\\n\\n\\t\/**\\n\\t * Retrieve the value as an array.\\n\\t *\\n\\t * @return array<mixed>\\n\\t *\/\\n\\tpublic function array(): array {\\n\\t\\treturn (array) $this->value;\\n\\t}\\n\\n\\t\/**\\n\\t * Retrieve the value as a collection.\\n\\t *\/\\n\\tpublic function collection(): Collection {\\n\\t\\treturn new Collection( $this->value );\\n\\t}\\n\\n\\t\/**\\n\\t * Alias for collection().\\n\\t *\/\\n\\tpublic function collect(): Collection {\\n\\t\\treturn $this->collection();\\n\\t}\\n\\n\\t\/**\\n\\t * Retrieve the value as a Carbon instance.\\n\\t *\\n\\t * @param string|null                  $format Date format.\\n\\t * @param DateTimeZone|string|int|null $timezone Timezone.\\n\\t *\/\\n\\tpublic function date( ?string $format = null, DateTimeZone|string|int|null $timezone = null ): ?Carbon {\\n\\t\\tif ( $this->is_empty() ) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\tif ( $format ) {\\n\\t\\t\\treturn Carbon::createFromFormat( $format, $this->string(), $timezone );\\n\\t\\t}\\n\\n\\t\\ttry {\\n\\t\\t\\treturn Carbon::parse( $this->string(), $timezone );\\n\\t\\t} catch ( InvalidFormatException ) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t}\\n\\n\\t\/**\\n\\t * Retrieve the value as an object.\\n\\t *\/\\n\\tpublic function object(): object {\\n\\t\\treturn (object) $this->value;\\n\\t}\\n\\n\\t\/**\\n\\t * Check if the value is empty.\\n\\t *\/\\n\\tpublic function is_empty(): bool {\\n\\t\\treturn empty( $this->value );\\n\\t}\\n\\n\\t\/**\\n\\t * Check if the value is not empty.\\n\\t *\/\\n\\tpublic function is_not_empty(): bool {\\n\\t\\treturn ! $this->is_empty();\\n\\t}\\n\\n\\t\/**\\n\\t * Check if the value is null.\\n\\t *\/\\n\\tpublic function is_null(): bool {\\n\\t\\treturn null === $this->value;\\n\\t}\\n\\n\\t\/**\\n\\t * Check if the value is not null.\\n\\t *\/\\n\\tpublic function is_not_null(): bool {\\n\\t\\treturn ! $this->is_null();\\n\\t}\\n\\n\\t\/**\\n\\t * Check if the value is a specific type.\\n\\t *\\n\\t * @param string $type Type to check.\\n\\t *\/\\n\\tpublic function is_type( string $type ): bool {\\n\\t\\treturn gettype( $this->value ) === $type;\\n\\t}\\n\\n\\t\/**\\n\\t * Check if the value is not a specific type.\\n\\t *\\n\\t * @param string $type Type to check.\\n\\t *\/\\n\\tpublic function is_not_type( string $type ): bool {\\n\\t\\treturn ! $this->is_type( $type );\\n\\t}\\n\\n\\t\/**\\n\\t * Check if the value is an array.\\n\\t *\/\\n\\tpublic function is_array(): bool {\\n\\t\\treturn is_array( $this->value );\\n\\t}\\n\\n\\t\/**\\n\\t * Check if the value is not an array.\\n\\t *\/\\n\\tpublic function is_not_array(): bool {\\n\\t\\treturn ! $this->is_array();\\n\\t}\\n\\n\\t\/**\\n\\t * Check if the value is an object.\\n\\t *\/\\n\\tpublic function is_object(): bool {\\n\\t\\treturn is_object( $this->value );\\n\\t}\\n\\n\\t\/**\\n\\t * Check if the value is not an object.\\n\\t *\/\\n\\tpublic function is_not_object(): bool {\\n\\t\\treturn ! $this->is_object();\\n\\t}\\n\\n\\t\/**\\n\\t * Retrieve the raw value of the option.\\n\\t *\/\\n\\tpublic function value(): mixed {\\n\\t\\treturn $this->value;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the option value.\\n\\t *\\n\\t * @param mixed $value Option value.\\n\\t *\/\\n\\tpublic function set( mixed $value ): void {\\n\\t\\t$this->value = $value;\\n\\t}\\n\\n\\t\/**\\n\\t * Dump the value.\\n\\t *\/\\n\\tpublic function dump(): static {\\n\\t\\tdump( $this->value );\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Dump the value and exit.\\n\\t *\/\\n\\tpublic function dd(): never {\\n\\t\\tdd( $this->value );\\n\\t}\\n\\n\\t\/**\\n\\t * Set whether to throw an exception if the value is not a compatible type.\\n\\t *\\n\\t * @param bool $throw Whether to throw an exception.\\n\\t *\/\\n\\tpublic function throw( bool $throw = true ): static {\\n\\t\\t$this->throw = $throw;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set whether to throw an exception if the condition is met.\\n\\t *\\n\\t * @param (callable(): bool)|bool $condition Condition to check.\\n\\t *\/\\n\\tpublic function throw_if( callable|bool $condition ): static {\\n\\t\\t$this->throw = (bool) value( $condition );\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Retrieve a sub-property from an array value.\\n\\t *\\n\\t * @throws InvalidArgumentException If the value is not an array and $throw is true.\\n\\t *\\n\\t * @param string $property Property name. Supports dot notation.\\n\\t * @param mixed  $default Default value. Default is null.\\n\\t *\/\\n\\tpublic function get( string $property, mixed $default = null ): static {\\n\\t\\tif ( ! $this->is_array() && ! $this->is_object() && $this->throw ) {\\n\\t\\t\\tthrow new InvalidArgumentException( 'Value is not an array or object and cannot retrieve a sub-property.' );\\n\\t\\t}\\n\\n\\t\\treturn static::create( data_get( $this->value, $property, $default ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Check if a property or a set of properties exists in the value.\\n\\t *\\n\\t * @param string ...$property Property name. Supports dot notation.\\n\\t *\/\\n\\tpublic function has( string ...$property ): bool {\\n\\t\\tforeach ( $property as $prop ) {\\n\\t\\t\\tif ( $this->get( $prop )->is_empty() ) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\\n\\n\\t\/**\\n\\t * Check if a property or a set of properties is missing in the value.\\n\\t *\\n\\t * @param string ...$property Property name. Supports dot notation.\\n\\t *\/\\n\\tpublic function missing( string ...$property ): bool {\\n\\t\\treturn ! $this->has( ...$property );\\n\\t}\\n\\n\\t\/**\\n\\t * Check if any of the properties exist in the value.\\n\\t *\\n\\t * @param string ...$property Property name. Supports dot notation.\\n\\t *\/\\n\\tpublic function has_any( string ...$property ): bool {\\n\\t\\tforeach ( $property as $prop ) {\\n\\t\\t\\tif ( ! $this->get( $prop )->is_empty() ) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\t\/**\\n\\t * Convert the value to its JSON representation.\\n\\t *\\n\\t * @param int $options json_encode() options.\\n\\t *\/\\n\\tpublic function to_json( $options = 0 ): string {\\n\\t\\treturn json_encode( $this->value, $options ); \/\/ phpcs:ignore WordPress.WP.AlternativeFunctions.json_encode_json_encode\\n\\t}\\n\\n\\t\/**\\n\\t * Convert the value to its JSON representation.\\n\\t *\/\\n\\tpublic function jsonSerialize(): mixed {\\n\\t\\treturn $this->value;\\n\\t}\\n\\n\\t\/**\\n\\t * Convert the value to its string representation.\\n\\t *\/\\n\\tpublic function __toString(): string {\\n\\t\\treturn $this->string();\\n\\t}\\n\\n\\t\/**\\n\\t * Check if a property exists in a value.\\n\\t *\\n\\t * @param mixed $offset\\n\\t *\/\\n\\tpublic function offsetExists( mixed $offset ): bool {\\n\\t\\treturn '__not_found__' !== $this->get( $offset, '__not_found__' )->value;\\n\\t}\\n\\n\\t\/**\\n\\t * Retrieve an offset from the value.\\n\\t *\\n\\t * @param mixed $offset Offset name.\\n\\t *\/\\n\\tpublic function offsetGet( mixed $offset ): mixed {\\n\\t\\treturn data_get( $this->value, $offset );\\n\\t}\\n\\n\\t\/**\\n\\t * Set an offset in the value.\\n\\t *\\n\\t * @param mixed $offset Offset name.\\n\\t * @param mixed $value value.\\n\\t *\/\\n\\tpublic function offsetSet( mixed $offset, mixed $value ): void {\\n\\t\\t$data = $this->value;\\n\\n\\t\\tdata_set( $data, $offset, $value );\\n\\n\\t\\t$this->set( $data );\\n\\t}\\n\\n\\t\/**\\n\\t * Unset an offset in the value.\\n\\t *\\n\\t * @throws InvalidArgumentException If the value is immutable.\\n\\t *\\n\\t * @param mixed $offset Offset name.\\n\\t *\/\\n\\tpublic function offsetUnset( mixed $offset ): void {\\n\\t\\t$data = $this->value;\\n\\n\\t\\tunset( $data[ $offset ] );\\n\\n\\t\\t$this->set( $data );\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/html\/trait-assertions.php\",\"ext\":\"php\",\"size\":2331,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Assertions trait file\\n *\\n * phpcs:disable WordPress.NamingConventions.ValidFunctionName.MethodNameInvalid\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support\\\\HTML;\\n\\nuse PHPUnit\\\\Framework\\\\Assert;\\n\\n\/**\\n * Assertions for the HTML class.\\n *\\n * @mixin \\\\Mantle\\\\Support\\\\HTML\\n *\/\\ntrait Assertions {\\n\\t\/**\\n\\t * Assert that the node has all of the specified classes.\\n\\t *\\n\\t * @param string ...$class Class names.\\n\\t *\/\\n\\tpublic function assertNodeHasClass( string ...$class ): static {\\n\\t\\tAssert::assertTrue( $this->has_class( ...$class ), sprintf(\\n\\t\\t\\t'Failed asserting that the node has class(es): %s',\\n\\t\\t\\timplode( ', ', $class )\\n\\t\\t) );\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Assert that the node has any of the specified classes.\\n\\t *\\n\\t * @param string ...$class Class names.\\n\\t *\/\\n\\tpublic function assertNodeHasAnyClass( string ...$class ): static {\\n\\t\\tAssert::assertTrue( $this->has_any_class( ...$class ), sprintf(\\n\\t\\t\\t'Failed asserting that the node has any of the class(es): %s',\\n\\t\\t\\timplode( ', ', $class )\\n\\t\\t) );\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Assert that the current filter has the specified number of nodes.\\n\\t *\\n\\t * @param int|null $count Expected number of nodes. If null, only checks if any nodes exist.\\n\\t *\/\\n\\tpublic function assertHasNodes( ?int $count = null ): static {\\n\\t\\tif ( null === $count ) {\\n\\t\\t\\tAssert::assertTrue( $this->count() > 0, 'Failed asserting that the node has children.' );\\n\\t\\t} else {\\n\\t\\t\\tAssert::assertEquals( $count, $this->count(), sprintf(\\n\\t\\t\\t\\t'Failed asserting that the node has %d children, found %d.',\\n\\t\\t\\t\\t$count,\\n\\t\\t\\t\\t$this->count()\\n\\t\\t\\t) );\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Assert that the node has children matching the specified selector.\\n\\t *\\n\\t * @param string|null $selector CSS selector to match children against.\\n\\t * @param int|null    $count    Expected number of children. If null, only checks if any children exist.\\n\\t *\/\\n\\tpublic function assertHasChildren( ?string $selector = null, ?int $count = null ): static {\\n\\t\\tif ( null === $count ) {\\n\\t\\t\\tAssert::assertTrue( count( $this->children( $selector ) ) > 0, 'Failed asserting that the node has children.' );\\n\\t\\t} else {\\n\\t\\t\\tAssert::assertEquals( $count, count( $this->children( $selector ) ), sprintf(\\n\\t\\t\\t\\t'Failed asserting that the node has %d children, found %d.',\\n\\t\\t\\t\\t$count,\\n\\t\\t\\t\\tcount( $this->children( $selector ) )\\n\\t\\t\\t) );\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/registration\/class-post-type-arguments.php\",\"ext\":\"php\",\"size\":15997,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Post_Type_Arguments class file\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support\\\\Registration;\\n\\nuse Mantle\\\\Contracts\\\\Support\\\\Arrayable;\\nuse Mantle\\\\Support\\\\Str;\\nuse Mantle\\\\Support\\\\Traits\\\\Makeable;\\n\\nuse function Mantle\\\\Support\\\\Helpers\\\\collect;\\n\\n\/**\\n * Fluent interface for creating arguments to register a post type.\\n *\/\\nclass Post_Type_Arguments implements Arrayable {\\n\\tuse Makeable;\\n\\n\\t\/**\\n\\t * Arguments to register the post with.\\n\\t *\\n\\t * @var array<string, mixed>\\n\\t *\/\\n\\tprotected array $arguments = [];\\n\\n\\t\/**\\n\\t * Get the instance as an array.\\n\\t *\\n\\t * @return array<string, mixed>\\n\\t *\/\\n\\tpublic function to_array(): array {\\n\\t\\treturn $this->arguments;\\n\\t}\\n\\n\\t\/**\\n\\t * Get all the arguments.\\n\\t *\\n\\t * @return array<string, mixed>\\n\\t *\/\\n\\tpublic function all(): array {\\n\\t\\treturn $this->arguments;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the label for the post type.\\n\\t *\\n\\t * @param string      $singular The singular label for the post type.\\n\\t * @param string|null $plural The plural label for the post type. Optional.\\n\\t *\/\\n\\tpublic function label( string $singular, ?string $plural = null ): static {\\n\\t\\tif ( ! isset( $this->arguments['labels'] ) || ! is_array( $this->arguments['labels'] ) ) {\\n\\t\\t\\t$this->arguments['labels'] = [];\\n\\t\\t}\\n\\n\\t\\tif ( ! $plural ) {\\n\\t\\t\\t$plural = Str::plural( $singular );\\n\\t\\t}\\n\\n\\t\\t$this->arguments['labels'] = array_merge(\\n\\t\\t\\t$this->arguments['labels'],\\n\\t\\t\\t[\\n\\t\\t\\t\\t'name'                     => $plural,\\n\\t\\t\\t\\t'singular_name'            => $singular,\\n\\t\\t\\t\\t\/* translators: %s: Singular post type name. *\/\\n\\t\\t\\t\\t'add_new'                  => sprintf( __( 'Add New %s', 'mantle' ), $singular ),\\n\\t\\t\\t\\t\/* translators: %s: Singular post type name. *\/\\n\\t\\t\\t\\t'add_new_item'             => sprintf( __( 'Add New %s', 'mantle' ), $singular ),\\n\\t\\t\\t\\t\/* translators: %s: Singular post type name. *\/\\n\\t\\t\\t\\t'edit_item'                => sprintf( __( 'Edit %s', 'mantle' ), $singular ),\\n\\t\\t\\t\\t\/* translators: %s: Singular post type name. *\/\\n\\t\\t\\t\\t'new_item'                 => sprintf( __( 'New %s', 'mantle' ), $singular ),\\n\\t\\t\\t\\t\/* translators: %s: Singular post type name. *\/\\n\\t\\t\\t\\t'view_item'                => sprintf( __( 'View %s', 'mantle' ), $singular ),\\n\\t\\t\\t\\t\/* translators: %s: Plural post type name. *\/\\n\\t\\t\\t\\t'view_items'               => sprintf( __( 'View %s', 'mantle' ), $plural ),\\n\\t\\t\\t\\t\/* translators: %s: Plural post type name. *\/\\n\\t\\t\\t\\t'search_items'             => sprintf( __( 'Search %s', 'mantle' ), $plural ),\\n\\t\\t\\t\\t\/* translators: %s: Plural post type name. *\/\\n\\t\\t\\t\\t'not_found'                => sprintf( __( 'No %s found.', 'mantle' ), strtolower( $plural ) ),\\n\\t\\t\\t\\t\/* translators: %s: Plural post type name. *\/\\n\\t\\t\\t\\t'not_found_in_trash'       => sprintf( __( 'No %s found in Trash.', 'mantle' ), strtolower( $plural ) ),\\n\\t\\t\\t\\t'parent_item_colon'        => __( 'Parent Item:', 'mantle' ),\\n\\t\\t\\t\\t\/* translators: %s: Plural post type name. *\/\\n\\t\\t\\t\\t'all_items'                => sprintf( __( 'All %s', 'mantle' ), $plural ),\\n\\t\\t\\t\\t\/* translators: %s: Singular post type name. *\/\\n\\t\\t\\t\\t'archives'                 => sprintf( __( '%s Archives', 'mantle' ), $singular ),\\n\\t\\t\\t\\t\/* translators: %s: Singular post type name. *\/\\n\\t\\t\\t\\t'attributes'               => sprintf( __( '%s Attributes', 'mantle' ), $singular ),\\n\\t\\t\\t\\t\/* translators: %s: Singular post type name. *\/\\n\\t\\t\\t\\t'insert_into_item'         => sprintf( __( 'Insert into %s', 'mantle' ), strtolower( $singular ) ),\\n\\t\\t\\t\\t\/* translators: %s: Singular post type name. *\/\\n\\t\\t\\t\\t'uploaded_to_this_item'    => sprintf( __( 'Uploaded to this %s', 'mantle' ), strtolower( $singular ) ),\\n\\t\\t\\t\\t'featured_image'           => __( 'Featured Image', 'mantle' ),\\n\\t\\t\\t\\t'set_featured_image'       => __( 'Set featured image', 'mantle' ),\\n\\t\\t\\t\\t'remove_featured_image'    => __( 'Remove featured image', 'mantle' ),\\n\\t\\t\\t\\t'use_featured_image'       => __( 'Use as featured image', 'mantle' ),\\n\\t\\t\\t\\t'menu_name'                => $plural,\\n\\t\\t\\t\\t\/* translators: %s: Singular Post type name. *\/\\n\\t\\t\\t\\t'filter_items_list'        => sprintf( __( 'Filter %s list', 'mantle' ), strtolower( $plural ) ),\\n\\t\\t\\t\\t'filter_by_date'           => __( 'Filter by date', 'mantle' ),\\n\\t\\t\\t\\t\/* translators: %s: Plural post type name. *\/\\n\\t\\t\\t\\t'items_list_navigation'    => sprintf( __( '%s list navigation', 'mantle' ), $plural ),\\n\\t\\t\\t\\t\/* translators: %s: Plural post type name. *\/\\n\\t\\t\\t\\t'items_list'               => sprintf( __( '%s list', 'mantle' ), $plural ),\\n\\t\\t\\t\\t\/* translators: %s: Singular post type name. *\/\\n\\t\\t\\t\\t'item_published'           => sprintf( __( '%s published.', 'mantle' ), $singular ),\\n\\t\\t\\t\\t\/* translators: %s: Singular post type name. *\/\\n\\t\\t\\t\\t'item_published_privately' => sprintf( __( '%s published privately.', 'mantle' ), $singular ),\\n\\t\\t\\t\\t\/* translators: %s: Singular post type name. *\/\\n\\t\\t\\t\\t'item_reverted_to_draft'   => sprintf( __( '%s reverted to draft.', 'mantle' ), $singular ),\\n\\t\\t\\t\\t\/* translators: %s: Singular post type name. *\/\\n\\t\\t\\t\\t'item_trashed'             => sprintf( __( '%s trashed.', 'mantle' ), $singular ),\\n\\t\\t\\t\\t\/* translators: %s: Singular post type name. *\/\\n\\t\\t\\t\\t'item_scheduled'           => sprintf( __( '%s scheduled.', 'mantle' ), $singular ),\\n\\t\\t\\t\\t\/* translators: %s: Singular post type name. *\/\\n\\t\\t\\t\\t'item_updated'             => sprintf( __( '%s updated.', 'mantle' ), $singular ),\\n\\t\\t\\t\\t\/* translators: %s: Singular post type name. *\/\\n\\t\\t\\t\\t'item_link'                => sprintf( __( '%s Link', 'mantle' ), $singular ),\\n\\t\\t\\t\\t\/* translators: %s: Singular post type name. *\/\\n\\t\\t\\t\\t'item_link_description'    => sprintf( __( 'A link to a %s.', 'mantle' ), strtolower( $singular ) ),\\n\\t\\t\\t],\\n\\t\\t);\\n\\n\\t\\t$this->arguments['labels']['name'] = $plural;\\n\\n\\t\\t$this->arguments['labels']['singular_name'] = $singular;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set a specific label for the post type.\\n\\t *\\n\\t * @see get_post_type_labels()\\n\\t *\\n\\t * @param string|array<string, string> $key The key for the label or an array of labels.\\n\\t * @param string                       $value The value for the label.\\n\\t *\/\\n\\tpublic function labels( array|string $key, ?string $value = null ): static {\\n\\t\\tif ( is_array( $key ) ) {\\n\\t\\t\\t$this->arguments['labels'] = array_merge( $this->arguments['labels'], $key );\\n\\n\\t\\t\\treturn $this;\\n\\t\\t}\\n\\n\\t\\tif ( $value ) {\\n\\t\\t\\t$this->arguments['labels'][ $key ] = $value;\\n\\t\\t} else {\\n\\t\\t\\tunset( $this->arguments['labels'][ $key ] );\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the description for the post type.\\n\\t *\\n\\t * @param string $description The description for the post type.\\n\\t *\/\\n\\tpublic function description( string $description ): static {\\n\\t\\t$this->arguments['description'] = $description;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the public argument for the post type.\\n\\t *\\n\\t * @param bool $public Whether the post type is public.\\n\\t *\/\\n\\tpublic function public( bool $public = true ): static {\\n\\t\\t$this->arguments['public'] = $public;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the hierarchical argument for the post type.\\n\\t *\\n\\t * @param bool $hierarchical Whether the post type is hierarchical.\\n\\t *\/\\n\\tpublic function hierarchical( bool $hierarchical = true ): static {\\n\\t\\t$this->arguments['hierarchical'] = $hierarchical;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the exclude_from_search argument for the post type.\\n\\t *\\n\\t * @param bool $exclude_from_search Whether to exclude from search.\\n\\t *\/\\n\\tpublic function exclude_from_search( bool $exclude_from_search = true ): static {\\n\\t\\t$this->arguments['exclude_from_search'] = $exclude_from_search;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the publicly_queryable argument for the post type.\\n\\t *\\n\\t * @param bool $publicly_queryable Whether the post type is publicly queryable.\\n\\t *\/\\n\\tpublic function publicly_queryable( bool $publicly_queryable = true ): static {\\n\\t\\t$this->arguments['publicly_queryable'] = $publicly_queryable;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the show_ui argument for the post type.\\n\\t *\\n\\t * @param bool $show_ui Whether to show the UI for the post type.\\n\\t *\/\\n\\tpublic function show_ui( bool $show_ui = true ): static {\\n\\t\\t$this->arguments['show_ui'] = $show_ui;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the show_in_menu argument for the post type.\\n\\t *\\n\\t * @param bool|string $show_in_menu Whether to show in menu.\\n\\t *\/\\n\\tpublic function show_in_menu( bool|string $show_in_menu = true ): static {\\n\\t\\t$this->arguments['show_in_menu'] = $show_in_menu;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the show_in_admin_bar argument for the post type.\\n\\t *\\n\\t * @param bool $show_in_admin_bar Whether to show in admin bar.\\n\\t *\/\\n\\tpublic function show_in_admin_bar( bool $show_in_admin_bar = true ): static {\\n\\t\\t$this->arguments['show_in_admin_bar'] = $show_in_admin_bar;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the menu position argument for the post type.\\n\\t *\\n\\t * @param int|null $menu_position\\n\\t *\/\\n\\tpublic function menu_position( ?int $menu_position ): static {\\n\\t\\t$this->arguments['menu_position'] = $menu_position;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the menu_icon argument for the post type.\\n\\t *\\n\\t * @param string $menu_icon The menu icon for the post type.\\n\\t *\/\\n\\tpublic function menu_icon( string $menu_icon ): static {\\n\\t\\t$this->arguments['menu_icon'] = $menu_icon;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the show_in_nav_menus argument for the post type.\\n\\t *\\n\\t * @param bool $show_in_nav_menus Whether to show in nav menus.\\n\\t *\/\\n\\tpublic function show_in_nav_menus( bool $show_in_nav_menus = true ): static {\\n\\t\\t$this->arguments['show_in_nav_menus'] = $show_in_nav_menus;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the show_in_rest argument for the post type.\\n\\t *\\n\\t * @param bool $show_in_rest Whether to show in REST.\\n\\t *\/\\n\\tpublic function show_in_rest( bool $show_in_rest = true ): static {\\n\\t\\t$this->arguments['show_in_rest'] = $show_in_rest;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the rest_base argument for the post type.\\n\\t *\\n\\t * @param string $rest_base The REST base for the post type.\\n\\t *\/\\n\\tpublic function rest_base( string $rest_base ): static {\\n\\t\\t$this->arguments['rest_base'] = $rest_base;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the rest_namespace argument for the post type.\\n\\t *\\n\\t * @param string $rest_namespace The REST namespace for the post type.\\n\\t *\/\\n\\tpublic function rest_namespace( string $rest_namespace ): static {\\n\\t\\t$this->arguments['rest_namespace'] = $rest_namespace;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the rest_controller_class argument for the post type.\\n\\t *\\n\\t * @param string $rest_controller_class The REST controller class for the post type.\\n\\t *\/\\n\\tpublic function rest_controller_class( string $rest_controller_class ): static {\\n\\t\\t$this->arguments['rest_controller_class'] = $rest_controller_class;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the capability_type argument for the post type.\\n\\t *\\n\\t * @param string|array{0: string, 1: string} $capability_type The capability type for the post type.\\n\\t *\/\\n\\tpublic function capability_type( string|array $capability_type ): static {\\n\\t\\t$this->arguments['capability_type'] = $capability_type;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Array of capabilities for this post type. $capability_type is used as a\\n\\t * base to construct capabilities by default.\\n\\t *\\n\\t * @see get_post_type_capabilities()\\n\\t *\\n\\t * @param array<string, string> $capabilities Array of capabilities for this post type.\\n\\t *\/\\n\\tpublic function capabilities( array $capabilities ): static {\\n\\t\\t$this->arguments['capabilities'] = $capabilities;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the map_meta_cap argument for the post type.\\n\\t *\\n\\t * @param bool $map_meta_cap Whether to map meta capabilities.\\n\\t *\/\\n\\tpublic function map_meta_cap( bool $map_meta_cap = true ): static {\\n\\t\\t$this->arguments['map_meta_cap'] = $map_meta_cap;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the supports argument for the post type.\\n\\t *\\n\\t * @param array<string> $supports Array of features the post type supports.\\n\\t *\/\\n\\tpublic function supports( array $supports ): static {\\n\\t\\t$this->arguments['supports'] = $supports;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set a default set of supports for the post type.\\n\\t *\\n\\t * @param array<string> $except Array of features to exclude from the default set.\\n\\t *\/\\n\\tpublic function default_supports( array $except = [] ): static {\\n\\t\\t$this->arguments['supports'] = collect( $this->arguments['supports'] ?? [] )\\n\\t\\t\\t->merge( [ 'title', 'editor', 'author', 'thumbnail', 'excerpt', 'custom-fields', 'comments', 'revisions' ] )\\n\\t\\t\\t->unique()\\n\\t\\t\\t->reject( fn ( string $value ) => in_array( $value, $except, true ) )\\n\\t\\t\\t->values()\\n\\t\\t\\t->all();\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Add a support feature to the post type.\\n\\t *\\n\\t * @param string $name The name of the support feature.\\n\\t *\/\\n\\tpublic function add_support( string $name ): static {\\n\\t\\tif ( ! isset( $this->arguments['supports'] ) || ! is_array( $this->arguments['supports'] ) ) {\\n\\t\\t\\t$this->arguments['supports'] = [];\\n\\t\\t}\\n\\n\\t\\tif ( ! in_array( $name, $this->arguments['supports'], true ) ) {\\n\\t\\t\\t$this->arguments['supports'][] = $name;\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Remove a support feature to the post type.\\n\\t *\\n\\t * @param string $name The name of the support feature.\\n\\t *\/\\n\\tpublic function remove_support( string $name ): static {\\n\\t\\tif ( ! isset( $this->arguments['supports'] ) || ! is_array( $this->arguments['supports'] ) ) {\\n\\t\\t\\treturn $this;\\n\\t\\t}\\n\\n\\t\\t$this->arguments['supports'] = collect( $this->arguments['supports'] )\\n\\t\\t\\t->reject( fn( $value ) => $value === $name )\\n\\t\\t\\t->values()\\n\\t\\t\\t->all();\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the taxonomies argument for the post type.\\n\\t *\\n\\t * @param array<string> $taxonomies Array of taxonomies for the post type.\\n\\t *\/\\n\\tpublic function taxonomies( array $taxonomies ): static {\\n\\t\\t$this->arguments['taxonomies'] = $taxonomies;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the register_meta_box_cb argument for the post type.\\n\\t *\\n\\t * @param callable $register_meta_box_cb The callback to register meta boxes.\\n\\t *\/\\n\\tpublic function register_meta_box_cb( callable $register_meta_box_cb ): static {\\n\\t\\t$this->arguments['register_meta_box_cb'] = $register_meta_box_cb;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the has_archive argument for the post type.\\n\\t *\\n\\t * @param bool|string $has_archive Whether the post type has an archive.\\n\\t *\/\\n\\tpublic function has_archive( bool|string $has_archive = true ): static {\\n\\t\\t$this->arguments['has_archive'] = $has_archive;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the rewrite argument for the post type.\\n\\t *\\n\\t * @param bool|array $rewrite The rewrite rules for the post type.\\n\\t * @phpstan-param bool|array{\\n\\t *   slug?: string,\\n\\t *   with_front?: bool,\\n\\t *   feeds?: bool,\\n\\t *   pages?: bool,\\n\\t *   ep_mask?: int,\\n\\t * } $rewrite\\n\\t *\/\\n\\tpublic function rewrite( array|bool $rewrite ): static {\\n\\t\\t$this->arguments['rewrite'] = $rewrite;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the query_var argument for the post type.\\n\\t *\\n\\t * @param bool|string $query_var Whether to use a query var.\\n\\t *\/\\n\\tpublic function query_var( bool|string $query_var = true ): static {\\n\\t\\t$this->arguments['query_var'] = $query_var;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the template argument for the post type.\\n\\t *\\n\\t * @param array<array<mixed>> $template Array of blocks to use as the default\\n\\t *                                      initial state session. Each item\\n\\t *                                      should be an array containing block\\n\\t *                                      name and optional attributes. Default\\n\\t *                                      empty array.\\n\\t *\/\\n\\tpublic function template( array $template ): static {\\n\\t\\t$this->arguments['template'] = $template;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the template_lock argument for the post type.\\n\\t *\\n\\t * @param bool|string $template_lock Whether to lock the template.\\n\\t *\/\\n\\tpublic function template_lock( bool|string $template_lock ): static {\\n\\t\\t$this->arguments['template_lock'] = $template_lock;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Handle dynamic method calls to set arguments.\\n\\t *\\n\\t * @throws \\\\InvalidArgumentException If no arguments are provided.\\n\\t *\\n\\t * @param string       $name The name of the method called.\\n\\t * @param array<mixed> $arguments The arguments passed to the method.\\n\\t *\/\\n\\tpublic function __call( string $name, array $arguments ): static {\\n\\t\\tif ( empty( $arguments ) ) {\\n\\t\\t\\tthrow new \\\\InvalidArgumentException( 'No arguments provided for ' . $name );\\n\\t\\t}\\n\\n\\t\\t$this->arguments[ $name ] = $arguments[0];\\n\\n\\t\\treturn $this;\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/registration\/class-taxonomy-arguments.php\",\"ext\":\"php\",\"size\":12439,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Taxonomy_Arguments class file\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support\\\\Registration;\\n\\nuse Mantle\\\\Contracts\\\\Support\\\\Arrayable;\\nuse Mantle\\\\Support\\\\Str;\\nuse Mantle\\\\Support\\\\Traits\\\\Makeable;\\n\\n\/**\\n * Fluent interface for creating arguments to register a taxonomy.\\n *\/\\nclass Taxonomy_Arguments implements Arrayable {\\n\\tuse Makeable;\\n\\n\\t\/**\\n\\t * Arguments to register the taxonomy with.\\n\\t *\\n\\t * @var array<string, mixed>\\n\\t *\/\\n\\tprotected array $arguments = [];\\n\\n\\t\/**\\n\\t * Get the instance as an array.\\n\\t *\\n\\t * @return array<string, mixed>\\n\\t *\/\\n\\tpublic function to_array(): array {\\n\\t\\treturn $this->arguments;\\n\\t}\\n\\n\\t\/**\\n\\t * Get all the arguments.\\n\\t *\\n\\t * @return array<string, mixed>\\n\\t *\/\\n\\tpublic function all(): array {\\n\\t\\treturn $this->arguments;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the label for the taxonomy.\\n\\t *\\n\\t * @param string      $singular The singular label for the taxonomy.\\n\\t * @param string|null $plural The plural label for the taxonomy. Optional.\\n\\t *\/\\n\\tpublic function label( string $singular, ?string $plural = null ): static {\\n\\t\\tif ( ! isset( $this->arguments['labels'] ) || ! is_array( $this->arguments['labels'] ) ) {\\n\\t\\t\\t$this->arguments['labels'] = [];\\n\\t\\t}\\n\\n\\t\\tif ( ! $plural ) {\\n\\t\\t\\t$plural = Str::plural( $singular );\\n\\t\\t}\\n\\n\\t\\t$this->arguments['labels'] = array_merge(\\n\\t\\t\\t$this->arguments['labels'],\\n\\t\\t\\t[\\n\\t\\t\\t\\t'name'                       => $plural,\\n\\t\\t\\t\\t'singular_name'              => $singular,\\n\\t\\t\\t\\t\/* translators: %s: Plural label for the taxonomy. *\/\\n\\t\\t\\t\\t'search_items'               => sprintf( __( 'Search %s' ), $plural ),\\n\\t\\t\\t\\t\/* translators: %s: Plural label for the taxonomy. *\/\\n\\t\\t\\t\\t'popular_items'              => sprintf( __( 'Popular %s' ), $plural ),\\n\\t\\t\\t\\t\/* translators: %s: Plural label for the taxonomy. *\/\\n\\t\\t\\t\\t'all_items'                  => sprintf( __( 'All %s' ), $plural ),\\n\\t\\t\\t\\t\/* translators: %s: Singular label for the taxonomy. *\/\\n\\t\\t\\t\\t'parent_item'                => sprintf( __( 'Parent %s' ), $singular ),\\n\\t\\t\\t\\t\/* translators: %s: Singular label for the taxonomy. *\/\\n\\t\\t\\t\\t'parent_item_colon'          => sprintf( __( 'Parent %s:' ), $singular ),\\n\\t\\t\\t\\t\/* translators: %s: Singular label for the taxonomy. *\/\\n\\t\\t\\t\\t'edit_item'                  => sprintf( __( 'Edit %s' ), $singular ),\\n\\t\\t\\t\\t\/* translators: %s: Singular label for the taxonomy. *\/\\n\\t\\t\\t\\t'view_item'                  => sprintf( __( 'View %s' ), $singular ),\\n\\t\\t\\t\\t\/* translators: %s: Singular label for the taxonomy. *\/\\n\\t\\t\\t\\t'update_item'                => sprintf( __( 'Update %s' ), $singular ),\\n\\t\\t\\t\\t\/* translators: %s: Singular label for the taxonomy. *\/\\n\\t\\t\\t\\t'add_new_item'               => sprintf( __( 'Add New %s' ), $singular ),\\n\\t\\t\\t\\t\/* translators: %s: Singular label for the taxonomy. *\/\\n\\t\\t\\t\\t'new_item_name'              => sprintf( __( 'New %s Name' ), $singular ),\\n\\t\\t\\t\\t\/* translators: %s: Singular label for the taxonomy. *\/\\n\\t\\t\\t\\t'template_name'              => sprintf( __( 'Single Item: %s' ), $singular ),\\n\\t\\t\\t\\t\/* translators: %s: Plural label for the taxonomy. *\/\\n\\t\\t\\t\\t'separate_items_with_commas' => sprintf( __( 'Separate %s with commas' ), $plural ),\\n\\t\\t\\t\\t\/* translators: %s: Plural label for the taxonomy. *\/\\n\\t\\t\\t\\t'add_or_remove_items'        => sprintf( __( 'Add or remove %s' ), $plural ),\\n\\t\\t\\t\\t\/* translators: %s: Plural label for the taxonomy. *\/\\n\\t\\t\\t\\t'choose_from_most_used'      => sprintf( __( 'Choose from the most used %s' ), $plural ),\\n\\t\\t\\t\\t\/* translators: %s: Plural label for the taxonomy. *\/\\n\\t\\t\\t\\t'not_found'                  => sprintf( __( 'No %s found' ), $plural ),\\n\\t\\t\\t\\t\/* translators: %s: Plural label for the taxonomy. *\/\\n\\t\\t\\t\\t'no_terms'                   => sprintf( __( 'No %s' ), $plural ),\\n\\t\\t\\t\\t\/* translators: %s: Singular label for the taxonomy. *\/\\n\\t\\t\\t\\t'filter_by_item'             => sprintf( __( 'Filter by %s' ), $singular ),\\n\\t\\t\\t\\t\/* translators: %s: Plural label for the taxonomy. *\/\\n\\t\\t\\t\\t'back_to_items'              => sprintf( __( 'Back to %s' ), $plural ),\\n\\t\\t\\t\\t\/* translators: %s: Singular label for the taxonomy. *\/\\n\\t\\t\\t\\t'item_link'                  => sprintf( __( '%s Link' ), $singular ),\\n\\t\\t\\t\\t\/* translators: %s: Singular label for the taxonomy. *\/\\n\\t\\t\\t\\t'item_link_description'      => sprintf( __( 'A link to a %s' ), $singular ),\\n\\t\\t\\t],\\n\\t\\t);\\n\\n\\t\\t$this->arguments['labels']['name'] = $plural;\\n\\n\\t\\t$this->arguments['labels']['singular_name'] = $singular;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set a specific label for the taxonomy.\\n\\t *\\n\\t * @see get_taxonomy_labels()\\n\\t *\\n\\t * @param string|array<string, string> $key The key for the label or an array of labels.\\n\\t * @param string                       $value The value for the label.\\n\\t *\/\\n\\tpublic function labels( array|string $key, ?string $value = null ): static {\\n\\t\\tif ( is_array( $key ) ) {\\n\\t\\t\\t$this->arguments['labels'] = array_merge( $this->arguments['labels'], $key );\\n\\n\\t\\t\\treturn $this;\\n\\t\\t}\\n\\n\\t\\tif ( $value ) {\\n\\t\\t\\t$this->arguments['labels'][ $key ] = $value;\\n\\t\\t} else {\\n\\t\\t\\tunset( $this->arguments['labels'][ $key ] );\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the description for the taxonomy.\\n\\t *\\n\\t * @param string $description The description for the taxonomy.\\n\\t *\/\\n\\tpublic function description( string $description ): static {\\n\\t\\t$this->arguments['description'] = $description;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the public argument for the taxonomy.\\n\\t *\\n\\t * @param bool $public Whether the taxonomy is public.\\n\\t *\/\\n\\tpublic function public( bool $public = true ): static {\\n\\t\\t$this->arguments['public'] = $public;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the publicly_queryable argument for the taxonomy.\\n\\t *\\n\\t * @param bool $publicly_queryable Whether the taxonomy is publicly queryable.\\n\\t *\/\\n\\tpublic function publicly_queryable( bool $publicly_queryable = true ): static {\\n\\t\\t$this->arguments['publicly_queryable'] = $publicly_queryable;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the hierarchical argument for the taxonomy.\\n\\t *\\n\\t * @param bool $hierarchical Whether the taxonomy is hierarchical.\\n\\t *\/\\n\\tpublic function hierarchical( bool $hierarchical = true ): static {\\n\\t\\t$this->arguments['hierarchical'] = $hierarchical;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the show_ui argument for the taxonomy.\\n\\t *\\n\\t * @param bool $show_ui Whether to generate a default UI for managing this taxonomy.\\n\\t *\/\\n\\tpublic function show_ui( bool $show_ui = true ): static {\\n\\t\\t$this->arguments['show_ui'] = $show_ui;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the show_in_menu argument for the taxonomy.\\n\\t *\\n\\t * @param bool|string $show_in_menu Whether to show the taxonomy in the admin menu.\\n\\t *\/\\n\\tpublic function show_in_menu( bool|string $show_in_menu = true ): static {\\n\\t\\t$this->arguments['show_in_menu'] = $show_in_menu;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the show_in_nav_menus argument for the taxonomy.\\n\\t *\\n\\t * @param bool $show_in_nav_menus Whether to show the taxonomy in navigation menus.\\n\\t *\/\\n\\tpublic function show_in_nav_menus( bool $show_in_nav_menus = true ): static {\\n\\t\\t$this->arguments['show_in_nav_menus'] = $show_in_nav_menus;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the show_in_rest argument for the taxonomy.\\n\\t *\\n\\t * @param bool $show_in_rest Whether to include the taxonomy in the REST API.\\n\\t *\/\\n\\tpublic function show_in_rest( bool $show_in_rest = true ): static {\\n\\t\\t$this->arguments['show_in_rest'] = $show_in_rest;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the rest_base argument for the taxonomy.\\n\\t *\\n\\t * @param string $rest_base The base slug for the REST API routes.\\n\\t *\/\\n\\tpublic function rest_base( string $rest_base ): static {\\n\\t\\t$this->arguments['rest_base'] = $rest_base;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the rest_namespace argument for the taxonomy.\\n\\t *\\n\\t * @param string $rest_namespace The namespace for the REST API routes.\\n\\t *\/\\n\\tpublic function rest_namespace( string $rest_namespace ): static {\\n\\t\\t$this->arguments['rest_namespace'] = $rest_namespace;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the rest_controller_class argument for the taxonomy.\\n\\t *\\n\\t * @param string $rest_controller_class The controller class for the REST API.\\n\\t *\/\\n\\tpublic function rest_controller_class( string $rest_controller_class ): static {\\n\\t\\t$this->arguments['rest_controller_class'] = $rest_controller_class;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the show_tagcloud argument for the taxonomy.\\n\\t *\\n\\t * @param bool $show_tagcloud Whether to show the tag cloud in the admin.\\n\\t *\/\\n\\tpublic function show_tagcloud( bool $show_tagcloud = true ): static {\\n\\t\\t$this->arguments['show_tagcloud'] = $show_tagcloud;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the show_in_quick_edit argument for the taxonomy.\\n\\t *\\n\\t * @param bool $show_in_quick_edit Whether to show the taxonomy in the quick edit panel.\\n\\t *\/\\n\\tpublic function show_in_quick_edit( bool $show_in_quick_edit = true ): static {\\n\\t\\t$this->arguments['show_in_quick_edit'] = $show_in_quick_edit;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the show_admin_column argument for the taxonomy.\\n\\t *\\n\\t * @param bool $show_admin_column Whether to show the taxonomy in the admin columns.\\n\\t *\/\\n\\tpublic function show_admin_column( bool $show_admin_column = true ): static {\\n\\t\\t$this->arguments['show_admin_column'] = $show_admin_column;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the meta_box_cb argument for the taxonomy.\\n\\t *\\n\\t * @param callable|null $meta_box_cb The callback function for the meta box.\\n\\t *\/\\n\\tpublic function meta_box_cb( ?callable $meta_box_cb ): static {\\n\\t\\t$this->arguments['meta_box_cb'] = $meta_box_cb;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the meta_box_sanitize_cb argument for the taxonomy.\\n\\t *\\n\\t * @param callable|null $meta_box_sanitize_cb The callback function for sanitizing meta box input.\\n\\t *\/\\n\\tpublic function meta_box_sanitize_cb( ?callable $meta_box_sanitize_cb ): static {\\n\\t\\t$this->arguments['meta_box_sanitize_cb'] = $meta_box_sanitize_cb;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the capabilities argument for the taxonomy.\\n\\t *\\n\\t * @param array<string, string> $capabilities The capabilities for the taxonomy.\\n\\t *\/\\n\\tpublic function capabilities( array $capabilities ): static {\\n\\t\\t$this->arguments['capabilities'] = $capabilities;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the rewrite argument for the taxonomy.\\n\\t *\\n\\t * @param false|array<string, mixed> $rewrite The rewrite rules for the taxonomy.\\n\\t * @phpstan-param false|array{\\n\\t *   slug?: string,\\n\\t *   with_front?: bool,\\n\\t *   hierarchical?: bool,\\n\\t *   ep_mask?: string,\\n\\t * } $rewrite\\n\\t *\/\\n\\tpublic function rewrite( false|array $rewrite ): static {\\n\\t\\t$this->arguments['rewrite'] = $rewrite;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the query_var argument for the taxonomy.\\n\\t *\\n\\t * @param false|string $query_var The query variable for the taxonomy.\\n\\t *\/\\n\\tpublic function query_var( false|string $query_var ): static {\\n\\t\\t$this->arguments['query_var'] = $query_var;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the update_count_callback argument for the taxonomy.\\n\\t *\\n\\t * @param callable|null $update_count_callback The callback function for updating the count.\\n\\t *\/\\n\\tpublic function update_count_callback( ?callable $update_count_callback ): static {\\n\\t\\t$this->arguments['update_count_callback'] = $update_count_callback;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Set the default_term argument for the taxonomy.\\n\\t *\\n\\t * @param array|string $default_term The default term for the taxonomy.\\n\\t * @phpstan-param array{\\n\\t *   name?: string,\\n\\t *   slug?: string,\\n\\t *   description?: string,\\n\\t * } $default_term\\n\\t *\/\\n\\tpublic function default_term( array|string $default_term ): static {\\n\\t\\t$this->arguments['default_term'] = $default_term;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Whether terms in this taxonomy should be sorted in the order they are\\n\\t * provided to wp_set_object_terms(). Default null which equates to false.\\n\\t *\\n\\t * @param bool $sort Whether to sort terms in the taxonomy.\\n\\t *\/\\n\\tpublic function sort( bool $sort = false ): static {\\n\\t\\t$this->arguments['sort'] = $sort;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Array of arguments to automatically use inside wp_get_object_terms() for\\n\\t * this taxonomy.\\n\\t *\\n\\t * @param array<mixed> $args Additional arguments for the taxonomy.\\n\\t *\/\\n\\tpublic function args( array $args ): static {\\n\\t\\t$this->arguments['args'] = $args;\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Handle dynamic method calls to set arguments.\\n\\t *\\n\\t * @throws \\\\InvalidArgumentException If no arguments are provided.\\n\\t *\\n\\t * @param string       $name The name of the method called.\\n\\t * @param array<mixed> $arguments The arguments passed to the method.\\n\\t *\/\\n\\tpublic function __call( string $name, array $arguments ): static {\\n\\t\\tif ( empty( $arguments ) ) {\\n\\t\\t\\tthrow new \\\\InvalidArgumentException( 'No arguments provided for ' . $name );\\n\\t\\t}\\n\\n\\t\\t$this->arguments[ $name ] = $arguments[0];\\n\\n\\t\\treturn $this;\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/class-reflector.php\",\"ext\":\"php\",\"size\":5064,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Reflector class file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Support;\\n\\nuse ReflectionClass;\\nuse ReflectionNamedType;\\nuse ReflectionUnionType;\\n\\n\/**\\n * Reflector class.\\n *\\n * Provides methods to inspect classes, methods, and parameters, including\\n * reading attributes and determining parameter types.\\n *\/\\nclass Reflector {\\n\\t\/**\\n\\t * Get the class name of the given parameter's type, if possible.\\n\\t *\\n\\t * @param  \\\\ReflectionParameter $parameter\\n\\t * @return string|null\\n\\t *\/\\n\\tpublic static function get_parameter_class_name( $parameter ) {\\n\\t\\t$type = $parameter->getType();\\n\\n\\t\\tif ( ! $type instanceof ReflectionNamedType || $type->isBuiltin() ) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\t$name = $type->getName();\\n\\n\\t\\tif ( ! is_null( $class = $parameter->getDeclaringClass() ) ) {\\n\\t\\t\\tif ( 'self' === $name ) {\\n\\t\\t\\t\\treturn $class->getName();\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( 'parent' === $name && $parent = $class->getParentClass() ) {\\n\\t\\t\\t\\treturn $parent->getName();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $name;\\n\\t}\\n\\n\\t\/**\\n\\t * Get the class names of the given parameter's type, including union types.\\n\\t *\\n\\t * @param  \\\\ReflectionParameter $parameter\\n\\t * @return array<string>\\n\\t *\/\\n\\tpublic static function get_parameter_class_names( $parameter ): array {\\n\\t\\t$type = $parameter->getType();\\n\\n\\t\\tif ( ! $type instanceof ReflectionUnionType ) {\\n\\t\\t\\treturn array_filter( [ static::get_parameter_class_name( $parameter ) ] );\\n\\t\\t}\\n\\n\\t\\t$union_types = [];\\n\\n\\t\\tforeach ( $type->getTypes() as $listed_type ) {\\n\\t\\t\\tif ( ! $listed_type instanceof ReflectionNamedType || $listed_type->isBuiltin() ) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$union_types[] = static::get_type_name( $parameter, $listed_type );\\n\\t\\t}\\n\\n\\t\\treturn array_filter( $union_types );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the given type's class name.\\n\\t *\\n\\t * @param  \\\\ReflectionParameter $parameter\\n\\t * @param  \\\\ReflectionNamedType $type\\n\\t * @return string\\n\\t *\/\\n\\tprotected static function get_type_name( $parameter, $type ) {\\n\\t\\t$name = $type->getName();\\n\\n\\t\\tif ( ! is_null( $class = $parameter->getDeclaringClass() ) ) {\\n\\t\\t\\tif ( 'self' === $name ) {\\n\\t\\t\\t\\treturn $class->getName();\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( 'parent' === $name && $parent = $class->getParentClass() ) {\\n\\t\\t\\t\\treturn $parent->getName();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $name;\\n\\t}\\n\\n\\t\/**\\n\\t * Determine if the parameter's type is a subclass of the given type.\\n\\t *\\n\\t * @param  \\\\ReflectionParameter $parameter\\n\\t * @param  string               $class_name\\n\\t *\/\\n\\tpublic static function is_parameter_subclass_of( \\\\ReflectionParameter $parameter, string $class_name ): bool {\\n\\t\\t$param_class_name = static::get_parameter_class_name( $parameter );\\n\\n\\t\\treturn $param_class_name && class_exists( $param_class_name ) && ( new ReflectionClass( $param_class_name ) )->isSubclassOf( $class_name );\\n\\t}\\n\\n\\t\/**\\n\\t * Get the attributes for a class or method.\\n\\t *\\n\\t * @see https:\/\/www.php.net\/manual\/en\/reflectionclass.getattributes.php\\n\\t *\\n\\t * @param  object|string     $class     The class name.\\n\\t * @param  string            $method    The method name.\\n\\t * @param  class-string|null $attribute The attribute name to filter by, or null for all attributes.\\n\\t * @param  int               $flags     Flags to pass to getAttributes().\\n\\t * @param  bool              $inherit   Whether to include attributes from parent classes.\\n\\t * @param  bool              $inherit_from_class Whether to include attributes from the class itself.\\n\\t * @return array<\\\\ReflectionAttribute>\\n\\t *\/\\n\\tpublic static function get_attributes_for_method( object|string $class, string $method, ?string $attribute = null, int $flags = 0, bool $inherit = true, bool $inherit_from_class = true ): array {\\n\\t\\t$reflection = new ReflectionClass( $class );\\n\\n\\t\\tif ( ! $reflection->hasMethod( $method ) ) {\\n\\t\\t\\treturn [];\\n\\t\\t}\\n\\n\\t\\treturn [\\n\\t\\t\\t...( $inherit_from_class ? static::get_attributes_for_class( $class, $attribute, $flags, $inherit ) : [] ),\\n\\t\\t\\t...$reflection->getMethod( $method )->getAttributes( $attribute, $flags ),\\n\\t\\t];\\n\\t}\\n\\n\\t\/**\\n\\t * Retrieve attributes for a class.\\n\\t *\\n\\t * Supports attributes on the class and all parent classes.\\n\\t *\\n\\t * @param object|string $class The class name or object instance.\\n\\t * @param string|null   $attribute The attribute name to filter by, or null for all attributes.\\n\\t * @param int           $flags Flags to pass to getAttributes().\\n\\t * @param bool          $inherit Whether to include attributes from parent classes.\\n\\t * @return array<\\\\ReflectionAttribute> Returned in inheritance order (parent -> child).\\n\\t *\/\\n\\tpublic static function get_attributes_for_class( object|string $class, ?string $attribute = null, int $flags = 0, bool $inherit = true ): array {\\n\\t\\t$reflection = new ReflectionClass( $class );\\n\\n\\t\\t$attributes = $reflection->getAttributes( $attribute, $flags );\\n\\n\\t\\tif ( ! $inherit ) {\\n\\t\\t\\treturn $attributes;\\n\\t\\t}\\n\\n\\t\\twhile ( $reflection = $reflection->getParentClass() ) { \/\/ phpcs:ignore Generic.CodeAnalysis.AssignmentInCondition.FoundInWhileCondition\\n\\t\\t\\t$attributes = array_merge( $attributes, $reflection->getAttributes( $attribute, $flags ) );\\n\\t\\t}\\n\\n\\t\\t\/\/ Reverse the order of attributes to maintain inheritance order (parent -> child).\\n\\t\\treturn array_reverse( $attributes );\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/support\/class-option.php\",\"ext\":\"php\",\"size\":2122,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Option class file\\n *\\n * @package mantle-framework\\n *\/\\n\\nnamespace Mantle\\\\Support;\\n\\nuse ArrayAccess;\\nuse InvalidArgumentException;\\nuse Mantle\\\\Contracts\\\\Support\\\\Jsonable;\\n\\n\/**\\n * Fluent class for retrieving options as type-safe objects.\\n *\\n * When retrieving options from the database, get_option() has a return value of\\n * mixed. This class allows you to retrieve options with a specific type.\\n *\/\\nclass Option implements ArrayAccess, Jsonable, \\\\JsonSerializable, \\\\Stringable {\\n\\tuse Interacts_With_Data;\\n\\n\\t\/**\\n\\t * Retrieve an option from the database.\\n\\t *\\n\\t * @param string $option Option name.\\n\\t * @param mixed  $default Default value. Default is null.\\n\\t *\/\\n\\tpublic static function of( ?string $option, mixed $default = null ): static {\\n\\t\\treturn new static( $option, get_option( $option, $default ) );\\n\\t}\\n\\n\\t\/**\\n\\t * Create a new instance of the class.\\n\\t *\\n\\t * @param mixed $value Value.\\n\\t *\/\\n\\tpublic static function create( mixed $value ): static {\\n\\t\\treturn new static( null, $value );\\n\\t}\\n\\n\\t\/**\\n\\t * Constructor\\n\\t *\\n\\t * @param string|null $option Option name.\\n\\t * @param mixed       $value Option value.\\n\\t * @param bool        $throw Whether to throw an exception if the option is not a compatible type.\\n\\t *\/\\n\\tpublic function __construct( protected readonly ?string $option, mixed $value, bool $throw = false ) {\\n\\t\\t$this->value = $value;\\n\\t\\t$this->throw = $throw;\\n\\t}\\n\\n\\t\/**\\n\\t * Save the option.\\n\\t *\\n\\t * @throws InvalidArgumentException If the option is a sub-property of an option and the option name is not passed.\\n\\t *\/\\n\\tpublic function save(): static {\\n\\t\\tif ( ! $this->option ) {\\n\\t\\t\\tthrow new InvalidArgumentException( 'Unable to save sub-property of an option.' );\\n\\t\\t}\\n\\n\\t\\tupdate_option( $this->option, $this->value );\\n\\n\\t\\t$this->value = get_option( $this->option );\\n\\n\\t\\treturn $this;\\n\\t}\\n\\n\\t\/**\\n\\t * Delete the option.\\n\\t *\\n\\t * @throws InvalidArgumentException If the option is a sub-property of an option.\\n\\t *\/\\n\\tpublic function delete(): void {\\n\\t\\tif ( ! $this->option ) {\\n\\t\\t\\tthrow new InvalidArgumentException( 'Unable to delete option on a sub-property of an option.' );\\n\\t\\t}\\n\\n\\t\\tdelete_option( $this->option );\\n\\t}\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/exceptions\/interface-handler.php\",\"ext\":\"php\",\"size\":1145,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Handler interface file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Exceptions;\\n\\nuse Symfony\\\\Component\\\\Console\\\\Output\\\\OutputInterface;\\nuse Symfony\\\\Component\\\\HttpFoundation\\\\Response as SymfonyResponse;\\nuse Throwable;\\n\\n\/**\\n * Error Handler Contract\\n *\/\\ninterface Handler {\\n\\t\/**\\n\\t * Report or log an exception.\\n\\t *\\n\\t * @param Throwable $e Exception thrown.\\n\\t *\\n\\t * @throws \\\\Exception Thrown on missing logger.\\n\\t *\/\\n\\tpublic function report( Throwable $e );\\n\\n\\t\/**\\n\\t * Determine if the exception should be reported.\\n\\t *\\n\\t * @param Throwable $e Exception thrown.\\n\\t * @return bool\\n\\t *\/\\n\\tpublic function should_report( Throwable $e );\\n\\n\\t\/**\\n\\t * Render an exception into an HTTP response.\\n\\t *\\n\\t * @param \\\\Mantle\\\\Http\\\\Request $request\\n\\t * @param \\\\Throwable           $e Exception thrown.\\n\\t * @return mixed\\n\\t *\\n\\t * @throws Throwable Thrown on error rendering.\\n\\t *\/\\n\\tpublic function render( $request, Throwable $e );\\n\\n\\t\/**\\n\\t * Render an exception for the console.\\n\\t *\\n\\t * @param OutputInterface $output\\n\\t * @param Throwable       $e\\n\\t * @return void\\n\\t *\/\\n\\tpublic function render_for_console( OutputInterface $output, Throwable $e );\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/framework\/interface-bootloader.php\",\"ext\":\"php\",\"size\":593,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Bootloader interface file\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Framework;\\n\\nuse Closure;\\n\\n\/**\\n * Bootloader Contract\\n *\\n * Used to instantiate the application and load the framework.\\n *\/\\ninterface Bootloader {\\n\\t\/**\\n\\t * Boot the application given the current context.\\n\\t *\/\\n\\tpublic function boot(): static;\\n\\n\\t\/**\\n\\t * Bind to the container before booting.\\n\\t *\\n\\t * @param string              $abstract Abstract to bind.\\n\\t * @param Closure|string|null $concrete Concrete to bind.\\n\\t *\/\\n\\tpublic function bind( string $abstract, Closure|string|null $concrete ): static;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/assets\/class-load-method.php\",\"ext\":\"php\",\"size\":573,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Load_Method class file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Assets;\\n\\n\/**\\n * Asset Load Methods\\n *\\n * @todo Convert to ENUM with PHP 8.1.\\n *\/\\nclass Load_Method {\\n\\t\/**\\n\\t * Synchronous load method.\\n\\t *\\n\\t * @var string\\n\\t *\/\\n\\tpublic const SYNC = 'sync';\\n\\n\\t\/**\\n\\t * Asynchronous load method.\\n\\t *\\n\\t * @var string\\n\\t *\/\\n\\tpublic const ASYNC = 'async';\\n\\n\\t\/**\\n\\t * Defer load method.\\n\\t *\\n\\t * @var string\\n\\t *\/\\n\\tpublic const DEFER = 'defer';\\n\\n\\t\/**\\n\\t * Asynchronous and Defer load method.\\n\\t *\\n\\t * @var string\\n\\t *\/\\n\\tpublic const ASYNC_DEFER = 'async-defer';\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/assets\/interface-asset-manager.php\",\"ext\":\"php\",\"size\":2616,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Asset_Manager interface file.\\n *\\n * phpcs:disable Squiz.Commenting.FunctionComment\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Assets;\\n\\n\/**\\n * Asset Manager Contract\\n *\/\\ninterface Asset_Manager {\\n\\t\/**\\n\\t * Load a external script.\\n\\t *\\n\\t * @param string          $handle Script handle.\\n\\t * @param string          $src Script URL.\\n\\t * @param string[]|string $deps Script dependencies.\\n\\t * @param array|string    $condition Condition to load.\\n\\t * @param string          $load_method Load method.\\n\\t * @param string          $load_hook Load hook.\\n\\t * @param string|null     $version Script version.\\n\\t * @return void\\n\\t *\/\\n\\tpublic function script( mixed ...$params );\\n\\n\\t\/**\\n\\t * Load an external stylesheet file.\\n\\t *\\n\\t * @param string          $handle Stylesheet handle.\\n\\t * @param string          $src Stylesheet URL.\\n\\t * @param string[]|string $deps Stylesheet dependencies.\\n\\t * @param array|string    $condition Condition to load.\\n\\t * @param string          $load_method Load method.\\n\\t * @param string          $load_hook Load hook.\\n\\t * @param string|null     $version Script version.\\n\\t * @param string          $media Style media.\\n\\t * @return void\\n\\t *\/\\n\\tpublic function style( mixed ...$params );\\n\\n\\t\/**\\n\\t * Preload content by URL.\\n\\t *\\n\\t * @link https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/HTML\/Link_types\/preload\\n\\t *\\n\\t * @param string      $handle Preload handle.\\n\\t * @param string      $src URL to preload.\\n\\t * @param string      $condition Condition to preload.\\n\\t * @param string|null $as Preload as, defaults to detect \\\"as\\\" by file URL.\\n\\t * @param string|null $mime_type Mime type to load as, defaults to detect by file URL.\\n\\t * @param string      $media Media to preload, defaults to 'all'.\\n\\t * @param bool        $crossorigin Flag to load as cross origin, defaults to false.\\n\\t * @param string|null $version Handle version, optional.\\n\\t *\/\\n\\tpublic function preload(\\n\\t\\tstring $handle,\\n\\t\\tstring $src,\\n\\t\\t$condition = 'global',\\n\\t\\t?string $as = null,\\n\\t\\t?string $mime_type = null,\\n\\t\\tstring $media = 'all',\\n\\t\\tbool $crossorigin = false,\\n\\t\\t?string $version = null\\n\\t): void;\\n\\n\\t\/**\\n\\t * Asynchronously load a script file.\\n\\t *\\n\\t * @param string $handle Handle to change.\\n\\t *\/\\n\\tpublic function async( string $handle ): void;\\n\\n\\t\/**\\n\\t * Defer a script file\\n\\t *\\n\\t * @param string $handle Handle to change.\\n\\t *\/\\n\\tpublic function defer( string $handle ): void;\\n\\n\\t\/**\\n\\t * Change the load method of an asset.\\n\\t *\\n\\t * @param string $handle Handle to change.\\n\\t * @param string $load_method Load method to change to.\\n\\t *\/\\n\\tpublic function load_method( string $handle, string $load_method = Load_Method::SYNC ): void;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/assets\/class-load-hook.php\",\"ext\":\"php\",\"size\":325,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Load_Hook class file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Assets;\\n\\n\/**\\n * Asset Load Hooks\\n *\/\\nclass Load_Hook {\\n\\t\/**\\n\\t * Header load method.\\n\\t *\\n\\t * @var string\\n\\t *\/\\n\\tpublic const HEADER = 'wp_head';\\n\\n\\t\/**\\n\\t * Footer load method.\\n\\t *\\n\\t * @var string\\n\\t *\/\\n\\tpublic const FOOTER = 'wp_footer';\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/view\/interface-engine.php\",\"ext\":\"php\",\"size\":340,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Engine interface file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\View;\\n\\n\/**\\n * Engine Interface\\n *\/\\ninterface Engine {\\n\\t\/**\\n\\t * Get the evaluated contents of the view.\\n\\t *\\n\\t * @param  string $path View path.\\n\\t * @param  array  $data View data.\\n\\t *\/\\n\\tpublic function get( string $path, array $data = [] ): string;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/interface-bootstrapable.php\",\"ext\":\"php\",\"size\":403,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Bootstrapable interface file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts;\\n\\nuse Mantle\\\\Application\\\\Application;\\n\\n\/**\\n * Bootstrapable Contract\\n *\/\\ninterface Bootstrapable {\\n\\t\/**\\n\\t * Bootstrap method.\\n\\t *\\n\\t * @param Application $app Application instance.\\n\\t * @param Kernel|null $kernel Kernel instance.\\n\\t *\/\\n\\tpublic function bootstrap( Application $app, ?Kernel $kernel ): void;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/cache\/interface-repository.php\",\"ext\":\"php\",\"size\":3965,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Repository interface file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Cache;\\n\\nuse Closure;\\nuse Psr\\\\SimpleCache\\\\CacheInterface;\\n\\n\/**\\n * Cache Repository\\n * Implements PSR-16 standard and follows PSR code naming conventions.\\n *\\n * @link https:\/\/www.php-fig.org\/psr\/psr-16\/\\n *\/\\ninterface Repository extends CacheInterface {\\n\\t\/**\\n\\t * Retrieve a value from cache.\\n\\t *\\n\\t * @template TCacheValue\\n\\t *\\n\\t * @param string                                $key Cache key.\\n\\t * @param TCacheValue|(\\\\Closure(): TCacheValue) $default Default value.\\n\\t * @return (TCacheValue is null ? mixed : TCacheValue)\\n\\t *\/\\n\\tpublic function get( string $key, mixed $default = null ): mixed;\\n\\n\\t\/**\\n\\t * Retrieve an item from the cache and delete it.\\n\\t *\\n\\t * @template TCacheValue\\n\\t *\\n\\t * @param  string                                $key\\n\\t * @param TCacheValue|(\\\\Closure(): TCacheValue) $default Default value.\\n\\t * @return (TCacheValue is null ? mixed : TCacheValue)\\n\\t *\/\\n\\tpublic function pull( string $key, mixed $default = null ): mixed;\\n\\n\\t\/**\\n\\t * Store an item in the cache.\\n\\t *\\n\\t * @param  string                                    $key\\n\\t * @param  mixed                                     $value\\n\\t * @param  \\\\DateTimeInterface|\\\\DateInterval|int|null $ttl\\n\\t *\/\\n\\tpublic function put( string $key, mixed $value, \\\\DateTimeInterface|\\\\DateInterval|int|null $ttl = null ): bool;\\n\\n\\t\/**\\n\\t * Store an item in the cache if the key does not exist.\\n\\t *\\n\\t * @param  string                                    $key\\n\\t * @param  mixed                                     $value\\n\\t * @param  \\\\DateTimeInterface|\\\\DateInterval|int|null $ttl\\n\\t *\/\\n\\tpublic function add( string $key, mixed $value, \\\\DateTimeInterface|\\\\DateInterval|int|null $ttl = null ): bool;\\n\\n\\t\/**\\n\\t * Increment the value of an item in the cache.\\n\\t *\\n\\t * @param  string $key\\n\\t * @param  int    $value\\n\\t *\/\\n\\tpublic function increment( string $key, int $value = 1 ): int|bool;\\n\\n\\t\/**\\n\\t * Decrement the value of an item in the cache.\\n\\t *\\n\\t * @param  string $key\\n\\t * @param  int    $value\\n\\t *\/\\n\\tpublic function decrement( string $key, int $value = 1 ): int|bool;\\n\\n\\t\/**\\n\\t * Store an item in the cache indefinitely.\\n\\t *\\n\\t * @param  string $key\\n\\t * @param  mixed  $value\\n\\t *\/\\n\\tpublic function forever( string $key, mixed $value ): bool;\\n\\n\\t\/**\\n\\t * Get an item from the cache, or execute the given Closure and store the result.\\n\\t *\\n\\t * @template TCacheValue\\n\\t *\\n\\t * @param  string                                    $key\\n\\t * @param  \\\\DateTimeInterface|\\\\DateInterval|int|null $ttl\\n\\t * @param  (\\\\Closure(): TCacheValue)                 $callback\\n\\t *\/\\n\\tpublic function remember( string $key, \\\\DateTimeInterface|\\\\DateInterval|int|null $ttl, Closure $callback ): mixed;\\n\\n\\t\/**\\n\\t * Get an item from the cache, or execute the given Closure and store the result forever.\\n\\t *\\n\\t * @param  string   $key\\n\\t * @param  \\\\Closure $callback\\n\\t *\/\\n\\tpublic function sear( string $key, Closure $callback ): mixed;\\n\\n\\t\/**\\n\\t * Get an item from the cache, or execute the given Closure and store the result forever.\\n\\t *\\n\\t * @template TCacheValue\\n\\t *\\n\\t * @param  string                    $key\\n\\t * @param  (\\\\Closure(): TCacheValue) $callback\\n\\t *\/\\n\\tpublic function remember_forever( string $key, Closure $callback ): mixed;\\n\\n\\t\/**\\n\\t * Remove an item from the cache.\\n\\t *\\n\\t * @param  string $key\\n\\t *\/\\n\\tpublic function forget( string $key ): bool;\\n\\n\\t\/**\\n\\t * Retrieve a value from cache. Return it if it exists and if stale, refresh it after the response is sent.\\n\\t *\\n\\t * @throws \\\\InvalidArgumentException If the value in cache is not an array.\\n\\t *\\n\\t * @param string                                    $key\\n\\t * @param int|\\\\DateInterval|\\\\DateTimeInterface|null $stale\\n\\t * @param int|\\\\DateInterval|\\\\DateTimeInterface|null $expire\\n\\t * @param callable                                  $callback\\n\\t *\/\\n\\tpublic function flexible( string $key, int|\\\\DateInterval|\\\\DateTimeInterface|null $stale, int|\\\\DateInterval|\\\\DateTimeInterface|null $expire, callable $callback ): mixed;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/cache\/interface-taggable-repository.php\",\"ext\":\"php\",\"size\":345,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Taggable_Repository interface file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Cache;\\n\\n\/**\\n * Cache Tag Contract\\n *\/\\ninterface Taggable_Repository extends Repository {\\n\\t\/**\\n\\t * Cache tags to apply.\\n\\t *\\n\\t * @param string[]|string $names Cache names.\\n\\t * @return static\\n\\t *\/\\n\\tpublic function tags( array|string $names );\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/cache\/interface-factory.php\",\"ext\":\"php\",\"size\":314,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Factory interface file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Cache;\\n\\n\/**\\n * Cache Factory\\n *\/\\ninterface Factory {\\n\\t\/**\\n\\t * Retrieve a cache store by name.\\n\\t *\\n\\t * @param string|null $name Cache store name.\\n\\t * @return Repository\\n\\t *\/\\n\\tpublic function store( ?string $name = null );\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/interface-block.php\",\"ext\":\"php\",\"size\":288,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Block interface file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts;\\n\\n\/**\\n * Block Contract\\n *\/\\ninterface Block {\\n\\t\/**\\n\\t * Executed by the Block Service Provider to handle registering the block\\n\\t * with Mantle and WordPress.\\n\\t *\/\\n\\tpublic function register(): void;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/events\/interface-dispatcher.php\",\"ext\":\"php\",\"size\":1304,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Dispatcher interface file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Events;\\n\\n\/**\\n * Event Dispatcher Contract\\n *\/\\ninterface Dispatcher {\\n\\t\/**\\n\\t * Register an event listener with the dispatcher.\\n\\t *\\n\\t * @param  string|string[] $events\\n\\t * @param  string|callable $listener\\n\\t *\/\\n\\tpublic function listen( string|array $events, string|callable $listener ): void;\\n\\n\\t\/**\\n\\t * Determine if a given event has listeners.\\n\\t *\\n\\t * @param  string $event_name\\n\\t *\/\\n\\tpublic function has_listeners( string $event_name ): bool;\\n\\n\\t\/**\\n\\t * Register an event subscriber with the dispatcher.\\n\\t *\\n\\t * @param  object|string $subscriber\\n\\t *\/\\n\\tpublic function subscribe( object|string $subscriber ): void;\\n\\n\\t\/**\\n\\t * Dispatch an event and call the listeners.\\n\\t *\\n\\t * @param  string|object $event Event name.\\n\\t * @param  mixed         ...$payload Event payload.\\n\\t *\/\\n\\tpublic function dispatch( string|object $event, mixed ...$payload ): mixed;\\n\\n\\t\/**\\n\\t * Remove a set of listeners from the dispatcher.\\n\\t *\\n\\t * @param string               $event Event to remove.\\n\\t * @param callable|string|null $listener Listener to remove.\\n\\t * @param int                  $priority Priority of the listener.\\n\\t *\/\\n\\tpublic function forget( string $event, callable|string|null $listener = null, int $priority = 10 ): void;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/interface-application.php\",\"ext\":\"php\",\"size\":5020,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Application Contract interface file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts;\\n\\nuse RuntimeException;\\nuse Mantle\\\\Contracts\\\\Kernel as Kernel_Contract;\\nuse Mantle\\\\Support\\\\Service_Provider;\\n\\n\/**\\n * Application Contract\\n *\/\\ninterface Application extends Container {\\n\\t\/**\\n\\t * Getter for the base path.\\n\\t *\\n\\t * @param string $path Path to append.\\n\\t *\/\\n\\tpublic function get_base_path( string $path = '' ): string;\\n\\n\\t\/**\\n\\t * Set the base path for a application.\\n\\t *\\n\\t * @param string $path Path to set.\\n\\t *\/\\n\\tpublic function set_base_path( string $path );\\n\\n\\t\/**\\n\\t * Get the path to the application \\\"app\\\" directory.\\n\\t *\\n\\t * @param string $path Path to append, optional.\\n\\t *\/\\n\\tpublic function get_app_path( string $path = '' ): string;\\n\\n\\t\/**\\n\\t * Set the application directory.\\n\\t *\\n\\t * @param string $path Path to use.\\n\\t * @return static\\n\\t *\/\\n\\tpublic function set_app_path( string $path );\\n\\n\\t\/**\\n\\t * Getter for the bootstrap path.\\n\\t *\\n\\t * @param string $path Path to append.\\n\\t *\/\\n\\tpublic function get_bootstrap_path( string $path = '' ): string;\\n\\n\\t\/**\\n\\t * Set the root URL of the application.\\n\\t *\\n\\t * @param string $url Root URL to set.\\n\\t *\/\\n\\tpublic function set_root_url( string $url );\\n\\n\\t\/**\\n\\t * Getter for the root URL.\\n\\t * This would be the root URL to the WordPress installation.\\n\\t *\\n\\t * @param string $path Path to append.\\n\\t *\/\\n\\tpublic function get_root_url( string $path = '' ): string;\\n\\n\\t\/**\\n\\t * Get the cache folder root.\\n\\t * Folder that stores all compiled server-side assets for the application.\\n\\t *\/\\n\\tpublic function get_cache_path(): string;\\n\\n\\t\/**\\n\\t * Get the cached Composer packages path.\\n\\t *\\n\\t * Used to store all auto-loaded packages that are Composer dependencies.\\n\\t *\/\\n\\tpublic function get_cached_packages_path(): string;\\n\\n\\t\/**\\n\\t * Get the cached model manifest path.\\n\\t * Used to store all auto-registered models that are in the application.\\n\\t *\/\\n\\tpublic function get_cached_models_path(): string;\\n\\n\\t\/**\\n\\t * Get the path to the application configuration files.\\n\\t *\/\\n\\tpublic function get_config_path(): string;\\n\\n\\t\/**\\n\\t * Determine if the application has been bootstrapped before.\\n\\t *\/\\n\\tpublic function has_been_bootstrapped(): bool;\\n\\n\\t\/**\\n\\t * Get the Application's Environment\\n\\t *\/\\n\\tpublic function environment(): string;\\n\\n\\t\/**\\n\\t * Check if the Application's Environment matches a list.\\n\\t *\\n\\t * @param string|array ...$environments Environments to check.\\n\\t *\/\\n\\tpublic function is_environment( ...$environments ): bool;\\n\\n\\t\/**\\n\\t * Get the application namespace.\\n\\t *\\n\\t * @throws RuntimeException Thrown on error determining namespace.\\n\\t *\/\\n\\tpublic function get_namespace(): string;\\n\\n\\t\/**\\n\\t * Alias to get_namespace().\\n\\t *\\n\\t * @throws RuntimeException Thrown on error determining namespace.\\n\\t *\/\\n\\tpublic function namespace(): string;\\n\\n\\t\/**\\n\\t * Check if the application is running in the console.\\n\\t *\/\\n\\tpublic function is_running_in_console(): bool;\\n\\n\\t\/**\\n\\t * Check if the application is running in console isolation mode.\\n\\t *\/\\n\\tpublic function is_running_in_console_isolation(): bool;\\n\\n\\t\/**\\n\\t * Determine if the application has booted.\\n\\t *\/\\n\\tpublic function is_booted(): bool;\\n\\n\\t\/**\\n\\t * Boot the application's service providers.\\n\\t *\/\\n\\tpublic function boot();\\n\\n\\t\/**\\n\\t * Register a new boot listener.\\n\\t *\\n\\t * @param callable $callback Callback for the listener.\\n\\t *\/\\n\\tpublic function booting( callable $callback ): static;\\n\\n\\t\/**\\n\\t * Register a new \\\"booted\\\" listener.\\n\\t *\\n\\t * @param callable $callback Callback for the listener.\\n\\t *\/\\n\\tpublic function booted( callable $callback ): static;\\n\\n\\t\/**\\n\\t * Register a new terminating callback.\\n\\t *\\n\\t * @param callable $callback Callback for the listener.\\n\\t *\/\\n\\tpublic function terminating( callable $callback ): static;\\n\\n\\t\/**\\n\\t * Terminate the application.\\n\\t *\/\\n\\tpublic function terminate(): void;\\n\\n\\t\/**\\n\\t * Run the given array of bootstrap classes.\\n\\t *\\n\\t * Bootstrap classes should implement `Mantle\\\\Contracts\\\\Bootstrapable`.\\n\\t *\\n\\t * @param string[]        $bootstrappers Class names of packages to boot.\\n\\t * @param Kernel_Contract $kernel Kernel instance.\\n\\t *\/\\n\\tpublic function bootstrap_with( array $bootstrappers, Kernel_Contract $kernel );\\n\\n\\t\/**\\n\\t * Get an instance of a service provider.\\n\\t *\\n\\t * @param string $name Provider class name.\\n\\t *\/\\n\\tpublic function get_provider( string $name ): ?Service_Provider;\\n\\n\\t\/**\\n\\t * Get all service providers.\\n\\t *\\n\\t * @return Service_Provider[]\\n\\t *\/\\n\\tpublic function get_providers(): array;\\n\\n\\t\/**\\n\\t * Determine if the application is cached.\\n\\t *\/\\n\\tpublic function is_configuration_cached(): bool;\\n\\n\\t\/**\\n\\t * Retrieve the cached configuration path.\\n\\t *\/\\n\\tpublic function get_cached_config_path(): string;\\n\\n\\t\/**\\n\\t * Determine if events are cached.\\n\\t *\/\\n\\tpublic function is_events_cached(): bool;\\n\\n\\t\/**\\n\\t * Retrieve the cached configuration path.\\n\\t *\/\\n\\tpublic function get_cached_events_path(): string;\\n\\n\\t\/**\\n\\t * Register a service provider.\\n\\t *\\n\\t * @param Service_Provider|class-string<Service_Provider> $provider Provider to register.\\n\\t *\/\\n\\tpublic function register( Service_Provider|string $provider ): static;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/queue\/interface-dispatcher.php\",\"ext\":\"php\",\"size\":484,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Dispatcher interface file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Queue;\\n\\n\/**\\n * Queue Dispatcher\\n *\/\\ninterface Dispatcher {\\n\\t\/**\\n\\t * Dispatch the job to the queue to be handled asynchronously.\\n\\t *\\n\\t * @param mixed $job Job instance.\\n\\t * @return mixed\\n\\t *\/\\n\\tpublic function dispatch( $job );\\n\\n\\t\/**\\n\\t * Dispatch the job to the queue to be executed now.\\n\\t *\\n\\t * @param mixed $job Job instance.\\n\\t * @return mixed\\n\\t *\/\\n\\tpublic function dispatch_now( $job );\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/queue\/interface-can-queue.php\",\"ext\":\"php\",\"size\":197,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Can_Queue interface file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Queue;\\n\\n\/**\\n * Contract to allow a job to be added to a asynchronous queue.\\n *\/\\ninterface Can_Queue { }\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/queue\/interface-provider.php\",\"ext\":\"php\",\"size\":925,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Provider interface file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Queue;\\n\\nuse Mantle\\\\Support\\\\Collection;\\n\\n\/**\\n * Queue Provider Contract\\n *\/\\ninterface Provider {\\n\\t\/**\\n\\t * Push a job to the queue.\\n\\t *\\n\\t * @param mixed $job Job instance.\\n\\t *\/\\n\\tpublic function push( $job ): bool;\\n\\n\\t\/**\\n\\t * Get the next set of jobs in the queue.\\n\\t *\\n\\t * @param string $queue Queue name, optional.\\n\\t * @param int    $count Number of items to return.\\n\\t *\/\\n\\tpublic function pop( ?string $queue = null, int $count = 1 ): Collection;\\n\\n\\t\/**\\n\\t * Check if a job is in the queue.\\n\\t *\\n\\t * @param mixed  $job Job instance.\\n\\t * @param string $queue Queue to compare against.\\n\\t *\/\\n\\tpublic function in_queue( mixed $job, ?string $queue = null ): bool;\\n\\n\\t\/**\\n\\t * Retrieve the number of pending jobs in the queue.\\n\\t *\\n\\t * @param string $queue Queue name, optional.\\n\\t *\/\\n\\tpublic function pending_count( ?string $queue = null ): int;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/queue\/interface-job.php\",\"ext\":\"php\",\"size\":196,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Job interface file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Queue;\\n\\n\/**\\n * Job interface.\\n *\/\\ninterface Job {\\n\\t\/**\\n\\t * Handle the job.\\n\\t *\/\\n\\tpublic function handle();\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/queue\/interface-queue-manager.php\",\"ext\":\"php\",\"size\":559,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Queue_Manager class file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Queue;\\n\\n\/**\\n * Queue Manager Contract\\n *\/\\ninterface Queue_Manager {\\n\\t\/**\\n\\t * Get a queue provider instance.\\n\\t *\\n\\t * @param string $name Provider name, optional.\\n\\t *\/\\n\\tpublic function get_provider( ?string $name = null ): Provider;\\n\\n\\t\/**\\n\\t * Add a provider for the queue manager.\\n\\t *\\n\\t * @param string $name Provider name.\\n\\t * @param string $class_name Provider class name.\\n\\t * @return static\\n\\t *\/\\n\\tpublic function add_provider( string $name, string $class_name );\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/rest-api\/interface-rest-field-update-callback.php\",\"ext\":\"php\",\"size\":801,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Interface file for REST_Update_Callback\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\REST_API;\\n\\n\/**\\n * Specifies a REST field that implements an `update_callback()`.\\n *\/\\ninterface REST_Field_Update_Callback {\\n\\t\/**\\n\\t * The callback function used to update the field value.\\n\\t *\\n\\t * @param mixed            $value       Submitted field value.\\n\\t * @param mixed            $object      REST API data object.\\n\\t * @param string           $field_name  Field name.\\n\\t * @param \\\\WP_REST_Request $request     REST API request.\\n\\t * @param string           $object_type Object type.\\n\\t * @return mixed True on success, \\\\WP_Error object if a field cannot be updated.\\n\\t *\/\\n\\tpublic function update_callback( $value, $object, string $field_name, \\\\WP_REST_Request $request, string $object_type );\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/rest-api\/interface-rest-field.php\",\"ext\":\"php\",\"size\":492,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Interface file for REST_Field\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\REST_API;\\n\\n\/**\\n * Specifies a registrable REST API field.\\n *\\n * @see register_rest_field().\\n *\/\\ninterface REST_Field {\\n\\t\/**\\n\\t * Get the object(s) the field is being registered to.\\n\\t *\\n\\t * @return string|array Object type or types.\\n\\t *\/\\n\\tpublic function get_object_types();\\n\\n\\t\/**\\n\\t * Get the attribute name.\\n\\t *\\n\\t * @return string Attribute name.\\n\\t *\/\\n\\tpublic function get_attribute(): string;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/rest-api\/interface-rest-field-schema.php\",\"ext\":\"php\",\"size\":353,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Interface file for REST_Field_Schema\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\REST_API;\\n\\n\/**\\n * Specifies a REST field that has schema.\\n *\/\\ninterface REST_Field_Schema {\\n\\t\/**\\n\\t * Get the field schema, if any.\\n\\t *\\n\\t * @return array|null Typically a schema array, but could be null.\\n\\t *\/\\n\\tpublic function get_schema(): ?array;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/rest-api\/interface-rest-field-with-schema.php\",\"ext\":\"php\",\"size\":245,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Interface file for REST_Field_With_Schema\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\REST_API;\\n\\n\/**\\n * Specifies a REST field that has schema.\\n *\/\\ninterface REST_Field_With_Schema extends REST_Field, REST_Field_Schema {}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/rest-api\/interface-rest-field-get-callback.php\",\"ext\":\"php\",\"size\":666,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Interface file for REST_Get_Callback\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Rest_Api;\\n\\n\/**\\n * Specifies a REST API field that implements a `get_callback()`.\\n *\/\\ninterface REST_Field_Get_Callback {\\n\\t\/**\\n\\t * The callback function used to retrieve the field value.\\n\\t *\\n\\t * @param array            $object      REST API object.\\n\\t * @param string           $field_name  Field name.\\n\\t * @param \\\\WP_REST_Request $request     REST API request.\\n\\t * @param string           $object_type Object type.\\n\\t * @return mixed Field value.\\n\\t *\/\\n\\tpublic function get_callback( $object, string $field_name, \\\\WP_REST_Request $request, string $object_type );\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/paginator\/interface-paginator.php\",\"ext\":\"php\",\"size\":1793,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Paginator interface file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Paginator;\\n\\nuse Mantle\\\\Support\\\\Collection;\\n\\n\/**\\n * Paginator Contract\\n *\\n * @template TModel of \\\\Mantle\\\\Database\\\\Model\\\\Model = object\\n *\/\\ninterface Paginator {\\n\\t\/**\\n\\t * Set the path for the paginator.\\n\\t *\\n\\t * @param string $path Path to set.\\n\\t * @return static\\n\\t *\/\\n\\tpublic function path( ?string $path = null );\\n\\n\\t\/**\\n\\t * Retrieve the paginator's path.\\n\\t *\/\\n\\tpublic function get_path(): string;\\n\\n\\t\/**\\n\\t * Flag to use query string for pagination.\\n\\t *\\n\\t * @return static\\n\\t *\/\\n\\tpublic function use_query_string();\\n\\n\\t\/**\\n\\t * Flag to use path for pagination.\\n\\t *\\n\\t * @return static\\n\\t *\/\\n\\tpublic function use_path();\\n\\n\\t\/**\\n\\t * Set the current page.\\n\\t *\\n\\t * @param int $current_page Page to set.\\n\\t * @return static\\n\\t *\/\\n\\tpublic function set_current_page( ?int $current_page = null );\\n\\n\\t\/**\\n\\t * Retrieve the current page.\\n\\t *\/\\n\\tpublic function current_page(): int;\\n\\n\\t\/**\\n\\t * Retrieve the items in the paginator.\\n\\t *\/\\n\\tpublic function items(): Collection;\\n\\n\\t\/**\\n\\t * Retrieve the count of the paginator.\\n\\t *\/\\n\\tpublic function count(): int;\\n\\n\\t\/**\\n\\t * Append a query variable or set multiple query variables.\\n\\t *\\n\\t * @param string $key Query variable or an array of key value query variables.\\n\\t * @param mixed  $value Variable value.\\n\\t * @return static\\n\\t *\/\\n\\tpublic function append( $key, $value = null );\\n\\n\\t\/**\\n\\t * Set the paginator to use the current query variables from the request.\\n\\t *\\n\\t * @return static\\n\\t *\/\\n\\tpublic function with_query_string();\\n\\n\\t\/**\\n\\t * Retrieve the query variables for the paginator.\\n\\t *\/\\n\\tpublic function query(): array;\\n\\n\\t\/**\\n\\t * Retrieve the next URL.\\n\\t *\/\\n\\tpublic function next_url(): ?string;\\n\\n\\t\/**\\n\\t * Retrieve the previous URL.\\n\\t *\/\\n\\tpublic function previous_url(): ?string;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/console\/interface-application.php\",\"ext\":\"php\",\"size\":1454,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Application interface file\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Console;\\n\\nuse Symfony\\\\Component\\\\Console\\\\Input\\\\InputInterface;\\nuse Symfony\\\\Component\\\\Console\\\\Output\\\\OutputInterface;\\nuse Symfony\\\\Component\\\\Console\\\\Tester\\\\CommandTester;\\nuse Throwable;\\n\\n\/**\\n * Console Application Contract\\n *\/\\ninterface Application {\\n\\t\/**\\n\\t * Run the command through the console application.\\n\\t *\\n\\t * @param InputInterface|null  $input Input interface.\\n\\t * @param OutputInterface|null $output Output interface.\\n\\t *\/\\n\\tpublic function run( ?InputInterface $input = null, ?OutputInterface $output = null ): int;\\n\\n\\t\/**\\n\\t * Run a command through the console application by name.\\n\\t *\\n\\t * @param string                $command Command name.\\n\\t * @param array<string, string> $parameters Command parameters.\\n\\t * @param OutputInterface|null  $output_buffer Output buffer.\\n\\t *\/\\n\\tpublic function call( string $command, array $parameters = [], ?OutputInterface $output_buffer = null ): int;\\n\\n\\t\/**\\n\\t * Test a console command by name.\\n\\t *\\n\\t * @param string                $command Command name.\\n\\t * @param array<string, string> $parameters Command parameters.\\n\\t *\/\\n\\tpublic function test( string $command, array $parameters = [] ): CommandTester;\\n\\n\\t\/**\\n\\t * Render an exception for the console.\\n\\t *\\n\\t * @param Throwable       $e\\n\\t * @param OutputInterface $output\\n\\t * @return void\\n\\t *\/\\n\\tpublic function render_throwable( Throwable $e, OutputInterface $output );\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/console\/interface-kernel.php\",\"ext\":\"php\",\"size\":2440,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Kernel interface file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Console;\\n\\nuse Closure;\\nuse Mantle\\\\Console\\\\Closure_Command;\\nuse Mantle\\\\Console\\\\Command;\\nuse Symfony\\\\Component\\\\Console\\\\Input\\\\InputInterface;\\nuse Symfony\\\\Component\\\\Console\\\\Output\\\\OutputInterface;\\nuse Symfony\\\\Component\\\\Console\\\\Tester\\\\CommandTester;\\n\\n\/**\\n * Console Kernel\\n *\/\\ninterface Kernel extends \\\\Mantle\\\\Contracts\\\\Kernel {\\n\\t\/**\\n\\t * Run the console application.\\n\\t *\\n\\t * @param InputInterface       $input Console input.\\n\\t * @param OutputInterface|null $output Console output.\\n\\t *\/\\n\\tpublic function handle( InputInterface $input, ?OutputInterface $output = null ): int;\\n\\n\\t\/**\\n\\t * Run the console application by command name.\\n\\t *\\n\\t * @param string               $command Command name.\\n\\t * @param array<mixed>         $parameters Command parameters.\\n\\t * @param OutputInterface|null $output_buffer Output buffer.\\n\\t *\/\\n\\tpublic function call( string $command, array $parameters = [], ?OutputInterface $output_buffer = null ): int;\\n\\n\\t\/**\\n\\t * Run the console application by command name without output.\\n\\t *\\n\\t * @param string       $command Command name.\\n\\t * @param array<mixed> $parameters Command parameters.\\n\\t *\/\\n\\tpublic function call_silently( string $command, array $parameters = [] ): int;\\n\\n\\t\/**\\n\\t * Test a console command by name.\\n\\t *\\n\\t * @param string       $command Command name.\\n\\t * @param array<mixed> $parameters Command parameters.\\n\\t *\/\\n\\tpublic function test( string $command, array $parameters = [] ): CommandTester;\\n\\n\\t\/**\\n\\t * Register the application's commands.\\n\\t *\/\\n\\tpublic function register_commands(): void;\\n\\n\\t\/**\\n\\t * Register a new command with the console application.\\n\\t *\\n\\t * @param Command|class-string<Command> $command Command instance or class name.\\n\\t *\/\\n\\tpublic function register( Command|string $command ): void;\\n\\n\\t\/**\\n\\t * Register a new Closure based command with a signature.\\n\\t *\\n\\t * @param string  $signature Command signature.\\n\\t * @param Closure $callback Command callback.\\n\\t *\/\\n\\tpublic function command( string $signature, Closure $callback ): Closure_Command;\\n\\n\\t\/**\\n\\t * Log to the console.\\n\\t *\\n\\t * @param string $message Message to log.\\n\\t *\/\\n\\tpublic function log( string $message ): void;\\n\\n\\t\/**\\n\\t * Terminate the application.\\n\\t *\\n\\t * @param  \\\\Symfony\\\\Component\\\\Console\\\\Input\\\\InputInterface $input\\n\\t * @param  int                                             $status\\n\\t *\/\\n\\tpublic function terminate( $input, $status ): void;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/interface-container.php\",\"ext\":\"php\",\"size\":4381,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Container Contract\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts;\\n\\nuse Closure;\\nuse Psr\\\\Container\\\\ContainerInterface;\\n\\n\/**\\n * Container Contract\\n *\/\\ninterface Container extends ContainerInterface {\\n\\t\/**\\n\\t * Determine if the given abstract type has been bound.\\n\\t *\\n\\t * @param string $abstract Abstract name.\\n\\t *\/\\n\\tpublic function bound( string $abstract ): bool;\\n\\n\\t\/**\\n\\t * Alias a type to a different name.\\n\\t *\\n\\t * @param string $abstract Abstract name.\\n\\t * @param string $alias Alias name.\\n\\t *\/\\n\\tpublic function alias( string $abstract, string $alias ): void;\\n\\n\\t\/**\\n\\t * Register a binding with the container.\\n\\t *\\n\\t * @param string               $abstract Abstract name.\\n\\t * @param \\\\Closure|string|null $concrete Concrete to bind.\\n\\t * @param bool                 $shared Shared flag.\\n\\t *\/\\n\\tpublic function bind( string $abstract, Closure|string|null $concrete = null, bool $shared = false ): void;\\n\\n\\t\/**\\n\\t * Register a binding if it hasn't already been registered.\\n\\t *\\n\\t * @param string               $abstract Abstract name.\\n\\t * @param \\\\Closure|string|null $concrete Concrete to bind.\\n\\t * @param bool                 $shared Shared flag.\\n\\t *\/\\n\\tpublic function bind_if( string $abstract, Closure|string|null $concrete = null, bool $shared = false ): void;\\n\\n\\t\/**\\n\\t * Register a shared binding in the container.\\n\\t *\\n\\t * @param string               $abstract Abstract name.\\n\\t * @param \\\\Closure|string|null $concrete Concrete to bind.\\n\\t * @phpstan-param (\\\\Closure(static, array<mixed>): mixed)|string|null $concrete\\n\\t *\/\\n\\tpublic function singleton( string $abstract, Closure|string|null $concrete = null ): void;\\n\\n\\t\/**\\n\\t * Register a shared binding if it hasn't already been registered.\\n\\t *\\n\\t * @param string               $abstract Abstract name.\\n\\t * @param \\\\Closure|string|null $concrete Concrete name.\\n\\t * @phpstan-param (\\\\Closure(static, array<mixed>): mixed)|string|null $concrete\\n\\t *\/\\n\\tpublic function singleton_if( string $abstract, Closure|string|null $concrete = null ): void;\\n\\n\\t\/**\\n\\t * \\\"Extend\\\" an abstract type in the container.\\n\\t *\\n\\t * @param string   $abstract Abstract name.\\n\\t * @param \\\\Closure $closure Closure callback.\\n\\t *\/\\n\\tpublic function extend( string $abstract, Closure $closure ): void;\\n\\n\\t\/**\\n\\t * Register an existing instance as shared in the container.\\n\\t *\\n\\t * @param string $abstract Abstract name.\\n\\t * @param mixed  $instance Interface instance.\\n\\t *\/\\n\\tpublic function instance( string $abstract, mixed $instance ): mixed;\\n\\n\\t\/**\\n\\t * Get a closure to resolve the given type from the container.\\n\\t *\\n\\t * @param string $abstract Abstract name.\\n\\t *\/\\n\\tpublic function factory( string $abstract ): Closure;\\n\\n\\t\/**\\n\\t * Flush the container of all bindings and resolved instances.\\n\\t *\/\\n\\tpublic function flush(): void;\\n\\n\\t\/**\\n\\t * Call the given Closure \/ class@method and inject its dependencies.\\n\\t *\\n\\t * @param  callable|string $callback\\n\\t * @param  array<mixed>    $parameters\\n\\t * @param  string|null     $default_method\\n\\t *\/\\n\\tpublic function call( $callback, array $parameters = [], $default_method = null ): mixed;\\n\\n\\t\/**\\n\\t * Resolve the given type from the container.\\n\\t *\\n\\t * @param string       $abstract Abstract name.\\n\\t * @param array<mixed> $parameters Parameters to pass.\\n\\t *\/\\n\\tpublic function make( $abstract, array $parameters = [] ): mixed;\\n\\n\\t\/**\\n\\t * Create a new class instance from the container.\\n\\t *\\n\\t * Similar to make() but specifically for passing a class name and returning\\n\\t * an instance of it. This is useful for PHPStan.\\n\\t *\\n\\t * @template TAbstract of object\\n\\t *\\n\\t * @param  string       $class\\n\\t * @phpstan-param class-string<TAbstract> $class\\n\\t * @param  array<mixed> $parameters\\n\\t * @phpstan-return TAbstract\\n\\t *\/\\n\\tpublic function class( string $class, array $parameters = [] ): object;\\n\\n\\t\/**\\n\\t * Determine if the given abstract type has been resolved.\\n\\t *\\n\\t * @param string $abstract Abstract name.\\n\\t *\/\\n\\tpublic function resolved( string $abstract ): bool;\\n\\n\\t\/**\\n\\t * Register a new resolving callback.\\n\\t *\\n\\t * @param \\\\Closure|string $abstract Abstract name.\\n\\t * @param \\\\Closure|null   $callback Callback.\\n\\t *\/\\n\\tpublic function resolving( $abstract, ?Closure $callback = null ): void;\\n\\n\\t\/**\\n\\t * Register a new after resolving callback.\\n\\t *\\n\\t * @param \\\\Closure|string $abstract Abstract name.\\n\\t * @param \\\\Closure|null   $callback Callback.\\n\\t *\/\\n\\tpublic function after_resolving( $abstract, ?Closure $callback = null ): void;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/http\/routing\/interface-router.php\",\"ext\":\"php\",\"size\":4694,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Router interface file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Http\\\\Routing;\\n\\nuse Mantle\\\\Http\\\\Request;\\nuse Mantle\\\\Http\\\\Routing\\\\Route;\\nuse Symfony\\\\Component\\\\HttpFoundation\\\\Response;\\nuse Symfony\\\\Component\\\\Routing\\\\RouteCollection;\\n\\n\/**\\n * Router Contract\\n *\/\\ninterface Router {\\n\\t\/**\\n\\t * Register a route.\\n\\t *\\n\\t * @param string[]     $methods Methods to register.\\n\\t * @param string       $uri URL route.\\n\\t * @param array<mixed> $arguments Route callback.\\n\\t *\/\\n\\tpublic function add_route( array $methods, string $uri, array $arguments ): Route;\\n\\n\\t\/**\\n\\t * Register a REST API route.\\n\\t *\\n\\t * @param string[]     $methods Methods to register.\\n\\t * @param string       $uri URL route.\\n\\t * @param array<mixed> $arguments Route arguments.\\n\\t *\/\\n\\tpublic function add_rest_route( array $methods, string $uri, array $arguments ): Route;\\n\\n\\t\/**\\n\\t * Register a GET route.\\n\\t *\\n\\t * @param string $uri URL to register for.\\n\\t * @param mixed  $action Callback action.\\n\\t *\/\\n\\tpublic function get( string $uri, mixed $action = '' );\\n\\n\\t\/**\\n\\t * Register a POST route.\\n\\t *\\n\\t * @param string $uri URL to register for.\\n\\t * @param mixed  $action Callback action.\\n\\t *\/\\n\\tpublic function post( string $uri, mixed $action = '' );\\n\\n\\t\/**\\n\\t * Register a PUT route.\\n\\t *\\n\\t * @param string $uri URL to register for.\\n\\t * @param mixed  $action Callback action.\\n\\t *\/\\n\\tpublic function put( string $uri, mixed $action = '' );\\n\\n\\t\/**\\n\\t * Register a DELETE route.\\n\\t *\\n\\t * @param string $uri URL to register for.\\n\\t * @param mixed  $action Callback action.\\n\\t *\/\\n\\tpublic function delete( string $uri, mixed $action = '' );\\n\\n\\t\/**\\n\\t * Register a PATCH route.\\n\\t *\\n\\t * @param string $uri URL to register for.\\n\\t * @param mixed  $action Callback action.\\n\\t *\/\\n\\tpublic function patch( string $uri, mixed $action = '' );\\n\\n\\t\/**\\n\\t * Register a OPTIONS route.\\n\\t *\\n\\t * @param string $uri URL to register for.\\n\\t * @param mixed  $action Callback action.\\n\\t *\/\\n\\tpublic function options( string $uri, mixed $action = '' );\\n\\n\\t\/**\\n\\t * Register a route for any HTTP method.\\n\\t *\\n\\t * @param string $uri URL to register for.\\n\\t * @param mixed  $action Callback action.\\n\\t *\/\\n\\tpublic function any( string $uri, mixed $action = '' );\\n\\n\\t\/**\\n\\t * Dispatch a request to the registered routes.\\n\\t *\\n\\t * @param Request $request Request object.\\n\\t *\/\\n\\tpublic function dispatch( Request $request ): ?Response;\\n\\n\\t\/**\\n\\t * Get registered routes.\\n\\t *\/\\n\\tpublic function get_routes(): RouteCollection;\\n\\n\\t\/**\\n\\t * Substitute Explicit Bindings\\n\\t *\\n\\t * @param Request $request Request object.\\n\\t *\/\\n\\tpublic function substitute_bindings( Request $request );\\n\\n\\t\/**\\n\\t * Substitute the implicit Eloquent model bindings for the route.\\n\\t *\\n\\t * @param Request $request Request instance.\\n\\t *\/\\n\\tpublic function substitute_implicit_bindings( Request $request );\\n\\n\\t\/**\\n\\t * Register a REST API route\\n\\t *\\n\\t * @param string                       $namespace        Namespace for the REST API route.\\n\\t * @param callable|string              $callback_or_uri  Callback that will be invoked to register\\n\\t *                                                       routes or a string route path.\\n\\t * @param callable|array<mixed>|string $args             Callback for the route if $callback or route arguments.\\n\\t *\/\\n\\tpublic function rest_api( string $namespace, callable|string $callback_or_uri, callable|array|string $args = [] ): ?Route;\\n\\n\\t\/**\\n\\t * Rename a route.\\n\\t *\\n\\t * @param string $old_name Old route name.\\n\\t * @param string $new_name New route name.\\n\\t *\\n\\t * @throws \\\\InvalidArgumentException Thrown when attempting to rename a route\\n\\t *                                  a name that is already taken.\\n\\t *\/\\n\\tpublic function rename_route( string $old_name, string $new_name ): static;\\n\\n\\t\/**\\n\\t * Register a group of middleware.\\n\\t *\\n\\t * @param  string $name\\n\\t * @param  array  $middleware\\n\\t *\/\\n\\tpublic function middleware_group( string $name, array $middleware ): static;\\n\\n\\t\/**\\n\\t * Register a short-hand name for a middleware.\\n\\t *\\n\\t * @param  string $name\\n\\t * @param  string $class\\n\\t *\/\\n\\tpublic function alias_middleware( string $name, string $class ): static;\\n\\n\\t\/**\\n\\t * Determine if the request should pass through to WordPress.\\n\\t *\\n\\t * @param (callable(Request): bool)|bool $callback Callback to determine if the request should pass through to WordPress.\\n\\t *\/\\n\\tpublic function pass_requests_to_wordpress( callable|bool $callback ): static;\\n\\n\\t\/**\\n\\t * Determine if the request should pass through to WordPress.\\n\\t *\\n\\t * @param Request $request Request object.\\n\\t *\/\\n\\tpublic function should_pass_through_request( Request $request ): bool;\\n\\n\\t\/**\\n\\t * Register the registered REST API routes with WordPress.\\n\\t *\\n\\t * Called on 'rest_api_init'.\\n\\t *\/\\n\\tpublic function register_rest_routes(): void;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/http\/routing\/interface-entity-router.php\",\"ext\":\"php\",\"size\":444,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Entity_Router interface file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Http\\\\Routing;\\n\\n\/**\\n * Entity Router Contract\\n *\/\\ninterface Entity_Router {\\n\\t\/**\\n\\t * Add an entity to the router.\\n\\t *\\n\\t * @param Router $router Router instance.\\n\\t * @param string $entity Entity class name.\\n\\t * @param string $controller Controller class name.\\n\\t *\/\\n\\tpublic function add( Router $router, string $entity, string $controller ): void;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/http\/routing\/interface-url-routable.php\",\"ext\":\"php\",\"size\":827,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Url_Routable class file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Http\\\\Routing;\\n\\n\/**\\n * URL Routable Contract\\n *\\n * Provides an interface to route to a specific model.\\n *\/\\ninterface Url_Routable {\\n\\n\\t\/**\\n\\t * Get the value of the model's route key.\\n\\t *\\n\\t * @return mixed\\n\\t *\/\\n\\tpublic function get_route_key();\\n\\n\\t\/**\\n\\t * Get the route key for the model.\\n\\t *\/\\n\\tpublic function get_route_key_name(): string;\\n\\n\\t\/**\\n\\t * Get route for the model.\\n\\t *\/\\n\\tpublic static function get_route(): ?string;\\n\\n\\t\/**\\n\\t * Get archive route for the model.\\n\\t *\/\\n\\tpublic static function get_archive_route(): ?string;\\n\\n\\t\/**\\n\\t * Retrieve the model for a bound value.\\n\\t *\\n\\t * @param  mixed       $value\\n\\t * @param  string|null $field\\n\\t * @return static|null\\n\\t *\/\\n\\tpublic function resolve_route_binding( $value, $field = null );\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/http\/routing\/interface-response-factory.php\",\"ext\":\"php\",\"size\":3555,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Response_Factory interface file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Http\\\\Routing;\\n\\nuse Symfony\\\\Component\\\\HttpFoundation\\\\RedirectResponse;\\nuse Mantle\\\\Http\\\\Response;\\nuse Symfony\\\\Component\\\\HttpFoundation\\\\JsonResponse;\\n\\n\/**\\n * Response Factory Contract\\n *\/\\ninterface Response_Factory {\\n\\n\\t\/**\\n\\t * Create a new response instance.\\n\\t *\\n\\t * @param  string $content\\n\\t * @param  int    $status\\n\\t * @param  array  $headers\\n\\t * @return Response\\n\\t *\/\\n\\tpublic function make( $content = '', $status = 200, array $headers = [] );\\n\\n\\t\/**\\n\\t * Create a new \\\"no content\\\" response.\\n\\t *\\n\\t * @param  int   $status\\n\\t * @param  array $headers\\n\\t * @return Response\\n\\t *\/\\n\\tpublic function no_content( $status = 204, array $headers = [] );\\n\\n\\t\/**\\n\\t * Create a new response for a given view.\\n\\t *\\n\\t * @param string $slug View slug.\\n\\t * @param string $name View name (optional).\\n\\t * @param array  $data Data to pass to the view.\\n\\t * @param int    $status Response status code.\\n\\t * @param array  $headers Additional headers.\\n\\t * @return Response\\n\\t *\/\\n\\tpublic function view( string $slug, $name = null, $data = [], $status = 200, array $headers = [] );\\n\\n\\t\/**\\n\\t * Create a new JSON response instance.\\n\\t *\\n\\t * @param  mixed $data\\n\\t * @param  int   $status\\n\\t * @param  array $headers\\n\\t * @return JsonResponse\\n\\t *\/\\n\\tpublic function json( $data = [], $status = 200, array $headers = [] );\\n\\n\\t\/**\\n\\t * Create a new JSONP response instance.\\n\\t *\\n\\t * @param  string $callback\\n\\t * @param  mixed  $data\\n\\t * @param  int    $status\\n\\t * @param  array  $headers\\n\\t * @return JsonResponse\\n\\t *\/\\n\\tpublic function jsonp( $callback, $data = [], $status = 200, array $headers = [] );\\n\\n\\t\/**\\n\\t * Create a new streamed response instance.\\n\\t *\\n\\t * @param  \\\\Closure $callback\\n\\t * @param  int      $status\\n\\t * @param  array    $headers\\n\\t * @return \\\\Symfony\\\\Component\\\\HttpFoundation\\\\StreamedResponse\\n\\t *\/\\n\\tpublic function stream( $callback, $status = 200, array $headers = [] );\\n\\n\\t\/**\\n\\t * Create a new streamed response instance as a file download.\\n\\t *\\n\\t * @param  \\\\Closure    $callback\\n\\t * @param  string|null $name\\n\\t * @param  array       $headers\\n\\t * @param  string|null $disposition\\n\\t * @return \\\\Symfony\\\\Component\\\\HttpFoundation\\\\StreamedResponse\\n\\t *\/\\n\\tpublic function stream_download( $callback, $name = null, array $headers = [], $disposition = 'attachment' );\\n\\n\\t\/**\\n\\t * Create a new file download response.\\n\\t *\\n\\t * @param  \\\\SplFileInfo|string $file\\n\\t * @param  string|null         $name\\n\\t * @param  array               $headers\\n\\t * @param  string|null         $disposition\\n\\t * @return \\\\Symfony\\\\Component\\\\HttpFoundation\\\\BinaryFileResponse\\n\\t *\/\\n\\tpublic function download( $file, $name = null, array $headers = [], $disposition = 'attachment' );\\n\\n\\t\/**\\n\\t * Return the raw contents of a binary file.\\n\\t *\\n\\t * @param  \\\\SplFileInfo|string $file\\n\\t * @param  array               $headers\\n\\t * @return \\\\Symfony\\\\Component\\\\HttpFoundation\\\\BinaryFileResponse\\n\\t *\/\\n\\tpublic function file( $file, array $headers = [] );\\n\\n\\t\/**\\n\\t * Create a new redirect response to the given path.\\n\\t *\\n\\t * @param  string    $path\\n\\t * @param  int       $status\\n\\t * @param  array     $headers\\n\\t * @param  bool|null $secure\\n\\t *\/\\n\\tpublic function redirect_to( $path, $status = 302, $headers = [], $secure = null ): RedirectResponse;\\n\\n\\t\/**\\n\\t * Create a new redirect response to a named route.\\n\\t *\\n\\t * @param  string $route\\n\\t * @param  mixed  $parameters\\n\\t * @param  int    $status\\n\\t * @param  array  $headers\\n\\t *\/\\n\\tpublic function redirect_to_route( $route, $parameters = [], $status = 302, $headers = [] ): RedirectResponse;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/http\/routing\/interface-url-generator.php\",\"ext\":\"php\",\"size\":1320,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Url_Generator class file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Http\\\\Routing;\\n\\n\/**\\n * URL Generator\\n *\/\\ninterface Url_Generator {\\n\\t\/**\\n\\t * Get the current URL for the request.\\n\\t *\\n\\t * @return string\\n\\t *\/\\n\\tpublic function current();\\n\\n\\t\/**\\n\\t * Get the URL for the previous request.\\n\\t *\\n\\t * @param string $fallback Fallback value, optional.\\n\\t *\/\\n\\tpublic function previous( ?string $fallback = null ): string;\\n\\n\\t\/**\\n\\t * Generate a URL to a specific path.\\n\\t *\\n\\t * @param string               $path URL Path.\\n\\t * @param array<string, mixed> $extra_query Extra query parameters to be appended to the URL path.\\n\\t * @param array                $extra_params Extra parameters to be appended to the URL path.\\n\\t * @param bool                 $secure Flag if should be forced to be secure.\\n\\t * @return string\\n\\t *\/\\n\\tpublic function to( string $path, array $extra_query = [], array $extra_params = [], ?bool $secure = null );\\n\\n\\t\/**\\n\\t * Generate a URL for a route.\\n\\t *\\n\\t * @param string $name Route name.\\n\\t * @param array  $parameters Route parameters.\\n\\t * @param bool   $absolute Flag if should be absolute.\\n\\t *\\n\\t * @throws \\\\Symfony\\\\Component\\\\Routing\\\\Exception\\\\RouteNotFoundException If route not found.\\n\\t *\/\\n\\tpublic function route( string $name, array $parameters = [], bool $absolute = true ): string;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/http\/routing\/interface-route-registrar.php\",\"ext\":\"php\",\"size\":852,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Route_Registrar interface file\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Http\\\\Routing;\\n\\nuse Mantle\\\\Http\\\\Routing\\\\Route;\\n\\n\/**\\n * Route Registrar Contract\\n *\/\\ninterface Route_Registrar {\\n\\t\/**\\n\\t * Set the value for a given attribute.\\n\\t *\\n\\t * @param  string $key\\n\\t * @param  mixed  $value\\n\\t *\/\\n\\tpublic function attribute( string $key, mixed $value ): static;\\n\\n\\t\/**\\n\\t * Retrieve the registrar's attributes.\\n\\t *\\n\\t * @return array<mixed>\\n\\t *\/\\n\\tpublic function attributes(): array;\\n\\n\\t\/**\\n\\t * Register a route.\\n\\t *\\n\\t * @param string|string[]                   $method HTTP methods.\\n\\t * @param string                            $uri Route URI.\\n\\t * @param \\\\Closure|array<mixed>|string|null $action Route action.\\n\\t *\/\\n\\tpublic function register_route( string|array $method, string $uri, \\\\Closure|array|string|null $action = null ): Route;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/http\/view\/interface-view-finder.php\",\"ext\":\"php\",\"size\":992,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * View_Finder interface file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Http\\\\View;\\n\\n\/**\\n * View Loader Contract\\n *\/\\ninterface View_Finder {\\n\\t\/**\\n\\t * Add a path to check against when loading a template.\\n\\t *\\n\\t * @param string $path Path to add.\\n\\t * @return static\\n\\t *\/\\n\\tpublic function add_path( string $path );\\n\\n\\t\/**\\n\\t * Remove a path to check against when loading a template.\\n\\t *\\n\\t * @param string $path Path to remove.\\n\\t * @return static\\n\\t *\/\\n\\tpublic function remove_path( string $path );\\n\\n\\t\/**\\n\\t * Remove all paths to check against.\\n\\t *\\n\\t * @return static\\n\\t *\/\\n\\tpublic function clear_paths();\\n\\n\\t\/**\\n\\t * Load a template by template name.\\n\\t *\\n\\t * Acts as a replacement to `get_template_part()` to allow sites to load templates\\n\\t * outside of a theme.\\n\\t *\\n\\t * @param string $slug Template slug.\\n\\t * @param string $name Template name.\\n\\t * @return string The template filename if one is located.\\n\\t *\/\\n\\tpublic function load( string $slug, ?string $name = null ): string;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/http\/view\/interface-factory.php\",\"ext\":\"php\",\"size\":2879,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Factory interface file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Http\\\\View;\\n\\nuse Mantle\\\\Http\\\\View\\\\View;\\nuse Mantle\\\\Support\\\\Collection;\\n\\n\/**\\n * View Factory Contract\\n *\/\\ninterface Factory {\\n\\t\/**\\n\\t * Add a piece of shared data to the environment.\\n\\t *\\n\\t * @param array<string, mixed>|string $key Key to share.\\n\\t * @param mixed|null                  $value Value to share.\\n\\t *\/\\n\\tpublic function share( array|string $key, mixed $value = null ): void;\\n\\n\\t\/**\\n\\t * Get an item from the shared data.\\n\\t *\\n\\t * @param string $key Key to get item by.\\n\\t * @param mixed  $default Default value.\\n\\t *\/\\n\\tpublic function shared( string $key, mixed $default = null ): mixed;\\n\\n\\t\/**\\n\\t * Get all of the shared data for the environment.\\n\\t *\/\\n\\tpublic function get_shared(): array;\\n\\n\\t\/**\\n\\t * Create a collection of views that loop over a collection of WordPress objects.\\n\\t *\\n\\t * While iterating over the data, the proper post data is setup for each item.\\n\\t *\\n\\t * @param array|\\\\ArrayAccess $data Array of WordPress data to loop over.\\n\\t * @param string             $slug View slug.\\n\\t * @param array|string       $name View name, optional. Supports passing variables in if\\n\\t *                                 $variables is not used.\\n\\t * @param array              $variables Variables for the view, optional.\\n\\t *\/\\n\\tpublic function loop( $data, string $slug, $name = null, array $variables = [] ): Collection;\\n\\n\\t\/**\\n\\t * Iterate over an array, loading a given template part for each item in the\\n\\t * array.\\n\\t *\\n\\t * @param array|\\\\ArrayAccess $data Array of data to iterate over over.\\n\\t * @param string             $slug View slug.\\n\\t * @param array|string       $name View name, optional. Supports passing variables in if\\n\\t *                                 $variables is not used.\\n\\t * @param array              $variables Variables for the view, optional.\\n\\t *\/\\n\\tpublic function iterate( $data, string $slug, $name = null, array $variables = [] ): Collection;\\n\\n\\t\/**\\n\\t * Get the rendered contents of a view.\\n\\t *\\n\\t * @param string       $slug View slug.\\n\\t * @param array|string $name View name, optional. Supports passing variables in if\\n\\t *                           $variables is not used.\\n\\t * @param array        $variables Variables for the view, optional.\\n\\t *\/\\n\\tpublic function make( string $slug, array|string|null $name = null, array $variables = [] ): View;\\n\\n\\t\/**\\n\\t * Get a variable from the current view.\\n\\t *\\n\\t * @param string $key Variable to get.\\n\\t * @param mixed  $default Default value if unset.\\n\\t *\/\\n\\tpublic function get_var( string $key, mixed $default = null ): mixed;\\n\\n\\t\/**\\n\\t * Push a view onto the stack and set it as the current view.\\n\\t *\\n\\t * @param View $view View being loaded.\\n\\t *\/\\n\\tpublic function push( View $view ): static;\\n\\n\\t\/**\\n\\t * Pop a partial off the top of the stack and set the current partial to the\\n\\t * next one down.\\n\\t *\/\\n\\tpublic function pop(): static;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/http\/interface-kernel.php\",\"ext\":\"php\",\"size\":485,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Kernel interface file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Http;\\n\\nuse Mantle\\\\Http\\\\Request;\\nuse Mantle\\\\Http\\\\Response;\\n\/**\\n * Http Kernel\\n *\/\\ninterface Kernel {\\n\\t\/**\\n\\t * Run the HTTP Application.\\n\\t *\\n\\t * @param Request $request Request object.\\n\\t *\/\\n\\tpublic function handle( Request $request ): void;\\n\\n\\t\/**\\n\\t * Terminate the HTTP request.\\n\\t *\\n\\t * @param Response $response Response object.\\n\\t *\/\\n\\tpublic function terminate( mixed $response = null ): void;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/support\/interface-arrayable.php\",\"ext\":\"php\",\"size\":342,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Arrayable interface file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Support;\\n\\n\/**\\n * Arrayable interface.\\n *\\n * @template TKey of array-key = array-key\\n * @template TValue = mixed\\n *\/\\ninterface Arrayable {\\n\\t\/**\\n\\t * Get the instance as an array.\\n\\t *\\n\\t * @return array<TKey, TValue>\\n\\t *\/\\n\\tpublic function to_array();\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/support\/interface-jsonable.php\",\"ext\":\"php\",\"size\":298,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Jsonable interface file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Support;\\n\\ninterface Jsonable {\\n\\t\/**\\n\\t * Convert the object to its JSON representation.\\n\\t *\\n\\t * @param int $options json_encode() options.\\n\\t * @return string\\n\\t *\/\\n\\tpublic function to_json( $options = 0 );\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/support\/interface-isolated-service-provider.php\",\"ext\":\"php\",\"size\":537,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Isolated_Service_Provider interface file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Support;\\n\\n\/**\\n * Isolated Service Provider\\n *\\n * A service provider that is isolated from the dependency on WordPress. This\\n * service provider will be registered when the application is running in\\n * isolation mode (a non-WordPress environment). The main use case is for\\n * service providers that are required when running vendor\/bin\/mantle versus the\\n * 'wp mantle' WP-CLI command.\\n *\/\\ninterface Isolated_Service_Provider {\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/support\/interface-htmlable.php\",\"ext\":\"php\",\"size\":224,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Htmlable interface file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Support;\\n\\ninterface Htmlable {\\n\\n\\t\/**\\n\\t * Get content as a string of HTML.\\n\\t *\\n\\t * @return string\\n\\t *\/\\n\\tpublic function to_html();\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/interface-kernel.php\",\"ext\":\"php\",\"size\":141,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Kernel interface.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts;\\n\\n\/**\\n * Core Kernel Interface\\n *\/\\ninterface Kernel { }\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/config\/interface-repository.php\",\"ext\":\"php\",\"size\":1198,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Repository interface file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Config;\\n\\nuse Mantle\\\\Support\\\\Mixed_Data;\\n\\n\/**\\n * Config Repository Contract\\n *\/\\ninterface Repository {\\n\\t\/**\\n\\t * Check if a configuration value exists.\\n\\t *\\n\\t * @param string $key Key to get, period-delimited.\\n\\t *\/\\n\\tpublic function has( string $key ): bool;\\n\\n\\t\/**\\n\\t * Retrieve a configuration value.\\n\\t *\\n\\t * @param string $key Configuration key to get, period-delimited.\\n\\t * @param mixed  $default Default value, optional.\\n\\t *\/\\n\\tpublic function get( string $key, mixed $default = null ): mixed;\\n\\n\\t\/**\\n\\t * Retrieve a configuration value as Mixed_Data.\\n\\t *\\n\\t * @param string $key Configuration key to get, period-delimited.\\n\\t * @param mixed  $default Default value, optional.\\n\\t *\/\\n\\tpublic function get_mixed( string $key, mixed $default = null ): Mixed_Data;\\n\\n\\t\/**\\n\\t * Set a configuration value.\\n\\t *\\n\\t * @param array<string, mixed>|string $key Key(s) to set.\\n\\t * @param mixed                       $value Value to set.\\n\\t *\/\\n\\tpublic function set( array|string $key, mixed $value ): void;\\n\\n\\t\/**\\n\\t * Get all configuration values.\\n\\t *\\n\\t * @return array<string, array<mixed>>\\n\\t *\/\\n\\tpublic function all(): array;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/interface-pipeline.php\",\"ext\":\"php\",\"size\":764,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Pipeline interface file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts;\\n\\nuse Closure;\\n\\n\/**\\n * Pipeline Contract\\n *\/\\ninterface Pipeline {\\n\\n\\t\/**\\n\\t * Set the traveler object being sent on the pipeline.\\n\\t *\\n\\t * @param  mixed $traveler\\n\\t * @return static\\n\\t *\/\\n\\tpublic function send( $traveler );\\n\\n\\t\/**\\n\\t * Set the stops of the pipeline.\\n\\t *\\n\\t * @param  array<callable>|null $stops\\n\\t * @return static\\n\\t *\/\\n\\tpublic function through( $stops );\\n\\n\\t\/**\\n\\t * Set the method to call on the stops.\\n\\t *\\n\\t * @param  string $method\\n\\t * @return static\\n\\t *\/\\n\\tpublic function via( $method );\\n\\n\\t\/**\\n\\t * Run the pipeline with a final destination callback.\\n\\t *\\n\\t * @param  \\\\Closure $destination\\n\\t * @return mixed\\n\\t *\/\\n\\tpublic function then( Closure $destination );\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/filesystem\/interface-filesystem-manager.php\",\"ext\":\"php\",\"size\":328,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Filesystem_Manager interface file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Filesystem;\\n\\n\/**\\n * Filesystem Manager Contract\\n *\/\\ninterface Filesystem_Manager {\\n\\t\/**\\n\\t * Retrieve a filesystem disk.\\n\\t *\\n\\t * @param string $name Disk name.\\n\\t *\/\\n\\tpublic function drive( ?string $name = null ): Filesystem;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/filesystem\/interface-filesystem.php\",\"ext\":\"php\",\"size\":5091,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Filesystem interface file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Filesystem;\\n\\n\/**\\n * Filesystem Contract\\n *\/\\ninterface Filesystem {\\n\\t\/**\\n\\t * The public visibility setting.\\n\\t *\\n\\t * @var string\\n\\t *\/\\n\\tpublic const VISIBILITY_PUBLIC = 'public';\\n\\n\\t\/**\\n\\t * The private visibility setting.\\n\\t *\\n\\t * @var string\\n\\t *\/\\n\\tpublic const VISIBILITY_PRIVATE = 'private';\\n\\n\\t\/**\\n\\t * Get all (recursive) of the directories within a given directory.\\n\\t *\\n\\t * @param  string $directory Directory name.\\n\\t * @return string[]\\n\\t *\/\\n\\tpublic function all_directories( ?string $directory = null ): array;\\n\\n\\t\/**\\n\\t * Get all the directories within a given directory.\\n\\t *\\n\\t * @param string $directory Directory name.\\n\\t * @param bool   $recursive Flag if it should be recursive.\\n\\t *\/\\n\\tpublic function directories( ?string $directory = null, bool $recursive = false ): array;\\n\\n\\t\/**\\n\\t * Create a directory.\\n\\t *\\n\\t * @param string $path Path to create.\\n\\t *\/\\n\\tpublic function make_directory( string $path ): bool;\\n\\n\\t\/**\\n\\t * Recursively delete a directory.\\n\\t *\\n\\t * @param string $directory Directory name.\\n\\t *\/\\n\\tpublic function delete_directory( string $directory ): bool;\\n\\n\\t\/**\\n\\t * Get all of the files from the given directory (recursive).\\n\\t *\\n\\t * @param string $directory Directory name.\\n\\t * @return string[]\\n\\t *\/\\n\\tpublic function all_files( ?string $directory = null ): array;\\n\\n\\t\/**\\n\\t * Get an array of all files in a directory.\\n\\t *\\n\\t * @param string $directory Directory name.\\n\\t * @param bool   $recursive Flag if recursive.\\n\\t * @return string[]\\n\\t *\/\\n\\tpublic function files( ?string $directory = null, bool $recursive = false ): array;\\n\\n\\t\/**\\n\\t * Copy a file from one location to another.\\n\\t *\\n\\t * @param string $from From location.\\n\\t * @param string $to To location.\\n\\t *\/\\n\\tpublic function copy( string $from, string $to ): bool;\\n\\n\\t\/**\\n\\t * Move a file from a location to another.\\n\\t *\\n\\t * @param string $from From location.\\n\\t * @param string $to To location.\\n\\t *\/\\n\\tpublic function move( string $from, string $to ): bool;\\n\\n\\t\/**\\n\\t * Delete a file at the given paths.\\n\\t *\\n\\t * @param string|string[] $paths File paths.\\n\\t *\/\\n\\tpublic function delete( $paths ): bool;\\n\\n\\t\/**\\n\\t * Check if a file exists at a current path.\\n\\t *\\n\\t * @param string $path\\n\\t *\/\\n\\tpublic function exists( string $path ): bool;\\n\\n\\t\/**\\n\\t * Check if a file is missing at a given path.\\n\\t *\\n\\t * @param string $path File path.\\n\\t *\/\\n\\tpublic function missing( string $path ): bool;\\n\\n\\t\/**\\n\\t * Get the contents of a file.\\n\\t *\\n\\t * @param string $path File path.\\n\\t * @return string|bool\\n\\t *\/\\n\\tpublic function get( string $path );\\n\\n\\t\/**\\n\\t * Get the file's last modification time.\\n\\t *\\n\\t * @param string $path File path.\\n\\t * @return int|bool\\n\\t *\/\\n\\tpublic function last_modified( string $path );\\n\\n\\t\/**\\n\\t * Write the contents of a file.\\n\\t *\\n\\t * @param string          $path File path.\\n\\t * @param string|resource $contents File contents.\\n\\t * @param array|string    $options  Options for the files or a string visibility.\\n\\t *\/\\n\\tpublic function put( string $path, $contents, $options = [] ): bool;\\n\\n\\t\/**\\n\\t * Retrieve the size of the file.\\n\\t *\\n\\t * @param string $path File path.\\n\\t * @return int|bool\\n\\t *\/\\n\\tpublic function size( string $path );\\n\\n\\t\/**\\n\\t * Read a file through a stream.\\n\\t *\\n\\t * @param string $path File path.\\n\\t * @return resource|false The path resource or false on failure.\\n\\t *\/\\n\\tpublic function read_stream( string $path );\\n\\n\\t\/**\\n\\t * Write a file through a stream.\\n\\t *\\n\\t * @param string       $path File path.\\n\\t * @param resource     $resource File resource.\\n\\t * @param array|string $options File options or string visibility.\\n\\t *\/\\n\\tpublic function write_stream( string $path, $resource, $options = [] ): bool;\\n\\n\\t\/**\\n\\t * Prepend to a file.\\n\\t *\\n\\t * @param string $path File to prepend.\\n\\t * @param string $data Data to prepend.\\n\\t * @param string $separator Separator from existing data.\\n\\t * @return bool\\n\\t *\/\\n\\tpublic function prepend( string $path, string $data, string $separator = PHP_EOL );\\n\\n\\t\/**\\n\\t * Append to a file.\\n\\t *\\n\\t * @param string $path File to append.\\n\\t * @param string $data Data to append.\\n\\t * @param string $separator Separator from existing data.\\n\\t * @return bool\\n\\t *\/\\n\\tpublic function append( $path, $data, $separator = PHP_EOL );\\n\\n\\t\/**\\n\\t * Retrieve a file's visibility.\\n\\t *\\n\\t * @param string $path\\n\\t *\/\\n\\tpublic function get_visibility( string $path ): string;\\n\\n\\t\/**\\n\\t * Set the visibility for a file.\\n\\t *\\n\\t * @param string $path Path to set.\\n\\t * @param string $visibility Visibility to set.\\n\\t *\/\\n\\tpublic function set_visibility( string $path, string $visibility ): bool;\\n\\n\\t\/**\\n\\t * Get the URL for the file at the given path.\\n\\t *\\n\\t * @param string $path Path to the file.\\n\\t *\/\\n\\tpublic function url( string $path ): ?string;\\n\\n\\t\/**\\n\\t * Get a temporary URL for the file at the given path.\\n\\t *\\n\\t * @param  string             $path File path.\\n\\t * @param  \\\\DateTimeInterface $expiration File expiration.\\n\\t * @param  array              $options Options for the URL.\\n\\t *\\n\\t * @throws \\\\RuntimeException Thrown on missing temporary URL.\\n\\t *\/\\n\\tpublic function temporary_url( string $path, $expiration, array $options = [] ): string;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/database\/interface-registrable-meta.php\",\"ext\":\"php\",\"size\":3256,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Registrable_Meta class file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Database;\\n\\n\/**\\n * Registrable Model Meta Interface\\n *\\n * Provides methods to register a model's meta automatically.\\n *\/\\ninterface Registrable_Meta {\\n\\t\/**\\n\\t * Register a meta field for the model.\\n\\t *\\n\\t * @see register_meta()\\n\\t *\\n\\t * @param string       $meta_key Meta key to register.\\n\\t * @param array<mixed> $args {\\n\\t *    Data used to describe the meta key when registered.\\n\\t *\\n\\t *     @type string     $object_subtype    A subtype; e.g. if the object type is \\\"post\\\", the post type. If left empty,\\n\\t *                                         the meta key will be registered on the entire object type. Default empty.\\n\\t *     @type string     $type              The type of data associated with this meta key.\\n\\t *                                         Valid values are 'string', 'boolean', 'integer', 'number', 'array', and 'object'.\\n\\t *     @type string     $description       A description of the data attached to this meta key.\\n\\t *     @type bool       $single            Whether the meta key has one value per object, or an array of values per object.\\n\\t *     @type mixed      $default           The default value returned from get_metadata() if no value has been set yet.\\n\\t *                                         When using a non-single meta key, the default value is for the first entry.\\n\\t *                                         In other words, when calling get_metadata() with `$single` set to `false`,\\n\\t *                                         the default value given here will be wrapped in an array.\\n\\t *     @type callable   $sanitize_callback A function or method to call when sanitizing `$meta_key` data.\\n\\t *     @type callable   $auth_callback     Optional. A function or method to call when performing edit_post_meta,\\n\\t *                                         add_post_meta, and delete_post_meta capability checks.\\n\\t *     @type bool|array $show_in_rest      Whether data associated with this meta key can be considered public and\\n\\t *                                         should be accessible via the REST API. A custom post type must also declare\\n\\t *                                         support for custom fields for registered meta to be accessible via REST.\\n\\t *                                         When registering complex meta values this argument may optionally be an\\n\\t *                                         array with 'schema' or 'prepare_callback' keys instead of a boolean.\\n\\t * }\\n\\t * @phpstan-param array{\\n\\t *   object_subtype: string,\\n\\t *   type: string,\\n\\t *   description: string,\\n\\t *   single: bool,\\n\\t *   default: mixed,\\n\\t *   sanitize_callback: callable,\\n\\t *   auth_callback: callable,\\n\\t *   show_in_rest: bool|array{\\n\\t *      schema: array<mixed>,\\n\\t *      prepare_callback: callable,\\n\\t *   }\\n\\t * } $args\\n\\t * @return bool True if the meta key was successfully registered in the global array, false if not.\\n\\t *              Registering a meta key with distinct sanitize and auth callbacks will fire those callbacks,\\n\\t *              but will not add to the global registry.\\n\\t * @phpstan-ignore parameter.defaultValue\\n\\t *\/\\n\\tpublic static function register_meta( string $meta_key, array $args = [] ): bool;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/database\/interface-registrable-fields.php\",\"ext\":\"php\",\"size\":354,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Registrable interface file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Database;\\n\\n\/**\\n * Registrable Fields Model Interface\\n *\\n * Provides methods to register a model's fields automatically.\\n *\/\\ninterface Registrable_Fields {\\n\\t\/**\\n\\t * Method to register the model's fields.\\n\\t *\/\\n\\tpublic static function register_fields(): void;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/database\/interface-registrable.php\",\"ext\":\"php\",\"size\":512,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Registrable interface file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Database;\\n\\n\/**\\n * Registrable Model Interface\\n *\\n * Provides methods to register a model with WordPress either through a post type or\\n * a custom taxonomy.\\n *\/\\ninterface Registrable {\\n\\t\/**\\n\\t * Method to register the model.\\n\\t *\/\\n\\tpublic static function register_object(): void;\\n\\n\\t\/**\\n\\t * Arguments to register the model with.\\n\\t *\\n\\t * @return array<mixed>\\n\\t *\/\\n\\tpublic static function get_registration_args(): array;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/database\/interface-scope.php\",\"ext\":\"php\",\"size\":586,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Scope interface file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Database;\\n\\nuse Mantle\\\\Database\\\\Model\\\\Model;\\nuse Mantle\\\\Database\\\\Query\\\\Builder;\\n\\n\/**\\n * Query Scope Contract\\n *\/\\ninterface Scope {\\n\\t\/**\\n\\t * Apply the scope to a given query builder.\\n\\t *\\n\\t * @template TModel of Model\\n\\t *\\n\\t * @param Builder $builder Query Builder instance.\\n\\t * @phpstan-param Builder<TModel> $builder\\n\\t * @param Model   $model Model object.\\n\\t * @phpstan-param Model<object> $model\\n\\t * @return Builder<TModel>\\n\\t *\/\\n\\tpublic function apply( Builder $builder, Model $model ): Builder;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/database\/interface-updatable.php\",\"ext\":\"php\",\"size\":448,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Updatable interface file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Database;\\n\\n\/**\\n * Updatable Model Interface\\n *\/\\ninterface Updatable {\\n\\t\/**\\n\\t * Save the model.\\n\\t *\\n\\t * @param array<mixed> $attributes Attributes to save.\\n\\t *\/\\n\\tpublic function save( array $attributes = [] ): bool;\\n\\n\\t\/**\\n\\t * Delete the model.\\n\\t *\\n\\t * @param bool $force Force delete the mode.\\n\\t *\/\\n\\tpublic function delete( bool $force = false ): mixed;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/database\/interface-core-object.php\",\"ext\":\"php\",\"size\":932,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Core_Object interface file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Database;\\n\\n\/**\\n * Provides a way to normalize interacting with assorted WordPress objects\\n * which have different properties. Allows for a uniform experience when\\n * retrieving\/updating object data in posts, terms, etc.\\n *\/\\ninterface Core_Object {\\n\\t\/**\\n\\t * Getter for Object ID\\n\\t *\/\\n\\tpublic function id(): int;\\n\\n\\t\/**\\n\\t * Getter for Object Name\\n\\t *\/\\n\\tpublic function name(): string;\\n\\n\\t\/**\\n\\t * Getter for Object Slug\\n\\t *\/\\n\\tpublic function slug(): string;\\n\\n\\t\/**\\n\\t * Getter for Object Description\\n\\t *\/\\n\\tpublic function description(): string;\\n\\n\\t\/**\\n\\t * Getter for Parent Object (if any)\\n\\t *\/\\n\\tpublic function parent(): ?Core_Object;\\n\\n\\t\/**\\n\\t * Getter for the Object Permalink\\n\\t *\/\\n\\tpublic function permalink(): ?string;\\n\\n\\t\/**\\n\\t * Retrieve the core object for the underlying object.\\n\\t *\\n\\t * @return mixed\\n\\t *\/\\n\\tpublic function core_object();\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/mantle-framework\/contracts\/database\/interface-model-meta.php\",\"ext\":\"php\",\"size\":2142,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\/**\\n * Model_Meta interface file.\\n *\\n * @package Mantle\\n *\/\\n\\nnamespace Mantle\\\\Contracts\\\\Database;\\n\\nuse Mantle\\\\Database\\\\Model\\\\Model_Exception;\\n\\n\/**\\n * Model Meta Interface\\n *\/\\ninterface Model_Meta {\\n\\t\/**\\n\\t * Retrieve meta data for the object.\\n\\t *\\n\\t * @param string $meta_key Meta key to retrieve.\\n\\t * @param bool   $single Return the first meta key, defaults to true.\\n\\t *\/\\n\\tpublic function get_meta( string $meta_key, bool $single = true ): mixed;\\n\\n\\t\/**\\n\\t * Add meta value for the object.\\n\\t *\\n\\t * @param string $meta_key Meta key.\\n\\t * @param mixed  $meta_value Meta value to store.\\n\\t *\/\\n\\tpublic function add_meta( string $meta_key, mixed $meta_value ): void;\\n\\n\\t\/**\\n\\t * Update meta value for the object.\\n\\t *\\n\\t * @param string $meta_key Meta key.\\n\\t * @param mixed  $meta_value Meta value to store.\\n\\t * @param string $prev_value Optional, previous meta value.\\n\\t *\/\\n\\tpublic function set_meta( string $meta_key, mixed $meta_value, mixed $prev_value = '' ): void;\\n\\n\\t\/**\\n\\t * Delete a object's meta.\\n\\t *\\n\\t * @param string $meta_key Meta key to delete by.\\n\\t * @param mixed  $meta_value Previous meta value to delete.\\n\\t *\/\\n\\tpublic function delete_meta( string $meta_key, mixed $meta_value = '' ): void;\\n\\n\\t\/**\\n\\t * Allow setting meta through an array via an attribute mutator.\\n\\t *\\n\\t * @param array<mixed> $meta_values Meta values to set.\\n\\t * @throws Model_Exception Thrown on invalid value being set.\\n\\t *\/\\n\\tpublic function set_meta_attribute( array $meta_values ): void;\\n\\n\\t\/**\\n\\t * Get a queued meta attribute.\\n\\t *\\n\\t * @param string $key Meta key.\\n\\t * @return mixed|null Meta value or null.\\n\\t *\/\\n\\tpublic function get_queued_meta_attribute( string $key ): mixed;\\n\\n\\t\/**\\n\\t * Queue a meta attribute for saving.\\n\\t * Allows meta to be set before a model is saved.\\n\\t *\\n\\t * Should not be called directly, only to be used via `$model->meta->...`.\\n\\t *\\n\\t * @param string $key Meta key.\\n\\t * @param mixed  $value Meta value.\\n\\t * @param bool   $update Flag to update the queued meta.\\n\\t *\/\\n\\tpublic function queue_meta_attribute( string $key, $value, bool $update = true ): void;\\n\\n\\t\/**\\n\\t * Store queued model meta.\\n\\t *\/\\n\\tpublic function store_queued_meta(): void;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Guid\/Fields.php\",\"ext\":\"php\",\"size\":5002,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Guid;\\n\\nuse Ramsey\\\\Uuid\\\\Exception\\\\InvalidArgumentException;\\nuse Ramsey\\\\Uuid\\\\Fields\\\\SerializableFieldsTrait;\\nuse Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface;\\nuse Ramsey\\\\Uuid\\\\Rfc4122\\\\MaxTrait;\\nuse Ramsey\\\\Uuid\\\\Rfc4122\\\\NilTrait;\\nuse Ramsey\\\\Uuid\\\\Rfc4122\\\\VariantTrait;\\nuse Ramsey\\\\Uuid\\\\Rfc4122\\\\VersionTrait;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Hexadecimal;\\nuse Ramsey\\\\Uuid\\\\Uuid;\\n\\nuse function bin2hex;\\nuse function dechex;\\nuse function hexdec;\\nuse function pack;\\nuse function sprintf;\\nuse function str_pad;\\nuse function strlen;\\nuse function substr;\\nuse function unpack;\\n\\nuse const STR_PAD_LEFT;\\n\\n\/**\\n * GUIDs consist of a set of named fields, according to RFC 9562 (formerly RFC 4122)\\n *\\n * @see Guid\\n *\\n * @immutable\\n *\/\\nfinal class Fields implements FieldsInterface\\n{\\n    use MaxTrait;\\n    use NilTrait;\\n    use SerializableFieldsTrait;\\n    use VariantTrait;\\n    use VersionTrait;\\n\\n    \/**\\n     * @param string $bytes A 16-byte binary string representation of a UUID\\n     *\\n     * @throws InvalidArgumentException if the byte string is not exactly 16 bytes\\n     * @throws InvalidArgumentException if the byte string does not represent a GUID\\n     * @throws InvalidArgumentException if the byte string does not contain a valid version\\n     *\/\\n    public function __construct(private string $bytes)\\n    {\\n        if (strlen($this->bytes) !== 16) {\\n            throw new InvalidArgumentException(\\n                'The byte string must be 16 bytes long; received ' . strlen($this->bytes) . ' bytes',\\n            );\\n        }\\n\\n        if (!$this->isCorrectVariant()) {\\n            throw new InvalidArgumentException(\\n                'The byte string received does not conform to the RFC 9562 (formerly RFC 4122) '\\n                . 'or Microsoft Corporation variants',\\n            );\\n        }\\n\\n        if (!$this->isCorrectVersion()) {\\n            throw new InvalidArgumentException('The byte string received does not contain a valid version');\\n        }\\n    }\\n\\n    public function getBytes(): string\\n    {\\n        return $this->bytes;\\n    }\\n\\n    public function getTimeLow(): Hexadecimal\\n    {\\n        \/\/ Swap the bytes from little endian to network byte order.\\n        \/** @var string[] $hex *\/\\n        $hex = unpack(\\n            'H*',\\n            pack(\\n                'v*',\\n                hexdec(bin2hex(substr($this->bytes, 2, 2))),\\n                hexdec(bin2hex(substr($this->bytes, 0, 2))),\\n            ),\\n        );\\n\\n        return new Hexadecimal($hex[1] ?? '');\\n    }\\n\\n    public function getTimeMid(): Hexadecimal\\n    {\\n        \/\/ Swap the bytes from little endian to network byte order.\\n        \/** @var string[] $hex *\/\\n        $hex = unpack('H*', pack('v', hexdec(bin2hex(substr($this->bytes, 4, 2)))));\\n\\n        return new Hexadecimal($hex[1] ?? '');\\n    }\\n\\n    public function getTimeHiAndVersion(): Hexadecimal\\n    {\\n        \/\/ Swap the bytes from little endian to network byte order.\\n        \/** @var string[] $hex *\/\\n        $hex = unpack('H*', pack('v', hexdec(bin2hex(substr($this->bytes, 6, 2)))));\\n\\n        return new Hexadecimal($hex[1] ?? '');\\n    }\\n\\n    public function getTimestamp(): Hexadecimal\\n    {\\n        return new Hexadecimal(sprintf(\\n            '%03x%04s%08s',\\n            hexdec($this->getTimeHiAndVersion()->toString()) & 0x0fff,\\n            $this->getTimeMid()->toString(),\\n            $this->getTimeLow()->toString()\\n        ));\\n    }\\n\\n    public function getClockSeq(): Hexadecimal\\n    {\\n        if ($this->isMax()) {\\n            $clockSeq = 0xffff;\\n        } elseif ($this->isNil()) {\\n            $clockSeq = 0x0000;\\n        } else {\\n            $clockSeq = hexdec(bin2hex(substr($this->bytes, 8, 2))) & 0x3fff;\\n        }\\n\\n        return new Hexadecimal(str_pad(dechex($clockSeq), 4, '0', STR_PAD_LEFT));\\n    }\\n\\n    public function getClockSeqHiAndReserved(): Hexadecimal\\n    {\\n        return new Hexadecimal(bin2hex(substr($this->bytes, 8, 1)));\\n    }\\n\\n    public function getClockSeqLow(): Hexadecimal\\n    {\\n        return new Hexadecimal(bin2hex(substr($this->bytes, 9, 1)));\\n    }\\n\\n    public function getNode(): Hexadecimal\\n    {\\n        return new Hexadecimal(bin2hex(substr($this->bytes, 10)));\\n    }\\n\\n    public function getVersion(): ?int\\n    {\\n        if ($this->isNil() || $this->isMax()) {\\n            return null;\\n        }\\n\\n        \/** @var int[] $parts *\/\\n        $parts = unpack('n*', $this->bytes);\\n\\n        return ($parts[4] >> 4) & 0x00f;\\n    }\\n\\n    private function isCorrectVariant(): bool\\n    {\\n        if ($this->isNil() || $this->isMax()) {\\n            return true;\\n        }\\n\\n        $variant = $this->getVariant();\\n\\n        return $variant === Uuid::RFC_4122 || $variant === Uuid::RESERVED_MICROSOFT;\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Guid\/Guid.php\",\"ext\":\"php\",\"size\":2275,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Guid;\\n\\nuse Ramsey\\\\Uuid\\\\Codec\\\\CodecInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\NumberConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\TimeConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Uuid;\\n\\n\/**\\n * Guid represents a UUID with \\\"native\\\" (little-endian) byte order\\n *\\n * From Wikipedia:\\n *\\n * > The first three fields are unsigned 32- and 16-bit integers and are subject to swapping, while the last two fields\\n * > consist of uninterpreted bytes, not subject to swapping. This byte swapping applies even for versions 3, 4, and 5,\\n * > where the canonical fields do not correspond to the content of the UUID.\\n *\\n * The first three fields of a GUID are encoded in little-endian byte order, while the last three fields are in network\\n * (big-endian) byte order. This is according to the history of the Microsoft GUID definition.\\n *\\n * According to the .NET Guid.ToByteArray method documentation:\\n *\\n * > Note that the order of bytes in the returned byte array is different from the string representation of a Guid value.\\n * > The order of the beginning four-byte group and the next two two-byte groups is reversed, whereas the order of the\\n * > last two-byte group and the closing six-byte group is the same.\\n *\\n * @link https:\/\/en.wikipedia.org\/wiki\/Universally_unique_identifier#Variants UUID Variants on Wikipedia\\n * @link https:\/\/docs.microsoft.com\/en-us\/windows\/win32\/api\/guiddef\/ns-guiddef-guid Windows GUID structure\\n * @link https:\/\/docs.microsoft.com\/en-us\/dotnet\/api\/system.guid .NET Guid Struct\\n * @link https:\/\/docs.microsoft.com\/en-us\/dotnet\/api\/system.guid.tobytearray .NET Guid.ToByteArray Method\\n *\\n * @immutable\\n *\/\\nfinal class Guid extends Uuid\\n{\\n    public function __construct(\\n        Fields $fields,\\n        NumberConverterInterface $numberConverter,\\n        CodecInterface $codec,\\n        TimeConverterInterface $timeConverter,\\n    ) {\\n        parent::__construct($fields, $numberConverter, $codec, $timeConverter);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Guid\/GuidBuilder.php\",\"ext\":\"php\",\"size\":2297,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Guid;\\n\\nuse Ramsey\\\\Uuid\\\\Builder\\\\UuidBuilderInterface;\\nuse Ramsey\\\\Uuid\\\\Codec\\\\CodecInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\NumberConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\TimeConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Exception\\\\UnableToBuildUuidException;\\nuse Ramsey\\\\Uuid\\\\UuidInterface;\\nuse Throwable;\\n\\n\/**\\n * GuidBuilder builds instances of Guid\\n *\\n * @see Guid\\n *\\n * @immutable\\n *\/\\nclass GuidBuilder implements UuidBuilderInterface\\n{\\n    \/**\\n     * @param NumberConverterInterface $numberConverter The number converter to use when constructing the Guid\\n     * @param TimeConverterInterface $timeConverter The time converter to use for converting timestamps extracted from a\\n     *     UUID to Unix timestamps\\n     *\/\\n    public function __construct(\\n        private NumberConverterInterface $numberConverter,\\n        private TimeConverterInterface $timeConverter,\\n    ) {\\n    }\\n\\n    \/**\\n     * Builds and returns a Guid\\n     *\\n     * @param CodecInterface $codec The codec to use for building this Guid instance\\n     * @param string $bytes The byte string from which to construct a UUID\\n     *\\n     * @return Guid The GuidBuilder returns an instance of Ramsey\\\\Uuid\\\\Guid\\\\Guid\\n     *\\n     * @pure\\n     *\/\\n    public function build(CodecInterface $codec, string $bytes): UuidInterface\\n    {\\n        try {\\n            \/** @phpstan-ignore possiblyImpure.new *\/\\n            return new Guid($this->buildFields($bytes), $this->numberConverter, $codec, $this->timeConverter);\\n        } catch (Throwable $e) {\\n            \/** @phpstan-ignore possiblyImpure.methodCall, possiblyImpure.methodCall *\/\\n            throw new UnableToBuildUuidException($e->getMessage(), (int) $e->getCode(), $e);\\n        }\\n    }\\n\\n    \/**\\n     * Proxy method to allow injecting a mock for testing\\n     *\\n     * @pure\\n     *\/\\n    protected function buildFields(string $bytes): Fields\\n    {\\n        \/** @phpstan-ignore possiblyImpure.new *\/\\n        return new Fields($bytes);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Converter\/Time\/PhpTimeConverter.php\",\"ext\":\"php\",\"size\":5790,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Converter\\\\Time;\\n\\nuse Ramsey\\\\Uuid\\\\Converter\\\\TimeConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Math\\\\BrickMathCalculator;\\nuse Ramsey\\\\Uuid\\\\Math\\\\CalculatorInterface;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Hexadecimal;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Integer as IntegerObject;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Time;\\n\\nuse function count;\\nuse function dechex;\\nuse function explode;\\nuse function is_float;\\nuse function is_int;\\nuse function str_pad;\\nuse function strlen;\\nuse function substr;\\n\\nuse const STR_PAD_LEFT;\\nuse const STR_PAD_RIGHT;\\n\\n\/**\\n * PhpTimeConverter uses built-in PHP functions and standard math operations available to the PHP programming language\\n * to provide facilities for converting parts of time into representations that may be used in UUIDs\\n *\\n * @immutable\\n *\/\\nclass PhpTimeConverter implements TimeConverterInterface\\n{\\n    \/**\\n     * The number of 100-nanosecond intervals from the Gregorian calendar epoch to the Unix epoch.\\n     *\/\\n    private const GREGORIAN_TO_UNIX_INTERVALS = 0x01b21dd213814000;\\n\\n    \/**\\n     * The number of 100-nanosecond intervals in one second.\\n     *\/\\n    private const SECOND_INTERVALS = 10_000_000;\\n\\n    \/**\\n     * The number of 100-nanosecond intervals in one microsecond.\\n     *\/\\n    private const MICROSECOND_INTERVALS = 10;\\n\\n    private int $phpPrecision;\\n    private CalculatorInterface $calculator;\\n    private TimeConverterInterface $fallbackConverter;\\n\\n    public function __construct(\\n        ?CalculatorInterface $calculator = null,\\n        ?TimeConverterInterface $fallbackConverter = null,\\n    ) {\\n        if ($calculator === null) {\\n            $calculator = new BrickMathCalculator();\\n        }\\n\\n        if ($fallbackConverter === null) {\\n            $fallbackConverter = new GenericTimeConverter($calculator);\\n        }\\n\\n        $this->calculator = $calculator;\\n        $this->fallbackConverter = $fallbackConverter;\\n        $this->phpPrecision = (int) ini_get('precision');\\n    }\\n\\n    public function calculateTime(string $seconds, string $microseconds): Hexadecimal\\n    {\\n        $seconds = new IntegerObject($seconds); \/** @phpstan-ignore possiblyImpure.new *\/\\n        $microseconds = new IntegerObject($microseconds); \/** @phpstan-ignore possiblyImpure.new *\/\\n\\n        \/\/ Calculate the count of 100-nanosecond intervals since the Gregorian calendar epoch\\n        \/\/ for the given seconds and microseconds.\\n        $uuidTime = ((int) $seconds->toString() * self::SECOND_INTERVALS)\\n            + ((int) $microseconds->toString() * self::MICROSECOND_INTERVALS)\\n            + self::GREGORIAN_TO_UNIX_INTERVALS;\\n\\n        \/\/ Check to see whether we've overflowed the max\/min integer size.\\n        \/\/ If so, we will default to a different time converter.\\n        \/\/ @phpstan-ignore function.alreadyNarrowedType (the integer value might have overflowed)\\n        if (!is_int($uuidTime)) {\\n            return $this->fallbackConverter->calculateTime(\\n                $seconds->toString(),\\n                $microseconds->toString(),\\n            );\\n        }\\n\\n        \/** @phpstan-ignore possiblyImpure.new *\/\\n        return new Hexadecimal(\\n            str_pad(dechex($uuidTime), 16, '0', STR_PAD_LEFT)\\n        );\\n    }\\n\\n    public function convertTime(Hexadecimal $uuidTimestamp): Time\\n    {\\n        $timestamp = $this->calculator->toInteger($uuidTimestamp);\\n\\n        \/\/ Convert the 100-nanosecond intervals into seconds and microseconds.\\n        $splitTime = $this->splitTime(\\n            ((int) $timestamp->toString() - self::GREGORIAN_TO_UNIX_INTERVALS) \/ self::SECOND_INTERVALS,\\n        );\\n\\n        if (count($splitTime) === 0) {\\n            return $this->fallbackConverter->convertTime($uuidTimestamp);\\n        }\\n\\n        \/** @phpstan-ignore possiblyImpure.new *\/\\n        return new Time($splitTime['sec'], $splitTime['usec']);\\n    }\\n\\n    \/**\\n     * @param float | int $time The time to split into seconds and microseconds\\n     *\\n     * @return string[]\\n     *\\n     * @pure\\n     *\/\\n    private function splitTime(float | int $time): array\\n    {\\n        $split = explode('.', (string) $time, 2);\\n\\n        \/\/ If the $time value is a float but $split only has 1 element, then the float math was rounded up to the next\\n        \/\/ second, so we want to return an empty array to allow use of the fallback converter.\\n        if (is_float($time) && count($split) === 1) {\\n            return [];\\n        }\\n\\n        if (count($split) === 1) {\\n            return ['sec' => $split[0], 'usec' => '0'];\\n        }\\n\\n        \/\/ If the microseconds are less than six characters AND the length of the number is greater than or equal to the\\n        \/\/ PHP precision, then it's possible that we lost some precision for the microseconds. Return an empty array so\\n        \/\/ that we can choose to use the fallback converter.\\n        if (strlen($split[1]) < 6 && strlen((string) $time) >= $this->phpPrecision) {\\n            return [];\\n        }\\n\\n        $microseconds = $split[1];\\n\\n        \/\/ Ensure the microseconds are no longer than 6 digits. If they are,\\n        \/\/ truncate the number to the first 6 digits and round up, if needed.\\n        if (strlen($microseconds) > 6) {\\n            $roundingDigit = (int) substr($microseconds, 6, 1);\\n            $microseconds = (int) substr($microseconds, 0, 6);\\n\\n            if ($roundingDigit >= 5) {\\n                $microseconds++;\\n            }\\n        }\\n\\n        return [\\n            'sec' => $split[0],\\n            'usec' => str_pad((string) $microseconds, 6, '0', STR_PAD_RIGHT),\\n        ];\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Converter\/Time\/DegradedTimeConverter.php\",\"ext\":\"php\",\"size\":616,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Converter\\\\Time;\\n\\n\/**\\n * @deprecated DegradedTimeConverter is no longer necessary for converting time on 32-bit systems. Please transition to\\n *     {@see GenericTimeConverter}.\\n *\\n * @immutable\\n *\/\\nclass DegradedTimeConverter extends BigNumberTimeConverter\\n{\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Converter\/Time\/BigNumberTimeConverter.php\",\"ext\":\"php\",\"size\":1325,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Converter\\\\Time;\\n\\nuse Ramsey\\\\Uuid\\\\Converter\\\\TimeConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Math\\\\BrickMathCalculator;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Hexadecimal;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Time;\\n\\n\/**\\n * Previously used to integrate moontoast\/math as a bignum arithmetic library, BigNumberTimeConverter is deprecated in\\n * favor of GenericTimeConverter\\n *\\n * @deprecated Please transition to {@see GenericTimeConverter}.\\n *\\n * @immutable\\n *\/\\nclass BigNumberTimeConverter implements TimeConverterInterface\\n{\\n    private TimeConverterInterface $converter;\\n\\n    public function __construct()\\n    {\\n        $this->converter = new GenericTimeConverter(new BrickMathCalculator());\\n    }\\n\\n    public function calculateTime(string $seconds, string $microseconds): Hexadecimal\\n    {\\n        return $this->converter->calculateTime($seconds, $microseconds);\\n    }\\n\\n    public function convertTime(Hexadecimal $uuidTimestamp): Time\\n    {\\n        return $this->converter->convertTime($uuidTimestamp);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Converter\/Time\/GenericTimeConverter.php\",\"ext\":\"php\",\"size\":4028,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Converter\\\\Time;\\n\\nuse Ramsey\\\\Uuid\\\\Converter\\\\TimeConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Math\\\\CalculatorInterface;\\nuse Ramsey\\\\Uuid\\\\Math\\\\RoundingMode;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Hexadecimal;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Integer as IntegerObject;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Time;\\n\\nuse function explode;\\nuse function str_pad;\\n\\nuse const STR_PAD_LEFT;\\n\\n\/**\\n * GenericTimeConverter uses the provided calculator to calculate and convert time values\\n *\\n * @immutable\\n *\/\\nclass GenericTimeConverter implements TimeConverterInterface\\n{\\n    \/**\\n     * The number of 100-nanosecond intervals from the Gregorian calendar epoch to the Unix epoch.\\n     *\/\\n    private const GREGORIAN_TO_UNIX_INTERVALS = '122192928000000000';\\n\\n    \/**\\n     * The number of 100-nanosecond intervals in one second.\\n     *\/\\n    private const SECOND_INTERVALS = '10000000';\\n\\n    \/**\\n     * The number of 100-nanosecond intervals in one microsecond.\\n     *\/\\n    private const MICROSECOND_INTERVALS = '10';\\n\\n    public function __construct(private CalculatorInterface $calculator)\\n    {\\n    }\\n\\n    public function calculateTime(string $seconds, string $microseconds): Hexadecimal\\n    {\\n        \/** @phpstan-ignore possiblyImpure.new *\/\\n        $timestamp = new Time($seconds, $microseconds);\\n\\n        \/\/ Convert the seconds into a count of 100-nanosecond intervals.\\n        $sec = $this->calculator->multiply(\\n            $timestamp->getSeconds(),\\n            new IntegerObject(self::SECOND_INTERVALS), \/** @phpstan-ignore possiblyImpure.new *\/\\n        );\\n\\n        \/\/ Convert the microseconds into a count of 100-nanosecond intervals.\\n        $usec = $this->calculator->multiply(\\n            $timestamp->getMicroseconds(),\\n            new IntegerObject(self::MICROSECOND_INTERVALS), \/** @phpstan-ignore possiblyImpure.new *\/\\n        );\\n\\n        \/**\\n         * Combine the intervals of seconds and microseconds and add the count of 100-nanosecond intervals from the\\n         * Gregorian calendar epoch to the Unix epoch. This gives us the correct count of 100-nanosecond intervals since\\n         * the Gregorian calendar epoch for the given seconds and microseconds.\\n         *\\n         * @var IntegerObject $uuidTime\\n         * @phpstan-ignore possiblyImpure.new\\n         *\/\\n        $uuidTime = $this->calculator->add($sec, $usec, new IntegerObject(self::GREGORIAN_TO_UNIX_INTERVALS));\\n\\n        \/**\\n         * PHPStan considers CalculatorInterface::toHexadecimal, Hexadecimal:toString impure.\\n         *\\n         * @phpstan-ignore possiblyImpure.new\\n         *\/\\n        return new Hexadecimal(str_pad($this->calculator->toHexadecimal($uuidTime)->toString(), 16, '0', STR_PAD_LEFT));\\n    }\\n\\n    public function convertTime(Hexadecimal $uuidTimestamp): Time\\n    {\\n        \/\/ From the total, subtract the number of 100-nanosecond intervals from the Gregorian calendar epoch to the Unix\\n        \/\/ epoch. This gives us the number of 100-nanosecond intervals from the Unix epoch, which also includes the microtime.\\n        $epochNanoseconds = $this->calculator->subtract(\\n            $this->calculator->toInteger($uuidTimestamp),\\n            new IntegerObject(self::GREGORIAN_TO_UNIX_INTERVALS), \/** @phpstan-ignore possiblyImpure.new *\/\\n        );\\n\\n        \/\/ Convert the 100-nanosecond intervals into seconds and microseconds.\\n        $unixTimestamp = $this->calculator->divide(\\n            RoundingMode::HALF_UP,\\n            6,\\n            $epochNanoseconds,\\n            new IntegerObject(self::SECOND_INTERVALS), \/** @phpstan-ignore possiblyImpure.new *\/\\n        );\\n\\n        $split = explode('.', (string) $unixTimestamp, 2);\\n\\n        \/** @phpstan-ignore possiblyImpure.new *\/\\n        return new Time($split[0], $split[1] ?? 0);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Converter\/Time\/UnixTimeConverter.php\",\"ext\":\"php\",\"size\":2809,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Converter\\\\Time;\\n\\nuse Ramsey\\\\Uuid\\\\Converter\\\\TimeConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Math\\\\CalculatorInterface;\\nuse Ramsey\\\\Uuid\\\\Math\\\\RoundingMode;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Hexadecimal;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Integer as IntegerObject;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Time;\\n\\nuse function explode;\\nuse function str_pad;\\n\\nuse const STR_PAD_LEFT;\\n\\n\/**\\n * UnixTimeConverter converts Unix Epoch timestamps to\/from hexadecimal values consisting of milliseconds elapsed since\\n * the Unix Epoch\\n *\\n * @immutable\\n *\/\\nclass UnixTimeConverter implements TimeConverterInterface\\n{\\n    private const MILLISECONDS = 1000;\\n\\n    public function __construct(private CalculatorInterface $calculator)\\n    {\\n    }\\n\\n    public function calculateTime(string $seconds, string $microseconds): Hexadecimal\\n    {\\n        \/** @phpstan-ignore possiblyImpure.new *\/\\n        $timestamp = new Time($seconds, $microseconds);\\n\\n        \/\/ Convert the seconds into milliseconds.\\n        $sec = $this->calculator->multiply(\\n            $timestamp->getSeconds(),\\n            new IntegerObject(self::MILLISECONDS) \/** @phpstan-ignore possiblyImpure.new *\/\\n        );\\n\\n        \/\/ Convert the microseconds into milliseconds; the scale is zero because we need to discard the fractional part.\\n        $usec = $this->calculator->divide(\\n            RoundingMode::DOWN, \/\/ Always round down to stay in the previous millisecond.\\n            0,\\n            $timestamp->getMicroseconds(),\\n            new IntegerObject(self::MILLISECONDS), \/** @phpstan-ignore possiblyImpure.new *\/\\n        );\\n\\n        \/** @var IntegerObject $unixTime *\/\\n        $unixTime = $this->calculator->add($sec, $usec);\\n\\n        \/** @phpstan-ignore possiblyImpure.new *\/\\n        return new Hexadecimal(\\n            str_pad(\\n                $this->calculator->toHexadecimal($unixTime)->toString(),\\n                12,\\n                '0',\\n                STR_PAD_LEFT\\n            ),\\n        );\\n    }\\n\\n    public function convertTime(Hexadecimal $uuidTimestamp): Time\\n    {\\n        $milliseconds = $this->calculator->toInteger($uuidTimestamp);\\n\\n        $unixTimestamp = $this->calculator->divide(\\n            RoundingMode::HALF_UP,\\n            6,\\n            $milliseconds,\\n            new IntegerObject(self::MILLISECONDS), \/** @phpstan-ignore possiblyImpure.new *\/\\n        );\\n\\n        $split = explode('.', (string) $unixTimestamp, 2);\\n\\n        \/** @phpstan-ignore possiblyImpure.new *\/\\n        return new Time($split[0], $split[1] ?? '0');\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Converter\/Number\/GenericNumberConverter.php\",\"ext\":\"php\",\"size\":1194,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Converter\\\\Number;\\n\\nuse Ramsey\\\\Uuid\\\\Converter\\\\NumberConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Math\\\\CalculatorInterface;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Integer as IntegerObject;\\n\\n\/**\\n * GenericNumberConverter uses the provided calculator to convert decimal numbers to and from hexadecimal values\\n *\\n * @immutable\\n *\/\\nclass GenericNumberConverter implements NumberConverterInterface\\n{\\n    public function __construct(private CalculatorInterface $calculator)\\n    {\\n    }\\n\\n    \/**\\n     * @pure\\n     *\/\\n    public function fromHex(string $hex): string\\n    {\\n        return $this->calculator->fromBase($hex, 16)->toString();\\n    }\\n\\n    \/**\\n     * @pure\\n     *\/\\n    public function toHex(string $number): string\\n    {\\n        \/** @phpstan-ignore return.type, possiblyImpure.new *\/\\n        return $this->calculator->toBase(new IntegerObject($number), 16);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Converter\/Number\/DegradedNumberConverter.php\",\"ext\":\"php\",\"size\":623,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Converter\\\\Number;\\n\\n\/**\\n * @deprecated DegradedNumberConverter is no longer necessary for converting numbers on 32-bit systems. Please\\n *     transition to {@see GenericNumberConverter}.\\n *\\n * @immutable\\n *\/\\nclass DegradedNumberConverter extends BigNumberConverter\\n{\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Converter\/Number\/BigNumberConverter.php\",\"ext\":\"php\",\"size\":1237,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Converter\\\\Number;\\n\\nuse Ramsey\\\\Uuid\\\\Converter\\\\NumberConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Math\\\\BrickMathCalculator;\\n\\n\/**\\n * Previously used to integrate moontoast\/math as a bignum arithmetic library, BigNumberConverter is deprecated in favor\\n * of GenericNumberConverter\\n *\\n * @deprecated Please transition to {@see GenericNumberConverter}.\\n *\\n * @immutable\\n *\/\\nclass BigNumberConverter implements NumberConverterInterface\\n{\\n    private NumberConverterInterface $converter;\\n\\n    public function __construct()\\n    {\\n        $this->converter = new GenericNumberConverter(new BrickMathCalculator());\\n    }\\n\\n    \/**\\n     * @pure\\n     *\/\\n    public function fromHex(string $hex): string\\n    {\\n        return $this->converter->fromHex($hex);\\n    }\\n\\n    \/**\\n     * @pure\\n     *\/\\n    public function toHex(string $number): string\\n    {\\n        return $this->converter->toHex($number);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Converter\/TimeConverterInterface.php\",\"ext\":\"php\",\"size\":1753,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Converter;\\n\\nuse Ramsey\\\\Uuid\\\\Type\\\\Hexadecimal;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Time;\\n\\n\/**\\n * A time converter converts timestamps into representations that may be used in UUIDs\\n *\\n * @immutable\\n *\/\\ninterface TimeConverterInterface\\n{\\n    \/**\\n     * Uses the provided seconds and micro-seconds to calculate the count of 100-nanosecond intervals since\\n     * UTC 00:00:00.00, 15 October 1582, for RFC 9562 (formerly RFC 4122) variant UUIDs\\n     *\\n     * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#appendix-A RFC 9562, Appendix A. Test Vectors\\n     *\\n     * @param string $seconds A string representation of seconds since the Unix epoch for the time to calculate\\n     * @param string $microseconds A string representation of the micro-seconds associated with the time to calculate\\n     *\\n     * @return Hexadecimal The full UUID timestamp as a Hexadecimal value\\n     *\\n     * @pure\\n     *\/\\n    public function calculateTime(string $seconds, string $microseconds): Hexadecimal;\\n\\n    \/**\\n     * Converts a timestamp extracted from a UUID to a Unix timestamp\\n     *\\n     * @param Hexadecimal $uuidTimestamp A hexadecimal representation of a UUID timestamp; a UUID timestamp is a count\\n     *     of 100-nanosecond intervals since UTC 00:00:00.00, 15 October 1582.\\n     *\\n     * @return Time An instance of {@see Time}\\n     *\\n     * @pure\\n     *\/\\n    public function convertTime(Hexadecimal $uuidTimestamp): Time;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Converter\/NumberConverterInterface.php\",\"ext\":\"php\",\"size\":1482,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Converter;\\n\\n\/**\\n * A number converter converts UUIDs from hexadecimal characters into representations of integers and vice versa\\n *\\n * @immutable\\n *\/\\ninterface NumberConverterInterface\\n{\\n    \/**\\n     * Converts a hexadecimal number into a string integer representation of the number\\n     *\\n     * The integer representation returned is a string representation of the integer to accommodate unsigned integers\\n     * that are greater than `PHP_INT_MAX`.\\n     *\\n     * @param string $hex The hexadecimal string representation to convert\\n     *\\n     * @return numeric-string String representation of an integer\\n     *\\n     * @pure\\n     *\/\\n    public function fromHex(string $hex): string;\\n\\n    \/**\\n     * Converts a string integer representation into a hexadecimal string representation of the number\\n     *\\n     * @param string $number A string integer representation to convert; this must be a numeric string to accommodate\\n     *     unsigned integers that are greater than `PHP_INT_MAX`.\\n     *\\n     * @return non-empty-string Hexadecimal string\\n     *\\n     * @pure\\n     *\/\\n    public function toHex(string $number): string;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/FeatureSet.php\",\"ext\":\"php\",\"size\":12346,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid;\\n\\nuse Ramsey\\\\Uuid\\\\Builder\\\\FallbackBuilder;\\nuse Ramsey\\\\Uuid\\\\Builder\\\\UuidBuilderInterface;\\nuse Ramsey\\\\Uuid\\\\Codec\\\\CodecInterface;\\nuse Ramsey\\\\Uuid\\\\Codec\\\\GuidStringCodec;\\nuse Ramsey\\\\Uuid\\\\Codec\\\\StringCodec;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\Number\\\\GenericNumberConverter;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\NumberConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\Time\\\\GenericTimeConverter;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\Time\\\\PhpTimeConverter;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\TimeConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Generator\\\\DceSecurityGenerator;\\nuse Ramsey\\\\Uuid\\\\Generator\\\\DceSecurityGeneratorInterface;\\nuse Ramsey\\\\Uuid\\\\Generator\\\\NameGeneratorFactory;\\nuse Ramsey\\\\Uuid\\\\Generator\\\\NameGeneratorInterface;\\nuse Ramsey\\\\Uuid\\\\Generator\\\\PeclUuidNameGenerator;\\nuse Ramsey\\\\Uuid\\\\Generator\\\\PeclUuidRandomGenerator;\\nuse Ramsey\\\\Uuid\\\\Generator\\\\PeclUuidTimeGenerator;\\nuse Ramsey\\\\Uuid\\\\Generator\\\\RandomGeneratorFactory;\\nuse Ramsey\\\\Uuid\\\\Generator\\\\RandomGeneratorInterface;\\nuse Ramsey\\\\Uuid\\\\Generator\\\\TimeGeneratorFactory;\\nuse Ramsey\\\\Uuid\\\\Generator\\\\TimeGeneratorInterface;\\nuse Ramsey\\\\Uuid\\\\Generator\\\\UnixTimeGenerator;\\nuse Ramsey\\\\Uuid\\\\Guid\\\\GuidBuilder;\\nuse Ramsey\\\\Uuid\\\\Math\\\\BrickMathCalculator;\\nuse Ramsey\\\\Uuid\\\\Math\\\\CalculatorInterface;\\nuse Ramsey\\\\Uuid\\\\Nonstandard\\\\UuidBuilder as NonstandardUuidBuilder;\\nuse Ramsey\\\\Uuid\\\\Provider\\\\Dce\\\\SystemDceSecurityProvider;\\nuse Ramsey\\\\Uuid\\\\Provider\\\\DceSecurityProviderInterface;\\nuse Ramsey\\\\Uuid\\\\Provider\\\\Node\\\\FallbackNodeProvider;\\nuse Ramsey\\\\Uuid\\\\Provider\\\\Node\\\\RandomNodeProvider;\\nuse Ramsey\\\\Uuid\\\\Provider\\\\Node\\\\SystemNodeProvider;\\nuse Ramsey\\\\Uuid\\\\Provider\\\\NodeProviderInterface;\\nuse Ramsey\\\\Uuid\\\\Provider\\\\Time\\\\SystemTimeProvider;\\nuse Ramsey\\\\Uuid\\\\Provider\\\\TimeProviderInterface;\\nuse Ramsey\\\\Uuid\\\\Rfc4122\\\\UuidBuilder as Rfc4122UuidBuilder;\\nuse Ramsey\\\\Uuid\\\\Validator\\\\GenericValidator;\\nuse Ramsey\\\\Uuid\\\\Validator\\\\ValidatorInterface;\\n\\nuse const PHP_INT_SIZE;\\n\\n\/**\\n * FeatureSet detects and exposes available features in the current environment\\n *\\n * A feature set is used by UuidFactory to determine the available features and capabilities of the environment.\\n *\/\\nclass FeatureSet\\n{\\n    private ?TimeProviderInterface $timeProvider = null;\\n    private CalculatorInterface $calculator;\\n    private CodecInterface $codec;\\n    private DceSecurityGeneratorInterface $dceSecurityGenerator;\\n    private NameGeneratorInterface $nameGenerator;\\n    private NodeProviderInterface $nodeProvider;\\n    private NumberConverterInterface $numberConverter;\\n    private RandomGeneratorInterface $randomGenerator;\\n    private TimeConverterInterface $timeConverter;\\n    private TimeGeneratorInterface $timeGenerator;\\n    private TimeGeneratorInterface $unixTimeGenerator;\\n    private UuidBuilderInterface $builder;\\n    private ValidatorInterface $validator;\\n\\n    \/**\\n     * @param bool $useGuids True build UUIDs using the GuidStringCodec\\n     * @param bool $force32Bit True to force the use of 32-bit functionality (primarily for testing purposes)\\n     * @param bool $forceNoBigNumber (obsolete)\\n     * @param bool $ignoreSystemNode True to disable attempts to check for the system node ID (primarily for testing purposes)\\n     * @param bool $enablePecl True to enable the use of the PeclUuidTimeGenerator to generate version 1 UUIDs\\n     *\\n     * @phpstan-ignore constructor.unusedParameter ($forceNoBigNumber is deprecated)\\n     *\/\\n    public function __construct(\\n        bool $useGuids = false,\\n        private bool $force32Bit = false,\\n        bool $forceNoBigNumber = false,\\n        private bool $ignoreSystemNode = false,\\n        private bool $enablePecl = false,\\n    ) {\\n        $this->randomGenerator = $this->buildRandomGenerator();\\n        $this->setCalculator(new BrickMathCalculator());\\n        $this->builder = $this->buildUuidBuilder($useGuids);\\n        $this->codec = $this->buildCodec($useGuids);\\n        $this->nodeProvider = $this->buildNodeProvider();\\n        $this->nameGenerator = $this->buildNameGenerator();\\n        $this->setTimeProvider(new SystemTimeProvider());\\n        $this->setDceSecurityProvider(new SystemDceSecurityProvider());\\n        $this->validator = new GenericValidator();\\n\\n        assert($this->timeProvider !== null);\\n        $this->unixTimeGenerator = $this->buildUnixTimeGenerator();\\n    }\\n\\n    \/**\\n     * Returns the builder configured for this environment\\n     *\/\\n    public function getBuilder(): UuidBuilderInterface\\n    {\\n        return $this->builder;\\n    }\\n\\n    \/**\\n     * Returns the calculator configured for this environment\\n     *\/\\n    public function getCalculator(): CalculatorInterface\\n    {\\n        return $this->calculator;\\n    }\\n\\n    \/**\\n     * Returns the codec configured for this environment\\n     *\/\\n    public function getCodec(): CodecInterface\\n    {\\n        return $this->codec;\\n    }\\n\\n    \/**\\n     * Returns the DCE Security generator configured for this environment\\n     *\/\\n    public function getDceSecurityGenerator(): DceSecurityGeneratorInterface\\n    {\\n        return $this->dceSecurityGenerator;\\n    }\\n\\n    \/**\\n     * Returns the name generator configured for this environment\\n     *\/\\n    public function getNameGenerator(): NameGeneratorInterface\\n    {\\n        return $this->nameGenerator;\\n    }\\n\\n    \/**\\n     * Returns the node provider configured for this environment\\n     *\/\\n    public function getNodeProvider(): NodeProviderInterface\\n    {\\n        return $this->nodeProvider;\\n    }\\n\\n    \/**\\n     * Returns the number converter configured for this environment\\n     *\/\\n    public function getNumberConverter(): NumberConverterInterface\\n    {\\n        return $this->numberConverter;\\n    }\\n\\n    \/**\\n     * Returns the random generator configured for this environment\\n     *\/\\n    public function getRandomGenerator(): RandomGeneratorInterface\\n    {\\n        return $this->randomGenerator;\\n    }\\n\\n    \/**\\n     * Returns the time converter configured for this environment\\n     *\/\\n    public function getTimeConverter(): TimeConverterInterface\\n    {\\n        return $this->timeConverter;\\n    }\\n\\n    \/**\\n     * Returns the time generator configured for this environment\\n     *\/\\n    public function getTimeGenerator(): TimeGeneratorInterface\\n    {\\n        return $this->timeGenerator;\\n    }\\n\\n    \/**\\n     * Returns the Unix Epoch time generator configured for this environment\\n     *\/\\n    public function getUnixTimeGenerator(): TimeGeneratorInterface\\n    {\\n        return $this->unixTimeGenerator;\\n    }\\n\\n    \/**\\n     * Returns the validator configured for this environment\\n     *\/\\n    public function getValidator(): ValidatorInterface\\n    {\\n        return $this->validator;\\n    }\\n\\n    \/**\\n     * Sets the calculator to use in this environment\\n     *\/\\n    public function setCalculator(CalculatorInterface $calculator): void\\n    {\\n        $this->calculator = $calculator;\\n        $this->numberConverter = $this->buildNumberConverter($calculator);\\n        $this->timeConverter = $this->buildTimeConverter($calculator);\\n\\n        if (isset($this->timeProvider)) {\\n            $this->timeGenerator = $this->buildTimeGenerator($this->timeProvider);\\n        }\\n    }\\n\\n    \/**\\n     * Sets the DCE Security provider to use in this environment\\n     *\/\\n    public function setDceSecurityProvider(DceSecurityProviderInterface $dceSecurityProvider): void\\n    {\\n        $this->dceSecurityGenerator = $this->buildDceSecurityGenerator($dceSecurityProvider);\\n    }\\n\\n    \/**\\n     * Sets the node provider to use in this environment\\n     *\/\\n    public function setNodeProvider(NodeProviderInterface $nodeProvider): void\\n    {\\n        $this->nodeProvider = $nodeProvider;\\n\\n        if (isset($this->timeProvider)) {\\n            $this->timeGenerator = $this->buildTimeGenerator($this->timeProvider);\\n        }\\n    }\\n\\n    \/**\\n     * Sets the time provider to use in this environment\\n     *\/\\n    public function setTimeProvider(TimeProviderInterface $timeProvider): void\\n    {\\n        $this->timeProvider = $timeProvider;\\n        $this->timeGenerator = $this->buildTimeGenerator($timeProvider);\\n    }\\n\\n    \/**\\n     * Set the validator to use in this environment\\n     *\/\\n    public function setValidator(ValidatorInterface $validator): void\\n    {\\n        $this->validator = $validator;\\n    }\\n\\n    \/**\\n     * Returns a codec configured for this environment\\n     *\\n     * @param bool $useGuids Whether to build UUIDs using the GuidStringCodec\\n     *\/\\n    private function buildCodec(bool $useGuids = false): CodecInterface\\n    {\\n        if ($useGuids) {\\n            return new GuidStringCodec($this->builder);\\n        }\\n\\n        return new StringCodec($this->builder);\\n    }\\n\\n    \/**\\n     * Returns a DCE Security generator configured for this environment\\n     *\/\\n    private function buildDceSecurityGenerator(\\n        DceSecurityProviderInterface $dceSecurityProvider,\\n    ): DceSecurityGeneratorInterface {\\n        return new DceSecurityGenerator($this->numberConverter, $this->timeGenerator, $dceSecurityProvider);\\n    }\\n\\n    \/**\\n     * Returns a node provider configured for this environment\\n     *\/\\n    private function buildNodeProvider(): NodeProviderInterface\\n    {\\n        if ($this->ignoreSystemNode) {\\n            return new RandomNodeProvider();\\n        }\\n\\n        return new FallbackNodeProvider([new SystemNodeProvider(), new RandomNodeProvider()]);\\n    }\\n\\n    \/**\\n     * Returns a number converter configured for this environment\\n     *\/\\n    private function buildNumberConverter(CalculatorInterface $calculator): NumberConverterInterface\\n    {\\n        return new GenericNumberConverter($calculator);\\n    }\\n\\n    \/**\\n     * Returns a random generator configured for this environment\\n     *\/\\n    private function buildRandomGenerator(): RandomGeneratorInterface\\n    {\\n        if ($this->enablePecl) {\\n            return new PeclUuidRandomGenerator();\\n        }\\n\\n        return (new RandomGeneratorFactory())->getGenerator();\\n    }\\n\\n    \/**\\n     * Returns a time generator configured for this environment\\n     *\\n     * @param TimeProviderInterface $timeProvider The time provider to use with\\n     *     the time generator\\n     *\/\\n    private function buildTimeGenerator(TimeProviderInterface $timeProvider): TimeGeneratorInterface\\n    {\\n        if ($this->enablePecl) {\\n            return new PeclUuidTimeGenerator();\\n        }\\n\\n        return (new TimeGeneratorFactory($this->nodeProvider, $this->timeConverter, $timeProvider))->getGenerator();\\n    }\\n\\n    \/**\\n     * Returns a Unix Epoch time generator configured for this environment\\n     *\/\\n    private function buildUnixTimeGenerator(): TimeGeneratorInterface\\n    {\\n        return new UnixTimeGenerator($this->randomGenerator);\\n    }\\n\\n    \/**\\n     * Returns a name generator configured for this environment\\n     *\/\\n    private function buildNameGenerator(): NameGeneratorInterface\\n    {\\n        if ($this->enablePecl) {\\n            return new PeclUuidNameGenerator();\\n        }\\n\\n        return (new NameGeneratorFactory())->getGenerator();\\n    }\\n\\n    \/**\\n     * Returns a time converter configured for this environment\\n     *\/\\n    private function buildTimeConverter(CalculatorInterface $calculator): TimeConverterInterface\\n    {\\n        $genericConverter = new GenericTimeConverter($calculator);\\n\\n        if ($this->is64BitSystem()) {\\n            return new PhpTimeConverter($calculator, $genericConverter);\\n        }\\n\\n        return $genericConverter;\\n    }\\n\\n    \/**\\n     * Returns a UUID builder configured for this environment\\n     *\\n     * @param bool $useGuids Whether to build UUIDs using the GuidStringCodec\\n     *\/\\n    private function buildUuidBuilder(bool $useGuids = false): UuidBuilderInterface\\n    {\\n        if ($useGuids) {\\n            return new GuidBuilder($this->numberConverter, $this->timeConverter);\\n        }\\n\\n        return new FallbackBuilder([\\n            new Rfc4122UuidBuilder($this->numberConverter, $this->timeConverter),\\n            new NonstandardUuidBuilder($this->numberConverter, $this->timeConverter),\\n        ]);\\n    }\\n\\n    \/**\\n     * Returns true if the PHP build is 64-bit\\n     *\/\\n    private function is64BitSystem(): bool\\n    {\\n        return PHP_INT_SIZE === 8 && !$this->force32Bit;\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/BinaryUtils.php\",\"ext\":\"php\",\"size\":1565,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid;\\n\\n\/**\\n * Provides binary math utilities\\n *\/\\nclass BinaryUtils\\n{\\n    \/**\\n     * Applies the variant field to the 16-bit clock sequence\\n     *\\n     * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-4.1 RFC 9562, 4.1. Variant Field\\n     *\\n     * @param int $clockSeq The 16-bit clock sequence value before the variant is applied\\n     *\\n     * @return int The 16-bit clock sequence multiplexed with the UUID variant\\n     *\\n     * @pure\\n     *\/\\n    public static function applyVariant(int $clockSeq): int\\n    {\\n        return ($clockSeq & 0x3fff) | 0x8000;\\n    }\\n\\n    \/**\\n     * Applies the version field to the 16-bit `time_hi_and_version` field\\n     *\\n     * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-4.2 RFC 9562, 4.2. Version Field\\n     *\\n     * @param int $timeHi The value of the 16-bit `time_hi_and_version` field before the version is applied\\n     * @param int $version The version to apply to the `time_hi` field\\n     *\\n     * @return int The 16-bit time_hi field of the timestamp multiplexed with the UUID version number\\n     *\\n     * @pure\\n     *\/\\n    public static function applyVersion(int $timeHi, int $version): int\\n    {\\n        return ($timeHi & 0x0fff) | ($version << 12);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Provider\/Time\/FixedTimeProvider.php\",\"ext\":\"php\",\"size\":1404,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Provider\\\\Time;\\n\\nuse Ramsey\\\\Uuid\\\\Provider\\\\TimeProviderInterface;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Integer as IntegerObject;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Time;\\n\\n\/**\\n * FixedTimeProvider uses a known time to provide the time\\n *\\n * This provider allows the use of a previously generated, or known, time when generating time-based UUIDs.\\n *\/\\nclass FixedTimeProvider implements TimeProviderInterface\\n{\\n    public function __construct(private Time $time)\\n    {\\n    }\\n\\n    \/**\\n     * Sets the `usec` component of the time\\n     *\\n     * @param IntegerObject | int | string $value The `usec` value to set\\n     *\/\\n    public function setUsec($value): void\\n    {\\n        $this->time = new Time($this->time->getSeconds(), $value);\\n    }\\n\\n    \/**\\n     * Sets the `sec` component of the time\\n     *\\n     * @param IntegerObject | int | string $value The `sec` value to set\\n     *\/\\n    public function setSec($value): void\\n    {\\n        $this->time = new Time($value, $this->time->getMicroseconds());\\n    }\\n\\n    public function getTime(): Time\\n    {\\n        return $this->time;\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Provider\/Time\/SystemTimeProvider.php\",\"ext\":\"php\",\"size\":758,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Provider\\\\Time;\\n\\nuse Ramsey\\\\Uuid\\\\Provider\\\\TimeProviderInterface;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Time;\\n\\nuse function gettimeofday;\\n\\n\/**\\n * SystemTimeProvider retrieves the current time using built-in PHP functions\\n *\/\\nclass SystemTimeProvider implements TimeProviderInterface\\n{\\n    public function getTime(): Time\\n    {\\n        $time = gettimeofday();\\n\\n        return new Time($time['sec'], $time['usec']);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Provider\/NodeProviderInterface.php\",\"ext\":\"php\",\"size\":652,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Provider;\\n\\nuse Ramsey\\\\Uuid\\\\Type\\\\Hexadecimal;\\n\\n\/**\\n * A node provider retrieves or generates a node ID\\n *\/\\ninterface NodeProviderInterface\\n{\\n    \/**\\n     * Returns a node ID\\n     *\\n     * @return Hexadecimal The node ID as a hexadecimal string\\n     *\/\\n    public function getNode(): Hexadecimal;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Provider\/Node\/StaticNodeProvider.php\",\"ext\":\"php\",\"size\":1791,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Provider\\\\Node;\\n\\nuse Ramsey\\\\Uuid\\\\Exception\\\\InvalidArgumentException;\\nuse Ramsey\\\\Uuid\\\\Provider\\\\NodeProviderInterface;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Hexadecimal;\\n\\nuse function dechex;\\nuse function hexdec;\\nuse function str_pad;\\nuse function substr;\\n\\nuse const STR_PAD_LEFT;\\n\\n\/**\\n * StaticNodeProvider provides a static node value with the multicast bit set\\n *\\n * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-6.10 RFC 9562, 6.10. UUIDs That Do Not Identify the Host\\n *\/\\nclass StaticNodeProvider implements NodeProviderInterface\\n{\\n    private Hexadecimal $node;\\n\\n    \/**\\n     * @param Hexadecimal $node The static node value to use\\n     *\/\\n    public function __construct(Hexadecimal $node)\\n    {\\n        if (strlen($node->toString()) > 12) {\\n            throw new InvalidArgumentException('Static node value cannot be greater than 12 hexadecimal characters');\\n        }\\n\\n        $this->node = $this->setMulticastBit($node);\\n    }\\n\\n    public function getNode(): Hexadecimal\\n    {\\n        return $this->node;\\n    }\\n\\n    \/**\\n     * Set the multicast bit for the static node value\\n     *\/\\n    private function setMulticastBit(Hexadecimal $node): Hexadecimal\\n    {\\n        $nodeHex = str_pad($node->toString(), 12, '0', STR_PAD_LEFT);\\n        $firstOctet = substr($nodeHex, 0, 2);\\n        $firstOctet = str_pad(dechex(hexdec($firstOctet) | 0x01), 2, '0', STR_PAD_LEFT);\\n\\n        return new Hexadecimal($firstOctet . substr($nodeHex, 2));\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Provider\/Node\/NodeProviderCollection.php\",\"ext\":\"php\",\"size\":1904,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Provider\\\\Node;\\n\\nuse Ramsey\\\\Collection\\\\AbstractCollection;\\nuse Ramsey\\\\Uuid\\\\Provider\\\\NodeProviderInterface;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Hexadecimal;\\n\\n\/**\\n * A collection of NodeProviderInterface objects\\n *\\n * @deprecated this class has been deprecated and will be removed in 5.0.0. The use-case for this class comes from a\\n *     pre-`phpstan\/phpstan` and pre-`vimeo\/psalm` ecosystem, in which type safety had to be mostly enforced at runtime:\\n *     that is no longer necessary, now that you can safely verify your code to be correct and use more generic types\\n *     like `iterable<T>` instead.\\n *\\n * @extends AbstractCollection<NodeProviderInterface>\\n *\/\\nclass NodeProviderCollection extends AbstractCollection\\n{\\n    public function getType(): string\\n    {\\n        return NodeProviderInterface::class;\\n    }\\n\\n    \/**\\n     * Re-constructs the object from its serialized form\\n     *\\n     * @param string $serialized The serialized PHP string to unserialize into a UuidInterface instance\\n     *\/\\n    public function unserialize($serialized): void\\n    {\\n        \/** @var array<array-key, NodeProviderInterface> $data *\/\\n        $data = unserialize($serialized, [\\n            'allowed_classes' => [\\n                Hexadecimal::class,\\n                RandomNodeProvider::class,\\n                StaticNodeProvider::class,\\n                SystemNodeProvider::class,\\n            ],\\n        ]);\\n\\n        \/** @phpstan-ignore-next-line *\/\\n        $this->data = array_filter($data, fn ($unserialized): bool => $unserialized instanceof NodeProviderInterface);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Provider\/Node\/FallbackNodeProvider.php\",\"ext\":\"php\",\"size\":1344,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Provider\\\\Node;\\n\\nuse Ramsey\\\\Uuid\\\\Exception\\\\NodeException;\\nuse Ramsey\\\\Uuid\\\\Provider\\\\NodeProviderInterface;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Hexadecimal;\\n\\n\/**\\n * FallbackNodeProvider retrieves the system node ID by stepping through a list of providers until a node ID can be obtained\\n *\/\\nclass FallbackNodeProvider implements NodeProviderInterface\\n{\\n    \/**\\n     * @param iterable<NodeProviderInterface> $providers Array of node providers\\n     *\/\\n    public function __construct(private iterable $providers)\\n    {\\n    }\\n\\n    public function getNode(): Hexadecimal\\n    {\\n        $lastProviderException = null;\\n\\n        foreach ($this->providers as $provider) {\\n            try {\\n                return $provider->getNode();\\n            } catch (NodeException $exception) {\\n                $lastProviderException = $exception;\\n\\n                continue;\\n            }\\n        }\\n\\n        throw new NodeException(message: 'Unable to find a suitable node provider', previous: $lastProviderException);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Provider\/Node\/RandomNodeProvider.php\",\"ext\":\"php\",\"size\":1593,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Provider\\\\Node;\\n\\nuse Ramsey\\\\Uuid\\\\Exception\\\\RandomSourceException;\\nuse Ramsey\\\\Uuid\\\\Provider\\\\NodeProviderInterface;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Hexadecimal;\\nuse Throwable;\\n\\nuse function bin2hex;\\nuse function dechex;\\nuse function hex2bin;\\nuse function hexdec;\\nuse function str_pad;\\nuse function substr;\\n\\nuse const STR_PAD_LEFT;\\n\\n\/**\\n * RandomNodeProvider generates a random node ID\\n *\\n * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-6.10 RFC 9562, 6.10. UUIDs That Do Not Identify the Host\\n *\/\\nclass RandomNodeProvider implements NodeProviderInterface\\n{\\n    public function getNode(): Hexadecimal\\n    {\\n        try {\\n            $nodeBytes = random_bytes(6);\\n        } catch (Throwable $exception) {\\n            throw new RandomSourceException($exception->getMessage(), (int) $exception->getCode(), $exception);\\n        }\\n\\n        \/\/ Split the node bytes for math on 32-bit systems.\\n        $nodeMsb = substr($nodeBytes, 0, 3);\\n        $nodeLsb = substr($nodeBytes, 3);\\n\\n        \/\/ Set the multicast bit; see RFC 9562, section 6.10.\\n        $nodeMsb = hex2bin(str_pad(dechex(hexdec(bin2hex($nodeMsb)) | 0x010000), 6, '0', STR_PAD_LEFT));\\n\\n        return new Hexadecimal(str_pad(bin2hex($nodeMsb . $nodeLsb), 12, '0', STR_PAD_LEFT));\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Provider\/Node\/SystemNodeProvider.php\",\"ext\":\"php\",\"size\":4759,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Provider\\\\Node;\\n\\nuse Ramsey\\\\Uuid\\\\Exception\\\\NodeException;\\nuse Ramsey\\\\Uuid\\\\Provider\\\\NodeProviderInterface;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Hexadecimal;\\n\\nuse function array_filter;\\nuse function array_map;\\nuse function array_walk;\\nuse function count;\\nuse function ob_get_clean;\\nuse function ob_start;\\nuse function preg_match;\\nuse function preg_match_all;\\nuse function reset;\\nuse function str_contains;\\nuse function str_replace;\\nuse function strtolower;\\nuse function strtoupper;\\nuse function substr;\\n\\nuse const GLOB_NOSORT;\\nuse const PREG_PATTERN_ORDER;\\n\\n\/**\\n * SystemNodeProvider retrieves the system node ID, if possible\\n *\\n * The system node ID, or host ID, is often the same as the MAC address for a network interface on the host.\\n *\/\\nclass SystemNodeProvider implements NodeProviderInterface\\n{\\n    \/**\\n     * Pattern to match nodes in `ifconfig` and `ipconfig` output.\\n     *\/\\n    private const IFCONFIG_PATTERN = '\/[^:]([0-9a-f]{2}([:-])[0-9a-f]{2}(\\\\2[0-9a-f]{2}){4})[^:]\/i';\\n\\n    \/**\\n     * Pattern to match nodes in sysfs stream output.\\n     *\/\\n    private const SYSFS_PATTERN = '\/^([0-9a-f]{2}:){5}[0-9a-f]{2}$\/i';\\n\\n    public function getNode(): Hexadecimal\\n    {\\n        $node = $this->getNodeFromSystem();\\n\\n        if ($node === '') {\\n            throw new NodeException('Unable to fetch a node for this system');\\n        }\\n\\n        return new Hexadecimal($node);\\n    }\\n\\n    \/**\\n     * Returns the system node if found\\n     *\/\\n    protected function getNodeFromSystem(): string\\n    {\\n        \/** @var string | null $node *\/\\n        static $node = null;\\n\\n        if ($node !== null) {\\n            return $node;\\n        }\\n\\n        \/\/ First, try a Linux-specific approach.\\n        $node = $this->getSysfs();\\n\\n        if ($node === '') {\\n            \/\/ Search ifconfig output for MAC addresses & return the first one.\\n            $node = $this->getIfconfig();\\n        }\\n\\n        $node = str_replace([':', '-'], '', $node);\\n\\n        return $node;\\n    }\\n\\n    \/**\\n     * Returns the network interface configuration for the system\\n     *\\n     * @codeCoverageIgnore\\n     *\/\\n    protected function getIfconfig(): string\\n    {\\n        if (str_contains(strtolower((string) ini_get('disable_functions')), 'passthru')) {\\n            return '';\\n        }\\n\\n        \/** @var string $phpOs *\/\\n        $phpOs = constant('PHP_OS');\\n\\n        ob_start();\\n        switch (strtoupper(substr($phpOs, 0, 3))) {\\n            case 'WIN':\\n                passthru('ipconfig \/all 2>&1');\\n\\n                break;\\n            case 'DAR':\\n                passthru('ifconfig 2>&1');\\n\\n                break;\\n            case 'FRE':\\n                passthru('netstat -i -f link 2>&1');\\n\\n                break;\\n            case 'LIN':\\n            default:\\n                passthru('netstat -ie 2>&1');\\n\\n                break;\\n        }\\n\\n        $ifconfig = (string) ob_get_clean();\\n\\n        if (preg_match_all(self::IFCONFIG_PATTERN, $ifconfig, $matches, PREG_PATTERN_ORDER)) {\\n            foreach ($matches[1] as $iface) {\\n                if ($iface !== '00:00:00:00:00:00' && $iface !== '00-00-00-00-00-00') {\\n                    return $iface;\\n                }\\n            }\\n        }\\n\\n        return '';\\n    }\\n\\n    \/**\\n     * Returns MAC address from the first system interface via the sysfs interface\\n     *\/\\n    protected function getSysfs(): string\\n    {\\n        \/** @var string $phpOs *\/\\n        $phpOs = constant('PHP_OS');\\n\\n        if (strtoupper($phpOs) !== 'LINUX') {\\n            return '';\\n        }\\n\\n        $addressPaths = glob('\/sys\/class\/net\/*\/address', GLOB_NOSORT);\\n\\n        if ($addressPaths === false || count($addressPaths) === 0) {\\n            return '';\\n        }\\n\\n        \/** @var array<array-key, string> $macs *\/\\n        $macs = [];\\n\\n        array_walk($addressPaths, function (string $addressPath) use (&$macs): void {\\n            if (is_readable($addressPath)) {\\n                $macs[] = file_get_contents($addressPath);\\n            }\\n        });\\n\\n        \/** @var callable $trim *\/\\n        $trim = 'trim';\\n\\n        $macs = array_map($trim, $macs);\\n\\n        \/\/ Remove invalid entries.\\n        $macs = array_filter($macs, function (mixed $address): bool {\\n            assert(is_string($address));\\n\\n            return $address !== '00:00:00:00:00:00' && preg_match(self::SYSFS_PATTERN, $address);\\n        });\\n\\n        \/** @var bool | string $mac *\/\\n        $mac = reset($macs);\\n\\n        return (string) $mac;\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Provider\/DceSecurityProviderInterface.php\",\"ext\":\"php\",\"size\":998,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Provider;\\n\\nuse Ramsey\\\\Uuid\\\\Rfc4122\\\\UuidV2;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Integer as IntegerObject;\\n\\n\/**\\n * A DCE provider provides access to local domain identifiers for version 2, DCE Security, UUIDs\\n *\\n * @see UuidV2\\n *\/\\ninterface DceSecurityProviderInterface\\n{\\n    \/**\\n     * Returns a user identifier for the system\\n     *\\n     * @link https:\/\/en.wikipedia.org\/wiki\/User_identifier User identifier\\n     *\/\\n    public function getUid(): IntegerObject;\\n\\n    \/**\\n     * Returns a group identifier for the system\\n     *\\n     * @link https:\/\/en.wikipedia.org\/wiki\/Group_identifier Group identifier\\n     *\/\\n    public function getGid(): IntegerObject;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Provider\/TimeProviderInterface.php\",\"ext\":\"php\",\"size\":566,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Provider;\\n\\nuse Ramsey\\\\Uuid\\\\Type\\\\Time;\\n\\n\/**\\n * A time provider retrieves the current time\\n *\/\\ninterface TimeProviderInterface\\n{\\n    \/**\\n     * Returns a time object\\n     *\/\\n    public function getTime(): Time;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Provider\/Dce\/SystemDceSecurityProvider.php\",\"ext\":\"php\",\"size\":6498,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Provider\\\\Dce;\\n\\nuse Ramsey\\\\Uuid\\\\Exception\\\\DceSecurityException;\\nuse Ramsey\\\\Uuid\\\\Provider\\\\DceSecurityProviderInterface;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Integer as IntegerObject;\\n\\nuse function escapeshellarg;\\nuse function preg_split;\\nuse function str_getcsv;\\nuse function strrpos;\\nuse function strtolower;\\nuse function strtoupper;\\nuse function substr;\\nuse function trim;\\n\\nuse const PREG_SPLIT_NO_EMPTY;\\n\\n\/**\\n * SystemDceSecurityProvider retrieves the user or group identifiers from the system\\n *\/\\nclass SystemDceSecurityProvider implements DceSecurityProviderInterface\\n{\\n    \/**\\n     * @throws DceSecurityException if unable to get a user identifier\\n     *\\n     * @inheritDoc\\n     *\/\\n    public function getUid(): IntegerObject\\n    {\\n        \/** @var IntegerObject | int | float | string | null $uid *\/\\n        static $uid = null;\\n\\n        if ($uid instanceof IntegerObject) {\\n            return $uid;\\n        }\\n\\n        if ($uid === null) {\\n            $uid = $this->getSystemUid();\\n        }\\n\\n        if ($uid === '') {\\n            throw new DceSecurityException(\\n                'Unable to get a user identifier using the system DCE Security provider; please provide a custom '\\n                . 'identifier or use a different provider',\\n            );\\n        }\\n\\n        $uid = new IntegerObject($uid);\\n\\n        return $uid;\\n    }\\n\\n    \/**\\n     * @throws DceSecurityException if unable to get a group identifier\\n     *\\n     * @inheritDoc\\n     *\/\\n    public function getGid(): IntegerObject\\n    {\\n        \/** @var IntegerObject | int | float | string | null $gid *\/\\n        static $gid = null;\\n\\n        if ($gid instanceof IntegerObject) {\\n            return $gid;\\n        }\\n\\n        if ($gid === null) {\\n            $gid = $this->getSystemGid();\\n        }\\n\\n        if ($gid === '') {\\n            throw new DceSecurityException(\\n                'Unable to get a group identifier using the system DCE Security provider; please provide a custom '\\n                . 'identifier or use a different provider',\\n            );\\n        }\\n\\n        $gid = new IntegerObject($gid);\\n\\n        return $gid;\\n    }\\n\\n    \/**\\n     * Returns the UID from the system\\n     *\/\\n    private function getSystemUid(): string\\n    {\\n        if (!$this->hasShellExec()) {\\n            return '';\\n        }\\n\\n        return match ($this->getOs()) {\\n            'WIN' => $this->getWindowsUid(),\\n            default => trim((string) shell_exec('id -u')),\\n        };\\n    }\\n\\n    \/**\\n     * Returns the GID from the system\\n     *\/\\n    private function getSystemGid(): string\\n    {\\n        if (!$this->hasShellExec()) {\\n            return '';\\n        }\\n\\n        return match ($this->getOs()) {\\n            'WIN' => $this->getWindowsGid(),\\n            default => trim((string) shell_exec('id -g')),\\n        };\\n    }\\n\\n    \/**\\n     * Returns true if shell_exec() is available for use\\n     *\/\\n    private function hasShellExec(): bool\\n    {\\n        return !str_contains(strtolower((string) ini_get('disable_functions')), 'shell_exec');\\n    }\\n\\n    \/**\\n     * Returns the PHP_OS string\\n     *\/\\n    private function getOs(): string\\n    {\\n        \/** @var string $phpOs *\/\\n        $phpOs = constant('PHP_OS');\\n\\n        return strtoupper(substr($phpOs, 0, 3));\\n    }\\n\\n    \/**\\n     * Returns the user identifier for a user on a Windows system\\n     *\\n     * Windows does not have the same concept as an effective POSIX UID for the running script. Instead, each user is\\n     * uniquely identified by an SID (security identifier). The SID includes three 32-bit unsigned integers that make up\\n     * a unique domain identifier, followed by an RID (relative identifier) that we will use as the UID. The primary\\n     * caveat is that this UID may not be unique to the system, since it is, instead, unique to the domain.\\n     *\\n     * @link https:\/\/www.lifewire.com\/what-is-an-sid-number-2626005 What Is an SID Number?\\n     * @link https:\/\/learn.microsoft.com\/en-us\/openspecs\/windows_protocols\/ms-dtyp\/81d92bba-d22b-4a8c-908a-554ab29148ab Well-known SID Structures\\n     * @link https:\/\/learn.microsoft.com\/en-us\/windows-server\/identity\/ad-ds\/manage\/understand-security-identifiers#well-known-sids Well-known SIDs\\n     * @link https:\/\/www.windows-commandline.com\/get-sid-of-user\/ Get SID of user\\n     *\/\\n    private function getWindowsUid(): string\\n    {\\n        $response = shell_exec('whoami \/user \/fo csv \/nh');\\n\\n        if ($response === null) {\\n            return '';\\n        }\\n\\n        $sid = str_getcsv(trim((string) $response), escape: '\\\\\\\\')[1] ?? '';\\n\\n        if (($lastHyphen = strrpos($sid, '-')) === false) {\\n            return '';\\n        }\\n\\n        return trim(substr($sid, $lastHyphen + 1));\\n    }\\n\\n    \/**\\n     * Returns a group identifier for a user on a Windows system\\n     *\\n     * Since Windows does not have the same concept as an effective POSIX GID for the running script, we will get the\\n     * local group memberships for the user running the script. Then, we will get the SID (security identifier) for the\\n     * first group that appears in that list. Finally, we will return the RID (relative identifier) for the group and\\n     * use that as the GID.\\n     *\\n     * @link https:\/\/www.windows-commandline.com\/list-of-user-groups-command-line\/ List of user groups command line\\n     *\/\\n    private function getWindowsGid(): string\\n    {\\n        $response = shell_exec('net user %username% | findstr \/b \/i \\\"Local Group Memberships\\\"');\\n\\n        if ($response === null) {\\n            return '';\\n        }\\n\\n        $userGroups = preg_split('\/\\\\s{2,}\/', (string) $response, -1, PREG_SPLIT_NO_EMPTY);\\n        $firstGroup = trim($userGroups[1] ?? '', \\\"* \\\\t\\\\n\\\\r\\\\0\\\\x0B\\\");\\n\\n        if ($firstGroup === '') {\\n            return '';\\n        }\\n\\n        $response = shell_exec('wmic group get name,sid | findstr \/b \/i ' . escapeshellarg($firstGroup));\\n\\n        if ($response === null) {\\n            return '';\\n        }\\n\\n        $userGroup = preg_split('\/\\\\s{2,}\/', (string) $response, -1, PREG_SPLIT_NO_EMPTY);\\n        $sid = $userGroup[1] ?? '';\\n\\n        if (($lastHyphen = strrpos($sid, '-')) === false) {\\n            return '';\\n        }\\n\\n        return trim(substr($sid, $lastHyphen + 1));\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Uuid.php\",\"ext\":\"php\",\"size\":24503,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid;\\n\\nuse BadMethodCallException;\\nuse DateTimeInterface;\\nuse Ramsey\\\\Uuid\\\\Codec\\\\CodecInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\NumberConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\TimeConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Exception\\\\InvalidArgumentException;\\nuse Ramsey\\\\Uuid\\\\Exception\\\\UnsupportedOperationException;\\nuse Ramsey\\\\Uuid\\\\Fields\\\\FieldsInterface;\\nuse Ramsey\\\\Uuid\\\\Lazy\\\\LazyUuidFromString;\\nuse Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface as Rfc4122FieldsInterface;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Hexadecimal;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Integer as IntegerObject;\\nuse ValueError;\\n\\nuse function assert;\\nuse function bin2hex;\\nuse function method_exists;\\nuse function preg_match;\\nuse function sprintf;\\nuse function str_replace;\\nuse function strcmp;\\nuse function strlen;\\nuse function strtolower;\\nuse function substr;\\n\\n\/**\\n * Uuid provides constants and static methods for working with and generating UUIDs\\n *\\n * @immutable\\n *\/\\nclass Uuid implements UuidInterface\\n{\\n    use DeprecatedUuidMethodsTrait;\\n\\n    \/**\\n     * When this namespace is specified, the name string is a fully qualified domain name\\n     *\\n     * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-6.6 RFC 9562, 6.6. Namespace ID Usage and Allocation\\n     *\/\\n    public const NAMESPACE_DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\\n\\n    \/**\\n     * When this namespace is specified, the name string is a URL\\n     *\\n     * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-6.6 RFC 9562, 6.6. Namespace ID Usage and Allocation\\n     *\/\\n    public const NAMESPACE_URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\\n\\n    \/**\\n     * When this namespace is specified, the name string is an ISO OID\\n     *\\n     * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-6.6 RFC 9562, 6.6. Namespace ID Usage and Allocation\\n     *\/\\n    public const NAMESPACE_OID = '6ba7b812-9dad-11d1-80b4-00c04fd430c8';\\n\\n    \/**\\n     * When this namespace is specified, the name string is an X.500 DN (in DER or a text output format)\\n     *\\n     * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-6.6 RFC 9562, 6.6. Namespace ID Usage and Allocation\\n     *\/\\n    public const NAMESPACE_X500 = '6ba7b814-9dad-11d1-80b4-00c04fd430c8';\\n\\n    \/**\\n     * The Nil UUID is a special form of UUID that is specified to have all 128 bits set to zero\\n     *\\n     * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-5.9 RFC 9562, 5.9. Nil UUID\\n     *\/\\n    public const NIL = '00000000-0000-0000-0000-000000000000';\\n\\n    \/**\\n     * The Max UUID is a special form of UUID that is specified to have all 128 bits set to one\\n     *\\n     * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-5.10 RFC 9562, 5.10. Max UUID\\n     *\/\\n    public const MAX = 'ffffffff-ffff-ffff-ffff-ffffffffffff';\\n\\n    \/**\\n     * Variant: reserved, NCS backward compatibility\\n     *\\n     * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-4.1 RFC 9562, 4.1. Variant Field\\n     *\/\\n    public const RESERVED_NCS = 0;\\n\\n    \/**\\n     * Variant: the UUID layout specified in RFC 9562 (formerly RFC 4122)\\n     *\\n     * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-4.1 RFC 9562, 4.1. Variant Field\\n     * @see Uuid::RFC_9562\\n     *\/\\n    public const RFC_4122 = 2;\\n\\n    \/**\\n     * Variant: the UUID layout specified in RFC 9562 (formerly RFC 4122)\\n     *\\n     * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-4.1 RFC 9562, 4.1. Variant Field\\n     *\/\\n    public const RFC_9562 = 2;\\n\\n    \/**\\n     * Variant: reserved, Microsoft Corporation backward compatibility\\n     *\\n     * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-4.1 RFC 9562, 4.1. Variant Field\\n     *\/\\n    public const RESERVED_MICROSOFT = 6;\\n\\n    \/**\\n     * Variant: reserved for future definition\\n     *\\n     * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-4.1 RFC 9562, 4.1. Variant Field\\n     *\/\\n    public const RESERVED_FUTURE = 7;\\n\\n    \/**\\n     * @deprecated Use {@see ValidatorInterface::getPattern()} instead.\\n     *\/\\n    public const VALID_PATTERN = '^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}$';\\n\\n    \/**\\n     * Version 1 (Gregorian time) UUID\\n     *\\n     * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-4.2 RFC 9562, 4.2. Version Field\\n     *\/\\n    public const UUID_TYPE_TIME = 1;\\n\\n    \/**\\n     * Version 2 (DCE Security) UUID\\n     *\\n     * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-4.2 RFC 9562, 4.2. Version Field\\n     *\/\\n    public const UUID_TYPE_DCE_SECURITY = 2;\\n\\n    \/**\\n     * @deprecated Use {@see Uuid::UUID_TYPE_DCE_SECURITY} instead.\\n     *\/\\n    public const UUID_TYPE_IDENTIFIER = 2;\\n\\n    \/**\\n     * Version 3 (name-based and hashed with MD5) UUID\\n     *\\n     * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-4.2 RFC 9562, 4.2. Version Field\\n     *\/\\n    public const UUID_TYPE_HASH_MD5 = 3;\\n\\n    \/**\\n     * Version 4 (random) UUID\\n     *\\n     * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-4.2 RFC 9562, 4.2. Version Field\\n     *\/\\n    public const UUID_TYPE_RANDOM = 4;\\n\\n    \/**\\n     * Version 5 (name-based and hashed with SHA1) UUID\\n     *\\n     * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-4.2 RFC 9562, 4.2. Version Field\\n     *\/\\n    public const UUID_TYPE_HASH_SHA1 = 5;\\n\\n    \/**\\n     * @deprecated Use {@see Uuid::UUID_TYPE_REORDERED_TIME} instead.\\n     *\/\\n    public const UUID_TYPE_PEABODY = 6;\\n\\n    \/**\\n     * Version 6 (reordered Gregorian time) UUID\\n     *\\n     * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-4.2 RFC 9562, 4.2. Version Field\\n     *\/\\n    public const UUID_TYPE_REORDERED_TIME = 6;\\n\\n    \/**\\n     * Version 7 (Unix Epoch time) UUID\\n     *\\n     * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-4.2 RFC 9562, 4.2. Version Field\\n     *\/\\n    public const UUID_TYPE_UNIX_TIME = 7;\\n\\n    \/**\\n     * Version 8 (custom format) UUID\\n     *\\n     * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-4.2 RFC 9562, 4.2. Version Field\\n     *\/\\n    public const UUID_TYPE_CUSTOM = 8;\\n\\n    \/**\\n     * DCE Security principal domain\\n     *\\n     * @link https:\/\/pubs.opengroup.org\/onlinepubs\/9696989899\/chap11.htm#tagcjh_14_05_01_01 DCE 1.1, \u00a711.5.1.1\\n     *\/\\n    public const DCE_DOMAIN_PERSON = 0;\\n\\n    \/**\\n     * DCE Security group domain\\n     *\\n     * @link https:\/\/pubs.opengroup.org\/onlinepubs\/9696989899\/chap11.htm#tagcjh_14_05_01_01 DCE 1.1, \u00a711.5.1.1\\n     *\/\\n    public const DCE_DOMAIN_GROUP = 1;\\n\\n    \/**\\n     * DCE Security organization domain\\n     *\\n     * @link https:\/\/pubs.opengroup.org\/onlinepubs\/9696989899\/chap11.htm#tagcjh_14_05_01_01 DCE 1.1, \u00a711.5.1.1\\n     *\/\\n    public const DCE_DOMAIN_ORG = 2;\\n\\n    \/**\\n     * DCE Security domain string names\\n     *\\n     * @link https:\/\/pubs.opengroup.org\/onlinepubs\/9696989899\/chap11.htm#tagcjh_14_05_01_01 DCE 1.1, \u00a711.5.1.1\\n     *\/\\n    public const DCE_DOMAIN_NAMES = [\\n        self::DCE_DOMAIN_PERSON => 'person',\\n        self::DCE_DOMAIN_GROUP => 'group',\\n        self::DCE_DOMAIN_ORG => 'org',\\n    ];\\n\\n    \/**\\n     * @phpstan-ignore property.readOnlyByPhpDocDefaultValue\\n     *\/\\n    private static ?UuidFactoryInterface $factory = null;\\n\\n    \/**\\n     * @var bool flag to detect if the UUID factory was replaced internally, which disables all optimizations for the\\n     *     default\/happy path internal scenarios\\n     * @phpstan-ignore property.readOnlyByPhpDocDefaultValue\\n     *\/\\n    private static bool $factoryReplaced = false;\\n\\n    protected CodecInterface $codec;\\n    protected NumberConverterInterface $numberConverter;\\n    protected Rfc4122FieldsInterface $fields;\\n    protected TimeConverterInterface $timeConverter;\\n\\n    \/**\\n     * Creates a universally unique identifier (UUID) from an array of fields\\n     *\\n     * Unless you're making advanced use of this library to generate identifiers that deviate from RFC 9562 (formerly\\n     * RFC 4122), you probably do not want to instantiate a UUID directly. Use the static methods, instead:\\n     *\\n     * ```\\n     * use Ramsey\\\\Uuid\\\\Uuid;\\n     *\\n     * $timeBasedUuid = Uuid::uuid1();\\n     * $namespaceMd5Uuid = Uuid::uuid3(Uuid::NAMESPACE_URL, 'http:\/\/php.net\/');\\n     * $randomUuid = Uuid::uuid4();\\n     * $namespaceSha1Uuid = Uuid::uuid5(Uuid::NAMESPACE_URL, 'http:\/\/php.net\/');\\n     * ```\\n     *\\n     * @param Rfc4122FieldsInterface $fields The fields from which to construct a UUID\\n     * @param NumberConverterInterface $numberConverter The number converter to use for converting hex values to\/from integers\\n     * @param CodecInterface $codec The codec to use when encoding or decoding UUID strings\\n     * @param TimeConverterInterface $timeConverter The time converter to use for converting timestamps extracted from a\\n     *     UUID to unix timestamps\\n     *\/\\n    public function __construct(\\n        Rfc4122FieldsInterface $fields,\\n        NumberConverterInterface $numberConverter,\\n        CodecInterface $codec,\\n        TimeConverterInterface $timeConverter,\\n    ) {\\n        $this->fields = $fields;\\n        $this->codec = $codec;\\n        $this->numberConverter = $numberConverter;\\n        $this->timeConverter = $timeConverter;\\n    }\\n\\n    \/**\\n     * @return non-empty-string\\n     *\/\\n    public function __toString(): string\\n    {\\n        return $this->toString();\\n    }\\n\\n    \/**\\n     * Converts the UUID to a string for JSON serialization\\n     *\/\\n    public function jsonSerialize(): string\\n    {\\n        return $this->toString();\\n    }\\n\\n    \/**\\n     * Converts the UUID to a string for PHP serialization\\n     *\/\\n    public function serialize(): string\\n    {\\n        return $this->codec->encode($this);\\n    }\\n\\n    \/**\\n     * @return array{bytes: string}\\n     *\/\\n    public function __serialize(): array\\n    {\\n        return ['bytes' => $this->serialize()];\\n    }\\n\\n    \/**\\n     * Re-constructs the object from its serialized form\\n     *\\n     * @param string $data The serialized PHP string to unserialize into a UuidInterface instance\\n     *\/\\n    public function unserialize(string $data): void\\n    {\\n        if (strlen($data) === 16) {\\n            \/** @var Uuid $uuid *\/\\n            $uuid = self::getFactory()->fromBytes($data);\\n        } else {\\n            \/** @var Uuid $uuid *\/\\n            $uuid = self::getFactory()->fromString($data);\\n        }\\n\\n        \/** @phpstan-ignore property.readOnlyByPhpDocAssignNotInConstructor *\/\\n        $this->codec = $uuid->codec;\\n\\n        \/** @phpstan-ignore property.readOnlyByPhpDocAssignNotInConstructor *\/\\n        $this->numberConverter = $uuid->numberConverter;\\n\\n        \/** @phpstan-ignore property.readOnlyByPhpDocAssignNotInConstructor *\/\\n        $this->fields = $uuid->fields;\\n\\n        \/** @phpstan-ignore property.readOnlyByPhpDocAssignNotInConstructor *\/\\n        $this->timeConverter = $uuid->timeConverter;\\n    }\\n\\n    \/**\\n     * @param array{bytes?: string} $data\\n     *\/\\n    public function __unserialize(array $data): void\\n    {\\n        \/\/ @codeCoverageIgnoreStart\\n        if (!isset($data['bytes'])) {\\n            throw new ValueError(sprintf('%s(): Argument #1 ($data) is invalid', __METHOD__));\\n        }\\n        \/\/ @codeCoverageIgnoreEnd\\n\\n        $this->unserialize($data['bytes']);\\n    }\\n\\n    public function compareTo(UuidInterface $other): int\\n    {\\n        $compare = strcmp($this->toString(), $other->toString());\\n\\n        if ($compare < 0) {\\n            return -1;\\n        }\\n\\n        if ($compare > 0) {\\n            return 1;\\n        }\\n\\n        return 0;\\n    }\\n\\n    public function equals(?object $other): bool\\n    {\\n        if (!$other instanceof UuidInterface) {\\n            return false;\\n        }\\n\\n        return $this->compareTo($other) === 0;\\n    }\\n\\n    \/**\\n     * @return non-empty-string\\n     *\/\\n    public function getBytes(): string\\n    {\\n        return $this->codec->encodeBinary($this);\\n    }\\n\\n    public function getFields(): FieldsInterface\\n    {\\n        return $this->fields;\\n    }\\n\\n    public function getHex(): Hexadecimal\\n    {\\n        return new Hexadecimal(str_replace('-', '', $this->toString()));\\n    }\\n\\n    public function getInteger(): IntegerObject\\n    {\\n        return new IntegerObject($this->numberConverter->fromHex($this->getHex()->toString()));\\n    }\\n\\n    public function getUrn(): string\\n    {\\n        return 'urn:uuid:' . $this->toString();\\n    }\\n\\n    \/**\\n     * @return non-empty-string\\n     *\/\\n    public function toString(): string\\n    {\\n        return $this->codec->encode($this);\\n    }\\n\\n    \/**\\n     * Returns the factory used to create UUIDs\\n     *\/\\n    public static function getFactory(): UuidFactoryInterface\\n    {\\n        if (self::$factory === null) {\\n            self::$factory = new UuidFactory();\\n        }\\n\\n        return self::$factory;\\n    }\\n\\n    \/**\\n     * Sets the factory used to create UUIDs\\n     *\\n     * @param UuidFactoryInterface $factory A factory that will be used by this class to create UUIDs\\n     *\/\\n    public static function setFactory(UuidFactoryInterface $factory): void\\n    {\\n        \/\/ Note: non-strict equality is intentional here. If the factory is configured differently, every assumption\\n        \/\/       around purity is broken, and we have to internally decide everything differently.\\n        \/\/ phpcs:ignore SlevomatCodingStandard.Operators.DisallowEqualOperators.DisallowedNotEqualOperator\\n        self::$factoryReplaced = ($factory != new UuidFactory());\\n\\n        self::$factory = $factory;\\n    }\\n\\n    \/**\\n     * Creates a UUID from a byte string\\n     *\\n     * @param string $bytes A binary string\\n     *\\n     * @return UuidInterface A UuidInterface instance created from a binary string representation\\n     *\\n     * @throws InvalidArgumentException\\n     *\\n     * @pure\\n     *\/\\n    public static function fromBytes(string $bytes): UuidInterface\\n    {\\n        \/** @phpstan-ignore impure.staticPropertyAccess *\/\\n        if (!self::$factoryReplaced && strlen($bytes) === 16) {\\n            $base16Uuid = bin2hex($bytes);\\n\\n            \/\/ Note: we are calling `fromString` internally because we don't know if the given `$bytes` is a valid UUID\\n            return self::fromString(\\n                substr($base16Uuid, 0, 8)\\n                    . '-'\\n                    . substr($base16Uuid, 8, 4)\\n                    . '-'\\n                    . substr($base16Uuid, 12, 4)\\n                    . '-'\\n                    . substr($base16Uuid, 16, 4)\\n                    . '-'\\n                    . substr($base16Uuid, 20, 12),\\n            );\\n        }\\n\\n        \/** @phpstan-ignore possiblyImpure.methodCall *\/\\n        return self::getFactory()->fromBytes($bytes);\\n    }\\n\\n    \/**\\n     * Creates a UUID from the string standard representation\\n     *\\n     * @param string $uuid A hexadecimal string\\n     *\\n     * @return UuidInterface A UuidInterface instance created from a hexadecimal string representation\\n     *\\n     * @throws InvalidArgumentException\\n     *\\n     * @pure\\n     *\/\\n    public static function fromString(string $uuid): UuidInterface\\n    {\\n        $uuid = strtolower($uuid);\\n        \/** @phpstan-ignore impure.staticPropertyAccess, possiblyImpure.functionCall *\/\\n        if (!self::$factoryReplaced && preg_match(LazyUuidFromString::VALID_REGEX, $uuid) === 1) {\\n            \/** @phpstan-ignore possiblyImpure.functionCall *\/\\n            assert($uuid !== '');\\n\\n            \/** @phpstan-ignore possiblyImpure.new *\/\\n            return new LazyUuidFromString($uuid);\\n        }\\n\\n        \/** @phpstan-ignore possiblyImpure.methodCall *\/\\n        return self::getFactory()->fromString($uuid);\\n    }\\n\\n    \/**\\n     * Creates a UUID from a DateTimeInterface instance\\n     *\\n     * @param DateTimeInterface $dateTime The date and time\\n     * @param Hexadecimal | null $node A 48-bit number representing the hardware address\\n     * @param int | null $clockSeq A 14-bit number used to help avoid duplicates that could arise when the clock is set\\n     *     backwards in time or if the node ID changes\\n     *\\n     * @return UuidInterface A UuidInterface instance that represents a version 1 UUID created from a DateTimeInterface instance\\n     *\/\\n    public static function fromDateTime(\\n        DateTimeInterface $dateTime,\\n        ?Hexadecimal $node = null,\\n        ?int $clockSeq = null\\n    ): UuidInterface {\\n        return self::getFactory()->fromDateTime($dateTime, $node, $clockSeq);\\n    }\\n\\n    \/**\\n     * Creates a UUID from the Hexadecimal object\\n     *\\n     * @param Hexadecimal $hex Hexadecimal object representing a hexadecimal number\\n     *\\n     * @return UuidInterface A UuidInterface instance created from the Hexadecimal object representing a hexadecimal number\\n     *\\n     * @throws InvalidArgumentException\\n     *\\n     * @pure\\n     *\/\\n    public static function fromHexadecimal(Hexadecimal $hex): UuidInterface\\n    {\\n        \/** @phpstan-ignore possiblyImpure.methodCall *\/\\n        $factory = self::getFactory();\\n\\n        if (method_exists($factory, 'fromHexadecimal')) {\\n            \/** @phpstan-ignore possiblyImpure.methodCall *\/\\n            $uuid = $factory->fromHexadecimal($hex);\\n            \/** @phpstan-ignore possiblyImpure.functionCall *\/\\n            assert($uuid instanceof UuidInterface);\\n\\n            return $uuid;\\n        }\\n\\n        throw new BadMethodCallException('The method fromHexadecimal() does not exist on the provided factory');\\n    }\\n\\n    \/**\\n     * Creates a UUID from a 128-bit integer string\\n     *\\n     * @param string $integer String representation of 128-bit integer\\n     *\\n     * @return UuidInterface A UuidInterface instance created from the string representation of a 128-bit integer\\n     *\\n     * @throws InvalidArgumentException\\n     *\\n     * @pure\\n     *\/\\n    public static function fromInteger(string $integer): UuidInterface\\n    {\\n        \/** @phpstan-ignore possiblyImpure.methodCall *\/\\n        return self::getFactory()->fromInteger($integer);\\n    }\\n\\n    \/**\\n     * Returns true if the provided string is a valid UUID\\n     *\\n     * @param string $uuid A string to validate as a UUID\\n     *\\n     * @return bool True if the string is a valid UUID, false otherwise\\n     *\\n     * @phpstan-assert-if-true =non-empty-string $uuid\\n     *\\n     * @pure\\n     *\/\\n    public static function isValid(string $uuid): bool\\n    {\\n        \/** @phpstan-ignore possiblyImpure.methodCall, possiblyImpure.methodCall *\/\\n        return self::getFactory()->getValidator()->validate($uuid);\\n    }\\n\\n    \/**\\n     * Returns a version 1 (Gregorian time) UUID from a host ID, sequence number, and the current time\\n     *\\n     * @param Hexadecimal | int | string | null $node A 48-bit number representing the hardware address; this number may\\n     *     be represented as an integer or a hexadecimal string\\n     * @param int | null $clockSeq A 14-bit number used to help avoid duplicates that could arise when the clock is set\\n     *     backwards in time or if the node ID changes\\n     *\\n     * @return UuidInterface A UuidInterface instance that represents a version 1 UUID\\n     *\/\\n    public static function uuid1($node = null, ?int $clockSeq = null): UuidInterface\\n    {\\n        return self::getFactory()->uuid1($node, $clockSeq);\\n    }\\n\\n    \/**\\n     * Returns a version 2 (DCE Security) UUID from a local domain, local identifier, host ID, clock sequence, and the current time\\n     *\\n     * @param int $localDomain The local domain to use when generating bytes, according to DCE Security\\n     * @param IntegerObject | null $localIdentifier The local identifier for the given domain; this may be a UID or GID\\n     *     on POSIX systems, if the local domain is \\\"person\\\" or \\\"group,\\\" or it may be a site-defined identifier if the\\n     *     local domain is \\\"org\\\"\\n     * @param Hexadecimal | null $node A 48-bit number representing the hardware address\\n     * @param int | null $clockSeq A 14-bit number used to help avoid duplicates that could arise when the clock is set\\n     *     backwards in time or if the node ID changes (in a version 2 UUID, the lower 8 bits of this number are\\n     *     replaced with the domain).\\n     *\\n     * @return UuidInterface A UuidInterface instance that represents a version 2 UUID\\n     *\/\\n    public static function uuid2(\\n        int $localDomain,\\n        ?IntegerObject $localIdentifier = null,\\n        ?Hexadecimal $node = null,\\n        ?int $clockSeq = null\\n    ): UuidInterface {\\n        return self::getFactory()->uuid2($localDomain, $localIdentifier, $node, $clockSeq);\\n    }\\n\\n    \/**\\n     * Returns a version 3 (name-based) UUID based on the MD5 hash of a namespace ID and a name\\n     *\\n     * @param UuidInterface | string $ns The namespace (must be a valid UUID)\\n     * @param string $name The name to use for creating a UUID\\n     *\\n     * @return UuidInterface A UuidInterface instance that represents a version 3 UUID\\n     *\\n     * @pure\\n     *\/\\n    public static function uuid3($ns, string $name): UuidInterface\\n    {\\n        \/** @phpstan-ignore possiblyImpure.methodCall *\/\\n        return self::getFactory()->uuid3($ns, $name);\\n    }\\n\\n    \/**\\n     * Returns a version 4 (random) UUID\\n     *\\n     * @return UuidInterface A UuidInterface instance that represents a version 4 UUID\\n     *\/\\n    public static function uuid4(): UuidInterface\\n    {\\n        return self::getFactory()->uuid4();\\n    }\\n\\n    \/**\\n     * Returns a version 5 (name-based) UUID based on the SHA-1 hash of a namespace ID and a name\\n     *\\n     * @param UuidInterface | string $ns The namespace (must be a valid UUID)\\n     * @param string $name The name to use for creating a UUID\\n     *\\n     * @return UuidInterface A UuidInterface instance that represents a version 5 UUID\\n     *\\n     * @pure\\n     *\/\\n    public static function uuid5($ns, string $name): UuidInterface\\n    {\\n        \/** @phpstan-ignore possiblyImpure.methodCall *\/\\n        return self::getFactory()->uuid5($ns, $name);\\n    }\\n\\n    \/**\\n     * Returns a version 6 (reordered Gregorian time) UUID from a host ID, sequence number, and the current time\\n     *\\n     * @param Hexadecimal | null $node A 48-bit number representing the hardware address\\n     * @param int | null $clockSeq A 14-bit number used to help avoid duplicates that could arise when the clock is set\\n     *     backwards in time or if the node ID changes\\n     *\\n     * @return UuidInterface A UuidInterface instance that represents a version 6 UUID\\n     *\/\\n    public static function uuid6(\\n        ?Hexadecimal $node = null,\\n        ?int $clockSeq = null\\n    ): UuidInterface {\\n        return self::getFactory()->uuid6($node, $clockSeq);\\n    }\\n\\n    \/**\\n     * Returns a version 7 (Unix Epoch time) UUID\\n     *\\n     * @param DateTimeInterface | null $dateTime An optional date\/time from which to create the version 7 UUID. If not\\n     *     provided, the UUID is generated using the current date\/time.\\n     *\\n     * @return UuidInterface A UuidInterface instance that represents a version 7 UUID\\n     *\/\\n    public static function uuid7(?DateTimeInterface $dateTime = null): UuidInterface\\n    {\\n        $factory = self::getFactory();\\n\\n        if (method_exists($factory, 'uuid7')) {\\n            \/** @var UuidInterface *\/\\n            return $factory->uuid7($dateTime);\\n        }\\n\\n        throw new UnsupportedOperationException('The provided factory does not support the uuid7() method');\\n    }\\n\\n    \/**\\n     * Returns a version 8 (custom format) UUID\\n     *\\n     * The bytes provided may contain any value according to your application's needs. Be aware, however, that other\\n     * applications may not understand the semantics of the value.\\n     *\\n     * @param string $bytes A 16-byte octet string. This is an open blob of data that you may fill with 128 bits of\\n     *     information. Be aware, however, bits 48 through 51 will be replaced with the UUID version field, and bits 64\\n     *     and 65 will be replaced with the UUID variant. You MUST NOT rely on these bits for your application needs.\\n     *\\n     * @return UuidInterface A UuidInterface instance that represents a version 8 UUID\\n     *\\n     * @pure\\n     *\/\\n    public static function uuid8(string $bytes): UuidInterface\\n    {\\n        \/** @phpstan-ignore possiblyImpure.methodCall *\/\\n        $factory = self::getFactory();\\n\\n        if (method_exists($factory, 'uuid8')) {\\n            \/**\\n             * @var UuidInterface\\n             * @phpstan-ignore possiblyImpure.methodCall\\n             *\/\\n            return $factory->uuid8($bytes);\\n        }\\n\\n        throw new UnsupportedOperationException('The provided factory does not support the uuid8() method');\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/DeprecatedUuidInterface.php\",\"ext\":\"php\",\"size\":5005,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid;\\n\\nuse DateTimeInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\NumberConverterInterface;\\n\\n\/**\\n * This interface encapsulates deprecated methods for ramsey\/uuid\\n *\\n * @immutable\\n *\/\\ninterface DeprecatedUuidInterface\\n{\\n    \/**\\n     * @deprecated This method will be removed in 5.0.0. There is no alternative recommendation, so plan accordingly.\\n     *\/\\n    public function getNumberConverter(): NumberConverterInterface;\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see FieldsInterface} instance.\\n     *\\n     * @return string[]\\n     *\/\\n    public function getFieldsHex(): array;\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see FieldsInterface} instance. If it is a\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface} instance, you may call\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface::getClockSeqHiAndReserved()}.\\n     *\/\\n    public function getClockSeqHiAndReservedHex(): string;\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see FieldsInterface} instance. If it is a\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface} instance, you may call\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface::getClockSeqLow()}.\\n     *\/\\n    public function getClockSeqLowHex(): string;\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see FieldsInterface} instance. If it is a\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface} instance, you may call\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface::getClockSeq()}.\\n     *\/\\n    public function getClockSequenceHex(): string;\\n\\n    \/**\\n     * @deprecated In ramsey\/uuid version 5.0.0, this will be removed from the interface. It is available at\\n     *     {@see UuidV1::getDateTime()}.\\n     *\/\\n    public function getDateTime(): DateTimeInterface;\\n\\n    \/**\\n     * @deprecated This method will be removed in 5.0.0. There is no direct alternative, but the same information may be\\n     *     obtained by splitting in half the value returned by {@see UuidInterface::getHex()}.\\n     *\/\\n    public function getLeastSignificantBitsHex(): string;\\n\\n    \/**\\n     * @deprecated This method will be removed in 5.0.0. There is no direct alternative, but the same information may be\\n     *     obtained by splitting in half the value returned by {@see UuidInterface::getHex()}.\\n     *\/\\n    public function getMostSignificantBitsHex(): string;\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see FieldsInterface} instance. If it is a\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface} instance, you may call\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface::getNode()}.\\n     *\/\\n    public function getNodeHex(): string;\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see FieldsInterface} instance. If it is a\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface} instance, you may call\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface::getTimeHiAndVersion()}.\\n     *\/\\n    public function getTimeHiAndVersionHex(): string;\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see FieldsInterface} instance. If it is a\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface} instance, you may call\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface::getTimeLow()}.\\n     *\/\\n    public function getTimeLowHex(): string;\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see FieldsInterface} instance. If it is a\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface} instance, you may call\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface::getTimeMid()}.\\n     *\/\\n    public function getTimeMidHex(): string;\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see FieldsInterface} instance. If it is a\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface} instance, you may call\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface::getTimestamp()}.\\n     *\/\\n    public function getTimestampHex(): string;\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see FieldsInterface} instance. If it is a\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface} instance, you may call\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface::getVariant()}.\\n     *\/\\n    public function getVariant(): ?int;\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see FieldsInterface} instance. If it is a\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface} instance, you may call\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface::getVersion()}.\\n     *\/\\n    public function getVersion(): ?int;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Nonstandard\/Fields.php\",\"ext\":\"php\",\"size\":3382,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Nonstandard;\\n\\nuse Ramsey\\\\Uuid\\\\Exception\\\\InvalidArgumentException;\\nuse Ramsey\\\\Uuid\\\\Fields\\\\SerializableFieldsTrait;\\nuse Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface;\\nuse Ramsey\\\\Uuid\\\\Rfc4122\\\\VariantTrait;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Hexadecimal;\\n\\nuse function bin2hex;\\nuse function dechex;\\nuse function hexdec;\\nuse function sprintf;\\nuse function str_pad;\\nuse function strlen;\\nuse function substr;\\n\\nuse const STR_PAD_LEFT;\\n\\n\/**\\n * Nonstandard UUID fields do not conform to the RFC 9562 (formerly RFC 4122) standard\\n *\\n * Since some systems may create nonstandard UUIDs, this implements the {@see FieldsInterface}, so that functionality of\\n * a nonstandard UUID is not degraded, in the event these UUIDs are expected to contain RFC 9562 (formerly RFC 4122) fields.\\n *\\n * Internally, this class represents the fields together as a 16-byte binary string.\\n *\\n * @immutable\\n *\/\\nfinal class Fields implements FieldsInterface\\n{\\n    use SerializableFieldsTrait;\\n    use VariantTrait;\\n\\n    \/**\\n     * @param string $bytes A 16-byte binary string representation of a UUID\\n     *\\n     * @throws InvalidArgumentException if the byte string is not exactly 16 bytes\\n     *\/\\n    public function __construct(private string $bytes)\\n    {\\n        if (strlen($this->bytes) !== 16) {\\n            throw new InvalidArgumentException(\\n                'The byte string must be 16 bytes long; received ' . strlen($this->bytes) . ' bytes',\\n            );\\n        }\\n    }\\n\\n    public function getBytes(): string\\n    {\\n        return $this->bytes;\\n    }\\n\\n    public function getClockSeq(): Hexadecimal\\n    {\\n        $clockSeq = hexdec(bin2hex(substr($this->bytes, 8, 2))) & 0x3fff;\\n\\n        return new Hexadecimal(str_pad(dechex($clockSeq), 4, '0', STR_PAD_LEFT));\\n    }\\n\\n    public function getClockSeqHiAndReserved(): Hexadecimal\\n    {\\n        return new Hexadecimal(bin2hex(substr($this->bytes, 8, 1)));\\n    }\\n\\n    public function getClockSeqLow(): Hexadecimal\\n    {\\n        return new Hexadecimal(bin2hex(substr($this->bytes, 9, 1)));\\n    }\\n\\n    public function getNode(): Hexadecimal\\n    {\\n        return new Hexadecimal(bin2hex(substr($this->bytes, 10)));\\n    }\\n\\n    public function getTimeHiAndVersion(): Hexadecimal\\n    {\\n        return new Hexadecimal(bin2hex(substr($this->bytes, 6, 2)));\\n    }\\n\\n    public function getTimeLow(): Hexadecimal\\n    {\\n        return new Hexadecimal(bin2hex(substr($this->bytes, 0, 4)));\\n    }\\n\\n    public function getTimeMid(): Hexadecimal\\n    {\\n        return new Hexadecimal(bin2hex(substr($this->bytes, 4, 2)));\\n    }\\n\\n    public function getTimestamp(): Hexadecimal\\n    {\\n        return new Hexadecimal(sprintf(\\n            '%03x%04s%08s',\\n            hexdec($this->getTimeHiAndVersion()->toString()) & 0x0fff,\\n            $this->getTimeMid()->toString(),\\n            $this->getTimeLow()->toString()\\n        ));\\n    }\\n\\n    public function getVersion(): ?int\\n    {\\n        return null;\\n    }\\n\\n    public function isNil(): bool\\n    {\\n        return false;\\n    }\\n\\n    public function isMax(): bool\\n    {\\n        return false;\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Nonstandard\/Uuid.php\",\"ext\":\"php\",\"size\":979,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Nonstandard;\\n\\nuse Ramsey\\\\Uuid\\\\Codec\\\\CodecInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\NumberConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\TimeConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Uuid as BaseUuid;\\n\\n\/**\\n * Nonstandard\\\\Uuid is a UUID that doesn't conform to RFC 9562 (formerly RFC 4122)\\n *\\n * @immutable\\n * @pure\\n *\/\\nfinal class Uuid extends BaseUuid\\n{\\n    public function __construct(\\n        Fields $fields,\\n        NumberConverterInterface $numberConverter,\\n        CodecInterface $codec,\\n        TimeConverterInterface $timeConverter,\\n    ) {\\n        parent::__construct($fields, $numberConverter, $codec, $timeConverter);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Nonstandard\/UuidBuilder.php\",\"ext\":\"php\",\"size\":2338,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Nonstandard;\\n\\nuse Ramsey\\\\Uuid\\\\Builder\\\\UuidBuilderInterface;\\nuse Ramsey\\\\Uuid\\\\Codec\\\\CodecInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\NumberConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\TimeConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Exception\\\\UnableToBuildUuidException;\\nuse Ramsey\\\\Uuid\\\\UuidInterface;\\nuse Throwable;\\n\\n\/**\\n * Nonstandard\\\\UuidBuilder builds instances of Nonstandard\\\\Uuid\\n *\\n * @immutable\\n *\/\\nclass UuidBuilder implements UuidBuilderInterface\\n{\\n    \/**\\n     * @param NumberConverterInterface $numberConverter The number converter to use when constructing the Nonstandard\\\\Uuid\\n     * @param TimeConverterInterface $timeConverter The time converter to use for converting timestamps extracted from a\\n     *     UUID to Unix timestamps\\n     *\/\\n    public function __construct(\\n        private NumberConverterInterface $numberConverter,\\n        private TimeConverterInterface $timeConverter,\\n    ) {\\n    }\\n\\n    \/**\\n     * Builds and returns a Nonstandard\\\\Uuid\\n     *\\n     * @param CodecInterface $codec The codec to use for building this instance\\n     * @param string $bytes The byte string from which to construct a UUID\\n     *\\n     * @return Uuid The Nonstandard\\\\UuidBuilder returns an instance of Nonstandard\\\\Uuid\\n     *\\n     * @pure\\n     *\/\\n    public function build(CodecInterface $codec, string $bytes): UuidInterface\\n    {\\n        try {\\n            \/** @phpstan-ignore possiblyImpure.new *\/\\n            return new Uuid($this->buildFields($bytes), $this->numberConverter, $codec, $this->timeConverter);\\n        } catch (Throwable $e) {\\n            \/** @phpstan-ignore possiblyImpure.methodCall, possiblyImpure.methodCall *\/\\n            throw new UnableToBuildUuidException($e->getMessage(), (int) $e->getCode(), $e);\\n        }\\n    }\\n\\n    \/**\\n     * Proxy method to allow injecting a mock for testing\\n     *\\n     * @pure\\n     *\/\\n    protected function buildFields(string $bytes): Fields\\n    {\\n        \/** @phpstan-ignore possiblyImpure.new *\/\\n        return new Fields($bytes);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Nonstandard\/UuidV6.php\",\"ext\":\"php\",\"size\":3469,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Nonstandard;\\n\\nuse Ramsey\\\\Uuid\\\\Codec\\\\CodecInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\NumberConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\TimeConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Exception\\\\InvalidArgumentException;\\nuse Ramsey\\\\Uuid\\\\Lazy\\\\LazyUuidFromString;\\nuse Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface as Rfc4122FieldsInterface;\\nuse Ramsey\\\\Uuid\\\\Rfc4122\\\\TimeTrait;\\nuse Ramsey\\\\Uuid\\\\Rfc4122\\\\UuidInterface;\\nuse Ramsey\\\\Uuid\\\\Rfc4122\\\\UuidV1;\\nuse Ramsey\\\\Uuid\\\\Uuid as BaseUuid;\\n\\n\/**\\n * Reordered time, or version 6, UUIDs include timestamp, clock sequence, and node values that are combined into a\\n * 128-bit unsigned integer\\n *\\n * @deprecated Use {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\UuidV6} instead.\\n *\\n * @link https:\/\/github.com\/uuid6\/uuid6-ietf-draft UUID version 6 IETF draft\\n * @link http:\/\/gh.peabody.io\/uuidv6\/ \\\"Version 6\\\" UUIDs\\n * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-5.6 RFC 9562, 5.6. UUID Version 6\\n *\\n * @immutable\\n *\/\\nclass UuidV6 extends BaseUuid implements UuidInterface\\n{\\n    use TimeTrait;\\n\\n    \/**\\n     * Creates a version 6 (reordered Gregorian time) UUID\\n     *\\n     * @param Rfc4122FieldsInterface $fields The fields from which to construct a UUID\\n     * @param NumberConverterInterface $numberConverter The number converter to use for converting hex values to\/from integers\\n     * @param CodecInterface $codec The codec to use when encoding or decoding UUID strings\\n     * @param TimeConverterInterface $timeConverter The time converter to use for converting timestamps extracted from a\\n     *     UUID to unix timestamps\\n     *\/\\n    public function __construct(\\n        Rfc4122FieldsInterface $fields,\\n        NumberConverterInterface $numberConverter,\\n        CodecInterface $codec,\\n        TimeConverterInterface $timeConverter,\\n    ) {\\n        if ($fields->getVersion() !== BaseUuid::UUID_TYPE_REORDERED_TIME) {\\n            throw new InvalidArgumentException(\\n                'Fields used to create a UuidV6 must represent a version 6 (reordered time) UUID',\\n            );\\n        }\\n\\n        parent::__construct($fields, $numberConverter, $codec, $timeConverter);\\n    }\\n\\n    \/**\\n     * Converts this UUID into an instance of a version 1 UUID\\n     *\/\\n    public function toUuidV1(): UuidV1\\n    {\\n        $hex = $this->getHex()->toString();\\n        $hex = substr($hex, 7, 5)\\n            . substr($hex, 13, 3)\\n            . substr($hex, 3, 4)\\n            . '1' . substr($hex, 0, 3)\\n            . substr($hex, 16);\\n\\n        \/** @var LazyUuidFromString $uuid *\/\\n        $uuid = BaseUuid::fromBytes((string) hex2bin($hex));\\n\\n        return $uuid->toUuidV1();\\n    }\\n\\n    \/**\\n     * Converts a version 1 UUID into an instance of a version 6 UUID\\n     *\/\\n    public static function fromUuidV1(UuidV1 $uuidV1): \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\UuidV6\\n    {\\n        $hex = $uuidV1->getHex()->toString();\\n        $hex = substr($hex, 13, 3)\\n            . substr($hex, 8, 4)\\n            . substr($hex, 0, 5)\\n            . '6' . substr($hex, 5, 3)\\n            . substr($hex, 16);\\n\\n        \/** @var LazyUuidFromString $uuid *\/\\n        $uuid = BaseUuid::fromBytes((string) hex2bin($hex));\\n\\n        return $uuid->toUuidV6();\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Validator\/GenericValidator.php\",\"ext\":\"php\",\"size\":1293,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Validator;\\n\\nuse Ramsey\\\\Uuid\\\\Uuid;\\n\\nuse function preg_match;\\nuse function str_replace;\\n\\n\/**\\n * GenericValidator validates strings as UUIDs of any variant\\n *\\n * @immutable\\n *\/\\nfinal class GenericValidator implements ValidatorInterface\\n{\\n    \/**\\n     * Regular expression pattern for matching a UUID of any variant.\\n     *\/\\n    private const VALID_PATTERN = '\\\\A[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}\\\\z';\\n\\n    \/**\\n     * @return non-empty-string\\n     *\/\\n    public function getPattern(): string\\n    {\\n        return self::VALID_PATTERN;\\n    }\\n\\n    public function validate(string $uuid): bool\\n    {\\n        \/** @phpstan-ignore possiblyImpure.functionCall *\/\\n        $uuid = str_replace(['urn:', 'uuid:', 'URN:', 'UUID:', '{', '}'], '', $uuid);\\n\\n        \/** @phpstan-ignore possiblyImpure.functionCall *\/\\n        return $uuid === Uuid::NIL || preg_match('\/' . self::VALID_PATTERN . '\/Dms', $uuid);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Validator\/ValidatorInterface.php\",\"ext\":\"php\",\"size\":987,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Validator;\\n\\n\/**\\n * A validator validates a string as a proper UUID\\n *\\n * @immutable\\n *\/\\ninterface ValidatorInterface\\n{\\n    \/**\\n     * Returns the regular expression pattern used by this validator\\n     *\\n     * @return non-empty-string The regular expression pattern this validator uses\\n     *\/\\n    public function getPattern(): string;\\n\\n    \/**\\n     * Returns true if the provided string represents a UUID\\n     *\\n     * @param string $uuid The string to validate as a UUID\\n     *\\n     * @return bool True if the string is a valid UUID, false otherwise\\n     *\\n     * @pure\\n     *\/\\n    public function validate(string $uuid): bool;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/UuidFactoryInterface.php\",\"ext\":\"php\",\"size\":5843,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid;\\n\\nuse DateTimeInterface;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Hexadecimal;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Integer as IntegerObject;\\nuse Ramsey\\\\Uuid\\\\Validator\\\\ValidatorInterface;\\n\\n\/**\\n * UuidFactoryInterface defines the common functionality all `UuidFactory` instances must implement\\n *\/\\ninterface UuidFactoryInterface\\n{\\n    \/**\\n     * Creates a UUID from a byte string\\n     *\\n     * @param string $bytes A binary string\\n     *\\n     * @return UuidInterface A UuidInterface instance created from a binary string representation\\n     *\\n     * @pure\\n     *\/\\n    public function fromBytes(string $bytes): UuidInterface;\\n\\n    \/**\\n     * Creates a UUID from a DateTimeInterface instance\\n     *\\n     * @param DateTimeInterface $dateTime The date and time\\n     * @param Hexadecimal | null $node A 48-bit number representing the hardware address\\n     * @param int | null $clockSeq A 14-bit number used to help avoid duplicates that could arise when the clock is set\\n     *     backwards in time or if the node ID changes\\n     *\\n     * @return UuidInterface A UuidInterface instance that represents a version 1 UUID created from a DateTimeInterface instance\\n     *\/\\n    public function fromDateTime(\\n        DateTimeInterface $dateTime,\\n        ?Hexadecimal $node = null,\\n        ?int $clockSeq = null,\\n    ): UuidInterface;\\n\\n    \/**\\n     * Creates a UUID from a 128-bit integer string\\n     *\\n     * @param string $integer String representation of 128-bit integer\\n     *\\n     * @return UuidInterface A UuidInterface instance created from the string representation of a 128-bit integer\\n     *\\n     * @pure\\n     *\/\\n    public function fromInteger(string $integer): UuidInterface;\\n\\n    \/**\\n     * Creates a UUID from the string standard representation\\n     *\\n     * @param string $uuid A hexadecimal string\\n     *\\n     * @return UuidInterface A UuidInterface instance created from a hexadecimal string representation\\n     *\\n     * @pure\\n     *\/\\n    public function fromString(string $uuid): UuidInterface;\\n\\n    \/**\\n     * Returns the validator used by the factory\\n     *\/\\n    public function getValidator(): ValidatorInterface;\\n\\n    \/**\\n     * Returns a version 1 (Gregorian time) UUID from a host ID, sequence number, and the current time\\n     *\\n     * @param Hexadecimal | int | string | null $node A 48-bit number representing the hardware address; this number may\\n     *     be represented as an integer or a hexadecimal string\\n     * @param int | null $clockSeq A 14-bit number used to help avoid duplicates that could arise when the clock is set\\n     *     backwards in time or if the node ID changes\\n     *\\n     * @return UuidInterface A UuidInterface instance that represents a version 1 UUID\\n     *\/\\n    public function uuid1($node = null, ?int $clockSeq = null): UuidInterface;\\n\\n    \/**\\n     * Returns a version 2 (DCE Security) UUID from a local domain, local identifier, host ID, clock sequence, and the\\n     * current time\\n     *\\n     * @param int $localDomain The local domain to use when generating bytes, according to DCE Security\\n     * @param IntegerObject | null $localIdentifier The local identifier for the given domain; this may be a UID or GID\\n     *     on POSIX systems, if the local domain is a person or group, or it may be a site-defined identifier if the\\n     *     local domain is org\\n     * @param Hexadecimal | null $node A 48-bit number representing the hardware address\\n     * @param int | null $clockSeq A 14-bit number used to help avoid duplicates that could arise when the clock is set\\n     *     backwards in time or if the node ID changes\\n     *\\n     * @return UuidInterface A UuidInterface instance that represents a version 2 UUID\\n     *\/\\n    public function uuid2(\\n        int $localDomain,\\n        ?IntegerObject $localIdentifier = null,\\n        ?Hexadecimal $node = null,\\n        ?int $clockSeq = null,\\n    ): UuidInterface;\\n\\n    \/**\\n     * Returns a version 3 (name-based) UUID based on the MD5 hash of a namespace ID and a name\\n     *\\n     * @param UuidInterface | string $ns The namespace (must be a valid UUID)\\n     * @param string $name The name to use for creating a UUID\\n     *\\n     * @return UuidInterface A UuidInterface instance that represents a version 3 UUID\\n     *\\n     * @pure\\n     *\/\\n    public function uuid3($ns, string $name): UuidInterface;\\n\\n    \/**\\n     * Returns a version 4 (random) UUID\\n     *\\n     * @return UuidInterface A UuidInterface instance that represents a version 4 UUID\\n     *\/\\n    public function uuid4(): UuidInterface;\\n\\n    \/**\\n     * Returns a version 5 (name-based) UUID based on the SHA-1 hash of a namespace ID and a name\\n     *\\n     * @param UuidInterface | string $ns The namespace (must be a valid UUID)\\n     * @param string $name The name to use for creating a UUID\\n     *\\n     * @return UuidInterface A UuidInterface instance that represents a version 5 UUID\\n     *\\n     * @pure\\n     *\/\\n    public function uuid5($ns, string $name): UuidInterface;\\n\\n    \/**\\n     * Returns a version 6 (reordered Gregorian time) UUID from a host ID, sequence number, and the current time\\n     *\\n     * @param Hexadecimal | null $node A 48-bit number representing the hardware address\\n     * @param int | null $clockSeq A 14-bit number used to help avoid duplicates that could arise when the clock is set\\n     *     backwards in time or if the node ID changes\\n     *\\n     * @return UuidInterface A UuidInterface instance that represents a version 6 UUID\\n     *\/\\n    public function uuid6(?Hexadecimal $node = null, ?int $clockSeq = null): UuidInterface;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Generator\/UnixTimeGenerator.php\",\"ext\":\"php\",\"size\":5975,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Generator;\\n\\nuse Brick\\\\Math\\\\BigInteger;\\nuse DateTimeInterface;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Hexadecimal;\\n\\nuse function assert;\\nuse function hash;\\nuse function pack;\\nuse function str_pad;\\nuse function strlen;\\nuse function substr;\\nuse function substr_replace;\\nuse function unpack;\\n\\nuse const PHP_INT_SIZE;\\nuse const STR_PAD_LEFT;\\n\\n\/**\\n * UnixTimeGenerator generates bytes, combining a 48-bit timestamp in milliseconds since the Unix Epoch with 80 random bits\\n *\\n * Code and concepts within this class are borrowed from the symfony\/uid package and are used under the terms of the MIT\\n * license distributed with symfony\/uid.\\n *\\n * symfony\/uid is copyright (c) Fabien Potencier.\\n *\\n * @link https:\/\/symfony.com\/components\/Uid Symfony Uid component\\n * @link https:\/\/github.com\/symfony\/uid\/blob\/4f9f537e57261519808a7ce1d941490736522bbc\/UuidV7.php Symfony UuidV7 class\\n * @link https:\/\/github.com\/symfony\/uid\/blob\/6.2\/LICENSE MIT License\\n *\/\\nclass UnixTimeGenerator implements TimeGeneratorInterface\\n{\\n    private static string $time = '';\\n    private static ?string $seed = null;\\n    private static int $seedIndex = 0;\\n\\n    \/** @var int[] *\/\\n    private static array $rand = [];\\n\\n    \/** @var int[] *\/\\n    private static array $seedParts;\\n\\n    public function __construct(\\n        private RandomGeneratorInterface $randomGenerator,\\n        private int $intSize = PHP_INT_SIZE,\\n    ) {\\n    }\\n\\n    \/**\\n     * @param Hexadecimal | int | string | null $node Unused in this generator\\n     * @param int | null $clockSeq Unused in this generator\\n     * @param DateTimeInterface | null $dateTime A date-time instance to use when generating bytes\\n     *\/\\n    public function generate($node = null, ?int $clockSeq = null, ?DateTimeInterface $dateTime = null): string\\n    {\\n        if ($dateTime === null) {\\n            $time = microtime(false);\\n            $time = substr($time, 11) . substr($time, 2, 3);\\n        } else {\\n            $time = $dateTime->format('Uv');\\n        }\\n\\n        if ($time > self::$time || ($dateTime !== null && $time !== self::$time)) {\\n            $this->randomize($time);\\n        } else {\\n            $time = $this->increment();\\n        }\\n\\n        if ($this->intSize >= 8) {\\n            $time = substr(pack('J', (int) $time), -6);\\n        } else {\\n            $time = str_pad(BigInteger::of($time)->toBytes(false), 6, \\\"\\\\x00\\\", STR_PAD_LEFT);\\n        }\\n\\n        assert(strlen($time) === 6);\\n\\n        return $time . pack('n*', self::$rand[1], self::$rand[2], self::$rand[3], self::$rand[4], self::$rand[5]);\\n    }\\n\\n    private function randomize(string $time): void\\n    {\\n        if (self::$seed === null) {\\n            $seed = $this->randomGenerator->generate(16);\\n            self::$seed = $seed;\\n        } else {\\n            $seed = $this->randomGenerator->generate(10);\\n        }\\n\\n        \/** @var int[] $rand *\/\\n        $rand = unpack('n*', $seed);\\n        $rand[1] &= 0x03ff;\\n\\n        self::$rand = $rand;\\n        self::$time = $time;\\n    }\\n\\n    \/**\\n     * Special thanks to Nicolas Grekas (<https:\/\/github.com\/nicolas-grekas>) for sharing the following information:\\n     *\\n     * Within the same ms, we increment the rand part by a random 24-bit number.\\n     *\\n     * Instead of getting this number from random_bytes(), which is slow, we get it by sha512-hashing self::$seed. This\\n     * produces 64 bytes of entropy, which we need to split in a list of 24-bit numbers. `unpack()` first splits them\\n     * into 16 x 32-bit numbers; we take the first byte of each number to get 5 extra 24-bit numbers. Then, we consume\\n     * each number one-by-one and run this logic every 21 iterations.\\n     *\\n     * `self::$rand` holds the random part of the UUID, split into 5 x 16-bit numbers for x86 portability. We increment\\n     * this random part by the next 24-bit number in the `self::$seedParts` list and decrement `self::$seedIndex`.\\n     *\/\\n    private function increment(): string\\n    {\\n        if (self::$seedIndex === 0 && self::$seed !== null) {\\n            self::$seed = hash('sha512', self::$seed, true);\\n\\n            \/** @var int[] $s *\/\\n            $s = unpack('l*', self::$seed);\\n            $s[] = ($s[1] >> 8 & 0xff0000) | ($s[2] >> 16 & 0xff00) | ($s[3] >> 24 & 0xff);\\n            $s[] = ($s[4] >> 8 & 0xff0000) | ($s[5] >> 16 & 0xff00) | ($s[6] >> 24 & 0xff);\\n            $s[] = ($s[7] >> 8 & 0xff0000) | ($s[8] >> 16 & 0xff00) | ($s[9] >> 24 & 0xff);\\n            $s[] = ($s[10] >> 8 & 0xff0000) | ($s[11] >> 16 & 0xff00) | ($s[12] >> 24 & 0xff);\\n            $s[] = ($s[13] >> 8 & 0xff0000) | ($s[14] >> 16 & 0xff00) | ($s[15] >> 24 & 0xff);\\n\\n            self::$seedParts = $s;\\n            self::$seedIndex = 21;\\n        }\\n\\n        self::$rand[5] = 0xffff & $carry = self::$rand[5] + 1 + (self::$seedParts[self::$seedIndex--] & 0xffffff);\\n        self::$rand[4] = 0xffff & $carry = self::$rand[4] + ($carry >> 16);\\n        self::$rand[3] = 0xffff & $carry = self::$rand[3] + ($carry >> 16);\\n        self::$rand[2] = 0xffff & $carry = self::$rand[2] + ($carry >> 16);\\n        self::$rand[1] += $carry >> 16;\\n\\n        if (0xfc00 & self::$rand[1]) {\\n            $time = self::$time;\\n            $mtime = (int) substr($time, -9);\\n\\n            if ($this->intSize >= 8 || strlen($time) < 10) {\\n                $time = (string) ((int) $time + 1);\\n            } elseif ($mtime === 999999999) {\\n                $time = (1 + (int) substr($time, 0, -9)) . '000000000';\\n            } else {\\n                $mtime++;\\n                $time = substr_replace($time, str_pad((string) $mtime, 9, '0', STR_PAD_LEFT), -9);\\n            }\\n\\n            $this->randomize($time);\\n        }\\n\\n        return self::$time;\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Generator\/NameGeneratorInterface.php\",\"ext\":\"php\",\"size\":1053,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Generator;\\n\\nuse Ramsey\\\\Uuid\\\\UuidInterface;\\n\\n\/**\\n * A name generator generates strings of binary data created by hashing together a namespace with a name, according to a\\n * hashing algorithm\\n *\/\\ninterface NameGeneratorInterface\\n{\\n    \/**\\n     * Generate a binary string from a namespace and name hashed together with the specified hashing algorithm\\n     *\\n     * @param UuidInterface $ns The namespace\\n     * @param string $name The name to use for creating a UUID\\n     * @param string $hashAlgorithm The hashing algorithm to use\\n     *\\n     * @return string A binary string\\n     *\\n     * @pure\\n     *\/\\n    public function generate(UuidInterface $ns, string $name, string $hashAlgorithm): string;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Generator\/TimeGeneratorFactory.php\",\"ext\":\"php\",\"size\":1113,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Generator;\\n\\nuse Ramsey\\\\Uuid\\\\Converter\\\\TimeConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Provider\\\\NodeProviderInterface;\\nuse Ramsey\\\\Uuid\\\\Provider\\\\TimeProviderInterface;\\n\\n\/**\\n * TimeGeneratorFactory retrieves a default time generator, based on the environment\\n *\/\\nclass TimeGeneratorFactory\\n{\\n    public function __construct(\\n        private NodeProviderInterface $nodeProvider,\\n        private TimeConverterInterface $timeConverter,\\n        private TimeProviderInterface $timeProvider,\\n    ) {\\n    }\\n\\n    \/**\\n     * Returns a default time generator, based on the current environment\\n     *\/\\n    public function getGenerator(): TimeGeneratorInterface\\n    {\\n        return new DefaultTimeGenerator($this->nodeProvider, $this->timeConverter, $this->timeProvider);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Generator\/DefaultTimeGenerator.php\",\"ext\":\"php\",\"size\":3733,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Generator;\\n\\nuse Ramsey\\\\Uuid\\\\Converter\\\\TimeConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Exception\\\\InvalidArgumentException;\\nuse Ramsey\\\\Uuid\\\\Exception\\\\RandomSourceException;\\nuse Ramsey\\\\Uuid\\\\Exception\\\\TimeSourceException;\\nuse Ramsey\\\\Uuid\\\\Provider\\\\NodeProviderInterface;\\nuse Ramsey\\\\Uuid\\\\Provider\\\\TimeProviderInterface;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Hexadecimal;\\nuse Throwable;\\n\\nuse function dechex;\\nuse function hex2bin;\\nuse function is_int;\\nuse function pack;\\nuse function preg_match;\\nuse function sprintf;\\nuse function str_pad;\\nuse function strlen;\\n\\nuse const STR_PAD_LEFT;\\n\\n\/**\\n * DefaultTimeGenerator generates strings of binary data based on a node ID, clock sequence, and the current time\\n *\/\\nclass DefaultTimeGenerator implements TimeGeneratorInterface\\n{\\n    public function __construct(\\n        private NodeProviderInterface $nodeProvider,\\n        private TimeConverterInterface $timeConverter,\\n        private TimeProviderInterface $timeProvider,\\n    ) {\\n    }\\n\\n    \/**\\n     * @throws InvalidArgumentException if the parameters contain invalid values\\n     * @throws RandomSourceException if random_int() throws an exception\/error\\n     *\\n     * @inheritDoc\\n     *\/\\n    public function generate($node = null, ?int $clockSeq = null): string\\n    {\\n        if ($node instanceof Hexadecimal) {\\n            $node = $node->toString();\\n        }\\n\\n        $node = $this->getValidNode($node);\\n\\n        if ($clockSeq === null) {\\n            try {\\n                \/\/ This does not use \\\"stable storage\\\"; see RFC 9562, section 6.3.\\n                $clockSeq = random_int(0, 0x3fff);\\n            } catch (Throwable $exception) {\\n                throw new RandomSourceException($exception->getMessage(), (int) $exception->getCode(), $exception);\\n            }\\n        }\\n\\n        $time = $this->timeProvider->getTime();\\n\\n        $uuidTime = $this->timeConverter->calculateTime(\\n            $time->getSeconds()->toString(),\\n            $time->getMicroseconds()->toString()\\n        );\\n\\n        $timeHex = str_pad($uuidTime->toString(), 16, '0', STR_PAD_LEFT);\\n\\n        if (strlen($timeHex) !== 16) {\\n            throw new TimeSourceException(sprintf('The generated time of \\\\'%s\\\\' is larger than expected', $timeHex));\\n        }\\n\\n        $timeBytes = (string) hex2bin($timeHex);\\n\\n        return $timeBytes[4] . $timeBytes[5] . $timeBytes[6] . $timeBytes[7]\\n            . $timeBytes[2] . $timeBytes[3] . $timeBytes[0] . $timeBytes[1]\\n            . pack('n*', $clockSeq) . $node;\\n    }\\n\\n    \/**\\n     * Uses the node provider given when constructing this instance to get the node ID (usually a MAC address)\\n     *\\n     * @param int | string | null $node A node value that may be used to override the node provider\\n     *\\n     * @return string 6-byte binary string representation of the node\\n     *\\n     * @throws InvalidArgumentException\\n     *\/\\n    private function getValidNode(int | string | null $node): string\\n    {\\n        if ($node === null) {\\n            $node = $this->nodeProvider->getNode();\\n        }\\n\\n        \/\/ Convert the node to hex if it is still an integer.\\n        if (is_int($node)) {\\n            $node = dechex($node);\\n        }\\n\\n        if (!preg_match('\/^[A-Fa-f0-9]+$\/', (string) $node) || strlen((string) $node) > 12) {\\n            throw new InvalidArgumentException('Invalid node value');\\n        }\\n\\n        return (string) hex2bin(str_pad((string) $node, 12, '0', STR_PAD_LEFT));\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Generator\/PeclUuidTimeGenerator.php\",\"ext\":\"php\",\"size\":879,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Generator;\\n\\nuse function uuid_create;\\nuse function uuid_parse;\\n\\nuse const UUID_TYPE_TIME;\\n\\n\/**\\n * PeclUuidTimeGenerator generates strings of binary data for time-base UUIDs, using ext-uuid\\n *\\n * @link https:\/\/pecl.php.net\/package\/uuid ext-uuid\\n *\/\\nclass PeclUuidTimeGenerator implements TimeGeneratorInterface\\n{\\n    \/**\\n     * @inheritDoc\\n     *\/\\n    public function generate($node = null, ?int $clockSeq = null): string\\n    {\\n        $uuid = uuid_create(UUID_TYPE_TIME);\\n\\n        return (string) uuid_parse($uuid);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Generator\/RandomBytesGenerator.php\",\"ext\":\"php\",\"size\":1079,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Generator;\\n\\nuse Ramsey\\\\Uuid\\\\Exception\\\\RandomSourceException;\\nuse Throwable;\\n\\n\/**\\n * RandomBytesGenerator generates strings of random binary data using the built-in `random_bytes()` PHP function\\n *\\n * @link http:\/\/php.net\/random_bytes random_bytes()\\n *\/\\nclass RandomBytesGenerator implements RandomGeneratorInterface\\n{\\n    \/**\\n     * @throws RandomSourceException if random_bytes() throws an exception\/error\\n     *\\n     * @inheritDoc\\n     *\/\\n    public function generate(int $length): string\\n    {\\n        try {\\n            return random_bytes($length);\\n        } catch (Throwable $exception) {\\n            throw new RandomSourceException($exception->getMessage(), (int) $exception->getCode(), $exception);\\n        }\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Generator\/RandomGeneratorFactory.php\",\"ext\":\"php\",\"size\":705,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Generator;\\n\\n\/**\\n * RandomGeneratorFactory retrieves a default random generator, based on the environment\\n *\/\\nclass RandomGeneratorFactory\\n{\\n    \/**\\n     * Returns a default random generator, based on the current environment\\n     *\/\\n    public function getGenerator(): RandomGeneratorInterface\\n    {\\n        return new RandomBytesGenerator();\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Generator\/PeclUuidNameGenerator.php\",\"ext\":\"php\",\"size\":1468,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Generator;\\n\\nuse Ramsey\\\\Uuid\\\\Exception\\\\NameException;\\nuse Ramsey\\\\Uuid\\\\UuidInterface;\\n\\nuse function sprintf;\\nuse function uuid_generate_md5;\\nuse function uuid_generate_sha1;\\nuse function uuid_parse;\\n\\n\/**\\n * PeclUuidNameGenerator generates strings of binary data from a namespace and a name, using ext-uuid\\n *\\n * @link https:\/\/pecl.php.net\/package\/uuid ext-uuid\\n *\/\\nclass PeclUuidNameGenerator implements NameGeneratorInterface\\n{\\n    \/**\\n     * @pure\\n     *\/\\n    public function generate(UuidInterface $ns, string $name, string $hashAlgorithm): string\\n    {\\n        $uuid = match ($hashAlgorithm) {\\n            'md5' => uuid_generate_md5($ns->toString(), $name), \/** @phpstan-ignore possiblyImpure.functionCall *\/\\n            'sha1' => uuid_generate_sha1($ns->toString(), $name), \/** @phpstan-ignore possiblyImpure.functionCall *\/\\n            default => throw new NameException(\\n                sprintf('Unable to hash namespace and name with algorithm \\\\'%s\\\\'', $hashAlgorithm),\\n            ),\\n        };\\n\\n        \/** @phpstan-ignore possiblyImpure.functionCall *\/\\n        return (string) uuid_parse($uuid);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Generator\/RandomGeneratorInterface.php\",\"ext\":\"php\",\"size\":735,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Generator;\\n\\n\/**\\n * A random generator generates strings of random binary data\\n *\/\\ninterface RandomGeneratorInterface\\n{\\n    \/**\\n     * Generates a string of randomized binary data\\n     *\\n     * @param int<1, max> $length The number of bytes to generate of random binary data\\n     *\\n     * @return string A binary string\\n     *\/\\n    public function generate(int $length): string;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Generator\/NameGeneratorFactory.php\",\"ext\":\"php\",\"size\":695,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Generator;\\n\\n\/**\\n * NameGeneratorFactory retrieves a default name generator, based on the environment\\n *\/\\nclass NameGeneratorFactory\\n{\\n    \/**\\n     * Returns a default name generator, based on the current environment\\n     *\/\\n    public function getGenerator(): NameGeneratorInterface\\n    {\\n        return new DefaultNameGenerator();\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Generator\/DceSecurityGeneratorInterface.php\",\"ext\":\"php\",\"size\":1709,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Generator;\\n\\nuse Ramsey\\\\Uuid\\\\Rfc4122\\\\UuidV2;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Hexadecimal;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Integer as IntegerObject;\\n\\n\/**\\n * A DCE Security generator generates strings of binary data based on a local domain, local identifier, node ID, clock\\n * sequence, and the current time\\n *\\n * @see UuidV2\\n *\/\\ninterface DceSecurityGeneratorInterface\\n{\\n    \/**\\n     * Generate a binary string from a local domain, local identifier, node ID, clock sequence, and current time\\n     *\\n     * @param int $localDomain The local domain to use when generating bytes, according to DCE Security\\n     * @param IntegerObject | null $localIdentifier The local identifier for the given domain; this may be a UID or GID\\n     *     on POSIX systems if the local domain is \\\"person\\\" or \\\"group,\\\" or it may be a site-defined identifier if the\\n     *     local domain is \\\"org\\\"\\n     * @param Hexadecimal | null $node A 48-bit number representing the hardware address\\n     * @param int | null $clockSeq A 14-bit number used to help avoid duplicates that could arise when the clock is set\\n     *     backwards in time or if the node ID changes\\n     *\\n     * @return string A binary string\\n     *\/\\n    public function generate(\\n        int $localDomain,\\n        ?IntegerObject $localIdentifier = null,\\n        ?Hexadecimal $node = null,\\n        ?int $clockSeq = null,\\n    ): string;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Generator\/DceSecurityGenerator.php\",\"ext\":\"php\",\"size\":4327,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Generator;\\n\\nuse Ramsey\\\\Uuid\\\\Converter\\\\NumberConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Exception\\\\DceSecurityException;\\nuse Ramsey\\\\Uuid\\\\Provider\\\\DceSecurityProviderInterface;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Hexadecimal;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Integer as IntegerObject;\\nuse Ramsey\\\\Uuid\\\\Uuid;\\n\\nuse function hex2bin;\\nuse function in_array;\\nuse function pack;\\nuse function str_pad;\\nuse function strlen;\\nuse function substr_replace;\\n\\nuse const STR_PAD_LEFT;\\n\\n\/**\\n * DceSecurityGenerator generates strings of binary data based on a local domain, local identifier, node ID, clock\\n * sequence, and the current time\\n *\/\\nclass DceSecurityGenerator implements DceSecurityGeneratorInterface\\n{\\n    private const DOMAINS = [\\n        Uuid::DCE_DOMAIN_PERSON,\\n        Uuid::DCE_DOMAIN_GROUP,\\n        Uuid::DCE_DOMAIN_ORG,\\n    ];\\n\\n    \/**\\n     * Upper bounds for the clock sequence in DCE Security UUIDs.\\n     *\/\\n    private const CLOCK_SEQ_HIGH = 63;\\n\\n    \/**\\n     * Lower bounds for the clock sequence in DCE Security UUIDs.\\n     *\/\\n    private const CLOCK_SEQ_LOW = 0;\\n\\n    public function __construct(\\n        private NumberConverterInterface $numberConverter,\\n        private TimeGeneratorInterface $timeGenerator,\\n        private DceSecurityProviderInterface $dceSecurityProvider,\\n    ) {\\n    }\\n\\n    public function generate(\\n        int $localDomain,\\n        ?IntegerObject $localIdentifier = null,\\n        ?Hexadecimal $node = null,\\n        ?int $clockSeq = null,\\n    ): string {\\n        if (!in_array($localDomain, self::DOMAINS)) {\\n            throw new DceSecurityException('Local domain must be a valid DCE Security domain');\\n        }\\n\\n        if ($localIdentifier && $localIdentifier->isNegative()) {\\n            throw new DceSecurityException(\\n                'Local identifier out of bounds; it must be a value between 0 and 4294967295',\\n            );\\n        }\\n\\n        if ($clockSeq > self::CLOCK_SEQ_HIGH || $clockSeq < self::CLOCK_SEQ_LOW) {\\n            throw new DceSecurityException('Clock sequence out of bounds; it must be a value between 0 and 63');\\n        }\\n\\n        switch ($localDomain) {\\n            case Uuid::DCE_DOMAIN_ORG:\\n                if ($localIdentifier === null) {\\n                    throw new DceSecurityException('A local identifier must be provided for the org domain');\\n                }\\n\\n                break;\\n            case Uuid::DCE_DOMAIN_PERSON:\\n                if ($localIdentifier === null) {\\n                    $localIdentifier = $this->dceSecurityProvider->getUid();\\n                }\\n\\n                break;\\n            case Uuid::DCE_DOMAIN_GROUP:\\n            default:\\n                if ($localIdentifier === null) {\\n                    $localIdentifier = $this->dceSecurityProvider->getGid();\\n                }\\n\\n                break;\\n        }\\n\\n        $identifierHex = $this->numberConverter->toHex($localIdentifier->toString());\\n\\n        \/\/ The maximum value for the local identifier is 0xffffffff, or 4,294,967,295. This is 8 hexadecimal digits, so\\n        \/\/ if the length of hexadecimal digits is greater than 8, we know the value is greater than 0xffffffff.\\n        if (strlen($identifierHex) > 8) {\\n            throw new DceSecurityException(\\n                'Local identifier out of bounds; it must be a value between 0 and 4294967295',\\n            );\\n        }\\n\\n        $domainByte = pack('n', $localDomain)[1];\\n        $identifierBytes = (string) hex2bin(str_pad($identifierHex, 8, '0', STR_PAD_LEFT));\\n\\n        if ($node instanceof Hexadecimal) {\\n            $node = $node->toString();\\n        }\\n\\n        \/\/ Shift the clock sequence 8 bits to the left, so it matches 0x3f00.\\n        if ($clockSeq !== null) {\\n            $clockSeq = $clockSeq << 8;\\n        }\\n\\n        $bytes = $this->timeGenerator->generate($node, $clockSeq);\\n\\n        \/\/ Replace bytes in the time-based UUID with DCE Security values.\\n        $bytes = substr_replace($bytes, $identifierBytes, 0, 4);\\n\\n        return substr_replace($bytes, $domainByte, 9, 1);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Generator\/TimeGeneratorInterface.php\",\"ext\":\"php\",\"size\":1141,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Generator;\\n\\nuse Ramsey\\\\Uuid\\\\Type\\\\Hexadecimal;\\n\\n\/**\\n * A time generator generates strings of binary data based on a node ID, clock sequence, and the current time\\n *\/\\ninterface TimeGeneratorInterface\\n{\\n    \/**\\n     * Generate a binary string from a node ID, clock sequence, and current time\\n     *\\n     * @param Hexadecimal | int | string | null $node A 48-bit number representing the hardware address; this number may\\n     *     be represented as an integer or a hexadecimal string\\n     * @param int | null $clockSeq A 14-bit number used to help avoid duplicates that could arise when the clock is set\\n     *     backwards in time or if the node ID changes\\n     *\\n     * @return string A binary string\\n     *\/\\n    public function generate($node = null, ?int $clockSeq = null): string;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Generator\/CombGenerator.php\",\"ext\":\"php\",\"size\":3490,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Generator;\\n\\nuse Ramsey\\\\Uuid\\\\Converter\\\\NumberConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Exception\\\\InvalidArgumentException;\\n\\nuse function bin2hex;\\nuse function explode;\\nuse function hex2bin;\\nuse function microtime;\\nuse function str_pad;\\nuse function substr;\\n\\nuse const STR_PAD_LEFT;\\n\\n\/**\\n * CombGenerator generates COMBs (combined UUID\/timestamp)\\n *\\n * The CombGenerator, when used with the StringCodec (and, by proxy, the TimestampLastCombCodec) or the\\n * TimestampFirstCombCodec, combines the current timestamp with a UUID (hence the name \\\"COMB\\\"). The timestamp either\\n * appears as the first or last 48 bits of the COMB, depending on the codec used.\\n *\\n * By default, COMBs will have the timestamp set as the last 48 bits of the identifier.\\n *\\n * ```\\n * $factory = new UuidFactory();\\n *\\n * $factory->setRandomGenerator(new CombGenerator(\\n *     $factory->getRandomGenerator(),\\n *     $factory->getNumberConverter(),\\n * ));\\n *\\n * $comb = $factory->uuid4();\\n * ```\\n *\\n * To generate a COMB with the timestamp as the first 48 bits, set the TimestampFirstCombCodec as the codec.\\n *\\n * ```\\n * $factory->setCodec(new TimestampFirstCombCodec($factory->getUuidBuilder()));\\n * ```\\n *\\n * @deprecated Please migrate to {@link https:\/\/uuid.ramsey.dev\/en\/stable\/rfc4122\/version7.html Version 7, Unix Epoch Time UUIDs}.\\n *\\n * @link https:\/\/web.archive.org\/web\/20240118030355\/https:\/\/www.informit.com\/articles\/printerfriendly\/25862 The Cost of GUIDs as Primary Keys\\n *\/\\nclass CombGenerator implements RandomGeneratorInterface\\n{\\n    public const TIMESTAMP_BYTES = 6;\\n\\n    public function __construct(\\n        private RandomGeneratorInterface $generator,\\n        private NumberConverterInterface $numberConverter\\n    ) {\\n    }\\n\\n    \/**\\n     * @throws InvalidArgumentException if $length is not a positive integer greater than or equal to CombGenerator::TIMESTAMP_BYTES\\n     *\\n     * @inheritDoc\\n     *\/\\n    public function generate(int $length): string\\n    {\\n        if ($length < self::TIMESTAMP_BYTES) {\\n            throw new InvalidArgumentException(\\n                'Length must be a positive integer greater than or equal to ' . self::TIMESTAMP_BYTES\\n            );\\n        }\\n\\n        if ($length % 2 !== 0) {\\n            throw new InvalidArgumentException('Length must be an even number');\\n        }\\n\\n        $hash = '';\\n\\n        \/** @phpstan-ignore greater.alwaysTrue (TIMESTAMP_BYTES constant could change in child classes) *\/\\n        if (self::TIMESTAMP_BYTES > 0 && $length > self::TIMESTAMP_BYTES) {\\n            $hash = $this->generator->generate($length - self::TIMESTAMP_BYTES);\\n        }\\n\\n        $lsbTime = str_pad(\\n            $this->numberConverter->toHex($this->timestamp()),\\n            self::TIMESTAMP_BYTES * 2,\\n            '0',\\n            STR_PAD_LEFT,\\n        );\\n\\n        return (string) hex2bin(str_pad(bin2hex($hash), $length - self::TIMESTAMP_BYTES, '0') . $lsbTime);\\n    }\\n\\n    \/**\\n     * Returns the current timestamp as a string integer, precise to 0.00001 seconds\\n     *\/\\n    private function timestamp(): string\\n    {\\n        $time = explode(' ', microtime(false));\\n\\n        return $time[1] . substr($time[0], 2, 5);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Generator\/DefaultNameGenerator.php\",\"ext\":\"php\",\"size\":1111,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Generator;\\n\\nuse Ramsey\\\\Uuid\\\\Exception\\\\NameException;\\nuse Ramsey\\\\Uuid\\\\UuidInterface;\\nuse ValueError;\\n\\nuse function hash;\\n\\n\/**\\n * DefaultNameGenerator generates strings of binary data based on a namespace, name, and hashing algorithm\\n *\/\\nclass DefaultNameGenerator implements NameGeneratorInterface\\n{\\n    \/**\\n     * @pure\\n     *\/\\n    public function generate(UuidInterface $ns, string $name, string $hashAlgorithm): string\\n    {\\n        try {\\n            return hash($hashAlgorithm, $ns->getBytes() . $name, true);\\n        } catch (ValueError $e) {\\n            throw new NameException(\\n                message: sprintf('Unable to hash namespace and name with algorithm \\\\'%s\\\\'', $hashAlgorithm),\\n                previous: $e,\\n            );\\n        }\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Generator\/PeclUuidRandomGenerator.php\",\"ext\":\"php\",\"size\":816,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Generator;\\n\\nuse function uuid_create;\\nuse function uuid_parse;\\n\\nuse const UUID_TYPE_RANDOM;\\n\\n\/**\\n * PeclUuidRandomGenerator generates strings of random binary data using ext-uuid\\n *\\n * @link https:\/\/pecl.php.net\/package\/uuid ext-uuid\\n *\/\\nclass PeclUuidRandomGenerator implements RandomGeneratorInterface\\n{\\n    public function generate(int $length): string\\n    {\\n        $uuid = uuid_create(UUID_TYPE_RANDOM);\\n\\n        return (string) uuid_parse($uuid);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Generator\/RandomLibAdapter.php\",\"ext\":\"php\",\"size\":1550,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Generator;\\n\\nuse RandomLib\\\\Factory;\\nuse RandomLib\\\\Generator;\\n\\n\/**\\n * RandomLibAdapter generates strings of random binary data using the paragonie\/random-lib library\\n *\\n * @deprecated This class will be removed in 5.0.0. Use the default RandomBytesGenerator or implement your own generator\\n *     that implements RandomGeneratorInterface.\\n *\\n * @link https:\/\/packagist.org\/packages\/paragonie\/random-lib paragonie\/random-lib\\n *\/\\nclass RandomLibAdapter implements RandomGeneratorInterface\\n{\\n    private Generator $generator;\\n\\n    \/**\\n     * Constructs a RandomLibAdapter\\n     *\\n     * By default, if no Generator is passed in, this creates a high-strength generator to use when generating random\\n     * binary data.\\n     *\\n     * @param Generator | null $generator The generator to use when generating binary data\\n     *\/\\n    public function __construct(?Generator $generator = null)\\n    {\\n        if ($generator === null) {\\n            $factory = new Factory();\\n            $generator = $factory->getHighStrengthGenerator();\\n        }\\n\\n        $this->generator = $generator;\\n    }\\n\\n    public function generate(int $length): string\\n    {\\n        return $this->generator->generate($length);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/functions.php\",\"ext\":\"php\",\"size\":4722,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n * phpcs:disable Squiz.Functions.GlobalFunction\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid;\\n\\nuse DateTimeInterface;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Hexadecimal;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Integer as IntegerObject;\\n\\n\/**\\n * Returns a version 1 (Gregorian time) UUID from a host ID, sequence number, and the current time\\n *\\n * @param Hexadecimal | int | string | null $node A 48-bit number representing the hardware address; this number may be\\n *     represented as an integer or a hexadecimal string\\n * @param int | null $clockSeq A 14-bit number used to help avoid duplicates that could arise when the clock is set\\n *     backwards in time or if the node ID changes\\n *\\n * @return non-empty-string Version 1 UUID as a string\\n *\/\\nfunction v1($node = null, ?int $clockSeq = null): string\\n{\\n    return Uuid::uuid1($node, $clockSeq)->toString();\\n}\\n\\n\/**\\n * Returns a version 2 (DCE Security) UUID from a local domain, local identifier, host ID, clock sequence, and the current time\\n *\\n * @param int $localDomain The local domain to use when generating bytes, according to DCE Security\\n * @param IntegerObject | null $localIdentifier The local identifier for the given domain; this may be a UID or GID on\\n *     POSIX systems, if the local domain is a person or group, or it may be a site-defined identifier if the local\\n *     domain is org\\n * @param Hexadecimal | null $node A 48-bit number representing the hardware address\\n * @param int | null $clockSeq A 14-bit number used to help avoid duplicates that could arise when the clock is set\\n *     backwards in time or if the node ID changes\\n *\\n * @return non-empty-string Version 2 UUID as a string\\n *\/\\nfunction v2(\\n    int $localDomain,\\n    ?IntegerObject $localIdentifier = null,\\n    ?Hexadecimal $node = null,\\n    ?int $clockSeq = null,\\n): string {\\n    return Uuid::uuid2($localDomain, $localIdentifier, $node, $clockSeq)->toString();\\n}\\n\\n\/**\\n * Returns a version 3 (name-based) UUID based on the MD5 hash of a namespace ID and a name\\n *\\n * @param UuidInterface | string $ns The namespace (must be a valid UUID)\\n *\\n * @return non-empty-string Version 3 UUID as a string\\n *\\n * @pure\\n *\/\\nfunction v3($ns, string $name): string\\n{\\n    return Uuid::uuid3($ns, $name)->toString();\\n}\\n\\n\/**\\n * Returns a version 4 (random) UUID\\n *\\n * @return non-empty-string Version 4 UUID as a string\\n *\/\\nfunction v4(): string\\n{\\n    return Uuid::uuid4()->toString();\\n}\\n\\n\/**\\n * Returns a version 5 (name-based) UUID based on the SHA-1 hash of a namespace ID and a name\\n *\\n * @param UuidInterface | string $ns The namespace (must be a valid UUID)\\n *\\n * @return non-empty-string Version 5 UUID as a string\\n *\\n * @pure\\n *\/\\nfunction v5($ns, string $name): string\\n{\\n    return Uuid::uuid5($ns, $name)->toString();\\n}\\n\\n\/**\\n * Returns a version 6 (reordered Gregorian time) UUID from a host ID, sequence number, and the current time\\n *\\n * @param Hexadecimal | null $node A 48-bit number representing the hardware address\\n * @param int | null $clockSeq A 14-bit number used to help avoid duplicates that could arise when the clock is set\\n *     backwards in time or if the node ID changes\\n *\\n * @return non-empty-string Version 6 UUID as a string\\n *\/\\nfunction v6(?Hexadecimal $node = null, ?int $clockSeq = null): string\\n{\\n    return Uuid::uuid6($node, $clockSeq)->toString();\\n}\\n\\n\/**\\n * Returns a version 7 (Unix Epoch time) UUID\\n *\\n * @param DateTimeInterface|null $dateTime An optional date\/time from which to create the version 7 UUID. If not\\n *     provided, the UUID is generated using the current date\/time.\\n *\\n * @return non-empty-string Version 7 UUID as a string\\n *\/\\nfunction v7(?DateTimeInterface $dateTime = null): string\\n{\\n    return Uuid::uuid7($dateTime)->toString();\\n}\\n\\n\/**\\n * Returns a version 8 (custom format) UUID\\n *\\n * The bytes provided may contain any value according to your application's needs. Be aware, however, that other\\n * applications may not understand the semantics of the value.\\n *\\n * @param string $bytes A 16-byte octet string. This is an open blob of data that you may fill with 128 bits of\\n *     information. Be aware, however, bits 48 through 51 will be replaced with the UUID version field, and bits 64 and\\n *     65 will be replaced with the UUID variant. You MUST NOT rely on these bits for your application needs.\\n *\\n * @return non-empty-string Version 8 UUID as a string\\n *\\n * @pure\\n *\/\\nfunction v8(string $bytes): string\\n{\\n    return Uuid::uuid8($bytes)->toString();\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Builder\/BuilderCollection.php\",\"ext\":\"php\",\"size\":2519,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Builder;\\n\\nuse Ramsey\\\\Collection\\\\AbstractCollection;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\Number\\\\GenericNumberConverter;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\Time\\\\GenericTimeConverter;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\Time\\\\PhpTimeConverter;\\nuse Ramsey\\\\Uuid\\\\Guid\\\\GuidBuilder;\\nuse Ramsey\\\\Uuid\\\\Math\\\\BrickMathCalculator;\\nuse Ramsey\\\\Uuid\\\\Nonstandard\\\\UuidBuilder as NonstandardUuidBuilder;\\nuse Ramsey\\\\Uuid\\\\Rfc4122\\\\UuidBuilder as Rfc4122UuidBuilder;\\nuse Traversable;\\n\\n\/**\\n * A collection of UuidBuilderInterface objects\\n *\\n * @deprecated this class has been deprecated and will be removed in 5.0.0. The use-case for this class comes from a\\n *     pre-`phpstan\/phpstan` and pre-`vimeo\/psalm` ecosystem, in which type safety had to be mostly enforced at runtime:\\n *     that is no longer necessary, now that you can safely verify your code to be correct, and use more generic types\\n *     like `iterable<T>` instead.\\n *\\n * @extends AbstractCollection<UuidBuilderInterface>\\n *\/\\nclass BuilderCollection extends AbstractCollection\\n{\\n    public function getType(): string\\n    {\\n        return UuidBuilderInterface::class;\\n    }\\n\\n    public function getIterator(): Traversable\\n    {\\n        return parent::getIterator();\\n    }\\n\\n    \/**\\n     * Re-constructs the object from its serialized form\\n     *\\n     * @param string $serialized The serialized PHP string to unserialize into a UuidInterface instance\\n     *\/\\n    public function unserialize($serialized): void\\n    {\\n        \/** @var array<array-key, UuidBuilderInterface> $data *\/\\n        $data = unserialize($serialized, [\\n            'allowed_classes' => [\\n                BrickMathCalculator::class,\\n                GenericNumberConverter::class,\\n                GenericTimeConverter::class,\\n                GuidBuilder::class,\\n                NonstandardUuidBuilder::class,\\n                PhpTimeConverter::class,\\n                Rfc4122UuidBuilder::class,\\n            ],\\n        ]);\\n\\n        $this->data = array_filter(\\n            $data,\\n            function ($unserialized): bool {\\n                \/** @phpstan-ignore instanceof.alwaysTrue *\/\\n                return $unserialized instanceof UuidBuilderInterface;\\n            },\\n        );\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Builder\/DefaultUuidBuilder.php\",\"ext\":\"php\",\"size\":569,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Builder;\\n\\nuse Ramsey\\\\Uuid\\\\Rfc4122\\\\UuidBuilder as Rfc4122UuidBuilder;\\n\\n\/**\\n * @deprecated Please transition to {@see Rfc4122UuidBuilder}.\\n *\\n * @immutable\\n *\/\\nclass DefaultUuidBuilder extends Rfc4122UuidBuilder\\n{\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Builder\/FallbackBuilder.php\",\"ext\":\"php\",\"size\":1880,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Builder;\\n\\nuse Ramsey\\\\Uuid\\\\Codec\\\\CodecInterface;\\nuse Ramsey\\\\Uuid\\\\Exception\\\\BuilderNotFoundException;\\nuse Ramsey\\\\Uuid\\\\Exception\\\\UnableToBuildUuidException;\\nuse Ramsey\\\\Uuid\\\\UuidInterface;\\n\\n\/**\\n * FallbackBuilder builds a UUID by stepping through a list of UUID builders until a UUID can be constructed without exceptions\\n *\\n * @immutable\\n *\/\\nclass FallbackBuilder implements UuidBuilderInterface\\n{\\n    \/**\\n     * @param iterable<UuidBuilderInterface> $builders An array of UUID builders\\n     *\/\\n    public function __construct(private iterable $builders)\\n    {\\n    }\\n\\n    \/**\\n     * Builds and returns a UuidInterface instance using the first builder that succeeds\\n     *\\n     * @param CodecInterface $codec The codec to use for building this instance\\n     * @param string $bytes The byte string from which to construct a UUID\\n     *\\n     * @return UuidInterface an instance of a UUID object\\n     *\\n     * @pure\\n     *\/\\n    public function build(CodecInterface $codec, string $bytes): UuidInterface\\n    {\\n        $lastBuilderException = null;\\n\\n        foreach ($this->builders as $builder) {\\n            try {\\n                return $builder->build($codec, $bytes);\\n            } catch (UnableToBuildUuidException $exception) {\\n                $lastBuilderException = $exception;\\n\\n                continue;\\n            }\\n        }\\n\\n        throw new BuilderNotFoundException(\\n            'Could not find a suitable builder for the provided codec and fields',\\n            0,\\n            $lastBuilderException,\\n        );\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Builder\/UuidBuilderInterface.php\",\"ext\":\"php\",\"size\":1016,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Builder;\\n\\nuse Ramsey\\\\Uuid\\\\Codec\\\\CodecInterface;\\nuse Ramsey\\\\Uuid\\\\UuidInterface;\\n\\n\/**\\n * A UUID builder builds instances of UuidInterface\\n *\\n * @immutable\\n *\/\\ninterface UuidBuilderInterface\\n{\\n    \/**\\n     * Builds and returns a UuidInterface\\n     *\\n     * @param CodecInterface $codec The codec to use for building this UuidInterface instance\\n     * @param string $bytes The byte string from which to construct a UUID\\n     *\\n     * @return UuidInterface Implementations may choose to return more specific instances of UUIDs that implement UuidInterface\\n     *\\n     * @pure\\n     *\/\\n    public function build(CodecInterface $codec, string $bytes): UuidInterface;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Builder\/DegradedUuidBuilder.php\",\"ext\":\"php\",\"size\":2053,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Builder;\\n\\nuse Ramsey\\\\Uuid\\\\Codec\\\\CodecInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\NumberConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\Time\\\\DegradedTimeConverter;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\TimeConverterInterface;\\nuse Ramsey\\\\Uuid\\\\DegradedUuid;\\nuse Ramsey\\\\Uuid\\\\Rfc4122\\\\Fields as Rfc4122Fields;\\nuse Ramsey\\\\Uuid\\\\UuidInterface;\\n\\n\/**\\n * @deprecated DegradedUuid instances are no longer necessary to support 32-bit systems. Please transition to {@see DefaultUuidBuilder}.\\n *\\n * @immutable\\n *\/\\nclass DegradedUuidBuilder implements UuidBuilderInterface\\n{\\n    private TimeConverterInterface $timeConverter;\\n\\n    \/**\\n     * @param NumberConverterInterface $numberConverter The number converter to use when constructing the DegradedUuid\\n     * @param TimeConverterInterface|null $timeConverter The time converter to use for converting timestamps extracted\\n     *     from a UUID to Unix timestamps\\n     *\/\\n    public function __construct(\\n        private NumberConverterInterface $numberConverter,\\n        ?TimeConverterInterface $timeConverter = null\\n    ) {\\n        $this->timeConverter = $timeConverter ?: new DegradedTimeConverter();\\n    }\\n\\n    \/**\\n     * Builds and returns a DegradedUuid\\n     *\\n     * @param CodecInterface $codec The codec to use for building this DegradedUuid instance\\n     * @param string $bytes The byte string from which to construct a UUID\\n     *\\n     * @return DegradedUuid The DegradedUuidBuild returns an instance of Ramsey\\\\Uuid\\\\DegradedUuid\\n     *\\n     * @phpstan-impure\\n     *\/\\n    public function build(CodecInterface $codec, string $bytes): UuidInterface\\n    {\\n        return new DegradedUuid(new Rfc4122Fields($bytes), $this->numberConverter, $codec, $this->timeConverter);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Fields\/SerializableFieldsTrait.php\",\"ext\":\"php\",\"size\":1903,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Fields;\\n\\nuse ValueError;\\n\\nuse function base64_decode;\\nuse function sprintf;\\nuse function strlen;\\n\\n\/**\\n * Provides common serialization functionality to fields\\n *\\n * @immutable\\n *\/\\ntrait SerializableFieldsTrait\\n{\\n    \/**\\n     * @param string $bytes The bytes that comprise the fields\\n     *\/\\n    abstract public function __construct(string $bytes);\\n\\n    \/**\\n     * Returns the bytes that comprise the fields\\n     *\/\\n    abstract public function getBytes(): string;\\n\\n    \/**\\n     * Returns a string representation of the object\\n     *\/\\n    public function serialize(): string\\n    {\\n        return $this->getBytes();\\n    }\\n\\n    \/**\\n     * @return array{bytes: string}\\n     *\/\\n    public function __serialize(): array\\n    {\\n        return ['bytes' => $this->getBytes()];\\n    }\\n\\n    \/**\\n     * Constructs the object from a serialized string representation\\n     *\\n     * @param string $data The serialized string representation of the object\\n     *\/\\n    public function unserialize(string $data): void\\n    {\\n        if (strlen($data) === 16) {\\n            $this->__construct($data);\\n        } else {\\n            $this->__construct(base64_decode($data));\\n        }\\n    }\\n\\n    \/**\\n     * @param array{bytes?: string} $data\\n     *\/\\n    public function __unserialize(array $data): void\\n    {\\n        \/\/ @codeCoverageIgnoreStart\\n        if (!isset($data['bytes'])) {\\n            throw new ValueError(sprintf('%s(): Argument #1 ($data) is invalid', __METHOD__));\\n        }\\n        \/\/ @codeCoverageIgnoreEnd\\n\\n        $this->unserialize($data['bytes']);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Fields\/FieldsInterface.php\",\"ext\":\"php\",\"size\":753,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Fields;\\n\\nuse Serializable;\\n\\n\/**\\n * UUIDs consist of unsigned integers, the bytes of which are separated into fields and arranged in a particular layout\\n * defined by the specification for the variant\\n *\\n * @immutable\\n *\/\\ninterface FieldsInterface extends Serializable\\n{\\n    \/**\\n     * Returns the bytes that comprise the fields\\n     *\\n     * @pure\\n     *\/\\n    public function getBytes(): string;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Math\/RoundingMode.php\",\"ext\":\"php\",\"size\":4909,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file was originally part of brick\/math\\n *\\n * Copyright (c) 2013-present Benjamin Morel\\n *\\n * Permission is hereby granted, free of charge, to any person obtaining a copy\\n * of this software and associated documentation files (the \\\"Software\\\"), to deal\\n * in the Software without restriction, including without limitation the rights\\n * to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\\n * copies of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be included in\\n * all copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n * SOFTWARE.\\n *\\n * @link https:\/\/github.com\/brick\/math brick\/math at GitHub\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Math;\\n\\n\/**\\n * Specifies a rounding behavior for numerical operations capable of discarding precision.\\n *\\n * Each rounding mode indicates how the least significant returned digit of a rounded result is to be calculated. If\\n * fewer digits are returned than the digits needed to represent the exact numerical result, the discarded digits will\\n * be referred to as the discarded fraction regardless of the digits' contribution to the value of the number. In other\\n * words, considered as a numerical value, the discarded fraction could have an absolute value greater than one.\\n *\/\\nfinal class RoundingMode\\n{\\n    \/**\\n     * Asserts that the requested operation has an exact result; hence no rounding is necessary.\\n     *\/\\n    public const UNNECESSARY = 0;\\n\\n    \/**\\n     * Rounds away from zero.\\n     *\\n     * Always increments the digit prior to a nonzero discarded fraction. Note that this rounding mode never decreases\\n     * the magnitude of the calculated value.\\n     *\/\\n    public const UP = 1;\\n\\n    \/**\\n     * Rounds towards zero.\\n     *\\n     * Never increments the digit prior to a discarded fraction (i.e., truncates). Note that this rounding mode never\\n     * increases the magnitude of the calculated value.\\n     *\/\\n    public const DOWN = 2;\\n\\n    \/**\\n     * Rounds towards positive infinity.\\n     *\\n     * If the result is positive, behaves as for UP; if negative, behaves as for DOWN. Note that this rounding mode\\n     * never decreases the calculated value.\\n     *\/\\n    public const CEILING = 3;\\n\\n    \/**\\n     * Rounds towards negative infinity.\\n     *\\n     * If the result is positive, behave as for DOWN; if negative, behave as for UP. Note that this rounding mode never\\n     * increases the calculated value.\\n     *\/\\n    public const FLOOR = 4;\\n\\n    \/**\\n     * Rounds towards \\\"nearest neighbor\\\" unless both neighbors are equidistant, in which case round up.\\n     *\\n     * Behaves as for UP if the discarded fraction is >= 0.5; otherwise, behaves as for DOWN. Note that this is the\\n     * rounding mode commonly taught at school.\\n     *\/\\n    public const HALF_UP = 5;\\n\\n    \/**\\n     * Rounds towards \\\"nearest neighbor\\\" unless both neighbors are equidistant, in which case round down.\\n     *\\n     * Behaves as for UP if the discarded fraction is > 0.5; otherwise, behaves as for DOWN.\\n     *\/\\n    public const HALF_DOWN = 6;\\n\\n    \/**\\n     * Rounds towards \\\"nearest neighbor\\\" unless both neighbors are equidistant, in which case round towards positive infinity.\\n     *\\n     * If the result is positive, behaves as for HALF_UP; if negative, behaves as for HALF_DOWN.\\n     *\/\\n    public const HALF_CEILING = 7;\\n\\n    \/**\\n     * Rounds towards \\\"nearest neighbor\\\" unless both neighbors are equidistant, in which case round towards negative infinity.\\n     *\\n     * If the result is positive, behaves as for HALF_DOWN; if negative, behaves as for HALF_UP.\\n     *\/\\n    public const HALF_FLOOR = 8;\\n\\n    \/**\\n     * Rounds towards the \\\"nearest neighbor\\\" unless both neighbors are equidistant, in which case rounds towards the even neighbor.\\n     *\\n     * Behaves as for HALF_UP if the digit to the left of the discarded fraction is odd; behaves as for HALF_DOWN if it's even.\\n     *\\n     * Note that this is the rounding mode that statistically minimizes cumulative error when applied repeatedly over a\\n     * sequence of calculations. It is sometimes known as \\\"Banker's rounding\\\", and is chiefly used in the USA.\\n     *\/\\n    public const HALF_EVEN = 9;\\n\\n    \/**\\n     * Private constructor. This class is not instantiable.\\n     *\\n     * @codeCoverageIgnore\\n     *\/\\n    private function __construct()\\n    {\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Math\/CalculatorInterface.php\",\"ext\":\"php\",\"size\":3854,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Math;\\n\\nuse Ramsey\\\\Uuid\\\\Type\\\\Hexadecimal;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Integer as IntegerObject;\\nuse Ramsey\\\\Uuid\\\\Type\\\\NumberInterface;\\n\\n\/**\\n * A calculator performs arithmetic operations on numbers\\n *\\n * @immutable\\n *\/\\ninterface CalculatorInterface\\n{\\n    \/**\\n     * Returns the sum of all the provided parameters\\n     *\\n     * @param NumberInterface $augend The first addend (the integer being added to)\\n     * @param NumberInterface ...$addends The additional integers to a add to the augend\\n     *\\n     * @return NumberInterface The sum of all the parameters\\n     *\\n     * @pure\\n     *\/\\n    public function add(NumberInterface $augend, NumberInterface ...$addends): NumberInterface;\\n\\n    \/**\\n     * Returns the difference of all the provided parameters\\n     *\\n     * @param NumberInterface $minuend The integer being subtracted from\\n     * @param NumberInterface ...$subtrahends The integers to subtract from the minuend\\n     *\\n     * @return NumberInterface The difference after subtracting all parameters\\n     *\\n     * @pure\\n     *\/\\n    public function subtract(NumberInterface $minuend, NumberInterface ...$subtrahends): NumberInterface;\\n\\n    \/**\\n     * Returns the product of all the provided parameters\\n     *\\n     * @param NumberInterface $multiplicand The integer to be multiplied\\n     * @param NumberInterface ...$multipliers The factors by which to multiply the multiplicand\\n     *\\n     * @return NumberInterface The product of multiplying all the provided parameters\\n     *\\n     * @pure\\n     *\/\\n    public function multiply(NumberInterface $multiplicand, NumberInterface ...$multipliers): NumberInterface;\\n\\n    \/**\\n     * Returns the quotient of the provided parameters divided left-to-right\\n     *\\n     * @param int $roundingMode The RoundingMode constant to use for this operation\\n     * @param int $scale The scale to use for this operation\\n     * @param NumberInterface $dividend The integer to be divided\\n     * @param NumberInterface ...$divisors The integers to divide $dividend by, in the order in which the division\\n     *     operations should take place (left-to-right)\\n     *\\n     * @return NumberInterface The quotient of dividing the provided parameters left-to-right\\n     *\\n     * @pure\\n     *\/\\n    public function divide(\\n        int $roundingMode,\\n        int $scale,\\n        NumberInterface $dividend,\\n        NumberInterface ...$divisors,\\n    ): NumberInterface;\\n\\n    \/**\\n     * Converts a value from an arbitrary base to a base-10 integer value\\n     *\\n     * @param string $value The value to convert\\n     * @param int $base The base to convert from (i.e., 2, 16, 32, etc.)\\n     *\\n     * @return IntegerObject The base-10 integer value of the converted value\\n     *\\n     * @pure\\n     *\/\\n    public function fromBase(string $value, int $base): IntegerObject;\\n\\n    \/**\\n     * Converts a base-10 integer value to an arbitrary base\\n     *\\n     * @param IntegerObject $value The integer value to convert\\n     * @param int $base The base to convert to (i.e., 2, 16, 32, etc.)\\n     *\\n     * @return string The value represented in the specified base\\n     *\\n     * @pure\\n     *\/\\n    public function toBase(IntegerObject $value, int $base): string;\\n\\n    \/**\\n     * Converts an Integer instance to a Hexadecimal instance\\n     *\\n     * @pure\\n     *\/\\n    public function toHexadecimal(IntegerObject $value): Hexadecimal;\\n\\n    \/**\\n     * Converts a Hexadecimal instance to an Integer instance\\n     *\\n     * @pure\\n     *\/\\n    public function toInteger(Hexadecimal $value): IntegerObject;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Math\/BrickMathCalculator.php\",\"ext\":\"php\",\"size\":5528,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Math;\\n\\nuse Brick\\\\Math\\\\BigDecimal;\\nuse Brick\\\\Math\\\\BigInteger;\\nuse Brick\\\\Math\\\\Exception\\\\MathException;\\nuse Brick\\\\Math\\\\RoundingMode as BrickMathRounding;\\nuse Ramsey\\\\Uuid\\\\Exception\\\\InvalidArgumentException;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Decimal;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Hexadecimal;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Integer as IntegerObject;\\nuse Ramsey\\\\Uuid\\\\Type\\\\NumberInterface;\\n\\n\/**\\n * A calculator using the brick\/math library for arbitrary-precision arithmetic\\n *\\n * @immutable\\n *\/\\nfinal class BrickMathCalculator implements CalculatorInterface\\n{\\n    private const ROUNDING_MODE_MAP = [\\n        RoundingMode::UNNECESSARY => BrickMathRounding::UNNECESSARY,\\n        RoundingMode::UP => BrickMathRounding::UP,\\n        RoundingMode::DOWN => BrickMathRounding::DOWN,\\n        RoundingMode::CEILING => BrickMathRounding::CEILING,\\n        RoundingMode::FLOOR => BrickMathRounding::FLOOR,\\n        RoundingMode::HALF_UP => BrickMathRounding::HALF_UP,\\n        RoundingMode::HALF_DOWN => BrickMathRounding::HALF_DOWN,\\n        RoundingMode::HALF_CEILING => BrickMathRounding::HALF_CEILING,\\n        RoundingMode::HALF_FLOOR => BrickMathRounding::HALF_FLOOR,\\n        RoundingMode::HALF_EVEN => BrickMathRounding::HALF_EVEN,\\n    ];\\n\\n    public function add(NumberInterface $augend, NumberInterface ...$addends): NumberInterface\\n    {\\n        $sum = BigInteger::of($augend->toString());\\n\\n        foreach ($addends as $addend) {\\n            $sum = $sum->plus($addend->toString()); \/** @phpstan-ignore possiblyImpure.methodCall *\/\\n        }\\n\\n        \/** @phpstan-ignore possiblyImpure.methodCall, possiblyImpure.new *\/\\n        return new IntegerObject((string) $sum);\\n    }\\n\\n    public function subtract(NumberInterface $minuend, NumberInterface ...$subtrahends): NumberInterface\\n    {\\n        $difference = BigInteger::of($minuend->toString());\\n\\n        foreach ($subtrahends as $subtrahend) {\\n            $difference = $difference->minus($subtrahend->toString()); \/** @phpstan-ignore possiblyImpure.methodCall *\/\\n        }\\n\\n        \/** @phpstan-ignore possiblyImpure.methodCall, possiblyImpure.new *\/\\n        return new IntegerObject((string) $difference);\\n    }\\n\\n    public function multiply(NumberInterface $multiplicand, NumberInterface ...$multipliers): NumberInterface\\n    {\\n        $product = BigInteger::of($multiplicand->toString());\\n\\n        foreach ($multipliers as $multiplier) {\\n            \/** @phpstan-ignore possiblyImpure.methodCall *\/\\n            $product = $product->multipliedBy($multiplier->toString());\\n        }\\n\\n        \/** @phpstan-ignore possiblyImpure.methodCall, possiblyImpure.new *\/\\n        return new IntegerObject((string) $product);\\n    }\\n\\n    public function divide(\\n        int $roundingMode,\\n        int $scale,\\n        NumberInterface $dividend,\\n        NumberInterface ...$divisors,\\n    ): NumberInterface {\\n        \/** @phpstan-ignore possiblyImpure.methodCall *\/\\n        $brickRounding = $this->getBrickRoundingMode($roundingMode);\\n\\n        $quotient = BigDecimal::of($dividend->toString());\\n\\n        foreach ($divisors as $divisor) {\\n            \/** @phpstan-ignore possiblyImpure.methodCall *\/\\n            $quotient = $quotient->dividedBy($divisor->toString(), $scale, $brickRounding);\\n        }\\n\\n        if ($scale === 0) {\\n            \/** @phpstan-ignore possiblyImpure.methodCall, possiblyImpure.methodCall, possiblyImpure.new *\/\\n            return new IntegerObject((string) $quotient->toBigInteger());\\n        }\\n\\n        \/** @phpstan-ignore possiblyImpure.methodCall, possiblyImpure.new *\/\\n        return new Decimal((string) $quotient);\\n    }\\n\\n    public function fromBase(string $value, int $base): IntegerObject\\n    {\\n        try {\\n            \/** @phpstan-ignore possiblyImpure.methodCall, possiblyImpure.new *\/\\n            return new IntegerObject((string) BigInteger::fromBase($value, $base));\\n        } catch (MathException | \\\\InvalidArgumentException $exception) {\\n            throw new InvalidArgumentException(\\n                $exception->getMessage(),\\n                (int) $exception->getCode(),\\n                $exception\\n            );\\n        }\\n    }\\n\\n    public function toBase(IntegerObject $value, int $base): string\\n    {\\n        try {\\n            \/** @phpstan-ignore possiblyImpure.methodCall *\/\\n            return BigInteger::of($value->toString())->toBase($base);\\n        } catch (MathException | \\\\InvalidArgumentException $exception) {\\n            throw new InvalidArgumentException(\\n                $exception->getMessage(),\\n                (int) $exception->getCode(),\\n                $exception\\n            );\\n        }\\n    }\\n\\n    public function toHexadecimal(IntegerObject $value): Hexadecimal\\n    {\\n        \/** @phpstan-ignore possiblyImpure.new *\/\\n        return new Hexadecimal($this->toBase($value, 16));\\n    }\\n\\n    public function toInteger(Hexadecimal $value): IntegerObject\\n    {\\n        return $this->fromBase($value->toString(), 16);\\n    }\\n\\n    \/**\\n     * Maps ramsey\/uuid rounding modes to those used by brick\/math\\n     *\\n     * @return BrickMathRounding::*\\n     *\/\\n    private function getBrickRoundingMode(int $roundingMode)\\n    {\\n        return self::ROUNDING_MODE_MAP[$roundingMode] ?? BrickMathRounding::UNNECESSARY;\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Lazy\/LazyUuidFromString.php\",\"ext\":\"php\",\"size\":13724,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Lazy;\\n\\nuse DateTimeInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\NumberConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Exception\\\\UnsupportedOperationException;\\nuse Ramsey\\\\Uuid\\\\Fields\\\\FieldsInterface;\\nuse Ramsey\\\\Uuid\\\\Rfc4122\\\\UuidV1;\\nuse Ramsey\\\\Uuid\\\\Rfc4122\\\\UuidV6;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Hexadecimal;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Integer as IntegerObject;\\nuse Ramsey\\\\Uuid\\\\UuidFactory;\\nuse Ramsey\\\\Uuid\\\\UuidInterface;\\nuse ValueError;\\n\\nuse function assert;\\nuse function bin2hex;\\nuse function hex2bin;\\nuse function sprintf;\\nuse function str_replace;\\nuse function substr;\\n\\n\/**\\n * Lazy version of a UUID: its format has not been determined yet, so it is mostly only usable for string\/bytes\\n * conversion. This object optimizes instantiation, serialization and string conversion time, at the cost of increased\\n * overhead for more advanced UUID operations.\\n *\\n * > [!NOTE]\\n * > The {@see FieldsInterface} does not declare methods that deprecated API relies upon: the API has been ported from\\n * > the {@see \\\\Ramsey\\\\Uuid\\\\Uuid} definition, and is deprecated anyway.\\n *\\n * > [!NOTE]\\n * > The deprecated API from {@see \\\\Ramsey\\\\Uuid\\\\Uuid} is in use here (on purpose): it will be removed once the\\n * > deprecated API is gone from this class too.\\n *\\n * @internal this type is used internally for performance reasons and is not supposed to be directly referenced in consumer libraries.\\n *\/\\nfinal class LazyUuidFromString implements UuidInterface\\n{\\n    public const VALID_REGEX = '\/\\\\A[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\\\\z\/ms';\\n\\n    private ?UuidInterface $unwrapped = null;\\n\\n    \/**\\n     * @param non-empty-string $uuid\\n     *\/\\n    public function __construct(private string $uuid)\\n    {\\n    }\\n\\n    public static function fromBytes(string $bytes): self\\n    {\\n        $base16Uuid = bin2hex($bytes);\\n\\n        return new self(\\n            substr($base16Uuid, 0, 8)\\n            . '-'\\n            . substr($base16Uuid, 8, 4)\\n            . '-'\\n            . substr($base16Uuid, 12, 4)\\n            . '-'\\n            . substr($base16Uuid, 16, 4)\\n            . '-'\\n            . substr($base16Uuid, 20, 12)\\n        );\\n    }\\n\\n    public function serialize(): string\\n    {\\n        return $this->uuid;\\n    }\\n\\n    \/**\\n     * @return array{string: non-empty-string}\\n     *\/\\n    public function __serialize(): array\\n    {\\n        return ['string' => $this->uuid];\\n    }\\n\\n    \/**\\n     * {@inheritDoc}\\n     *\\n     * @param non-empty-string $data\\n     *\/\\n    public function unserialize(string $data): void\\n    {\\n        $this->uuid = $data;\\n    }\\n\\n    \/**\\n     * @param array{string?: non-empty-string} $data\\n     *\/\\n    public function __unserialize(array $data): void\\n    {\\n        \/\/ @codeCoverageIgnoreStart\\n        if (!isset($data['string'])) {\\n            throw new ValueError(sprintf('%s(): Argument #1 ($data) is invalid', __METHOD__));\\n        }\\n        \/\/ @codeCoverageIgnoreEnd\\n\\n        $this->unserialize($data['string']);\\n    }\\n\\n    public function getNumberConverter(): NumberConverterInterface\\n    {\\n        return ($this->unwrapped ?? $this->unwrap())->getNumberConverter();\\n    }\\n\\n    \/**\\n     * @inheritDoc\\n     *\/\\n    public function getFieldsHex(): array\\n    {\\n        return ($this->unwrapped ?? $this->unwrap())->getFieldsHex();\\n    }\\n\\n    public function getClockSeqHiAndReservedHex(): string\\n    {\\n        return ($this->unwrapped ?? $this->unwrap())->getClockSeqHiAndReservedHex();\\n    }\\n\\n    public function getClockSeqLowHex(): string\\n    {\\n        return ($this->unwrapped ?? $this->unwrap())->getClockSeqLowHex();\\n    }\\n\\n    public function getClockSequenceHex(): string\\n    {\\n        return ($this->unwrapped ?? $this->unwrap())->getClockSequenceHex();\\n    }\\n\\n    public function getDateTime(): DateTimeInterface\\n    {\\n        return ($this->unwrapped ?? $this->unwrap())->getDateTime();\\n    }\\n\\n    public function getLeastSignificantBitsHex(): string\\n    {\\n        return ($this->unwrapped ?? $this->unwrap())->getLeastSignificantBitsHex();\\n    }\\n\\n    public function getMostSignificantBitsHex(): string\\n    {\\n        return ($this->unwrapped ?? $this->unwrap())->getMostSignificantBitsHex();\\n    }\\n\\n    public function getNodeHex(): string\\n    {\\n        return ($this->unwrapped ?? $this->unwrap())->getNodeHex();\\n    }\\n\\n    public function getTimeHiAndVersionHex(): string\\n    {\\n        return ($this->unwrapped ?? $this->unwrap())->getTimeHiAndVersionHex();\\n    }\\n\\n    public function getTimeLowHex(): string\\n    {\\n        return ($this->unwrapped ?? $this->unwrap())->getTimeLowHex();\\n    }\\n\\n    public function getTimeMidHex(): string\\n    {\\n        return ($this->unwrapped ?? $this->unwrap())->getTimeMidHex();\\n    }\\n\\n    public function getTimestampHex(): string\\n    {\\n        return ($this->unwrapped ?? $this->unwrap())->getTimestampHex();\\n    }\\n\\n    public function getUrn(): string\\n    {\\n        return ($this->unwrapped ?? $this->unwrap())->getUrn();\\n    }\\n\\n    public function getVariant(): ?int\\n    {\\n        return ($this->unwrapped ?? $this->unwrap())->getVariant();\\n    }\\n\\n    public function getVersion(): ?int\\n    {\\n        return ($this->unwrapped ?? $this->unwrap())->getVersion();\\n    }\\n\\n    public function compareTo(UuidInterface $other): int\\n    {\\n        return ($this->unwrapped ?? $this->unwrap())->compareTo($other);\\n    }\\n\\n    public function equals(?object $other): bool\\n    {\\n        if (!$other instanceof UuidInterface) {\\n            return false;\\n        }\\n\\n        return $this->uuid === $other->toString();\\n    }\\n\\n    public function getBytes(): string\\n    {\\n        \/**\\n         * @var non-empty-string\\n         * @phpstan-ignore possiblyImpure.functionCall, possiblyImpure.functionCall\\n         *\/\\n        return (string) hex2bin(str_replace('-', '', $this->uuid));\\n    }\\n\\n    public function getFields(): FieldsInterface\\n    {\\n        return ($this->unwrapped ?? $this->unwrap())->getFields();\\n    }\\n\\n    public function getHex(): Hexadecimal\\n    {\\n        return ($this->unwrapped ?? $this->unwrap())->getHex();\\n    }\\n\\n    public function getInteger(): IntegerObject\\n    {\\n        return ($this->unwrapped ?? $this->unwrap())->getInteger();\\n    }\\n\\n    public function toString(): string\\n    {\\n        return $this->uuid;\\n    }\\n\\n    public function __toString(): string\\n    {\\n        return $this->uuid;\\n    }\\n\\n    public function jsonSerialize(): string\\n    {\\n        return $this->uuid;\\n    }\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see FieldsInterface} instance. If it is a\\n     *     {@see Rfc4122FieldsInterface} instance, you may call {@see Rfc4122FieldsInterface::getClockSeqHiAndReserved()}\\n     *     and use the arbitrary-precision math library of your choice to convert it to a string integer.\\n     *\/\\n    public function getClockSeqHiAndReserved(): string\\n    {\\n        $instance = ($this->unwrapped ?? $this->unwrap());\\n\\n        $fields = $instance->getFields();\\n        assert($fields instanceof \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface);\\n\\n        return $instance->getNumberConverter()->fromHex($fields->getClockSeqHiAndReserved()->toString());\\n    }\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see FieldsInterface} instance. If it is a\\n     *     {@see Rfc4122FieldsInterface} instance, you may call {@see Rfc4122FieldsInterface::getClockSeqLow()} and use\\n     *     the arbitrary-precision math library of your choice to convert it to a string integer.\\n     *\/\\n    public function getClockSeqLow(): string\\n    {\\n        $instance = ($this->unwrapped ?? $this->unwrap());\\n\\n        $fields = $instance->getFields();\\n        assert($fields instanceof \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface);\\n\\n        return $instance->getNumberConverter()->fromHex($fields->getClockSeqLow()->toString());\\n    }\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see FieldsInterface} instance. If it is a\\n     *     {@see Rfc4122FieldsInterface} instance, you may call {@see Rfc4122FieldsInterface::getClockSeq()} and use the\\n     *     arbitrary-precision math library of your choice to convert it to a string integer.\\n     *\/\\n    public function getClockSequence(): string\\n    {\\n        $instance = ($this->unwrapped ?? $this->unwrap());\\n\\n        $fields = $instance->getFields();\\n        assert($fields instanceof \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface);\\n\\n        return $instance->getNumberConverter()->fromHex($fields->getClockSeq()->toString());\\n    }\\n\\n    \/**\\n     * @deprecated This method will be removed in 5.0.0. There is no direct alternative, but the same information may be\\n     *     obtained by splitting in half the value returned by {@see UuidInterface::getHex()}.\\n     *\/\\n    public function getLeastSignificantBits(): string\\n    {\\n        $instance = ($this->unwrapped ?? $this->unwrap());\\n\\n        return $instance->getNumberConverter()->fromHex(substr($instance->getHex()->toString(), 16));\\n    }\\n\\n    \/**\\n     * @deprecated This method will be removed in 5.0.0. There is no direct alternative, but the same information may be\\n     *     obtained by splitting in half the value returned by {@see UuidInterface::getHex()}.\\n     *\/\\n    public function getMostSignificantBits(): string\\n    {\\n        $instance = ($this->unwrapped ?? $this->unwrap());\\n\\n        return $instance->getNumberConverter()->fromHex(substr($instance->getHex()->toString(), 0, 16));\\n    }\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see FieldsInterface} instance. If it is a\\n     *     {@see Rfc4122FieldsInterface} instance, you may call {@see Rfc4122FieldsInterface::getNode()} and use the\\n     *     arbitrary-precision math library of your choice to convert it to a string integer.\\n     *\/\\n    public function getNode(): string\\n    {\\n        $instance = ($this->unwrapped ?? $this->unwrap());\\n\\n        $fields = $instance->getFields();\\n        assert($fields instanceof \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface);\\n\\n        return $instance->getNumberConverter()->fromHex($fields->getNode()->toString());\\n    }\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see FieldsInterface} instance. If it is a\\n     *     {@see Rfc4122FieldsInterface} instance, you may call {@see Rfc4122FieldsInterface::getTimeHiAndVersion()} and\\n     *     use the arbitrary-precision math library of your choice to convert it to a string integer.\\n     *\/\\n    public function getTimeHiAndVersion(): string\\n    {\\n        $instance = ($this->unwrapped ?? $this->unwrap());\\n\\n        $fields = $instance->getFields();\\n        assert($fields instanceof \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface);\\n\\n        return $instance->getNumberConverter()->fromHex($fields->getTimeHiAndVersion()->toString());\\n    }\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see FieldsInterface} instance. If it is a\\n     *     {@see Rfc4122FieldsInterface} instance, you may call {@see Rfc4122FieldsInterface::getTimeLow()} and use the\\n     *     arbitrary-precision math library of your choice to convert it to a string integer.\\n     *\/\\n    public function getTimeLow(): string\\n    {\\n        $instance = ($this->unwrapped ?? $this->unwrap());\\n\\n        $fields = $instance->getFields();\\n        assert($fields instanceof \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface);\\n\\n        return $instance->getNumberConverter()->fromHex($fields->getTimeLow()->toString());\\n    }\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see FieldsInterface} instance. If it is a\\n     *     {@see Rfc4122FieldsInterface} instance, you may call {@see Rfc4122FieldsInterface::getTimeMid()} and use the\\n     *     arbitrary-precision math library of your choice to convert it to a string integer.\\n     *\/\\n    public function getTimeMid(): string\\n    {\\n        $instance = ($this->unwrapped ?? $this->unwrap());\\n\\n        $fields = $instance->getFields();\\n        assert($fields instanceof \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface);\\n\\n        return $instance->getNumberConverter()->fromHex($fields->getTimeMid()->toString());\\n    }\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see FieldsInterface} instance. If it is a\\n     *     {@see Rfc4122FieldsInterface} instance, you may call {@see Rfc4122FieldsInterface::getTimestamp()} and use\\n     *     the arbitrary-precision math library of your choice to convert it to a string integer.\\n     *\/\\n    public function getTimestamp(): string\\n    {\\n        $instance = ($this->unwrapped ?? $this->unwrap());\\n\\n        $fields = $instance->getFields();\\n        assert($fields instanceof \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface);\\n\\n        if ($fields->getVersion() !== 1) {\\n            throw new UnsupportedOperationException('Not a time-based UUID');\\n        }\\n\\n        return $instance->getNumberConverter()->fromHex($fields->getTimestamp()->toString());\\n    }\\n\\n    public function toUuidV1(): UuidV1\\n    {\\n        $instance = ($this->unwrapped ?? $this->unwrap());\\n\\n        if ($instance instanceof UuidV1) {\\n            return $instance;\\n        }\\n\\n        assert($instance instanceof UuidV6);\\n\\n        return $instance->toUuidV1();\\n    }\\n\\n    public function toUuidV6(): UuidV6\\n    {\\n        $instance = ($this->unwrapped ?? $this->unwrap());\\n\\n        assert($instance instanceof UuidV6);\\n\\n        return $instance;\\n    }\\n\\n    private function unwrap(): UuidInterface\\n    {\\n        return $this->unwrapped = (new UuidFactory())->fromString($this->uuid);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/DeprecatedUuidMethodsTrait.php\",\"ext\":\"php\",\"size\":13324,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid;\\n\\nuse DateTimeImmutable;\\nuse DateTimeInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\NumberConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Exception\\\\DateTimeException;\\nuse Ramsey\\\\Uuid\\\\Exception\\\\UnsupportedOperationException;\\nuse Throwable;\\n\\nuse function str_pad;\\nuse function substr;\\n\\nuse const STR_PAD_LEFT;\\n\\n\/**\\n * This trait encapsulates deprecated methods for ramsey\/uuid; this trait and its methods will be removed in ramsey\/uuid 5.0.0.\\n *\\n * @deprecated This trait and its methods will be removed in ramsey\/uuid 5.0.0.\\n *\\n * @immutable\\n *\/\\ntrait DeprecatedUuidMethodsTrait\\n{\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see \\\\Ramsey\\\\Uuid\\\\Fields\\\\FieldsInterface} instance.\\n     *     If it is a {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface} instance, you may call\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface::getClockSeqHiAndReserved()} and use the arbitrary-precision math\\n     *     library of your choice to convert it to a string integer.\\n     *\/\\n    public function getClockSeqHiAndReserved(): string\\n    {\\n        return $this->numberConverter->fromHex($this->fields->getClockSeqHiAndReserved()->toString());\\n    }\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see \\\\Ramsey\\\\Uuid\\\\Fields\\\\FieldsInterface} instance.\\n     *     If it is a {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface} instance, you may call\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface::getClockSeqHiAndReserved()}.\\n     *\/\\n    public function getClockSeqHiAndReservedHex(): string\\n    {\\n        return $this->fields->getClockSeqHiAndReserved()->toString();\\n    }\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see \\\\Ramsey\\\\Uuid\\\\Fields\\\\FieldsInterface} instance.\\n     *     If it is a {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface} instance, you may call\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface::getClockSeqLow()} and use the arbitrary-precision math library of\\n     *     your choice to convert it to a string integer.\\n     *\/\\n    public function getClockSeqLow(): string\\n    {\\n        return $this->numberConverter->fromHex($this->fields->getClockSeqLow()->toString());\\n    }\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see \\\\Ramsey\\\\Uuid\\\\Fields\\\\FieldsInterface} instance.\\n     *     If it is a {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface} instance, you may call\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface::getClockSeqLow()}.\\n     *\/\\n    public function getClockSeqLowHex(): string\\n    {\\n        return $this->fields->getClockSeqLow()->toString();\\n    }\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see \\\\Ramsey\\\\Uuid\\\\Fields\\\\FieldsInterface} instance.\\n     *     If it is a {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface} instance, you may call\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface::getClockSeq()} and use the arbitrary-precision math library of\\n     *     your choice to convert it to a string integer.\\n     *\/\\n    public function getClockSequence(): string\\n    {\\n        return $this->numberConverter->fromHex($this->fields->getClockSeq()->toString());\\n    }\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see \\\\Ramsey\\\\Uuid\\\\Fields\\\\FieldsInterface} instance.\\n     *     If it is a {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface} instance, you may call\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface::getClockSeq()}.\\n     *\/\\n    public function getClockSequenceHex(): string\\n    {\\n        return $this->fields->getClockSeq()->toString();\\n    }\\n\\n    \/**\\n     * @deprecated This method will be removed in 5.0.0. There is no alternative recommendation, so plan accordingly.\\n     *\/\\n    public function getNumberConverter(): NumberConverterInterface\\n    {\\n        return $this->numberConverter;\\n    }\\n\\n    \/**\\n     * @deprecated In ramsey\/uuid version 5.0.0, this will be removed. It is available at {@see UuidV1::getDateTime()}.\\n     *\\n     * @return DateTimeImmutable An immutable instance of DateTimeInterface\\n     *\\n     * @throws UnsupportedOperationException if UUID is not time-based\\n     * @throws DateTimeException if DateTime throws an exception\/error\\n     *\/\\n    public function getDateTime(): DateTimeInterface\\n    {\\n        if ($this->fields->getVersion() !== 1) {\\n            throw new UnsupportedOperationException('Not a time-based UUID');\\n        }\\n\\n        $time = $this->timeConverter->convertTime($this->fields->getTimestamp());\\n\\n        try {\\n            return new DateTimeImmutable(\\n                '@'\\n                . $time->getSeconds()->toString()\\n                . '.'\\n                . str_pad($time->getMicroseconds()->toString(), 6, '0', STR_PAD_LEFT)\\n            );\\n        } catch (Throwable $e) {\\n            throw new DateTimeException($e->getMessage(), (int) $e->getCode(), $e);\\n        }\\n    }\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see \\\\Ramsey\\\\Uuid\\\\Fields\\\\FieldsInterface} instance.\\n     *\\n     * @return string[]\\n     *\/\\n    public function getFieldsHex(): array\\n    {\\n        return [\\n            'time_low' => $this->fields->getTimeLow()->toString(),\\n            'time_mid' => $this->fields->getTimeMid()->toString(),\\n            'time_hi_and_version' => $this->fields->getTimeHiAndVersion()->toString(),\\n            'clock_seq_hi_and_reserved' => $this->fields->getClockSeqHiAndReserved()->toString(),\\n            'clock_seq_low' => $this->fields->getClockSeqLow()->toString(),\\n            'node' => $this->fields->getNode()->toString(),\\n        ];\\n    }\\n\\n    \/**\\n     * @deprecated This method will be removed in 5.0.0. There is no direct alternative, but the same information may be\\n     *     obtained by splitting in half the value returned by {@see UuidInterface::getHex()}.\\n     *\/\\n    public function getLeastSignificantBits(): string\\n    {\\n        $leastSignificantHex = substr($this->getHex()->toString(), 16);\\n\\n        return $this->numberConverter->fromHex($leastSignificantHex);\\n    }\\n\\n    \/**\\n     * @deprecated This method will be removed in 5.0.0. There is no direct alternative, but the same information may be\\n     *     obtained by splitting in half the value returned by {@see UuidInterface::getHex()}.\\n     *\/\\n    public function getLeastSignificantBitsHex(): string\\n    {\\n        return substr($this->getHex()->toString(), 16);\\n    }\\n\\n    \/**\\n     * @deprecated This method will be removed in 5.0.0. There is no direct alternative, but the same information may be\\n     *     obtained by splitting in half the value returned by {@see UuidInterface::getHex()}.\\n     *\/\\n    public function getMostSignificantBits(): string\\n    {\\n        $mostSignificantHex = substr($this->getHex()->toString(), 0, 16);\\n\\n        return $this->numberConverter->fromHex($mostSignificantHex);\\n    }\\n\\n    \/**\\n     * @deprecated This method will be removed in 5.0.0. There is no direct alternative, but the same information may be\\n     *     obtained by splitting in half the value returned by {@see UuidInterface::getHex()}.\\n     *\/\\n    public function getMostSignificantBitsHex(): string\\n    {\\n        return substr($this->getHex()->toString(), 0, 16);\\n    }\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see \\\\Ramsey\\\\Uuid\\\\Fields\\\\FieldsInterface} instance.\\n     *     If it is a {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface} instance, you may call\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface::getNode()} and use the arbitrary-precision math library of your\\n     *     choice to convert it to a string integer.\\n     *\/\\n    public function getNode(): string\\n    {\\n        return $this->numberConverter->fromHex($this->fields->getNode()->toString());\\n    }\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see \\\\Ramsey\\\\Uuid\\\\Fields\\\\FieldsInterface} instance.\\n     *     If it is a {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface} instance, you may call\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface::getNode()}.\\n     *\/\\n    public function getNodeHex(): string\\n    {\\n        return $this->fields->getNode()->toString();\\n    }\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see \\\\Ramsey\\\\Uuid\\\\Fields\\\\FieldsInterface} instance.\\n     *     If it is a {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface} instance, you may call\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface::getTimeHiAndVersion()} and use the arbitrary-precision math\\n     *     library of your choice to convert it to a string integer.\\n     *\/\\n    public function getTimeHiAndVersion(): string\\n    {\\n        return $this->numberConverter->fromHex($this->fields->getTimeHiAndVersion()->toString());\\n    }\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see \\\\Ramsey\\\\Uuid\\\\Fields\\\\FieldsInterface} instance.\\n     *     If it is a {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface} instance, you may call\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface::getTimeHiAndVersion()}.\\n     *\/\\n    public function getTimeHiAndVersionHex(): string\\n    {\\n        return $this->fields->getTimeHiAndVersion()->toString();\\n    }\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see \\\\Ramsey\\\\Uuid\\\\Fields\\\\FieldsInterface} instance.\\n     *     If it is a {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface} instance, you may call\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface::getTimeLow()} and use the arbitrary-precision math library of\\n     *     your choice to convert it to a string integer.\\n     *\/\\n    public function getTimeLow(): string\\n    {\\n        return $this->numberConverter->fromHex($this->fields->getTimeLow()->toString());\\n    }\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see \\\\Ramsey\\\\Uuid\\\\Fields\\\\FieldsInterface} instance.\\n     *     If it is a {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface} instance, you may call\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface::getTimeLow()}.\\n     *\/\\n    public function getTimeLowHex(): string\\n    {\\n        return $this->fields->getTimeLow()->toString();\\n    }\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see \\\\Ramsey\\\\Uuid\\\\Fields\\\\FieldsInterface} instance.\\n     *     If it is a {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface} instance, you may call\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface::getTimeMid()} and use the arbitrary-precision math library of\\n     *     your choice to convert it to a string integer.\\n     *\/\\n    public function getTimeMid(): string\\n    {\\n        return $this->numberConverter->fromHex($this->fields->getTimeMid()->toString());\\n    }\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see \\\\Ramsey\\\\Uuid\\\\Fields\\\\FieldsInterface} instance.\\n     *     If it is a {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface} instance, you may call\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface::getTimeMid()}.\\n     *\/\\n    public function getTimeMidHex(): string\\n    {\\n        return $this->fields->getTimeMid()->toString();\\n    }\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see \\\\Ramsey\\\\Uuid\\\\Fields\\\\FieldsInterface} instance.\\n     *     If it is a {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface} instance, you may call\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface::getTimestamp()} and use the arbitrary-precision math library of\\n     *     your choice to convert it to a string integer.\\n     *\/\\n    public function getTimestamp(): string\\n    {\\n        if ($this->fields->getVersion() !== 1) {\\n            throw new UnsupportedOperationException('Not a time-based UUID');\\n        }\\n\\n        return $this->numberConverter->fromHex($this->fields->getTimestamp()->toString());\\n    }\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see \\\\Ramsey\\\\Uuid\\\\Fields\\\\FieldsInterface} instance.\\n     *     If it is a {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface} instance, you may call\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface::getTimestamp()}.\\n     *\/\\n    public function getTimestampHex(): string\\n    {\\n        if ($this->fields->getVersion() !== 1) {\\n            throw new UnsupportedOperationException('Not a time-based UUID');\\n        }\\n\\n        return $this->fields->getTimestamp()->toString();\\n    }\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see \\\\Ramsey\\\\Uuid\\\\Fields\\\\FieldsInterface} instance.\\n     *     If it is a {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface} instance, you may call\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface::getVariant()}.\\n     *\/\\n    public function getVariant(): ?int\\n    {\\n        return $this->fields->getVariant();\\n    }\\n\\n    \/**\\n     * @deprecated Use {@see UuidInterface::getFields()} to get a {@see \\\\Ramsey\\\\Uuid\\\\Fields\\\\FieldsInterface} instance.\\n     *     If it is a {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface} instance, you may call\\n     *     {@see \\\\Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface::getVersion()}.\\n     *\/\\n    public function getVersion(): ?int\\n    {\\n        return $this->fields->getVersion();\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Type\/Decimal.php\",\"ext\":\"php\",\"size\":3057,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Type;\\n\\nuse Ramsey\\\\Uuid\\\\Exception\\\\InvalidArgumentException;\\nuse ValueError;\\n\\nuse function is_numeric;\\nuse function sprintf;\\nuse function str_starts_with;\\n\\n\/**\\n * A value object representing a decimal\\n *\\n * This class exists for type-safety purposes, to ensure that decimals returned from ramsey\/uuid methods as strings are\\n * truly decimals and not some other kind of string.\\n *\\n * To support values as true decimals and not as floats or doubles, we store the decimals as strings.\\n *\\n * @immutable\\n *\/\\nfinal class Decimal implements NumberInterface\\n{\\n    private string $value;\\n    private bool $isNegative;\\n\\n    public function __construct(float | int | string | self $value)\\n    {\\n        $value = (string) $value;\\n\\n        if (!is_numeric($value)) {\\n            throw new InvalidArgumentException(\\n                'Value must be a signed decimal or a string containing only '\\n                . 'digits 0-9 and, optionally, a decimal point or sign (+ or -)'\\n            );\\n        }\\n\\n        \/\/ Remove the leading +-symbol.\\n        if (str_starts_with($value, '+')) {\\n            $value = substr($value, 1);\\n        }\\n\\n        \/\/ For cases like `-0` or `-0.0000`, convert the value to `0`.\\n        if (abs((float) $value) === 0.0) {\\n            $value = '0';\\n        }\\n\\n        if (str_starts_with($value, '-')) {\\n            $this->isNegative = true;\\n        } else {\\n            $this->isNegative = false;\\n        }\\n\\n        $this->value = $value;\\n    }\\n\\n    public function isNegative(): bool\\n    {\\n        return $this->isNegative;\\n    }\\n\\n    public function toString(): string\\n    {\\n        return $this->value;\\n    }\\n\\n    public function __toString(): string\\n    {\\n        return $this->toString();\\n    }\\n\\n    public function jsonSerialize(): string\\n    {\\n        return $this->toString();\\n    }\\n\\n    public function serialize(): string\\n    {\\n        return $this->toString();\\n    }\\n\\n    \/**\\n     * @return array{string: string}\\n     *\/\\n    public function __serialize(): array\\n    {\\n        return ['string' => $this->toString()];\\n    }\\n\\n    \/**\\n     * Constructs the object from a serialized string representation\\n     *\\n     * @param string $data The serialized string representation of the object\\n     *\/\\n    public function unserialize(string $data): void\\n    {\\n        $this->__construct($data);\\n    }\\n\\n    \/**\\n     * @param array{string?: string} $data\\n     *\/\\n    public function __unserialize(array $data): void\\n    {\\n        \/\/ @codeCoverageIgnoreStart\\n        if (!isset($data['string'])) {\\n            throw new ValueError(sprintf('%s(): Argument #1 ($data) is invalid', __METHOD__));\\n        }\\n        \/\/ @codeCoverageIgnoreEnd\\n\\n        $this->unserialize($data['string']);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Type\/Time.php\",\"ext\":\"php\",\"size\":3428,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Type;\\n\\nuse Ramsey\\\\Uuid\\\\Exception\\\\UnsupportedOperationException;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Integer as IntegerObject;\\nuse ValueError;\\n\\nuse function json_decode;\\nuse function json_encode;\\nuse function sprintf;\\n\\n\/**\\n * A value object representing a timestamp\\n *\\n * This class exists for type-safety purposes, to ensure that timestamps used by ramsey\/uuid are truly timestamp\\n * integers and not some other kind of string or integer.\\n *\\n * @immutable\\n *\/\\nfinal class Time implements TypeInterface\\n{\\n    private IntegerObject $seconds;\\n    private IntegerObject $microseconds;\\n\\n    public function __construct(\\n        IntegerObject | float | int | string $seconds,\\n        IntegerObject | float | int | string $microseconds = 0,\\n    ) {\\n        $this->seconds = new IntegerObject($seconds);\\n        $this->microseconds = new IntegerObject($microseconds);\\n    }\\n\\n    \/**\\n     * @pure\\n     *\/\\n    public function getSeconds(): IntegerObject\\n    {\\n        return $this->seconds;\\n    }\\n\\n    \/**\\n     * @pure\\n     *\/\\n    public function getMicroseconds(): IntegerObject\\n    {\\n        return $this->microseconds;\\n    }\\n\\n    public function toString(): string\\n    {\\n        return $this->seconds->toString() . '.' . sprintf('%06s', $this->microseconds->toString());\\n    }\\n\\n    public function __toString(): string\\n    {\\n        return $this->toString();\\n    }\\n\\n    \/**\\n     * @return string[]\\n     *\/\\n    public function jsonSerialize(): array\\n    {\\n        return [\\n            'seconds' => $this->getSeconds()->toString(),\\n            'microseconds' => $this->getMicroseconds()->toString(),\\n        ];\\n    }\\n\\n    public function serialize(): string\\n    {\\n        return (string) json_encode($this);\\n    }\\n\\n    \/**\\n     * @return array{seconds: string, microseconds: string}\\n     *\/\\n    public function __serialize(): array\\n    {\\n        return [\\n            'seconds' => $this->getSeconds()->toString(),\\n            'microseconds' => $this->getMicroseconds()->toString(),\\n        ];\\n    }\\n\\n    \/**\\n     * Constructs the object from a serialized string representation\\n     *\\n     * @param string $data The serialized string representation of the object\\n     *\/\\n    public function unserialize(string $data): void\\n    {\\n        \/** @var array{seconds?: float | int | string, microseconds?: float | int | string} $time *\/\\n        $time = json_decode($data, true);\\n\\n        if (!isset($time['seconds']) || !isset($time['microseconds'])) {\\n            throw new UnsupportedOperationException('Attempted to unserialize an invalid value');\\n        }\\n\\n        $this->__construct($time['seconds'], $time['microseconds']);\\n    }\\n\\n    \/**\\n     * @param array{seconds?: string, microseconds?: string} $data\\n     *\/\\n    public function __unserialize(array $data): void\\n    {\\n        \/\/ @codeCoverageIgnoreStart\\n        if (!isset($data['seconds']) || !isset($data['microseconds'])) {\\n            throw new ValueError(sprintf('%s(): Argument #1 ($data) is invalid', __METHOD__));\\n        }\\n        \/\/ @codeCoverageIgnoreEnd\\n\\n        $this->__construct($data['seconds'], $data['microseconds']);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Type\/Hexadecimal.php\",\"ext\":\"php\",\"size\":2969,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Type;\\n\\nuse Ramsey\\\\Uuid\\\\Exception\\\\InvalidArgumentException;\\nuse ValueError;\\n\\nuse function preg_match;\\nuse function sprintf;\\nuse function substr;\\n\\n\/**\\n * A value object representing a hexadecimal number\\n *\\n * This class exists for type-safety purposes, to ensure that hexadecimal numbers returned from ramsey\/uuid methods as\\n * strings are truly hexadecimal and not some other kind of string.\\n *\\n * @immutable\\n *\/\\nfinal class Hexadecimal implements TypeInterface\\n{\\n    \/**\\n     * @var non-empty-string\\n     *\/\\n    private string $value;\\n\\n    \/**\\n     * @param self | string $value The hexadecimal value to store\\n     *\/\\n    public function __construct(self | string $value)\\n    {\\n        $this->value = $value instanceof self ? (string) $value : $this->prepareValue($value);\\n    }\\n\\n    \/**\\n     * @return non-empty-string\\n     *\\n     * @pure\\n     *\/\\n    public function toString(): string\\n    {\\n        return $this->value;\\n    }\\n\\n    \/**\\n     * @return non-empty-string\\n     *\/\\n    public function __toString(): string\\n    {\\n        return $this->toString();\\n    }\\n\\n    \/**\\n     * @return non-empty-string\\n     *\/\\n    public function jsonSerialize(): string\\n    {\\n        return $this->toString();\\n    }\\n\\n    \/**\\n     * @return non-empty-string\\n     *\/\\n    public function serialize(): string\\n    {\\n        return $this->toString();\\n    }\\n\\n    \/**\\n     * @return array{string: string}\\n     *\/\\n    public function __serialize(): array\\n    {\\n        return ['string' => $this->toString()];\\n    }\\n\\n    \/**\\n     * Constructs the object from a serialized string representation\\n     *\\n     * @param string $data The serialized string representation of the object\\n     *\/\\n    public function unserialize(string $data): void\\n    {\\n        $this->__construct($data);\\n    }\\n\\n    \/**\\n     * @param array{string?: string} $data\\n     *\/\\n    public function __unserialize(array $data): void\\n    {\\n        \/\/ @codeCoverageIgnoreStart\\n        if (!isset($data['string'])) {\\n            throw new ValueError(sprintf('%s(): Argument #1 ($data) is invalid', __METHOD__));\\n        }\\n        \/\/ @codeCoverageIgnoreEnd\\n\\n        $this->unserialize($data['string']);\\n    }\\n\\n    \/**\\n     * @return non-empty-string\\n     *\/\\n    private function prepareValue(string $value): string\\n    {\\n        $value = strtolower($value);\\n\\n        if (str_starts_with($value, '0x')) {\\n            $value = substr($value, 2);\\n        }\\n\\n        if (!preg_match('\/^[A-Fa-f0-9]+$\/', $value)) {\\n            throw new InvalidArgumentException('Value must be a hexadecimal number');\\n        }\\n\\n        \/** @var non-empty-string *\/\\n        return $value;\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Type\/TypeInterface.php\",\"ext\":\"php\",\"size\":713,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Type;\\n\\nuse JsonSerializable;\\nuse Serializable;\\n\\n\/**\\n * TypeInterface ensures consistency in typed values returned by ramsey\/uuid\\n *\\n * @immutable\\n *\/\\ninterface TypeInterface extends JsonSerializable, Serializable\\n{\\n    \/**\\n     * @pure\\n     *\/\\n    public function toString(): string;\\n\\n    \/**\\n     * @pure\\n     *\/\\n    public function __toString(): string;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Type\/Integer.php\",\"ext\":\"php\",\"size\":3929,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Type;\\n\\nuse Ramsey\\\\Uuid\\\\Exception\\\\InvalidArgumentException;\\nuse ValueError;\\n\\nuse function assert;\\nuse function is_numeric;\\nuse function preg_match;\\nuse function sprintf;\\nuse function substr;\\n\\n\/**\\n * A value object representing an integer\\n *\\n * This class exists for type-safety purposes, to ensure that integers returned from ramsey\/uuid methods as strings are\\n * truly integers and not some other kind of string.\\n *\\n * To support large integers beyond PHP_INT_MAX and PHP_INT_MIN on both 64-bit and 32-bit systems, we store the integers\\n * as strings.\\n *\\n * @immutable\\n *\/\\nfinal class Integer implements NumberInterface\\n{\\n    \/**\\n     * @var numeric-string\\n     *\/\\n    private string $value;\\n\\n    \/**\\n     * @phpstan-ignore property.readOnlyByPhpDocDefaultValue\\n     *\/\\n    private bool $isNegative = false;\\n\\n    public function __construct(self | float | int | string $value)\\n    {\\n        $this->value = $value instanceof self ? (string) $value : $this->prepareValue($value);\\n    }\\n\\n    public function isNegative(): bool\\n    {\\n        return $this->isNegative;\\n    }\\n\\n    \/**\\n     * @return numeric-string\\n     *\\n     * @pure\\n     *\/\\n    public function toString(): string\\n    {\\n        return $this->value;\\n    }\\n\\n    \/**\\n     * @return numeric-string\\n     *\/\\n    public function __toString(): string\\n    {\\n        return $this->toString();\\n    }\\n\\n    public function jsonSerialize(): string\\n    {\\n        return $this->toString();\\n    }\\n\\n    public function serialize(): string\\n    {\\n        return $this->toString();\\n    }\\n\\n    \/**\\n     * @return array{string: string}\\n     *\/\\n    public function __serialize(): array\\n    {\\n        return ['string' => $this->toString()];\\n    }\\n\\n    \/**\\n     * Constructs the object from a serialized string representation\\n     *\\n     * @param string $data The serialized string representation of the object\\n     *\/\\n    public function unserialize(string $data): void\\n    {\\n        $this->__construct($data);\\n    }\\n\\n    \/**\\n     * @param array{string?: string} $data\\n     *\/\\n    public function __unserialize(array $data): void\\n    {\\n        \/\/ @codeCoverageIgnoreStart\\n        if (!isset($data['string'])) {\\n            throw new ValueError(sprintf('%s(): Argument #1 ($data) is invalid', __METHOD__));\\n        }\\n        \/\/ @codeCoverageIgnoreEnd\\n\\n        $this->unserialize($data['string']);\\n    }\\n\\n    \/**\\n     * @return numeric-string\\n     *\/\\n    private function prepareValue(float | int | string $value): string\\n    {\\n        $value = (string) $value;\\n        $sign = '+';\\n\\n        \/\/ If the value contains a sign, remove it for the digit pattern check.\\n        if (str_starts_with($value, '-') || str_starts_with($value, '+')) {\\n            $sign = substr($value, 0, 1);\\n            $value = substr($value, 1);\\n        }\\n\\n        if (!preg_match('\/^\\\\d+$\/', $value)) {\\n            throw new InvalidArgumentException(\\n                'Value must be a signed integer or a string containing only '\\n                . 'digits 0-9 and, optionally, a sign (+ or -)'\\n            );\\n        }\\n\\n        \/\/ Trim any leading zeros.\\n        $value = ltrim($value, '0');\\n\\n        \/\/ Set to zero if the string is empty after trimming zeros.\\n        if ($value === '') {\\n            $value = '0';\\n        }\\n\\n        \/\/ Add the negative sign back to the value.\\n        if ($sign === '-' && $value !== '0') {\\n            $value = $sign . $value;\\n\\n            \/** @phpstan-ignore property.readOnlyByPhpDocAssignNotInConstructor *\/\\n            $this->isNegative = true;\\n        }\\n\\n        assert(is_numeric($value));\\n\\n        return $value;\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Type\/NumberInterface.php\",\"ext\":\"php\",\"size\":629,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Type;\\n\\n\/**\\n * NumberInterface ensures consistency in numeric values returned by ramsey\/uuid\\n *\\n * @immutable\\n *\/\\ninterface NumberInterface extends TypeInterface\\n{\\n    \/**\\n     * Returns true if this number is less than zero\\n     *\/\\n    public function isNegative(): bool;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/UuidFactory.php\",\"ext\":\"php\",\"size\":15334,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid;\\n\\nuse DateTimeInterface;\\nuse Ramsey\\\\Uuid\\\\Builder\\\\UuidBuilderInterface;\\nuse Ramsey\\\\Uuid\\\\Codec\\\\CodecInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\NumberConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\TimeConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Generator\\\\DceSecurityGeneratorInterface;\\nuse Ramsey\\\\Uuid\\\\Generator\\\\DefaultTimeGenerator;\\nuse Ramsey\\\\Uuid\\\\Generator\\\\NameGeneratorInterface;\\nuse Ramsey\\\\Uuid\\\\Generator\\\\RandomGeneratorInterface;\\nuse Ramsey\\\\Uuid\\\\Generator\\\\TimeGeneratorInterface;\\nuse Ramsey\\\\Uuid\\\\Generator\\\\UnixTimeGenerator;\\nuse Ramsey\\\\Uuid\\\\Lazy\\\\LazyUuidFromString;\\nuse Ramsey\\\\Uuid\\\\Provider\\\\NodeProviderInterface;\\nuse Ramsey\\\\Uuid\\\\Provider\\\\Time\\\\FixedTimeProvider;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Hexadecimal;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Integer as IntegerObject;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Time;\\nuse Ramsey\\\\Uuid\\\\Validator\\\\ValidatorInterface;\\n\\nuse function bin2hex;\\nuse function hex2bin;\\nuse function pack;\\nuse function str_pad;\\nuse function strtolower;\\nuse function substr;\\nuse function substr_replace;\\nuse function unpack;\\n\\nuse const STR_PAD_LEFT;\\n\\nclass UuidFactory implements UuidFactoryInterface\\n{\\n    private CodecInterface $codec;\\n    private DceSecurityGeneratorInterface $dceSecurityGenerator;\\n    private NameGeneratorInterface $nameGenerator;\\n    private NodeProviderInterface $nodeProvider;\\n    private NumberConverterInterface $numberConverter;\\n    private RandomGeneratorInterface $randomGenerator;\\n    private TimeConverterInterface $timeConverter;\\n    private TimeGeneratorInterface $timeGenerator;\\n    private TimeGeneratorInterface $unixTimeGenerator;\\n    private UuidBuilderInterface $uuidBuilder;\\n    private ValidatorInterface $validator;\\n\\n    \/**\\n     * @var bool whether the feature set was provided from outside, or we can operate under \\\"default\\\" assumptions\\n     *\/\\n    private bool $isDefaultFeatureSet;\\n\\n    \/**\\n     * @param FeatureSet | null $features A set of available features in the current environment\\n     *\/\\n    public function __construct(?FeatureSet $features = null)\\n    {\\n        $this->isDefaultFeatureSet = $features === null;\\n\\n        $features = $features ?: new FeatureSet();\\n\\n        $this->codec = $features->getCodec();\\n        $this->dceSecurityGenerator = $features->getDceSecurityGenerator();\\n        $this->nameGenerator = $features->getNameGenerator();\\n        $this->nodeProvider = $features->getNodeProvider();\\n        $this->numberConverter = $features->getNumberConverter();\\n        $this->randomGenerator = $features->getRandomGenerator();\\n        $this->timeConverter = $features->getTimeConverter();\\n        $this->timeGenerator = $features->getTimeGenerator();\\n        $this->uuidBuilder = $features->getBuilder();\\n        $this->validator = $features->getValidator();\\n        $this->unixTimeGenerator = $features->getUnixTimeGenerator();\\n    }\\n\\n    \/**\\n     * Returns the codec used by this factory\\n     *\/\\n    public function getCodec(): CodecInterface\\n    {\\n        return $this->codec;\\n    }\\n\\n    \/**\\n     * Sets the codec to use for this factory\\n     *\\n     * @param CodecInterface $codec A UUID encoder-decoder\\n     *\/\\n    public function setCodec(CodecInterface $codec): void\\n    {\\n        $this->isDefaultFeatureSet = false;\\n\\n        $this->codec = $codec;\\n    }\\n\\n    \/**\\n     * Returns the name generator used by this factory\\n     *\/\\n    public function getNameGenerator(): NameGeneratorInterface\\n    {\\n        return $this->nameGenerator;\\n    }\\n\\n    \/**\\n     * Sets the name generator to use for this factory\\n     *\\n     * @param NameGeneratorInterface $nameGenerator A generator to generate binary data, based on a namespace and name\\n     *\/\\n    public function setNameGenerator(NameGeneratorInterface $nameGenerator): void\\n    {\\n        $this->isDefaultFeatureSet = false;\\n\\n        $this->nameGenerator = $nameGenerator;\\n    }\\n\\n    \/**\\n     * Returns the node provider used by this factory\\n     *\/\\n    public function getNodeProvider(): NodeProviderInterface\\n    {\\n        return $this->nodeProvider;\\n    }\\n\\n    \/**\\n     * Returns the random generator used by this factory\\n     *\/\\n    public function getRandomGenerator(): RandomGeneratorInterface\\n    {\\n        return $this->randomGenerator;\\n    }\\n\\n    \/**\\n     * Returns the time generator used by this factory\\n     *\/\\n    public function getTimeGenerator(): TimeGeneratorInterface\\n    {\\n        return $this->timeGenerator;\\n    }\\n\\n    \/**\\n     * Sets the time generator to use for this factory\\n     *\\n     * @param TimeGeneratorInterface $generator A generator to generate binary data, based on the time\\n     *\/\\n    public function setTimeGenerator(TimeGeneratorInterface $generator): void\\n    {\\n        $this->isDefaultFeatureSet = false;\\n\\n        $this->timeGenerator = $generator;\\n    }\\n\\n    \/**\\n     * Returns the DCE Security generator used by this factory\\n     *\/\\n    public function getDceSecurityGenerator(): DceSecurityGeneratorInterface\\n    {\\n        return $this->dceSecurityGenerator;\\n    }\\n\\n    \/**\\n     * Sets the DCE Security generator to use for this factory\\n     *\\n     * @param DceSecurityGeneratorInterface $generator A generator to generate binary data, based on a local domain and\\n     *     local identifier\\n     *\/\\n    public function setDceSecurityGenerator(DceSecurityGeneratorInterface $generator): void\\n    {\\n        $this->isDefaultFeatureSet = false;\\n\\n        $this->dceSecurityGenerator = $generator;\\n    }\\n\\n    \/**\\n     * Returns the number converter used by this factory\\n     *\/\\n    public function getNumberConverter(): NumberConverterInterface\\n    {\\n        return $this->numberConverter;\\n    }\\n\\n    \/**\\n     * Sets the random generator to use for this factory\\n     *\\n     * @param RandomGeneratorInterface $generator A generator to generate binary data, based on some random input\\n     *\/\\n    public function setRandomGenerator(RandomGeneratorInterface $generator): void\\n    {\\n        $this->isDefaultFeatureSet = false;\\n\\n        $this->randomGenerator = $generator;\\n    }\\n\\n    \/**\\n     * Sets the number converter to use for this factory\\n     *\\n     * @param NumberConverterInterface $converter A converter to use for working with large integers (i.e., integers\\n     *     greater than PHP_INT_MAX)\\n     *\/\\n    public function setNumberConverter(NumberConverterInterface $converter): void\\n    {\\n        $this->isDefaultFeatureSet = false;\\n\\n        $this->numberConverter = $converter;\\n    }\\n\\n    \/**\\n     * Returns the UUID builder used by this factory\\n     *\/\\n    public function getUuidBuilder(): UuidBuilderInterface\\n    {\\n        return $this->uuidBuilder;\\n    }\\n\\n    \/**\\n     * Sets the UUID builder to use for this factory\\n     *\\n     * @param UuidBuilderInterface $builder A builder for constructing instances of UuidInterface\\n     *\/\\n    public function setUuidBuilder(UuidBuilderInterface $builder): void\\n    {\\n        $this->isDefaultFeatureSet = false;\\n\\n        $this->uuidBuilder = $builder;\\n    }\\n\\n    public function getValidator(): ValidatorInterface\\n    {\\n        return $this->validator;\\n    }\\n\\n    \/**\\n     * Sets the validator to use for this factory\\n     *\\n     * @param ValidatorInterface $validator A validator to use for validating whether a string is a valid UUID\\n     *\/\\n    public function setValidator(ValidatorInterface $validator): void\\n    {\\n        $this->isDefaultFeatureSet = false;\\n\\n        $this->validator = $validator;\\n    }\\n\\n    \/**\\n     * @pure\\n     *\/\\n    public function fromBytes(string $bytes): UuidInterface\\n    {\\n        return $this->codec->decodeBytes($bytes);\\n    }\\n\\n    \/**\\n     * @pure\\n     *\/\\n    public function fromString(string $uuid): UuidInterface\\n    {\\n        $uuid = strtolower($uuid);\\n\\n        return $this->codec->decode($uuid);\\n    }\\n\\n    \/**\\n     * @pure\\n     *\/\\n    public function fromInteger(string $integer): UuidInterface\\n    {\\n        $hex = $this->numberConverter->toHex($integer);\\n        $hex = str_pad($hex, 32, '0', STR_PAD_LEFT);\\n\\n        return $this->fromString($hex);\\n    }\\n\\n    public function fromDateTime(\\n        DateTimeInterface $dateTime,\\n        ?Hexadecimal $node = null,\\n        ?int $clockSeq = null,\\n    ): UuidInterface {\\n        $timeProvider = new FixedTimeProvider(new Time($dateTime->format('U'), $dateTime->format('u')));\\n        $timeGenerator = new DefaultTimeGenerator($this->nodeProvider, $this->timeConverter, $timeProvider);\\n        $bytes = $timeGenerator->generate($node?->toString(), $clockSeq);\\n\\n        return $this->uuidFromBytesAndVersion($bytes, Uuid::UUID_TYPE_TIME);\\n    }\\n\\n    \/**\\n     * @pure\\n     *\/\\n    public function fromHexadecimal(Hexadecimal $hex): UuidInterface\\n    {\\n        return $this->codec->decode($hex->__toString());\\n    }\\n\\n    \/**\\n     * @inheritDoc\\n     *\/\\n    public function uuid1($node = null, ?int $clockSeq = null): UuidInterface\\n    {\\n        $bytes = $this->timeGenerator->generate($node, $clockSeq);\\n\\n        return $this->uuidFromBytesAndVersion($bytes, Uuid::UUID_TYPE_TIME);\\n    }\\n\\n    public function uuid2(\\n        int $localDomain,\\n        ?IntegerObject $localIdentifier = null,\\n        ?Hexadecimal $node = null,\\n        ?int $clockSeq = null,\\n    ): UuidInterface {\\n        $bytes = $this->dceSecurityGenerator->generate($localDomain, $localIdentifier, $node, $clockSeq);\\n\\n        return $this->uuidFromBytesAndVersion($bytes, Uuid::UUID_TYPE_DCE_SECURITY);\\n    }\\n\\n    \/**\\n     * @inheritDoc\\n     * @pure\\n     *\/\\n    public function uuid3($ns, string $name): UuidInterface\\n    {\\n        return $this->uuidFromNsAndName($ns, $name, Uuid::UUID_TYPE_HASH_MD5, 'md5');\\n    }\\n\\n    public function uuid4(): UuidInterface\\n    {\\n        $bytes = $this->randomGenerator->generate(16);\\n\\n        return $this->uuidFromBytesAndVersion($bytes, Uuid::UUID_TYPE_RANDOM);\\n    }\\n\\n    \/**\\n     * @inheritDoc\\n     * @pure\\n     *\/\\n    public function uuid5($ns, string $name): UuidInterface\\n    {\\n        return $this->uuidFromNsAndName($ns, $name, Uuid::UUID_TYPE_HASH_SHA1, 'sha1');\\n    }\\n\\n    public function uuid6(?Hexadecimal $node = null, ?int $clockSeq = null): UuidInterface\\n    {\\n        $bytes = $this->timeGenerator->generate($node?->toString(), $clockSeq);\\n\\n        \/\/ Rearrange the bytes, according to the UUID version 6 specification.\\n        $v6 = $bytes[6] . $bytes[7] . $bytes[4] . $bytes[5]\\n            . $bytes[0] . $bytes[1] . $bytes[2] . $bytes[3];\\n        $v6 = bin2hex($v6);\\n\\n        \/\/ Drop the first four bits, while adding an empty four bits for the version field. This allows us to\\n        \/\/ reconstruct the correct time from the bytes of this UUID.\\n        $v6Bytes = hex2bin(substr($v6, 1, 12) . '0' . substr($v6, -3));\\n        $v6Bytes .= substr($bytes, 8);\\n\\n        return $this->uuidFromBytesAndVersion($v6Bytes, Uuid::UUID_TYPE_REORDERED_TIME);\\n    }\\n\\n    \/**\\n     * Returns a version 7 (Unix Epoch time) UUID\\n     *\\n     * @param DateTimeInterface | null $dateTime An optional date\/time from which to create the version 7 UUID. If not\\n     *     provided, the UUID is generated using the current date\/time.\\n     *\\n     * @return UuidInterface A UuidInterface instance that represents a version 7 UUID\\n     *\/\\n    public function uuid7(?DateTimeInterface $dateTime = null): UuidInterface\\n    {\\n        assert($this->unixTimeGenerator instanceof UnixTimeGenerator);\\n        $bytes = $this->unixTimeGenerator->generate(null, null, $dateTime);\\n\\n        return $this->uuidFromBytesAndVersion($bytes, Uuid::UUID_TYPE_UNIX_TIME);\\n    }\\n\\n    \/**\\n     * Returns a version 8 (custom format) UUID\\n     *\\n     * The bytes provided may contain any value according to your application's needs. Be aware, however, that other\\n     * applications may not understand the semantics of the value.\\n     *\\n     * @param string $bytes A 16-byte octet string. This is an open blob of data that you may fill with 128 bits of\\n     *     information. Be aware, however, bits 48 through 51 will be replaced with the UUID version field, and bits 64\\n     *     and 65 will be replaced with the UUID variant. You MUST NOT rely on these bits for your application needs.\\n     *\\n     * @return UuidInterface A UuidInterface instance that represents a version 8 UUID\\n     *\\n     * @pure\\n     *\/\\n    public function uuid8(string $bytes): UuidInterface\\n    {\\n        \/** @phpstan-ignore possiblyImpure.methodCall *\/\\n        return $this->uuidFromBytesAndVersion($bytes, Uuid::UUID_TYPE_CUSTOM);\\n    }\\n\\n    \/**\\n     * Returns a Uuid created from the provided byte string\\n     *\\n     * Uses the configured builder and codec and the provided byte string to construct a Uuid object.\\n     *\\n     * @param string $bytes The byte string from which to construct a UUID\\n     *\\n     * @return UuidInterface An instance of UuidInterface, created from the provided bytes\\n     *\\n     * @pure\\n     *\/\\n    public function uuid(string $bytes): UuidInterface\\n    {\\n        return $this->uuidBuilder->build($this->codec, $bytes);\\n    }\\n\\n    \/**\\n     * Returns a version 3 or 5 namespaced Uuid\\n     *\\n     * @param UuidInterface | string $ns The namespace (must be a valid UUID)\\n     * @param string $name The name to hash together with the namespace\\n     * @param int $version The version of UUID to create (3 or 5)\\n     * @param string $hashAlgorithm The hashing algorithm to use when hashing together the namespace and name\\n     *\\n     * @return UuidInterface An instance of UuidInterface, created by hashing together the provided namespace and name\\n     *\\n     * @pure\\n     *\/\\n    private function uuidFromNsAndName(\\n        UuidInterface | string $ns,\\n        string $name,\\n        int $version,\\n        string $hashAlgorithm,\\n    ): UuidInterface {\\n        if (!($ns instanceof UuidInterface)) {\\n            $ns = $this->fromString($ns);\\n        }\\n\\n        $bytes = $this->nameGenerator->generate($ns, $name, $hashAlgorithm);\\n\\n        \/** @phpstan-ignore possiblyImpure.methodCall *\/\\n        return $this->uuidFromBytesAndVersion(substr($bytes, 0, 16), $version);\\n    }\\n\\n    \/**\\n     * Returns a Uuid created from the provided bytes and version\\n     *\\n     * @param string $bytes The byte string to convert to a UUID\\n     * @param int $version The version to apply to the UUID\\n     *\\n     * @return UuidInterface An instance of UuidInterface, created from the byte string and version\\n     *\/\\n    private function uuidFromBytesAndVersion(string $bytes, int $version): UuidInterface\\n    {\\n        \/** @var int[] $unpackedTime *\/\\n        $unpackedTime = unpack('n*', substr($bytes, 6, 2));\\n        $timeHi = $unpackedTime[1];\\n        $timeHiAndVersion = pack('n*', BinaryUtils::applyVersion($timeHi, $version));\\n\\n        \/** @var int[] $unpackedClockSeq *\/\\n        $unpackedClockSeq = unpack('n*', substr($bytes, 8, 2));\\n        $clockSeqHi = $unpackedClockSeq[1];\\n        $clockSeqHiAndReserved = pack('n*', BinaryUtils::applyVariant($clockSeqHi));\\n\\n        $bytes = substr_replace($bytes, $timeHiAndVersion, 6, 2);\\n        $bytes = substr_replace($bytes, $clockSeqHiAndReserved, 8, 2);\\n\\n        if ($this->isDefaultFeatureSet) {\\n            return LazyUuidFromString::fromBytes($bytes);\\n        }\\n\\n        return $this->uuid($bytes);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Codec\/CodecInterface.php\",\"ext\":\"php\",\"size\":2004,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Codec;\\n\\nuse Ramsey\\\\Uuid\\\\UuidInterface;\\n\\n\/**\\n * A codec encodes and decodes a UUID according to defined rules\\n *\\n * @immutable\\n *\/\\ninterface CodecInterface\\n{\\n    \/**\\n     * Returns a hexadecimal string representation of a UuidInterface\\n     *\\n     * @param UuidInterface $uuid The UUID for which to create a hexadecimal string representation\\n     *\\n     * @return non-empty-string Hexadecimal string representation of a UUID\\n     *\\n     * @pure\\n     *\/\\n    public function encode(UuidInterface $uuid): string;\\n\\n    \/**\\n     * Returns a binary string representation of a UuidInterface\\n     *\\n     * @param UuidInterface $uuid The UUID for which to create a binary string representation\\n     *\\n     * @return non-empty-string Binary string representation of a UUID\\n     *\\n     * @pure\\n     *\/\\n    public function encodeBinary(UuidInterface $uuid): string;\\n\\n    \/**\\n     * Returns a UuidInterface derived from a hexadecimal string representation\\n     *\\n     * @param string $encodedUuid The hexadecimal string representation to convert into a UuidInterface instance\\n     *\\n     * @return UuidInterface An instance of a UUID decoded from a hexadecimal string representation\\n     *\\n     * @pure\\n     *\/\\n    public function decode(string $encodedUuid): UuidInterface;\\n\\n    \/**\\n     * Returns a UuidInterface derived from a binary string representation\\n     *\\n     * @param string $bytes The binary string representation to convert into a UuidInterface instance\\n     *\\n     * @return UuidInterface An instance of a UUID decoded from a binary string representation\\n     *\\n     * @pure\\n     *\/\\n    public function decodeBytes(string $bytes): UuidInterface;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Codec\/TimestampLastCombCodec.php\",\"ext\":\"php\",\"size\":1551,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Codec;\\n\\n\/**\\n * TimestampLastCombCodec encodes and decodes COMBs, with the timestamp as the last 48 bits\\n *\\n * The CombGenerator when used with the StringCodec (and, by proxy, the TimestampLastCombCodec) adds the timestamp to\\n * the last 48 bits of the COMB. The TimestampLastCombCodec is provided for the sake of consistency. In practice, it is\\n * identical to the standard StringCodec, but it may be used with the CombGenerator for additional context when reading\\n * code.\\n *\\n * Consider the following code. By default, the codec used by UuidFactory is the StringCodec, but here, we explicitly\\n * set the TimestampLastCombCodec. It is redundant, but it is clear that we intend this COMB to be generated with the\\n * timestamp appearing at the end.\\n *\\n * ```\\n * $factory = new UuidFactory();\\n *\\n * $factory->setCodec(new TimestampLastCombCodec($factory->getUuidBuilder()));\\n *\\n * $factory->setRandomGenerator(new CombGenerator(\\n *     $factory->getRandomGenerator(),\\n *     $factory->getNumberConverter(),\\n * ));\\n *\\n * $timestampLastComb = $factory->uuid4();\\n * ```\\n *\\n * @deprecated Please use {@see StringCodec} instead.\\n *\\n * @immutable\\n *\/\\nclass TimestampLastCombCodec extends StringCodec\\n{\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Codec\/OrderedTimeCodec.php\",\"ext\":\"php\",\"size\":3622,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Codec;\\n\\nuse Ramsey\\\\Uuid\\\\Exception\\\\InvalidArgumentException;\\nuse Ramsey\\\\Uuid\\\\Exception\\\\UnsupportedOperationException;\\nuse Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface as Rfc4122FieldsInterface;\\nuse Ramsey\\\\Uuid\\\\Uuid;\\nuse Ramsey\\\\Uuid\\\\UuidInterface;\\n\\nuse function strlen;\\nuse function substr;\\n\\n\/**\\n * OrderedTimeCodec encodes and decodes a UUID, optimizing the byte order for more efficient storage\\n *\\n * For binary representations of version 1 UUID, this codec may be used to reorganize the time fields, making the UUID\\n * closer to sequential when storing the bytes. According to Percona, this optimization can improve database INSERT and\\n * SELECT statements using the UUID column as a key.\\n *\\n * The string representation of the UUID will remain unchanged. Only the binary representation is reordered.\\n *\\n * PLEASE NOTE: Binary representations of UUIDs encoded with this codec must be decoded with this codec. Decoding using\\n * another codec can result in malformed UUIDs.\\n *\\n * @deprecated Please migrate to {@link https:\/\/uuid.ramsey.dev\/en\/stable\/rfc4122\/version6.html Version 6, reordered time-based UUIDs}.\\n *\\n * @link https:\/\/www.percona.com\/blog\/2014\/12\/19\/store-uuid-optimized-way\/ Storing UUID Values in MySQL\\n *\\n * @immutable\\n *\/\\nclass OrderedTimeCodec extends StringCodec\\n{\\n    \/**\\n     * Returns a binary string representation of a UUID, with the timestamp fields rearranged for optimized storage\\n     *\\n     * @return non-empty-string\\n     *\/\\n    public function encodeBinary(UuidInterface $uuid): string\\n    {\\n        if (\\n            \/** @phpstan-ignore possiblyImpure.methodCall *\/\\n            !($uuid->getFields() instanceof Rfc4122FieldsInterface)\\n            \/** @phpstan-ignore possiblyImpure.methodCall *\/\\n            || $uuid->getFields()->getVersion() !== Uuid::UUID_TYPE_TIME\\n        ) {\\n            throw new InvalidArgumentException('Expected version 1 (time-based) UUID');\\n        }\\n\\n        \/** @phpstan-ignore possiblyImpure.methodCall *\/\\n        $bytes = $uuid->getFields()->getBytes();\\n\\n        return $bytes[6] . $bytes[7] . $bytes[4] . $bytes[5]\\n            . $bytes[0] . $bytes[1] . $bytes[2] . $bytes[3]\\n            . substr($bytes, 8);\\n    }\\n\\n    \/**\\n     * Returns a UuidInterface derived from an ordered-time binary string representation\\n     *\\n     * @throws InvalidArgumentException if $bytes is an invalid length\\n     *\\n     * @inheritDoc\\n     *\/\\n    public function decodeBytes(string $bytes): UuidInterface\\n    {\\n        if (strlen($bytes) !== 16) {\\n            throw new InvalidArgumentException('$bytes string should contain 16 characters.');\\n        }\\n\\n        \/\/ Rearrange the bytes to their original order.\\n        $rearrangedBytes = $bytes[4] . $bytes[5] . $bytes[6] . $bytes[7]\\n            . $bytes[2] . $bytes[3] . $bytes[0] . $bytes[1]\\n            . substr($bytes, 8);\\n\\n        $uuid = parent::decodeBytes($rearrangedBytes);\\n\\n        \/** @phpstan-ignore possiblyImpure.methodCall *\/\\n        $fields = $uuid->getFields();\\n\\n        if (!$fields instanceof Rfc4122FieldsInterface || $fields->getVersion() !== Uuid::UUID_TYPE_TIME) {\\n            throw new UnsupportedOperationException(\\n                'Attempting to decode a non-time-based UUID using OrderedTimeCodec',\\n            );\\n        }\\n\\n        return $uuid;\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Codec\/TimestampFirstCombCodec.php\",\"ext\":\"php\",\"size\":3355,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Codec;\\n\\nuse Ramsey\\\\Uuid\\\\Exception\\\\InvalidUuidStringException;\\nuse Ramsey\\\\Uuid\\\\UuidInterface;\\n\\nuse function bin2hex;\\nuse function sprintf;\\nuse function substr;\\nuse function substr_replace;\\n\\n\/**\\n * TimestampFirstCombCodec encodes and decodes COMBs, with the timestamp as the first 48 bits\\n *\\n * In contrast with the TimestampLastCombCodec, the TimestampFirstCombCodec adds the timestamp to the first 48 bits of\\n * the COMB. To generate a timestamp-first COMB, set the TimestampFirstCombCodec as the codec, along with the\\n * CombGenerator as the random generator.\\n *\\n * ```\\n * $factory = new UuidFactory();\\n *\\n * $factory->setCodec(new TimestampFirstCombCodec($factory->getUuidBuilder()));\\n *\\n * $factory->setRandomGenerator(new CombGenerator(\\n *     $factory->getRandomGenerator(),\\n *     $factory->getNumberConverter(),\\n * ));\\n *\\n * $timestampFirstComb = $factory->uuid4();\\n * ```\\n *\\n * @deprecated Please migrate to {@link https:\/\/uuid.ramsey.dev\/en\/stable\/rfc4122\/version7.html Version 7, Unix Epoch Time UUIDs}.\\n *\\n * @link https:\/\/web.archive.org\/web\/20240118030355\/https:\/\/www.informit.com\/articles\/printerfriendly\/25862 The Cost of GUIDs as Primary Keys\\n *\\n * @immutable\\n *\/\\nclass TimestampFirstCombCodec extends StringCodec\\n{\\n    \/**\\n     * @return non-empty-string\\n     *\/\\n    public function encode(UuidInterface $uuid): string\\n    {\\n        \/** @phpstan-ignore possiblyImpure.methodCall *\/\\n        $bytes = $this->swapBytes($uuid->getFields()->getBytes());\\n\\n        return sprintf(\\n            '%08s-%04s-%04s-%04s-%012s',\\n            bin2hex(substr($bytes, 0, 4)),\\n            bin2hex(substr($bytes, 4, 2)),\\n            bin2hex(substr($bytes, 6, 2)),\\n            bin2hex(substr($bytes, 8, 2)),\\n            bin2hex(substr($bytes, 10))\\n        );\\n    }\\n\\n    \/**\\n     * @return non-empty-string\\n     *\/\\n    public function encodeBinary(UuidInterface $uuid): string\\n    {\\n        \/** @phpstan-ignore-next-line PHPStan complains that this is not a non-empty-string. *\/\\n        return $this->swapBytes($uuid->getFields()->getBytes());\\n    }\\n\\n    \/**\\n     * @throws InvalidUuidStringException\\n     *\\n     * @inheritDoc\\n     *\/\\n    public function decode(string $encodedUuid): UuidInterface\\n    {\\n        \/** @phpstan-ignore possiblyImpure.methodCall *\/\\n        $bytes = $this->getBytes($encodedUuid);\\n\\n        \/** @phpstan-ignore possiblyImpure.methodCall *\/\\n        return $this->getBuilder()->build($this, $this->swapBytes($bytes));\\n    }\\n\\n    public function decodeBytes(string $bytes): UuidInterface\\n    {\\n        \/** @phpstan-ignore possiblyImpure.methodCall *\/\\n        return $this->getBuilder()->build($this, $this->swapBytes($bytes));\\n    }\\n\\n    \/**\\n     * Swaps bytes according to the timestamp-first COMB rules\\n     *\\n     * @pure\\n     *\/\\n    private function swapBytes(string $bytes): string\\n    {\\n        $first48Bits = substr($bytes, 0, 6);\\n        $last48Bits = substr($bytes, -6);\\n\\n        return substr_replace(substr_replace($bytes, $last48Bits, 0, 6), $first48Bits, -6);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Codec\/GuidStringCodec.php\",\"ext\":\"php\",\"size\":2104,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Codec;\\n\\nuse Ramsey\\\\Uuid\\\\Guid\\\\Guid;\\nuse Ramsey\\\\Uuid\\\\UuidInterface;\\n\\nuse function bin2hex;\\nuse function sprintf;\\nuse function substr;\\n\\n\/**\\n * GuidStringCodec encodes and decodes globally unique identifiers (GUID)\\n *\\n * @see Guid\\n *\\n * @immutable\\n *\/\\nclass GuidStringCodec extends StringCodec\\n{\\n    public function encode(UuidInterface $uuid): string\\n    {\\n        \/** @phpstan-ignore possiblyImpure.methodCall *\/\\n        $hex = bin2hex($uuid->getFields()->getBytes());\\n\\n        \/** @var non-empty-string *\/\\n        return sprintf(\\n            '%02s%02s%02s%02s-%02s%02s-%02s%02s-%04s-%012s',\\n            substr($hex, 6, 2),\\n            substr($hex, 4, 2),\\n            substr($hex, 2, 2),\\n            substr($hex, 0, 2),\\n            substr($hex, 10, 2),\\n            substr($hex, 8, 2),\\n            substr($hex, 14, 2),\\n            substr($hex, 12, 2),\\n            substr($hex, 16, 4),\\n            substr($hex, 20),\\n        );\\n    }\\n\\n    public function decode(string $encodedUuid): UuidInterface\\n    {\\n        \/** @phpstan-ignore possiblyImpure.methodCall *\/\\n        $bytes = $this->getBytes($encodedUuid);\\n\\n        \/** @phpstan-ignore possiblyImpure.methodCall, possiblyImpure.methodCall *\/\\n        return $this->getBuilder()->build($this, $this->swapBytes($bytes));\\n    }\\n\\n    public function decodeBytes(string $bytes): UuidInterface\\n    {\\n        \/\/ Call parent::decode() to preserve the correct byte order.\\n        return parent::decode(bin2hex($bytes));\\n    }\\n\\n    \/**\\n     * Swaps bytes according to the GUID rules\\n     *\/\\n    private function swapBytes(string $bytes): string\\n    {\\n        return $bytes[3] . $bytes[2] . $bytes[1] . $bytes[0]\\n            . $bytes[5] . $bytes[4] . $bytes[7] . $bytes[6]\\n            . substr($bytes, 8);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Codec\/StringCodec.php\",\"ext\":\"php\",\"size\":3197,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Codec;\\n\\nuse Ramsey\\\\Uuid\\\\Builder\\\\UuidBuilderInterface;\\nuse Ramsey\\\\Uuid\\\\Exception\\\\InvalidArgumentException;\\nuse Ramsey\\\\Uuid\\\\Exception\\\\InvalidUuidStringException;\\nuse Ramsey\\\\Uuid\\\\Uuid;\\nuse Ramsey\\\\Uuid\\\\UuidInterface;\\n\\nuse function bin2hex;\\nuse function hex2bin;\\nuse function implode;\\nuse function sprintf;\\nuse function str_replace;\\nuse function strlen;\\nuse function substr;\\n\\n\/**\\n * StringCodec encodes and decodes RFC 9562 (formerly RFC 4122) UUIDs\\n *\\n * @immutable\\n *\/\\nclass StringCodec implements CodecInterface\\n{\\n    \/**\\n     * Constructs a StringCodec\\n     *\\n     * @param UuidBuilderInterface $builder The builder to use when encoding UUIDs\\n     *\/\\n    public function __construct(private UuidBuilderInterface $builder)\\n    {\\n    }\\n\\n    public function encode(UuidInterface $uuid): string\\n    {\\n        \/** @phpstan-ignore possiblyImpure.methodCall *\/\\n        $hex = bin2hex($uuid->getFields()->getBytes());\\n\\n        \/** @var non-empty-string *\/\\n        return sprintf(\\n            '%08s-%04s-%04s-%04s-%012s',\\n            substr($hex, 0, 8),\\n            substr($hex, 8, 4),\\n            substr($hex, 12, 4),\\n            substr($hex, 16, 4),\\n            substr($hex, 20),\\n        );\\n    }\\n\\n    \/**\\n     * @return non-empty-string\\n     *\/\\n    public function encodeBinary(UuidInterface $uuid): string\\n    {\\n        \/** @phpstan-ignore-next-line PHPStan complains that this is not a non-empty-string. *\/\\n        return $uuid->getFields()->getBytes();\\n    }\\n\\n    \/**\\n     * @throws InvalidUuidStringException\\n     *\\n     * @inheritDoc\\n     *\/\\n    public function decode(string $encodedUuid): UuidInterface\\n    {\\n        \/** @phpstan-ignore possiblyImpure.methodCall *\/\\n        return $this->builder->build($this, $this->getBytes($encodedUuid));\\n    }\\n\\n    public function decodeBytes(string $bytes): UuidInterface\\n    {\\n        if (strlen($bytes) !== 16) {\\n            throw new InvalidArgumentException('$bytes string should contain 16 characters.');\\n        }\\n\\n        return $this->builder->build($this, $bytes);\\n    }\\n\\n    \/**\\n     * Returns the UUID builder\\n     *\/\\n    protected function getBuilder(): UuidBuilderInterface\\n    {\\n        return $this->builder;\\n    }\\n\\n    \/**\\n     * Returns a byte string of the UUID\\n     *\/\\n    protected function getBytes(string $encodedUuid): string\\n    {\\n        $parsedUuid = str_replace(['urn:', 'uuid:', 'URN:', 'UUID:', '{', '}', '-'], '', $encodedUuid);\\n\\n        $components = [\\n            substr($parsedUuid, 0, 8),\\n            substr($parsedUuid, 8, 4),\\n            substr($parsedUuid, 12, 4),\\n            substr($parsedUuid, 16, 4),\\n            substr($parsedUuid, 20),\\n        ];\\n\\n        if (!Uuid::isValid(implode('-', $components))) {\\n            throw new InvalidUuidStringException('Invalid UUID string: ' . $encodedUuid);\\n        }\\n\\n        return (string) hex2bin($parsedUuid);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/UuidInterface.php\",\"ext\":\"php\",\"size\":3172,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid;\\n\\nuse JsonSerializable;\\nuse Ramsey\\\\Uuid\\\\Fields\\\\FieldsInterface;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Hexadecimal;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Integer as IntegerObject;\\nuse Serializable;\\nuse Stringable;\\n\\n\/**\\n * A UUID is a universally unique identifier adhering to an agreed-upon representation format and standard for generation\\n *\\n * @immutable\\n *\/\\ninterface UuidInterface extends\\n    DeprecatedUuidInterface,\\n    JsonSerializable,\\n    Serializable,\\n    Stringable\\n{\\n    \/**\\n     * Returns -1, 0, or 1 if the UUID is less than, equal to, or greater than the other UUID\\n     *\\n     * The first of two UUIDs is greater than the second if the most significant field in which the UUIDs differ is\\n     * greater for the first UUID.\\n     *\\n     * @param UuidInterface $other The UUID to compare\\n     *\\n     * @return int<-1,1> -1, 0, or 1 if the UUID is less than, equal to, or greater than $other\\n     *\/\\n    public function compareTo(UuidInterface $other): int;\\n\\n    \/**\\n     * Returns true if the UUID is equal to the provided object\\n     *\\n     * The result is true if and only if the argument is not null, is a UUID object, has the same variant, and contains\\n     * the same value, bit-for-bit, as the UUID.\\n     *\\n     * @param object | null $other An object to test for equality with this UUID\\n     *\\n     * @return bool True if the other object is equal to this UUID\\n     *\/\\n    public function equals(?object $other): bool;\\n\\n    \/**\\n     * Returns the binary string representation of the UUID\\n     *\\n     * @return non-empty-string\\n     *\\n     * @pure\\n     *\/\\n    public function getBytes(): string;\\n\\n    \/**\\n     * Returns the fields that comprise this UUID\\n     *\/\\n    public function getFields(): FieldsInterface;\\n\\n    \/**\\n     * Returns the hexadecimal representation of the UUID\\n     *\/\\n    public function getHex(): Hexadecimal;\\n\\n    \/**\\n     * Returns the integer representation of the UUID\\n     *\/\\n    public function getInteger(): IntegerObject;\\n\\n    \/**\\n     * Returns the string standard representation of the UUID as a URN\\n     *\\n     * @link http:\/\/en.wikipedia.org\/wiki\/Uniform_Resource_Name Uniform Resource Name\\n     * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562.html#section-4 RFC 9562, 4. UUID Format\\n     * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562.html#section-7 RFC 9562, 7. IANA Considerations\\n     * @link https:\/\/www.rfc-editor.org\/rfc\/rfc4122.html#section-3 RFC 4122, 3. Namespace Registration Template\\n     *\/\\n    public function getUrn(): string;\\n\\n    \/**\\n     * Returns the string standard representation of the UUID\\n     *\\n     * @return non-empty-string\\n     *\\n     * @pure\\n     *\/\\n    public function toString(): string;\\n\\n    \/**\\n     * Casts the UUID to the string standard representation\\n     *\\n     * @return non-empty-string\\n     *\\n     * @pure\\n     *\/\\n    public function __toString(): string;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/DegradedUuid.php\",\"ext\":\"php\",\"size\":589,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid;\\n\\n\/**\\n * @deprecated DegradedUuid is no longer necessary to represent UUIDs on 32-bit systems.\\n *     Transition any type declarations using this class to {@see UuidInterface}.\\n *\\n * @immutable\\n *\/\\nclass DegradedUuid extends Uuid\\n{\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Exception\/NodeException.php\",\"ext\":\"php\",\"size\":595,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Exception;\\n\\nuse RuntimeException as PhpRuntimeException;\\n\\n\/**\\n * Thrown to indicate that attempting to fetch or create a node ID encountered an error\\n *\/\\nclass NodeException extends PhpRuntimeException implements UuidExceptionInterface\\n{\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Exception\/RandomSourceException.php\",\"ext\":\"php\",\"size\":754,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Exception;\\n\\nuse RuntimeException as PhpRuntimeException;\\n\\n\/**\\n * Thrown to indicate that the source of random data encountered an error\\n *\\n * This exception is used mostly to indicate that random_bytes() or random_int() threw an exception. However, it may be\\n * used for other sources of random data.\\n *\/\\nclass RandomSourceException extends PhpRuntimeException implements UuidExceptionInterface\\n{\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Exception\/DceSecurityException.php\",\"ext\":\"php\",\"size\":608,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Exception;\\n\\nuse RuntimeException as PhpRuntimeException;\\n\\n\/**\\n * Thrown to indicate an exception occurred while dealing with DCE Security (version 2) UUIDs\\n *\/\\nclass DceSecurityException extends PhpRuntimeException implements UuidExceptionInterface\\n{\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Exception\/NameException.php\",\"ext\":\"php\",\"size\":598,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Exception;\\n\\nuse RuntimeException as PhpRuntimeException;\\n\\n\/**\\n * Thrown to indicate that an error occurred while attempting to hash a namespace and name\\n *\/\\nclass NameException extends PhpRuntimeException implements UuidExceptionInterface\\n{\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Exception\/TimeSourceException.php\",\"ext\":\"php\",\"size\":580,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Exception;\\n\\nuse RuntimeException as PhpRuntimeException;\\n\\n\/**\\n * Thrown to indicate that the source of time encountered an error\\n *\/\\nclass TimeSourceException extends PhpRuntimeException implements UuidExceptionInterface\\n{\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Exception\/UuidExceptionInterface.php\",\"ext\":\"php\",\"size\":438,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Exception;\\n\\nuse Throwable;\\n\\ninterface UuidExceptionInterface extends Throwable\\n{\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Exception\/UnableToBuildUuidException.php\",\"ext\":\"php\",\"size\":578,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Exception;\\n\\nuse RuntimeException as PhpRuntimeException;\\n\\n\/**\\n * Thrown to indicate a builder is unable to build a UUID\\n *\/\\nclass UnableToBuildUuidException extends PhpRuntimeException implements UuidExceptionInterface\\n{\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Exception\/InvalidUuidStringException.php\",\"ext\":\"php\",\"size\":695,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Exception;\\n\\n\/**\\n * Thrown to indicate that the string received is not a valid UUID\\n *\\n * The InvalidArgumentException that this extends is the ramsey\/uuid version of this exception. It exists in the same\\n * namespace as this class.\\n *\/\\nclass InvalidUuidStringException extends InvalidArgumentException implements UuidExceptionInterface\\n{\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Exception\/InvalidBytesException.php\",\"ext\":\"php\",\"size\":594,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Exception;\\n\\nuse RuntimeException as PhpRuntimeException;\\n\\n\/**\\n * Thrown to indicate that the bytes being operated on are invalid in some way\\n *\/\\nclass InvalidBytesException extends PhpRuntimeException implements UuidExceptionInterface\\n{\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Exception\/BuilderNotFoundException.php\",\"ext\":\"php\",\"size\":580,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Exception;\\n\\nuse RuntimeException as PhpRuntimeException;\\n\\n\/**\\n * Thrown to indicate that no suitable builder could be found\\n *\/\\nclass BuilderNotFoundException extends PhpRuntimeException implements UuidExceptionInterface\\n{\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Exception\/DateTimeException.php\",\"ext\":\"php\",\"size\":596,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Exception;\\n\\nuse RuntimeException as PhpRuntimeException;\\n\\n\/**\\n * Thrown to indicate that the PHP DateTime extension encountered an exception\/error\\n *\/\\nclass DateTimeException extends PhpRuntimeException implements UuidExceptionInterface\\n{\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Exception\/InvalidArgumentException.php\",\"ext\":\"php\",\"size\":604,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Exception;\\n\\nuse InvalidArgumentException as PhpInvalidArgumentException;\\n\\n\/**\\n * Thrown to indicate that the argument received is not valid\\n *\/\\nclass InvalidArgumentException extends PhpInvalidArgumentException implements UuidExceptionInterface\\n{\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Exception\/UnsupportedOperationException.php\",\"ext\":\"php\",\"size\":585,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Exception;\\n\\nuse LogicException as PhpLogicException;\\n\\n\/**\\n * Thrown to indicate that the requested operation is not supported\\n *\/\\nclass UnsupportedOperationException extends PhpLogicException implements UuidExceptionInterface\\n{\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Rfc4122\/Fields.php\",\"ext\":\"php\",\"size\":5987,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Rfc4122;\\n\\nuse Ramsey\\\\Uuid\\\\Exception\\\\InvalidArgumentException;\\nuse Ramsey\\\\Uuid\\\\Fields\\\\SerializableFieldsTrait;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Hexadecimal;\\nuse Ramsey\\\\Uuid\\\\Uuid;\\n\\nuse function bin2hex;\\nuse function dechex;\\nuse function hexdec;\\nuse function sprintf;\\nuse function str_pad;\\nuse function strlen;\\nuse function substr;\\nuse function unpack;\\n\\nuse const STR_PAD_LEFT;\\n\\n\/**\\n * RFC 9562 (formerly RFC 4122) variant UUIDs consist of a set of named fields\\n *\\n * Internally, this class represents the fields together as a 16-byte binary string.\\n *\\n * @immutable\\n *\/\\nfinal class Fields implements FieldsInterface\\n{\\n    use MaxTrait;\\n    use NilTrait;\\n    use SerializableFieldsTrait;\\n    use VariantTrait;\\n    use VersionTrait;\\n\\n    \/**\\n     * @param string $bytes A 16-byte binary string representation of a UUID\\n     *\\n     * @throws InvalidArgumentException if the byte string is not exactly 16 bytes\\n     * @throws InvalidArgumentException if the byte string does not represent an RFC 9562 (formerly RFC 4122) UUID\\n     * @throws InvalidArgumentException if the byte string does not contain a valid version\\n     *\/\\n    public function __construct(private string $bytes)\\n    {\\n        if (strlen($this->bytes) !== 16) {\\n            throw new InvalidArgumentException(\\n                'The byte string must be 16 bytes long; ' . 'received ' . strlen($this->bytes) . ' bytes',\\n            );\\n        }\\n\\n        if (!$this->isCorrectVariant()) {\\n            throw new InvalidArgumentException(\\n                'The byte string received does not conform to the RFC 9562 (formerly RFC 4122) variant',\\n            );\\n        }\\n\\n        if (!$this->isCorrectVersion()) {\\n            throw new InvalidArgumentException(\\n                'The byte string received does not contain a valid RFC 9562 (formerly RFC 4122) version',\\n            );\\n        }\\n    }\\n\\n    \/**\\n     * @pure\\n     *\/\\n    public function getBytes(): string\\n    {\\n        return $this->bytes;\\n    }\\n\\n    public function getClockSeq(): Hexadecimal\\n    {\\n        if ($this->isMax()) {\\n            $clockSeq = 0xffff;\\n        } elseif ($this->isNil()) {\\n            $clockSeq = 0x0000;\\n        } else {\\n            $clockSeq = hexdec(bin2hex(substr($this->bytes, 8, 2))) & 0x3fff;\\n        }\\n\\n        return new Hexadecimal(str_pad(dechex($clockSeq), 4, '0', STR_PAD_LEFT));\\n    }\\n\\n    public function getClockSeqHiAndReserved(): Hexadecimal\\n    {\\n        return new Hexadecimal(bin2hex(substr($this->bytes, 8, 1)));\\n    }\\n\\n    public function getClockSeqLow(): Hexadecimal\\n    {\\n        return new Hexadecimal(bin2hex(substr($this->bytes, 9, 1)));\\n    }\\n\\n    public function getNode(): Hexadecimal\\n    {\\n        return new Hexadecimal(bin2hex(substr($this->bytes, 10)));\\n    }\\n\\n    public function getTimeHiAndVersion(): Hexadecimal\\n    {\\n        return new Hexadecimal(bin2hex(substr($this->bytes, 6, 2)));\\n    }\\n\\n    public function getTimeLow(): Hexadecimal\\n    {\\n        return new Hexadecimal(bin2hex(substr($this->bytes, 0, 4)));\\n    }\\n\\n    public function getTimeMid(): Hexadecimal\\n    {\\n        return new Hexadecimal(bin2hex(substr($this->bytes, 4, 2)));\\n    }\\n\\n    \/**\\n     * Returns the full 60-bit timestamp, without the version\\n     *\\n     * For version 2 UUIDs, the time_low field is the local identifier and should not be returned as part of the time.\\n     * For this reason, we set the bottom 32 bits of the timestamp to 0's. As a result, there is some loss of timestamp\\n     * fidelity, for version 2 UUIDs. The timestamp can be off by a range of 0 to 429.4967295 seconds (or 7 minutes, 9\\n     * seconds, and 496,730 microseconds).\\n     *\\n     * For version 6 UUIDs, the timestamp order is reversed from the typical RFC 9562 (formerly RFC 4122) order (the\\n     * time bits are in the correct bit order, so that it is monotonically increasing). In returning the timestamp\\n     * value, we put the bits in the order: time_low + time_mid + time_hi.\\n     *\/\\n    public function getTimestamp(): Hexadecimal\\n    {\\n        return new Hexadecimal(match ($this->getVersion()) {\\n            Uuid::UUID_TYPE_DCE_SECURITY => sprintf(\\n                '%03x%04s%08s',\\n                hexdec($this->getTimeHiAndVersion()->toString()) & 0x0fff,\\n                $this->getTimeMid()->toString(),\\n                ''\\n            ),\\n            Uuid::UUID_TYPE_REORDERED_TIME => sprintf(\\n                '%08s%04s%03x',\\n                $this->getTimeLow()->toString(),\\n                $this->getTimeMid()->toString(),\\n                hexdec($this->getTimeHiAndVersion()->toString()) & 0x0fff\\n            ),\\n            \/\/ The Unix timestamp in version 7 UUIDs is a 48-bit number, but for consistency, we will return a 60-bit\\n            \/\/ number, padded to the left with zeros.\\n            Uuid::UUID_TYPE_UNIX_TIME => sprintf(\\n                '%011s%04s',\\n                $this->getTimeLow()->toString(),\\n                $this->getTimeMid()->toString(),\\n            ),\\n            default => sprintf(\\n                '%03x%04s%08s',\\n                hexdec($this->getTimeHiAndVersion()->toString()) & 0x0fff,\\n                $this->getTimeMid()->toString(),\\n                $this->getTimeLow()->toString()\\n            ),\\n        });\\n    }\\n\\n    public function getVersion(): ?int\\n    {\\n        if ($this->isNil() || $this->isMax()) {\\n            return null;\\n        }\\n\\n        \/** @var int[] $parts *\/\\n        $parts = unpack('n*', $this->bytes);\\n\\n        return $parts[4] >> 12;\\n    }\\n\\n    private function isCorrectVariant(): bool\\n    {\\n        if ($this->isNil() || $this->isMax()) {\\n            return true;\\n        }\\n\\n        return $this->getVariant() === Uuid::RFC_4122;\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Rfc4122\/NilTrait.php\",\"ext\":\"php\",\"size\":788,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Rfc4122;\\n\\n\/**\\n * Provides common functionality for nil UUIDs\\n *\\n * @immutable\\n *\/\\ntrait NilTrait\\n{\\n    \/**\\n     * Returns the bytes that comprise the fields\\n     *\\n     * @pure\\n     *\/\\n    abstract public function getBytes(): string;\\n\\n    \/**\\n     * Returns true if the byte string represents a nil UUID\\n     *\/\\n    public function isNil(): bool\\n    {\\n        return $this->getBytes() === \\\"\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\";\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Rfc4122\/UuidV7.php\",\"ext\":\"php\",\"size\":2040,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Rfc4122;\\n\\nuse Ramsey\\\\Uuid\\\\Codec\\\\CodecInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\NumberConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\TimeConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Exception\\\\InvalidArgumentException;\\nuse Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface as Rfc4122FieldsInterface;\\nuse Ramsey\\\\Uuid\\\\Uuid;\\n\\n\/**\\n * Unix Epoch time, or version 7, UUIDs include a timestamp in milliseconds since the Unix Epoch, along with random bytes\\n *\\n * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-5.7 RFC 9562, 5.7. UUID Version 7\\n *\\n * @immutable\\n *\/\\nfinal class UuidV7 extends Uuid implements UuidInterface\\n{\\n    use TimeTrait;\\n\\n    \/**\\n     * Creates a version 7 (Unix Epoch time) UUID\\n     *\\n     * @param Rfc4122FieldsInterface $fields The fields from which to construct a UUID\\n     * @param NumberConverterInterface $numberConverter The number converter to use for converting hex values to\/from integers\\n     * @param CodecInterface $codec The codec to use when encoding or decoding UUID strings\\n     * @param TimeConverterInterface $timeConverter The time converter to use for converting timestamps extracted from a\\n     *     UUID to unix timestamps\\n     *\/\\n    public function __construct(\\n        Rfc4122FieldsInterface $fields,\\n        NumberConverterInterface $numberConverter,\\n        CodecInterface $codec,\\n        TimeConverterInterface $timeConverter,\\n    ) {\\n        if ($fields->getVersion() !== Uuid::UUID_TYPE_UNIX_TIME) {\\n            throw new InvalidArgumentException(\\n                'Fields used to create a UuidV7 must represent a version 7 (Unix Epoch time) UUID',\\n            );\\n        }\\n\\n        parent::__construct($fields, $numberConverter, $codec, $timeConverter);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Rfc4122\/TimeTrait.php\",\"ext\":\"php\",\"size\":1397,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Rfc4122;\\n\\nuse DateTimeImmutable;\\nuse DateTimeInterface;\\nuse Ramsey\\\\Uuid\\\\Exception\\\\DateTimeException;\\nuse Throwable;\\n\\nuse function str_pad;\\n\\nuse const STR_PAD_LEFT;\\n\\n\/**\\n * Provides common functionality for getting the time from a time-based UUID\\n *\\n * @immutable\\n *\/\\ntrait TimeTrait\\n{\\n    \/**\\n     * Returns a DateTimeInterface object representing the timestamp associated with the UUID\\n     *\\n     * @return DateTimeImmutable A PHP DateTimeImmutable instance representing the timestamp of a time-based UUID\\n     *\/\\n    public function getDateTime(): DateTimeInterface\\n    {\\n        $time = $this->timeConverter->convertTime($this->fields->getTimestamp());\\n\\n        try {\\n            return new DateTimeImmutable(\\n                '@'\\n                . $time->getSeconds()->toString()\\n                . '.'\\n                . str_pad($time->getMicroseconds()->toString(), 6, '0', STR_PAD_LEFT)\\n            );\\n        } catch (Throwable $e) {\\n            throw new DateTimeException($e->getMessage(), (int) $e->getCode(), $e);\\n        }\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Rfc4122\/MaxTrait.php\",\"ext\":\"php\",\"size\":840,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Rfc4122;\\n\\n\/**\\n * Provides common functionality for max UUIDs\\n *\\n * @immutable\\n *\/\\ntrait MaxTrait\\n{\\n    \/**\\n     * Returns the bytes that comprise the fields\\n     *\\n     * @pure\\n     *\/\\n    abstract public function getBytes(): string;\\n\\n    \/**\\n     * Returns true if the byte string represents a max UUID\\n     *\\n     * @pure\\n     *\/\\n    public function isMax(): bool\\n    {\\n        return $this->getBytes() === \\\"\\\\xff\\\\xff\\\\xff\\\\xff\\\\xff\\\\xff\\\\xff\\\\xff\\\\xff\\\\xff\\\\xff\\\\xff\\\\xff\\\\xff\\\\xff\\\\xff\\\";\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Rfc4122\/UuidV3.php\",\"ext\":\"php\",\"size\":2074,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Rfc4122;\\n\\nuse Ramsey\\\\Uuid\\\\Codec\\\\CodecInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\NumberConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\TimeConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Exception\\\\InvalidArgumentException;\\nuse Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface as Rfc4122FieldsInterface;\\nuse Ramsey\\\\Uuid\\\\Uuid;\\n\\n\/**\\n * Version 3 UUIDs are named-based, using a combination of a namespace and name that are hashed into a 128-bit unsigned\\n * integer using the MD5 hashing algorithm\\n *\\n * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-5.3 RFC 9562, 5.3. UUID Version 3\\n *\\n * @immutable\\n *\/\\nfinal class UuidV3 extends Uuid implements UuidInterface\\n{\\n    \/**\\n     * Creates a version 3 (name-based, MD5-hashed) UUID\\n     *\\n     * @param Rfc4122FieldsInterface $fields The fields from which to construct a UUID\\n     * @param NumberConverterInterface $numberConverter The number converter to use for converting hex values to\/from integers\\n     * @param CodecInterface $codec The codec to use when encoding or decoding UUID strings\\n     * @param TimeConverterInterface $timeConverter The time converter to use for converting timestamps extracted from a\\n     *     UUID to unix timestamps\\n     *\/\\n    public function __construct(\\n        Rfc4122FieldsInterface $fields,\\n        NumberConverterInterface $numberConverter,\\n        CodecInterface $codec,\\n        TimeConverterInterface $timeConverter,\\n    ) {\\n        if ($fields->getVersion() !== Uuid::UUID_TYPE_HASH_MD5) {\\n            throw new InvalidArgumentException(\\n                'Fields used to create a UuidV3 must represent a version 3 (name-based, MD5-hashed) UUID',\\n            );\\n        }\\n\\n        parent::__construct($fields, $numberConverter, $codec, $timeConverter);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Rfc4122\/UuidV4.php\",\"ext\":\"php\",\"size\":1967,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Rfc4122;\\n\\nuse Ramsey\\\\Uuid\\\\Codec\\\\CodecInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\NumberConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\TimeConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Exception\\\\InvalidArgumentException;\\nuse Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface as Rfc4122FieldsInterface;\\nuse Ramsey\\\\Uuid\\\\Uuid;\\n\\n\/**\\n * Random, or version 4, UUIDs are randomly or pseudo-randomly generated 128-bit integers\\n *\\n * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-5.4 RFC 9562, 5.4. UUID Version 4\\n *\\n * @immutable\\n *\/\\nfinal class UuidV4 extends Uuid implements UuidInterface\\n{\\n    \/**\\n     * Creates a version 4 (random) UUID\\n     *\\n     * @param Rfc4122FieldsInterface $fields The fields from which to construct a UUID\\n     * @param NumberConverterInterface $numberConverter The number converter to use for converting hex values to\/from integers\\n     * @param CodecInterface $codec The codec to use when encoding or decoding UUID strings\\n     * @param TimeConverterInterface $timeConverter The time converter to use for converting timestamps extracted from a\\n     *     UUID to unix timestamps\\n     *\/\\n    public function __construct(\\n        Rfc4122FieldsInterface $fields,\\n        NumberConverterInterface $numberConverter,\\n        CodecInterface $codec,\\n        TimeConverterInterface $timeConverter,\\n    ) {\\n        if ($fields->getVersion() !== Uuid::UUID_TYPE_RANDOM) {\\n            throw new InvalidArgumentException(\\n                'Fields used to create a UuidV4 must represent a version 4 (random) UUID',\\n            );\\n        }\\n\\n        parent::__construct($fields, $numberConverter, $codec, $timeConverter);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Rfc4122\/UuidV2.php\",\"ext\":\"php\",\"size\":4306,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Rfc4122;\\n\\nuse Ramsey\\\\Uuid\\\\Codec\\\\CodecInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\NumberConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\TimeConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Exception\\\\InvalidArgumentException;\\nuse Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface as Rfc4122FieldsInterface;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Integer as IntegerObject;\\nuse Ramsey\\\\Uuid\\\\Uuid;\\n\\nuse function hexdec;\\n\\n\/**\\n * DCE Security version, or version 2, UUIDs include local domain identifier, local ID for the specified domain, and\\n * node values that are combined into a 128-bit unsigned integer\\n *\\n * It is important to note that a version 2 UUID suffers from some loss of timestamp fidelity, due to replacing the\\n * time_low field with the local identifier. When constructing the timestamp value for date purposes, we replace the\\n * local identifier bits with zeros. As a result, the timestamp can be off by a range of 0 to 429.4967295 seconds (or 7\\n * minutes, 9 seconds, and 496,730 microseconds).\\n *\\n * Astute observers might note this value directly corresponds to `2^32-1`, or `0xffffffff`. The local identifier is\\n * 32-bits, and we have set each of these bits to `0`, so the maximum range of timestamp drift is `0x00000000` to\\n * `0xffffffff` (counted in 100-nanosecond intervals).\\n *\\n * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-5.2 RFC 9562, 5.2. UUID Version 2\\n * @link https:\/\/publications.opengroup.org\/c311 DCE 1.1: Authentication and Security Services\\n * @link https:\/\/publications.opengroup.org\/c706 DCE 1.1: Remote Procedure Call\\n * @link https:\/\/pubs.opengroup.org\/onlinepubs\/9696989899\/chap5.htm#tagcjh_08_02_01_01 DCE 1.1: Auth & Sec, \u00a75.2.1.1\\n * @link https:\/\/pubs.opengroup.org\/onlinepubs\/9696989899\/chap11.htm#tagcjh_14_05_01_01 DCE 1.1: Auth & Sec, \u00a711.5.1.1\\n * @link https:\/\/pubs.opengroup.org\/onlinepubs\/9629399\/apdxa.htm DCE 1.1: RPC, Appendix A\\n * @link https:\/\/github.com\/google\/uuid Go package for UUIDs (includes DCE implementation)\\n *\\n * @immutable\\n *\/\\nfinal class UuidV2 extends Uuid implements UuidInterface\\n{\\n    use TimeTrait;\\n\\n    \/**\\n     * Creates a version 2 (DCE Security) UUID\\n     *\\n     * @param Rfc4122FieldsInterface $fields The fields from which to construct a UUID\\n     * @param NumberConverterInterface $numberConverter The number converter to use for converting hex values to\/from integers\\n     * @param CodecInterface $codec The codec to use when encoding or decoding UUID strings\\n     * @param TimeConverterInterface $timeConverter The time converter to use for converting timestamps extracted from a\\n     *     UUID to unix timestamps\\n     *\/\\n    public function __construct(\\n        Rfc4122FieldsInterface $fields,\\n        NumberConverterInterface $numberConverter,\\n        CodecInterface $codec,\\n        TimeConverterInterface $timeConverter,\\n    ) {\\n        if ($fields->getVersion() !== Uuid::UUID_TYPE_DCE_SECURITY) {\\n            throw new InvalidArgumentException(\\n                'Fields used to create a UuidV2 must represent a version 2 (DCE Security) UUID'\\n            );\\n        }\\n\\n        parent::__construct($fields, $numberConverter, $codec, $timeConverter);\\n    }\\n\\n    \/**\\n     * Returns the local domain used to create this version 2 UUID\\n     *\/\\n    public function getLocalDomain(): int\\n    {\\n        \/** @var Rfc4122FieldsInterface $fields *\/\\n        $fields = $this->getFields();\\n\\n        return (int) hexdec($fields->getClockSeqLow()->toString());\\n    }\\n\\n    \/**\\n     * Returns the string name of the local domain\\n     *\/\\n    public function getLocalDomainName(): string\\n    {\\n        return Uuid::DCE_DOMAIN_NAMES[$this->getLocalDomain()];\\n    }\\n\\n    \/**\\n     * Returns the local identifier for the domain used to create this version 2 UUID\\n     *\/\\n    public function getLocalIdentifier(): IntegerObject\\n    {\\n        \/** @var Rfc4122FieldsInterface $fields *\/\\n        $fields = $this->getFields();\\n\\n        return new IntegerObject($this->numberConverter->fromHex($fields->getTimeLow()->toString()));\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Rfc4122\/UuidV1.php\",\"ext\":\"php\",\"size\":2039,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Rfc4122;\\n\\nuse Ramsey\\\\Uuid\\\\Codec\\\\CodecInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\NumberConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\TimeConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Exception\\\\InvalidArgumentException;\\nuse Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface as Rfc4122FieldsInterface;\\nuse Ramsey\\\\Uuid\\\\Uuid;\\n\\n\/**\\n * Gregorian time, or version 1, UUIDs include timestamp, clock sequence, and node values, combined into a 128-bit unsigned integer\\n *\\n * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-5.1 RFC 9562, 5.1. UUID Version 1\\n *\\n * @immutable\\n *\/\\nfinal class UuidV1 extends Uuid implements UuidInterface\\n{\\n    use TimeTrait;\\n\\n    \/**\\n     * Creates a version 1 (Gregorian time) UUID\\n     *\\n     * @param Rfc4122FieldsInterface $fields The fields from which to construct a UUID\\n     * @param NumberConverterInterface $numberConverter The number converter to use for converting hex values to\/from integers\\n     * @param CodecInterface $codec The codec to use when encoding or decoding UUID strings\\n     * @param TimeConverterInterface $timeConverter The time converter to use for converting timestamps extracted from a\\n     *     UUID to unix timestamps\\n     *\/\\n    public function __construct(\\n        Rfc4122FieldsInterface $fields,\\n        NumberConverterInterface $numberConverter,\\n        CodecInterface $codec,\\n        TimeConverterInterface $timeConverter,\\n    ) {\\n        if ($fields->getVersion() !== Uuid::UUID_TYPE_TIME) {\\n            throw new InvalidArgumentException(\\n                'Fields used to create a UuidV1 must represent a version 1 (time-based) UUID',\\n            );\\n        }\\n\\n        parent::__construct($fields, $numberConverter, $codec, $timeConverter);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Rfc4122\/NilUuid.php\",\"ext\":\"php\",\"size\":644,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Rfc4122;\\n\\nuse Ramsey\\\\Uuid\\\\Uuid;\\n\\n\/**\\n * The nil UUID is a special form of UUID that has all 128 bits set to zero (`0`)\\n *\\n * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-5.9 RFC 9562, 5.9. Nil UUID\\n *\\n * @immutable\\n *\/\\nfinal class NilUuid extends Uuid implements UuidInterface\\n{\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Rfc4122\/VariantTrait.php\",\"ext\":\"php\",\"size\":3069,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Rfc4122;\\n\\nuse Ramsey\\\\Uuid\\\\Exception\\\\InvalidBytesException;\\nuse Ramsey\\\\Uuid\\\\Uuid;\\n\\nuse function decbin;\\nuse function str_pad;\\nuse function str_starts_with;\\nuse function strlen;\\nuse function substr;\\nuse function unpack;\\n\\nuse const STR_PAD_LEFT;\\n\\n\/**\\n * Provides common functionality for handling the variant, as defined by RFC 9562 (formerly RFC 4122)\\n *\\n * @immutable\\n *\/\\ntrait VariantTrait\\n{\\n    \/**\\n     * Returns the bytes that comprise the fields\\n     *\/\\n    abstract public function getBytes(): string;\\n\\n    \/**\\n     * Returns the variant\\n     *\\n     * The variant number describes the layout of the UUID. The variant number has the following meaning:\\n     *\\n     * - 0 - Reserved for NCS backward compatibility\\n     * - 2 - The RFC 9562 (formerly RFC 4122) variant\\n     * - 6 - Reserved, Microsoft Corporation backward compatibility\\n     * - 7 - Reserved for future definition\\n     *\\n     * For RFC 9562 (formerly RFC 4122) variant UUIDs, this value should always be the integer `2`.\\n     *\\n     * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-4.1 RFC 9562, 4.1. Variant Field\\n     *\/\\n    public function getVariant(): int\\n    {\\n        if (strlen($this->getBytes()) !== 16) {\\n            throw new InvalidBytesException('Invalid number of bytes');\\n        }\\n\\n        \/\/ According to RFC 9562, sections {@link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-4.1 4.1} and\\n        \/\/ {@link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-5.10 5.10}, the Max UUID falls within the range\\n        \/\/ of the future variant.\\n        if ($this->isMax()) {\\n            return Uuid::RESERVED_FUTURE;\\n        }\\n\\n        \/\/ According to RFC 9562, sections {@link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-4.1 4.1} and\\n        \/\/ {@link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-5.9 5.9}, the Nil UUID falls within the range\\n        \/\/ of the Apollo NCS variant.\\n        if ($this->isNil()) {\\n            return Uuid::RESERVED_NCS;\\n        }\\n\\n        \/** @var int[] $parts *\/\\n        $parts = unpack('n*', $this->getBytes());\\n\\n        \/\/ $parts[5] is a 16-bit, unsigned integer containing the variant bits of the UUID. We convert this integer into\\n        \/\/ a string containing a binary representation, padded to 16 characters. We analyze the first three characters\\n        \/\/ (three most-significant bits) to determine the variant.\\n        $msb = substr(str_pad(decbin($parts[5]), 16, '0', STR_PAD_LEFT), 0, 3);\\n\\n        if ($msb === '111') {\\n            return Uuid::RESERVED_FUTURE;\\n        } elseif ($msb === '110') {\\n            return Uuid::RESERVED_MICROSOFT;\\n        } elseif (str_starts_with($msb, '10')) {\\n            return Uuid::RFC_4122;\\n        }\\n\\n        return Uuid::RESERVED_NCS;\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Rfc4122\/Validator.php\",\"ext\":\"php\",\"size\":1335,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Rfc4122;\\n\\nuse Ramsey\\\\Uuid\\\\Uuid;\\nuse Ramsey\\\\Uuid\\\\Validator\\\\ValidatorInterface;\\n\\nuse function preg_match;\\nuse function str_replace;\\n\\n\/**\\n * Rfc4122\\\\Validator validates strings as UUIDs of the RFC 9562 (formerly RFC 4122) variant\\n *\\n * @immutable\\n *\/\\nfinal class Validator implements ValidatorInterface\\n{\\n    private const VALID_PATTERN = '\\\\A[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-'\\n        . '[1-8][0-9A-Fa-f]{3}-[ABab89][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}\\\\z';\\n\\n    \/**\\n     * @return non-empty-string\\n     *\/\\n    public function getPattern(): string\\n    {\\n        return self::VALID_PATTERN;\\n    }\\n\\n    public function validate(string $uuid): bool\\n    {\\n        \/** @phpstan-ignore possiblyImpure.functionCall *\/\\n        $uuid = strtolower(str_replace(['urn:', 'uuid:', 'URN:', 'UUID:', '{', '}'], '', $uuid));\\n\\n        \/** @phpstan-ignore possiblyImpure.functionCall *\/\\n        return $uuid === Uuid::NIL || $uuid === Uuid::MAX || preg_match('\/' . self::VALID_PATTERN . '\/Dms', $uuid);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Rfc4122\/UuidBuilder.php\",\"ext\":\"php\",\"size\":5123,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Rfc4122;\\n\\nuse Ramsey\\\\Uuid\\\\Builder\\\\UuidBuilderInterface;\\nuse Ramsey\\\\Uuid\\\\Codec\\\\CodecInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\NumberConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\Time\\\\UnixTimeConverter;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\TimeConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Exception\\\\UnableToBuildUuidException;\\nuse Ramsey\\\\Uuid\\\\Exception\\\\UnsupportedOperationException;\\nuse Ramsey\\\\Uuid\\\\Math\\\\BrickMathCalculator;\\nuse Ramsey\\\\Uuid\\\\Rfc4122\\\\UuidInterface as Rfc4122UuidInterface;\\nuse Ramsey\\\\Uuid\\\\Uuid;\\nuse Ramsey\\\\Uuid\\\\UuidInterface;\\nuse Throwable;\\n\\n\/**\\n * UuidBuilder builds instances of RFC 9562 (formerly 4122) UUIDs\\n *\\n * @immutable\\n *\/\\nclass UuidBuilder implements UuidBuilderInterface\\n{\\n    private TimeConverterInterface $unixTimeConverter;\\n\\n    \/**\\n     * Constructs the DefaultUuidBuilder\\n     *\\n     * @param NumberConverterInterface $numberConverter The number converter to use when constructing the Uuid\\n     * @param TimeConverterInterface $timeConverter The time converter to use for converting Gregorian time extracted\\n     *     from version 1, 2, and 6 UUIDs to Unix timestamps\\n     * @param TimeConverterInterface | null $unixTimeConverter The time converter to use for converter Unix Epoch time\\n     *     extracted from version 7 UUIDs to Unix timestamps\\n     *\/\\n    public function __construct(\\n        private NumberConverterInterface $numberConverter,\\n        private TimeConverterInterface $timeConverter,\\n        ?TimeConverterInterface $unixTimeConverter = null,\\n    ) {\\n        $this->unixTimeConverter = $unixTimeConverter ?? new UnixTimeConverter(new BrickMathCalculator());\\n    }\\n\\n    \/**\\n     * Builds and returns a Uuid\\n     *\\n     * @param CodecInterface $codec The codec to use for building this Uuid instance\\n     * @param string $bytes The byte string from which to construct a UUID\\n     *\\n     * @return Rfc4122UuidInterface UuidBuilder returns instances of Rfc4122UuidInterface\\n     *\\n     * @pure\\n     *\/\\n    public function build(CodecInterface $codec, string $bytes): UuidInterface\\n    {\\n        try {\\n            \/** @var Fields $fields *\/\\n            $fields = $this->buildFields($bytes);\\n\\n            if ($fields->isNil()) {\\n                \/** @phpstan-ignore possiblyImpure.new *\/\\n                return new NilUuid($fields, $this->numberConverter, $codec, $this->timeConverter);\\n            }\\n\\n            if ($fields->isMax()) {\\n                \/** @phpstan-ignore possiblyImpure.new *\/\\n                return new MaxUuid($fields, $this->numberConverter, $codec, $this->timeConverter);\\n            }\\n\\n            return match ($fields->getVersion()) {\\n                \/** @phpstan-ignore possiblyImpure.new *\/\\n                Uuid::UUID_TYPE_TIME => new UuidV1($fields, $this->numberConverter, $codec, $this->timeConverter),\\n                Uuid::UUID_TYPE_DCE_SECURITY\\n                    \/** @phpstan-ignore possiblyImpure.new *\/\\n                    => new UuidV2($fields, $this->numberConverter, $codec, $this->timeConverter),\\n                \/** @phpstan-ignore possiblyImpure.new *\/\\n                Uuid::UUID_TYPE_HASH_MD5 => new UuidV3($fields, $this->numberConverter, $codec, $this->timeConverter),\\n                \/** @phpstan-ignore possiblyImpure.new *\/\\n                Uuid::UUID_TYPE_RANDOM => new UuidV4($fields, $this->numberConverter, $codec, $this->timeConverter),\\n                \/** @phpstan-ignore possiblyImpure.new *\/\\n                Uuid::UUID_TYPE_HASH_SHA1 => new UuidV5($fields, $this->numberConverter, $codec, $this->timeConverter),\\n                Uuid::UUID_TYPE_REORDERED_TIME\\n                    \/** @phpstan-ignore possiblyImpure.new *\/\\n                    => new UuidV6($fields, $this->numberConverter, $codec, $this->timeConverter),\\n                Uuid::UUID_TYPE_UNIX_TIME\\n                    \/** @phpstan-ignore possiblyImpure.new *\/\\n                    => new UuidV7($fields, $this->numberConverter, $codec, $this->unixTimeConverter),\\n                \/** @phpstan-ignore possiblyImpure.new *\/\\n                Uuid::UUID_TYPE_CUSTOM => new UuidV8($fields, $this->numberConverter, $codec, $this->timeConverter),\\n                default => throw new UnsupportedOperationException(\\n                    'The UUID version in the given fields is not supported by this UUID builder',\\n                ),\\n            };\\n        } catch (Throwable $e) {\\n            \/** @phpstan-ignore possiblyImpure.methodCall, possiblyImpure.methodCall *\/\\n            throw new UnableToBuildUuidException($e->getMessage(), (int) $e->getCode(), $e);\\n        }\\n    }\\n\\n    \/**\\n     * Proxy method to allow injecting a mock for testing\\n     *\\n     * @pure\\n     *\/\\n    protected function buildFields(string $bytes): FieldsInterface\\n    {\\n        \/** @phpstan-ignore possiblyImpure.new *\/\\n        return new Fields($bytes);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Rfc4122\/UuidInterface.php\",\"ext\":\"php\",\"size\":643,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Rfc4122;\\n\\nuse Ramsey\\\\Uuid\\\\UuidInterface as BaseUuidInterface;\\n\\n\/**\\n * A universally unique identifier (UUID), as defined in RFC 9562 (formerly RFC 4122)\\n *\\n * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562 RFC 9562\\n *\\n * @immutable\\n *\/\\ninterface UuidInterface extends BaseUuidInterface\\n{\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Rfc4122\/MaxUuid.php\",\"ext\":\"php\",\"size\":645,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Rfc4122;\\n\\nuse Ramsey\\\\Uuid\\\\Uuid;\\n\\n\/**\\n * The max UUID is a special form of UUID that has all 128 bits set to one (`1`)\\n *\\n * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-5.10 RFC 9562, 5.10. Max UUID\\n *\\n * @immutable\\n *\/\\nfinal class MaxUuid extends Uuid implements UuidInterface\\n{\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Rfc4122\/UuidV6.php\",\"ext\":\"php\",\"size\":768,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Rfc4122;\\n\\nuse Ramsey\\\\Uuid\\\\Nonstandard\\\\UuidV6 as NonstandardUuidV6;\\n\\n\/**\\n * Reordered Gregorian time, or version 6, UUIDs include timestamp, clock sequence, and node values that are combined\\n * into a 128-bit unsigned integer\\n *\\n * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-5.6 RFC 9562, 5.6. UUID Version 6\\n *\\n * @immutable\\n *\/\\nfinal class UuidV6 extends NonstandardUuidV6 implements UuidInterface\\n{\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Rfc4122\/UuidV5.php\",\"ext\":\"php\",\"size\":2079,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Rfc4122;\\n\\nuse Ramsey\\\\Uuid\\\\Codec\\\\CodecInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\NumberConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\TimeConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Exception\\\\InvalidArgumentException;\\nuse Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface as Rfc4122FieldsInterface;\\nuse Ramsey\\\\Uuid\\\\Uuid;\\n\\n\/**\\n * Version 5 UUIDs are named-based, using a combination of a namespace and name that are hashed into a 128-bit unsigned\\n * integer using the SHA1 hashing algorithm\\n *\\n * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-5.5 RFC 9562, 5.5. UUID Version 5\\n *\\n * @immutable\\n *\/\\nfinal class UuidV5 extends Uuid implements UuidInterface\\n{\\n    \/**\\n     * Creates a version 5 (name-based, SHA1-hashed) UUID\\n     *\\n     * @param Rfc4122FieldsInterface $fields The fields from which to construct a UUID\\n     * @param NumberConverterInterface $numberConverter The number converter to use for converting hex values to\/from integers\\n     * @param CodecInterface $codec The codec to use when encoding or decoding UUID strings\\n     * @param TimeConverterInterface $timeConverter The time converter to use for converting timestamps extracted from a\\n     *     UUID to unix timestamps\\n     *\/\\n    public function __construct(\\n        Rfc4122FieldsInterface $fields,\\n        NumberConverterInterface $numberConverter,\\n        CodecInterface $codec,\\n        TimeConverterInterface $timeConverter,\\n    ) {\\n        if ($fields->getVersion() !== Uuid::UUID_TYPE_HASH_SHA1) {\\n            throw new InvalidArgumentException(\\n                'Fields used to create a UuidV5 must represent a version 5 (named-based, SHA1-hashed) UUID',\\n            );\\n        }\\n\\n        parent::__construct($fields, $numberConverter, $codec, $timeConverter);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Rfc4122\/UuidV8.php\",\"ext\":\"php\",\"size\":2291,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Rfc4122;\\n\\nuse Ramsey\\\\Uuid\\\\Codec\\\\CodecInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\NumberConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Converter\\\\TimeConverterInterface;\\nuse Ramsey\\\\Uuid\\\\Exception\\\\InvalidArgumentException;\\nuse Ramsey\\\\Uuid\\\\Rfc4122\\\\FieldsInterface as Rfc4122FieldsInterface;\\nuse Ramsey\\\\Uuid\\\\Uuid;\\n\\n\/**\\n * Custom format, or version 8, UUIDs provide an RFC-compatible format for experimental or vendor-specific uses\\n *\\n * The only requirement for version 8 UUIDs is that the version and variant bits must be set. Otherwise, implementations\\n * are free to set the other bits according to their needs. As a result, the uniqueness of version 8 UUIDs is\\n * implementation-specific and should not be assumed.\\n *\\n * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-5.8 RFC 9562, 5.8. UUID Version 8\\n *\\n * @immutable\\n *\/\\nfinal class UuidV8 extends Uuid implements UuidInterface\\n{\\n    \/**\\n     * Creates a version 8 (custom format) UUID\\n     *\\n     * @param Rfc4122FieldsInterface $fields The fields from which to construct a UUID\\n     * @param NumberConverterInterface $numberConverter The number converter to use for converting hex values to\/from integers\\n     * @param CodecInterface $codec The codec to use when encoding or decoding UUID strings\\n     * @param TimeConverterInterface $timeConverter The time converter to use for converting timestamps extracted from a\\n     *     UUID to unix timestamps\\n     *\/\\n    public function __construct(\\n        Rfc4122FieldsInterface $fields,\\n        NumberConverterInterface $numberConverter,\\n        CodecInterface $codec,\\n        TimeConverterInterface $timeConverter,\\n    ) {\\n        if ($fields->getVersion() !== Uuid::UUID_TYPE_CUSTOM) {\\n            throw new InvalidArgumentException(\\n                'Fields used to create a UuidV8 must represent a version 8 (custom format) UUID',\\n            );\\n        }\\n\\n        parent::__construct($fields, $numberConverter, $codec, $timeConverter);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Rfc4122\/FieldsInterface.php\",\"ext\":\"php\",\"size\":4308,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Rfc4122;\\n\\nuse Ramsey\\\\Uuid\\\\Fields\\\\FieldsInterface as BaseFieldsInterface;\\nuse Ramsey\\\\Uuid\\\\Type\\\\Hexadecimal;\\n\\n\/**\\n * UUID fields, as defined by RFC 4122\\n *\\n * This interface defines the fields of an RFC 4122 variant UUID. Since RFC 9562 removed the concept of fields and\\n * instead defined layouts that are specific to a given version, this interface is a legacy artifact of the earlier, and\\n * now obsolete, RFC 4122.\\n *\\n * The fields of an RFC 4122 variant UUID are:\\n *\\n * * **time_low**: The low field of the timestamp, an unsigned 32-bit integer\\n * * **time_mid**: The middle field of the timestamp, an unsigned 16-bit integer\\n * * **time_hi_and_version**: The high field of the timestamp multiplexed with the version number, an unsigned 16-bit integer\\n * * **clock_seq_hi_and_reserved**: The high field of the clock sequence multiplexed with the variant, an unsigned 8-bit integer\\n * * **clock_seq_low**: The low field of the clock sequence, an unsigned 8-bit integer\\n * * **node**: The spatially unique node identifier, an unsigned 48-bit integer\\n *\\n * @link https:\/\/www.rfc-editor.org\/rfc\/rfc4122#section-4.1 RFC 4122, 4.1. Format\\n * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-4 RFC 9562, 4. UUID Format\\n *\\n * @immutable\\n *\/\\ninterface FieldsInterface extends BaseFieldsInterface\\n{\\n    \/**\\n     * Returns the full 16-bit clock sequence, with the variant bits (two most significant bits) masked out\\n     *\/\\n    public function getClockSeq(): Hexadecimal;\\n\\n    \/**\\n     * Returns the high field of the clock sequence multiplexed with the variant\\n     *\/\\n    public function getClockSeqHiAndReserved(): Hexadecimal;\\n\\n    \/**\\n     * Returns the low field of the clock sequence\\n     *\/\\n    public function getClockSeqLow(): Hexadecimal;\\n\\n    \/**\\n     * Returns the node field\\n     *\/\\n    public function getNode(): Hexadecimal;\\n\\n    \/**\\n     * Returns the high field of the timestamp multiplexed with the version\\n     *\/\\n    public function getTimeHiAndVersion(): Hexadecimal;\\n\\n    \/**\\n     * Returns the low field of the timestamp\\n     *\/\\n    public function getTimeLow(): Hexadecimal;\\n\\n    \/**\\n     * Returns the middle field of the timestamp\\n     *\/\\n    public function getTimeMid(): Hexadecimal;\\n\\n    \/**\\n     * Returns the full 60-bit timestamp, without the version\\n     *\/\\n    public function getTimestamp(): Hexadecimal;\\n\\n    \/**\\n     * Returns the variant\\n     *\\n     * The variant number describes the layout of the UUID. The variant number has the following meaning:\\n     *\\n     * - 0 - Reserved for NCS backward compatibility\\n     * - 2 - The RFC 9562 (formerly RFC 4122) variant\\n     * - 6 - Reserved, Microsoft Corporation backward compatibility\\n     * - 7 - Reserved for future definition\\n     *\\n     * For RFC 9562 (formerly RFC 4122) variant UUIDs, this value should always be the integer `2`.\\n     *\\n     * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-4.1 RFC 9562, 4.1. Variant Field\\n     *\/\\n    public function getVariant(): int;\\n\\n    \/**\\n     * Returns the UUID version\\n     *\\n     * The version number describes how the UUID was generated and has the following meaning:\\n     *\\n     * 1. Gregorian time UUID\\n     * 2. DCE security UUID\\n     * 3. Name-based UUID hashed with MD5\\n     * 4. Randomly generated UUID\\n     * 5. Name-based UUID hashed with SHA-1\\n     * 6. Reordered Gregorian time UUID\\n     * 7. Unix Epoch time UUID\\n     * 8. Custom format UUID\\n     *\\n     * This returns `null` if the UUID is not an RFC 9562 (formerly RFC 4122) variant, since the version is only\\n     * meaningful for this variant.\\n     *\\n     * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-4.2 RFC 9562, 4.2. Version Field\\n     *\\n     * @pure\\n     *\/\\n    public function getVersion(): ?int;\\n\\n    \/**\\n     * Returns true if these fields represent a nil UUID\\n     *\\n     * The nil UUID is a special form of UUID that is specified to have all 128 bits set to zero.\\n     *\\n     * @pure\\n     *\/\\n    public function isNil(): bool;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/uuid\/src\/Rfc4122\/VersionTrait.php\",\"ext\":\"php\",\"size\":2232,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/uuid library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Uuid\\\\Rfc4122;\\n\\nuse Ramsey\\\\Uuid\\\\Uuid;\\n\\n\/**\\n * Provides common functionality for handling the version, as defined by RFC 9562 (formerly RFC 4122)\\n *\\n * @immutable\\n *\/\\ntrait VersionTrait\\n{\\n    \/**\\n     * Returns the UUID version\\n     *\\n     * The version number describes how the UUID was generated and has the following meaning:\\n     *\\n     * 1. Gregorian time UUID\\n     * 2. DCE security UUID\\n     * 3. Name-based UUID hashed with MD5\\n     * 4. Randomly generated UUID\\n     * 5. Name-based UUID hashed with SHA-1\\n     * 6. Reordered Gregorian time UUID\\n     * 7. Unix Epoch time UUID\\n     * 8. Custom format UUID\\n     *\\n     * This returns `null` if the UUID is not an RFC 9562 (formerly RFC 4122) variant, since the version is only\\n     * meaningful for this variant.\\n     *\\n     * @link https:\/\/www.rfc-editor.org\/rfc\/rfc9562#section-4.2 RFC 9562, 4.2. Version Field\\n     *\\n     * @pure\\n     *\/\\n    abstract public function getVersion(): ?int;\\n\\n    \/**\\n     * Returns true if these fields represent a max UUID\\n     *\/\\n    abstract public function isMax(): bool;\\n\\n    \/**\\n     * Returns true if these fields represent a nil UUID\\n     *\/\\n    abstract public function isNil(): bool;\\n\\n    \/**\\n     * Returns true if the version matches one of those defined by RFC 9562 (formerly RFC 4122)\\n     *\\n     * @return bool True if the UUID version is valid, false otherwise\\n     *\/\\n    private function isCorrectVersion(): bool\\n    {\\n        if ($this->isNil() || $this->isMax()) {\\n            return true;\\n        }\\n\\n        return match ($this->getVersion()) {\\n            Uuid::UUID_TYPE_TIME, Uuid::UUID_TYPE_DCE_SECURITY,\\n                Uuid::UUID_TYPE_HASH_MD5, Uuid::UUID_TYPE_RANDOM,\\n                Uuid::UUID_TYPE_HASH_SHA1, Uuid::UUID_TYPE_REORDERED_TIME,\\n                Uuid::UUID_TYPE_UNIX_TIME, Uuid::UUID_TYPE_CUSTOM => true,\\n            default => false,\\n        };\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/collection\/SECURITY.md\",\"ext\":\"md\",\"size\":7684,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<!--\\n    This policy template was created using the HackerOne Policy Builder [1],\\n    with guidance from the National Telecommunications and Information\\n    Administration Coordinated Vulnerability Disclosure Template [2].\\n -->\\n\\n# Vulnerability Disclosure Policy (VDP)\\n\\n## Brand Promise\\n\\n<!--\\n    This is your brand promise. Its objective is to \\\"demonstrate a clear, good\\n    faith commitment to customers and other stakeholders potentially impacted by\\n    security vulnerabilities\\\" [2].\\n-->\\n\\nKeeping user information safe and secure is a top priority, and we welcome the\\ncontribution of external security researchers.\\n\\n## Scope\\n\\n<!--\\n    This is your initial scope. It tells vulnerability finders and reporters\\n    \\\"which systems and capabilities are 'fair game' versus 'off limits'\\\" [2].\\n    For software packages, this is often a list of currently maintained versions\\n    of the package.\\n-->\\n\\nIf you believe you've found a security issue in software that is maintained in\\nthis repository, we encourage you to notify us.\\n\\n| Version | In scope | Source code |\\n| ------- | :------: | ----------- |\\n| latest  | \u2705        | https:\/\/github.com\/ramsey\/collection |\\n\\n## How to Submit a Report\\n\\n<!--\\n    This is your communication process. It tells security researchers how to\\n    contact you to report a vulnerability. It may be a link to a web form that\\n    uses HTTPS for secure communication, or it may be an email address.\\n    Optionally, you may choose to include a PGP public key, so that researchers\\n    may send you encrypted messages.\\n-->\\n\\nTo submit a vulnerability report, please contact us at security@ramsey.dev.\\nYour submission will be reviewed and validated by a member of our team.\\n\\n## Safe Harbor\\n\\n<!--\\n    This section assures vulnerability finders and reporters that they will\\n    receive good faith responses to their good faith acts. In other words,\\n    \\\"we will not take legal action if...\\\" [2].\\n-->\\n\\nWe support safe harbor for security researchers who:\\n\\n* Make a good faith effort to avoid privacy violations, destruction of data, and\\n  interruption or degradation of our services.\\n* Only interact with accounts you own or with explicit permission of the account\\n  holder. If you do encounter Personally Identifiable Information (PII) contact\\n  us immediately, do not proceed with access, and immediately purge any local\\n  information.\\n* Provide us with a reasonable amount of time to resolve vulnerabilities prior\\n  to any disclosure to the public or a third party.\\n\\nWe will consider activities conducted consistent with this policy to constitute\\n\\\"authorized\\\" conduct and will not pursue civil action or initiate a complaint to\\nlaw enforcement. We will help to the extent we can if legal action is initiated\\nby a third party against you.\\n\\nPlease submit a report to us before engaging in conduct that may be inconsistent\\nwith or unaddressed by this policy.\\n\\n## Preferences\\n\\n<!--\\n    The preferences section sets expectations based on priority and submission\\n    volume, rather than legal objection or restriction [2].\\n\\n    According to the NTIA [2]:\\n\\n        This section is a living document that sets expectations for preferences\\n        and priorities, typically maintained by the support and engineering\\n        team. This can outline classes of vulnerabilities, reporting style\\n        (crash dumps, CVSS scoring, proof-of-concept, etc.), tools, etc. Too\\n        many preferences can set the wrong tone or make reporting findings\\n        difficult to navigate. This section also sets expectations to the\\n        researcher community for what types of issues are considered important\\n        or not.\\n-->\\n\\n* Please provide detailed reports with reproducible steps and a clearly defined\\n  impact.\\n* Include the version number of the vulnerable package in your report\\n* Social engineering (e.g. phishing, vishing, smishing) is prohibited.\\n\\n<!--\\n    References\\n\\n    [1] HackerOne. Policy builder. Retrieved from https:\/\/hackerone.com\/policy-builder\/\\n\\n    [2] NTIA Safety Working Group. 2016. \\\"Early stage\\\" coordinated vulnerability\\n    disclosure template: Version 1.1. (15 December 2016). Retrieved from\\n    https:\/\/www.ntia.doc.gov\/files\/ntia\/publications\/ntia_vuln_disclosure_early_stage_template.pdf\\n-->\\n\\n## Encryption Key for security@ramsey.dev\\n\\nFor increased privacy when reporting sensitive issues, you may encrypt your\\nmessage using the following public key:\\n\\n```\\n-----BEGIN PGP PUBLIC KEY BLOCK-----\\n\\nmQINBF+Z9gEBEACbT\/pIx8RR0K18t8Z2rDnmEV44YdT7HNsMdq+D6SAlx8UUb6AU\\njGIbV9dgBgGNtOLU1pxloaJwL9bWIRbj+X\/Qb2WNIP\/\/Vz1Y40ox1dSpfCUrizXx\\nkb4p58Xml0PsB8dg3b4RDUgKwGC37ne5xmDnigyJPbiB2XJ6Xc46oPCjh86XROTK\\nwEBB2lY67ClBlSlvC2V9KmbTboRQkLdQDhOaUosMb99zRb0EWqDLaFkZVjY5HI7i\\n0pTveE6dI12NfHhTwKjZ5pUiAZQGlKA6J1dMjY2unxHZkQj5MlMfrLSyJHZxccdJ\\nxD94T6OTcTHt\/XmMpI2AObpewZDdChDQmcYDZXGfAhFoJmbvXsmLMGXKgzKoZ\/ls\\nRmLsQhh7+\/r8E+Pn5r+A6Hh4uAc14ApyEP0ckKeIXw1C6pepHM4E8TEXVr\/IA6K\/\\nz6jlHORixIFX7iNOnfHh+qwOgZw40D6JnBfEzjFi+T2Cy+JzN2uy7I8UnecTMGo3\\n5t6astPy6xcH6kZYzFTV7XERR6LIIVyLAiMFd8kF5MbJ8N5ElRFsFHPW+82N2HDX\\nc60iSaTB85k6R6xd8JIKDiaKE4sSuw2wHFCKq33d\/GamYezp1wO+bVUQg88efljC\\n2JNFyD+vl30josqhw1HcmbE1TP3DlYeIL5jQOlxCMsgai6JtTfHFM\/5MYwARAQAB\\ntBNzZWN1cml0eUByYW1zZXkuZGV2iQJUBBMBCAA+FiEE4drPD+\/ofZ570fAYq0bv\\nvXQCywIFAl+Z9gECGwMFCQeGH4AFCwkIBwIGFQoJCAsCBBYCAwECHgECF4AACgkQ\\nq0bvvXQCywIkEA\/\/Qcwv8MtTCy01LHZd9c7VslwhNdXQDYymcTyjcYw8x7O22m4B\\n3hXE6vqAplFhVxxkqXB2ef0tQuzxhPHNJgkCE4Wq4i+V6qGpaSVHQT2W6DN\/NIhL\\nvS8OdScc6zddmIbIkSrzVVAtjwehFNEIrX3DnbbbK+Iku7vsKT5EclOluIsjlYoX\\ngoW8IeReyDBqOe2H3hoCGw6EA0D\/NYV2bJnfy53rXVIyarsXXeOLp7eNEH6Td7aW\\nPVSrMZJe1t+knrEGnEdrXWzlg4lCJJCtemGv+pKBUomnyISXSdqyoRCCzvQjqyig\\n2kRebUX8BXPW33p4OXPj9sIboUOjZwormWwqqbFMO+J4TiVCUoEoheI7emPFRcNN\\nQtPJrjbY1++OznBc0GRpfeUkGoU1cbRl1bnepnFIZMTDLkrVW6I1Y4q8ZVwX3BkE\\nN81ctFrRpHBlU36EdHvjPQmGtuiL77Qq3fWmMv7yTvK1wHJAXfEb0ZJWHZCbck3w\\nl0CVq0Z+UUAOM8Rp1N0N8m92xtapav0qCFU9qzf2J5qX6GRmWv+d29wPgFHzDWBm\\nnnrYYIA4wJLx00U6SMcVBSnNe91B+RfGY5XQhbWPjQQecOGCSDsxaFAq2MeOVJyZ\\nbIjLYfG9GxoLKr5R7oLRJvZI4nKKBc1Kci\/crZbdiSdQhSQGlDz88F1OHeCIdQQQ\\nEQgAHRYhBOhdAxHd+lus86YQ57Atl5icjAcbBQJfmfdIAAoJELAtl5icjAcbFVcA\\n\/1LqB3ZjsnXDAvvAXZVjSPqofSlpMLeRQP6IM\/A9Odq0AQCZrtZc1knOMGEcjppK\\nRk+sy\/R0Mshy8TDuaZIRgh2Ux7kCDQRfmfYBARAAmchKzzVz7IaEq7PnZDb3szQs\\nT\/+E9F3m39yOpV4fEB1YzObonFakXNT7Gw2tZEx0eitUMqQ\/13jjfu3UdzlKl2bR\\nqA8LrSQRhB+PTC9A1XvwxCUYhhjGiLzJ9CZL6hBQB43qHOmE9XJPme90geLsF+gK\\nu39Waj1SNWzwGg+Gy1Gl5f2AJoDTxznreCuFGj+Vfaczt\/hlfgqpOdb9jsmdoE7t\\n3DSWppA9dRHWwQSgE6J28rR4QySBcqyXS6IMykqaJn7Z26yNIaITLnHCZOSY8zhP\\nha7GFsN549EOCgECbrnPt9dmI2+hQE0RO0e7SOBNsIf5sz\/i7urhwuj0CbOqhjc2\\nX1AEVNFCVcb6HPi\/AWefdFCRu0gaWQxn5g+9nkq5slEgvzCCiKYzaBIcr8qR6Hb4\\nFaOPVPxO8vndRouq57Ws8XpAwbPttioFuCqF4u9K+tK\/8e2\/R8QgRYJsE3Cz\/Fu8\\n+pZFpMnqbDEbK3DL3ss+1ed1sky+mDV8qXXeI33XW5hMFnk1JWshUjHNlQmE6ftC\\nU0xSTMVUtwJhzH2zDp8lEdu7qi3EsNULOl68ozDr6soWAvCbHPeTdTOnFySGCleG\\n\/3TonsoZJs\/sSPPJnxFQ1DtgQL6EbhIwa0ZwU4eKYVHZ9tjxuMX3teFzRvOrJjgs\\n+ywGlsIURtEckT5Y6nMAEQEAAYkCPAQYAQgAJhYhBOHazw\/v6H2ee9HwGKtG7710\\nAssCBQJfmfYBAhsMBQkHhh+AAAoJEKtG7710AssC8NcP\/iDAcy1aZFvkA0EbZ85p\\ni7\/+ywtE\/1wF4U4\/9OuLcoskqGGnl1pJNPooMOSBCfreoTB8HimT0Fln0CoaOm4Q\\npScNq39JXmf4VxauqUJVARByP6zUfgYarqoaZNeuFF0S4AZJ2HhGzaQPjDz1uKVM\\nPE6tQSgQkFzdZ9AtRA4vElTH6yRAgmepUsOihk0b0gUtVnwtRYZ8e0Qt3ie97a73\\nDxLgAgedFRUbLRYiT0vNaYbainBsLWKpN\/T8odwIg\/smP0Khjp\/ckV60cZTdBiPR\\nszBTPJESMUTu0VPntc4gWwGsmhZJg\/Tt\/qP08XYo3VxNYBegyuWwNR66zDWvwvGH\\nmuMv5UchuDxp6Rt3JkIO4voMT1JSjWy9p8krkPEE4V6PxAagLjdZSkt92wVLiK5x\\ny5gNrtPhU45YdRAKHr36OvJBJQ42CDaZ6nzrzghcIp9CZ7ANHrI+QLRM\/csz+AGA\\nszSp6S4mc1lnxxfbOhPPpebZPn0nIAXoZnnoVKdrxBVedPQHT59ZFvKTQ9Fs7gd3\\nsYNuc7tJGFGC2CxBH4ANDpOQkc5q9JJ1HSGrXU3juxIiRgfA26Q22S9c71dXjElw\\nRi584QH+bL6kkYmm8xpKF6TVwhwu5xx\/jBPrbWqFrtbvLNrnfPoapTihBfdIhkT6\\nnmgawbBHA02D5xEqB5SU3WJu\\n=eJNx\\n-----END PGP PUBLIC KEY BLOCK-----\\n```\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/collection\/src\/Tool\/ValueToStringTrait.php\",\"ext\":\"php\",\"size\":2311,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/collection library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Collection\\\\Tool;\\n\\nuse DateTimeInterface;\\n\\nuse function assert;\\nuse function get_resource_type;\\nuse function is_array;\\nuse function is_bool;\\nuse function is_callable;\\nuse function is_object;\\nuse function is_resource;\\nuse function is_scalar;\\n\\n\/**\\n * Provides functionality to express a value as string\\n *\/\\ntrait ValueToStringTrait\\n{\\n    \/**\\n     * Returns a string representation of the value.\\n     *\\n     * - null value: `'NULL'`\\n     * - boolean: `'TRUE'`, `'FALSE'`\\n     * - array: `'Array'`\\n     * - scalar: converted-value\\n     * - resource: `'(type resource #number)'`\\n     * - object with `__toString()`: result of `__toString()`\\n     * - object DateTime: ISO 8601 date\\n     * - object: `'(className Object)'`\\n     * - anonymous function: same as object\\n     *\\n     * @param mixed $value the value to return as a string.\\n     *\/\\n    protected function toolValueToString(mixed $value): string\\n    {\\n        \/\/ null\\n        if ($value === null) {\\n            return 'NULL';\\n        }\\n\\n        \/\/ boolean constants\\n        if (is_bool($value)) {\\n            return $value ? 'TRUE' : 'FALSE';\\n        }\\n\\n        \/\/ array\\n        if (is_array($value)) {\\n            return 'Array';\\n        }\\n\\n        \/\/ scalar types (integer, float, string)\\n        if (is_scalar($value)) {\\n            return (string) $value;\\n        }\\n\\n        \/\/ resource\\n        if (is_resource($value)) {\\n            return '(' . get_resource_type($value) . ' resource #' . (int) $value . ')';\\n        }\\n\\n        \/\/ From here, $value should be an object.\\n        assert(is_object($value));\\n\\n        \/\/ __toString() is implemented\\n        if (is_callable([$value, '__toString'])) {\\n            \/** @var string *\/\\n            return $value->__toString();\\n        }\\n\\n        \/\/ object of type \\\\DateTime\\n        if ($value instanceof DateTimeInterface) {\\n            return $value->format('c');\\n        }\\n\\n        \/\/ unknown type\\n        return '(' . $value::class . ' Object)';\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/collection\/src\/Tool\/TypeTrait.php\",\"ext\":\"php\",\"size\":1589,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/collection library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Collection\\\\Tool;\\n\\nuse function is_array;\\nuse function is_bool;\\nuse function is_callable;\\nuse function is_float;\\nuse function is_int;\\nuse function is_numeric;\\nuse function is_object;\\nuse function is_resource;\\nuse function is_scalar;\\nuse function is_string;\\n\\n\/**\\n * Provides functionality to check values for specific types.\\n *\/\\ntrait TypeTrait\\n{\\n    \/**\\n     * Returns `true` if value is of the specified type.\\n     *\\n     * @param string $type The type to check the value against.\\n     * @param mixed $value The value to check.\\n     *\/\\n    protected function checkType(string $type, mixed $value): bool\\n    {\\n        return match ($type) {\\n            'array' => is_array($value),\\n            'bool', 'boolean' => is_bool($value),\\n            'callable' => is_callable($value),\\n            'float', 'double' => is_float($value),\\n            'int', 'integer' => is_int($value),\\n            'null' => $value === null,\\n            'numeric' => is_numeric($value),\\n            'object' => is_object($value),\\n            'resource' => is_resource($value),\\n            'scalar' => is_scalar($value),\\n            'string' => is_string($value),\\n            'mixed' => true,\\n            default => $value instanceof $type,\\n        };\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/collection\/src\/Tool\/ValueExtractorTrait.php\",\"ext\":\"php\",\"size\":3118,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/collection library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Collection\\\\Tool;\\n\\nuse Ramsey\\\\Collection\\\\Exception\\\\InvalidPropertyOrMethod;\\nuse Ramsey\\\\Collection\\\\Exception\\\\UnsupportedOperationException;\\nuse ReflectionProperty;\\n\\nuse function is_array;\\nuse function is_object;\\nuse function method_exists;\\nuse function property_exists;\\nuse function sprintf;\\n\\n\/**\\n * Provides functionality to extract the value of a property or method from an object.\\n *\/\\ntrait ValueExtractorTrait\\n{\\n    \/**\\n     * Returns the type associated with this collection.\\n     *\/\\n    abstract public function getType(): string;\\n\\n    \/**\\n     * Extracts the value of the given property, method, or array key from the\\n     * element.\\n     *\\n     * If `$propertyOrMethod` is `null`, we return the element as-is.\\n     *\\n     * @param mixed $element The element to extract the value from.\\n     * @param string | null $propertyOrMethod The property or method for which the\\n     *     value should be extracted.\\n     *\\n     * @return mixed the value extracted from the specified property, method,\\n     *     or array key, or the element itself.\\n     *\\n     * @throws InvalidPropertyOrMethod\\n     * @throws UnsupportedOperationException\\n     *\/\\n    protected function extractValue(mixed $element, ?string $propertyOrMethod): mixed\\n    {\\n        if ($propertyOrMethod === null) {\\n            return $element;\\n        }\\n\\n        if (!is_object($element) && !is_array($element)) {\\n            throw new UnsupportedOperationException(sprintf(\\n                'The collection type \\\"%s\\\" does not support the $propertyOrMethod parameter',\\n                $this->getType(),\\n            ));\\n        }\\n\\n        if (is_array($element)) {\\n            return $element[$propertyOrMethod] ?? throw new InvalidPropertyOrMethod(sprintf(\\n                'Key or index \\\"%s\\\" not found in collection elements',\\n                $propertyOrMethod,\\n            ));\\n        }\\n\\n        if (property_exists($element, $propertyOrMethod) && method_exists($element, $propertyOrMethod)) {\\n            $reflectionProperty = new ReflectionProperty($element, $propertyOrMethod);\\n            if ($reflectionProperty->isPublic()) {\\n                return $element->$propertyOrMethod;\\n            }\\n\\n            return $element->{$propertyOrMethod}();\\n        }\\n\\n        if (property_exists($element, $propertyOrMethod)) {\\n            return $element->$propertyOrMethod;\\n        }\\n\\n        if (method_exists($element, $propertyOrMethod)) {\\n            return $element->{$propertyOrMethod}();\\n        }\\n\\n        if (isset($element->$propertyOrMethod)) {\\n            return $element->$propertyOrMethod;\\n        }\\n\\n        throw new InvalidPropertyOrMethod(sprintf(\\n            'Method or property \\\"%s\\\" not defined in %s',\\n            $propertyOrMethod,\\n            $element::class,\\n        ));\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/collection\/src\/AbstractArray.php\",\"ext\":\"php\",\"size\":4371,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/collection library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Collection;\\n\\nuse ArrayIterator;\\nuse Traversable;\\n\\nuse function count;\\n\\n\/**\\n * This class provides a basic implementation of `ArrayInterface`, to minimize\\n * the effort required to implement this interface.\\n *\\n * @template T\\n * @implements ArrayInterface<T>\\n *\/\\nabstract class AbstractArray implements ArrayInterface\\n{\\n    \/**\\n     * The items of this array.\\n     *\\n     * @var array<array-key, T>\\n     *\/\\n    protected array $data = [];\\n\\n    \/**\\n     * Constructs a new array object.\\n     *\\n     * @param array<array-key, T> $data The initial items to add to this array.\\n     *\/\\n    public function __construct(array $data = [])\\n    {\\n        \/\/ Invoke offsetSet() for each value added; in this way, subclasses\\n        \/\/ may provide additional logic about values added to the array object.\\n        foreach ($data as $key => $value) {\\n            $this[$key] = $value;\\n        }\\n    }\\n\\n    \/**\\n     * Returns an iterator for this array.\\n     *\\n     * @link http:\/\/php.net\/manual\/en\/iteratoraggregate.getiterator.php IteratorAggregate::getIterator()\\n     *\\n     * @return Traversable<array-key, T>\\n     *\/\\n    public function getIterator(): Traversable\\n    {\\n        return new ArrayIterator($this->data);\\n    }\\n\\n    \/**\\n     * Returns `true` if the given offset exists in this array.\\n     *\\n     * @link http:\/\/php.net\/manual\/en\/arrayaccess.offsetexists.php ArrayAccess::offsetExists()\\n     *\\n     * @param array-key $offset The offset to check.\\n     *\/\\n    public function offsetExists(mixed $offset): bool\\n    {\\n        return isset($this->data[$offset]);\\n    }\\n\\n    \/**\\n     * Returns the value at the specified offset.\\n     *\\n     * @link http:\/\/php.net\/manual\/en\/arrayaccess.offsetget.php ArrayAccess::offsetGet()\\n     *\\n     * @param array-key $offset The offset for which a value should be returned.\\n     *\\n     * @return T the value stored at the offset, or null if the offset\\n     *     does not exist.\\n     *\/\\n    public function offsetGet(mixed $offset): mixed\\n    {\\n        return $this->data[$offset];\\n    }\\n\\n    \/**\\n     * Sets the given value to the given offset in the array.\\n     *\\n     * @link http:\/\/php.net\/manual\/en\/arrayaccess.offsetset.php ArrayAccess::offsetSet()\\n     *\\n     * @param array-key | null $offset The offset to set. If `null`, the value\\n     *     may be set at a numerically-indexed offset.\\n     * @param T $value The value to set at the given offset.\\n     *\/\\n    public function offsetSet(mixed $offset, mixed $value): void\\n    {\\n        if ($offset === null) {\\n            $this->data[] = $value;\\n        } else {\\n            $this->data[$offset] = $value;\\n        }\\n    }\\n\\n    \/**\\n     * Removes the given offset and its value from the array.\\n     *\\n     * @link http:\/\/php.net\/manual\/en\/arrayaccess.offsetunset.php ArrayAccess::offsetUnset()\\n     *\\n     * @param array-key $offset The offset to remove from the array.\\n     *\/\\n    public function offsetUnset(mixed $offset): void\\n    {\\n        unset($this->data[$offset]);\\n    }\\n\\n    \/**\\n     * Returns data suitable for PHP serialization.\\n     *\\n     * @link https:\/\/www.php.net\/manual\/en\/language.oop5.magic.php#language.oop5.magic.serialize\\n     * @link https:\/\/www.php.net\/serialize\\n     *\\n     * @return array<array-key, T>\\n     *\/\\n    public function __serialize(): array\\n    {\\n        return $this->data;\\n    }\\n\\n    \/**\\n     * Adds unserialized data to the object.\\n     *\\n     * @param array<array-key, T> $data\\n     *\/\\n    public function __unserialize(array $data): void\\n    {\\n        $this->data = $data;\\n    }\\n\\n    \/**\\n     * Returns the number of items in this array.\\n     *\\n     * @link http:\/\/php.net\/manual\/en\/countable.count.php Countable::count()\\n     *\/\\n    public function count(): int\\n    {\\n        return count($this->data);\\n    }\\n\\n    public function clear(): void\\n    {\\n        $this->data = [];\\n    }\\n\\n    \/**\\n     * @inheritDoc\\n     *\/\\n    public function toArray(): array\\n    {\\n        return $this->data;\\n    }\\n\\n    public function isEmpty(): bool\\n    {\\n        return $this->data === [];\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/collection\/src\/Queue.php\",\"ext\":\"php\",\"size\":3661,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/collection library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Collection;\\n\\nuse Ramsey\\\\Collection\\\\Exception\\\\InvalidArgumentException;\\nuse Ramsey\\\\Collection\\\\Exception\\\\NoSuchElementException;\\nuse Ramsey\\\\Collection\\\\Tool\\\\TypeTrait;\\nuse Ramsey\\\\Collection\\\\Tool\\\\ValueToStringTrait;\\n\\nuse function array_key_first;\\n\\n\/**\\n * This class provides a basic implementation of `QueueInterface`, to minimize\\n * the effort required to implement this interface.\\n *\\n * @template T\\n * @extends AbstractArray<T>\\n * @implements QueueInterface<T>\\n *\/\\nclass Queue extends AbstractArray implements QueueInterface\\n{\\n    use TypeTrait;\\n    use ValueToStringTrait;\\n\\n    \/**\\n     * Constructs a queue object of the specified type, optionally with the\\n     * specified data.\\n     *\\n     * @param string $queueType The type or class name associated with this queue.\\n     * @param array<array-key, T> $data The initial items to store in the queue.\\n     *\/\\n    public function __construct(private readonly string $queueType, array $data = [])\\n    {\\n        parent::__construct($data);\\n    }\\n\\n    \/**\\n     * {@inheritDoc}\\n     *\\n     * Since arbitrary offsets may not be manipulated in a queue, this method\\n     * serves only to fulfill the `ArrayAccess` interface requirements. It is\\n     * invoked by other operations when adding values to the queue.\\n     *\\n     * @throws InvalidArgumentException if $value is of the wrong type.\\n     *\/\\n    public function offsetSet(mixed $offset, mixed $value): void\\n    {\\n        if ($this->checkType($this->getType(), $value) === false) {\\n            throw new InvalidArgumentException(\\n                'Value must be of type ' . $this->getType() . '; value is '\\n                . $this->toolValueToString($value),\\n            );\\n        }\\n\\n        $this->data[] = $value;\\n    }\\n\\n    \/**\\n     * @throws InvalidArgumentException if $value is of the wrong type.\\n     *\/\\n    public function add(mixed $element): bool\\n    {\\n        $this[] = $element;\\n\\n        return true;\\n    }\\n\\n    \/**\\n     * @return T\\n     *\\n     * @throws NoSuchElementException if this queue is empty.\\n     *\/\\n    public function element(): mixed\\n    {\\n        return $this->peek() ?? throw new NoSuchElementException(\\n            'Can\\\\'t return element from Queue. Queue is empty.',\\n        );\\n    }\\n\\n    public function offer(mixed $element): bool\\n    {\\n        try {\\n            return $this->add($element);\\n        } catch (InvalidArgumentException) {\\n            return false;\\n        }\\n    }\\n\\n    \/**\\n     * @return T | null\\n     *\/\\n    public function peek(): mixed\\n    {\\n        $index = array_key_first($this->data);\\n\\n        if ($index === null) {\\n            return null;\\n        }\\n\\n        return $this[$index];\\n    }\\n\\n    \/**\\n     * @return T | null\\n     *\/\\n    public function poll(): mixed\\n    {\\n        $index = array_key_first($this->data);\\n\\n        if ($index === null) {\\n            return null;\\n        }\\n\\n        $head = $this[$index];\\n        unset($this[$index]);\\n\\n        return $head;\\n    }\\n\\n    \/**\\n     * @return T\\n     *\\n     * @throws NoSuchElementException if this queue is empty.\\n     *\/\\n    public function remove(): mixed\\n    {\\n        return $this->poll() ?? throw new NoSuchElementException(\\n            'Can\\\\'t return element from Queue. Queue is empty.',\\n        );\\n    }\\n\\n    public function getType(): string\\n    {\\n        return $this->queueType;\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/collection\/src\/Set.php\",\"ext\":\"php\",\"size\":1570,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/collection library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Collection;\\n\\n\/**\\n * A set is a collection that contains no duplicate elements.\\n *\\n * Great care must be exercised if mutable objects are used as set elements.\\n * The behavior of a set is not specified if the value of an object is changed\\n * in a manner that affects equals comparisons while the object is an element in\\n * the set.\\n *\\n * Example usage:\\n *\\n * ```\\n * $foo = new \\\\My\\\\Foo();\\n * $set = new Set(\\\\My\\\\Foo::class);\\n *\\n * $set->add($foo); \/\/ returns TRUE, the element doesn't exist\\n * $set->add($foo); \/\/ returns FALSE, the element already exists\\n *\\n * $bar = new \\\\My\\\\Foo();\\n * $set->add($bar); \/\/ returns TRUE, $bar !== $foo\\n * ```\\n *\\n * @template T\\n * @extends AbstractSet<T>\\n *\/\\nclass Set extends AbstractSet\\n{\\n    \/**\\n     * Constructs a set object of the specified type, optionally with the\\n     * specified data.\\n     *\\n     * @param string $setType The type or class name associated with this set.\\n     * @param array<array-key, T> $data The initial items to store in the set.\\n     *\/\\n    public function __construct(private readonly string $setType, array $data = [])\\n    {\\n        parent::__construct($data);\\n    }\\n\\n    public function getType(): string\\n    {\\n        return $this->setType;\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/collection\/src\/DoubleEndedQueue.php\",\"ext\":\"php\",\"size\":4288,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/collection library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Collection;\\n\\nuse Ramsey\\\\Collection\\\\Exception\\\\InvalidArgumentException;\\nuse Ramsey\\\\Collection\\\\Exception\\\\NoSuchElementException;\\n\\nuse function array_key_last;\\nuse function array_pop;\\nuse function array_unshift;\\n\\n\/**\\n * This class provides a basic implementation of `DoubleEndedQueueInterface`, to\\n * minimize the effort required to implement this interface.\\n *\\n * @template T\\n * @extends Queue<T>\\n * @implements DoubleEndedQueueInterface<T>\\n *\/\\nclass DoubleEndedQueue extends Queue implements DoubleEndedQueueInterface\\n{\\n    \/**\\n     * Constructs a double-ended queue (dequeue) object of the specified type,\\n     * optionally with the specified data.\\n     *\\n     * @param string $queueType The type or class name associated with this dequeue.\\n     * @param array<array-key, T> $data The initial items to store in the dequeue.\\n     *\/\\n    public function __construct(private readonly string $queueType, array $data = [])\\n    {\\n        parent::__construct($this->queueType, $data);\\n    }\\n\\n    \/**\\n     * @throws InvalidArgumentException if $element is of the wrong type\\n     *\/\\n    public function addFirst(mixed $element): bool\\n    {\\n        if ($this->checkType($this->getType(), $element) === false) {\\n            throw new InvalidArgumentException(\\n                'Value must be of type ' . $this->getType() . '; value is '\\n                . $this->toolValueToString($element),\\n            );\\n        }\\n\\n        array_unshift($this->data, $element);\\n\\n        return true;\\n    }\\n\\n    \/**\\n     * @throws InvalidArgumentException if $element is of the wrong type\\n     *\/\\n    public function addLast(mixed $element): bool\\n    {\\n        return $this->add($element);\\n    }\\n\\n    public function offerFirst(mixed $element): bool\\n    {\\n        try {\\n            return $this->addFirst($element);\\n        } catch (InvalidArgumentException) {\\n            return false;\\n        }\\n    }\\n\\n    public function offerLast(mixed $element): bool\\n    {\\n        return $this->offer($element);\\n    }\\n\\n    \/**\\n     * @return T the first element in this queue.\\n     *\\n     * @throws NoSuchElementException if the queue is empty\\n     *\/\\n    public function removeFirst(): mixed\\n    {\\n        return $this->remove();\\n    }\\n\\n    \/**\\n     * @return T the last element in this queue.\\n     *\\n     * @throws NoSuchElementException if this queue is empty.\\n     *\/\\n    public function removeLast(): mixed\\n    {\\n        return $this->pollLast() ?? throw new NoSuchElementException(\\n            'Can\\\\'t return element from Queue. Queue is empty.',\\n        );\\n    }\\n\\n    \/**\\n     * @return T | null the head of this queue, or `null` if this queue is empty.\\n     *\/\\n    public function pollFirst(): mixed\\n    {\\n        return $this->poll();\\n    }\\n\\n    \/**\\n     * @return T | null the tail of this queue, or `null` if this queue is empty.\\n     *\/\\n    public function pollLast(): mixed\\n    {\\n        return array_pop($this->data);\\n    }\\n\\n    \/**\\n     * @return T the head of this queue.\\n     *\\n     * @throws NoSuchElementException if this queue is empty.\\n     *\/\\n    public function firstElement(): mixed\\n    {\\n        return $this->element();\\n    }\\n\\n    \/**\\n     * @return T the tail of this queue.\\n     *\\n     * @throws NoSuchElementException if this queue is empty.\\n     *\/\\n    public function lastElement(): mixed\\n    {\\n        return $this->peekLast() ?? throw new NoSuchElementException(\\n            'Can\\\\'t return element from Queue. Queue is empty.',\\n        );\\n    }\\n\\n    \/**\\n     * @return T | null the head of this queue, or `null` if this queue is empty.\\n     *\/\\n    public function peekFirst(): mixed\\n    {\\n        return $this->peek();\\n    }\\n\\n    \/**\\n     * @return T | null the tail of this queue, or `null` if this queue is empty.\\n     *\/\\n    public function peekLast(): mixed\\n    {\\n        $lastIndex = array_key_last($this->data);\\n\\n        if ($lastIndex === null) {\\n            return null;\\n        }\\n\\n        return $this->data[$lastIndex];\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/collection\/src\/QueueInterface.php\",\"ext\":\"php\",\"size\":7389,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/collection library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Collection;\\n\\nuse Ramsey\\\\Collection\\\\Exception\\\\NoSuchElementException;\\nuse RuntimeException;\\n\\n\/**\\n * A queue is a collection in which the entities in the collection are kept in\\n * order.\\n *\\n * The principal operations on the queue are the addition of entities to the end\\n * (tail), also known as *enqueue*, and removal of entities from the front\\n * (head), also known as *dequeue*. This makes the queue a first-in-first-out\\n * (FIFO) data structure.\\n *\\n * Besides basic array operations, queues provide additional insertion,\\n * extraction, and inspection operations. Each of these methods exists in two\\n * forms: one throws an exception if the operation fails, the other returns a\\n * special value (either `null` or `false`, depending on the operation). The\\n * latter form of the insert operation is designed specifically for use with\\n * capacity-restricted `QueueInterface` implementations; in most\\n * implementations, insert operations cannot fail.\\n *\\n * <table>\\n * <caption>Summary of QueueInterface methods<\/caption>\\n * <thead>\\n * <tr>\\n * <td><\/td>\\n * <td><em>Throws exception<\/em><\/td>\\n * <td><em>Returns special value<\/em><\/td>\\n * <\/tr>\\n * <\/thead>\\n * <tbody>\\n * <tr>\\n * <th>Insert<\/th>\\n * <td><code>add()<\/code><\/td>\\n * <td><code>offer()<\/code><\/td>\\n * <\/tr>\\n * <tr>\\n * <th>Remove<\/th>\\n * <td><code>remove()<\/code><\/td>\\n * <td><code>poll()<\/code><\/td>\\n * <\/tr>\\n * <tr>\\n * <th>Examine<\/th>\\n * <td><code>element()<\/code><\/td>\\n * <td><code>peek()<\/code><\/td>\\n * <\/tr>\\n * <\/tbody>\\n * <\/table>\\n *\\n * Queues typically, but do not necessarily, order elements in a FIFO\\n * (first-in-first-out) manner. Among the exceptions are priority queues, which\\n * order elements according to a supplied comparator, or the elements' natural\\n * ordering, and LIFO queues (or stacks) which order the elements LIFO\\n * (last-in-first-out). Whatever the ordering used, the head of the queue is\\n * that element which would be removed by a call to remove() or poll(). In a\\n * FIFO queue, all new elements are inserted at the tail of the queue. Other\\n * kinds of queues may use different placement rules. Every `QueueInterface`\\n * implementation must specify its ordering properties.\\n *\\n * The `offer()` method inserts an element if possible, otherwise returning\\n * `false`. This differs from the `add()` method, which can fail to add an\\n * element only by throwing an unchecked exception. The `offer()` method is\\n * designed for use when failure is a normal, rather than exceptional\\n * occurrence, for example, in fixed-capacity (or \\\"bounded\\\") queues.\\n *\\n * The `remove()` and `poll()` methods remove and return the head of the queue.\\n * Exactly which element is removed from the queue is a function of the queue's\\n * ordering policy, which differs from implementation to implementation. The\\n * `remove()` and `poll()` methods differ only in their behavior when the queue\\n * is empty: the `remove()` method throws an exception, while the `poll()`\\n * method returns `null`.\\n *\\n * The `element()` and `peek()` methods return, but do not remove, the head of\\n * the queue.\\n *\\n * `QueueInterface` implementations generally do not allow insertion of `null`\\n * elements, although some implementations do not prohibit insertion of `null`.\\n * Even in the implementations that permit it, `null` should not be inserted\\n * into a queue, as `null` is also used as a special return value by the\\n * `poll()` method to indicate that the queue contains no elements.\\n *\\n * @template T\\n * @extends ArrayInterface<T>\\n *\/\\ninterface QueueInterface extends ArrayInterface\\n{\\n    \/**\\n     * Ensures that this queue contains the specified element (optional\\n     * operation).\\n     *\\n     * Returns `true` if this queue changed as a result of the call. (Returns\\n     * `false` if this queue does not permit duplicates and already contains the\\n     * specified element.)\\n     *\\n     * Queues that support this operation may place limitations on what elements\\n     * may be added to this queue. In particular, some queues will refuse to add\\n     * `null` elements, and others will impose restrictions on the type of\\n     * elements that may be added. Queue classes should clearly specify in their\\n     * documentation any restrictions on what elements may be added.\\n     *\\n     * If a queue refuses to add a particular element for any reason other than\\n     * that it already contains the element, it must throw an exception (rather\\n     * than returning `false`). This preserves the invariant that a queue always\\n     * contains the specified element after this call returns.\\n     *\\n     * @see self::offer()\\n     *\\n     * @param T $element The element to add to this queue.\\n     *\\n     * @return bool `true` if this queue changed as a result of the call.\\n     *\\n     * @throws RuntimeException if a queue refuses to add a particular element\\n     *     for any reason other than that it already contains the element.\\n     *     Implementations should use a more-specific exception that extends\\n     *     `\\\\RuntimeException`.\\n     *\/\\n    public function add(mixed $element): bool;\\n\\n    \/**\\n     * Retrieves, but does not remove, the head of this queue.\\n     *\\n     * This method differs from `peek()` only in that it throws an exception if\\n     * this queue is empty.\\n     *\\n     * @see self::peek()\\n     *\\n     * @return T the head of this queue.\\n     *\\n     * @throws NoSuchElementException if this queue is empty.\\n     *\/\\n    public function element(): mixed;\\n\\n    \/**\\n     * Inserts the specified element into this queue if it is possible to do so\\n     * immediately without violating capacity restrictions.\\n     *\\n     * When using a capacity-restricted queue, this method is generally\\n     * preferable to `add()`, which can fail to insert an element only by\\n     * throwing an exception.\\n     *\\n     * @see self::add()\\n     *\\n     * @param T $element The element to add to this queue.\\n     *\\n     * @return bool `true` if the element was added to this queue, else `false`.\\n     *\/\\n    public function offer(mixed $element): bool;\\n\\n    \/**\\n     * Retrieves, but does not remove, the head of this queue, or returns `null`\\n     * if this queue is empty.\\n     *\\n     * @see self::element()\\n     *\\n     * @return T | null the head of this queue, or `null` if this queue is empty.\\n     *\/\\n    public function peek(): mixed;\\n\\n    \/**\\n     * Retrieves and removes the head of this queue, or returns `null`\\n     * if this queue is empty.\\n     *\\n     * @see self::remove()\\n     *\\n     * @return T | null the head of this queue, or `null` if this queue is empty.\\n     *\/\\n    public function poll(): mixed;\\n\\n    \/**\\n     * Retrieves and removes the head of this queue.\\n     *\\n     * This method differs from `poll()` only in that it throws an exception if\\n     * this queue is empty.\\n     *\\n     * @see self::poll()\\n     *\\n     * @return T the head of this queue.\\n     *\\n     * @throws NoSuchElementException if this queue is empty.\\n     *\/\\n    public function remove(): mixed;\\n\\n    \/**\\n     * Returns the type associated with this queue.\\n     *\/\\n    public function getType(): string;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/collection\/src\/AbstractSet.php\",\"ext\":\"php\",\"size\":1431,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/collection library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Collection;\\n\\n\/**\\n * This class contains the basic implementation of a collection that does not\\n * allow duplicated values (a set), to minimize the effort required to implement\\n * this specific type of collection.\\n *\\n * @template T\\n * @extends AbstractCollection<T>\\n *\/\\nabstract class AbstractSet extends AbstractCollection\\n{\\n    public function add(mixed $element): bool\\n    {\\n        if ($this->contains($element)) {\\n            return false;\\n        }\\n\\n        \/\/ Call offsetSet() on the parent instead of add(), since calling\\n        \/\/ parent::add() will invoke $this->offsetSet(), which will call\\n        \/\/ $this->contains() a second time. This can cause performance issues\\n        \/\/ with extremely large collections. For more information, see\\n        \/\/ https:\/\/github.com\/ramsey\/collection\/issues\/68.\\n        parent::offsetSet(null, $element);\\n\\n        return true;\\n    }\\n\\n    public function offsetSet(mixed $offset, mixed $value): void\\n    {\\n        if ($this->contains($value)) {\\n            return;\\n        }\\n\\n        parent::offsetSet($offset, $value);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/collection\/src\/GenericArray.php\",\"ext\":\"php\",\"size\":512,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/collection library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Collection;\\n\\n\/**\\n * `GenericArray` represents a standard array object.\\n *\\n * @extends AbstractArray<mixed>\\n *\/\\nclass GenericArray extends AbstractArray\\n{\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/collection\/src\/Map\/TypedMap.php\",\"ext\":\"php\",\"size\":2808,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/collection library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Collection\\\\Map;\\n\\n\/**\\n * A `TypedMap` represents a map of elements where key and value are typed.\\n *\\n * Each element is identified by a key with defined type and a value of defined\\n * type. The keys of the map must be unique. The values on the map can be\\n * repeated but each with its own different key.\\n *\\n * The most common case is to use a string type key, but it's not limited to\\n * this type of keys.\\n *\\n * This is a direct implementation of `TypedMapInterface`, provided for the sake\\n * of convenience.\\n *\\n * Example usage:\\n *\\n * ```\\n * $map = new TypedMap('string', Foo::class);\\n * $map['x'] = new Foo();\\n * foreach ($map as $key => $value) {\\n *     \/\/ do something with $key, it will be a Foo::class\\n * }\\n *\\n * \/\/ this will throw an exception since key must be string\\n * $map[10] = new Foo();\\n *\\n * \/\/ this will throw an exception since value must be a Foo\\n * $map['bar'] = 'bar';\\n *\\n * \/\/ initialize map with contents\\n * $map = new TypedMap('string', Foo::class, [\\n *     new Foo(), new Foo(), new Foo()\\n * ]);\\n * ```\\n *\\n * It is preferable to subclass `AbstractTypedMap` to create your own typed map\\n * implementation:\\n *\\n * ```\\n * class FooTypedMap extends AbstractTypedMap\\n * {\\n *     public function getKeyType()\\n *     {\\n *         return 'int';\\n *     }\\n *\\n *     public function getValueType()\\n *     {\\n *          return Foo::class;\\n *     }\\n * }\\n * ```\\n *\\n * \u2026 but you also may use the `TypedMap` class:\\n *\\n * ```\\n * class FooTypedMap extends TypedMap\\n * {\\n *     public function __constructor(array $data = [])\\n *     {\\n *         parent::__construct('int', Foo::class, $data);\\n *     }\\n * }\\n * ```\\n *\\n * @template K of array-key\\n * @template T\\n * @extends AbstractTypedMap<K, T>\\n *\/\\nclass TypedMap extends AbstractTypedMap\\n{\\n    \/**\\n     * Constructs a map object of the specified key and value types,\\n     * optionally with the specified data.\\n     *\\n     * @param string $keyType The data type of the map's keys.\\n     * @param string $valueType The data type of the map's values.\\n     * @param array<K, T> $data The initial data to set for this map.\\n     *\/\\n    public function __construct(\\n        private readonly string $keyType,\\n        private readonly string $valueType,\\n        array $data = [],\\n    ) {\\n        parent::__construct($data);\\n    }\\n\\n    public function getKeyType(): string\\n    {\\n        return $this->keyType;\\n    }\\n\\n    public function getValueType(): string\\n    {\\n        return $this->valueType;\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/collection\/src\/Map\/AbstractMap.php\",\"ext\":\"php\",\"size\":5062,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/collection library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Collection\\\\Map;\\n\\nuse Ramsey\\\\Collection\\\\AbstractArray;\\nuse Ramsey\\\\Collection\\\\Exception\\\\InvalidArgumentException;\\nuse Traversable;\\n\\nuse function array_key_exists;\\nuse function array_keys;\\nuse function in_array;\\nuse function var_export;\\n\\n\/**\\n * This class provides a basic implementation of `MapInterface`, to minimize the\\n * effort required to implement this interface.\\n *\\n * @template K of array-key\\n * @template T\\n * @extends AbstractArray<T>\\n * @implements MapInterface<K, T>\\n *\/\\nabstract class AbstractMap extends AbstractArray implements MapInterface\\n{\\n    \/**\\n     * @param array<K, T> $data The initial items to add to this map.\\n     *\/\\n    public function __construct(array $data = [])\\n    {\\n        parent::__construct($data);\\n    }\\n\\n    \/**\\n     * @return Traversable<K, T>\\n     *\/\\n    public function getIterator(): Traversable\\n    {\\n        return parent::getIterator();\\n    }\\n\\n    \/**\\n     * @param K $offset The offset to set\\n     * @param T $value The value to set at the given offset.\\n     *\\n     * @inheritDoc\\n     *\/\\n    public function offsetSet(mixed $offset, mixed $value): void\\n    {\\n        if ($offset === null) {\\n            throw new InvalidArgumentException(\\n                'Map elements are key\/value pairs; a key must be provided for '\\n                . 'value ' . var_export($value, true),\\n            );\\n        }\\n\\n        $this->data[$offset] = $value;\\n    }\\n\\n    public function containsKey(int | string $key): bool\\n    {\\n        return array_key_exists($key, $this->data);\\n    }\\n\\n    public function containsValue(mixed $value): bool\\n    {\\n        return in_array($value, $this->data, true);\\n    }\\n\\n    \/**\\n     * @inheritDoc\\n     *\/\\n    public function keys(): array\\n    {\\n        \/** @var list<K> *\/\\n        return array_keys($this->data);\\n    }\\n\\n    \/**\\n     * @param K $key The key to return from the map.\\n     * @param T | null $defaultValue The default value to use if `$key` is not found.\\n     *\\n     * @return T | null the value or `null` if the key could not be found.\\n     *\/\\n    public function get(int | string $key, mixed $defaultValue = null): mixed\\n    {\\n        return $this[$key] ?? $defaultValue;\\n    }\\n\\n    \/**\\n     * @param K $key The key to put or replace in the map.\\n     * @param T $value The value to store at `$key`.\\n     *\\n     * @return T | null the previous value associated with key, or `null` if\\n     *     there was no mapping for `$key`.\\n     *\/\\n    public function put(int | string $key, mixed $value): mixed\\n    {\\n        $previousValue = $this->get($key);\\n        $this[$key] = $value;\\n\\n        return $previousValue;\\n    }\\n\\n    \/**\\n     * @param K $key The key to put in the map.\\n     * @param T $value The value to store at `$key`.\\n     *\\n     * @return T | null the previous value associated with key, or `null` if\\n     *     there was no mapping for `$key`.\\n     *\/\\n    public function putIfAbsent(int | string $key, mixed $value): mixed\\n    {\\n        $currentValue = $this->get($key);\\n\\n        if ($currentValue === null) {\\n            $this[$key] = $value;\\n        }\\n\\n        return $currentValue;\\n    }\\n\\n    \/**\\n     * @param K $key The key to remove from the map.\\n     *\\n     * @return T | null the previous value associated with key, or `null` if\\n     *     there was no mapping for `$key`.\\n     *\/\\n    public function remove(int | string $key): mixed\\n    {\\n        $previousValue = $this->get($key);\\n        unset($this[$key]);\\n\\n        return $previousValue;\\n    }\\n\\n    public function removeIf(int | string $key, mixed $value): bool\\n    {\\n        if ($this->get($key) === $value) {\\n            unset($this[$key]);\\n\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    \/**\\n     * @param K $key The key to replace.\\n     * @param T $value The value to set at `$key`.\\n     *\\n     * @return T | null the previous value associated with key, or `null` if\\n     *     there was no mapping for `$key`.\\n     *\/\\n    public function replace(int | string $key, mixed $value): mixed\\n    {\\n        $currentValue = $this->get($key);\\n\\n        if ($this->containsKey($key)) {\\n            $this[$key] = $value;\\n        }\\n\\n        return $currentValue;\\n    }\\n\\n    public function replaceIf(int | string $key, mixed $oldValue, mixed $newValue): bool\\n    {\\n        if ($this->get($key) === $oldValue) {\\n            $this[$key] = $newValue;\\n\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    \/**\\n     * @return array<K, T>\\n     *\/\\n    public function __serialize(): array\\n    {\\n        \/** @var array<K, T> *\/\\n        return parent::__serialize();\\n    }\\n\\n    \/**\\n     * @return array<K, T>\\n     *\/\\n    public function toArray(): array\\n    {\\n        \/** @var array<K, T> *\/\\n        return parent::toArray();\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/collection\/src\/Map\/AbstractTypedMap.php\",\"ext\":\"php\",\"size\":1671,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/collection library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Collection\\\\Map;\\n\\nuse Ramsey\\\\Collection\\\\Exception\\\\InvalidArgumentException;\\nuse Ramsey\\\\Collection\\\\Tool\\\\TypeTrait;\\nuse Ramsey\\\\Collection\\\\Tool\\\\ValueToStringTrait;\\n\\n\/**\\n * This class provides a basic implementation of `TypedMapInterface`, to\\n * minimize the effort required to implement this interface.\\n *\\n * @template K of array-key\\n * @template T\\n * @extends AbstractMap<K, T>\\n * @implements TypedMapInterface<K, T>\\n *\/\\nabstract class AbstractTypedMap extends AbstractMap implements TypedMapInterface\\n{\\n    use TypeTrait;\\n    use ValueToStringTrait;\\n\\n    \/**\\n     * @param K $offset\\n     * @param T $value\\n     *\\n     * @inheritDoc\\n     *\/\\n    public function offsetSet(mixed $offset, mixed $value): void\\n    {\\n        if ($this->checkType($this->getKeyType(), $offset) === false) {\\n            throw new InvalidArgumentException(\\n                'Key must be of type ' . $this->getKeyType() . '; key is '\\n                . $this->toolValueToString($offset),\\n            );\\n        }\\n\\n        if ($this->checkType($this->getValueType(), $value) === false) {\\n            throw new InvalidArgumentException(\\n                'Value must be of type ' . $this->getValueType() . '; value is '\\n                . $this->toolValueToString($value),\\n            );\\n        }\\n\\n        parent::offsetSet($offset, $value);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/collection\/src\/Map\/TypedMapInterface.php\",\"ext\":\"php\",\"size\":803,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/collection library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Collection\\\\Map;\\n\\n\/**\\n * A `TypedMapInterface` represents a map of elements where key and value are\\n * typed.\\n *\\n * @template K of array-key\\n * @template T\\n * @extends MapInterface<K, T>\\n *\/\\ninterface TypedMapInterface extends MapInterface\\n{\\n    \/**\\n     * Return the type used on the key.\\n     *\/\\n    public function getKeyType(): string;\\n\\n    \/**\\n     * Return the type forced on the values.\\n     *\/\\n    public function getValueType(): string;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/collection\/src\/Map\/AssociativeArrayMap.php\",\"ext\":\"php\",\"size\":546,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/collection library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Collection\\\\Map;\\n\\n\/**\\n * `AssociativeArrayMap` represents a standard associative array object.\\n *\\n * @extends AbstractMap<string, mixed>\\n *\/\\nclass AssociativeArrayMap extends AbstractMap\\n{\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/collection\/src\/Map\/MapInterface.php\",\"ext\":\"php\",\"size\":4563,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/collection library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Collection\\\\Map;\\n\\nuse Ramsey\\\\Collection\\\\ArrayInterface;\\n\\n\/**\\n * An object that maps keys to values.\\n *\\n * A map cannot contain duplicate keys; each key can map to at most one value.\\n *\\n * @template K of array-key\\n * @template T\\n * @extends ArrayInterface<T>\\n *\/\\ninterface MapInterface extends ArrayInterface\\n{\\n    \/**\\n     * Returns `true` if this map contains a mapping for the specified key.\\n     *\\n     * @param K $key The key to check in the map.\\n     *\/\\n    public function containsKey(int | string $key): bool;\\n\\n    \/**\\n     * Returns `true` if this map maps one or more keys to the specified value.\\n     *\\n     * This performs a strict type check on the value.\\n     *\\n     * @param T $value The value to check in the map.\\n     *\/\\n    public function containsValue(mixed $value): bool;\\n\\n    \/**\\n     * Return an array of the keys contained in this map.\\n     *\\n     * @return list<K>\\n     *\/\\n    public function keys(): array;\\n\\n    \/**\\n     * Returns the value to which the specified key is mapped, `null` if this\\n     * map contains no mapping for the key, or (optionally) `$defaultValue` if\\n     * this map contains no mapping for the key.\\n     *\\n     * @param K $key The key to return from the map.\\n     * @param T | null $defaultValue The default value to use if `$key` is not found.\\n     *\\n     * @return T | null the value or `null` if the key could not be found.\\n     *\/\\n    public function get(int | string $key, mixed $defaultValue = null): mixed;\\n\\n    \/**\\n     * Associates the specified value with the specified key in this map.\\n     *\\n     * If the map previously contained a mapping for the key, the old value is\\n     * replaced by the specified value.\\n     *\\n     * @param K $key The key to put or replace in the map.\\n     * @param T $value The value to store at `$key`.\\n     *\\n     * @return T | null the previous value associated with key, or `null` if\\n     *     there was no mapping for `$key`.\\n     *\/\\n    public function put(int | string $key, mixed $value): mixed;\\n\\n    \/**\\n     * Associates the specified value with the specified key in this map only if\\n     * it is not already set.\\n     *\\n     * If there is already a value associated with `$key`, this returns that\\n     * value without replacing it.\\n     *\\n     * @param K $key The key to put in the map.\\n     * @param T $value The value to store at `$key`.\\n     *\\n     * @return T | null the previous value associated with key, or `null` if\\n     *     there was no mapping for `$key`.\\n     *\/\\n    public function putIfAbsent(int | string $key, mixed $value): mixed;\\n\\n    \/**\\n     * Removes the mapping for a key from this map if it is present.\\n     *\\n     * @param K $key The key to remove from the map.\\n     *\\n     * @return T | null the previous value associated with key, or `null` if\\n     *     there was no mapping for `$key`.\\n     *\/\\n    public function remove(int | string $key): mixed;\\n\\n    \/**\\n     * Removes the entry for the specified key only if it is currently mapped to\\n     * the specified value.\\n     *\\n     * This performs a strict type check on the value.\\n     *\\n     * @param K $key The key to remove from the map.\\n     * @param T $value The value to match.\\n     *\\n     * @return bool true if the value was removed.\\n     *\/\\n    public function removeIf(int | string $key, mixed $value): bool;\\n\\n    \/**\\n     * Replaces the entry for the specified key only if it is currently mapped\\n     * to some value.\\n     *\\n     * @param K $key The key to replace.\\n     * @param T $value The value to set at `$key`.\\n     *\\n     * @return T | null the previous value associated with key, or `null` if\\n     *     there was no mapping for `$key`.\\n     *\/\\n    public function replace(int | string $key, mixed $value): mixed;\\n\\n    \/**\\n     * Replaces the entry for the specified key only if currently mapped to the\\n     * specified value.\\n     *\\n     * This performs a strict type check on the value.\\n     *\\n     * @param K $key The key to remove from the map.\\n     * @param T $oldValue The value to match.\\n     * @param T $newValue The value to use as a replacement.\\n     *\\n     * @return bool true if the value was replaced.\\n     *\/\\n    public function replaceIf(int | string $key, mixed $oldValue, mixed $newValue): bool;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/collection\/src\/Map\/NamedParameterMap.php\",\"ext\":\"php\",\"size\":3130,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/collection library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Collection\\\\Map;\\n\\nuse Ramsey\\\\Collection\\\\Exception\\\\InvalidArgumentException;\\nuse Ramsey\\\\Collection\\\\Tool\\\\TypeTrait;\\nuse Ramsey\\\\Collection\\\\Tool\\\\ValueToStringTrait;\\n\\nuse function array_combine;\\nuse function array_key_exists;\\nuse function is_int;\\n\\n\/**\\n * `NamedParameterMap` represents a mapping of values to a set of named keys\\n * that may optionally be typed\\n *\\n * @extends AbstractMap<string, mixed>\\n *\/\\nclass NamedParameterMap extends AbstractMap\\n{\\n    use TypeTrait;\\n    use ValueToStringTrait;\\n\\n    \/**\\n     * Named parameters defined for this map.\\n     *\\n     * @var array<string, string>\\n     *\/\\n    private readonly array $namedParameters;\\n\\n    \/**\\n     * Constructs a new `NamedParameterMap`.\\n     *\\n     * @param array<array-key, string> $namedParameters The named parameters defined for this map.\\n     * @param array<string, mixed> $data An initial set of data to set on this map.\\n     *\/\\n    public function __construct(array $namedParameters, array $data = [])\\n    {\\n        $this->namedParameters = $this->filterNamedParameters($namedParameters);\\n        parent::__construct($data);\\n    }\\n\\n    \/**\\n     * Returns named parameters set for this `NamedParameterMap`.\\n     *\\n     * @return array<string, string>\\n     *\/\\n    public function getNamedParameters(): array\\n    {\\n        return $this->namedParameters;\\n    }\\n\\n    public function offsetSet(mixed $offset, mixed $value): void\\n    {\\n        if (!array_key_exists($offset, $this->namedParameters)) {\\n            throw new InvalidArgumentException(\\n                'Attempting to set value for unconfigured parameter \\\\''\\n                . $this->toolValueToString($offset) . '\\\\'',\\n            );\\n        }\\n\\n        if ($this->checkType($this->namedParameters[$offset], $value) === false) {\\n            throw new InvalidArgumentException(\\n                'Value for \\\\'' . $offset . '\\\\' must be of type '\\n                . $this->namedParameters[$offset] . '; value is '\\n                . $this->toolValueToString($value),\\n            );\\n        }\\n\\n        $this->data[$offset] = $value;\\n    }\\n\\n    \/**\\n     * Given an array of named parameters, constructs a proper mapping of\\n     * named parameters to types.\\n     *\\n     * @param array<array-key, string> $namedParameters The named parameters to filter.\\n     *\\n     * @return array<string, string>\\n     *\/\\n    protected function filterNamedParameters(array $namedParameters): array\\n    {\\n        $names = [];\\n        $types = [];\\n\\n        foreach ($namedParameters as $key => $value) {\\n            if (is_int($key)) {\\n                $names[] = $value;\\n                $types[] = 'mixed';\\n            } else {\\n                $names[] = $key;\\n                $types[] = $value;\\n            }\\n        }\\n\\n        return array_combine($names, $types) ?: [];\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/collection\/src\/DoubleEndedQueueInterface.php\",\"ext\":\"php\",\"size\":10361,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/collection library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Collection;\\n\\nuse Ramsey\\\\Collection\\\\Exception\\\\NoSuchElementException;\\nuse RuntimeException;\\n\\n\/**\\n * A linear collection that supports element insertion and removal at both ends.\\n *\\n * Most `DoubleEndedQueueInterface` implementations place no fixed limits on the\\n * number of elements they may contain, but this interface supports\\n * capacity-restricted double-ended queues as well as those with no fixed size\\n * limit.\\n *\\n * This interface defines methods to access the elements at both ends of the\\n * double-ended queue. Methods are provided to insert, remove, and examine the\\n * element. Each of these methods exists in two forms: one throws an exception\\n * if the operation fails, the other returns a special value (either `null` or\\n * `false`, depending on the operation). The latter form of the insert operation\\n * is designed specifically for use with capacity-restricted implementations; in\\n * most implementations, insert operations cannot fail.\\n *\\n * The twelve methods described above are summarized in the following table:\\n *\\n * <table>\\n * <caption>Summary of DoubleEndedQueueInterface methods<\/caption>\\n * <thead>\\n * <tr>\\n * <th><\/th>\\n * <th colspan=2>First Element (Head)<\/th>\\n * <th colspan=2>Last Element (Tail)<\/th>\\n * <\/tr>\\n * <tr>\\n * <td><\/td>\\n * <td><em>Throws exception<\/em><\/td>\\n * <td><em>Special value<\/em><\/td>\\n * <td><em>Throws exception<\/em><\/td>\\n * <td><em>Special value<\/em><\/td>\\n * <\/tr>\\n * <\/thead>\\n * <tbody>\\n * <tr>\\n * <th>Insert<\/th>\\n * <td><code>addFirst()<\/code><\/td>\\n * <td><code>offerFirst()<\/code><\/td>\\n * <td><code>addLast()<\/code><\/td>\\n * <td><code>offerLast()<\/code><\/td>\\n * <\/tr>\\n * <tr>\\n * <th>Remove<\/th>\\n * <td><code>removeFirst()<\/code><\/td>\\n * <td><code>pollFirst()<\/code><\/td>\\n * <td><code>removeLast()<\/code><\/td>\\n * <td><code>pollLast()<\/code><\/td>\\n * <\/tr>\\n * <tr>\\n * <th>Examine<\/th>\\n * <td><code>firstElement()<\/code><\/td>\\n * <td><code>peekFirst()<\/code><\/td>\\n * <td><code>lastElement()<\/code><\/td>\\n * <td><code>peekLast()<\/code><\/td>\\n * <\/tr>\\n * <\/tbody>\\n * <\/table>\\n *\\n * This interface extends the `QueueInterface`. When a double-ended queue is\\n * used as a queue, FIFO (first-in-first-out) behavior results. Elements are\\n * added at the end of the double-ended queue and removed from the beginning.\\n * The methods inherited from the `QueueInterface` are precisely equivalent to\\n * `DoubleEndedQueueInterface` methods as indicated in the following table:\\n *\\n * <table>\\n * <caption>Comparison of QueueInterface and DoubleEndedQueueInterface methods<\/caption>\\n * <thead>\\n * <tr>\\n * <th>QueueInterface Method<\/th>\\n * <th>DoubleEndedQueueInterface Method<\/th>\\n * <\/tr>\\n * <\/thead>\\n * <tbody>\\n * <tr>\\n * <td><code>add()<\/code><\/td>\\n * <td><code>addLast()<\/code><\/td>\\n * <\/tr>\\n * <tr>\\n * <td><code>offer()<\/code><\/td>\\n * <td><code>offerLast()<\/code><\/td>\\n * <\/tr>\\n * <tr>\\n * <td><code>remove()<\/code><\/td>\\n * <td><code>removeFirst()<\/code><\/td>\\n * <\/tr>\\n * <tr>\\n * <td><code>poll()<\/code><\/td>\\n * <td><code>pollFirst()<\/code><\/td>\\n * <\/tr>\\n * <tr>\\n * <td><code>element()<\/code><\/td>\\n * <td><code>firstElement()<\/code><\/td>\\n * <\/tr>\\n * <tr>\\n * <td><code>peek()<\/code><\/td>\\n * <td><code>peekFirst()<\/code><\/td>\\n * <\/tr>\\n * <\/tbody>\\n * <\/table>\\n *\\n * Double-ended queues can also be used as LIFO (last-in-first-out) stacks. When\\n * a double-ended queue is used as a stack, elements are pushed and popped from\\n * the beginning of the double-ended queue. Stack concepts are precisely\\n * equivalent to `DoubleEndedQueueInterface` methods as indicated in the table\\n * below:\\n *\\n * <table>\\n * <caption>Comparison of stack concepts and DoubleEndedQueueInterface methods<\/caption>\\n * <thead>\\n * <tr>\\n * <th>Stack concept<\/th>\\n * <th>DoubleEndedQueueInterface Method<\/th>\\n * <\/tr>\\n * <\/thead>\\n * <tbody>\\n * <tr>\\n * <td><em>push<\/em><\/td>\\n * <td><code>addFirst()<\/code><\/td>\\n * <\/tr>\\n * <tr>\\n * <td><em>pop<\/em><\/td>\\n * <td><code>removeFirst()<\/code><\/td>\\n * <\/tr>\\n * <tr>\\n * <td><em>peek<\/em><\/td>\\n * <td><code>peekFirst()<\/code><\/td>\\n * <\/tr>\\n * <\/tbody>\\n * <\/table>\\n *\\n * Note that the `peek()` method works equally well when a double-ended queue is\\n * used as a queue or a stack; in either case, elements are drawn from the\\n * beginning of the double-ended queue.\\n *\\n * While `DoubleEndedQueueInterface` implementations are not strictly required\\n * to prohibit the insertion of `null` elements, they are strongly encouraged to\\n * do so. Users of any `DoubleEndedQueueInterface` implementations that do allow\\n * `null` elements are strongly encouraged *not* to take advantage of the\\n * ability to insert nulls. This is so because `null` is used as a special\\n * return value by various methods to indicated that the double-ended queue is\\n * empty.\\n *\\n * @template T\\n * @extends QueueInterface<T>\\n *\/\\ninterface DoubleEndedQueueInterface extends QueueInterface\\n{\\n    \/**\\n     * Inserts the specified element at the front of this queue if it is\\n     * possible to do so immediately without violating capacity restrictions.\\n     *\\n     * When using a capacity-restricted double-ended queue, it is generally\\n     * preferable to use the `offerFirst()` method.\\n     *\\n     * @param T $element The element to add to the front of this queue.\\n     *\\n     * @return bool `true` if this queue changed as a result of the call.\\n     *\\n     * @throws RuntimeException if a queue refuses to add a particular element\\n     *     for any reason other than that it already contains the element.\\n     *     Implementations should use a more-specific exception that extends\\n     *     `\\\\RuntimeException`.\\n     *\/\\n    public function addFirst(mixed $element): bool;\\n\\n    \/**\\n     * Inserts the specified element at the end of this queue if it is possible\\n     * to do so immediately without violating capacity restrictions.\\n     *\\n     * When using a capacity-restricted double-ended queue, it is generally\\n     * preferable to use the `offerLast()` method.\\n     *\\n     * This method is equivalent to `add()`.\\n     *\\n     * @param T $element The element to add to the end of this queue.\\n     *\\n     * @return bool `true` if this queue changed as a result of the call.\\n     *\\n     * @throws RuntimeException if a queue refuses to add a particular element\\n     *     for any reason other than that it already contains the element.\\n     *     Implementations should use a more-specific exception that extends\\n     *     `\\\\RuntimeException`.\\n     *\/\\n    public function addLast(mixed $element): bool;\\n\\n    \/**\\n     * Inserts the specified element at the front of this queue if it is\\n     * possible to do so immediately without violating capacity restrictions.\\n     *\\n     * When using a capacity-restricted queue, this method is generally\\n     * preferable to `addFirst()`, which can fail to insert an element only by\\n     * throwing an exception.\\n     *\\n     * @param T $element The element to add to the front of this queue.\\n     *\\n     * @return bool `true` if the element was added to this queue, else `false`.\\n     *\/\\n    public function offerFirst(mixed $element): bool;\\n\\n    \/**\\n     * Inserts the specified element at the end of this queue if it is possible\\n     * to do so immediately without violating capacity restrictions.\\n     *\\n     * When using a capacity-restricted queue, this method is generally\\n     * preferable to `addLast()` which can fail to insert an element only by\\n     * throwing an exception.\\n     *\\n     * @param T $element The element to add to the end of this queue.\\n     *\\n     * @return bool `true` if the element was added to this queue, else `false`.\\n     *\/\\n    public function offerLast(mixed $element): bool;\\n\\n    \/**\\n     * Retrieves and removes the head of this queue.\\n     *\\n     * This method differs from `pollFirst()` only in that it throws an\\n     * exception if this queue is empty.\\n     *\\n     * @return T the first element in this queue.\\n     *\\n     * @throws NoSuchElementException if this queue is empty.\\n     *\/\\n    public function removeFirst(): mixed;\\n\\n    \/**\\n     * Retrieves and removes the tail of this queue.\\n     *\\n     * This method differs from `pollLast()` only in that it throws an exception\\n     * if this queue is empty.\\n     *\\n     * @return T the last element in this queue.\\n     *\\n     * @throws NoSuchElementException if this queue is empty.\\n     *\/\\n    public function removeLast(): mixed;\\n\\n    \/**\\n     * Retrieves and removes the head of this queue, or returns `null` if this\\n     * queue is empty.\\n     *\\n     * @return T | null the head of this queue, or `null` if this queue is empty.\\n     *\/\\n    public function pollFirst(): mixed;\\n\\n    \/**\\n     * Retrieves and removes the tail of this queue, or returns `null` if this\\n     * queue is empty.\\n     *\\n     * @return T | null the tail of this queue, or `null` if this queue is empty.\\n     *\/\\n    public function pollLast(): mixed;\\n\\n    \/**\\n     * Retrieves, but does not remove, the head of this queue.\\n     *\\n     * This method differs from `peekFirst()` only in that it throws an\\n     * exception if this queue is empty.\\n     *\\n     * @return T the head of this queue.\\n     *\\n     * @throws NoSuchElementException if this queue is empty.\\n     *\/\\n    public function firstElement(): mixed;\\n\\n    \/**\\n     * Retrieves, but does not remove, the tail of this queue.\\n     *\\n     * This method differs from `peekLast()` only in that it throws an exception\\n     * if this queue is empty.\\n     *\\n     * @return T the tail of this queue.\\n     *\\n     * @throws NoSuchElementException if this queue is empty.\\n     *\/\\n    public function lastElement(): mixed;\\n\\n    \/**\\n     * Retrieves, but does not remove, the head of this queue, or returns `null`\\n     * if this queue is empty.\\n     *\\n     * @return T | null the head of this queue, or `null` if this queue is empty.\\n     *\/\\n    public function peekFirst(): mixed;\\n\\n    \/**\\n     * Retrieves, but does not remove, the tail of this queue, or returns `null`\\n     * if this queue is empty.\\n     *\\n     * @return T | null the tail of this queue, or `null` if this queue is empty.\\n     *\/\\n    public function peekLast(): mixed;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/collection\/src\/AbstractCollection.php\",\"ext\":\"php\",\"size\":11285,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/collection library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Collection;\\n\\nuse Closure;\\nuse Ramsey\\\\Collection\\\\Exception\\\\CollectionMismatchException;\\nuse Ramsey\\\\Collection\\\\Exception\\\\InvalidArgumentException;\\nuse Ramsey\\\\Collection\\\\Exception\\\\InvalidPropertyOrMethod;\\nuse Ramsey\\\\Collection\\\\Exception\\\\NoSuchElementException;\\nuse Ramsey\\\\Collection\\\\Exception\\\\UnsupportedOperationException;\\nuse Ramsey\\\\Collection\\\\Tool\\\\TypeTrait;\\nuse Ramsey\\\\Collection\\\\Tool\\\\ValueExtractorTrait;\\nuse Ramsey\\\\Collection\\\\Tool\\\\ValueToStringTrait;\\n\\nuse function array_filter;\\nuse function array_key_first;\\nuse function array_key_last;\\nuse function array_map;\\nuse function array_merge;\\nuse function array_reduce;\\nuse function array_search;\\nuse function array_udiff;\\nuse function array_uintersect;\\nuse function in_array;\\nuse function is_int;\\nuse function is_object;\\nuse function spl_object_id;\\nuse function sprintf;\\nuse function usort;\\n\\n\/**\\n * This class provides a basic implementation of `CollectionInterface`, to\\n * minimize the effort required to implement this interface\\n *\\n * @template T\\n * @extends AbstractArray<T>\\n * @implements CollectionInterface<T>\\n *\/\\nabstract class AbstractCollection extends AbstractArray implements CollectionInterface\\n{\\n    use TypeTrait;\\n    use ValueToStringTrait;\\n    use ValueExtractorTrait;\\n\\n    \/**\\n     * @throws InvalidArgumentException if $element is of the wrong type.\\n     *\/\\n    public function add(mixed $element): bool\\n    {\\n        $this[] = $element;\\n\\n        return true;\\n    }\\n\\n    public function contains(mixed $element, bool $strict = true): bool\\n    {\\n        return in_array($element, $this->data, $strict);\\n    }\\n\\n    \/**\\n     * @throws InvalidArgumentException if $element is of the wrong type.\\n     *\/\\n    public function offsetSet(mixed $offset, mixed $value): void\\n    {\\n        if ($this->checkType($this->getType(), $value) === false) {\\n            throw new InvalidArgumentException(\\n                'Value must be of type ' . $this->getType() . '; value is '\\n                . $this->toolValueToString($value),\\n            );\\n        }\\n\\n        if ($offset === null) {\\n            $this->data[] = $value;\\n        } else {\\n            $this->data[$offset] = $value;\\n        }\\n    }\\n\\n    public function remove(mixed $element): bool\\n    {\\n        if (($position = array_search($element, $this->data, true)) !== false) {\\n            unset($this[$position]);\\n\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    \/**\\n     * @throws InvalidPropertyOrMethod if the $propertyOrMethod does not exist\\n     *     on the elements in this collection.\\n     * @throws UnsupportedOperationException if unable to call column() on this\\n     *     collection.\\n     *\\n     * @inheritDoc\\n     *\/\\n    public function column(string $propertyOrMethod): array\\n    {\\n        $temp = [];\\n\\n        foreach ($this->data as $item) {\\n            $temp[] = $this->extractValue($item, $propertyOrMethod);\\n        }\\n\\n        return $temp;\\n    }\\n\\n    \/**\\n     * @return T\\n     *\\n     * @throws NoSuchElementException if this collection is empty.\\n     *\/\\n    public function first(): mixed\\n    {\\n        $firstIndex = array_key_first($this->data);\\n\\n        if ($firstIndex === null) {\\n            throw new NoSuchElementException('Can\\\\'t determine first item. Collection is empty');\\n        }\\n\\n        return $this->data[$firstIndex];\\n    }\\n\\n    \/**\\n     * @return T\\n     *\\n     * @throws NoSuchElementException if this collection is empty.\\n     *\/\\n    public function last(): mixed\\n    {\\n        $lastIndex = array_key_last($this->data);\\n\\n        if ($lastIndex === null) {\\n            throw new NoSuchElementException('Can\\\\'t determine last item. Collection is empty');\\n        }\\n\\n        return $this->data[$lastIndex];\\n    }\\n\\n    \/**\\n     * @return CollectionInterface<T>\\n     *\\n     * @throws InvalidPropertyOrMethod if the $propertyOrMethod does not exist\\n     *     on the elements in this collection.\\n     * @throws UnsupportedOperationException if unable to call sort() on this\\n     *     collection.\\n     *\/\\n    public function sort(?string $propertyOrMethod = null, Sort $order = Sort::Ascending): CollectionInterface\\n    {\\n        $collection = clone $this;\\n\\n        usort(\\n            $collection->data,\\n            function (mixed $a, mixed $b) use ($propertyOrMethod, $order): int {\\n                $aValue = $this->extractValue($a, $propertyOrMethod);\\n                $bValue = $this->extractValue($b, $propertyOrMethod);\\n\\n                return ($aValue <=> $bValue) * ($order === Sort::Descending ? -1 : 1);\\n            },\\n        );\\n\\n        return $collection;\\n    }\\n\\n    \/**\\n     * @param callable(T): bool $callback A callable to use for filtering elements.\\n     *\\n     * @return CollectionInterface<T>\\n     *\/\\n    public function filter(callable $callback): CollectionInterface\\n    {\\n        $collection = clone $this;\\n        $collection->data = array_merge([], array_filter($collection->data, $callback));\\n\\n        return $collection;\\n    }\\n\\n    \/**\\n     * @return CollectionInterface<T>\\n     *\\n     * @throws InvalidPropertyOrMethod if the $propertyOrMethod does not exist\\n     *     on the elements in this collection.\\n     * @throws UnsupportedOperationException if unable to call where() on this\\n     *     collection.\\n     *\/\\n    public function where(?string $propertyOrMethod, mixed $value): CollectionInterface\\n    {\\n        return $this->filter(\\n            fn (mixed $item): bool => $this->extractValue($item, $propertyOrMethod) === $value,\\n        );\\n    }\\n\\n    \/**\\n     * @param callable(T): TCallbackReturn $callback A callable to apply to each\\n     *     item of the collection.\\n     *\\n     * @return CollectionInterface<TCallbackReturn>\\n     *\\n     * @template TCallbackReturn\\n     *\/\\n    public function map(callable $callback): CollectionInterface\\n    {\\n        return new Collection('mixed', array_map($callback, $this->data));\\n    }\\n\\n    \/**\\n     * @param callable(TCarry, T): TCarry $callback A callable to apply to each\\n     *     item of the collection to reduce it to a single value.\\n     * @param TCarry $initial This is the initial value provided to the callback.\\n     *\\n     * @return TCarry\\n     *\\n     * @template TCarry\\n     *\/\\n    public function reduce(callable $callback, mixed $initial): mixed\\n    {\\n        return array_reduce($this->data, $callback, $initial);\\n    }\\n\\n    \/**\\n     * @param CollectionInterface<T> $other The collection to check for divergent\\n     *     items.\\n     *\\n     * @return CollectionInterface<T>\\n     *\\n     * @throws CollectionMismatchException if the compared collections are of\\n     *     differing types.\\n     *\/\\n    public function diff(CollectionInterface $other): CollectionInterface\\n    {\\n        $this->compareCollectionTypes($other);\\n\\n        $diffAtoB = array_udiff($this->data, $other->toArray(), $this->getComparator());\\n        $diffBtoA = array_udiff($other->toArray(), $this->data, $this->getComparator());\\n\\n        $collection = clone $this;\\n        $collection->data = array_merge($diffAtoB, $diffBtoA);\\n\\n        return $collection;\\n    }\\n\\n    \/**\\n     * @param CollectionInterface<T> $other The collection to check for\\n     *     intersecting items.\\n     *\\n     * @return CollectionInterface<T>\\n     *\\n     * @throws CollectionMismatchException if the compared collections are of\\n     *     differing types.\\n     *\/\\n    public function intersect(CollectionInterface $other): CollectionInterface\\n    {\\n        $this->compareCollectionTypes($other);\\n\\n        $collection = clone $this;\\n        $collection->data = array_uintersect($this->data, $other->toArray(), $this->getComparator());\\n\\n        return $collection;\\n    }\\n\\n    \/**\\n     * @param CollectionInterface<T> ...$collections The collections to merge.\\n     *\\n     * @return CollectionInterface<T>\\n     *\\n     * @throws CollectionMismatchException if unable to merge any of the given\\n     *     collections or items within the given collections due to type\\n     *     mismatch errors.\\n     *\/\\n    public function merge(CollectionInterface ...$collections): CollectionInterface\\n    {\\n        $mergedCollection = clone $this;\\n\\n        foreach ($collections as $index => $collection) {\\n            if (!$collection instanceof static) {\\n                throw new CollectionMismatchException(\\n                    sprintf('Collection with index %d must be of type %s', $index, static::class),\\n                );\\n            }\\n\\n            \/\/ When using generics (Collection.php, Set.php, etc),\\n            \/\/ we also need to make sure that the internal types match each other\\n            if ($this->getUniformType($collection) !== $this->getUniformType($this)) {\\n                throw new CollectionMismatchException(\\n                    sprintf(\\n                        'Collection items in collection with index %d must be of type %s',\\n                        $index,\\n                        $this->getType(),\\n                    ),\\n                );\\n            }\\n\\n            foreach ($collection as $key => $value) {\\n                if (is_int($key)) {\\n                    $mergedCollection[] = $value;\\n                } else {\\n                    $mergedCollection[$key] = $value;\\n                }\\n            }\\n        }\\n\\n        return $mergedCollection;\\n    }\\n\\n    \/**\\n     * @param CollectionInterface<T> $other\\n     *\\n     * @throws CollectionMismatchException\\n     *\/\\n    private function compareCollectionTypes(CollectionInterface $other): void\\n    {\\n        if (!$other instanceof static) {\\n            throw new CollectionMismatchException('Collection must be of type ' . static::class);\\n        }\\n\\n        \/\/ When using generics (Collection.php, Set.php, etc),\\n        \/\/ we also need to make sure that the internal types match each other\\n        if ($this->getUniformType($other) !== $this->getUniformType($this)) {\\n            throw new CollectionMismatchException('Collection items must be of type ' . $this->getType());\\n        }\\n    }\\n\\n    private function getComparator(): Closure\\n    {\\n        return function (mixed $a, mixed $b): int {\\n            \/\/ If the two values are object, we convert them to unique scalars.\\n            \/\/ If the collection contains mixed values (unlikely) where some are objects\\n            \/\/ and some are not, we leave them as they are.\\n            \/\/ The comparator should still work and the result of $a < $b should\\n            \/\/ be consistent but unpredictable since not documented.\\n            if (is_object($a) && is_object($b)) {\\n                $a = spl_object_id($a);\\n                $b = spl_object_id($b);\\n            }\\n\\n            return $a === $b ? 0 : ($a < $b ? 1 : -1);\\n        };\\n    }\\n\\n    \/**\\n     * @param CollectionInterface<mixed> $collection\\n     *\/\\n    private function getUniformType(CollectionInterface $collection): string\\n    {\\n        return match ($collection->getType()) {\\n            'integer' => 'int',\\n            'boolean' => 'bool',\\n            'double' => 'float',\\n            default => $collection->getType(),\\n        };\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/collection\/src\/ArrayInterface.php\",\"ext\":\"php\",\"size\":1061,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/collection library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Collection;\\n\\nuse ArrayAccess;\\nuse Countable;\\nuse IteratorAggregate;\\n\\n\/**\\n * `ArrayInterface` provides traversable array functionality to data types.\\n *\\n * @template T\\n * @extends ArrayAccess<array-key, T>\\n * @extends IteratorAggregate<array-key, T>\\n *\/\\ninterface ArrayInterface extends\\n    ArrayAccess,\\n    Countable,\\n    IteratorAggregate\\n{\\n    \/**\\n     * Removes all items from this array.\\n     *\/\\n    public function clear(): void;\\n\\n    \/**\\n     * Returns a native PHP array representation of this array object.\\n     *\\n     * @return array<array-key, T>\\n     *\/\\n    public function toArray(): array;\\n\\n    \/**\\n     * Returns `true` if this array is empty.\\n     *\/\\n    public function isEmpty(): bool;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/collection\/src\/Collection.php\",\"ext\":\"php\",\"size\":2315,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/collection library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Collection;\\n\\n\/**\\n * A collection represents a group of objects.\\n *\\n * Each object in the collection is of a specific, defined type.\\n *\\n * This is a direct implementation of `CollectionInterface`, provided for\\n * the sake of convenience.\\n *\\n * Example usage:\\n *\\n * ```\\n * $collection = new \\\\Ramsey\\\\Collection\\\\Collection('My\\\\\\\\Foo');\\n * $collection->add(new \\\\My\\\\Foo());\\n * $collection->add(new \\\\My\\\\Foo());\\n *\\n * foreach ($collection as $foo) {\\n *     \/\/ Do something with $foo\\n * }\\n * ```\\n *\\n * It is preferable to subclass `AbstractCollection` to create your own typed\\n * collections. For example:\\n *\\n * ```\\n * namespace My\\\\Foo;\\n *\\n * class FooCollection extends \\\\Ramsey\\\\Collection\\\\AbstractCollection\\n * {\\n *     public function getType()\\n *     {\\n *         return 'My\\\\\\\\Foo';\\n *     }\\n * }\\n * ```\\n *\\n * And then use it similarly to the earlier example:\\n *\\n * ```\\n * $fooCollection = new \\\\My\\\\Foo\\\\FooCollection();\\n * $fooCollection->add(new \\\\My\\\\Foo());\\n * $fooCollection->add(new \\\\My\\\\Foo());\\n *\\n * foreach ($fooCollection as $foo) {\\n *     \/\/ Do something with $foo\\n * }\\n * ```\\n *\\n * The benefit with this approach is that you may do type-checking on the\\n * collection object:\\n *\\n * ```\\n * if ($collection instanceof \\\\My\\\\Foo\\\\FooCollection) {\\n *     \/\/ the collection is a collection of My\\\\Foo objects\\n * }\\n * ```\\n *\\n * @template T\\n * @extends AbstractCollection<T>\\n *\/\\nclass Collection extends AbstractCollection\\n{\\n    \/**\\n     * Constructs a collection object of the specified type, optionally with the\\n     * specified data.\\n     *\\n     * @param string $collectionType The type or class name associated with this\\n     *     collection.\\n     * @param array<array-key, T> $data The initial items to store in the collection.\\n     *\/\\n    public function __construct(private readonly string $collectionType, array $data = [])\\n    {\\n        parent::__construct($data);\\n    }\\n\\n    public function getType(): string\\n    {\\n        return $this->collectionType;\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/collection\/src\/Exception\/OutOfBoundsException.php\",\"ext\":\"php\",\"size\":618,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/collection library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Collection\\\\Exception;\\n\\nuse OutOfBoundsException as PhpOutOfBoundsException;\\n\\n\/**\\n * Thrown when attempting to access an element out of the range of the collection.\\n *\/\\nclass OutOfBoundsException extends PhpOutOfBoundsException implements CollectionException\\n{\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/collection\/src\/Exception\/NoSuchElementException.php\",\"ext\":\"php\",\"size\":567,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/collection library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Collection\\\\Exception;\\n\\nuse RuntimeException;\\n\\n\/**\\n * Thrown when attempting to access an element that does not exist.\\n *\/\\nclass NoSuchElementException extends RuntimeException implements CollectionException\\n{\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/collection\/src\/Exception\/InvalidPropertyOrMethod.php\",\"ext\":\"php\",\"size\":667,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/collection library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Collection\\\\Exception;\\n\\nuse RuntimeException;\\n\\n\/**\\n * Thrown when attempting to evaluate a property, method, or array key\\n * that doesn't exist on an element or cannot otherwise be evaluated in the\\n * current context.\\n *\/\\nclass InvalidPropertyOrMethod extends RuntimeException implements CollectionException\\n{\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/collection\/src\/Exception\/CollectionException.php\",\"ext\":\"php\",\"size\":447,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/collection library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Collection\\\\Exception;\\n\\nuse Throwable;\\n\\ninterface CollectionException extends Throwable\\n{\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/collection\/src\/Exception\/InvalidArgumentException.php\",\"ext\":\"php\",\"size\":614,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/collection library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Collection\\\\Exception;\\n\\nuse InvalidArgumentException as PhpInvalidArgumentException;\\n\\n\/**\\n * Thrown to indicate an argument is not of the expected type.\\n *\/\\nclass InvalidArgumentException extends PhpInvalidArgumentException implements CollectionException\\n{\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/collection\/src\/Exception\/CollectionMismatchException.php\",\"ext\":\"php\",\"size\":576,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/collection library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Collection\\\\Exception;\\n\\nuse RuntimeException;\\n\\n\/**\\n * Thrown when attempting to operate on collections of differing types.\\n *\/\\nclass CollectionMismatchException extends RuntimeException implements CollectionException\\n{\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/collection\/src\/Exception\/UnsupportedOperationException.php\",\"ext\":\"php\",\"size\":575,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/collection library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Collection\\\\Exception;\\n\\nuse RuntimeException;\\n\\n\/**\\n * Thrown to indicate that the requested operation is not supported.\\n *\/\\nclass UnsupportedOperationException extends RuntimeException implements CollectionException\\n{\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/collection\/src\/Sort.php\",\"ext\":\"php\",\"size\":621,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/collection library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Collection;\\n\\n\/**\\n * Collection sorting\\n *\/\\nenum Sort: string\\n{\\n    \/**\\n     * Sort items in a collection in ascending order.\\n     *\/\\n    case Ascending = 'asc';\\n\\n    \/**\\n     * Sort items in a collection in descending order.\\n     *\/\\n    case Descending = 'desc';\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/ramsey\/collection\/src\/CollectionInterface.php\",\"ext\":\"php\",\"size\":9152,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the ramsey\/collection library\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\\n * @copyright Copyright (c) Ben Ramsey <ben@benramsey.com>\\n * @license http:\/\/opensource.org\/licenses\/MIT MIT\\n *\/\\n\\ndeclare(strict_types=1);\\n\\nnamespace Ramsey\\\\Collection;\\n\\nuse Ramsey\\\\Collection\\\\Exception\\\\CollectionMismatchException;\\nuse Ramsey\\\\Collection\\\\Exception\\\\InvalidArgumentException;\\nuse Ramsey\\\\Collection\\\\Exception\\\\InvalidPropertyOrMethod;\\nuse Ramsey\\\\Collection\\\\Exception\\\\NoSuchElementException;\\nuse Ramsey\\\\Collection\\\\Exception\\\\UnsupportedOperationException;\\n\\n\/**\\n * A collection represents a group of values, known as its elements.\\n *\\n * Some collections allow duplicate elements and others do not. Some are ordered\\n * and others unordered.\\n *\\n * @template T\\n * @extends ArrayInterface<T>\\n *\/\\ninterface CollectionInterface extends ArrayInterface\\n{\\n    \/**\\n     * Ensures that this collection contains the specified element (optional\\n     * operation).\\n     *\\n     * Returns `true` if this collection changed as a result of the call.\\n     * (Returns `false` if this collection does not permit duplicates and\\n     * already contains the specified element.)\\n     *\\n     * Collections that support this operation may place limitations on what\\n     * elements may be added to this collection. In particular, some\\n     * collections will refuse to add `null` elements, and others will impose\\n     * restrictions on the type of elements that may be added. Collection\\n     * classes should clearly specify in their documentation any restrictions\\n     * on what elements may be added.\\n     *\\n     * If a collection refuses to add a particular element for any reason other\\n     * than that it already contains the element, it must throw an exception\\n     * (rather than returning `false`). This preserves the invariant that a\\n     * collection always contains the specified element after this call returns.\\n     *\\n     * @param T $element The element to add to the collection.\\n     *\\n     * @return bool `true` if this collection changed as a result of the call.\\n     *\\n     * @throws InvalidArgumentException if the collection refuses to add the\\n     *     $element for any reason other than that it already contains the element.\\n     *\/\\n    public function add(mixed $element): bool;\\n\\n    \/**\\n     * Returns `true` if this collection contains the specified element.\\n     *\\n     * @param T $element The element to check whether the collection contains.\\n     * @param bool $strict Whether to perform a strict type check on the value.\\n     *\/\\n    public function contains(mixed $element, bool $strict = true): bool;\\n\\n    \/**\\n     * Returns the type associated with this collection.\\n     *\/\\n    public function getType(): string;\\n\\n    \/**\\n     * Removes a single instance of the specified element from this collection,\\n     * if it is present.\\n     *\\n     * @param T $element The element to remove from the collection.\\n     *\\n     * @return bool `true` if an element was removed as a result of this call.\\n     *\/\\n    public function remove(mixed $element): bool;\\n\\n    \/**\\n     * Returns the values from the given property, method, or array key.\\n     *\\n     * @param string $propertyOrMethod The name of the property, method, or\\n     *     array key to evaluate and return.\\n     *\\n     * @return list<mixed>\\n     *\\n     * @throws InvalidPropertyOrMethod if the $propertyOrMethod does not exist\\n     *     on the elements in this collection.\\n     * @throws UnsupportedOperationException if unable to call column() on this\\n     *     collection.\\n     *\/\\n    public function column(string $propertyOrMethod): array;\\n\\n    \/**\\n     * Returns the first item of the collection.\\n     *\\n     * @return T\\n     *\\n     * @throws NoSuchElementException if this collection is empty.\\n     *\/\\n    public function first(): mixed;\\n\\n    \/**\\n     * Returns the last item of the collection.\\n     *\\n     * @return T\\n     *\\n     * @throws NoSuchElementException if this collection is empty.\\n     *\/\\n    public function last(): mixed;\\n\\n    \/**\\n     * Sort the collection by a property, method, or array key with the given\\n     * sort order.\\n     *\\n     * If $propertyOrMethod is `null`, this will sort by comparing each element.\\n     *\\n     * This will always leave the original collection untouched and will return\\n     * a new one.\\n     *\\n     * @param string | null $propertyOrMethod The property, method, or array key\\n     *     to sort by.\\n     * @param Sort $order The sort order for the resulting collection.\\n     *\\n     * @return CollectionInterface<T>\\n     *\\n     * @throws InvalidPropertyOrMethod if the $propertyOrMethod does not exist\\n     *     on the elements in this collection.\\n     * @throws UnsupportedOperationException if unable to call sort() on this\\n     *     collection.\\n     *\/\\n    public function sort(?string $propertyOrMethod = null, Sort $order = Sort::Ascending): self;\\n\\n    \/**\\n     * Filter out items of the collection which don't match the criteria of\\n     * given callback.\\n     *\\n     * This will always leave the original collection untouched and will return\\n     * a new one.\\n     *\\n     * See the {@link http:\/\/php.net\/manual\/en\/function.array-filter.php PHP array_filter() documentation}\\n     * for examples of how the `$callback` parameter works.\\n     *\\n     * @param callable(T): bool $callback A callable to use for filtering elements.\\n     *\\n     * @return CollectionInterface<T>\\n     *\/\\n    public function filter(callable $callback): self;\\n\\n    \/**\\n     * Create a new collection where the result of the given property, method,\\n     * or array key of each item in the collection equals the given value.\\n     *\\n     * This will always leave the original collection untouched and will return\\n     * a new one.\\n     *\\n     * @param string | null $propertyOrMethod The property, method, or array key\\n     *     to evaluate. If `null`, the element itself is compared to $value.\\n     * @param mixed $value The value to match.\\n     *\\n     * @return CollectionInterface<T>\\n     *\\n     * @throws InvalidPropertyOrMethod if the $propertyOrMethod does not exist\\n     *     on the elements in this collection.\\n     * @throws UnsupportedOperationException if unable to call where() on this\\n     *     collection.\\n     *\/\\n    public function where(?string $propertyOrMethod, mixed $value): self;\\n\\n    \/**\\n     * Apply a given callback method on each item of the collection.\\n     *\\n     * This will always leave the original collection untouched. The new\\n     * collection is created by mapping the callback to each item of the\\n     * original collection.\\n     *\\n     * See the {@link http:\/\/php.net\/manual\/en\/function.array-map.php PHP array_map() documentation}\\n     * for examples of how the `$callback` parameter works.\\n     *\\n     * @param callable(T): TCallbackReturn $callback A callable to apply to each\\n     *     item of the collection.\\n     *\\n     * @return CollectionInterface<TCallbackReturn>\\n     *\\n     * @template TCallbackReturn\\n     *\/\\n    public function map(callable $callback): self;\\n\\n    \/**\\n     * Apply a given callback method on each item of the collection\\n     * to reduce it to a single value.\\n     *\\n     * See the {@link http:\/\/php.net\/manual\/en\/function.array-reduce.php PHP array_reduce() documentation}\\n     * for examples of how the `$callback` and `$initial` parameters work.\\n     *\\n     * @param callable(TCarry, T): TCarry $callback A callable to apply to each\\n     *     item of the collection to reduce it to a single value.\\n     * @param TCarry $initial This is the initial value provided to the callback.\\n     *\\n     * @return TCarry\\n     *\\n     * @template TCarry\\n     *\/\\n    public function reduce(callable $callback, mixed $initial): mixed;\\n\\n    \/**\\n     * Create a new collection with divergent items between current and given\\n     * collection.\\n     *\\n     * @param CollectionInterface<T> $other The collection to check for divergent\\n     *     items.\\n     *\\n     * @return CollectionInterface<T>\\n     *\\n     * @throws CollectionMismatchException if the compared collections are of\\n     *     differing types.\\n     *\/\\n    public function diff(CollectionInterface $other): self;\\n\\n    \/**\\n     * Create a new collection with intersecting item between current and given\\n     * collection.\\n     *\\n     * @param CollectionInterface<T> $other The collection to check for\\n     *     intersecting items.\\n     *\\n     * @return CollectionInterface<T>\\n     *\\n     * @throws CollectionMismatchException if the compared collections are of\\n     *     differing types.\\n     *\/\\n    public function intersect(CollectionInterface $other): self;\\n\\n    \/**\\n     * Merge current items and items of given collections into a new one.\\n     *\\n     * @param CollectionInterface<T> ...$collections The collections to merge.\\n     *\\n     * @return CollectionInterface<T>\\n     *\\n     * @throws CollectionMismatchException if unable to merge any of the given\\n     *     collections or items within the given collections due to type\\n     *     mismatch errors.\\n     *\/\\n    public function merge(CollectionInterface ...$collections): self;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/.phpstorm.meta.php\",\"ext\":\"php\",\"size\":992,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\nnamespace PHPSTORM_META {\\n    registerArgumentsSet(\\\"date_units\\\", \\\"millenania\\\", \\\"millennium\\\", \\\"century\\\", \\\"centuries\\\", \\\"decade\\\", \\\"decades\\\", \\\"year\\\", \\\"years\\\", \\\"y\\\", \\\"yr\\\", \\\"yrs\\\", \\\"quarter\\\", \\\"quarters\\\", \\\"month\\\", \\\"months\\\", \\\"mo\\\", \\\"mos\\\", \\\"week\\\", \\\"weeks\\\", \\\"w\\\", \\\"day\\\", \\\"days\\\", \\\"d\\\", \\\"hour\\\", \\\"hours\\\", \\\"h\\\", \\\"minute\\\", \\\"minutes\\\", \\\"m\\\", \\\"second\\\", \\\"seconds\\\", \\\"s\\\", \\\"millisecond\\\", \\\"milliseconds\\\", \\\"milli\\\", \\\"ms\\\", \\\"microsecond\\\", \\\"microseconds\\\", \\\"micro\\\", \\\"\u00b5s\\\");\\n    expectedArguments(\\\\Carbon\\\\Traits\\\\Units::add(), 0, argumentsSet(\\\"date_units\\\"));\\n    expectedArguments(\\\\Carbon\\\\Traits\\\\Units::add(), 1, argumentsSet(\\\"date_units\\\"));\\n    expectedArguments(\\\\Carbon\\\\CarbonInterface::add(), 0, argumentsSet(\\\"date_units\\\"));\\n    expectedArguments(\\\\Carbon\\\\CarbonInterface::add(), 1, argumentsSet(\\\"date_units\\\"));\\n\\n    expectedArguments(\\\\Carbon\\\\CarbonInterface::getTimeFormatByPrecision(), 0, \\\"minute\\\", \\\"second\\\", \\\"m\\\", \\\"millisecond\\\", \\\"\u00b5\\\", \\\"microsecond\\\", \\\"minutes\\\", \\\"seconds\\\", \\\"ms\\\", \\\"milliseconds\\\", \\\"\u00b5s\\\", \\\"microseconds\\\");\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/sponsors.php\",\"ext\":\"php\",\"size\":9943,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nuse Carbon\\\\CarbonImmutable;\\n\\nrequire_once __DIR__.'\/vendor\/autoload.php';\\n\\nfunction getMaxHistoryMonthsByAmount($amount): int\\n{\\n    if ($amount >= 50) {\\n        return 6;\\n    }\\n\\n    if ($amount >= 20) {\\n        return 4;\\n    }\\n\\n    return 2;\\n}\\n\\nfunction getHtmlAttribute($rawValue): string\\n{\\n    return str_replace(\\n        ['\u200b', \\\"\\\\r\\\"],\\n        '',\\n        trim(htmlspecialchars((string) $rawValue), \\\"\u00a0 \\\\n\\\\r\\\\t\\\\v\\\\0\\\"),\\n    );\\n}\\n\\nfunction getOpenCollectiveSponsors(): string\\n{\\n    $customSponsorOverride = [\\n        \/\/ For consistency and equity among sponsors, as of now, we kindly ask our sponsors\\n        \/\/ to provide an image having a width\/height ratio between 1\/1 and 2\/1.\\n        \/\/ By default, we'll show the member picture from OpenCollective, and will resize it if bigger\\n        662698 => [\\n            \/\/ alt attribute\\n            'name' => 'Non Gamstop Casinos',\\n            \/\/ title attribute\\n            'description' => 'Casinos not on Gamstop',\\n            \/\/ src attribute\\n            'image' => 'https:\/\/lgcnews.com\/wp-content\/uploads\/2018\/01\/LGC-logo-v8-temp.png',\\n            \/\/ href attribute\\n            'website' => 'https:\/\/lgcnews.com\/',\\n        ],\\n        663069 => [\\n            \/\/ alt attribute\\n            'name' => '\u0421\u0442\u0430\u0432\u043a\u0438 \u043d\u0430 \u0441\u043f\u043e\u0440\u0442 Favbet',\\n            \/\/ href attribute\\n            'website' => 'https:\/\/www.favbet.ua\/uk\/',\\n        ],\\n        676798 => [\\n            \/\/ alt attribute\\n            'name' => 'Top Casinos Canada',\\n            \/\/ title attribute\\n            'description' => 'Top Casinos Canada',\\n            \/\/ src attribute\\n            'image' => 'https:\/\/topcasino.net\/img\/topcasino-logo-cover.png',\\n            \/\/ href attribute\\n            'website' => 'https:\/\/topcasino.net\/',\\n        ],\\n    ];\\n\\n    $members = json_decode(file_get_contents('https:\/\/opencollective.com\/carbon\/members\/all.json'), true);\\n\\n    foreach ($members as &$member) {\\n        $member = array_merge($member, $customSponsorOverride[$member['MemberId']] ?? []);\\n    }\\n\\n    \/\/ Adding sponsors paying via other payment methods\\n    $members[] = [\\n        'MemberId' => 1,\\n        'createdAt' => '2019-01-01 02:00',\\n        'type' => 'ORGANIZATION',\\n        'role' => 'BACKER',\\n        'tier' => 'backer+',\\n        'isActive' => true,\\n        'totalAmountDonated' => 1000,\\n        'currency' => 'USD',\\n        'lastTransactionAt' => CarbonImmutable::now()->format('Y-m-d').' 02:00',\\n        'lastTransactionAmount' => 25,\\n        'profile' => 'https:\/\/tidelift.com\/',\\n        'name' => 'Tidelift',\\n        'description' => 'Get professional support for Carbon',\\n        'image' => 'https:\/\/carbon.nesbot.com\/docs\/sponsors\/tidelift-brand.png',\\n        'website' => 'https:\/\/tidelift.com\/subscription\/pkg\/packagist-nesbot-carbon?utm_source=packagist-nesbot-carbon&utm_medium=referral&utm_campaign=docs',\\n    ];\\n    $members[] = [\\n        'MemberId' => 2,\\n        'createdAt' => '2024-11-14 02:00',\\n        'type' => 'ORGANIZATION',\\n        'role' => 'BACKER',\\n        'tier' => 'backer+ yearly',\\n        'isActive' => true,\\n        'totalAmountDonated' => 170,\\n        'currency' => 'USD',\\n        'lastTransactionAt' => '2024-11-14 02:00',\\n        'lastTransactionAmount' => 170,\\n        'profile' => 'https:\/\/www.slotozilla.com\/nz\/free-spins',\\n        'name' => 'Slotozilla',\\n        'description' => 'Slotozilla website',\\n        'image' => 'https:\/\/carbon.nesbot.com\/docs\/sponsors\/slotozilla.png',\\n        'website' => 'https:\/\/www.slotozilla.com\/nz\/free-spins',\\n    ];\\n\\n    $list = array_filter($members, static fn (array $member): bool => $member['totalAmountDonated'] > 3 && $member['role'] !== 'HOST' && (\\n        $member['totalAmountDonated'] > 100 ||\\n        $member['lastTransactionAt'] > CarbonImmutable::now()\\n            ->subMonthsNoOverflow(getMaxHistoryMonthsByAmount($member['lastTransactionAmount']))\\n            ->format('Y-m-d h:i') ||\\n        $member['isActive'] && $member['lastTransactionAmount'] >= 30\\n    ));\\n\\n    $list = array_map(static function (array $member): array {\\n        $createdAt = CarbonImmutable::parse($member['createdAt']);\\n        $lastTransactionAt = CarbonImmutable::parse($member['lastTransactionAt']);\\n\\n        if ($createdAt->format('d H:i:s.u') > $lastTransactionAt->format('d H:i:s.u')) {\\n            $createdAt = $createdAt\\n                ->setDay($lastTransactionAt->day)\\n                ->modify($lastTransactionAt->format('H:i:s.u'));\\n        }\\n\\n        $isYearly = str_contains(strtolower($member['tier'] ?? ''), 'yearly');\\n        $monthlyContribution = (float) (\\n            ($isYearly && $lastTransactionAt > CarbonImmutable::parse('-1 year'))\\n                ? ($member['lastTransactionAmount'] \/ 11.2) \/\/ 11.2 instead of 12 to include the discount for yearly subscription\\n                : ($member['totalAmountDonated'] \/ ceil($createdAt->floatDiffInMonths()))\\n        );\\n\\n        if (!$isYearly) {\\n            if (\\n                $lastTransactionAt->isAfter('last month') &&\\n                $member['lastTransactionAmount'] > $monthlyContribution\\n            ) {\\n                $monthlyContribution = (float) $member['lastTransactionAmount'];\\n            }\\n\\n            if ($lastTransactionAt->isBefore('-75 days')) {\\n                $days = min(120, $lastTransactionAt->diffInDays('now') - 70);\\n                $monthlyContribution *= 1 - $days \/ 240;\\n            }\\n        }\\n\\n        $yearlyContribution = (float) (\\n            $isYearly\\n                ? (12 * $monthlyContribution)\\n                : ($member['totalAmountDonated'] \/ max(1, $createdAt->floatDiffInYears()))\\n        );\\n        $status = null;\\n        $rank = 0;\\n\\n        if ($monthlyContribution > 50 || $yearlyContribution > 900) {\\n            $status = 'sponsor';\\n            $rank = 5;\\n        } elseif ($monthlyContribution > 29 || $yearlyContribution > 700) {\\n            $status = 'sponsor';\\n            $rank = 4;\\n        } elseif ($monthlyContribution > 14.5 || $yearlyContribution > 500) {\\n            $status = 'backerPlus';\\n            $rank = 3;\\n        } elseif ($monthlyContribution > 4.5 || $yearlyContribution > 80) {\\n            $status = 'backer';\\n            $rank = 2;\\n        } elseif ($member['totalAmountDonated'] > 0) {\\n            $status = 'helper';\\n            $rank = 1;\\n        }\\n\\n        return array_merge($member, [\\n            'star' => ($monthlyContribution > 98 || $yearlyContribution > 800),\\n            'status' => $status,\\n            'rank' => $rank,\\n            'monthlyContribution' => $monthlyContribution,\\n            'yearlyContribution' => $yearlyContribution,\\n        ]);\\n    }, $list);\\n\\n    usort($list, static function (array $a, array $b): int {\\n        return ($b['star'] <=> $a['star'])\\n            ?: ($b['rank'] <=> $a['rank'])\\n            ?: ($b['monthlyContribution'] <=> $a['monthlyContribution'])\\n            ?: ($b['totalAmountDonated'] <=> $a['totalAmountDonated']);\\n    });\\n\\n    $membersByUrl = [];\\n    $output = '';\\n    $extra = '';\\n\\n    foreach ($list as $member) {\\n        $url = $member['website'] ?? $member['profile'];\\n\\n        if (isset($membersByUrl[$url]) || !\\\\in_array($member['status'], ['sponsor', 'backerPlus'], true)) {\\n            continue;\\n        }\\n\\n        $membersByUrl[$url] = $member;\\n        $href = htmlspecialchars($url);\\n        $src = $customSponsorImages[$member['MemberId'] ?? ''] ?? $member['image'] ?? (strtr($member['profile'], ['https:\/\/opencollective.com\/' => 'https:\/\/images.opencollective.com\/']).'\/avatar\/256.png');\\n        [$x, $y] = @getimagesize($src) ?: [0, 0];\\n        $validImage = ($x && $y);\\n        $src = $validImage ? htmlspecialchars($src) : 'https:\/\/opencollective.com\/static\/images\/default-guest-logo.svg';\\n        $height = match ($member['status']) {\\n            'sponsor' => 64,\\n            'backerPlus' => 42,\\n            'backer' => 32,\\n            default => 24,\\n        };\\n        $rel = match ($member['status']) {\\n            'sponsor', 'backerPlus' => '',\\n            default => ' rel=\\\"sponsored\\\"',\\n        };\\n\\n        $width = min($height * 2, $validImage ? round($x * $height \/ $y) : $height);\\n\\n        if (!str_contains($href, 'utm_source') && !preg_match('\/^https?:\\\\\/\\\\\/(?:www\\\\.)?(?:onlinekasyno-polis\\\\.pl|zonaminecraft\\\\.net|slotozilla\\\\.com)(\\\\\/.*)?\/', $href)) {\\n            $href .= (!str_contains($href, '?') ? '?' : '&amp;').'utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon';\\n        }\\n\\n        $title = getHtmlAttribute(($member['description'] ?? null) ?: $member['name']);\\n        $alt = getHtmlAttribute($member['name']);\\n\\n        if ($member['star']) {\\n            $width *= 1.5;\\n            $height *= 1.5;\\n        }\\n\\n        $link = \\\"\\\\n\\\".'<a title=\\\"'.$title.'\\\" href=\\\"'.$href.'\\\" target=\\\"_blank\\\"'.$rel.'>'.\\n            '<img alt=\\\"'.$alt.'\\\" src=\\\"'.$src.'\\\" width=\\\"'.$width.'\\\" height=\\\"'.$height.'\\\">'.\\n            '<\/a>';\\n\\n        if ($member['rank'] >= 5) {\\n            $output .= $link;\\n\\n            continue;\\n        }\\n\\n        $extra .= $link;\\n    }\\n\\n    $github = [\\n        8343178 => 'ssddanbrown',\\n    ];\\n\\n    foreach ($github as $avatar => $user) {\\n        $extra .= \\\"\\\\n\\\".'<a title=\\\"'.$user.'\\\" href=\\\"https:\/\/github.com\/'.$user.'\\\" target=\\\"_blank\\\">'.\\n            '<img alt=\\\"'.$user.'\\\" src=\\\"https:\/\/avatars.githubusercontent.com\/u\/'.$avatar.'?s=128&v=4\\\" width=\\\"42\\\" height=\\\"42\\\">'.\\n            '<\/a>';\\n    }\\n\\n    return $output.'<details><summary>See more<\/summary>'.$extra.'<\/details>';\\n}\\n\\nfile_put_contents('readme.md', preg_replace_callback(\\n    '\/(<!-- <open-collective-sponsors> -->)[\\\\s\\\\S]+(<!-- <\\\\\/open-collective-sponsors> -->)\/',\\n    static function (array $match): string {\\n        return $match[1].getOpenCollectiveSponsors().$match[2];\\n    },\\n    file_get_contents('readme.md'),\\n));\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/readme.md\",\"ext\":\"md\",\"size\":21767,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"# Carbon\\n\\n[![Latest Stable Version](https:\/\/img.shields.io\/packagist\/v\/nesbot\/carbon.svg?style=flat-square)](https:\/\/packagist.org\/packages\/nesbot\/carbon)\\n[![Total Downloads](https:\/\/img.shields.io\/packagist\/dt\/nesbot\/carbon.svg?style=flat-square)](https:\/\/packagist.org\/packages\/nesbot\/carbon)\\n[![GitHub Actions](https:\/\/img.shields.io\/endpoint.svg?url=https%3A%2F%2Factions-badge.atrox.dev%2FCarbonPHP%2Fcarbon%2Fbadge&style=flat-square&label=Build&logo=none)](https:\/\/github.com\/CarbonPHP\/carbon\/actions)\\n[![codecov.io](https:\/\/img.shields.io\/codecov\/c\/github\/CarbonPHP\/carbon.svg?style=flat-square)](https:\/\/codecov.io\/github\/CarbonPHP\/carbon\/actions?branch=master)\\n\\nAn international PHP extension for DateTime. [https:\/\/carbon.nesbot.com](https:\/\/carbon.nesbot.com)\\n\\n> [!NOTE]  \\n> We're migrating the repository from [briannesbitt\/Carbon](https:\/\/github.com\/briannesbitt\/Carbon) to [CarbonPHP\/carbon](https:\/\/github.com\/CarbonPHP\/carbon),\\n> which means if you're looking specific issues\/pull-requests, you may have to search both. No other impact as code on both will be kept up to date. \\n\\n```php\\n<?php\\n\\nuse Carbon\\\\Carbon;\\n\\nprintf(\\\"Right now is %s\\\", Carbon::now()->toDateTimeString());\\nprintf(\\\"Right now in Vancouver is %s\\\", Carbon::now('America\/Vancouver'));  \/\/implicit __toString()\\n$tomorrow = Carbon::now()->addDay();\\n$lastWeek = Carbon::now()->subWeek();\\n\\n$officialDate = Carbon::now()->toRfc2822String();\\n\\n$howOldAmI = Carbon::createFromDate(1975, 5, 21)->age;\\n\\n$noonTodayLondonTime = Carbon::createFromTime(12, 0, 0, 'Europe\/London');\\n\\n$internetWillBlowUpOn = Carbon::create(2038, 01, 19, 3, 14, 7, 'GMT');\\n\\n\/\/ Don't really want this to happen so mock now\\nCarbon::setTestNow(Carbon::createFromDate(2000, 1, 1));\\n\\n\/\/ comparisons are always done in UTC\\nif (Carbon::now()->gte($internetWillBlowUpOn)) {\\n    die();\\n}\\n\\n\/\/ Phew! Return to normal behaviour\\nCarbon::setTestNow();\\n\\nif (Carbon::now()->isWeekend()) {\\n    echo 'Party!';\\n}\\n\/\/ Over 200 languages (and over 500 regional variants) supported:\\necho Carbon::now()->subMinutes(2)->diffForHumans(); \/\/ '2 minutes ago'\\necho Carbon::now()->subMinutes(2)->locale('zh_CN')->diffForHumans(); \/\/ '2\u5206\u949f\u524d'\\necho Carbon::parse('2019-07-23 14:51')->isoFormat('LLLL'); \/\/ 'Tuesday, July 23, 2019 2:51 PM'\\necho Carbon::parse('2019-07-23 14:51')->locale('fr_FR')->isoFormat('LLLL'); \/\/ 'mardi 23 juillet 2019 14:51'\\n\\n\/\/ ... but also does 'from now', 'after' and 'before'\\n\/\/ rolling up to seconds, minutes, hours, days, months, years\\n\\n$daysSinceEpoch = Carbon::createFromTimestamp(0)->diffInDays(); \/\/ something such as:\\n                                                                \/\/ 19817.6771\\n$daysUntilInternetBlowUp = $internetWillBlowUpOn->diffInDays(); \/\/ Negative value since it's in the future:\\n                                                                \/\/ -5037.4560\\n\\n\/\/ Without parameter, difference is calculated from now, but doing $a->diff($b)\\n\/\/ it will count time from $a to $b.\\nCarbon::createFromTimestamp(0)->diffInDays($internetWillBlowUpOn); \/\/ 24855.1348\\n```\\n\\n## Installation\\n\\n### With Composer\\n\\n```\\n$ composer require nesbot\/carbon\\n```\\n\\n```json\\n{\\n    \\\"require\\\": {\\n        \\\"nesbot\/carbon\\\": \\\"^3\\\"\\n    }\\n}\\n```\\n\\n```php\\n<?php\\nrequire 'vendor\/autoload.php';\\n\\nuse Carbon\\\\Carbon;\\n\\nprintf(\\\"Now: %s\\\", Carbon::now());\\n```\\n\\n### Without Composer\\n\\nWhy are you not using [composer](https:\/\/getcomposer.org\/)? Download the Carbon [latest release](https:\/\/github.com\/CarbonPHP\/carbon\/releases) and put the contents of the ZIP archive into a directory in your project. Then require the file `autoload.php` to get all classes and dependencies loaded on need.\\n\\n```php\\n<?php\\nrequire 'path-to-Carbon-directory\/autoload.php';\\n\\nuse Carbon\\\\Carbon;\\n\\nprintf(\\\"Now: %s\\\", Carbon::now());\\n```\\n\\n## Documentation\\n\\n[https:\/\/carbon.nesbot.com\/docs](https:\/\/carbon.nesbot.com\/docs)\\n\\n## Security contact information\\n\\nTo report a security vulnerability, please use the\\n[Tidelift security contact](https:\/\/tidelift.com\/security).\\nTidelift will coordinate the fix and disclosure.\\n\\n## Credits\\n\\n### Contributors\\n\\nThis project exists thanks to all the people who contribute. \\n\\n<a href=\\\"https:\/\/github.com\/CarbonPHP\/carbon\/graphs\/contributors\\\" target=\\\"_blank\\\"><img src=\\\"https:\/\/opencollective.com\/Carbon\/contributors.svg?width=890&button=false\\\" \/><\/a>\\n\\n### Translators\\n\\n[Thanks to people helping us to translate Carbon in so many languages](https:\/\/carbon.nesbot.com\/contribute\/translators\/)\\n\\n### Sponsors\\n\\nSupport this project by becoming a sponsor. Your logo will show up here with a link to your website.\\n\\n<!-- <open-collective-sponsors> -->\\n<a title=\\\"Por\u00f3wnanie kasyn online w Polsce. Darmowe automaty online.\\\" href=\\\"https:\/\/onlinekasyno-polis.pl\/\\\" target=\\\"_blank\\\"><img alt=\\\"Online Kasyno Polis\\\" src=\\\"https:\/\/opencollective-production.s3.us-west-1.amazonaws.com\/account-avatar\/12fe53d4-b2e4-4601-b9ea-7b652c414a38\/274px%20274px-2.png\\\" width=\\\"96\\\" height=\\\"96\\\"><\/a>\\n<a title=\\\"\u041e\u043d\u043b\u0430\u0439\u043d \u043a\u0430\u0437\u0438\u043d\u043e 777 \u0423\u043a\u0440\u0430\u0457\u043d\u0430\\\" href=\\\"https:\/\/777.ua\/?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"\u041e\u043d\u043b\u0430\u0439\u043d \u043a\u0430\u0437\u0438\u043d\u043e 777\\\" src=\\\"https:\/\/opencollective-production.s3.us-west-1.amazonaws.com\/account-avatar\/7e572d50-1ce8-4d69-ae12-86cc80371373\/ok-ua-777.png\\\" width=\\\"96\\\" height=\\\"96\\\"><\/a>\\n<a title=\\\"Best non Gamstop sites in the UK\\\" href=\\\"https:\/\/www.pieria.co.uk\/?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"Best non Gamstop sites in the UK\\\" src=\\\"https:\/\/opencollective-production.s3.us-west-1.amazonaws.com\/account-avatar\/34e340b8-e1de-4932-8a76-1b3ce2ec7ee8\/logo_white%20bg%20(8).png\\\" width=\\\"96\\\" height=\\\"96\\\"><\/a>\\n<a title=\\\"Non GamStop Bookies UK\\\" href=\\\"https:\/\/netto.co.uk\/betting-sites-not-on-gamstop\/?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"Non GamStop Bookies UK\\\" src=\\\"https:\/\/opencollective-production.s3.us-west-1.amazonaws.com\/account-avatar\/51bfaa05-02b3-4cd9-b1a4-9d0d8f34cbae\/%D0%97%D0%BD%D1%96%D0%BC%D0%BE%D0%BA%20%D0%B5%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%202025-07-04%20%D0%BE%2015.21.16%20(1)%20(1)%20(1).jpg\\\" width=\\\"126\\\" height=\\\"96\\\"><\/a>\\n<a title=\\\"Trusted last mile route planning and route optimization\\\" href=\\\"https:\/\/route4me.com\/?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"Route4Me Route Planner\\\" src=\\\"https:\/\/opencollective-production.s3.us-west-1.amazonaws.com\/account-avatar\/237386c3-48a2-47c6-97ac-5f888cdb4cda\/Route4MeIconLogo.png\\\" width=\\\"96\\\" height=\\\"96\\\"><\/a>\\n<a title=\\\"gaia-wines.gr\\\" href=\\\"https:\/\/www.gaia-wines.gr\/?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"gaia-wines.gr\\\" src=\\\"https:\/\/opencollective-production.s3.us-west-1.amazonaws.com\/account-avatar\/a9b971ee-db5f-4400-8c4b-76cf9bc35015\/IMAGE%202024-06-14%2013%3A54%3A14.jpg\\\" width=\\\"96\\\" height=\\\"96\\\"><\/a>\\n<a title=\\\"\u0421\u0442\u0430\u0432\u043a\u0438 \u043d\u0430 \u0441\u043f\u043e\u0440\u0442, \u0411\u041a \u0432 \u0423\u043a\u0440\u0430\u0457\u043d\u0456\\\" href=\\\"https:\/\/betking.com.ua\/sports-book\/?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"\u0411\u0443\u043a\u043c\u0435\u043a\u0435\u0440\\\" src=\\\"https:\/\/opencollective-production.s3.us-west-1.amazonaws.com\/account-avatar\/065e61d2-f890-42db-b06c-8d40b39b2f0e\/bk.jpg\\\" width=\\\"96\\\" height=\\\"96\\\"><\/a>\\n<a title=\\\"Best Casinos not on Gamstop in the UK 2025\\\" href=\\\"https:\/\/www.vso.org.uk\/?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"best non Gamstop casinos\\\" src=\\\"https:\/\/opencollective-production.s3.us-west-1.amazonaws.com\/account-avatar\/3f48874e-f2f6-4062-a2a2-1500677ee3d9\/125%D1%85125%20(1).jpg\\\" width=\\\"96\\\" height=\\\"96\\\"><\/a>\\n<a title=\\\"#1 Guide To Online Gambling In Canada\\\" href=\\\"https:\/\/casinohex.org\/canada\/?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"CasinoHex Canada\\\" src=\\\"https:\/\/opencollective-production.s3.us-west-1.amazonaws.com\/79fdbcc0-a997-11eb-abbc-25e48b63c6dc.jpg\\\" width=\\\"127.5\\\" height=\\\"96\\\"><\/a>\\n<a title=\\\"Real Money Pokies\\\" href=\\\"https:\/\/onlinecasinoskiwi.co.nz\/real-money-pokies\/?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"Real Money Pokies\\\" src=\\\"https:\/\/opencollective-production.s3.us-west-1.amazonaws.com\/account-avatar\/d0f7382e-32ea-4425-a8c4-3019f9ed501c\/NZ_logo%20(6)%20(2).jpg\\\" width=\\\"96\\\" height=\\\"96\\\"><\/a>\\n<a title=\\\"\u041e\u043d\u043b\u0430\u0439\u043d \u043a\u0430\u0437\u0438\u043d\u043e \u0442\u0430 \u0411\u041a (\u0441\u0442\u0430\u0432\u043a\u0438 \u043d\u0430 \u0441\u043f\u043e\u0440\u0442) \u0432 \u0423\u043a\u0440\u0430\u0457\u043d\u0456\\\" href=\\\"https:\/\/betking.com.ua\/?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"Betking \u043a\u0430\u0437\u0438\u043d\u043e\\\" src=\\\"https:\/\/opencollective-production.s3.us-west-1.amazonaws.com\/account-avatar\/08587758-582c-4136-aba5-2519230960d3\/betking.jpg\\\" width=\\\"64\\\" height=\\\"64\\\"><\/a>\\n<a title=\\\"WestNews \u2013  \u043f\u0440\u043e\u0435\u043a\u0442 \u0410\u043b\u0435\u043a\u0441\u0430\u043d\u0434\u0440\u0430 \u041f\u043e\u0431\u0435\u0434\u044b \u043e \u0433\u0435\u043c\u0431\u043b\u0438\u043d\u0433\u0435 \u0438 \u043e\u043d\u043b\u0430\u0439\u043d-\u043a\u0430\u0437\u0438\u043d\u043e \u0432 \u0423\u043a\u0440\u0430\u0438\u043d\u0435, \u043f\u0440\u0435\u0434\u043b\u0430\u0433\u0430\u044e\u0449\u0438\u0439 \u043d\u043e\u0432\u043e\u0441\u0442\u0438, \u043e\u0431\u0437\u043e\u0440\u044b, \u0440\u0435\u0439\u0442\u0438\u043d\u0433\u0438 \u0438 \u0433\u0438\u0434\u044b \u043f\u043e \u0438\u0433\u043e\u0440\u043d\u044b\u043c \u0437\u0430\u0432\u0435\u0434\u0435\u043d\u0438\u044f\u043c.\\\" href=\\\"https:\/\/westnews.com.ua\/?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"WestNews \u043e\u043d\u043b\u0430\u0439\u043d \u043a\u0430\u0437\u0438\u043d\u043e \u0423\u043a\u0440\u0430\u0438\u043d\u044b\\\" src=\\\"https:\/\/opencollective-production.s3.us-west-1.amazonaws.com\/account-avatar\/7fae83dd-0d53-42f7-b63c-d7062a86ccb1\/3502ab17-a150-40e1-8f01-c26ff60c4cf8.png\\\" width=\\\"64\\\" height=\\\"64\\\"><\/a>\\n<a title=\\\"UK casinos not on GamStop\\\" href=\\\"https:\/\/www.stjames-theatre.co.uk\/?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"UK casinos not on GamStop\\\" src=\\\"https:\/\/opencollective-production.s3.us-west-1.amazonaws.com\/account-avatar\/34e5e82e-2121-4082-a321-050dca381d6c\/%D0%97%D0%BD%D1%96%D0%BC%D0%BE%D0%BA%20%D0%B5%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%202025-01-10%20%D0%BE%2015.29.42%20(1)%20(1).jpg\\\" width=\\\"64\\\" height=\\\"64\\\"><\/a><details><summary>See more<\/summary>\\n<a title=\\\"OnlineCasinosSpelen\\\" href=\\\"https:\/\/onlinecasinosspelen.com?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"OnlineCasinosSpelen\\\" src=\\\"https:\/\/logo.clearbit.com\/onlinecasinosspelen.com\\\" width=\\\"64\\\" height=\\\"64\\\"><\/a>\\n<a title=\\\"Betwinner is an online bookmaker offering sports betting, casino games, and more.\\\" href=\\\"https:\/\/guidebook.betwinner.com\/?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"Guidebook.BetWinner\\\" src=\\\"https:\/\/opencollective-production.s3.us-west-1.amazonaws.com\/account-avatar\/82cab29a-7002-4924-83bf-2eecb03d07c4\/0x0.png\\\" width=\\\"64\\\" height=\\\"64\\\"><\/a>\\n<a title=\\\"\u041e\u043d\u043b\u0430\u0439\u043d \u043a\u0430\u0437\u0438\u043d\u043e casino.ua\\\" href=\\\"https:\/\/casino.ua\/?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"\u041e\u043d\u043b\u0430\u0439\u043d \u043a\u0430\u0437\u0438\u043d\u043e casino.ua\\\" src=\\\"https:\/\/opencollective-production.s3.us-west-1.amazonaws.com\/account-avatar\/32790ee6-245b-45bd-acf7-7a661fe2cf9f\/logo.png\\\" width=\\\"64\\\" height=\\\"64\\\"><\/a>\\n<a title=\\\"Best PayID Pokies in Australia\\\" href=\\\"https:\/\/payid-gambler.net\/?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"PayIDGambler\\\" src=\\\"https:\/\/opencollective-production.s3.us-west-1.amazonaws.com\/account-avatar\/b120ff74-a4cc-4e25-a96f-2b040d60de14\/payidgambler.png\\\" width=\\\"64\\\" height=\\\"64\\\"><\/a>\\n<a title=\\\"Legal-casino.net \u2013 \u043d\u0435\u0437\u0430\u043b\u0435\u0436\u043d\u0438\u0439 \u0456\u043d\u0442\u0435\u0440\u043d\u0435\u0442-\u043f\u043e\u0440\u0442\u0430\u043b, \u043f\u0440\u0438\u0441\u0432\u044f\u0447\u0435\u043d\u0438\u0439 \u043b\u0456\u0446\u0435\u043d\u0437\u0456\u0439\u043d\u0438\u043c \u043e\u043d\u043b\u0430\u0439\u043d \u043a\u0430\u0437\u0438\u043d\u043e \u0423\u043a\u0440\u0430\u0457\u043d\u0438 \u0442\u0430 \u0430\u0437\u0430\u0440\u0442\u043d\u0438\u043c \u0456\u0433\u0440\u0430\u043c \u0432 \u0456\u043d\u0442\u0435\u0440\u043d\u0435\u0442\u0456. \u041d\u0430 \u044f\u043a\u043e\u043c\u0443 \u043d\u0435 \u043f\u0440\u043e\u0432\u043e\u0434\u044f\u0442\u044c\u0441\u044f \u0456\u0433\u0440\u0438 \u043d\u0430 \u0440\u0435\u0430\u043b\u044c\u043d\u0456 \u0447\u0438 \u0432\u0456\u0440\u0442\u0443\u0430\u043b\u044c\u043d\u0456 \u0433\u0440\u043e\u0448\u0456.\\\" href=\\\"https:\/\/legal-casino.net\/?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"Legal Casino\\\" src=\\\"https:\/\/opencollective-production.s3.us-west-1.amazonaws.com\/account-avatar\/79978436-a1cb-42f1-8269-d495b232934a\/legal-casino.jpg\\\" width=\\\"64\\\" height=\\\"64\\\"><\/a>\\n<a title=\\\"Playfortune.net.br\\\" href=\\\"https:\/\/playfortune.net.br\/?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"Playfortune.net.br\\\" src=\\\"https:\/\/logo.clearbit.com\/playfortune.net.br\\\" width=\\\"64\\\" height=\\\"64\\\"><\/a>\\n<a title=\\\"https:\/\/play-fortune.pl\/kasyno\/z-minimalnym-depozytem\/\\\" href=\\\"https:\/\/play-fortune.pl\/kasyno\/z-minimalnym-depozytem\/?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"https:\/\/play-fortune.pl\/kasyno\/z-minimalnym-depozytem\/\\\" src=\\\"https:\/\/opencollective-production.s3.us-west-1.amazonaws.com\/account-avatar\/cbeea308-5148-4f6c-ac6e-dbfa029aadd1\/PL.png\\\" width=\\\"64\\\" height=\\\"64\\\"><\/a>\\n<a title=\\\"Best-betting.net is an Indian website where you can always find interesting, useful, and up-to-date information about cricket and other sports. Additionally, on our portal, you can explore predictions and betting opportunities for the most exciting sports\\\" href=\\\"https:\/\/best-betting.net\/?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"Best Betting\\\" src=\\\"https:\/\/opencollective-production.s3.us-west-1.amazonaws.com\/account-avatar\/4b437e94-747c-4cf5-be67-d11bf8472d76\/bestbetting-logo-cover.png\\\" width=\\\"64\\\" height=\\\"64\\\"><\/a>\\n<a title=\\\"Slots not on GamStop\\\" href=\\\"https:\/\/nogamstopcasinos.uk\/?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"Slots not on GamStop\\\" src=\\\"https:\/\/opencollective-production.s3.us-west-1.amazonaws.com\/account-avatar\/3b5fedc2-f3e5-41f5-84a9-869e2cbeb632\/%D0%97%D0%BD%D1%96%D0%BC%D0%BE%D0%BA%20%D0%B5%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%202025-05-01%20%D0%BE%2019.38.02%20(1)%20(1)%20(1).jpg\\\" width=\\\"64\\\" height=\\\"64\\\"><\/a>\\n<a title=\\\"Offshore bookmakers review site.\\\" href=\\\"https:\/\/www.sportsbookreviewsonline.com\/?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"Sportsbook Reviews Online\\\" src=\\\"https:\/\/opencollective-production.s3.us-west-1.amazonaws.com\/account-avatar\/6d499f24-d669-4fc6-bb5f-b87184aa7963\/sportsbookreviewsonline_com.png\\\" width=\\\"64\\\" height=\\\"64\\\"><\/a>\\n<a title=\\\"\u0421\u0442\u0430\u0432\u043a\u0438 \u043d\u0430 \u0441\u043f\u043e\u0440\u0442 Favbet\\\" href=\\\"https:\/\/www.favbet.ua\/uk\/?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"\u0421\u0442\u0430\u0432\u043a\u0438 \u043d\u0430 \u0441\u043f\u043e\u0440\u0442 Favbet\\\" src=\\\"https:\/\/opencollective-production.s3.us-west-1.amazonaws.com\/account-avatar\/d86d313e-7b17-42fa-8b76-3f17fbf681a2\/favbet-logo.jpg\\\" width=\\\"64\\\" height=\\\"64\\\"><\/a>\\n<a title=\\\"inkedin\\\" href=\\\"https:\/\/inkedin.com?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"inkedin\\\" src=\\\"https:\/\/logo.clearbit.com\/inkedin.com\\\" width=\\\"42\\\" height=\\\"42\\\"><\/a>\\n<a title=\\\"Casino-portugal.pt\\\" href=\\\"https:\/\/casino-portugal.pt\/?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"Casino-portugal.pt\\\" src=\\\"https:\/\/logo.clearbit.com\/casino-portugal.pt\\\" width=\\\"42\\\" height=\\\"42\\\"><\/a>\\n<a title=\\\"Znajd\u017a najlepsze zak\u0142ady bukmacherskie w Polsce w 2023 roku. Probukmacher.pl to Twoje kompendium wiedzy na temat bukmacher\u00f3w!\\\" href=\\\"https:\/\/www.probukmacher.pl?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"Probukmacher\\\" src=\\\"https:\/\/opencollective-production.s3.us-west-1.amazonaws.com\/account-avatar\/caf50271-4560-4ffe-a434-ea15239168db\/Screenshot_1.png\\\" width=\\\"58\\\" height=\\\"42\\\"><\/a>\\n<a title=\\\"Get professional support for Carbon\\\" href=\\\"https:\/\/tidelift.com\/subscription\/pkg\/packagist-nesbot-carbon?utm_source=packagist-nesbot-carbon&amp;utm_medium=referral&amp;utm_campaign=docs\\\" target=\\\"_blank\\\"><img alt=\\\"Tidelift\\\" src=\\\"https:\/\/carbon.nesbot.com\/docs\/sponsors\/tidelift-brand.png\\\" width=\\\"84\\\" height=\\\"42\\\"><\/a>\\n<a title=\\\"\u0410\u043a\u0442\u0443\u0430\u043b\u044c\u043d\u0438\u0439 \u0442\u0430 \u043f\u043e\u0432\u043d\u043e\u0441\u043f\u0440\u0430\u0432\u043d\u0438\u0439 \u0440\u0435\u0439\u0442\u0438\u043d\u0433 \u043e\u043d\u043b\u0430\u0439\u043d \u043a\u0430\u0437\u0438\u043d\u043e \u0423\u043a\u0440\u0430\u0457\u043d\u0438, \u0491\u0440\u0443\u043d\u0442\u043e\u0432\u0430\u043d\u0438\u0439 \u043d\u0430 \u0432\u0456\u0434\u0433\u0443\u043a\u0430\u0445 \u0440\u0435\u0430\u043b\u044c\u043d\u0438\u0445 \u0433\u0440\u0430\u0432\u0446\u0456\u0432.\\\" href=\\\"https:\/\/uk.onlinecasino.in.ua\/?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"\u041e\u043d\u043b\u0430\u0439\u043d \u043a\u0430\u0437\u0438\u043d\u043e \u0423\u043a\u0440\u0430\u0457\u043d\u0438\\\" src=\\\"https:\/\/opencollective-production.s3.us-west-1.amazonaws.com\/c0b4b090-eef8-11ec-9cb7-0527a205b226.png\\\" width=\\\"42\\\" height=\\\"42\\\"><\/a>\\n<a title=\\\"Sites not on GamStop\\\" href=\\\"https:\/\/casinonotongamstop.uk\/?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"Sites not on GamStop\\\" src=\\\"https:\/\/opencollective-production.s3.us-west-1.amazonaws.com\/account-avatar\/5c5977b8-1e94-43d6-b2d7-4af25bb85dbd\/%D0%97%D0%BD%D1%96%D0%BC%D0%BE%D0%BA%20%D0%B5%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%202025-05-01%20%D0%BE%2015.08.38%20(1)%20(2).jpg\\\" width=\\\"68\\\" height=\\\"42\\\"><\/a>\\n<a title=\\\"\u041f\u0440\u043e\u0435\u043a\u0442 \u0441 \u043e\u0431\u0437\u043e\u0440\u0430\u043c\u0438 \u043b\u0435\u0433\u0430\u043b\u044c\u043d\u044b\u0445 \u043e\u043d\u043b\u0430\u0439\u043d \u043a\u0430\u0437\u0438\u043d\u043e \u0423\u043a\u0440\u0430\u0438\u043d\u044b. \u041c\u044b \u043f\u043e\u043c\u043e\u0433\u0430\u0435\u043c \u0432\u044b\u0431\u0440\u0430\u0442\u044c \u043b\u0443\u0447\u0448\u0435 \u043a\u0430\u0437\u0438\u043d\u043e \u043e\u043d\u043b\u0430\u0439\u043d \u0438\u0433\u0440\u043e\u043a\u0430\u043c.\\\" href=\\\"https:\/\/sportarena.com\/casino\/?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"\u041b\u0443\u0447\u0448\u0438\u0435 \u043e\u043d\u043b\u0430\u0439\u043d \u043a\u0430\u0437\u0438\u043d\u043e \u0423\u043a\u0440\u0430\u0438\u043d\u044b \u043d\u0430 Sportarena\\\" src=\\\"https:\/\/opencollective-production.s3.us-west-1.amazonaws.com\/account-avatar\/765475f7-3fea-4867-8f83-7b6f91b06128\/sportarena%20(1).png\\\" width=\\\"40\\\" height=\\\"42\\\"><\/a>\\n<a title=\\\"\u041f\u0440\u043e\u0454\u043a\u0442 \u0437 \u043e\u0433\u043b\u044f\u0434\u0430\u043c\u0438 \u043e\u043d\u043b\u0430\u0439\u043d \u043a\u0430\u0437\u0438\u043d\u043e \u0442\u0430 \u0457\u0445\u043d\u0456\u0445 \u0431\u043e\u043d\u0443\u0441\u0456\u0432. \u041d\u0430 \u0441\u0430\u0439\u0442\u0456 \u043c\u043e\u0436\u043d\u0430 \u0437\u043d\u0430\u0439\u0442\u0438 \u0430\u043a\u0442\u0443\u0430\u043b\u044c\u043d\u0456 \u043f\u0440\u043e\u043c\u043e\u043a\u043e\u0434\u0438 \u0442\u0430 \u0456\u043d\u0448\u0456 \u0431\u043e\u043d\u0443\u0441\u0438 \u043e\u043d\u043b\u0430\u0439\u043d \u043a\u0430\u0437\u0438\u043d\u043e \u0423\u043a\u0440\u0430\u0457\u043d\u0438.\\\" href=\\\"https:\/\/y-k.com.ua\/?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"\u041e\u043d\u043b\u0430\u0439\u043d \u043a\u0430\u0437\u0438\u043d\u043e \u0442\u0430 \u0457\u0445\u043d\u0456 \u0431\u043e\u043d\u0443\u0441\u0438 y-k.com.ua\\\" src=\\\"https:\/\/logo.clearbit.com\/y-k.com.ua\\\" width=\\\"42\\\" height=\\\"42\\\"><\/a>\\n<a title=\\\"Slots City\u00ae \u27a2 \u041b\u0443\u0447\u0448\u0435\u0435 \u043b\u0438\u0446\u0435\u043d\u0437\u0438\u043e\u043d\u043d\u043e \u043a\u0430\u0437\u0438\u043d\u043e \u043e\u043d\u043b\u0430\u0439\u043d \u0438 \u043e\u0444\u0444\u043b\u0430\u0439\u043d \u043d\u0430 \u0433\u0440\u0438\u0432\u043d\u044b \u0432 \u0423\u043a\u0440\u0430\u0438\u043d\u0435. \u3010 \u0411\u043e\u043b\u0435\u04351500 \u0438\u0433\u0440\u043e\u0432\u044b\u0445 \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u043e\u0432 \u0438 \u0441\u043b\u043e\u0442\u043e\u0432\u3011\u2705 \u041e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u043e \u0438 \u0411\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u043e\\\" href=\\\"https:\/\/slotscity.ua\/?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"Slots City\\\" src=\\\"https:\/\/opencollective-production.s3.us-west-1.amazonaws.com\/d7e298c0-7abe-11ed-8553-230872f5e54d.png\\\" width=\\\"59\\\" height=\\\"42\\\"><\/a>\\n<a title=\\\"WildWinz online casino\\\" href=\\\"https:\/\/wildwinz.com?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"WildWinz Casino\\\" src=\\\"https:\/\/opencollective-production.s3.us-west-1.amazonaws.com\/account-avatar\/ccfcee7c-775c-4d43-ba23-3f0d2969497b\/wildwinz.jpg\\\" width=\\\"42\\\" height=\\\"42\\\"><\/a>\\n<a title=\\\"\u0456\u0433\u0440\u043e\u0432\u0456 \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438 \u0431\u0435\u0442\u043a\u0456\u043d\u0433\\\" href=\\\"https:\/\/betking.com.ua\/games\/all-slots\/?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"\u0406\u0433\u0440\u043e\u0432\u0456 \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\\\" src=\\\"https:\/\/opencollective-production.s3.us-west-1.amazonaws.com\/account-avatar\/94601d07-3205-4c60-9c2d-9b8194dbefb7\/skg-blue.png\\\" width=\\\"42\\\" height=\\\"42\\\"><\/a>\\n<a title=\\\"Casinos not on Gamstop\\\" href=\\\"https:\/\/lgcnews.com\/?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"Non Gamstop Casinos\\\" src=\\\"https:\/\/lgcnews.com\/wp-content\/uploads\/2018\/01\/LGC-logo-v8-temp.png\\\" width=\\\"84\\\" height=\\\"42\\\"><\/a>\\n<a title=\\\"Slotozilla website\\\" href=\\\"https:\/\/www.slotozilla.com\/nz\/free-spins\\\" target=\\\"_blank\\\"><img alt=\\\"Slotozilla\\\" src=\\\"https:\/\/carbon.nesbot.com\/docs\/sponsors\/slotozilla.png\\\" width=\\\"42\\\" height=\\\"42\\\"><\/a>\\n<a title=\\\"Per tutte le ultime notizie sul gioco d&#039;azzardo Non AAMS, le recensioni e i bonus di iscrizione.\\\" href=\\\"https:\/\/casinononaams.online?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"casino non aams\\\" src=\\\"https:\/\/opencollective-production.s3.us-west-1.amazonaws.com\/account-avatar\/c60b92d1-590c-48a5-9527-fb0909431a86\/casino%20non%20aams%20icon.jpg\\\" width=\\\"42\\\" height=\\\"42\\\"><\/a>\\n<a title=\\\"Credit Zaim\\\" href=\\\"https:\/\/creditzaim.com.ua\/?utm_source=opencollective&amp;utm_medium=github&amp;utm_campaign=Carbon\\\" target=\\\"_blank\\\"><img alt=\\\"Credit Zaim\\\" src=\\\"https:\/\/opencollective-production.s3.us-west-1.amazonaws.com\/account-avatar\/a856ed4e-651d-47c9-aa7a-98059423b3a6\/creditzaim_logo.png\\\" width=\\\"42\\\" height=\\\"42\\\"><\/a>\\n<a title=\\\"ssddanbrown\\\" href=\\\"https:\/\/github.com\/ssddanbrown\\\" target=\\\"_blank\\\"><img alt=\\\"ssddanbrown\\\" src=\\\"https:\/\/avatars.githubusercontent.com\/u\/8343178?s=128&v=4\\\" width=\\\"42\\\" height=\\\"42\\\"><\/a><\/details><!-- <\/open-collective-sponsors> -->\\n\\n[[See all](https:\/\/carbon.nesbot.com\/#sponsors)]\\n\\n[[Become a sponsor via OpenCollective*](https:\/\/opencollective.com\/Carbon#sponsor)]\\n\\n[[Become a sponsor via GitHub*](https:\/\/github.com\/sponsors\/kylekatarnls)]\\n\\n<small>* This is a donation. No goods or services are expected in return. Any requests for refunds for those purposes will be rejected.<\/small>\\n\\n### Backers\\n\\nThank you to all our backers! \ud83d\ude4f\\n\\n<a href=\\\"https:\/\/opencollective.com\/Carbon#backers\\\" target=\\\"_blank\\\"><img src=\\\"https:\/\/opencollective.com\/Carbon\/backers.svg?width=890&version=2023-06-08-07-12\\\"><\/a>\\n\\n[[Become a backer](https:\/\/opencollective.com\/Carbon#backer)]\\n\\n## Carbon for enterprise\\n\\nAvailable as part of the Tidelift Subscription.\\n\\nThe maintainers of ``Carbon`` and thousands of other packages are working with Tidelift to deliver commercial support and maintenance for the open source dependencies you use to build your applications. Save time, reduce risk, and improve code health, while paying the maintainers of the exact dependencies you use. [Learn more.](https:\/\/tidelift.com\/subscription\/pkg\/packagist-nesbot-carbon?utm_source=packagist-nesbot-carbon&utm_medium=referral&utm_campaign=enterprise&utm_term=repo)\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/lazy\/Carbon\/TranslatorWeakType.php\",\"ext\":\"php\",\"size\":813,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon;\\n\\nif (!class_exists(LazyTranslator::class, false)) {\\n    class LazyTranslator extends AbstractTranslator\\n    {\\n        \/**\\n         * Returns the translation.\\n         *\\n         * @param string|null $id\\n         * @param array       $parameters\\n         * @param string|null $domain\\n         * @param string|null $locale\\n         *\\n         * @return string\\n         *\/\\n        public function trans($id, array $parameters = [], $domain = null, $locale = null)\\n        {\\n            return $this->translate($id, $parameters, $domain, $locale);\\n        }\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/lazy\/Carbon\/TranslatorStrongType.php\",\"ext\":\"php\",\"size\":1702,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon;\\n\\nuse Symfony\\\\Component\\\\Translation\\\\MessageCatalogueInterface;\\n\\nif (!class_exists(LazyTranslator::class, false)) {\\n    class LazyTranslator extends AbstractTranslator implements TranslatorStrongTypeInterface\\n    {\\n        public function trans(?string $id, array $parameters = [], ?string $domain = null, ?string $locale = null): string\\n        {\\n            return $this->translate($id, $parameters, $domain, $locale);\\n        }\\n\\n        public function getFromCatalogue(MessageCatalogueInterface $catalogue, string $id, string $domain = 'messages')\\n        {\\n            $messages = $this->getPrivateProperty($catalogue, 'messages');\\n\\n            if (isset($messages[$domain.MessageCatalogueInterface::INTL_DOMAIN_SUFFIX][$id])) {\\n                return $messages[$domain.MessageCatalogueInterface::INTL_DOMAIN_SUFFIX][$id];\\n            }\\n\\n            if (isset($messages[$domain][$id])) {\\n                return $messages[$domain][$id];\\n            }\\n\\n            $fallbackCatalogue = $this->getPrivateProperty($catalogue, 'fallbackCatalogue');\\n\\n            if ($fallbackCatalogue !== null) {\\n                return $this->getFromCatalogue($fallbackCatalogue, $id, $domain);\\n            }\\n\\n            return $id;\\n        }\\n\\n        private function getPrivateProperty($instance, string $field)\\n        {\\n            return (function (string $field) {\\n                return $this->$field;\\n            })->call($instance, $field);\\n        }\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/lazy\/Carbon\/ProtectedDatePeriod.php\",\"ext\":\"php\",\"size\":1913,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon;\\n\\nuse DatePeriod;\\n\\nif (!class_exists(DatePeriodBase::class, false)) {\\n    class DatePeriodBase extends DatePeriod\\n    {\\n        \/**\\n         * Period start in PHP < 8.2.\\n         *\\n         * @var CarbonInterface\\n         *\\n         * @deprecated PHP 8.2 this property is no longer in sync with the actual period start.\\n         *\/\\n        protected $start;\\n\\n        \/**\\n         * Period end in PHP < 8.2.\\n         *\\n         * @var CarbonInterface|null\\n         *\\n         * @deprecated PHP 8.2 this property is no longer in sync with the actual period end.\\n         *\/\\n        protected $end;\\n\\n        \/**\\n         * Period current iterated date in PHP < 8.2.\\n         *\\n         * @var CarbonInterface|null\\n         *\\n         * @deprecated PHP 8.2 this property is no longer in sync with the actual period current iterated date.\\n         *\/\\n        protected $current;\\n\\n        \/**\\n         * Period interval in PHP < 8.2.\\n         *\\n         * @var CarbonInterval|null\\n         *\\n         * @deprecated PHP 8.2 this property is no longer in sync with the actual period interval.\\n         *\/\\n        protected $interval;\\n\\n        \/**\\n         * Period recurrences in PHP < 8.2.\\n         *\\n         * @var int|float|null\\n         *\\n         * @deprecated PHP 8.2 this property is no longer in sync with the actual period recurrences.\\n         *\/\\n        protected $recurrences;\\n\\n        \/**\\n         * Period start included option in PHP < 8.2.\\n         *\\n         * @var bool\\n         *\\n         * @deprecated PHP 8.2 this property is no longer in sync with the actual period start included option.\\n         *\/\\n        protected $include_start_date;\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/lazy\/Carbon\/MessageFormatter\/MessageFormatterMapperStrongType.php\",\"ext\":\"php\",\"size\":768,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon\\\\MessageFormatter;\\n\\nuse Symfony\\\\Component\\\\Translation\\\\Formatter\\\\MessageFormatterInterface;\\n\\nif (!class_exists(LazyMessageFormatter::class, false)) {\\n    abstract class LazyMessageFormatter implements MessageFormatterInterface\\n    {\\n        public function format(string $message, string $locale, array $parameters = []): string\\n        {\\n            return $this->formatter->format(\\n                $message,\\n                $this->transformLocale($locale),\\n                $parameters\\n            );\\n        }\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/lazy\/Carbon\/MessageFormatter\/MessageFormatterMapperWeakType.php\",\"ext\":\"php\",\"size\":1138,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon\\\\MessageFormatter;\\n\\nuse Symfony\\\\Component\\\\Translation\\\\Formatter\\\\ChoiceMessageFormatterInterface;\\nuse Symfony\\\\Component\\\\Translation\\\\Formatter\\\\MessageFormatterInterface;\\n\\nif (!class_exists(LazyMessageFormatter::class, false)) {\\n    abstract class LazyMessageFormatter implements MessageFormatterInterface, ChoiceMessageFormatterInterface\\n    {\\n        abstract protected function transformLocale(?string $locale): ?string;\\n\\n        public function format($message, $locale, array $parameters = [])\\n        {\\n            return $this->formatter->format(\\n                $message,\\n                $this->transformLocale($locale),\\n                $parameters\\n            );\\n        }\\n\\n        public function choiceFormat($message, $number, $locale, array $parameters = [])\\n        {\\n            return $this->formatter->choiceFormat($message, $number, $locale, $parameters);\\n        }\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/lazy\/Carbon\/UnprotectedDatePeriod.php\",\"ext\":\"php\",\"size\":378,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon;\\n\\nuse DatePeriod;\\n\\nif (!class_exists(DatePeriodBase::class, false)) {\\n    class DatePeriodBase extends DatePeriod\\n    {\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Month.php\",\"ext\":\"php\",\"size\":2547,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon;\\n\\nuse Carbon\\\\Exceptions\\\\InvalidFormatException;\\n\\nenum Month: int\\n{\\n    \/\/ Using constants is only safe starting from PHP 8.2\\n    case January = 1; \/\/ CarbonInterface::JANUARY\\n    case February = 2; \/\/ CarbonInterface::FEBRUARY\\n    case March = 3; \/\/ CarbonInterface::MARCH\\n    case April = 4; \/\/ CarbonInterface::APRIL\\n    case May = 5; \/\/ CarbonInterface::MAY\\n    case June = 6; \/\/ CarbonInterface::JUNE\\n    case July = 7; \/\/ CarbonInterface::JULY\\n    case August = 8; \/\/ CarbonInterface::AUGUST\\n    case September = 9; \/\/ CarbonInterface::SEPTEMBER\\n    case October = 10; \/\/ CarbonInterface::OCTOBER\\n    case November = 11; \/\/ CarbonInterface::NOVEMBER\\n    case December = 12; \/\/ CarbonInterface::DECEMBER\\n\\n    public static function int(self|int|null $value): ?int\\n    {\\n        return $value instanceof self ? $value->value : $value;\\n    }\\n\\n    public static function fromNumber(int $number): self\\n    {\\n        $month = $number % CarbonInterface::MONTHS_PER_YEAR;\\n\\n        return self::from($month + ($month < 1 ? CarbonInterface::MONTHS_PER_YEAR : 0));\\n    }\\n\\n    public static function fromName(string $name, ?string $locale = null): self\\n    {\\n        try {\\n            return self::from(CarbonImmutable::parseFromLocale(\\\"$name 1\\\", $locale)->month);\\n        } catch (InvalidFormatException $exception) {\\n            \/\/ Possibly current language expect a dot after short name, but it's missing\\n            if ($locale !== null && !mb_strlen($name) < 4 && !str_ends_with($name, '.')) {\\n                try {\\n                    return self::from(CarbonImmutable::parseFromLocale(\\\"$name. 1\\\", $locale)->month);\\n                } catch (InvalidFormatException $e) {\\n                    \/\/ Throw previous error\\n                }\\n            }\\n\\n            throw $exception;\\n        }\\n    }\\n\\n    public function ofTheYear(CarbonImmutable|int|null $now = null): CarbonImmutable\\n    {\\n        if (\\\\is_int($now)) {\\n            return CarbonImmutable::create($now, $this->value);\\n        }\\n\\n        $modifier = $this->name.' 1st';\\n\\n        return $now?->modify($modifier) ?? new CarbonImmutable($modifier);\\n    }\\n\\n    public function locale(string $locale, ?CarbonImmutable $now = null): CarbonImmutable\\n    {\\n        return $this->ofTheYear($now)->locale($locale);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Translator.php\",\"ext\":\"php\",\"size\":833,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon;\\n\\nuse ReflectionMethod;\\nuse Symfony\\\\Component\\\\Translation;\\nuse Symfony\\\\Contracts\\\\Translation\\\\TranslatorInterface;\\n\\n$transMethod = new ReflectionMethod(\\n    class_exists(TranslatorInterface::class)\\n        ? TranslatorInterface::class\\n        : Translation\\\\Translator::class,\\n    'trans',\\n);\\n\\nrequire $transMethod->hasReturnType()\\n    ? __DIR__.'\/..\/..\/lazy\/Carbon\/TranslatorStrongType.php'\\n    : __DIR__.'\/..\/..\/lazy\/Carbon\/TranslatorWeakType.php';\\n\\nclass Translator extends LazyTranslator\\n{\\n    \/\/ Proxy dynamically loaded LazyTranslator in a static way\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Traits\/LocalFactory.php\",\"ext\":\"php\",\"size\":1626,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon\\\\Traits;\\n\\nuse Carbon\\\\Factory;\\nuse Carbon\\\\FactoryImmutable;\\nuse Carbon\\\\WrapperClock;\\nuse Closure;\\n\\n\/**\\n * Remember the factory that was the current at the creation of the object.\\n *\/\\ntrait LocalFactory\\n{\\n    \/**\\n     * The clock that generated the current instance (or FactoryImmutable::getDefaultInstance() if none)\\n     *\/\\n    private ?WrapperClock $clock = null;\\n\\n    public function getClock(): ?WrapperClock\\n    {\\n        return $this->clock;\\n    }\\n\\n    private function initLocalFactory(): void\\n    {\\n        $this->clock = FactoryImmutable::getCurrentClock();\\n    }\\n\\n    \/**\\n     * Trigger the given action using the local factory of the object, so it will be transmitted\\n     * to any object also using this trait and calling initLocalFactory() in its constructor.\\n     *\\n     * @template T\\n     *\\n     * @param Closure(): T $action\\n     *\\n     * @return T\\n     *\/\\n    private function transmitFactory(Closure $action): mixed\\n    {\\n        $previousClock = FactoryImmutable::getCurrentClock();\\n        FactoryImmutable::setCurrentClock($this->clock);\\n\\n        try {\\n            return $action();\\n        } finally {\\n            FactoryImmutable::setCurrentClock($previousClock);\\n        }\\n    }\\n\\n    private function getFactory(): Factory\\n    {\\n        return $this->getClock()?->getFactory() ?? FactoryImmutable::getDefaultInstance();\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Traits\/Comparison.php\",\"ext\":\"php\",\"size\":47200,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon\\\\Traits;\\n\\nuse BackedEnum;\\nuse BadMethodCallException;\\nuse Carbon\\\\CarbonConverterInterface;\\nuse Carbon\\\\CarbonInterface;\\nuse Carbon\\\\Exceptions\\\\BadComparisonUnitException;\\nuse Carbon\\\\FactoryImmutable;\\nuse Carbon\\\\Month;\\nuse Carbon\\\\Unit;\\nuse Carbon\\\\WeekDay;\\nuse Closure;\\nuse DateInterval;\\nuse DateTimeInterface;\\nuse InvalidArgumentException;\\n\\n\/**\\n * Trait Comparison.\\n *\\n * Comparison utils and testers. All the following methods return booleans.\\n * nowWithSameTz\\n *\\n * Depends on the following methods:\\n *\\n * @method static        resolveCarbon($date)\\n * @method static        copy()\\n * @method static        nowWithSameTz()\\n * @method static static yesterday($timezone = null)\\n * @method static static tomorrow($timezone = null)\\n *\/\\ntrait Comparison\\n{\\n    protected bool $endOfTime = false;\\n\\n    protected bool $startOfTime = false;\\n\\n    \/**\\n     * Determines if the instance is equal to another\\n     *\\n     * @example\\n     * ```\\n     * Carbon::parse('2018-07-25 12:45:16')->eq('2018-07-25 12:45:16'); \/\/ true\\n     * Carbon::parse('2018-07-25 12:45:16')->eq(Carbon::parse('2018-07-25 12:45:16')); \/\/ true\\n     * Carbon::parse('2018-07-25 12:45:16')->eq('2018-07-25 12:45:17'); \/\/ false\\n     * ```\\n     *\\n     * @see equalTo()\\n     *\/\\n    public function eq(DateTimeInterface|string $date): bool\\n    {\\n        return $this->equalTo($date);\\n    }\\n\\n    \/**\\n     * Determines if the instance is equal to another\\n     *\\n     * @example\\n     * ```\\n     * Carbon::parse('2018-07-25 12:45:16')->equalTo('2018-07-25 12:45:16'); \/\/ true\\n     * Carbon::parse('2018-07-25 12:45:16')->equalTo(Carbon::parse('2018-07-25 12:45:16')); \/\/ true\\n     * Carbon::parse('2018-07-25 12:45:16')->equalTo('2018-07-25 12:45:17'); \/\/ false\\n     * ```\\n     *\/\\n    public function equalTo(DateTimeInterface|string $date): bool\\n    {\\n        return $this == $this->resolveCarbon($date);\\n    }\\n\\n    \/**\\n     * Determines if the instance is not equal to another\\n     *\\n     * @example\\n     * ```\\n     * Carbon::parse('2018-07-25 12:45:16')->ne('2018-07-25 12:45:16'); \/\/ false\\n     * Carbon::parse('2018-07-25 12:45:16')->ne(Carbon::parse('2018-07-25 12:45:16')); \/\/ false\\n     * Carbon::parse('2018-07-25 12:45:16')->ne('2018-07-25 12:45:17'); \/\/ true\\n     * ```\\n     *\\n     * @see notEqualTo()\\n     *\/\\n    public function ne(DateTimeInterface|string $date): bool\\n    {\\n        return $this->notEqualTo($date);\\n    }\\n\\n    \/**\\n     * Determines if the instance is not equal to another\\n     *\\n     * @example\\n     * ```\\n     * Carbon::parse('2018-07-25 12:45:16')->notEqualTo('2018-07-25 12:45:16'); \/\/ false\\n     * Carbon::parse('2018-07-25 12:45:16')->notEqualTo(Carbon::parse('2018-07-25 12:45:16')); \/\/ false\\n     * Carbon::parse('2018-07-25 12:45:16')->notEqualTo('2018-07-25 12:45:17'); \/\/ true\\n     * ```\\n     *\/\\n    public function notEqualTo(DateTimeInterface|string $date): bool\\n    {\\n        return !$this->equalTo($date);\\n    }\\n\\n    \/**\\n     * Determines if the instance is greater (after) than another\\n     *\\n     * @example\\n     * ```\\n     * Carbon::parse('2018-07-25 12:45:16')->gt('2018-07-25 12:45:15'); \/\/ true\\n     * Carbon::parse('2018-07-25 12:45:16')->gt('2018-07-25 12:45:16'); \/\/ false\\n     * Carbon::parse('2018-07-25 12:45:16')->gt('2018-07-25 12:45:17'); \/\/ false\\n     * ```\\n     *\\n     * @see greaterThan()\\n     *\/\\n    public function gt(DateTimeInterface|string $date): bool\\n    {\\n        return $this->greaterThan($date);\\n    }\\n\\n    \/**\\n     * Determines if the instance is greater (after) than another\\n     *\\n     * @example\\n     * ```\\n     * Carbon::parse('2018-07-25 12:45:16')->greaterThan('2018-07-25 12:45:15'); \/\/ true\\n     * Carbon::parse('2018-07-25 12:45:16')->greaterThan('2018-07-25 12:45:16'); \/\/ false\\n     * Carbon::parse('2018-07-25 12:45:16')->greaterThan('2018-07-25 12:45:17'); \/\/ false\\n     * ```\\n     *\/\\n    public function greaterThan(DateTimeInterface|string $date): bool\\n    {\\n        return $this > $this->resolveCarbon($date);\\n    }\\n\\n    \/**\\n     * Determines if the instance is greater (after) than another\\n     *\\n     * @example\\n     * ```\\n     * Carbon::parse('2018-07-25 12:45:16')->isAfter('2018-07-25 12:45:15'); \/\/ true\\n     * Carbon::parse('2018-07-25 12:45:16')->isAfter('2018-07-25 12:45:16'); \/\/ false\\n     * Carbon::parse('2018-07-25 12:45:16')->isAfter('2018-07-25 12:45:17'); \/\/ false\\n     * ```\\n     *\\n     * @see greaterThan()\\n     *\/\\n    public function isAfter(DateTimeInterface|string $date): bool\\n    {\\n        return $this->greaterThan($date);\\n    }\\n\\n    \/**\\n     * Determines if the instance is greater (after) than or equal to another\\n     *\\n     * @example\\n     * ```\\n     * Carbon::parse('2018-07-25 12:45:16')->gte('2018-07-25 12:45:15'); \/\/ true\\n     * Carbon::parse('2018-07-25 12:45:16')->gte('2018-07-25 12:45:16'); \/\/ true\\n     * Carbon::parse('2018-07-25 12:45:16')->gte('2018-07-25 12:45:17'); \/\/ false\\n     * ```\\n     *\\n     * @see greaterThanOrEqualTo()\\n     *\/\\n    public function gte(DateTimeInterface|string $date): bool\\n    {\\n        return $this->greaterThanOrEqualTo($date);\\n    }\\n\\n    \/**\\n     * Determines if the instance is greater (after) than or equal to another\\n     *\\n     * @example\\n     * ```\\n     * Carbon::parse('2018-07-25 12:45:16')->greaterThanOrEqualTo('2018-07-25 12:45:15'); \/\/ true\\n     * Carbon::parse('2018-07-25 12:45:16')->greaterThanOrEqualTo('2018-07-25 12:45:16'); \/\/ true\\n     * Carbon::parse('2018-07-25 12:45:16')->greaterThanOrEqualTo('2018-07-25 12:45:17'); \/\/ false\\n     * ```\\n     *\/\\n    public function greaterThanOrEqualTo(DateTimeInterface|string $date): bool\\n    {\\n        return $this >= $this->resolveCarbon($date);\\n    }\\n\\n    \/**\\n     * Determines if the instance is less (before) than another\\n     *\\n     * @example\\n     * ```\\n     * Carbon::parse('2018-07-25 12:45:16')->lt('2018-07-25 12:45:15'); \/\/ false\\n     * Carbon::parse('2018-07-25 12:45:16')->lt('2018-07-25 12:45:16'); \/\/ false\\n     * Carbon::parse('2018-07-25 12:45:16')->lt('2018-07-25 12:45:17'); \/\/ true\\n     * ```\\n     *\\n     * @see lessThan()\\n     *\/\\n    public function lt(DateTimeInterface|string $date): bool\\n    {\\n        return $this->lessThan($date);\\n    }\\n\\n    \/**\\n     * Determines if the instance is less (before) than another\\n     *\\n     * @example\\n     * ```\\n     * Carbon::parse('2018-07-25 12:45:16')->lessThan('2018-07-25 12:45:15'); \/\/ false\\n     * Carbon::parse('2018-07-25 12:45:16')->lessThan('2018-07-25 12:45:16'); \/\/ false\\n     * Carbon::parse('2018-07-25 12:45:16')->lessThan('2018-07-25 12:45:17'); \/\/ true\\n     * ```\\n     *\/\\n    public function lessThan(DateTimeInterface|string $date): bool\\n    {\\n        return $this < $this->resolveCarbon($date);\\n    }\\n\\n    \/**\\n     * Determines if the instance is less (before) than another\\n     *\\n     * @example\\n     * ```\\n     * Carbon::parse('2018-07-25 12:45:16')->isBefore('2018-07-25 12:45:15'); \/\/ false\\n     * Carbon::parse('2018-07-25 12:45:16')->isBefore('2018-07-25 12:45:16'); \/\/ false\\n     * Carbon::parse('2018-07-25 12:45:16')->isBefore('2018-07-25 12:45:17'); \/\/ true\\n     * ```\\n     *\\n     * @see lessThan()\\n     *\/\\n    public function isBefore(DateTimeInterface|string $date): bool\\n    {\\n        return $this->lessThan($date);\\n    }\\n\\n    \/**\\n     * Determines if the instance is less (before) or equal to another\\n     *\\n     * @example\\n     * ```\\n     * Carbon::parse('2018-07-25 12:45:16')->lte('2018-07-25 12:45:15'); \/\/ false\\n     * Carbon::parse('2018-07-25 12:45:16')->lte('2018-07-25 12:45:16'); \/\/ true\\n     * Carbon::parse('2018-07-25 12:45:16')->lte('2018-07-25 12:45:17'); \/\/ true\\n     * ```\\n     *\\n     * @see lessThanOrEqualTo()\\n     *\/\\n    public function lte(DateTimeInterface|string $date): bool\\n    {\\n        return $this->lessThanOrEqualTo($date);\\n    }\\n\\n    \/**\\n     * Determines if the instance is less (before) or equal to another\\n     *\\n     * @example\\n     * ```\\n     * Carbon::parse('2018-07-25 12:45:16')->lessThanOrEqualTo('2018-07-25 12:45:15'); \/\/ false\\n     * Carbon::parse('2018-07-25 12:45:16')->lessThanOrEqualTo('2018-07-25 12:45:16'); \/\/ true\\n     * Carbon::parse('2018-07-25 12:45:16')->lessThanOrEqualTo('2018-07-25 12:45:17'); \/\/ true\\n     * ```\\n     *\/\\n    public function lessThanOrEqualTo(DateTimeInterface|string $date): bool\\n    {\\n        return $this <= $this->resolveCarbon($date);\\n    }\\n\\n    \/**\\n     * Determines if the instance is between two others.\\n     *\\n     * The third argument allow you to specify if bounds are included or not (true by default)\\n     * but for when you including\/excluding bounds may produce different results in your application,\\n     * we recommend to use the explicit methods ->betweenIncluded() or ->betweenExcluded() instead.\\n     *\\n     * @example\\n     * ```\\n     * Carbon::parse('2018-07-25')->between('2018-07-14', '2018-08-01'); \/\/ true\\n     * Carbon::parse('2018-07-25')->between('2018-08-01', '2018-08-20'); \/\/ false\\n     * Carbon::parse('2018-07-25')->between('2018-07-25', '2018-08-01'); \/\/ true\\n     * Carbon::parse('2018-07-25')->between('2018-07-25', '2018-08-01', false); \/\/ false\\n     * ```\\n     *\\n     * @param bool $equal Indicates if an equal to comparison should be done\\n     *\/\\n    public function between(DateTimeInterface|string $date1, DateTimeInterface|string $date2, bool $equal = true): bool\\n    {\\n        $date1 = $this->resolveCarbon($date1);\\n        $date2 = $this->resolveCarbon($date2);\\n\\n        if ($date1->greaterThan($date2)) {\\n            [$date1, $date2] = [$date2, $date1];\\n        }\\n\\n        if ($equal) {\\n            return $this >= $date1 && $this <= $date2;\\n        }\\n\\n        return $this > $date1 && $this < $date2;\\n    }\\n\\n    \/**\\n     * Determines if the instance is between two others, bounds included.\\n     *\\n     * @example\\n     * ```\\n     * Carbon::parse('2018-07-25')->betweenIncluded('2018-07-14', '2018-08-01'); \/\/ true\\n     * Carbon::parse('2018-07-25')->betweenIncluded('2018-08-01', '2018-08-20'); \/\/ false\\n     * Carbon::parse('2018-07-25')->betweenIncluded('2018-07-25', '2018-08-01'); \/\/ true\\n     * ```\\n     *\/\\n    public function betweenIncluded(DateTimeInterface|string $date1, DateTimeInterface|string $date2): bool\\n    {\\n        return $this->between($date1, $date2, true);\\n    }\\n\\n    \/**\\n     * Determines if the instance is between two others, bounds excluded.\\n     *\\n     * @example\\n     * ```\\n     * Carbon::parse('2018-07-25')->betweenExcluded('2018-07-14', '2018-08-01'); \/\/ true\\n     * Carbon::parse('2018-07-25')->betweenExcluded('2018-08-01', '2018-08-20'); \/\/ false\\n     * Carbon::parse('2018-07-25')->betweenExcluded('2018-07-25', '2018-08-01'); \/\/ false\\n     * ```\\n     *\/\\n    public function betweenExcluded(DateTimeInterface|string $date1, DateTimeInterface|string $date2): bool\\n    {\\n        return $this->between($date1, $date2, false);\\n    }\\n\\n    \/**\\n     * Determines if the instance is between two others\\n     *\\n     * @example\\n     * ```\\n     * Carbon::parse('2018-07-25')->isBetween('2018-07-14', '2018-08-01'); \/\/ true\\n     * Carbon::parse('2018-07-25')->isBetween('2018-08-01', '2018-08-20'); \/\/ false\\n     * Carbon::parse('2018-07-25')->isBetween('2018-07-25', '2018-08-01'); \/\/ true\\n     * Carbon::parse('2018-07-25')->isBetween('2018-07-25', '2018-08-01', false); \/\/ false\\n     * ```\\n     *\\n     * @param bool $equal Indicates if an equal to comparison should be done\\n     *\/\\n    public function isBetween(DateTimeInterface|string $date1, DateTimeInterface|string $date2, bool $equal = true): bool\\n    {\\n        return $this->between($date1, $date2, $equal);\\n    }\\n\\n    \/**\\n     * Determines if the instance is a weekday.\\n     *\\n     * @example\\n     * ```\\n     * Carbon::parse('2019-07-14')->isWeekday(); \/\/ false\\n     * Carbon::parse('2019-07-15')->isWeekday(); \/\/ true\\n     * ```\\n     *\/\\n    public function isWeekday(): bool\\n    {\\n        return !$this->isWeekend();\\n    }\\n\\n    \/**\\n     * Determines if the instance is a weekend day.\\n     *\\n     * @example\\n     * ```\\n     * Carbon::parse('2019-07-14')->isWeekend(); \/\/ true\\n     * Carbon::parse('2019-07-15')->isWeekend(); \/\/ false\\n     * ```\\n     *\/\\n    public function isWeekend(): bool\\n    {\\n        return \\\\in_array(\\n            $this->dayOfWeek,\\n            $this->transmitFactory(static fn () => static::getWeekendDays()),\\n            true,\\n        );\\n    }\\n\\n    \/**\\n     * Determines if the instance is yesterday.\\n     *\\n     * @example\\n     * ```\\n     * Carbon::yesterday()->isYesterday(); \/\/ true\\n     * Carbon::tomorrow()->isYesterday(); \/\/ false\\n     * ```\\n     *\/\\n    public function isYesterday(): bool\\n    {\\n        return $this->toDateString() === $this->transmitFactory(\\n            fn () => static::yesterday($this->getTimezone())->toDateString(),\\n        );\\n    }\\n\\n    \/**\\n     * Determines if the instance is today.\\n     *\\n     * @example\\n     * ```\\n     * Carbon::today()->isToday(); \/\/ true\\n     * Carbon::tomorrow()->isToday(); \/\/ false\\n     * ```\\n     *\/\\n    public function isToday(): bool\\n    {\\n        return $this->toDateString() === $this->nowWithSameTz()->toDateString();\\n    }\\n\\n    \/**\\n     * Determines if the instance is tomorrow.\\n     *\\n     * @example\\n     * ```\\n     * Carbon::tomorrow()->isTomorrow(); \/\/ true\\n     * Carbon::yesterday()->isTomorrow(); \/\/ false\\n     * ```\\n     *\/\\n    public function isTomorrow(): bool\\n    {\\n        return $this->toDateString() === $this->transmitFactory(\\n            fn () => static::tomorrow($this->getTimezone())->toDateString(),\\n        );\\n    }\\n\\n    \/**\\n     * Determines if the instance is in the future, ie. greater (after) than now.\\n     *\\n     * @example\\n     * ```\\n     * Carbon::now()->addHours(5)->isFuture(); \/\/ true\\n     * Carbon::now()->subHours(5)->isFuture(); \/\/ false\\n     * ```\\n     *\/\\n    public function isFuture(): bool\\n    {\\n        return $this->greaterThan($this->nowWithSameTz());\\n    }\\n\\n    \/**\\n     * Determines if the instance is in the past, ie. less (before) than now.\\n     *\\n     * @example\\n     * ```\\n     * Carbon::now()->subHours(5)->isPast(); \/\/ true\\n     * Carbon::now()->addHours(5)->isPast(); \/\/ false\\n     * ```\\n     *\/\\n    public function isPast(): bool\\n    {\\n        return $this->lessThan($this->nowWithSameTz());\\n    }\\n\\n    \/**\\n     * Determines if the instance is now or in the future, ie. greater (after) than or equal to now.\\n     *\\n     * @example\\n     * ```\\n     * Carbon::now()->isNowOrFuture(); \/\/ true\\n     * Carbon::now()->addHours(5)->isNowOrFuture(); \/\/ true\\n     * Carbon::now()->subHours(5)->isNowOrFuture(); \/\/ false\\n     * ```\\n     *\/\\n    public function isNowOrFuture(): bool\\n    {\\n        return $this->greaterThanOrEqualTo($this->nowWithSameTz());\\n    }\\n\\n    \/**\\n     * Determines if the instance is now or in the past, ie. less (before) than or equal to now.\\n     *\\n     * @example\\n     * ```\\n     * Carbon::now()->isNowOrPast(); \/\/ true\\n     * Carbon::now()->subHours(5)->isNowOrPast(); \/\/ true\\n     * Carbon::now()->addHours(5)->isNowOrPast(); \/\/ false\\n     * ```\\n     *\/\\n    public function isNowOrPast(): bool\\n    {\\n        return $this->lessThanOrEqualTo($this->nowWithSameTz());\\n    }\\n\\n    \/**\\n     * Determines if the instance is a leap year.\\n     *\\n     * @example\\n     * ```\\n     * Carbon::parse('2020-01-01')->isLeapYear(); \/\/ true\\n     * Carbon::parse('2019-01-01')->isLeapYear(); \/\/ false\\n     * ```\\n     *\/\\n    public function isLeapYear(): bool\\n    {\\n        return $this->rawFormat('L') === '1';\\n    }\\n\\n    \/**\\n     * Determines if the instance is a long year (using calendar year).\\n     *\\n     * \u26a0\ufe0f This method completely ignores month and day to use the numeric year number,\\n     * it's not correct if the exact date matters. For instance as `2019-12-30` is already\\n     * in the first week of the 2020 year, if you want to know from this date if ISO week\\n     * year 2020 is a long year, use `isLongIsoYear` instead.\\n     *\\n     * @example\\n     * ```\\n     * Carbon::create(2015)->isLongYear(); \/\/ true\\n     * Carbon::create(2016)->isLongYear(); \/\/ false\\n     * ```\\n     *\\n     * @see https:\/\/en.wikipedia.org\/wiki\/ISO_8601#Week_dates\\n     *\/\\n    public function isLongYear(): bool\\n    {\\n        return static::create($this->year, 12, 28, 0, 0, 0, $this->tz)->weekOfYear === static::WEEKS_PER_YEAR + 1;\\n    }\\n\\n    \/**\\n     * Determines if the instance is a long year (using ISO 8601 year).\\n     *\\n     * @example\\n     * ```\\n     * Carbon::parse('2015-01-01')->isLongIsoYear(); \/\/ true\\n     * Carbon::parse('2016-01-01')->isLongIsoYear(); \/\/ true\\n     * Carbon::parse('2016-01-03')->isLongIsoYear(); \/\/ false\\n     * Carbon::parse('2019-12-29')->isLongIsoYear(); \/\/ false\\n     * Carbon::parse('2019-12-30')->isLongIsoYear(); \/\/ true\\n     * ```\\n     *\\n     * @see https:\/\/en.wikipedia.org\/wiki\/ISO_8601#Week_dates\\n     *\/\\n    public function isLongIsoYear(): bool\\n    {\\n        return static::create($this->isoWeekYear, 12, 28, 0, 0, 0, $this->tz)->weekOfYear === 53;\\n    }\\n\\n    \/**\\n     * Compares the formatted values of the two dates.\\n     *\\n     * @example\\n     * ```\\n     * Carbon::parse('2019-06-13')->isSameAs('Y-d', Carbon::parse('2019-12-13')); \/\/ true\\n     * Carbon::parse('2019-06-13')->isSameAs('Y-d', Carbon::parse('2019-06-14')); \/\/ false\\n     * ```\\n     *\\n     * @param string                   $format date formats to compare.\\n     * @param DateTimeInterface|string $date   instance to compare with or null to use current day.\\n     *\/\\n    public function isSameAs(string $format, DateTimeInterface|string $date): bool\\n    {\\n        return $this->rawFormat($format) === $this->resolveCarbon($date)->rawFormat($format);\\n    }\\n\\n    \/**\\n     * Determines if the instance is in the current unit given.\\n     *\\n     * @example\\n     * ```\\n     * Carbon::parse('2019-01-13')->isSameUnit('year', Carbon::parse('2019-12-25')); \/\/ true\\n     * Carbon::parse('2018-12-13')->isSameUnit('year', Carbon::parse('2019-12-25')); \/\/ false\\n     * ```\\n     *\\n     * @param string                   $unit singular unit string\\n     * @param DateTimeInterface|string $date instance to compare with or null to use current day.\\n     *\\n     * @throws BadComparisonUnitException\\n     *\\n     * @return bool\\n     *\/\\n    public function isSameUnit(string $unit, DateTimeInterface|string $date): bool\\n    {\\n        if ($unit === \/* @call isSameUnit *\/ 'quarter') {\\n            $other = $this->resolveCarbon($date);\\n\\n            return $other->year === $this->year && $other->quarter === $this->quarter;\\n        }\\n\\n        $units = [\\n            \/\/ @call isSameUnit\\n            'year' => 'Y',\\n            \/\/ @call isSameUnit\\n            'month' => 'Y-n',\\n            \/\/ @call isSameUnit\\n            'week' => 'o-W',\\n            \/\/ @call isSameUnit\\n            'day' => 'Y-m-d',\\n            \/\/ @call isSameUnit\\n            'hour' => 'Y-m-d H',\\n            \/\/ @call isSameUnit\\n            'minute' => 'Y-m-d H:i',\\n            \/\/ @call isSameUnit\\n            'second' => 'Y-m-d H:i:s',\\n            \/\/ @call isSameUnit\\n            'milli' => 'Y-m-d H:i:s.v',\\n            \/\/ @call isSameUnit\\n            'millisecond' => 'Y-m-d H:i:s.v',\\n            \/\/ @call isSameUnit\\n            'micro' => 'Y-m-d H:i:s.u',\\n            \/\/ @call isSameUnit\\n            'microsecond' => 'Y-m-d H:i:s.u',\\n        ];\\n\\n        if (isset($units[$unit])) {\\n            return $this->isSameAs($units[$unit], $date);\\n        }\\n\\n        if (isset($this->$unit)) {\\n            return $this->resolveCarbon($date)->$unit === $this->$unit;\\n        }\\n\\n        if ($this->isLocalStrictModeEnabled()) {\\n            throw new BadComparisonUnitException($unit);\\n        }\\n\\n        return false;\\n    }\\n\\n    \/**\\n     * Determines if the instance is in the current unit given.\\n     *\\n     * @example\\n     * ```\\n     * Carbon::now()->isCurrentUnit('hour'); \/\/ true\\n     * Carbon::now()->subHours(2)->isCurrentUnit('hour'); \/\/ false\\n     * ```\\n     *\\n     * @param string $unit The unit to test.\\n     *\\n     * @throws BadMethodCallException\\n     *\/\\n    public function isCurrentUnit(string $unit): bool\\n    {\\n        return $this->{'isSame'.ucfirst($unit)}('now');\\n    }\\n\\n    \/**\\n     * Checks if the passed in date is in the same quarter as the instance quarter (and year if needed).\\n     *\\n     * @example\\n     * ```\\n     * Carbon::parse('2019-01-12')->isSameQuarter(Carbon::parse('2019-03-01')); \/\/ true\\n     * Carbon::parse('2019-01-12')->isSameQuarter(Carbon::parse('2019-04-01')); \/\/ false\\n     * Carbon::parse('2019-01-12')->isSameQuarter(Carbon::parse('2018-03-01')); \/\/ false\\n     * Carbon::parse('2019-01-12')->isSameQuarter(Carbon::parse('2018-03-01'), false); \/\/ true\\n     * ```\\n     *\\n     * @param DateTimeInterface|string $date       The instance to compare with or null to use current day.\\n     * @param bool                     $ofSameYear Check if it is the same month in the same year.\\n     *\\n     * @return bool\\n     *\/\\n    public function isSameQuarter(DateTimeInterface|string $date, bool $ofSameYear = true): bool\\n    {\\n        $date = $this->resolveCarbon($date);\\n\\n        return $this->quarter === $date->quarter && (!$ofSameYear || $this->isSameYear($date));\\n    }\\n\\n    \/**\\n     * Checks if the passed in date is in the same month as the instance\u00b4s month.\\n     *\\n     * @example\\n     * ```\\n     * Carbon::parse('2019-01-12')->isSameMonth(Carbon::parse('2019-01-01')); \/\/ true\\n     * Carbon::parse('2019-01-12')->isSameMonth(Carbon::parse('2019-02-01')); \/\/ false\\n     * Carbon::parse('2019-01-12')->isSameMonth(Carbon::parse('2018-01-01')); \/\/ false\\n     * Carbon::parse('2019-01-12')->isSameMonth(Carbon::parse('2018-01-01'), false); \/\/ true\\n     * ```\\n     *\\n     * @param DateTimeInterface|string $date       The instance to compare with or null to use the current date.\\n     * @param bool                     $ofSameYear Check if it is the same month in the same year.\\n     *\\n     * @return bool\\n     *\/\\n    public function isSameMonth(DateTimeInterface|string $date, bool $ofSameYear = true): bool\\n    {\\n        return $this->isSameAs($ofSameYear ? 'Y-m' : 'm', $date);\\n    }\\n\\n    \/**\\n     * Checks if this day is a specific day of the week.\\n     *\\n     * @example\\n     * ```\\n     * Carbon::parse('2019-07-17')->isDayOfWeek(Carbon::WEDNESDAY); \/\/ true\\n     * Carbon::parse('2019-07-17')->isDayOfWeek(Carbon::FRIDAY); \/\/ false\\n     * Carbon::parse('2019-07-17')->isDayOfWeek('Wednesday'); \/\/ true\\n     * Carbon::parse('2019-07-17')->isDayOfWeek('Friday'); \/\/ false\\n     * ```\\n     *\\n     * @param int|string $dayOfWeek\\n     *\\n     * @return bool\\n     *\/\\n    public function isDayOfWeek($dayOfWeek): bool\\n    {\\n        if (\\\\is_string($dayOfWeek) && \\\\defined($constant = static::class.'::'.strtoupper($dayOfWeek))) {\\n            $dayOfWeek = \\\\constant($constant);\\n        }\\n\\n        return $this->dayOfWeek === $dayOfWeek;\\n    }\\n\\n    \/**\\n     * Check if its the birthday. Compares the date\/month values of the two dates.\\n     *\\n     * @example\\n     * ```\\n     * Carbon::now()->subYears(5)->isBirthday(); \/\/ true\\n     * Carbon::now()->subYears(5)->subDay()->isBirthday(); \/\/ false\\n     * Carbon::parse('2019-06-05')->isBirthday(Carbon::parse('2001-06-05')); \/\/ true\\n     * Carbon::parse('2019-06-05')->isBirthday(Carbon::parse('2001-06-06')); \/\/ false\\n     * ```\\n     *\\n     * @param DateTimeInterface|string|null $date The instance to compare with or null to use current day.\\n     *\\n     * @return bool\\n     *\/\\n    public function isBirthday(DateTimeInterface|string|null $date = null): bool\\n    {\\n        return $this->isSameAs('md', $date ?? 'now');\\n    }\\n\\n    \/**\\n     * Check if today is the last day of the Month\\n     *\\n     * @example\\n     * ```\\n     * Carbon::parse('2019-02-28')->isLastOfMonth(); \/\/ true\\n     * Carbon::parse('2019-03-28')->isLastOfMonth(); \/\/ false\\n     * Carbon::parse('2019-03-30')->isLastOfMonth(); \/\/ false\\n     * Carbon::parse('2019-03-31')->isLastOfMonth(); \/\/ true\\n     * Carbon::parse('2019-04-30')->isLastOfMonth(); \/\/ true\\n     * ```\\n     *\/\\n    public function isLastOfMonth(): bool\\n    {\\n        return $this->day === $this->daysInMonth;\\n    }\\n\\n    \/**\\n     * Check if the instance is start of a given unit (tolerating a given interval).\\n     *\\n     * @example\\n     * ```\\n     * \/\/ Check if a date-time is the first 15 minutes of the hour it's in\\n     * Carbon::parse('2019-02-28 20:13:00')->isStartOfUnit(Unit::Hour, '15 minutes'); \/\/ true\\n     * ```\\n     *\/\\n    public function isStartOfUnit(\\n        Unit $unit,\\n        Unit|DateInterval|Closure|CarbonConverterInterface|string|null $interval = null,\\n        mixed ...$params,\\n    ): bool {\\n        $interval ??= match ($unit) {\\n            Unit::Day, Unit::Hour, Unit::Minute, Unit::Second, Unit::Millisecond, Unit::Microsecond => Unit::Microsecond,\\n            default => Unit::Day,\\n        };\\n\\n        $startOfUnit = $this->avoidMutation()->startOf($unit, ...$params);\\n        $startOfUnitDateTime = $startOfUnit->rawFormat('Y-m-d H:i:s.u');\\n        $maximumDateTime = $startOfUnit\\n            ->add($interval instanceof Unit ? '1  '.$interval->value : $interval)\\n            ->rawFormat('Y-m-d H:i:s.u');\\n\\n        if ($maximumDateTime < $startOfUnitDateTime) {\\n            return false;\\n        }\\n\\n        return $this->rawFormat('Y-m-d H:i:s.u') < $maximumDateTime;\\n    }\\n\\n    \/**\\n     * Check if the instance is end of a given unit (tolerating a given interval).\\n     *\\n     * @example\\n     * ```\\n     * \/\/ Check if a date-time is the last 15 minutes of the hour it's in\\n     * Carbon::parse('2019-02-28 20:13:00')->isEndOfUnit(Unit::Hour, '15 minutes'); \/\/ false\\n     * ```\\n     *\/\\n    public function isEndOfUnit(\\n        Unit $unit,\\n        Unit|DateInterval|Closure|CarbonConverterInterface|string|null $interval = null,\\n        mixed ...$params,\\n    ): bool {\\n        $interval ??= match ($unit) {\\n            Unit::Day, Unit::Hour, Unit::Minute, Unit::Second, Unit::Millisecond, Unit::Microsecond => Unit::Microsecond,\\n            default => Unit::Day,\\n        };\\n\\n        $endOfUnit = $this->avoidMutation()->endOf($unit, ...$params);\\n        $endOfUnitDateTime = $endOfUnit->rawFormat('Y-m-d H:i:s.u');\\n        $minimumDateTime = $endOfUnit\\n            ->sub($interval instanceof Unit ? '1  '.$interval->value : $interval)\\n            ->rawFormat('Y-m-d H:i:s.u');\\n\\n        if ($minimumDateTime > $endOfUnitDateTime) {\\n            return false;\\n        }\\n\\n        return $this->rawFormat('Y-m-d H:i:s.u') > $minimumDateTime;\\n    }\\n\\n    \/**\\n     * Determines if the instance is start of millisecond (first microsecond by default but interval can be customized).\\n     *\/\\n    public function isStartOfMillisecond(\\n        Unit|DateInterval|Closure|CarbonConverterInterface|string|null $interval = null,\\n    ): bool {\\n        return $this->isStartOfUnit(Unit::Millisecond, $interval);\\n    }\\n\\n    \/**\\n     * Determines if the instance is end of millisecond (last microsecond by default but interval can be customized).\\n     *\/\\n    public function isEndOfMillisecond(\\n        Unit|DateInterval|Closure|CarbonConverterInterface|string|null $interval = null,\\n    ): bool {\\n        return $this->isEndOfUnit(Unit::Millisecond, $interval);\\n    }\\n\\n    \/**\\n     * Determines if the instance is start of second (first microsecond by default but interval can be customized).\\n     *\/\\n    public function isStartOfSecond(\\n        Unit|DateInterval|Closure|CarbonConverterInterface|string|null $interval = null,\\n    ): bool {\\n        return $this->isStartOfUnit(Unit::Second, $interval);\\n    }\\n\\n    \/**\\n     * Determines if the instance is end of second (last microsecond by default but interval can be customized).\\n     *\/\\n    public function isEndOfSecond(\\n        Unit|DateInterval|Closure|CarbonConverterInterface|string|null $interval = null,\\n    ): bool {\\n        return $this->isEndOfUnit(Unit::Second, $interval);\\n    }\\n\\n    \/**\\n     * Determines if the instance is start of minute (first microsecond by default but interval can be customized).\\n     *\/\\n    public function isStartOfMinute(\\n        Unit|DateInterval|Closure|CarbonConverterInterface|string|null $interval = null,\\n    ): bool {\\n        return $this->isStartOfUnit(Unit::Minute, $interval);\\n    }\\n\\n    \/**\\n     * Determines if the instance is end of minute (last microsecond by default but interval can be customized).\\n     *\/\\n    public function isEndOfMinute(\\n        Unit|DateInterval|Closure|CarbonConverterInterface|string|null $interval = null,\\n    ): bool {\\n        return $this->isEndOfUnit(Unit::Minute, $interval);\\n    }\\n\\n    \/**\\n     * Determines if the instance is start of hour (first microsecond by default but interval can be customized).\\n     *\/\\n    public function isStartOfHour(\\n        Unit|DateInterval|Closure|CarbonConverterInterface|string|null $interval = null,\\n    ): bool {\\n        return $this->isStartOfUnit(Unit::Hour, $interval);\\n    }\\n\\n    \/**\\n     * Determines if the instance is end of hour (last microsecond by default but interval can be customized).\\n     *\/\\n    public function isEndOfHour(\\n        Unit|DateInterval|Closure|CarbonConverterInterface|string|null $interval = null,\\n    ): bool {\\n        return $this->isEndOfUnit(Unit::Hour, $interval);\\n    }\\n\\n    \/**\\n     * Check if the instance is start of day \/ midnight.\\n     *\\n     * @example\\n     * ```\\n     * Carbon::parse('2019-02-28 00:00:00')->isStartOfDay(); \/\/ true\\n     * Carbon::parse('2019-02-28 00:00:00.999999')->isStartOfDay(); \/\/ true\\n     * Carbon::parse('2019-02-28 00:00:01')->isStartOfDay(); \/\/ false\\n     * Carbon::parse('2019-02-28 00:00:00.000000')->isStartOfDay(true); \/\/ true\\n     * Carbon::parse('2019-02-28 00:00:00.000012')->isStartOfDay(true); \/\/ false\\n     * ```\\n     *\\n     * @param bool                                                           $checkMicroseconds check time at microseconds precision\\n     * @param Unit|DateInterval|Closure|CarbonConverterInterface|string|null $interval          if an interval is specified it will be used as precision\\n     *                                                                                          for instance with \\\"15 minutes\\\", it checks if current date-time\\n     *                                                                                          is in the last 15 minutes of the day, with Unit::Hour, it\\n     *                                                                                          checks if it's in the last hour of the day.\\n     *\/\\n    public function isStartOfDay(\\n        Unit|DateInterval|Closure|CarbonConverterInterface|string|bool $checkMicroseconds = false,\\n        Unit|DateInterval|Closure|CarbonConverterInterface|string|null $interval = null,\\n    ): bool {\\n        if ($checkMicroseconds === true) {\\n            @trigger_error(\\n                \\\"Since 3.8.0, it's deprecated to use \\\\$checkMicroseconds.\\\\n\\\".\\n                \\\"It will be removed in 4.0.0.\\\\n\\\".\\n                \\\"Instead, you should use either isStartOfDay(interval: Unit::Microsecond) or isStartOfDay(interval: Unit::Second)\\\\n\\\".\\n                'And you can now use any custom interval as precision, such as isStartOfDay(interval: \\\"15 minutes\\\")',\\n                \\\\E_USER_DEPRECATED,\\n            );\\n        }\\n\\n        if ($interval === null && !\\\\is_bool($checkMicroseconds)) {\\n            $interval = $checkMicroseconds;\\n        }\\n\\n        if ($interval !== null) {\\n            if ($interval instanceof Unit) {\\n                $interval = '1  '.$interval->value;\\n            }\\n\\n            $date = $this->rawFormat('Y-m-d');\\n            $time = $this->rawFormat('H:i:s.u');\\n            $maximum = $this->avoidMutation()->startOfDay()->add($interval);\\n            $maximumDate = $maximum->rawFormat('Y-m-d');\\n\\n            if ($date === $maximumDate) {\\n                return $time < $maximum->rawFormat('H:i:s.u');\\n            }\\n\\n            return $maximumDate > $date;\\n        }\\n\\n        \/* @var CarbonInterface $this *\/\\n        return $checkMicroseconds\\n            ? $this->rawFormat('H:i:s.u') === '00:00:00.000000'\\n            : $this->rawFormat('H:i:s') === '00:00:00';\\n    }\\n\\n    \/**\\n     * Check if the instance is end of day.\\n     *\\n     * @example\\n     * ```\\n     * Carbon::parse('2019-02-28 23:59:59.999999')->isEndOfDay(); \/\/ true\\n     * Carbon::parse('2019-02-28 23:59:59.123456')->isEndOfDay(); \/\/ true\\n     * Carbon::parse('2019-02-28 23:59:59')->isEndOfDay(); \/\/ true\\n     * Carbon::parse('2019-02-28 23:59:58.999999')->isEndOfDay(); \/\/ false\\n     * Carbon::parse('2019-02-28 23:59:59.999999')->isEndOfDay(true); \/\/ true\\n     * Carbon::parse('2019-02-28 23:59:59.123456')->isEndOfDay(true); \/\/ false\\n     * Carbon::parse('2019-02-28 23:59:59')->isEndOfDay(true); \/\/ false\\n     * ```\\n     *\\n     * @param bool                                                           $checkMicroseconds check time at microseconds precision\\n     * @param Unit|DateInterval|Closure|CarbonConverterInterface|string|null $interval          if an interval is specified it will be used as precision\\n     *                                                                                          for instance with \\\"15 minutes\\\", it checks if current date-time\\n     *                                                                                          is in the last 15 minutes of the day, with Unit::Hour, it\\n     *                                                                                          checks if it's in the last hour of the day.\\n     *\/\\n    public function isEndOfDay(\\n        Unit|DateInterval|Closure|CarbonConverterInterface|string|bool $checkMicroseconds = false,\\n        Unit|DateInterval|Closure|CarbonConverterInterface|string|null $interval = null,\\n    ): bool {\\n        if ($checkMicroseconds === true) {\\n            @trigger_error(\\n                \\\"Since 3.8.0, it's deprecated to use \\\\$checkMicroseconds.\\\\n\\\".\\n                \\\"It will be removed in 4.0.0.\\\\n\\\".\\n                \\\"Instead, you should use either isEndOfDay(interval: Unit::Microsecond) or isEndOfDay(interval: Unit::Second)\\\\n\\\".\\n                'And you can now use any custom interval as precision, such as isEndOfDay(interval: \\\"15 minutes\\\")',\\n                \\\\E_USER_DEPRECATED,\\n            );\\n        }\\n\\n        if ($interval === null && !\\\\is_bool($checkMicroseconds)) {\\n            $interval = $checkMicroseconds;\\n        }\\n\\n        if ($interval !== null) {\\n            $date = $this->rawFormat('Y-m-d');\\n            $time = $this->rawFormat('H:i:s.u');\\n            $minimum = $this->avoidMutation()\\n                ->endOfDay()\\n                ->sub($interval instanceof Unit ? '1  '.$interval->value : $interval);\\n            $minimumDate = $minimum->rawFormat('Y-m-d');\\n\\n            if ($date === $minimumDate) {\\n                return $time > $minimum->rawFormat('H:i:s.u');\\n            }\\n\\n            return $minimumDate < $date;\\n        }\\n\\n        \/* @var CarbonInterface $this *\/\\n        return $checkMicroseconds\\n            ? $this->rawFormat('H:i:s.u') === '23:59:59.999999'\\n            : $this->rawFormat('H:i:s') === '23:59:59';\\n    }\\n\\n    \/**\\n     * Determines if the instance is start of week (first day by default but interval can be customized).\\n     *\\n     * @example\\n     * ```\\n     * Carbon::parse('2024-08-31')->startOfWeek()->isStartOfWeek(); \/\/ true\\n     * Carbon::parse('2024-08-31')->isStartOfWeek(); \/\/ false\\n     * ```\\n     *\/\\n    public function isStartOfWeek(\\n        Unit|DateInterval|Closure|CarbonConverterInterface|string|null $interval = null,\\n        WeekDay|int|null $weekStartsAt = null,\\n    ): bool {\\n        return $this->isStartOfUnit(Unit::Week, $interval, $weekStartsAt);\\n    }\\n\\n    \/**\\n     * Determines if the instance is end of week (last day by default but interval can be customized).\\n     *\\n     * @example\\n     * ```\\n     * Carbon::parse('2024-08-31')->endOfWeek()->isEndOfWeek(); \/\/ true\\n     * Carbon::parse('2024-08-31')->isEndOfWeek(); \/\/ false\\n     * ```\\n     *\/\\n    public function isEndOfWeek(\\n        Unit|DateInterval|Closure|CarbonConverterInterface|string|null $interval = null,\\n        WeekDay|int|null $weekEndsAt = null,\\n    ): bool {\\n        return $this->isEndOfUnit(Unit::Week, $interval, $weekEndsAt);\\n    }\\n\\n    \/**\\n     * Determines if the instance is start of month (first day by default but interval can be customized).\\n     *\/\\n    public function isStartOfMonth(\\n        Unit|DateInterval|Closure|CarbonConverterInterface|string|null $interval = null,\\n    ): bool {\\n        return $this->isStartOfUnit(Unit::Month, $interval);\\n    }\\n\\n    \/**\\n     * Determines if the instance is end of month (last day by default but interval can be customized).\\n     *\/\\n    public function isEndOfMonth(\\n        Unit|DateInterval|Closure|CarbonConverterInterface|string|null $interval = null,\\n    ): bool {\\n        return $this->isEndOfUnit(Unit::Month, $interval);\\n    }\\n\\n    \/**\\n     * Determines if the instance is start of quarter (first day by default but interval can be customized).\\n     *\/\\n    public function isStartOfQuarter(\\n        Unit|DateInterval|Closure|CarbonConverterInterface|string|null $interval = null,\\n    ): bool {\\n        return $this->isStartOfUnit(Unit::Quarter, $interval);\\n    }\\n\\n    \/**\\n     * Determines if the instance is end of quarter (last day by default but interval can be customized).\\n     *\/\\n    public function isEndOfQuarter(\\n        Unit|DateInterval|Closure|CarbonConverterInterface|string|null $interval = null,\\n    ): bool {\\n        return $this->isEndOfUnit(Unit::Quarter, $interval);\\n    }\\n\\n    \/**\\n     * Determines if the instance is start of year (first day by default but interval can be customized).\\n     *\/\\n    public function isStartOfYear(\\n        Unit|DateInterval|Closure|CarbonConverterInterface|string|null $interval = null,\\n    ): bool {\\n        return $this->isStartOfUnit(Unit::Year, $interval);\\n    }\\n\\n    \/**\\n     * Determines if the instance is end of year (last day by default but interval can be customized).\\n     *\/\\n    public function isEndOfYear(\\n        Unit|DateInterval|Closure|CarbonConverterInterface|string|null $interval = null,\\n    ): bool {\\n        return $this->isEndOfUnit(Unit::Year, $interval);\\n    }\\n\\n    \/**\\n     * Determines if the instance is start of decade (first day by default but interval can be customized).\\n     *\/\\n    public function isStartOfDecade(\\n        Unit|DateInterval|Closure|CarbonConverterInterface|string|null $interval = null,\\n    ): bool {\\n        return $this->isStartOfUnit(Unit::Decade, $interval);\\n    }\\n\\n    \/**\\n     * Determines if the instance is end of decade (last day by default but interval can be customized).\\n     *\/\\n    public function isEndOfDecade(\\n        Unit|DateInterval|Closure|CarbonConverterInterface|string|null $interval = null,\\n    ): bool {\\n        return $this->isEndOfUnit(Unit::Decade, $interval);\\n    }\\n\\n    \/**\\n     * Determines if the instance is start of century (first day by default but interval can be customized).\\n     *\/\\n    public function isStartOfCentury(\\n        Unit|DateInterval|Closure|CarbonConverterInterface|string|null $interval = null,\\n    ): bool {\\n        return $this->isStartOfUnit(Unit::Century, $interval);\\n    }\\n\\n    \/**\\n     * Determines if the instance is end of century (last day by default but interval can be customized).\\n     *\/\\n    public function isEndOfCentury(\\n        Unit|DateInterval|Closure|CarbonConverterInterface|string|null $interval = null,\\n    ): bool {\\n        return $this->isEndOfUnit(Unit::Century, $interval);\\n    }\\n\\n    \/**\\n     * Determines if the instance is start of millennium (first day by default but interval can be customized).\\n     *\/\\n    public function isStartOfMillennium(\\n        Unit|DateInterval|Closure|CarbonConverterInterface|string|null $interval = null,\\n    ): bool {\\n        return $this->isStartOfUnit(Unit::Millennium, $interval);\\n    }\\n\\n    \/**\\n     * Determines if the instance is end of millennium (last day by default but interval can be customized).\\n     *\/\\n    public function isEndOfMillennium(\\n        Unit|DateInterval|Closure|CarbonConverterInterface|string|null $interval = null,\\n    ): bool {\\n        return $this->isEndOfUnit(Unit::Millennium, $interval);\\n    }\\n\\n    \/**\\n     * Check if the instance is start of day \/ midnight.\\n     *\\n     * @example\\n     * ```\\n     * Carbon::parse('2019-02-28 00:00:00')->isMidnight(); \/\/ true\\n     * Carbon::parse('2019-02-28 00:00:00.999999')->isMidnight(); \/\/ true\\n     * Carbon::parse('2019-02-28 00:00:01')->isMidnight(); \/\/ false\\n     * ```\\n     *\/\\n    public function isMidnight(): bool\\n    {\\n        return $this->isStartOfDay();\\n    }\\n\\n    \/**\\n     * Check if the instance is midday.\\n     *\\n     * @example\\n     * ```\\n     * Carbon::parse('2019-02-28 11:59:59.999999')->isMidday(); \/\/ false\\n     * Carbon::parse('2019-02-28 12:00:00')->isMidday(); \/\/ true\\n     * Carbon::parse('2019-02-28 12:00:00.999999')->isMidday(); \/\/ true\\n     * Carbon::parse('2019-02-28 12:00:01')->isMidday(); \/\/ false\\n     * ```\\n     *\/\\n    public function isMidday(): bool\\n    {\\n        \/* @var CarbonInterface $this *\/\\n        return $this->rawFormat('G:i:s') === static::$midDayAt.':00:00';\\n    }\\n\\n    \/**\\n     * Checks if the (date)time string is in a given format.\\n     *\\n     * @example\\n     * ```\\n     * Carbon::hasFormat('11:12:45', 'h:i:s'); \/\/ true\\n     * Carbon::hasFormat('13:12:45', 'h:i:s'); \/\/ false\\n     * ```\\n     *\/\\n    public static function hasFormat(string $date, string $format): bool\\n    {\\n        return FactoryImmutable::getInstance()->hasFormat($date, $format);\\n    }\\n\\n    \/**\\n     * Checks if the (date)time string is in a given format.\\n     *\\n     * @example\\n     * ```\\n     * Carbon::hasFormatWithModifiers('31\/08\/2015', 'd#m#Y'); \/\/ true\\n     * Carbon::hasFormatWithModifiers('31\/08\/2015', 'm#d#Y'); \/\/ false\\n     * ```\\n     *\\n     * @param string $date\\n     * @param string $format\\n     *\\n     * @return bool\\n     *\/\\n    public static function hasFormatWithModifiers(?string $date, string $format): bool\\n    {\\n        return FactoryImmutable::getInstance()->hasFormatWithModifiers($date, $format);\\n    }\\n\\n    \/**\\n     * Checks if the (date)time string is in a given format and valid to create a\\n     * new instance.\\n     *\\n     * @example\\n     * ```\\n     * Carbon::canBeCreatedFromFormat('11:12:45', 'h:i:s'); \/\/ true\\n     * Carbon::canBeCreatedFromFormat('13:12:45', 'h:i:s'); \/\/ false\\n     * ```\\n     *\/\\n    public static function canBeCreatedFromFormat(?string $date, string $format): bool\\n    {\\n        if ($date === null) {\\n            return false;\\n        }\\n\\n        try {\\n            \/\/ Try to create a DateTime object. Throws an InvalidArgumentException if the provided time string\\n            \/\/ doesn't match the format in any way.\\n            if (!static::rawCreateFromFormat($format, $date)) {\\n                return false;\\n            }\\n        } catch (InvalidArgumentException) {\\n            return false;\\n        }\\n\\n        return static::hasFormatWithModifiers($date, $format);\\n    }\\n\\n    \/**\\n     * Returns true if the current date matches the given string.\\n     *\\n     * @example\\n     * ```\\n     * var_dump(Carbon::parse('2019-06-02 12:23:45')->is('2019')); \/\/ true\\n     * var_dump(Carbon::parse('2019-06-02 12:23:45')->is('2018')); \/\/ false\\n     * var_dump(Carbon::parse('2019-06-02 12:23:45')->is('2019-06')); \/\/ true\\n     * var_dump(Carbon::parse('2019-06-02 12:23:45')->is('06-02')); \/\/ true\\n     * var_dump(Carbon::parse('2019-06-02 12:23:45')->is('2019-06-02')); \/\/ true\\n     * var_dump(Carbon::parse('2019-06-02 12:23:45')->is('Sunday')); \/\/ true\\n     * var_dump(Carbon::parse('2019-06-02 12:23:45')->is('June')); \/\/ true\\n     * var_dump(Carbon::parse('2019-06-02 12:23:45')->is('12:23')); \/\/ true\\n     * var_dump(Carbon::parse('2019-06-02 12:23:45')->is('12:23:45')); \/\/ true\\n     * var_dump(Carbon::parse('2019-06-02 12:23:45')->is('12:23:00')); \/\/ false\\n     * var_dump(Carbon::parse('2019-06-02 12:23:45')->is('12h')); \/\/ true\\n     * var_dump(Carbon::parse('2019-06-02 15:23:45')->is('3pm')); \/\/ true\\n     * var_dump(Carbon::parse('2019-06-02 15:23:45')->is('3am')); \/\/ false\\n     * ```\\n     *\\n     * @param string $tester day name, month name, hour, date, etc. as string\\n     *\/\\n    public function is(WeekDay|Month|string $tester): bool\\n    {\\n        if ($tester instanceof BackedEnum) {\\n            $tester = $tester->name;\\n        }\\n\\n        $tester = trim($tester);\\n\\n        if (preg_match('\/^\\\\d+$\/', $tester)) {\\n            return $this->year === (int) $tester;\\n        }\\n\\n        if (preg_match('\/^(?:Jan|January|Feb|February|Mar|March|Apr|April|May|Jun|June|Jul|July|Aug|August|Sep|September|Oct|October|Nov|November|Dec|December)$\/i', $tester)) {\\n            return $this->isSameMonth(\\n                $this->transmitFactory(static fn () => static::parse(\\\"$tester 1st\\\")),\\n                false,\\n            );\\n        }\\n\\n        if (preg_match('\/^\\\\d{3,}-\\\\d{1,2}$\/', $tester)) {\\n            return $this->isSameMonth(\\n                $this->transmitFactory(static fn () => static::parse($tester)),\\n            );\\n        }\\n\\n        if (preg_match('\/^(\\\\d{1,2})-(\\\\d{1,2})$\/', $tester, $match)) {\\n            return $this->month === (int) $match[1] && $this->day === (int) $match[2];\\n        }\\n\\n        $modifier = preg_replace('\/(\\\\d)h$\/i', '$1:00', $tester);\\n\\n        \/* @var CarbonInterface $max *\/\\n        $median = $this->transmitFactory(static fn () => static::parse('5555-06-15 12:30:30.555555'))\\n            ->modify($modifier);\\n        $current = $this->avoidMutation();\\n        \/* @var CarbonInterface $other *\/\\n        $other = $this->avoidMutation()->modify($modifier);\\n\\n        if ($current->eq($other)) {\\n            return true;\\n        }\\n\\n        if (preg_match('\/\\\\d:\\\\d{1,2}:\\\\d{1,2}$\/', $tester)) {\\n            return $current->startOfSecond()->eq($other);\\n        }\\n\\n        if (preg_match('\/\\\\d:\\\\d{1,2}$\/', $tester)) {\\n            return $current->startOfMinute()->eq($other);\\n        }\\n\\n        if (preg_match('\/\\\\d(?:h|am|pm)$\/', $tester)) {\\n            return $current->startOfHour()->eq($other);\\n        }\\n\\n        if (preg_match(\\n            '\/^(?:january|february|march|april|may|june|july|august|september|october|november|december)(?:\\\\s+\\\\d+)?$\/i',\\n            $tester,\\n        )) {\\n            return $current->startOfMonth()->eq($other->startOfMonth());\\n        }\\n\\n        $units = [\\n            'month' => [1, 'year'],\\n            'day' => [1, 'month'],\\n            'hour' => [0, 'day'],\\n            'minute' => [0, 'hour'],\\n            'second' => [0, 'minute'],\\n            'microsecond' => [0, 'second'],\\n        ];\\n\\n        foreach ($units as $unit => [$minimum, $startUnit]) {\\n            if ($minimum === $median->$unit) {\\n                $current = $current->startOf($startUnit);\\n\\n                break;\\n            }\\n        }\\n\\n        return $current->eq($other);\\n    }\\n\\n    \/**\\n     * Returns true if the date was created using CarbonImmutable::startOfTime()\\n     *\\n     * @return bool\\n     *\/\\n    public function isStartOfTime(): bool\\n    {\\n        return $this->startOfTime ?? false;\\n    }\\n\\n    \/**\\n     * Returns true if the date was created using CarbonImmutable::endOfTime()\\n     *\\n     * @return bool\\n     *\/\\n    public function isEndOfTime(): bool\\n    {\\n        return $this->endOfTime ?? false;\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Traits\/Creator.php\",\"ext\":\"php\",\"size\":32145,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon\\\\Traits;\\n\\nuse Carbon\\\\Carbon;\\nuse Carbon\\\\CarbonImmutable;\\nuse Carbon\\\\CarbonInterface;\\nuse Carbon\\\\Exceptions\\\\InvalidDateException;\\nuse Carbon\\\\Exceptions\\\\InvalidFormatException;\\nuse Carbon\\\\Exceptions\\\\InvalidTimeZoneException;\\nuse Carbon\\\\Exceptions\\\\OutOfRangeException;\\nuse Carbon\\\\Exceptions\\\\UnitException;\\nuse Carbon\\\\Month;\\nuse Carbon\\\\Translator;\\nuse Carbon\\\\WeekDay;\\nuse Closure;\\nuse DateMalformedStringException;\\nuse DateTimeImmutable;\\nuse DateTimeInterface;\\nuse DateTimeZone;\\nuse Exception;\\nuse ReturnTypeWillChange;\\nuse Symfony\\\\Contracts\\\\Translation\\\\TranslatorInterface;\\n\\n\/**\\n * Trait Creator.\\n *\\n * Static creators.\\n *\\n * Depends on the following methods:\\n *\\n * @method static Carbon|CarbonImmutable getTestNow()\\n *\/\\ntrait Creator\\n{\\n    use ObjectInitialisation;\\n    use LocalFactory;\\n\\n    \/**\\n     * The errors that can occur.\\n     *\/\\n    protected static ?array $lastErrors = null;\\n\\n    \/**\\n     * Create a new Carbon instance.\\n     *\\n     * Please see the testing aids section (specifically static::setTestNow())\\n     * for more on the possibility of this constructor returning a test instance.\\n     *\\n     * @throws InvalidFormatException\\n     *\/\\n    public function __construct(\\n        DateTimeInterface|WeekDay|Month|string|int|float|null $time = null,\\n        DateTimeZone|string|int|null $timezone = null,\\n    ) {\\n        $this->initLocalFactory();\\n\\n        if ($time instanceof Month) {\\n            $time = $time->name.' 1';\\n        } elseif ($time instanceof WeekDay) {\\n            $time = $time->name;\\n        } elseif ($time instanceof DateTimeInterface) {\\n            $time = $this->constructTimezoneFromDateTime($time, $timezone)->format('Y-m-d H:i:s.u');\\n        }\\n\\n        if (\\\\is_string($time) && str_starts_with($time, '@')) {\\n            $time = static::createFromTimestampUTC(substr($time, 1))->format('Y-m-d\\\\TH:i:s.uP');\\n        } elseif (is_numeric($time) && (!\\\\is_string($time) || !preg_match('\/^\\\\d{1,14}$\/', $time))) {\\n            $time = static::createFromTimestampUTC($time)->format('Y-m-d\\\\TH:i:s.uP');\\n        }\\n\\n        \/\/ If the class has a test now set, and we are trying to create a now()\\n        \/\/ instance then override as required\\n        $isNow = \\\\in_array($time, [null, '', 'now'], true);\\n        $timezone = static::safeCreateDateTimeZone($timezone) ?? null;\\n\\n        if (\\n            ($this->clock || (\\n                method_exists(static::class, 'hasTestNow') &&\\n                method_exists(static::class, 'getTestNow') &&\\n                static::hasTestNow()\\n            )) &&\\n            ($isNow || static::hasRelativeKeywords($time))\\n        ) {\\n            $this->mockConstructorParameters($time, $timezone);\\n        }\\n\\n        try {\\n            parent::__construct($time ?? 'now', $timezone);\\n        } catch (Exception $exception) {\\n            throw new InvalidFormatException($exception->getMessage(), 0, $exception);\\n        }\\n\\n        $this->constructedObjectId = spl_object_hash($this);\\n\\n        self::setLastErrors(parent::getLastErrors());\\n    }\\n\\n    \/**\\n     * Get timezone from a datetime instance.\\n     *\/\\n    private function constructTimezoneFromDateTime(\\n        DateTimeInterface $date,\\n        DateTimeZone|string|int|null &$timezone,\\n    ): DateTimeInterface {\\n        if ($timezone !== null) {\\n            $safeTz = static::safeCreateDateTimeZone($timezone);\\n\\n            if ($safeTz) {\\n                $date = ($date instanceof DateTimeImmutable ? $date : clone $date)->setTimezone($safeTz);\\n            }\\n\\n            return $date;\\n        }\\n\\n        $timezone = $date->getTimezone();\\n\\n        return $date;\\n    }\\n\\n    \/**\\n     * Update constructedObjectId on cloned.\\n     *\/\\n    public function __clone(): void\\n    {\\n        $this->constructedObjectId = spl_object_hash($this);\\n    }\\n\\n    \/**\\n     * Create a Carbon instance from a DateTime one.\\n     *\/\\n    public static function instance(DateTimeInterface $date): static\\n    {\\n        if ($date instanceof static) {\\n            return clone $date;\\n        }\\n\\n        $instance = parent::createFromFormat('U.u', $date->format('U.u'))\\n            ->setTimezone($date->getTimezone());\\n\\n        if ($date instanceof CarbonInterface) {\\n            $settings = $date->getSettings();\\n\\n            if (!$date->hasLocalTranslator()) {\\n                unset($settings['locale']);\\n            }\\n\\n            $instance->settings($settings);\\n        }\\n\\n        return $instance;\\n    }\\n\\n    \/**\\n     * Create a carbon instance from a string.\\n     *\\n     * This is an alias for the constructor that allows better fluent syntax\\n     * as it allows you to do Carbon::parse('Monday next week')->fn() rather\\n     * than (new Carbon('Monday next week'))->fn().\\n     *\\n     * @throws InvalidFormatException\\n     *\/\\n    public static function rawParse(\\n        DateTimeInterface|WeekDay|Month|string|int|float|null $time,\\n        DateTimeZone|string|int|null $timezone = null,\\n    ): static {\\n        if ($time instanceof DateTimeInterface) {\\n            return static::instance($time);\\n        }\\n\\n        try {\\n            return new static($time, $timezone);\\n        } catch (Exception $exception) {\\n            \/\/ @codeCoverageIgnoreStart\\n            try {\\n                $date = @static::now($timezone)->change($time);\\n            } catch (DateMalformedStringException|InvalidFormatException) {\\n                $date = null;\\n            }\\n            \/\/ @codeCoverageIgnoreEnd\\n\\n            return $date\\n                ?? throw new InvalidFormatException(\\\"Could not parse '$time': \\\".$exception->getMessage(), 0, $exception);\\n        }\\n    }\\n\\n    \/**\\n     * Create a carbon instance from a string.\\n     *\\n     * This is an alias for the constructor that allows better fluent syntax\\n     * as it allows you to do Carbon::parse('Monday next week')->fn() rather\\n     * than (new Carbon('Monday next week'))->fn().\\n     *\\n     * @throws InvalidFormatException\\n     *\/\\n    public static function parse(\\n        DateTimeInterface|WeekDay|Month|string|int|float|null $time,\\n        DateTimeZone|string|int|null $timezone = null,\\n    ): static {\\n        $function = static::$parseFunction;\\n\\n        if (!$function) {\\n            return static::rawParse($time, $timezone);\\n        }\\n\\n        if (\\\\is_string($function) && method_exists(static::class, $function)) {\\n            $function = [static::class, $function];\\n        }\\n\\n        return $function(...\\\\func_get_args());\\n    }\\n\\n    \/**\\n     * Create a carbon instance from a localized string (in French, Japanese, Arabic, etc.).\\n     *\\n     * @param string                       $time     date\/time string in the given language (may also contain English).\\n     * @param string|null                  $locale   if locale is null or not specified, current global locale will be\\n     *                                               used instead.\\n     * @param DateTimeZone|string|int|null $timezone optional timezone for the new instance.\\n     *\\n     * @throws InvalidFormatException\\n     *\/\\n    public static function parseFromLocale(\\n        string $time,\\n        ?string $locale = null,\\n        DateTimeZone|string|int|null $timezone = null,\\n    ): static {\\n        return static::rawParse(static::translateTimeString($time, $locale, static::DEFAULT_LOCALE), $timezone);\\n    }\\n\\n    \/**\\n     * Get a Carbon instance for the current date and time.\\n     *\/\\n    public static function now(DateTimeZone|string|int|null $timezone = null): static\\n    {\\n        return new static(null, $timezone);\\n    }\\n\\n    \/**\\n     * Create a Carbon instance for today.\\n     *\/\\n    public static function today(DateTimeZone|string|int|null $timezone = null): static\\n    {\\n        return static::rawParse('today', $timezone);\\n    }\\n\\n    \/**\\n     * Create a Carbon instance for tomorrow.\\n     *\/\\n    public static function tomorrow(DateTimeZone|string|int|null $timezone = null): static\\n    {\\n        return static::rawParse('tomorrow', $timezone);\\n    }\\n\\n    \/**\\n     * Create a Carbon instance for yesterday.\\n     *\/\\n    public static function yesterday(DateTimeZone|string|int|null $timezone = null): static\\n    {\\n        return static::rawParse('yesterday', $timezone);\\n    }\\n\\n    private static function assertBetween($unit, $value, $min, $max): void\\n    {\\n        if (static::isStrictModeEnabled() && ($value < $min || $value > $max)) {\\n            throw new OutOfRangeException($unit, $min, $max, $value);\\n        }\\n    }\\n\\n    private static function createNowInstance($timezone)\\n    {\\n        if (!static::hasTestNow()) {\\n            return static::now($timezone);\\n        }\\n\\n        $now = static::getTestNow();\\n\\n        if ($now instanceof Closure) {\\n            return $now(static::now($timezone));\\n        }\\n\\n        $now = $now->avoidMutation();\\n\\n        return $timezone === null ? $now : $now->setTimezone($timezone);\\n    }\\n\\n    \/**\\n     * Create a new Carbon instance from a specific date and time.\\n     *\\n     * If any of $year, $month or $day are set to null their now() values will\\n     * be used.\\n     *\\n     * If $hour is null it will be set to its now() value and the default\\n     * values for $minute and $second will be their now() values.\\n     *\\n     * If $hour is not null then the default values for $minute and $second\\n     * will be 0.\\n     *\\n     * @param DateTimeInterface|string|int|null $year\\n     * @param int|null                          $month\\n     * @param int|null                          $day\\n     * @param int|null                          $hour\\n     * @param int|null                          $minute\\n     * @param int|null                          $second\\n     * @param DateTimeZone|string|int|null      $timezone\\n     *\\n     * @throws InvalidFormatException\\n     *\\n     * @return static|null\\n     *\/\\n    public static function create($year = 0, $month = 1, $day = 1, $hour = 0, $minute = 0, $second = 0, $timezone = null): ?static\\n    {\\n        $month = self::monthToInt($month);\\n\\n        if ((\\\\is_string($year) && !is_numeric($year)) || $year instanceof DateTimeInterface) {\\n            return static::parse($year, $timezone ?? (\\\\is_string($month) || $month instanceof DateTimeZone ? $month : null));\\n        }\\n\\n        $defaults = null;\\n        $getDefault = function ($unit) use ($timezone, &$defaults) {\\n            if ($defaults === null) {\\n                $now = self::createNowInstance($timezone);\\n\\n                $defaults = array_combine([\\n                    'year',\\n                    'month',\\n                    'day',\\n                    'hour',\\n                    'minute',\\n                    'second',\\n                ], explode('-', $now->rawFormat('Y-n-j-G-i-s.u')));\\n            }\\n\\n            return $defaults[$unit];\\n        };\\n\\n        $year = $year ?? $getDefault('year');\\n        $month = $month ?? $getDefault('month');\\n        $day = $day ?? $getDefault('day');\\n        $hour = $hour ?? $getDefault('hour');\\n        $minute = $minute ?? $getDefault('minute');\\n        $second = (float) ($second ?? $getDefault('second'));\\n\\n        self::assertBetween('month', $month, 0, 99);\\n        self::assertBetween('day', $day, 0, 99);\\n        self::assertBetween('hour', $hour, 0, 99);\\n        self::assertBetween('minute', $minute, 0, 99);\\n        self::assertBetween('second', $second, 0, 99);\\n\\n        $fixYear = null;\\n\\n        if ($year < 0) {\\n            $fixYear = $year;\\n            $year = 0;\\n        } elseif ($year > 9999) {\\n            $fixYear = $year - 9999;\\n            $year = 9999;\\n        }\\n\\n        $second = ($second < 10 ? '0' : '').number_format($second, 6);\\n        $instance = static::rawCreateFromFormat('!Y-n-j G:i:s.u', \\\\sprintf('%s-%s-%s %s:%02s:%02s', $year, $month, $day, $hour, $minute, $second), $timezone);\\n\\n        if ($instance && $fixYear !== null) {\\n            $instance = $instance->addYears($fixYear);\\n        }\\n\\n        return $instance ?? null;\\n    }\\n\\n    \/**\\n     * Create a new safe Carbon instance from a specific date and time.\\n     *\\n     * If any of $year, $month or $day are set to null their now() values will\\n     * be used.\\n     *\\n     * If $hour is null it will be set to its now() value and the default\\n     * values for $minute and $second will be their now() values.\\n     *\\n     * If $hour is not null then the default values for $minute and $second\\n     * will be 0.\\n     *\\n     * If one of the set values is not valid, an InvalidDateException\\n     * will be thrown.\\n     *\\n     * @param int|null                     $year\\n     * @param int|null                     $month\\n     * @param int|null                     $day\\n     * @param int|null                     $hour\\n     * @param int|null                     $minute\\n     * @param int|null                     $second\\n     * @param DateTimeZone|string|int|null $timezone\\n     *\\n     * @throws InvalidDateException\\n     *\\n     * @return static|null\\n     *\/\\n    public static function createSafe($year = null, $month = null, $day = null, $hour = null, $minute = null, $second = null, $timezone = null): ?static\\n    {\\n        $month = self::monthToInt($month);\\n        $fields = static::getRangesByUnit();\\n\\n        foreach ($fields as $field => $range) {\\n            if ($$field !== null && (!\\\\is_int($$field) || $$field < $range[0] || $$field > $range[1])) {\\n                if (static::isStrictModeEnabled()) {\\n                    throw new InvalidDateException($field, $$field);\\n                }\\n\\n                return null;\\n            }\\n        }\\n\\n        $instance = static::create($year, $month, $day, $hour, $minute, $second, $timezone);\\n\\n        foreach (array_reverse($fields) as $field => $range) {\\n            if ($$field !== null && (!\\\\is_int($$field) || $$field !== $instance->$field)) {\\n                if (static::isStrictModeEnabled()) {\\n                    throw new InvalidDateException($field, $$field);\\n                }\\n\\n                return null;\\n            }\\n        }\\n\\n        return $instance;\\n    }\\n\\n    \/**\\n     * Create a new Carbon instance from a specific date and time using strict validation.\\n     *\\n     * @see create()\\n     *\\n     * @param int|null                     $year\\n     * @param int|null                     $month\\n     * @param int|null                     $day\\n     * @param int|null                     $hour\\n     * @param int|null                     $minute\\n     * @param int|null                     $second\\n     * @param DateTimeZone|string|int|null $timezone\\n     *\\n     * @throws InvalidFormatException\\n     *\\n     * @return static\\n     *\/\\n    public static function createStrict(?int $year = 0, ?int $month = 1, ?int $day = 1, ?int $hour = 0, ?int $minute = 0, ?int $second = 0, $timezone = null): static\\n    {\\n        $initialStrictMode = static::isStrictModeEnabled();\\n        static::useStrictMode(true);\\n\\n        try {\\n            $date = static::create($year, $month, $day, $hour, $minute, $second, $timezone);\\n        } finally {\\n            static::useStrictMode($initialStrictMode);\\n        }\\n\\n        return $date;\\n    }\\n\\n    \/**\\n     * Create a Carbon instance from just a date. The time portion is set to now.\\n     *\\n     * @param int|null                     $year\\n     * @param int|null                     $month\\n     * @param int|null                     $day\\n     * @param DateTimeZone|string|int|null $timezone\\n     *\\n     * @throws InvalidFormatException\\n     *\\n     * @return static\\n     *\/\\n    public static function createFromDate($year = null, $month = null, $day = null, $timezone = null)\\n    {\\n        return static::create($year, $month, $day, null, null, null, $timezone);\\n    }\\n\\n    \/**\\n     * Create a Carbon instance from just a date. The time portion is set to midnight.\\n     *\\n     * @param int|null                     $year\\n     * @param int|null                     $month\\n     * @param int|null                     $day\\n     * @param DateTimeZone|string|int|null $timezone\\n     *\\n     * @throws InvalidFormatException\\n     *\\n     * @return static\\n     *\/\\n    public static function createMidnightDate($year = null, $month = null, $day = null, $timezone = null)\\n    {\\n        return static::create($year, $month, $day, 0, 0, 0, $timezone);\\n    }\\n\\n    \/**\\n     * Create a Carbon instance from just a time. The date portion is set to today.\\n     *\\n     * @param int|null                     $hour\\n     * @param int|null                     $minute\\n     * @param int|null                     $second\\n     * @param DateTimeZone|string|int|null $timezone\\n     *\\n     * @throws InvalidFormatException\\n     *\\n     * @return static\\n     *\/\\n    public static function createFromTime($hour = 0, $minute = 0, $second = 0, $timezone = null): static\\n    {\\n        return static::create(null, null, null, $hour, $minute, $second, $timezone);\\n    }\\n\\n    \/**\\n     * Create a Carbon instance from a time string. The date portion is set to today.\\n     *\\n     * @throws InvalidFormatException\\n     *\/\\n    public static function createFromTimeString(string $time, DateTimeZone|string|int|null $timezone = null): static\\n    {\\n        return static::today($timezone)->setTimeFromTimeString($time);\\n    }\\n\\n    private static function createFromFormatAndTimezone(\\n        string $format,\\n        string $time,\\n        DateTimeZone|string|int|null $originalTimezone,\\n    ): ?DateTimeInterface {\\n        if ($originalTimezone === null) {\\n            return parent::createFromFormat($format, $time) ?: null;\\n        }\\n\\n        $timezone = \\\\is_int($originalTimezone) ? self::getOffsetTimezone($originalTimezone) : $originalTimezone;\\n\\n        $timezone = static::safeCreateDateTimeZone($timezone, $originalTimezone);\\n\\n        return parent::createFromFormat($format, $time, $timezone) ?: null;\\n    }\\n\\n    private static function getOffsetTimezone(int $offset): string\\n    {\\n        $minutes = (int) ($offset * static::MINUTES_PER_HOUR * static::SECONDS_PER_MINUTE);\\n\\n        return @timezone_name_from_abbr('', $minutes, 1) ?: throw new InvalidTimeZoneException(\\n            \\\"Invalid offset timezone $offset\\\",\\n        );\\n    }\\n\\n    \/**\\n     * Create a Carbon instance from a specific format.\\n     *\\n     * @param string                       $format   Datetime format\\n     * @param string                       $time\\n     * @param DateTimeZone|string|int|null $timezone\\n     *\\n     * @throws InvalidFormatException\\n     *\\n     * @return static|null\\n     *\/\\n    public static function rawCreateFromFormat(string $format, string $time, $timezone = null): ?static\\n    {\\n        \/\/ Work-around for https:\/\/bugs.php.net\/bug.php?id=80141\\n        $format = preg_replace('\/(?<!\\\\\\\\\\\\\\\\)((?:\\\\\\\\\\\\\\\\{2})*)c\/', '$1Y-m-d\\\\TH:i:sP', $format);\\n\\n        if (preg_match('\/(?<!\\\\\\\\\\\\\\\\)(?:\\\\\\\\\\\\\\\\{2})*(a|A)\/', $format, $aMatches, PREG_OFFSET_CAPTURE) &&\\n            preg_match('\/(?<!\\\\\\\\\\\\\\\\)(?:\\\\\\\\\\\\\\\\{2})*(h|g|H|G)\/', $format, $hMatches, PREG_OFFSET_CAPTURE) &&\\n            $aMatches[1][1] < $hMatches[1][1] &&\\n            preg_match('\/(am|pm|AM|PM)\/', $time)\\n        ) {\\n            $format = preg_replace('\/^(.*)(?<!\\\\\\\\\\\\\\\\)((?:\\\\\\\\\\\\\\\\{2})*)(a|A)(.*)$\/U', '$1$2$4 $3', $format);\\n            $time = preg_replace('\/^(.*)(am|pm|AM|PM)(.*)$\/U', '$1$3 $2', $time);\\n        }\\n\\n        if ($timezone === false) {\\n            $timezone = null;\\n        }\\n\\n        \/\/ First attempt to create an instance, so that error messages are based on the unmodified format.\\n        $date = self::createFromFormatAndTimezone($format, $time, $timezone);\\n        $lastErrors = parent::getLastErrors();\\n        \/** @var \\\\Carbon\\\\CarbonImmutable|\\\\Carbon\\\\Carbon|null $mock *\/\\n        $mock = static::getMockedTestNow($timezone);\\n\\n        if ($mock && $date instanceof DateTimeInterface) {\\n            \/\/ Set timezone from mock if custom timezone was neither given directly nor as a part of format.\\n            \/\/ First let's skip the part that will be ignored by the parser.\\n            $nonEscaped = '(?<!\\\\\\\\\\\\\\\\)(\\\\\\\\\\\\\\\\{2})*';\\n\\n            $nonIgnored = preg_replace(\\\"\/^.*{$nonEscaped}!\/s\\\", '', $format);\\n\\n            if ($timezone === null && !preg_match(\\\"\/{$nonEscaped}[eOPT]\/\\\", $nonIgnored)) {\\n                $timezone = clone $mock->getTimezone();\\n            }\\n\\n            $mock = $mock->copy();\\n\\n            \/\/ Prepend mock datetime only if the format does not contain non escaped unix epoch reset flag.\\n            if (!preg_match(\\\"\/{$nonEscaped}[!|]\/\\\", $format)) {\\n                if (preg_match('\/[HhGgisvuB]\/', $format)) {\\n                    $mock = $mock->setTime(0, 0);\\n                }\\n\\n                $format = static::MOCK_DATETIME_FORMAT.' '.$format;\\n                $time = ($mock instanceof self ? $mock->rawFormat(static::MOCK_DATETIME_FORMAT) : $mock->format(static::MOCK_DATETIME_FORMAT)).' '.$time;\\n            }\\n\\n            \/\/ Regenerate date from the modified format to base result on the mocked instance instead of now.\\n            $date = self::createFromFormatAndTimezone($format, $time, $timezone);\\n        }\\n\\n        if ($date instanceof DateTimeInterface) {\\n            $instance = static::instance($date);\\n            $instance::setLastErrors($lastErrors);\\n\\n            return $instance;\\n        }\\n\\n        if (static::isStrictModeEnabled()) {\\n            throw new InvalidFormatException(implode(PHP_EOL, (array) $lastErrors['errors']));\\n        }\\n\\n        return null;\\n    }\\n\\n    \/**\\n     * Create a Carbon instance from a specific format.\\n     *\\n     * @param string                       $format   Datetime format\\n     * @param string                       $time\\n     * @param DateTimeZone|string|int|null $timezone\\n     *\\n     * @throws InvalidFormatException\\n     *\\n     * @return static|null\\n     *\/\\n    #[ReturnTypeWillChange]\\n    public static function createFromFormat($format, $time, $timezone = null): ?static\\n    {\\n        $function = static::$createFromFormatFunction;\\n\\n        \/\/ format is a single numeric unit\\n        if (\\\\is_int($time) && \\\\in_array(ltrim($format, '!'), ['U', 'Y', 'y', 'X', 'x', 'm', 'n', 'd', 'j', 'w', 'W', 'H', 'h', 'G', 'g', 'i', 's', 'u', 'z', 'v'], true)) {\\n            $time = (string) $time;\\n        }\\n\\n        if (!\\\\is_string($time)) {\\n            @trigger_error(\\n                'createFromFormat() $time parameter will only accept string or integer for 1-letter format representing a numeric unit in the next version',\\n                \\\\E_USER_DEPRECATED,\\n            );\\n            $time = (string) $time;\\n        }\\n\\n        if (!$function) {\\n            return static::rawCreateFromFormat($format, $time, $timezone);\\n        }\\n\\n        if (\\\\is_string($function) && method_exists(static::class, $function)) {\\n            $function = [static::class, $function];\\n        }\\n\\n        return $function(...\\\\func_get_args());\\n    }\\n\\n    \/**\\n     * Create a Carbon instance from a specific ISO format (same replacements as ->isoFormat()).\\n     *\\n     * @param string                       $format     Datetime format\\n     * @param string                       $time\\n     * @param DateTimeZone|string|int|null $timezone   optional timezone\\n     * @param string|null                  $locale     locale to be used for LTS, LT, LL, LLL, etc. macro-formats (en by fault, unneeded if no such macro-format in use)\\n     * @param TranslatorInterface|null     $translator optional custom translator to use for macro-formats\\n     *\\n     * @throws InvalidFormatException\\n     *\\n     * @return static|null\\n     *\/\\n    public static function createFromIsoFormat(\\n        string $format,\\n        string $time,\\n        $timezone = null,\\n        ?string $locale = CarbonInterface::DEFAULT_LOCALE,\\n        ?TranslatorInterface $translator = null\\n    ): ?static {\\n        $format = preg_replace_callback('\/(?<!\\\\\\\\\\\\\\\\)(\\\\\\\\\\\\\\\\{2})*(LTS|LT|[Ll]{1,4})\/', function ($match) use ($locale, $translator) {\\n            [$code] = $match;\\n\\n            static $formats = null;\\n\\n            if ($formats === null) {\\n                $translator ??= Translator::get($locale);\\n\\n                $formats = [\\n                    'LT' => static::getTranslationMessageWith($translator, 'formats.LT', $locale),\\n                    'LTS' => static::getTranslationMessageWith($translator, 'formats.LTS', $locale),\\n                    'L' => static::getTranslationMessageWith($translator, 'formats.L', $locale),\\n                    'LL' => static::getTranslationMessageWith($translator, 'formats.LL', $locale),\\n                    'LLL' => static::getTranslationMessageWith($translator, 'formats.LLL', $locale),\\n                    'LLLL' => static::getTranslationMessageWith($translator, 'formats.LLLL', $locale),\\n                ];\\n            }\\n\\n            return $formats[$code] ?? preg_replace_callback(\\n                '\/MMMM|MM|DD|dddd\/',\\n                static fn (array $code) => mb_substr($code[0], 1),\\n                $formats[strtoupper($code)] ?? '',\\n            );\\n        }, $format);\\n\\n        $format = preg_replace_callback('\/(?<!\\\\\\\\\\\\\\\\)(\\\\\\\\\\\\\\\\{2})*('.CarbonInterface::ISO_FORMAT_REGEXP.'|[A-Za-z])\/', function ($match) {\\n            [$code] = $match;\\n\\n            static $replacements = null;\\n\\n            if ($replacements === null) {\\n                $replacements = [\\n                    'OD' => 'd',\\n                    'OM' => 'M',\\n                    'OY' => 'Y',\\n                    'OH' => 'G',\\n                    'Oh' => 'g',\\n                    'Om' => 'i',\\n                    'Os' => 's',\\n                    'D' => 'd',\\n                    'DD' => 'd',\\n                    'Do' => 'd',\\n                    'd' => '!',\\n                    'dd' => '!',\\n                    'ddd' => 'D',\\n                    'dddd' => 'D',\\n                    'DDD' => 'z',\\n                    'DDDD' => 'z',\\n                    'DDDo' => 'z',\\n                    'e' => '!',\\n                    'E' => '!',\\n                    'H' => 'G',\\n                    'HH' => 'H',\\n                    'h' => 'g',\\n                    'hh' => 'h',\\n                    'k' => 'G',\\n                    'kk' => 'G',\\n                    'hmm' => 'gi',\\n                    'hmmss' => 'gis',\\n                    'Hmm' => 'Gi',\\n                    'Hmmss' => 'Gis',\\n                    'm' => 'i',\\n                    'mm' => 'i',\\n                    'a' => 'a',\\n                    'A' => 'a',\\n                    's' => 's',\\n                    'ss' => 's',\\n                    'S' => '*',\\n                    'SS' => '*',\\n                    'SSS' => '*',\\n                    'SSSS' => '*',\\n                    'SSSSS' => '*',\\n                    'SSSSSS' => 'u',\\n                    'SSSSSSS' => 'u*',\\n                    'SSSSSSSS' => 'u*',\\n                    'SSSSSSSSS' => 'u*',\\n                    'M' => 'm',\\n                    'MM' => 'm',\\n                    'MMM' => 'M',\\n                    'MMMM' => 'M',\\n                    'Mo' => 'm',\\n                    'Q' => '!',\\n                    'Qo' => '!',\\n                    'G' => '!',\\n                    'GG' => '!',\\n                    'GGG' => '!',\\n                    'GGGG' => '!',\\n                    'GGGGG' => '!',\\n                    'g' => '!',\\n                    'gg' => '!',\\n                    'ggg' => '!',\\n                    'gggg' => '!',\\n                    'ggggg' => '!',\\n                    'W' => '!',\\n                    'WW' => '!',\\n                    'Wo' => '!',\\n                    'w' => '!',\\n                    'ww' => '!',\\n                    'wo' => '!',\\n                    'x' => 'U???',\\n                    'X' => 'U',\\n                    'Y' => 'Y',\\n                    'YY' => 'y',\\n                    'YYYY' => 'Y',\\n                    'YYYYY' => 'Y',\\n                    'YYYYYY' => 'Y',\\n                    'z' => 'e',\\n                    'zz' => 'e',\\n                    'Z' => 'e',\\n                    'ZZ' => 'e',\\n                ];\\n            }\\n\\n            $format = $replacements[$code] ?? '?';\\n\\n            if ($format === '!') {\\n                throw new InvalidFormatException(\\\"Format $code not supported for creation.\\\");\\n            }\\n\\n            return $format;\\n        }, $format);\\n\\n        return static::rawCreateFromFormat($format, $time, $timezone);\\n    }\\n\\n    \/**\\n     * Create a Carbon instance from a specific format and a string in a given language.\\n     *\\n     * @param string                       $format   Datetime format\\n     * @param string                       $locale\\n     * @param string                       $time\\n     * @param DateTimeZone|string|int|null $timezone\\n     *\\n     * @throws InvalidFormatException\\n     *\\n     * @return static|null\\n     *\/\\n    public static function createFromLocaleFormat(string $format, string $locale, string $time, $timezone = null): ?static\\n    {\\n        $format = preg_replace_callback(\\n            '\/(?:\\\\\\\\\\\\\\\\[a-zA-Z]|[bfkqCEJKQRV]){2,}\/',\\n            static function (array $match) use ($locale): string {\\n                $word = str_replace('\\\\\\\\', '', $match[0]);\\n                $translatedWord = static::translateTimeString($word, $locale, static::DEFAULT_LOCALE);\\n\\n                return $word === $translatedWord\\n                    ? $match[0]\\n                    : preg_replace('\/[a-zA-Z]\/', '\\\\\\\\\\\\\\\\$0', $translatedWord);\\n            },\\n            $format\\n        );\\n\\n        return static::rawCreateFromFormat($format, static::translateTimeString($time, $locale, static::DEFAULT_LOCALE), $timezone);\\n    }\\n\\n    \/**\\n     * Create a Carbon instance from a specific ISO format and a string in a given language.\\n     *\\n     * @param string                       $format   Datetime ISO format\\n     * @param string                       $locale\\n     * @param string                       $time\\n     * @param DateTimeZone|string|int|null $timezone\\n     *\\n     * @throws InvalidFormatException\\n     *\\n     * @return static|null\\n     *\/\\n    public static function createFromLocaleIsoFormat(string $format, string $locale, string $time, $timezone = null): ?static\\n    {\\n        $time = static::translateTimeString($time, $locale, static::DEFAULT_LOCALE, CarbonInterface::TRANSLATE_MONTHS | CarbonInterface::TRANSLATE_DAYS | CarbonInterface::TRANSLATE_MERIDIEM);\\n\\n        return static::createFromIsoFormat($format, $time, $timezone, $locale);\\n    }\\n\\n    \/**\\n     * Make a Carbon instance from given variable if possible.\\n     *\\n     * Always return a new instance. Parse only strings and only these likely to be dates (skip intervals\\n     * and recurrences). Throw an exception for invalid format, but otherwise return null.\\n     *\\n     * @param mixed $var\\n     *\\n     * @throws InvalidFormatException\\n     *\\n     * @return static|null\\n     *\/\\n    public static function make($var, DateTimeZone|string|null $timezone = null): ?static\\n    {\\n        if ($var instanceof DateTimeInterface) {\\n            return static::instance($var);\\n        }\\n\\n        $date = null;\\n\\n        if (\\\\is_string($var)) {\\n            $var = trim($var);\\n\\n            if (!preg_match('\/^P[\\\\dT]\/', $var) &&\\n                !preg_match('\/^R\\\\d\/', $var) &&\\n                preg_match('\/[a-z\\\\d]\/i', $var)\\n            ) {\\n                $date = static::parse($var, $timezone);\\n            }\\n        }\\n\\n        return $date;\\n    }\\n\\n    \/**\\n     * Set last errors.\\n     *\\n     * @param array|bool $lastErrors\\n     *\\n     * @return void\\n     *\/\\n    private static function setLastErrors($lastErrors): void\\n    {\\n        if (\\\\is_array($lastErrors) || $lastErrors === false) {\\n            static::$lastErrors = \\\\is_array($lastErrors) ? $lastErrors : [\\n                'warning_count' => 0,\\n                'warnings' => [],\\n                'error_count' => 0,\\n                'errors' => [],\\n            ];\\n        }\\n    }\\n\\n    \/**\\n     * {@inheritdoc}\\n     *\/\\n    public static function getLastErrors(): array|false\\n    {\\n        return static::$lastErrors ?? false;\\n    }\\n\\n    private static function monthToInt(mixed $value, string $unit = 'month'): mixed\\n    {\\n        if ($value instanceof Month) {\\n            if ($unit !== 'month') {\\n                throw new UnitException(\\\"Month enum cannot be used to set $unit\\\");\\n            }\\n\\n            return Month::int($value);\\n        }\\n\\n        return $value;\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Traits\/Rounding.php\",\"ext\":\"php\",\"size\":7093,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon\\\\Traits;\\n\\nuse Carbon\\\\CarbonInterface;\\nuse Carbon\\\\Exceptions\\\\UnknownUnitException;\\nuse Carbon\\\\WeekDay;\\nuse DateInterval;\\n\\n\/**\\n * Trait Rounding.\\n *\\n * Round, ceil, floor units.\\n *\\n * Depends on the following methods:\\n *\\n * @method static copy()\\n * @method static startOfWeek(int $weekStartsAt = null)\\n *\/\\ntrait Rounding\\n{\\n    use IntervalRounding;\\n\\n    \/**\\n     * Round the current instance at the given unit with given precision if specified and the given function.\\n     *\/\\n    public function roundUnit(\\n        string $unit,\\n        DateInterval|string|float|int $precision = 1,\\n        callable|string $function = 'round',\\n    ): static {\\n        $metaUnits = [\\n            \/\/ @call roundUnit\\n            'millennium' => [static::YEARS_PER_MILLENNIUM, 'year'],\\n            \/\/ @call roundUnit\\n            'century' => [static::YEARS_PER_CENTURY, 'year'],\\n            \/\/ @call roundUnit\\n            'decade' => [static::YEARS_PER_DECADE, 'year'],\\n            \/\/ @call roundUnit\\n            'quarter' => [static::MONTHS_PER_QUARTER, 'month'],\\n            \/\/ @call roundUnit\\n            'millisecond' => [1000, 'microsecond'],\\n        ];\\n        $normalizedUnit = static::singularUnit($unit);\\n        $ranges = array_merge(static::getRangesByUnit($this->daysInMonth), [\\n            \/\/ @call roundUnit\\n            'microsecond' => [0, 999999],\\n        ]);\\n        $factor = 1;\\n\\n        if ($normalizedUnit === 'week') {\\n            $normalizedUnit = 'day';\\n            $precision *= static::DAYS_PER_WEEK;\\n        }\\n\\n        if (isset($metaUnits[$normalizedUnit])) {\\n            [$factor, $normalizedUnit] = $metaUnits[$normalizedUnit];\\n        }\\n\\n        $precision *= $factor;\\n\\n        if (!isset($ranges[$normalizedUnit])) {\\n            throw new UnknownUnitException($unit);\\n        }\\n\\n        $found = false;\\n        $fraction = 0;\\n        $arguments = null;\\n        $initialValue = null;\\n        $factor = $this->year < 0 ? -1 : 1;\\n        $changes = [];\\n        $minimumInc = null;\\n\\n        foreach ($ranges as $unit => [$minimum, $maximum]) {\\n            if ($normalizedUnit === $unit) {\\n                $arguments = [$this->$unit, $minimum];\\n                $initialValue = $this->$unit;\\n                $fraction = $precision - floor($precision);\\n                $found = true;\\n\\n                continue;\\n            }\\n\\n            if ($found) {\\n                $delta = $maximum + 1 - $minimum;\\n                $factor \/= $delta;\\n                $fraction *= $delta;\\n                $inc = ($this->$unit - $minimum) * $factor;\\n\\n                if ($inc !== 0.0) {\\n                    $minimumInc = $minimumInc ?? ($arguments[0] \/ pow(2, 52));\\n\\n                    \/\/ If value is still the same when adding a non-zero increment\/decrement,\\n                    \/\/ it means precision got lost in the addition\\n                    if (abs($inc) < $minimumInc) {\\n                        $inc = $minimumInc * ($inc < 0 ? -1 : 1);\\n                    }\\n\\n                    \/\/ If greater than $precision, assume precision loss caused an overflow\\n                    if ($function !== 'floor' || abs($arguments[0] + $inc - $initialValue) >= $precision) {\\n                        $arguments[0] += $inc;\\n                    }\\n                }\\n\\n                $changes[$unit] = round(\\n                    $minimum + ($fraction ? $fraction * $function(($this->$unit - $minimum) \/ $fraction) : 0),\\n                );\\n\\n                \/\/ Cannot use modulo as it lose double precision\\n                while ($changes[$unit] >= $delta) {\\n                    $changes[$unit] -= $delta;\\n                }\\n\\n                $fraction -= floor($fraction);\\n            }\\n        }\\n\\n        [$value, $minimum] = $arguments;\\n        $normalizedValue = floor($function(($value - $minimum) \/ $precision) * $precision + $minimum);\\n\\n        \/** @var CarbonInterface $result *\/\\n        $result = $this;\\n\\n        foreach ($changes as $unit => $value) {\\n            $result = $result->$unit($value);\\n        }\\n\\n        return $result->$normalizedUnit($normalizedValue);\\n    }\\n\\n    \/**\\n     * Truncate the current instance at the given unit with given precision if specified.\\n     *\/\\n    public function floorUnit(string $unit, DateInterval|string|float|int $precision = 1): static\\n    {\\n        return $this->roundUnit($unit, $precision, 'floor');\\n    }\\n\\n    \/**\\n     * Ceil the current instance at the given unit with given precision if specified.\\n     *\/\\n    public function ceilUnit(string $unit, DateInterval|string|float|int $precision = 1): static\\n    {\\n        return $this->roundUnit($unit, $precision, 'ceil');\\n    }\\n\\n    \/**\\n     * Round the current instance second with given precision if specified.\\n     *\/\\n    public function round(DateInterval|string|float|int $precision = 1, callable|string $function = 'round'): static\\n    {\\n        return $this->roundWith($precision, $function);\\n    }\\n\\n    \/**\\n     * Round the current instance second with given precision if specified.\\n     *\/\\n    public function floor(DateInterval|string|float|int $precision = 1): static\\n    {\\n        return $this->round($precision, 'floor');\\n    }\\n\\n    \/**\\n     * Ceil the current instance second with given precision if specified.\\n     *\/\\n    public function ceil(DateInterval|string|float|int $precision = 1): static\\n    {\\n        return $this->round($precision, 'ceil');\\n    }\\n\\n    \/**\\n     * Round the current instance week.\\n     *\\n     * @param WeekDay|int|null $weekStartsAt optional start allow you to specify the day of week to use to start the week\\n     *\/\\n    public function roundWeek(WeekDay|int|null $weekStartsAt = null): static\\n    {\\n        return $this->closest(\\n            $this->avoidMutation()->floorWeek($weekStartsAt),\\n            $this->avoidMutation()->ceilWeek($weekStartsAt),\\n        );\\n    }\\n\\n    \/**\\n     * Truncate the current instance week.\\n     *\\n     * @param WeekDay|int|null $weekStartsAt optional start allow you to specify the day of week to use to start the week\\n     *\/\\n    public function floorWeek(WeekDay|int|null $weekStartsAt = null): static\\n    {\\n        return $this->startOfWeek($weekStartsAt);\\n    }\\n\\n    \/**\\n     * Ceil the current instance week.\\n     *\\n     * @param WeekDay|int|null $weekStartsAt optional start allow you to specify the day of week to use to start the week\\n     *\/\\n    public function ceilWeek(WeekDay|int|null $weekStartsAt = null): static\\n    {\\n        if ($this->isMutable()) {\\n            $startOfWeek = $this->avoidMutation()->startOfWeek($weekStartsAt);\\n\\n            return $startOfWeek != $this ?\\n                $this->startOfWeek($weekStartsAt)->addWeek() :\\n                $this;\\n        }\\n\\n        $startOfWeek = $this->startOfWeek($weekStartsAt);\\n\\n        return $startOfWeek != $this ?\\n            $startOfWeek->addWeek() :\\n            $this->avoidMutation();\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Traits\/Week.php\",\"ext\":\"php\",\"size\":7726,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon\\\\Traits;\\n\\nuse Carbon\\\\CarbonInterval;\\n\\n\/**\\n * Trait Week.\\n *\\n * week and ISO week number, year and count in year.\\n *\\n * Depends on the following properties:\\n *\\n * @property int $daysInYear\\n * @property int $dayOfWeek\\n * @property int $dayOfYear\\n * @property int $year\\n *\\n * Depends on the following methods:\\n *\\n * @method static addWeeks(int $weeks = 1)\\n * @method static copy()\\n * @method static dayOfYear(int $dayOfYear)\\n * @method string getTranslationMessage(string $key, ?string $locale = null, ?string $default = null, $translator = null)\\n * @method static next(int|string $modifier = null)\\n * @method static startOfWeek(int $day = null)\\n * @method static subWeeks(int $weeks = 1)\\n * @method static year(int $year = null)\\n *\/\\ntrait Week\\n{\\n    \/**\\n     * Set\/get the week number of year using given first day of week and first\\n     * day of year included in the first week. Or use ISO format if no settings\\n     * given.\\n     *\\n     * @param int|null $year      if null, act as a getter, if not null, set the year and return current instance.\\n     * @param int|null $dayOfWeek first date of week from 0 (Sunday) to 6 (Saturday)\\n     * @param int|null $dayOfYear first day of year included in the week #1\\n     *\\n     * @return int|static\\n     *\/\\n    public function isoWeekYear($year = null, $dayOfWeek = null, $dayOfYear = null)\\n    {\\n        return $this->weekYear(\\n            $year,\\n            $dayOfWeek ?? static::MONDAY,\\n            $dayOfYear ?? static::THURSDAY,\\n        );\\n    }\\n\\n    \/**\\n     * Set\/get the week number of year using given first day of week and first\\n     * day of year included in the first week. Or use US format if no settings\\n     * given (Sunday \/ Jan 6).\\n     *\\n     * @param int|null $year      if null, act as a getter, if not null, set the year and return current instance.\\n     * @param int|null $dayOfWeek first date of week from 0 (Sunday) to 6 (Saturday)\\n     * @param int|null $dayOfYear first day of year included in the week #1\\n     *\\n     * @return int|static\\n     *\/\\n    public function weekYear($year = null, $dayOfWeek = null, $dayOfYear = null)\\n    {\\n        $dayOfWeek = $dayOfWeek ?? $this->getTranslationMessage('first_day_of_week') ?? static::SUNDAY;\\n        $dayOfYear = $dayOfYear ?? $this->getTranslationMessage('day_of_first_week_of_year') ?? 1;\\n\\n        if ($year !== null) {\\n            $year = (int) round($year);\\n\\n            if ($this->weekYear(null, $dayOfWeek, $dayOfYear) === $year) {\\n                return $this->avoidMutation();\\n            }\\n\\n            $week = $this->week(null, $dayOfWeek, $dayOfYear);\\n            $day = $this->dayOfWeek;\\n            $date = $this->year($year);\\n\\n            $date = match ($date->weekYear(null, $dayOfWeek, $dayOfYear) - $year) {\\n                CarbonInterval::POSITIVE => $date->subWeeks(static::WEEKS_PER_YEAR \/ 2),\\n                CarbonInterval::NEGATIVE => $date->addWeeks(static::WEEKS_PER_YEAR \/ 2),\\n                default => $date,\\n            };\\n\\n            $date = $date\\n                ->addWeeks($week - $date->week(null, $dayOfWeek, $dayOfYear))\\n                ->startOfWeek($dayOfWeek);\\n\\n            if ($date->dayOfWeek === $day) {\\n                return $date;\\n            }\\n\\n            return $date->next($day);\\n        }\\n\\n        $year = $this->year;\\n        $day = $this->dayOfYear;\\n        $date = $this->avoidMutation()->dayOfYear($dayOfYear)->startOfWeek($dayOfWeek);\\n\\n        if ($date->year === $year && $day < $date->dayOfYear) {\\n            return $year - 1;\\n        }\\n\\n        $date = $this->avoidMutation()->addYear()->dayOfYear($dayOfYear)->startOfWeek($dayOfWeek);\\n\\n        if ($date->year === $year && $day >= $date->dayOfYear) {\\n            return $year + 1;\\n        }\\n\\n        return $year;\\n    }\\n\\n    \/**\\n     * Get the number of weeks of the current week-year using given first day of week and first\\n     * day of year included in the first week. Or use ISO format if no settings\\n     * given.\\n     *\\n     * @param int|null $dayOfWeek first date of week from 0 (Sunday) to 6 (Saturday)\\n     * @param int|null $dayOfYear first day of year included in the week #1\\n     *\\n     * @return int\\n     *\/\\n    public function isoWeeksInYear($dayOfWeek = null, $dayOfYear = null)\\n    {\\n        return $this->weeksInYear(\\n            $dayOfWeek ?? static::MONDAY,\\n            $dayOfYear ?? static::THURSDAY,\\n        );\\n    }\\n\\n    \/**\\n     * Get the number of weeks of the current week-year using given first day of week and first\\n     * day of year included in the first week. Or use US format if no settings\\n     * given (Sunday \/ Jan 6).\\n     *\\n     * @param int|null $dayOfWeek first date of week from 0 (Sunday) to 6 (Saturday)\\n     * @param int|null $dayOfYear first day of year included in the week #1\\n     *\\n     * @return int\\n     *\/\\n    public function weeksInYear($dayOfWeek = null, $dayOfYear = null)\\n    {\\n        $dayOfWeek = $dayOfWeek ?? $this->getTranslationMessage('first_day_of_week') ?? static::SUNDAY;\\n        $dayOfYear = $dayOfYear ?? $this->getTranslationMessage('day_of_first_week_of_year') ?? 1;\\n        $year = $this->year;\\n        $start = $this->avoidMutation()->dayOfYear($dayOfYear)->startOfWeek($dayOfWeek);\\n        $startDay = $start->dayOfYear;\\n        if ($start->year !== $year) {\\n            $startDay -= $start->daysInYear;\\n        }\\n        $end = $this->avoidMutation()->addYear()->dayOfYear($dayOfYear)->startOfWeek($dayOfWeek);\\n        $endDay = $end->dayOfYear;\\n        if ($end->year !== $year) {\\n            $endDay += $this->daysInYear;\\n        }\\n\\n        return (int) round(($endDay - $startDay) \/ static::DAYS_PER_WEEK);\\n    }\\n\\n    \/**\\n     * Get\/set the week number using given first day of week and first\\n     * day of year included in the first week. Or use US format if no settings\\n     * given (Sunday \/ Jan 6).\\n     *\\n     * @param int|null $week\\n     * @param int|null $dayOfWeek\\n     * @param int|null $dayOfYear\\n     *\\n     * @return int|static\\n     *\/\\n    public function week($week = null, $dayOfWeek = null, $dayOfYear = null)\\n    {\\n        $date = $this;\\n        $dayOfWeek = $dayOfWeek ?? $this->getTranslationMessage('first_day_of_week') ?? 0;\\n        $dayOfYear = $dayOfYear ?? $this->getTranslationMessage('day_of_first_week_of_year') ?? 1;\\n\\n        if ($week !== null) {\\n            return $date->addWeeks(round($week) - $this->week(null, $dayOfWeek, $dayOfYear));\\n        }\\n\\n        $start = $date->avoidMutation()->shiftTimezone('UTC')->dayOfYear($dayOfYear)->startOfWeek($dayOfWeek);\\n        $end = $date->avoidMutation()->shiftTimezone('UTC')->startOfWeek($dayOfWeek);\\n\\n        if ($start > $end) {\\n            $start = $start->subWeeks(static::WEEKS_PER_YEAR \/ 2)->dayOfYear($dayOfYear)->startOfWeek($dayOfWeek);\\n        }\\n\\n        $week = (int) ($start->diffInDays($end) \/ static::DAYS_PER_WEEK + 1);\\n\\n        return $week > $end->weeksInYear($dayOfWeek, $dayOfYear) ? 1 : $week;\\n    }\\n\\n    \/**\\n     * Get\/set the week number using given first day of week and first\\n     * day of year included in the first week. Or use ISO format if no settings\\n     * given.\\n     *\\n     * @param int|null $week\\n     * @param int|null $dayOfWeek\\n     * @param int|null $dayOfYear\\n     *\\n     * @return int|static\\n     *\/\\n    public function isoWeek($week = null, $dayOfWeek = null, $dayOfYear = null)\\n    {\\n        return $this->week(\\n            $week,\\n            $dayOfWeek ?? static::MONDAY,\\n            $dayOfYear ?? static::THURSDAY,\\n        );\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Traits\/Test.php\",\"ext\":\"php\",\"size\":6592,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon\\\\Traits;\\n\\nuse Carbon\\\\CarbonInterface;\\nuse Carbon\\\\CarbonTimeZone;\\nuse Carbon\\\\Factory;\\nuse Carbon\\\\FactoryImmutable;\\nuse Closure;\\nuse DateTimeImmutable;\\nuse DateTimeInterface;\\nuse DateTimeZone;\\n\\ntrait Test\\n{\\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ TESTING AIDS \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\\n\\n    \/**\\n     * Set a Carbon instance (real or mock) to be returned when a \\\"now\\\"\\n     * instance is created.  The provided instance will be returned\\n     * specifically under the following conditions:\\n     *   - A call to the static now() method, ex. Carbon::now()\\n     *   - When a null (or blank string) is passed to the constructor or parse(), ex. new Carbon(null)\\n     *   - When the string \\\"now\\\" is passed to the constructor or parse(), ex. new Carbon('now')\\n     *   - When a string containing the desired time is passed to Carbon::parse().\\n     *\\n     * Note the timezone parameter was left out of the examples above and\\n     * has no affect as the mock value will be returned regardless of its value.\\n     *\\n     * Only the moment is mocked with setTestNow(), the timezone will still be the one passed\\n     * as parameter of date_default_timezone_get() as a fallback (see setTestNowAndTimezone()).\\n     *\\n     * To clear the test instance call this method using the default\\n     * parameter of null.\\n     *\\n     * \/!\\\\ Use this method for unit tests only.\\n     *\\n     * @param DateTimeInterface|Closure|static|string|false|null $testNow real or mock Carbon instance\\n     *\/\\n    public static function setTestNow(mixed $testNow = null): void\\n    {\\n        FactoryImmutable::getDefaultInstance()->setTestNow($testNow);\\n    }\\n\\n    \/**\\n     * Set a Carbon instance (real or mock) to be returned when a \\\"now\\\"\\n     * instance is created.  The provided instance will be returned\\n     * specifically under the following conditions:\\n     *   - A call to the static now() method, ex. Carbon::now()\\n     *   - When a null (or blank string) is passed to the constructor or parse(), ex. new Carbon(null)\\n     *   - When the string \\\"now\\\" is passed to the constructor or parse(), ex. new Carbon('now')\\n     *   - When a string containing the desired time is passed to Carbon::parse().\\n     *\\n     * It will also align default timezone (e.g. call date_default_timezone_set()) with\\n     * the second argument or if null, with the timezone of the given date object.\\n     *\\n     * To clear the test instance call this method using the default\\n     * parameter of null.\\n     *\\n     * \/!\\\\ Use this method for unit tests only.\\n     *\\n     * @param DateTimeInterface|Closure|static|string|false|null $testNow real or mock Carbon instance\\n     *\/\\n    public static function setTestNowAndTimezone($testNow = null, $timezone = null): void\\n    {\\n        FactoryImmutable::getDefaultInstance()->setTestNowAndTimezone($testNow, $timezone);\\n    }\\n\\n    \/**\\n     * Temporarily sets a static date to be used within the callback.\\n     * Using setTestNow to set the date, executing the callback, then\\n     * clearing the test instance.\\n     *\\n     * \/!\\\\ Use this method for unit tests only.\\n     *\\n     * @template T\\n     *\\n     * @param DateTimeInterface|Closure|static|string|false|null $testNow  real or mock Carbon instance\\n     * @param Closure(): T                                       $callback\\n     *\\n     * @return T\\n     *\/\\n    public static function withTestNow(mixed $testNow, callable $callback): mixed\\n    {\\n        return FactoryImmutable::getDefaultInstance()->withTestNow($testNow, $callback);\\n    }\\n\\n    \/**\\n     * Get the Carbon instance (real or mock) to be returned when a \\\"now\\\"\\n     * instance is created.\\n     *\\n     * @return Closure|CarbonInterface|null the current instance used for testing\\n     *\/\\n    public static function getTestNow(): Closure|CarbonInterface|null\\n    {\\n        return FactoryImmutable::getInstance()->getTestNow();\\n    }\\n\\n    \/**\\n     * Determine if there is a valid test instance set. A valid test instance\\n     * is anything that is not null.\\n     *\\n     * @return bool true if there is a test instance, otherwise false\\n     *\/\\n    public static function hasTestNow(): bool\\n    {\\n        return FactoryImmutable::getInstance()->hasTestNow();\\n    }\\n\\n    \/**\\n     * Get the mocked date passed in setTestNow() and if it's a Closure, execute it.\\n     *\/\\n    protected static function getMockedTestNow(DateTimeZone|string|int|null $timezone): ?CarbonInterface\\n    {\\n        $testNow = FactoryImmutable::getInstance()->handleTestNowClosure(static::getTestNow(), $timezone);\\n\\n        if ($testNow === null) {\\n            return null;\\n        }\\n\\n        $testNow = $testNow->avoidMutation();\\n\\n        return $timezone ? $testNow->setTimezone($timezone) : $testNow;\\n    }\\n\\n    private function mockConstructorParameters(&$time, ?CarbonTimeZone $timezone): void\\n    {\\n        $clock = $this->clock?->unwrap();\\n        $now = $clock instanceof Factory\\n            ? $clock->getTestNow()\\n            : $this->nowFromClock($timezone);\\n        $testInstance = $now ?? self::getMockedTestNowClone($timezone);\\n\\n        if (!$testInstance) {\\n            return;\\n        }\\n\\n        if ($testInstance instanceof DateTimeInterface) {\\n            $testInstance = $testInstance->setTimezone($timezone ?? date_default_timezone_get());\\n        }\\n\\n        if (static::hasRelativeKeywords($time)) {\\n            $testInstance = $testInstance->modify($time);\\n        }\\n\\n        $factory = $this->getClock()?->unwrap();\\n\\n        if (!($factory instanceof Factory)) {\\n            $factory = FactoryImmutable::getInstance();\\n        }\\n\\n        $testInstance = $factory->handleTestNowClosure($testInstance, $timezone);\\n\\n        $time = $testInstance instanceof self\\n            ? $testInstance->rawFormat(static::MOCK_DATETIME_FORMAT)\\n            : $testInstance->format(static::MOCK_DATETIME_FORMAT);\\n    }\\n\\n    private function getMockedTestNowClone($timezone): CarbonInterface|self|null\\n    {\\n        $mock = static::getMockedTestNow($timezone);\\n\\n        return $mock ? clone $mock : null;\\n    }\\n\\n    private function nowFromClock(?CarbonTimeZone $timezone): ?DateTimeImmutable\\n    {\\n        $now = $this->clock?->now();\\n\\n        return $now && $timezone ? $now->setTimezone($timezone) : null;\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Traits\/ObjectInitialisation.php\",\"ext\":\"php\",\"size\":448,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon\\\\Traits;\\n\\ntrait ObjectInitialisation\\n{\\n    \/**\\n     * True when parent::__construct has been called.\\n     *\\n     * @var string\\n     *\/\\n    protected $constructedObjectId;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Traits\/Cast.php\",\"ext\":\"php\",\"size\":1187,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon\\\\Traits;\\n\\nuse Carbon\\\\Exceptions\\\\InvalidCastException;\\nuse DateTimeInterface;\\n\\n\/**\\n * Trait Cast.\\n *\\n * Utils to cast into an other class.\\n *\/\\ntrait Cast\\n{\\n    \/**\\n     * Cast the current instance into the given class.\\n     *\\n     * @template T\\n     *\\n     * @param class-string<T> $className The $className::instance() method will be called to cast the current object.\\n     *\\n     * @return T\\n     *\/\\n    public function cast(string $className): mixed\\n    {\\n        if (!method_exists($className, 'instance')) {\\n            if (is_a($className, DateTimeInterface::class, true)) {\\n                return $className::createFromFormat('U.u', $this->rawFormat('U.u'))\\n                    ->setTimezone($this->getTimezone());\\n            }\\n\\n            throw new InvalidCastException(\\\"$className has not the instance() method needed to cast the date.\\\");\\n        }\\n\\n        return $className::instance($this);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Traits\/StaticOptions.php\",\"ext\":\"php\",\"size\":5403,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon\\\\Traits;\\n\\nuse Carbon\\\\FactoryImmutable;\\n\\n\/**\\n * Options related to a static variable.\\n *\/\\ntrait StaticOptions\\n{\\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\\n    \/\/\/\/\/\/\/\/\/\/\/\/\/ Behavior customization for sub-classes \/\/\/\/\/\/\/\/\/\/\/\/\/\/\\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\\n\\n    \/**\\n     * Function to call instead of format.\\n     *\\n     * @var string|callable|null\\n     *\/\\n    protected static $formatFunction;\\n\\n    \/**\\n     * Function to call instead of createFromFormat.\\n     *\\n     * @var string|callable|null\\n     *\/\\n    protected static $createFromFormatFunction;\\n\\n    \/**\\n     * Function to call instead of parse.\\n     *\\n     * @var string|callable|null\\n     *\/\\n    protected static $parseFunction;\\n\\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\\n    \/\/\/\/\/\/\/\/\/\/\/\/\/ Use default factory for static options \/\/\/\/\/\/\/\/\/\/\/\/\/\/\\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\\n\\n    \/**\\n     * @deprecated To avoid conflict between different third-party libraries, static setters should not be used.\\n     *             You should rather use the ->settings() method.\\n     * @see settings\\n     *\\n     * Enable the strict mode (or disable with passing false).\\n     *\\n     * @param bool $strictModeEnabled\\n     *\/\\n    public static function useStrictMode(bool $strictModeEnabled = true): void\\n    {\\n        FactoryImmutable::getDefaultInstance()->useStrictMode($strictModeEnabled);\\n    }\\n\\n    \/**\\n     * Returns true if the strict mode is globally in use, false else.\\n     * (It can be overridden in specific instances.)\\n     *\\n     * @return bool\\n     *\/\\n    public static function isStrictModeEnabled(): bool\\n    {\\n        return FactoryImmutable::getInstance()->isStrictModeEnabled();\\n    }\\n\\n    \/**\\n     * @deprecated To avoid conflict between different third-party libraries, static setters should not be used.\\n     *             You should rather use the ->settings() method.\\n     *             Or you can use method variants: addMonthsWithOverflow\/addMonthsNoOverflow, same variants\\n     *             are available for quarters, years, decade, centuries, millennia (singular and plural forms).\\n     * @see settings\\n     *\\n     * Indicates if months should be calculated with overflow.\\n     *\\n     * @param bool $monthsOverflow\\n     *\\n     * @return void\\n     *\/\\n    public static function useMonthsOverflow(bool $monthsOverflow = true): void\\n    {\\n        FactoryImmutable::getDefaultInstance()->useMonthsOverflow($monthsOverflow);\\n    }\\n\\n    \/**\\n     * @deprecated To avoid conflict between different third-party libraries, static setters should not be used.\\n     *             You should rather use the ->settings() method.\\n     *             Or you can use method variants: addMonthsWithOverflow\/addMonthsNoOverflow, same variants\\n     *             are available for quarters, years, decade, centuries, millennia (singular and plural forms).\\n     * @see settings\\n     *\\n     * Reset the month overflow behavior.\\n     *\\n     * @return void\\n     *\/\\n    public static function resetMonthsOverflow(): void\\n    {\\n        FactoryImmutable::getDefaultInstance()->resetMonthsOverflow();\\n    }\\n\\n    \/**\\n     * Get the month overflow global behavior (can be overridden in specific instances).\\n     *\\n     * @return bool\\n     *\/\\n    public static function shouldOverflowMonths(): bool\\n    {\\n        return FactoryImmutable::getInstance()->shouldOverflowMonths();\\n    }\\n\\n    \/**\\n     * @deprecated To avoid conflict between different third-party libraries, static setters should not be used.\\n     *             You should rather use the ->settings() method.\\n     *             Or you can use method variants: addYearsWithOverflow\/addYearsNoOverflow, same variants\\n     *             are available for quarters, years, decade, centuries, millennia (singular and plural forms).\\n     * @see settings\\n     *\\n     * Indicates if years should be calculated with overflow.\\n     *\\n     * @param bool $yearsOverflow\\n     *\\n     * @return void\\n     *\/\\n    public static function useYearsOverflow(bool $yearsOverflow = true): void\\n    {\\n        FactoryImmutable::getDefaultInstance()->useYearsOverflow($yearsOverflow);\\n    }\\n\\n    \/**\\n     * @deprecated To avoid conflict between different third-party libraries, static setters should not be used.\\n     *             You should rather use the ->settings() method.\\n     *             Or you can use method variants: addYearsWithOverflow\/addYearsNoOverflow, same variants\\n     *             are available for quarters, years, decade, centuries, millennia (singular and plural forms).\\n     * @see settings\\n     *\\n     * Reset the month overflow behavior.\\n     *\\n     * @return void\\n     *\/\\n    public static function resetYearsOverflow(): void\\n    {\\n        FactoryImmutable::getDefaultInstance()->resetYearsOverflow();\\n    }\\n\\n    \/**\\n     * Get the month overflow global behavior (can be overridden in specific instances).\\n     *\\n     * @return bool\\n     *\/\\n    public static function shouldOverflowYears(): bool\\n    {\\n        return FactoryImmutable::getInstance()->shouldOverflowYears();\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Traits\/DeprecatedPeriodProperties.php\",\"ext\":\"php\",\"size\":1935,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon\\\\Traits;\\n\\nuse Carbon\\\\CarbonInterface;\\nuse Carbon\\\\CarbonInterval;\\n\\ntrait DeprecatedPeriodProperties\\n{\\n    \/**\\n     * Period start in PHP < 8.2.\\n     *\\n     * @var CarbonInterface\\n     *\\n     * @deprecated PHP 8.2 this property is no longer in sync with the actual period start.\\n     *\/\\n    public $start;\\n\\n    \/**\\n     * Period end in PHP < 8.2.\\n     *\\n     * @var CarbonInterface|null\\n     *\\n     * @deprecated PHP 8.2 this property is no longer in sync with the actual period end.\\n     *\/\\n    public $end;\\n\\n    \/**\\n     * Period current iterated date in PHP < 8.2.\\n     *\\n     * @var CarbonInterface|null\\n     *\\n     * @deprecated PHP 8.2 this property is no longer in sync with the actual period current iterated date.\\n     *\/\\n    public $current;\\n\\n    \/**\\n     * Period interval in PHP < 8.2.\\n     *\\n     * @var CarbonInterval|null\\n     *\\n     * @deprecated PHP 8.2 this property is no longer in sync with the actual period interval.\\n     *\/\\n    public $interval;\\n\\n    \/**\\n     * Period recurrences in PHP < 8.2.\\n     *\\n     * @var int|float|null\\n     *\\n     * @deprecated PHP 8.2 this property is no longer in sync with the actual period recurrences.\\n     *\/\\n    public $recurrences;\\n\\n    \/**\\n     * Period start included option in PHP < 8.2.\\n     *\\n     * @var bool\\n     *\\n     * @deprecated PHP 8.2 this property is no longer in sync with the actual period start included option.\\n     *\/\\n    public $include_start_date;\\n\\n    \/**\\n     * Period end included option in PHP < 8.2.\\n     *\\n     * @var bool\\n     *\\n     * @deprecated PHP 8.2 this property is no longer in sync with the actual period end included option.\\n     *\/\\n    public $include_end_date;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Traits\/Localization.php\",\"ext\":\"php\",\"size\":26173,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon\\\\Traits;\\n\\nuse Carbon\\\\CarbonInterface;\\nuse Carbon\\\\Exceptions\\\\InvalidTypeException;\\nuse Carbon\\\\Exceptions\\\\NotLocaleAwareException;\\nuse Carbon\\\\Language;\\nuse Carbon\\\\Translator;\\nuse Carbon\\\\TranslatorStrongTypeInterface;\\nuse Closure;\\nuse Symfony\\\\Component\\\\Translation\\\\TranslatorBagInterface;\\nuse Symfony\\\\Contracts\\\\Translation\\\\LocaleAwareInterface;\\nuse Symfony\\\\Contracts\\\\Translation\\\\TranslatorInterface;\\n\\n\/**\\n * Trait Localization.\\n *\\n * Embed default and locale translators and translation base methods.\\n *\/\\ntrait Localization\\n{\\n    use StaticLocalization;\\n\\n    \/**\\n     * Specific translator of the current instance.\\n     *\/\\n    protected ?TranslatorInterface $localTranslator = null;\\n\\n    \/**\\n     * Return true if the current instance has its own translator.\\n     *\/\\n    public function hasLocalTranslator(): bool\\n    {\\n        return isset($this->localTranslator);\\n    }\\n\\n    \/**\\n     * Get the translator of the current instance or the default if none set.\\n     *\/\\n    public function getLocalTranslator(): TranslatorInterface\\n    {\\n        return $this->localTranslator ?? $this->transmitFactory(static fn () => static::getTranslator());\\n    }\\n\\n    \/**\\n     * Set the translator for the current instance.\\n     *\/\\n    public function setLocalTranslator(TranslatorInterface $translator): self\\n    {\\n        $this->localTranslator = $translator;\\n\\n        return $this;\\n    }\\n\\n    \/**\\n     * Returns raw translation message for a given key.\\n     *\\n     * @param TranslatorInterface|null $translator the translator to use\\n     * @param string                   $key        key to find\\n     * @param string|null              $locale     current locale used if null\\n     * @param string|null              $default    default value if translation returns the key\\n     *\\n     * @return string|Closure|null\\n     *\/\\n    public static function getTranslationMessageWith($translator, string $key, ?string $locale = null, ?string $default = null)\\n    {\\n        if (!($translator instanceof TranslatorBagInterface && $translator instanceof TranslatorInterface)) {\\n            throw new InvalidTypeException(\\n                'Translator does not implement '.TranslatorInterface::class.' and '.TranslatorBagInterface::class.'. '.\\n                (\\\\is_object($translator) ? \\\\get_class($translator) : \\\\gettype($translator)).' has been given.',\\n            );\\n        }\\n\\n        if (!$locale && $translator instanceof LocaleAwareInterface) {\\n            $locale = $translator->getLocale();\\n        }\\n\\n        $result = self::getFromCatalogue($translator, $translator->getCatalogue($locale), $key);\\n\\n        return $result === $key ? $default : $result;\\n    }\\n\\n    \/**\\n     * Returns raw translation message for a given key.\\n     *\\n     * @param string              $key        key to find\\n     * @param string|null         $locale     current locale used if null\\n     * @param string|null         $default    default value if translation returns the key\\n     * @param TranslatorInterface $translator an optional translator to use\\n     *\\n     * @return string\\n     *\/\\n    public function getTranslationMessage(string $key, ?string $locale = null, ?string $default = null, $translator = null)\\n    {\\n        return static::getTranslationMessageWith($translator ?? $this->getLocalTranslator(), $key, $locale, $default);\\n    }\\n\\n    \/**\\n     * Translate using translation string or callback available.\\n     *\\n     * @param TranslatorInterface $translator an optional translator to use\\n     * @param string              $key        key to find\\n     * @param array               $parameters replacement parameters\\n     * @param int|float|null      $number     number if plural\\n     *\\n     * @return string\\n     *\/\\n    public static function translateWith(TranslatorInterface $translator, string $key, array $parameters = [], $number = null): string\\n    {\\n        $message = static::getTranslationMessageWith($translator, $key, null, $key);\\n        if ($message instanceof Closure) {\\n            return (string) $message(...array_values($parameters));\\n        }\\n\\n        if ($number !== null) {\\n            $parameters['%count%'] = $number;\\n        }\\n        if (isset($parameters['%count%'])) {\\n            $parameters[':count'] = $parameters['%count%'];\\n        }\\n\\n        return (string) $translator->trans($key, $parameters);\\n    }\\n\\n    \/**\\n     * Translate using translation string or callback available.\\n     *\\n     * @param string                   $key        key to find\\n     * @param array                    $parameters replacement parameters\\n     * @param string|int|float|null    $number     number if plural\\n     * @param TranslatorInterface|null $translator an optional translator to use\\n     * @param bool                     $altNumbers pass true to use alternative numbers\\n     *\\n     * @return string\\n     *\/\\n    public function translate(\\n        string $key,\\n        array $parameters = [],\\n        string|int|float|null $number = null,\\n        ?TranslatorInterface $translator = null,\\n        bool $altNumbers = false,\\n    ): string {\\n        $translation = static::translateWith($translator ?? $this->getLocalTranslator(), $key, $parameters, $number);\\n\\n        if ($number !== null && $altNumbers) {\\n            return str_replace((string) $number, $this->translateNumber((int) $number), $translation);\\n        }\\n\\n        return $translation;\\n    }\\n\\n    \/**\\n     * Returns the alternative number for a given integer if available in the current locale.\\n     *\\n     * @param int $number\\n     *\\n     * @return string\\n     *\/\\n    public function translateNumber(int $number): string\\n    {\\n        $translateKey = \\\"alt_numbers.$number\\\";\\n        $symbol = $this->translate($translateKey);\\n\\n        if ($symbol !== $translateKey) {\\n            return $symbol;\\n        }\\n\\n        if ($number > 99 && $this->translate('alt_numbers.99') !== 'alt_numbers.99') {\\n            $start = '';\\n            foreach ([10000, 1000, 100] as $exp) {\\n                $key = \\\"alt_numbers_pow.$exp\\\";\\n                if ($number >= $exp && $number < $exp * 10 && ($pow = $this->translate($key)) !== $key) {\\n                    $unit = floor($number \/ $exp);\\n                    $number -= $unit * $exp;\\n                    $start .= ($unit > 1 ? $this->translate(\\\"alt_numbers.$unit\\\") : '').$pow;\\n                }\\n            }\\n            $result = '';\\n            while ($number) {\\n                $chunk = $number % 100;\\n                $result = $this->translate(\\\"alt_numbers.$chunk\\\").$result;\\n                $number = floor($number \/ 100);\\n            }\\n\\n            return \\\"$start$result\\\";\\n        }\\n\\n        if ($number > 9 && $this->translate('alt_numbers.9') !== 'alt_numbers.9') {\\n            $result = '';\\n            while ($number) {\\n                $chunk = $number % 10;\\n                $result = $this->translate(\\\"alt_numbers.$chunk\\\").$result;\\n                $number = floor($number \/ 10);\\n            }\\n\\n            return $result;\\n        }\\n\\n        return (string) $number;\\n    }\\n\\n    \/**\\n     * Translate a time string from a locale to an other.\\n     *\\n     * @param string      $timeString date\/time\/duration string to translate (may also contain English)\\n     * @param string|null $from       input locale of the $timeString parameter (`Carbon::getLocale()` by default)\\n     * @param string|null $to         output locale of the result returned (`\\\"en\\\"` by default)\\n     * @param int         $mode       specify what to translate with options:\\n     *                                - CarbonInterface::TRANSLATE_ALL (default)\\n     *                                - CarbonInterface::TRANSLATE_MONTHS\\n     *                                - CarbonInterface::TRANSLATE_DAYS\\n     *                                - CarbonInterface::TRANSLATE_UNITS\\n     *                                - CarbonInterface::TRANSLATE_MERIDIEM\\n     *                                You can use pipe to group: CarbonInterface::TRANSLATE_MONTHS | CarbonInterface::TRANSLATE_DAYS\\n     *\\n     * @return string\\n     *\/\\n    public static function translateTimeString(\\n        string $timeString,\\n        ?string $from = null,\\n        ?string $to = null,\\n        int $mode = CarbonInterface::TRANSLATE_ALL,\\n    ): string {\\n        \/\/ Fallback source and destination locales\\n        $from = $from ?: static::getLocale();\\n        $to = $to ?: CarbonInterface::DEFAULT_LOCALE;\\n\\n        if ($from === $to) {\\n            return $timeString;\\n        }\\n\\n        \/\/ Standardize apostrophe\\n        $timeString = strtr($timeString, ['\u2019' => \\\"'\\\"]);\\n\\n        $fromTranslations = [];\\n        $toTranslations = [];\\n\\n        foreach (['from', 'to'] as $key) {\\n            $language = $$key;\\n            $translator = Translator::get($language);\\n            $translations = $translator->getMessages();\\n\\n            if (!isset($translations[$language])) {\\n                return $timeString;\\n            }\\n\\n            $translationKey = $key.'Translations';\\n            $messages = $translations[$language];\\n            $months = $messages['months'] ?? [];\\n            $weekdays = $messages['weekdays'] ?? [];\\n            $meridiem = $messages['meridiem'] ?? ['AM', 'PM'];\\n\\n            if (isset($messages['ordinal_words'])) {\\n                $timeString = self::replaceOrdinalWords(\\n                    $timeString,\\n                    $key === 'from' ? array_flip($messages['ordinal_words']) : $messages['ordinal_words']\\n                );\\n            }\\n\\n            if ($key === 'from') {\\n                foreach (['months', 'weekdays'] as $variable) {\\n                    $list = $messages[$variable.'_standalone'] ?? null;\\n\\n                    if ($list) {\\n                        foreach ($$variable as $index => &$name) {\\n                            $name .= '|'.$messages[$variable.'_standalone'][$index];\\n                        }\\n                    }\\n                }\\n            }\\n\\n            $$translationKey = array_merge(\\n                $mode & CarbonInterface::TRANSLATE_MONTHS ? static::getTranslationArray($months, static::MONTHS_PER_YEAR, $timeString) : [],\\n                $mode & CarbonInterface::TRANSLATE_MONTHS ? static::getTranslationArray($messages['months_short'] ?? [], static::MONTHS_PER_YEAR, $timeString) : [],\\n                $mode & CarbonInterface::TRANSLATE_DAYS ? static::getTranslationArray($weekdays, static::DAYS_PER_WEEK, $timeString) : [],\\n                $mode & CarbonInterface::TRANSLATE_DAYS ? static::getTranslationArray($messages['weekdays_short'] ?? [], static::DAYS_PER_WEEK, $timeString) : [],\\n                $mode & CarbonInterface::TRANSLATE_DIFF ? static::translateWordsByKeys([\\n                    'diff_now',\\n                    'diff_today',\\n                    'diff_yesterday',\\n                    'diff_tomorrow',\\n                    'diff_before_yesterday',\\n                    'diff_after_tomorrow',\\n                ], $messages, $key) : [],\\n                $mode & CarbonInterface::TRANSLATE_UNITS ? static::translateWordsByKeys([\\n                    'year',\\n                    'month',\\n                    'week',\\n                    'day',\\n                    'hour',\\n                    'minute',\\n                    'second',\\n                ], $messages, $key) : [],\\n                $mode & CarbonInterface::TRANSLATE_MERIDIEM ? array_map(function ($hour) use ($meridiem) {\\n                    if (\\\\is_array($meridiem)) {\\n                        return $meridiem[$hour < static::HOURS_PER_DAY \/ 2 ? 0 : 1];\\n                    }\\n\\n                    return $meridiem($hour, 0, false);\\n                }, range(0, 23)) : [],\\n            );\\n        }\\n\\n        return substr(preg_replace_callback('\/(?<=[\\\\d\\\\s+.\\\\\/,_-])('.implode('|', $fromTranslations).')(?=[\\\\d\\\\s+.\\\\\/,_-])\/iu', function ($match) use ($fromTranslations, $toTranslations) {\\n            [$chunk] = $match;\\n\\n            foreach ($fromTranslations as $index => $word) {\\n                if (preg_match(\\\"\/^$word\\\\$\/iu\\\", $chunk)) {\\n                    return $toTranslations[$index] ?? '';\\n                }\\n            }\\n\\n            return $chunk; \/\/ @codeCoverageIgnore\\n        }, \\\" $timeString \\\"), 1, -1);\\n    }\\n\\n    \/**\\n     * Translate a time string from the current locale (`$date->locale()`) to another one.\\n     *\\n     * @param string      $timeString time string to translate\\n     * @param string|null $to         output locale of the result returned (\\\"en\\\" by default)\\n     *\\n     * @return string\\n     *\/\\n    public function translateTimeStringTo(string $timeString, ?string $to = null): string\\n    {\\n        return static::translateTimeString($timeString, $this->getTranslatorLocale(), $to);\\n    }\\n\\n    \/**\\n     * Get\/set the locale for the current instance.\\n     *\\n     * @param string|null $locale\\n     * @param string      ...$fallbackLocales\\n     *\\n     * @return $this|string\\n     *\/\\n    public function locale(?string $locale = null, string ...$fallbackLocales): static|string\\n    {\\n        if ($locale === null) {\\n            return $this->getTranslatorLocale();\\n        }\\n\\n        if (!$this->localTranslator || $this->getTranslatorLocale($this->localTranslator) !== $locale) {\\n            $translator = Translator::get($locale);\\n\\n            if (!empty($fallbackLocales)) {\\n                $translator->setFallbackLocales($fallbackLocales);\\n\\n                foreach ($fallbackLocales as $fallbackLocale) {\\n                    $messages = Translator::get($fallbackLocale)->getMessages();\\n\\n                    if (isset($messages[$fallbackLocale])) {\\n                        $translator->setMessages($fallbackLocale, $messages[$fallbackLocale]);\\n                    }\\n                }\\n            }\\n\\n            $this->localTranslator = $translator;\\n        }\\n\\n        return $this;\\n    }\\n\\n    \/**\\n     * Get the current translator locale.\\n     *\\n     * @return string\\n     *\/\\n    public static function getLocale(): string\\n    {\\n        return static::getLocaleAwareTranslator()->getLocale();\\n    }\\n\\n    \/**\\n     * Set the current translator locale and indicate if the source locale file exists.\\n     * Pass 'auto' as locale to use the closest language to the current LC_TIME locale.\\n     *\\n     * @param string $locale locale ex. en\\n     *\/\\n    public static function setLocale(string $locale): void\\n    {\\n        static::getLocaleAwareTranslator()->setLocale($locale);\\n    }\\n\\n    \/**\\n     * Set the fallback locale.\\n     *\\n     * @see https:\/\/symfony.com\/doc\/current\/components\/translation.html#fallback-locales\\n     *\\n     * @param string $locale\\n     *\/\\n    public static function setFallbackLocale(string $locale): void\\n    {\\n        $translator = static::getTranslator();\\n\\n        if (method_exists($translator, 'setFallbackLocales')) {\\n            $translator->setFallbackLocales([$locale]);\\n\\n            if ($translator instanceof Translator) {\\n                $preferredLocale = $translator->getLocale();\\n                $translator->setMessages($preferredLocale, array_replace_recursive(\\n                    $translator->getMessages()[$locale] ?? [],\\n                    Translator::get($locale)->getMessages()[$locale] ?? [],\\n                    $translator->getMessages($preferredLocale),\\n                ));\\n            }\\n        }\\n    }\\n\\n    \/**\\n     * Get the fallback locale.\\n     *\\n     * @see https:\/\/symfony.com\/doc\/current\/components\/translation.html#fallback-locales\\n     *\/\\n    public static function getFallbackLocale(): ?string\\n    {\\n        $translator = static::getTranslator();\\n\\n        if (method_exists($translator, 'getFallbackLocales')) {\\n            return $translator->getFallbackLocales()[0] ?? null;\\n        }\\n\\n        return null;\\n    }\\n\\n    \/**\\n     * Set the current locale to the given, execute the passed function, reset the locale to previous one,\\n     * then return the result of the closure (or null if the closure was void).\\n     *\\n     * @param string   $locale locale ex. en\\n     * @param callable $func\\n     *\\n     * @return mixed\\n     *\/\\n    public static function executeWithLocale(string $locale, callable $func): mixed\\n    {\\n        $currentLocale = static::getLocale();\\n        static::setLocale($locale);\\n        $newLocale = static::getLocale();\\n        $result = $func(\\n            $newLocale === 'en' && strtolower(substr((string) $locale, 0, 2)) !== 'en'\\n                ? false\\n                : $newLocale,\\n            static::getTranslator(),\\n        );\\n        static::setLocale($currentLocale);\\n\\n        return $result;\\n    }\\n\\n    \/**\\n     * Returns true if the given locale is internally supported and has short-units support.\\n     * Support is considered enabled if either year, day or hour has a short variant translated.\\n     *\\n     * @param string $locale locale ex. en\\n     *\\n     * @return bool\\n     *\/\\n    public static function localeHasShortUnits(string $locale): bool\\n    {\\n        return static::executeWithLocale($locale, function ($newLocale, TranslatorInterface $translator) {\\n            return ($newLocale && (($y = static::translateWith($translator, 'y')) !== 'y' && $y !== static::translateWith($translator, 'year'))) || (\\n                ($y = static::translateWith($translator, 'd')) !== 'd' &&\\n                    $y !== static::translateWith($translator, 'day')\\n            ) || (\\n                ($y = static::translateWith($translator, 'h')) !== 'h' &&\\n                    $y !== static::translateWith($translator, 'hour')\\n            );\\n        });\\n    }\\n\\n    \/**\\n     * Returns true if the given locale is internally supported and has diff syntax support (ago, from now, before, after).\\n     * Support is considered enabled if the 4 sentences are translated in the given locale.\\n     *\\n     * @param string $locale locale ex. en\\n     *\\n     * @return bool\\n     *\/\\n    public static function localeHasDiffSyntax(string $locale): bool\\n    {\\n        return static::executeWithLocale($locale, function ($newLocale, TranslatorInterface $translator) {\\n            if (!$newLocale) {\\n                return false;\\n            }\\n\\n            foreach (['ago', 'from_now', 'before', 'after'] as $key) {\\n                if ($translator instanceof TranslatorBagInterface &&\\n                    self::getFromCatalogue($translator, $translator->getCatalogue($newLocale), $key) instanceof Closure\\n                ) {\\n                    continue;\\n                }\\n\\n                if ($translator->trans($key) === $key) {\\n                    return false;\\n                }\\n            }\\n\\n            return true;\\n        });\\n    }\\n\\n    \/**\\n     * Returns true if the given locale is internally supported and has words for 1-day diff (just now, yesterday, tomorrow).\\n     * Support is considered enabled if the 3 words are translated in the given locale.\\n     *\\n     * @param string $locale locale ex. en\\n     *\\n     * @return bool\\n     *\/\\n    public static function localeHasDiffOneDayWords(string $locale): bool\\n    {\\n        return static::executeWithLocale($locale, function ($newLocale, TranslatorInterface $translator) {\\n            return $newLocale &&\\n                $translator->trans('diff_now') !== 'diff_now' &&\\n                $translator->trans('diff_yesterday') !== 'diff_yesterday' &&\\n                $translator->trans('diff_tomorrow') !== 'diff_tomorrow';\\n        });\\n    }\\n\\n    \/**\\n     * Returns true if the given locale is internally supported and has words for 2-days diff (before yesterday, after tomorrow).\\n     * Support is considered enabled if the 2 words are translated in the given locale.\\n     *\\n     * @param string $locale locale ex. en\\n     *\\n     * @return bool\\n     *\/\\n    public static function localeHasDiffTwoDayWords(string $locale): bool\\n    {\\n        return static::executeWithLocale($locale, function ($newLocale, TranslatorInterface $translator) {\\n            return $newLocale &&\\n                $translator->trans('diff_before_yesterday') !== 'diff_before_yesterday' &&\\n                $translator->trans('diff_after_tomorrow') !== 'diff_after_tomorrow';\\n        });\\n    }\\n\\n    \/**\\n     * Returns true if the given locale is internally supported and has period syntax support (X times, every X, from X, to X).\\n     * Support is considered enabled if the 4 sentences are translated in the given locale.\\n     *\\n     * @param string $locale locale ex. en\\n     *\\n     * @return bool\\n     *\/\\n    public static function localeHasPeriodSyntax($locale)\\n    {\\n        return static::executeWithLocale($locale, function ($newLocale, TranslatorInterface $translator) {\\n            return $newLocale &&\\n                $translator->trans('period_recurrences') !== 'period_recurrences' &&\\n                $translator->trans('period_interval') !== 'period_interval' &&\\n                $translator->trans('period_start_date') !== 'period_start_date' &&\\n                $translator->trans('period_end_date') !== 'period_end_date';\\n        });\\n    }\\n\\n    \/**\\n     * Returns the list of internally available locales and already loaded custom locales.\\n     * (It will ignore custom translator dynamic loading.)\\n     *\\n     * @return array\\n     *\/\\n    public static function getAvailableLocales()\\n    {\\n        $translator = static::getLocaleAwareTranslator();\\n\\n        return $translator instanceof Translator\\n            ? $translator->getAvailableLocales()\\n            : [$translator->getLocale()];\\n    }\\n\\n    \/**\\n     * Returns list of Language object for each available locale. This object allow you to get the ISO name, native\\n     * name, region and variant of the locale.\\n     *\\n     * @return Language[]\\n     *\/\\n    public static function getAvailableLocalesInfo()\\n    {\\n        $languages = [];\\n        foreach (static::getAvailableLocales() as $id) {\\n            $languages[$id] = new Language($id);\\n        }\\n\\n        return $languages;\\n    }\\n\\n    \/**\\n     * Get the locale of a given translator.\\n     *\\n     * If null or omitted, current local translator is used.\\n     * If no local translator is in use, current global translator is used.\\n     *\/\\n    protected function getTranslatorLocale($translator = null): ?string\\n    {\\n        if (\\\\func_num_args() === 0) {\\n            $translator = $this->getLocalTranslator();\\n        }\\n\\n        $translator = static::getLocaleAwareTranslator($translator);\\n\\n        return $translator?->getLocale();\\n    }\\n\\n    \/**\\n     * Throw an error if passed object is not LocaleAwareInterface.\\n     *\\n     * @param LocaleAwareInterface|null $translator\\n     *\\n     * @return LocaleAwareInterface|null\\n     *\/\\n    protected static function getLocaleAwareTranslator($translator = null)\\n    {\\n        if (\\\\func_num_args() === 0) {\\n            $translator = static::getTranslator();\\n        }\\n\\n        if ($translator && !($translator instanceof LocaleAwareInterface || method_exists($translator, 'getLocale'))) {\\n            throw new NotLocaleAwareException($translator); \/\/ @codeCoverageIgnore\\n        }\\n\\n        return $translator;\\n    }\\n\\n    \/**\\n     * @param mixed                                                    $translator\\n     * @param \\\\Symfony\\\\Component\\\\Translation\\\\MessageCatalogueInterface $catalogue\\n     *\\n     * @return mixed\\n     *\/\\n    private static function getFromCatalogue($translator, $catalogue, string $id, string $domain = 'messages')\\n    {\\n        return $translator instanceof TranslatorStrongTypeInterface\\n            ? $translator->getFromCatalogue($catalogue, $id, $domain)\\n            : $catalogue->get($id, $domain); \/\/ @codeCoverageIgnore\\n    }\\n\\n    \/**\\n     * Return the word cleaned from its translation codes.\\n     *\\n     * @param string $word\\n     *\\n     * @return string\\n     *\/\\n    private static function cleanWordFromTranslationString($word)\\n    {\\n        $word = str_replace([':count', '%count', ':time'], '', $word);\\n        $word = strtr($word, ['\u2019' => \\\"'\\\"]);\\n        $word = preg_replace(\\n            '\/\\\\{(?:-?\\\\d+(?:\\\\.\\\\d+)?|-?Inf)(?:,(?:-?\\\\d+|-?Inf))?}|[\\\\[\\\\]](?:-?\\\\d+(?:\\\\.\\\\d+)?|-?Inf)(?:,(?:-?\\\\d+|-?Inf))?[\\\\[\\\\]]\/',\\n            '',\\n            $word,\\n        );\\n\\n        return trim($word);\\n    }\\n\\n    \/**\\n     * Translate a list of words.\\n     *\\n     * @param string[] $keys     keys to translate.\\n     * @param string[] $messages messages bag handling translations.\\n     * @param string   $key      'to' (to get the translation) or 'from' (to get the detection RegExp pattern).\\n     *\\n     * @return string[]\\n     *\/\\n    private static function translateWordsByKeys($keys, $messages, $key): array\\n    {\\n        return array_map(function ($wordKey) use ($messages, $key) {\\n            $message = $key === 'from' && isset($messages[$wordKey.'_regexp'])\\n                ? $messages[$wordKey.'_regexp']\\n                : ($messages[$wordKey] ?? null);\\n\\n            if (!$message) {\\n                return '>>DO NOT REPLACE<<';\\n            }\\n\\n            $parts = explode('|', $message);\\n\\n            return $key === 'to'\\n                ? self::cleanWordFromTranslationString(end($parts))\\n                : '(?:'.implode('|', array_map(static::cleanWordFromTranslationString(...), $parts)).')';\\n        }, $keys);\\n    }\\n\\n    \/**\\n     * Get an array of translations based on the current date.\\n     *\\n     * @param callable $translation\\n     * @param int      $length\\n     * @param string   $timeString\\n     *\\n     * @return string[]\\n     *\/\\n    private static function getTranslationArray($translation, $length, $timeString): array\\n    {\\n        $filler = '>>DO NOT REPLACE<<';\\n\\n        if (\\\\is_array($translation)) {\\n            return array_pad($translation, $length, $filler);\\n        }\\n\\n        $list = [];\\n        $date = static::now();\\n\\n        for ($i = 0; $i < $length; $i++) {\\n            $list[] = $translation($date, $timeString, $i) ?? $filler;\\n        }\\n\\n        return $list;\\n    }\\n\\n    private static function replaceOrdinalWords(string $timeString, array $ordinalWords): string\\n    {\\n        return preg_replace_callback('\/(?<![a-z])[a-z]+(?![a-z])\/i', function (array $match) use ($ordinalWords) {\\n            return $ordinalWords[mb_strtolower($match[0])] ?? $match[0];\\n        }, $timeString);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Traits\/Serialization.php\",\"ext\":\"php\",\"size\":9085,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon\\\\Traits;\\n\\nuse Carbon\\\\Exceptions\\\\InvalidFormatException;\\nuse Carbon\\\\FactoryImmutable;\\nuse DateTimeZone;\\nuse ReturnTypeWillChange;\\nuse Throwable;\\n\\n\/**\\n * Trait Serialization.\\n *\\n * Serialization and JSON stuff.\\n *\\n * Depends on the following properties:\\n *\\n * @property int $year\\n * @property int $month\\n * @property int $daysInMonth\\n * @property int $quarter\\n *\\n * Depends on the following methods:\\n *\\n * @method string|static locale(string $locale = null, string ...$fallbackLocales)\\n * @method string        toJSON()\\n *\/\\ntrait Serialization\\n{\\n    use ObjectInitialisation;\\n\\n    \/**\\n     * List of key to use for dump\/serialization.\\n     *\\n     * @var string[]\\n     *\/\\n    protected array $dumpProperties = ['date', 'timezone_type', 'timezone'];\\n\\n    \/**\\n     * Locale to dump comes here before serialization.\\n     *\\n     * @var string|null\\n     *\/\\n    protected $dumpLocale;\\n\\n    \/**\\n     * Embed date properties to dump in a dedicated variables so it won't overlap native\\n     * DateTime ones.\\n     *\\n     * @var array|null\\n     *\/\\n    protected $dumpDateProperties;\\n\\n    \/**\\n     * Return a serialized string of the instance.\\n     *\/\\n    public function serialize(): string\\n    {\\n        return serialize($this);\\n    }\\n\\n    \/**\\n     * Create an instance from a serialized string.\\n     *\\n     * If $value is not from a trusted source, consider using the allowed_classes option to limit\\n     * the types of objects that can be built, for instance:\\n     *\\n     * @example\\n     * ```php\\n     * $object = Carbon::fromSerialized($value, ['allowed_classes' => [Carbon::class, CarbonImmutable::class]]);\\n     * ```\\n     *\\n     * @param \\\\Stringable|string $value\\n     * @param array              $options example: ['allowed_classes' => [CarbonImmutable::class]]\\n     *\\n     * @throws InvalidFormatException\\n     *\\n     * @return static\\n     *\/\\n    public static function fromSerialized($value, array $options = []): static\\n    {\\n        $instance = @unserialize((string) $value, $options);\\n\\n        if (!$instance instanceof static) {\\n            throw new InvalidFormatException(\\\"Invalid serialized value: $value\\\");\\n        }\\n\\n        return $instance;\\n    }\\n\\n    \/**\\n     * The __set_state handler.\\n     *\\n     * @param string|array $dump\\n     *\\n     * @return static\\n     *\/\\n    #[ReturnTypeWillChange]\\n    public static function __set_state($dump): static\\n    {\\n        if (\\\\is_string($dump)) {\\n            return static::parse($dump);\\n        }\\n\\n        \/** @var \\\\DateTimeInterface $date *\/\\n        $date = get_parent_class(static::class) && method_exists(parent::class, '__set_state')\\n            ? parent::__set_state((array) $dump)\\n            : (object) $dump;\\n\\n        return static::instance($date);\\n    }\\n\\n    \/**\\n     * Returns the list of properties to dump on serialize() called on.\\n     *\\n     * Only used by PHP < 7.4.\\n     *\\n     * @return array\\n     *\/\\n    public function __sleep()\\n    {\\n        $properties = $this->getSleepProperties();\\n\\n        if ($this->localTranslator ?? null) {\\n            $properties[] = 'dumpLocale';\\n            $this->dumpLocale = $this->locale ?? null;\\n        }\\n\\n        return $properties;\\n    }\\n\\n    \/**\\n     * Returns the values to dump on serialize() called on.\\n     *\\n     * Only used by PHP >= 7.4.\\n     *\\n     * @return array\\n     *\/\\n    public function __serialize(): array\\n    {\\n        \/\/ @codeCoverageIgnoreStart\\n        if (isset($this->timezone_type, $this->timezone, $this->date)) {\\n            return [\\n                'date' => $this->date,\\n                'timezone_type' => $this->timezone_type,\\n                'timezone' => $this->dumpTimezone($this->timezone),\\n            ];\\n        }\\n        \/\/ @codeCoverageIgnoreEnd\\n\\n        $timezone = $this->getTimezone();\\n        $export = [\\n            'date' => $this->format('Y-m-d H:i:s.u'),\\n            'timezone_type' => $timezone->getType(),\\n            'timezone' => $timezone->getName(),\\n        ];\\n\\n        \/\/ @codeCoverageIgnoreStart\\n        if (\\\\extension_loaded('msgpack') && isset($this->constructedObjectId)) {\\n            $timezone = $this->timezone ?? null;\\n            $export['dumpDateProperties'] = [\\n                'date' => $this->format('Y-m-d H:i:s.u'),\\n                'timezone' => $this->dumpTimezone($timezone),\\n            ];\\n        }\\n        \/\/ @codeCoverageIgnoreEnd\\n\\n        if ($this->localTranslator ?? null) {\\n            $export['dumpLocale'] = $this->locale ?? null;\\n        }\\n\\n        return $export;\\n    }\\n\\n    \/**\\n     * Set locale if specified on unserialize() called.\\n     *\\n     * Only used by PHP < 7.4.\\n     *\/\\n    public function __wakeup(): void\\n    {\\n        if (parent::class && method_exists(parent::class, '__wakeup')) {\\n            \/\/ @codeCoverageIgnoreStart\\n            try {\\n                parent::__wakeup();\\n            } catch (Throwable $exception) {\\n                try {\\n                    \/\/ FatalError occurs when calling msgpack_unpack() in PHP 7.4 or later.\\n                    ['date' => $date, 'timezone' => $timezone] = $this->dumpDateProperties;\\n                    parent::__construct($date, $timezone);\\n                } catch (Throwable) {\\n                    throw $exception;\\n                }\\n            }\\n            \/\/ @codeCoverageIgnoreEnd\\n        }\\n\\n        $this->constructedObjectId = spl_object_hash($this);\\n\\n        if (isset($this->dumpLocale)) {\\n            $this->locale($this->dumpLocale);\\n            $this->dumpLocale = null;\\n        }\\n\\n        $this->cleanupDumpProperties();\\n    }\\n\\n    \/**\\n     * Set locale if specified on unserialize() called.\\n     *\\n     * Only used by PHP >= 7.4.\\n     *\/\\n    public function __unserialize(array $data): void\\n    {\\n        \/\/ @codeCoverageIgnoreStart\\n        try {\\n            $this->__construct($data['date'] ?? null, $data['timezone'] ?? null);\\n        } catch (Throwable $exception) {\\n            if (!isset($data['dumpDateProperties']['date'], $data['dumpDateProperties']['timezone'])) {\\n                throw $exception;\\n            }\\n\\n            try {\\n                \/\/ FatalError occurs when calling msgpack_unpack() in PHP 7.4 or later.\\n                ['date' => $date, 'timezone' => $timezone] = $data['dumpDateProperties'];\\n                $this->__construct($date, $timezone);\\n            } catch (Throwable) {\\n                throw $exception;\\n            }\\n        }\\n        \/\/ @codeCoverageIgnoreEnd\\n\\n        if (isset($data['dumpLocale'])) {\\n            $this->locale($data['dumpLocale']);\\n        }\\n    }\\n\\n    \/**\\n     * Prepare the object for JSON serialization.\\n     *\/\\n    public function jsonSerialize(): mixed\\n    {\\n        $serializer = $this->localSerializer\\n            ?? $this->getFactory()->getSettings()['toJsonFormat']\\n            ?? null;\\n\\n        if ($serializer) {\\n            return \\\\is_string($serializer)\\n                ? $this->rawFormat($serializer)\\n                : $serializer($this);\\n        }\\n\\n        return $this->toJSON();\\n    }\\n\\n    \/**\\n     * @deprecated To avoid conflict between different third-party libraries, static setters should not be used.\\n     *             You should rather transform Carbon object before the serialization.\\n     *\\n     * JSON serialize all Carbon instances using the given callback.\\n     *\/\\n    public static function serializeUsing(string|callable|null $format): void\\n    {\\n        FactoryImmutable::getDefaultInstance()->serializeUsing($format);\\n    }\\n\\n    \/**\\n     * Cleanup properties attached to the public scope of DateTime when a dump of the date is requested.\\n     * foreach ($date as $_) {}\\n     * serializer($date)\\n     * var_export($date)\\n     * get_object_vars($date)\\n     *\/\\n    public function cleanupDumpProperties(): self\\n    {\\n        \/\/ @codeCoverageIgnoreStart\\n        if (PHP_VERSION < 8.2) {\\n            foreach ($this->dumpProperties as $property) {\\n                if (isset($this->$property)) {\\n                    unset($this->$property);\\n                }\\n            }\\n        }\\n        \/\/ @codeCoverageIgnoreEnd\\n\\n        return $this;\\n    }\\n\\n    private function getSleepProperties(): array\\n    {\\n        $properties = $this->dumpProperties;\\n\\n        \/\/ @codeCoverageIgnoreStart\\n        if (!\\\\extension_loaded('msgpack')) {\\n            return $properties;\\n        }\\n\\n        if (isset($this->constructedObjectId)) {\\n            $timezone = $this->timezone ?? null;\\n            $this->dumpDateProperties = [\\n                'date' => $this->format('Y-m-d H:i:s.u'),\\n                'timezone' => $this->dumpTimezone($timezone),\\n            ];\\n\\n            $properties[] = 'dumpDateProperties';\\n        }\\n\\n        return $properties;\\n        \/\/ @codeCoverageIgnoreEnd\\n    }\\n\\n    \/** @codeCoverageIgnore *\/\\n    private function dumpTimezone(mixed $timezone): mixed\\n    {\\n        return $timezone instanceof DateTimeZone ? $timezone->getName() : $timezone;\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Traits\/ToStringFormat.php\",\"ext\":\"php\",\"size\":1450,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon\\\\Traits;\\n\\nuse Carbon\\\\FactoryImmutable;\\nuse Closure;\\n\\n\/**\\n * Trait ToStringFormat.\\n *\\n * Handle global format customization for string cast of the object.\\n *\/\\ntrait ToStringFormat\\n{\\n    \/**\\n     * Reset the format used to the default when type juggling a Carbon instance to a string\\n     *\\n     * @return void\\n     *\/\\n    public static function resetToStringFormat(): void\\n    {\\n        FactoryImmutable::getDefaultInstance()->resetToStringFormat();\\n    }\\n\\n    \/**\\n     * @deprecated To avoid conflict between different third-party libraries, static setters should not be used.\\n     *             You should rather let Carbon object being cast to string with DEFAULT_TO_STRING_FORMAT, and\\n     *             use other method or custom format passed to format() method if you need to dump another string\\n     *             format.\\n     *\\n     * Set the default format used when type juggling a Carbon instance to a string.\\n     *\\n     * @param string|Closure|null $format\\n     *\\n     * @return void\\n     *\/\\n    public static function setToStringFormat(string|Closure|null $format): void\\n    {\\n        FactoryImmutable::getDefaultInstance()->setToStringFormat($format);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Traits\/Timestamp.php\",\"ext\":\"php\",\"size\":6606,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon\\\\Traits;\\n\\nuse DateTimeZone;\\n\\n\/**\\n * Trait Timestamp.\\n *\/\\ntrait Timestamp\\n{\\n    \/**\\n     * Create a Carbon instance from a timestamp and set the timezone (UTC by default).\\n     *\\n     * Timestamp input can be given as int, float or a string containing one or more numbers.\\n     *\/\\n    #[\\\\ReturnTypeWillChange]\\n    public static function createFromTimestamp(\\n        float|int|string $timestamp,\\n        DateTimeZone|string|int|null $timezone = null,\\n    ): static {\\n        $date = static::createFromTimestampUTC($timestamp);\\n\\n        return $timezone === null ? $date : $date->setTimezone($timezone);\\n    }\\n\\n    \/**\\n     * Create a Carbon instance from a timestamp keeping the timezone to UTC.\\n     *\\n     * Timestamp input can be given as int, float or a string containing one or more numbers.\\n     *\/\\n    public static function createFromTimestampUTC(float|int|string $timestamp): static\\n    {\\n        [$integer, $decimal] = self::getIntegerAndDecimalParts($timestamp);\\n        $delta = floor($decimal \/ static::MICROSECONDS_PER_SECOND);\\n        $integer += $delta;\\n        $decimal -= $delta * static::MICROSECONDS_PER_SECOND;\\n        $decimal = str_pad((string) $decimal, 6, '0', STR_PAD_LEFT);\\n\\n        return static::rawCreateFromFormat('U u', \\\"$integer $decimal\\\");\\n    }\\n\\n    \/**\\n     * Create a Carbon instance from a timestamp in milliseconds.\\n     *\\n     * Timestamp input can be given as int, float or a string containing one or more numbers.\\n     *\\n     * @param float|int|string $timestamp\\n     *\\n     * @return static\\n     *\/\\n    public static function createFromTimestampMsUTC($timestamp): static\\n    {\\n        [$milliseconds, $microseconds] = self::getIntegerAndDecimalParts($timestamp, 3);\\n        $sign = $milliseconds < 0 || ($milliseconds === 0.0 && $microseconds < 0) ? -1 : 1;\\n        $milliseconds = abs($milliseconds);\\n        $microseconds = $sign * abs($microseconds) + static::MICROSECONDS_PER_MILLISECOND * ($milliseconds % static::MILLISECONDS_PER_SECOND);\\n        $seconds = $sign * floor($milliseconds \/ static::MILLISECONDS_PER_SECOND);\\n        $delta = floor($microseconds \/ static::MICROSECONDS_PER_SECOND);\\n        $seconds = (int) ($seconds + $delta);\\n        $microseconds -= $delta * static::MICROSECONDS_PER_SECOND;\\n        $microseconds = str_pad((string) (int) $microseconds, 6, '0', STR_PAD_LEFT);\\n\\n        return static::rawCreateFromFormat('U u', \\\"$seconds $microseconds\\\");\\n    }\\n\\n    \/**\\n     * Create a Carbon instance from a timestamp in milliseconds.\\n     *\\n     * Timestamp input can be given as int, float or a string containing one or more numbers.\\n     *\/\\n    public static function createFromTimestampMs(\\n        float|int|string $timestamp,\\n        DateTimeZone|string|int|null $timezone = null,\\n    ): static {\\n        $date = static::createFromTimestampMsUTC($timestamp);\\n\\n        return $timezone === null ? $date : $date->setTimezone($timezone);\\n    }\\n\\n    \/**\\n     * Set the instance's timestamp.\\n     *\\n     * Timestamp input can be given as int, float or a string containing one or more numbers.\\n     *\/\\n    public function timestamp(float|int|string $timestamp): static\\n    {\\n        return $this->setTimestamp($timestamp);\\n    }\\n\\n    \/**\\n     * Returns a timestamp rounded with the given precision (6 by default).\\n     *\\n     * @example getPreciseTimestamp()   1532087464437474 (microsecond maximum precision)\\n     * @example getPreciseTimestamp(6)  1532087464437474\\n     * @example getPreciseTimestamp(5)  153208746443747  (1\/100000 second precision)\\n     * @example getPreciseTimestamp(4)  15320874644375   (1\/10000 second precision)\\n     * @example getPreciseTimestamp(3)  1532087464437    (millisecond precision)\\n     * @example getPreciseTimestamp(2)  153208746444     (1\/100 second precision)\\n     * @example getPreciseTimestamp(1)  15320874644      (1\/10 second precision)\\n     * @example getPreciseTimestamp(0)  1532087464       (second precision)\\n     * @example getPreciseTimestamp(-1) 153208746        (10 second precision)\\n     * @example getPreciseTimestamp(-2) 15320875         (100 second precision)\\n     *\\n     * @param int $precision\\n     *\\n     * @return float\\n     *\/\\n    public function getPreciseTimestamp($precision = 6): float\\n    {\\n        return round(((float) $this->rawFormat('Uu')) \/ pow(10, 6 - $precision));\\n    }\\n\\n    \/**\\n     * Returns the milliseconds timestamps used amongst other by Date javascript objects.\\n     *\\n     * @return float\\n     *\/\\n    public function valueOf(): float\\n    {\\n        return $this->getPreciseTimestamp(3);\\n    }\\n\\n    \/**\\n     * Returns the timestamp with millisecond precision.\\n     *\\n     * @return int\\n     *\/\\n    public function getTimestampMs(): int\\n    {\\n        return (int) $this->getPreciseTimestamp(3);\\n    }\\n\\n    \/**\\n     * @alias getTimestamp\\n     *\\n     * Returns the UNIX timestamp for the current date.\\n     *\\n     * @return int\\n     *\/\\n    public function unix(): int\\n    {\\n        return $this->getTimestamp();\\n    }\\n\\n    \/**\\n     * Return an array with integer part digits and decimals digits split from one or more positive numbers\\n     * (such as timestamps) as string with the given number of decimals (6 by default).\\n     *\\n     * By splitting integer and decimal, this method obtain a better precision than\\n     * number_format when the input is a string.\\n     *\\n     * @param float|int|string $numbers  one or more numbers\\n     * @param int              $decimals number of decimals precision (6 by default)\\n     *\\n     * @return array 0-index is integer part, 1-index is decimal part digits\\n     *\/\\n    private static function getIntegerAndDecimalParts($numbers, $decimals = 6): array\\n    {\\n        if (\\\\is_int($numbers) || \\\\is_float($numbers)) {\\n            $numbers = number_format($numbers, $decimals, '.', '');\\n        }\\n\\n        $sign = str_starts_with($numbers, '-') ? -1 : 1;\\n        $integer = 0;\\n        $decimal = 0;\\n\\n        foreach (preg_split('`[^\\\\d.]+`', $numbers) as $chunk) {\\n            [$integerPart, $decimalPart] = explode('.', \\\"$chunk.\\\");\\n\\n            $integer += (int) $integerPart;\\n            $decimal += (float) (\\\"0.$decimalPart\\\");\\n        }\\n\\n        $overflow = floor($decimal);\\n        $integer += $overflow;\\n        $decimal -= $overflow;\\n\\n        return [$sign * $integer, $decimal === 0.0 ? 0.0 : $sign * round($decimal * pow(10, $decimals))];\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Traits\/Units.php\",\"ext\":\"php\",\"size\":14515,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon\\\\Traits;\\n\\nuse Carbon\\\\CarbonConverterInterface;\\nuse Carbon\\\\CarbonInterface;\\nuse Carbon\\\\CarbonInterval;\\nuse Carbon\\\\Exceptions\\\\InvalidFormatException;\\nuse Carbon\\\\Exceptions\\\\InvalidIntervalException;\\nuse Carbon\\\\Exceptions\\\\UnitException;\\nuse Carbon\\\\Exceptions\\\\UnsupportedUnitException;\\nuse Carbon\\\\Unit;\\nuse Closure;\\nuse DateInterval;\\nuse DateMalformedStringException;\\nuse ReturnTypeWillChange;\\n\\n\/**\\n * Trait Units.\\n *\\n * Add, subtract and set units.\\n *\/\\ntrait Units\\n{\\n    \/**\\n     * @deprecated Prefer to use add addUTCUnit() which more accurately defines what it's doing.\\n     *\\n     * Add seconds to the instance using timestamp. Positive $value travels\\n     * forward while negative $value travels into the past.\\n     *\\n     * @param string         $unit\\n     * @param int|float|null $value\\n     *\\n     * @return static\\n     *\/\\n    public function addRealUnit(string $unit, $value = 1): static\\n    {\\n        return $this->addUTCUnit($unit, $value);\\n    }\\n\\n    \/**\\n     * Add seconds to the instance using timestamp. Positive $value travels\\n     * forward while negative $value travels into the past.\\n     *\\n     * @param string         $unit\\n     * @param int|float|null $value\\n     *\\n     * @return static\\n     *\/\\n    public function addUTCUnit(string $unit, $value = 1): static\\n    {\\n        $value ??= 0;\\n\\n        switch ($unit) {\\n            \/\/ @call addUTCUnit\\n            case 'micro':\\n\\n            \/\/ @call addUTCUnit\\n            case 'microsecond':\\n                \/* @var CarbonInterface $this *\/\\n                $diff = $this->microsecond + $value;\\n                $time = $this->getTimestamp();\\n                $seconds = (int) floor($diff \/ static::MICROSECONDS_PER_SECOND);\\n                $time += $seconds;\\n                $diff -= $seconds * static::MICROSECONDS_PER_SECOND;\\n                $microtime = str_pad((string) $diff, 6, '0', STR_PAD_LEFT);\\n                $timezone = $this->tz;\\n\\n                return $this->tz('UTC')->modify(\\\"@$time.$microtime\\\")->setTimezone($timezone);\\n\\n            \/\/ @call addUTCUnit\\n            case 'milli':\\n            \/\/ @call addUTCUnit\\n            case 'millisecond':\\n                return $this->addUTCUnit('microsecond', $value * static::MICROSECONDS_PER_MILLISECOND);\\n\\n            \/\/ @call addUTCUnit\\n            case 'second':\\n                break;\\n\\n            \/\/ @call addUTCUnit\\n            case 'minute':\\n                $value *= static::SECONDS_PER_MINUTE;\\n\\n                break;\\n\\n            \/\/ @call addUTCUnit\\n            case 'hour':\\n                $value *= static::MINUTES_PER_HOUR * static::SECONDS_PER_MINUTE;\\n\\n                break;\\n\\n            \/\/ @call addUTCUnit\\n            case 'day':\\n                $value *= static::HOURS_PER_DAY * static::MINUTES_PER_HOUR * static::SECONDS_PER_MINUTE;\\n\\n                break;\\n\\n            \/\/ @call addUTCUnit\\n            case 'week':\\n                $value *= static::DAYS_PER_WEEK * static::HOURS_PER_DAY * static::MINUTES_PER_HOUR * static::SECONDS_PER_MINUTE;\\n\\n                break;\\n\\n            \/\/ @call addUTCUnit\\n            case 'month':\\n                $value *= 30 * static::HOURS_PER_DAY * static::MINUTES_PER_HOUR * static::SECONDS_PER_MINUTE;\\n\\n                break;\\n\\n            \/\/ @call addUTCUnit\\n            case 'quarter':\\n                $value *= static::MONTHS_PER_QUARTER * 30 * static::HOURS_PER_DAY * static::MINUTES_PER_HOUR * static::SECONDS_PER_MINUTE;\\n\\n                break;\\n\\n            \/\/ @call addUTCUnit\\n            case 'year':\\n                $value *= 365 * static::HOURS_PER_DAY * static::MINUTES_PER_HOUR * static::SECONDS_PER_MINUTE;\\n\\n                break;\\n\\n            \/\/ @call addUTCUnit\\n            case 'decade':\\n                $value *= static::YEARS_PER_DECADE * 365 * static::HOURS_PER_DAY * static::MINUTES_PER_HOUR * static::SECONDS_PER_MINUTE;\\n\\n                break;\\n\\n            \/\/ @call addUTCUnit\\n            case 'century':\\n                $value *= static::YEARS_PER_CENTURY * 365 * static::HOURS_PER_DAY * static::MINUTES_PER_HOUR * static::SECONDS_PER_MINUTE;\\n\\n                break;\\n\\n            \/\/ @call addUTCUnit\\n            case 'millennium':\\n                $value *= static::YEARS_PER_MILLENNIUM * 365 * static::HOURS_PER_DAY * static::MINUTES_PER_HOUR * static::SECONDS_PER_MINUTE;\\n\\n                break;\\n\\n            default:\\n                if ($this->isLocalStrictModeEnabled()) {\\n                    throw new UnitException(\\\"Invalid unit for real timestamp add\/sub: '$unit'\\\");\\n                }\\n\\n                return $this;\\n        }\\n\\n        $seconds = (int) $value;\\n        $microseconds = (int) round(\\n            (abs($value) - abs($seconds)) * ($value < 0 ? -1 : 1) * static::MICROSECONDS_PER_SECOND,\\n        );\\n        $date = $this->setTimestamp($this->getTimestamp() + $seconds);\\n\\n        return $microseconds ? $date->addUTCUnit('microsecond', $microseconds) : $date;\\n    }\\n\\n    \/**\\n     * @deprecated Prefer to use add subUTCUnit() which more accurately defines what it's doing.\\n     *\\n     * Subtract seconds to the instance using timestamp. Positive $value travels\\n     * into the past while negative $value travels forward.\\n     *\\n     * @param string $unit\\n     * @param int    $value\\n     *\\n     * @return static\\n     *\/\\n    public function subRealUnit($unit, $value = 1): static\\n    {\\n        return $this->addUTCUnit($unit, -$value);\\n    }\\n\\n    \/**\\n     * Subtract seconds to the instance using timestamp. Positive $value travels\\n     * into the past while negative $value travels forward.\\n     *\\n     * @param string $unit\\n     * @param int    $value\\n     *\\n     * @return static\\n     *\/\\n    public function subUTCUnit($unit, $value = 1): static\\n    {\\n        return $this->addUTCUnit($unit, -$value);\\n    }\\n\\n    \/**\\n     * Returns true if a property can be changed via setter.\\n     *\\n     * @param string $unit\\n     *\\n     * @return bool\\n     *\/\\n    public static function isModifiableUnit($unit): bool\\n    {\\n        static $modifiableUnits = [\\n            \/\/ @call addUnit\\n            'millennium',\\n            \/\/ @call addUnit\\n            'century',\\n            \/\/ @call addUnit\\n            'decade',\\n            \/\/ @call addUnit\\n            'quarter',\\n            \/\/ @call addUnit\\n            'week',\\n            \/\/ @call addUnit\\n            'weekday',\\n        ];\\n\\n        return \\\\in_array($unit, $modifiableUnits, true) || \\\\in_array($unit, static::$units, true);\\n    }\\n\\n    \/**\\n     * Call native PHP DateTime\/DateTimeImmutable add() method.\\n     *\\n     * @param DateInterval $interval\\n     *\\n     * @return static\\n     *\/\\n    public function rawAdd(DateInterval $interval): static\\n    {\\n        return parent::add($interval);\\n    }\\n\\n    \/**\\n     * Add given units or interval to the current instance.\\n     *\\n     * @example $date->add('hour', 3)\\n     * @example $date->add(15, 'days')\\n     * @example $date->add(CarbonInterval::days(4))\\n     *\\n     * @param Unit|string|DateInterval|Closure|CarbonConverterInterface $unit\\n     * @param int|float                                                 $value\\n     * @param bool|null                                                 $overflow\\n     *\\n     * @return static\\n     *\/\\n    #[ReturnTypeWillChange]\\n    public function add($unit, $value = 1, ?bool $overflow = null): static\\n    {\\n        $unit = Unit::toNameIfUnit($unit);\\n        $value = Unit::toNameIfUnit($value);\\n\\n        if (\\\\is_string($unit) && \\\\func_num_args() === 1) {\\n            $unit = CarbonInterval::make($unit, [], true);\\n        }\\n\\n        if ($unit instanceof CarbonConverterInterface) {\\n            $unit = Closure::fromCallable([$unit, 'convertDate']);\\n        }\\n\\n        if ($unit instanceof Closure) {\\n            $result = $this->resolveCarbon($unit($this, false));\\n\\n            if ($this !== $result && $this->isMutable()) {\\n                return $this->modify($result->rawFormat('Y-m-d H:i:s.u e O'));\\n            }\\n\\n            return $result;\\n        }\\n\\n        if ($unit instanceof DateInterval) {\\n            return parent::add($unit);\\n        }\\n\\n        if (is_numeric($unit)) {\\n            [$value, $unit] = [$unit, $value];\\n        }\\n\\n        return $this->addUnit((string) $unit, $value, $overflow);\\n    }\\n\\n    \/**\\n     * Add given units to the current instance.\\n     *\/\\n    public function addUnit(Unit|string $unit, $value = 1, ?bool $overflow = null): static\\n    {\\n        $unit = Unit::toName($unit);\\n\\n        $originalArgs = \\\\func_get_args();\\n\\n        $date = $this;\\n\\n        if (!is_numeric($value) || !(float) $value) {\\n            return $date->isMutable() ? $date : $date->copy();\\n        }\\n\\n        $unit = self::singularUnit($unit);\\n        $metaUnits = [\\n            'millennium' => [static::YEARS_PER_MILLENNIUM, 'year'],\\n            'century' => [static::YEARS_PER_CENTURY, 'year'],\\n            'decade' => [static::YEARS_PER_DECADE, 'year'],\\n            'quarter' => [static::MONTHS_PER_QUARTER, 'month'],\\n        ];\\n\\n        if (isset($metaUnits[$unit])) {\\n            [$factor, $unit] = $metaUnits[$unit];\\n            $value *= $factor;\\n        }\\n\\n        if ($unit === 'weekday') {\\n            $weekendDays = $this->transmitFactory(static fn () => static::getWeekendDays());\\n\\n            if ($weekendDays !== [static::SATURDAY, static::SUNDAY]) {\\n                $absoluteValue = abs($value);\\n                $sign = $value \/ max(1, $absoluteValue);\\n                $weekDaysCount = static::DAYS_PER_WEEK - min(static::DAYS_PER_WEEK - 1, \\\\count(array_unique($weekendDays)));\\n                $weeks = floor($absoluteValue \/ $weekDaysCount);\\n\\n                for ($diff = $absoluteValue % $weekDaysCount; $diff; $diff--) {\\n                    \/** @var static $date *\/\\n                    $date = $date->addDays($sign);\\n\\n                    while (\\\\in_array($date->dayOfWeek, $weekendDays, true)) {\\n                        $date = $date->addDays($sign);\\n                    }\\n                }\\n\\n                $value = $weeks * $sign;\\n                $unit = 'week';\\n            }\\n\\n            $timeString = $date->toTimeString();\\n        } elseif ($canOverflow = (\\\\in_array($unit, [\\n                'month',\\n                'year',\\n            ]) && ($overflow === false || (\\n                $overflow === null &&\\n                ($ucUnit = ucfirst($unit).'s') &&\\n                !($this->{'local'.$ucUnit.'Overflow'} ?? static::{'shouldOverflow'.$ucUnit}())\\n            )))) {\\n            $day = $date->day;\\n        }\\n\\n        if ($unit === 'milli' || $unit === 'millisecond') {\\n            $unit = 'microsecond';\\n            $value *= static::MICROSECONDS_PER_MILLISECOND;\\n        }\\n\\n        $previousException = null;\\n\\n        try {\\n            $date = self::rawAddUnit($date, $unit, $value);\\n\\n            if (isset($timeString)) {\\n                $date = $date?->setTimeFromTimeString($timeString);\\n            } elseif (isset($canOverflow, $day) && $canOverflow && $day !== $date?->day) {\\n                $date = $date?->modify('last day of previous month');\\n            }\\n        } catch (DateMalformedStringException|InvalidFormatException|UnsupportedUnitException $exception) {\\n            $date = null;\\n            $previousException = $exception;\\n        }\\n\\n        return $date ?? throw new UnitException(\\n            'Unable to add unit '.var_export($originalArgs, true),\\n            previous: $previousException,\\n        );\\n    }\\n\\n    \/**\\n     * Subtract given units to the current instance.\\n     *\/\\n    public function subUnit(Unit|string $unit, $value = 1, ?bool $overflow = null): static\\n    {\\n        return $this->addUnit($unit, -$value, $overflow);\\n    }\\n\\n    \/**\\n     * Call native PHP DateTime\/DateTimeImmutable sub() method.\\n     *\/\\n    public function rawSub(DateInterval $interval): static\\n    {\\n        return parent::sub($interval);\\n    }\\n\\n    \/**\\n     * Subtract given units or interval to the current instance.\\n     *\\n     * @example $date->sub('hour', 3)\\n     * @example $date->sub(15, 'days')\\n     * @example $date->sub(CarbonInterval::days(4))\\n     *\\n     * @param Unit|string|DateInterval|Closure|CarbonConverterInterface $unit\\n     * @param int|float                                                 $value\\n     * @param bool|null                                                 $overflow\\n     *\\n     * @return static\\n     *\/\\n    #[ReturnTypeWillChange]\\n    public function sub($unit, $value = 1, ?bool $overflow = null): static\\n    {\\n        if (\\\\is_string($unit) && \\\\func_num_args() === 1) {\\n            $unit = CarbonInterval::make($unit, [], true);\\n        }\\n\\n        if ($unit instanceof CarbonConverterInterface) {\\n            $unit = Closure::fromCallable([$unit, 'convertDate']);\\n        }\\n\\n        if ($unit instanceof Closure) {\\n            $result = $this->resolveCarbon($unit($this, true));\\n\\n            if ($this !== $result && $this->isMutable()) {\\n                return $this->modify($result->rawFormat('Y-m-d H:i:s.u e O'));\\n            }\\n\\n            return $result;\\n        }\\n\\n        if ($unit instanceof DateInterval) {\\n            return parent::sub($unit);\\n        }\\n\\n        if (is_numeric($unit)) {\\n            [$value, $unit] = [$unit, $value];\\n        }\\n\\n        return $this->addUnit((string) $unit, -(float) $value, $overflow);\\n    }\\n\\n    \/**\\n     * Subtract given units or interval to the current instance.\\n     *\\n     * @see sub()\\n     *\\n     * @param string|DateInterval $unit\\n     * @param int|float           $value\\n     * @param bool|null           $overflow\\n     *\\n     * @return static\\n     *\/\\n    public function subtract($unit, $value = 1, ?bool $overflow = null): static\\n    {\\n        if (\\\\is_string($unit) && \\\\func_num_args() === 1) {\\n            $unit = CarbonInterval::make($unit, [], true);\\n        }\\n\\n        return $this->sub($unit, $value, $overflow);\\n    }\\n\\n    private static function rawAddUnit(self $date, string $unit, int|float $value): ?static\\n    {\\n        try {\\n            return $date->rawAdd(\\n                CarbonInterval::fromString(abs($value).\\\" $unit\\\")->invert($value < 0),\\n            );\\n        } catch (InvalidIntervalException $exception) {\\n            try {\\n                return $date->modify(\\\"$value $unit\\\");\\n            } catch (InvalidFormatException) {\\n                throw new UnsupportedUnitException($unit, previous: $exception);\\n            }\\n        }\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Traits\/IntervalStep.php\",\"ext\":\"php\",\"size\":2417,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon\\\\Traits;\\n\\nuse Carbon\\\\Callback;\\nuse Carbon\\\\Carbon;\\nuse Carbon\\\\CarbonImmutable;\\nuse Carbon\\\\CarbonInterface;\\nuse Closure;\\nuse DateTimeImmutable;\\nuse DateTimeInterface;\\n\\ntrait IntervalStep\\n{\\n    \/**\\n     * Step to apply instead of a fixed interval to get the new date.\\n     *\\n     * @var Closure|null\\n     *\/\\n    protected $step;\\n\\n    \/**\\n     * Get the dynamic step in use.\\n     *\\n     * @return Closure\\n     *\/\\n    public function getStep(): ?Closure\\n    {\\n        return $this->step;\\n    }\\n\\n    \/**\\n     * Set a step to apply instead of a fixed interval to get the new date.\\n     *\\n     * Or pass null to switch to fixed interval.\\n     *\\n     * @param Closure|null $step\\n     *\/\\n    public function setStep(?Closure $step): void\\n    {\\n        $this->step = $step;\\n    }\\n\\n    \/**\\n     * Take a date and apply either the step if set, or the current interval else.\\n     *\\n     * The interval\/step is applied negatively (typically subtraction instead of addition) if $negated is true.\\n     *\\n     * @param DateTimeInterface $dateTime\\n     * @param bool              $negated\\n     *\\n     * @return CarbonInterface\\n     *\/\\n    public function convertDate(DateTimeInterface $dateTime, bool $negated = false): CarbonInterface\\n    {\\n        \/** @var CarbonInterface $carbonDate *\/\\n        $carbonDate = $dateTime instanceof CarbonInterface ? $dateTime : $this->resolveCarbon($dateTime);\\n\\n        if ($this->step) {\\n            $carbonDate = Callback::parameter($this->step, $carbonDate->avoidMutation());\\n\\n            return $carbonDate->modify(($this->step)($carbonDate, $negated)->format('Y-m-d H:i:s.u e O'));\\n        }\\n\\n        if ($negated) {\\n            return $carbonDate->rawSub($this);\\n        }\\n\\n        return $carbonDate->rawAdd($this);\\n    }\\n\\n    \/**\\n     * Convert DateTimeImmutable instance to CarbonImmutable instance and DateTime instance to Carbon instance.\\n     *\/\\n    private function resolveCarbon(DateTimeInterface $dateTime): Carbon|CarbonImmutable\\n    {\\n        if ($dateTime instanceof DateTimeImmutable) {\\n            return CarbonImmutable::instance($dateTime);\\n        }\\n\\n        return Carbon::instance($dateTime);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Traits\/Mutability.php\",\"ext\":\"php\",\"size\":1317,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon\\\\Traits;\\n\\nuse Carbon\\\\Carbon;\\nuse Carbon\\\\CarbonImmutable;\\n\\n\/**\\n * Trait Mutability.\\n *\\n * Utils to know if the current object is mutable or immutable and convert it.\\n *\/\\ntrait Mutability\\n{\\n    use Cast;\\n\\n    \/**\\n     * Returns true if the current class\/instance is mutable.\\n     *\/\\n    public static function isMutable(): bool\\n    {\\n        return false;\\n    }\\n\\n    \/**\\n     * Returns true if the current class\/instance is immutable.\\n     *\/\\n    public static function isImmutable(): bool\\n    {\\n        return !static::isMutable();\\n    }\\n\\n    \/**\\n     * Return a mutable copy of the instance.\\n     *\\n     * @return Carbon\\n     *\/\\n    public function toMutable()\\n    {\\n        \/** @var Carbon $date *\/\\n        $date = $this->cast(Carbon::class);\\n\\n        return $date;\\n    }\\n\\n    \/**\\n     * Return a immutable copy of the instance.\\n     *\\n     * @return CarbonImmutable\\n     *\/\\n    public function toImmutable()\\n    {\\n        \/** @var CarbonImmutable $date *\/\\n        $date = $this->cast(CarbonImmutable::class);\\n\\n        return $date;\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Traits\/Modifiers.php\",\"ext\":\"php\",\"size\":13915,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon\\\\Traits;\\n\\nuse Carbon\\\\CarbonInterface;\\nuse Carbon\\\\Exceptions\\\\InvalidFormatException;\\nuse ReturnTypeWillChange;\\n\\n\/**\\n * Trait Modifiers.\\n *\\n * Returns dates relative to current date using modifier short-hand.\\n *\/\\ntrait Modifiers\\n{\\n    \/**\\n     * Midday\/noon hour.\\n     *\\n     * @var int\\n     *\/\\n    protected static $midDayAt = 12;\\n\\n    \/**\\n     * get midday\/noon hour\\n     *\\n     * @return int\\n     *\/\\n    public static function getMidDayAt()\\n    {\\n        return static::$midDayAt;\\n    }\\n\\n    \/**\\n     * @deprecated To avoid conflict between different third-party libraries, static setters should not be used.\\n     *             You should rather consider mid-day is always 12pm, then if you need to test if it's an other\\n     *             hour, test it explicitly:\\n     *                 $date->format('G') == 13\\n     *             or to set explicitly to a given hour:\\n     *                 $date->setTime(13, 0, 0, 0)\\n     *\\n     * Set midday\/noon hour\\n     *\\n     * @param int $hour midday hour\\n     *\\n     * @return void\\n     *\/\\n    public static function setMidDayAt($hour)\\n    {\\n        static::$midDayAt = $hour;\\n    }\\n\\n    \/**\\n     * Modify to midday, default to self::$midDayAt\\n     *\\n     * @return static\\n     *\/\\n    public function midDay()\\n    {\\n        return $this->setTime(static::$midDayAt, 0, 0, 0);\\n    }\\n\\n    \/**\\n     * Modify to the next occurrence of a given modifier such as a day of\\n     * the week. If no modifier is provided, modify to the next occurrence\\n     * of the current day of the week. Use the supplied constants\\n     * to indicate the desired dayOfWeek, ex. static::MONDAY.\\n     *\\n     * @param string|int|null $modifier\\n     *\\n     * @return static\\n     *\/\\n    public function next($modifier = null)\\n    {\\n        if ($modifier === null) {\\n            $modifier = $this->dayOfWeek;\\n        }\\n\\n        return $this->change(\\n            'next '.(\\\\is_string($modifier) ? $modifier : static::$days[$modifier]),\\n        );\\n    }\\n\\n    \/**\\n     * Go forward or backward to the next week- or weekend-day.\\n     *\\n     * @param bool $weekday\\n     * @param bool $forward\\n     *\\n     * @return static\\n     *\/\\n    private function nextOrPreviousDay($weekday = true, $forward = true)\\n    {\\n        \/** @var CarbonInterface $date *\/\\n        $date = $this;\\n        $step = $forward ? 1 : -1;\\n\\n        do {\\n            $date = $date->addDays($step);\\n        } while ($weekday ? $date->isWeekend() : $date->isWeekday());\\n\\n        return $date;\\n    }\\n\\n    \/**\\n     * Go forward to the next weekday.\\n     *\\n     * @return static\\n     *\/\\n    public function nextWeekday()\\n    {\\n        return $this->nextOrPreviousDay();\\n    }\\n\\n    \/**\\n     * Go backward to the previous weekday.\\n     *\\n     * @return static\\n     *\/\\n    public function previousWeekday()\\n    {\\n        return $this->nextOrPreviousDay(true, false);\\n    }\\n\\n    \/**\\n     * Go forward to the next weekend day.\\n     *\\n     * @return static\\n     *\/\\n    public function nextWeekendDay()\\n    {\\n        return $this->nextOrPreviousDay(false);\\n    }\\n\\n    \/**\\n     * Go backward to the previous weekend day.\\n     *\\n     * @return static\\n     *\/\\n    public function previousWeekendDay()\\n    {\\n        return $this->nextOrPreviousDay(false, false);\\n    }\\n\\n    \/**\\n     * Modify to the previous occurrence of a given modifier such as a day of\\n     * the week. If no dayOfWeek is provided, modify to the previous occurrence\\n     * of the current day of the week. Use the supplied constants\\n     * to indicate the desired dayOfWeek, ex. static::MONDAY.\\n     *\\n     * @param string|int|null $modifier\\n     *\\n     * @return static\\n     *\/\\n    public function previous($modifier = null)\\n    {\\n        if ($modifier === null) {\\n            $modifier = $this->dayOfWeek;\\n        }\\n\\n        return $this->change(\\n            'last '.(\\\\is_string($modifier) ? $modifier : static::$days[$modifier]),\\n        );\\n    }\\n\\n    \/**\\n     * Modify to the first occurrence of a given day of the week\\n     * in the current month. If no dayOfWeek is provided, modify to the\\n     * first day of the current month.  Use the supplied constants\\n     * to indicate the desired dayOfWeek, ex. static::MONDAY.\\n     *\\n     * @param int|null $dayOfWeek\\n     *\\n     * @return static\\n     *\/\\n    public function firstOfMonth($dayOfWeek = null)\\n    {\\n        $date = $this->startOfDay();\\n\\n        if ($dayOfWeek === null) {\\n            return $date->day(1);\\n        }\\n\\n        return $date->modify('first '.static::$days[$dayOfWeek].' of '.$date->rawFormat('F').' '.$date->year);\\n    }\\n\\n    \/**\\n     * Modify to the last occurrence of a given day of the week\\n     * in the current month. If no dayOfWeek is provided, modify to the\\n     * last day of the current month.  Use the supplied constants\\n     * to indicate the desired dayOfWeek, ex. static::MONDAY.\\n     *\\n     * @param int|null $dayOfWeek\\n     *\\n     * @return static\\n     *\/\\n    public function lastOfMonth($dayOfWeek = null)\\n    {\\n        $date = $this->startOfDay();\\n\\n        if ($dayOfWeek === null) {\\n            return $date->day($date->daysInMonth);\\n        }\\n\\n        return $date->modify('last '.static::$days[$dayOfWeek].' of '.$date->rawFormat('F').' '.$date->year);\\n    }\\n\\n    \/**\\n     * Modify to the given occurrence of a given day of the week\\n     * in the current month. If the calculated occurrence is outside the scope\\n     * of the current month, then return false and no modifications are made.\\n     * Use the supplied constants to indicate the desired dayOfWeek, ex. static::MONDAY.\\n     *\\n     * @param int $nth\\n     * @param int $dayOfWeek\\n     *\\n     * @return mixed\\n     *\/\\n    public function nthOfMonth($nth, $dayOfWeek)\\n    {\\n        $date = $this->avoidMutation()->firstOfMonth();\\n        $check = $date->rawFormat('Y-m');\\n        $date = $date->modify('+'.$nth.' '.static::$days[$dayOfWeek]);\\n\\n        return $date->rawFormat('Y-m') === $check ? $this->modify((string) $date) : false;\\n    }\\n\\n    \/**\\n     * Modify to the first occurrence of a given day of the week\\n     * in the current quarter. If no dayOfWeek is provided, modify to the\\n     * first day of the current quarter.  Use the supplied constants\\n     * to indicate the desired dayOfWeek, ex. static::MONDAY.\\n     *\\n     * @param int|null $dayOfWeek day of the week default null\\n     *\\n     * @return static\\n     *\/\\n    public function firstOfQuarter($dayOfWeek = null)\\n    {\\n        return $this->setDate($this->year, $this->quarter * static::MONTHS_PER_QUARTER - 2, 1)->firstOfMonth($dayOfWeek);\\n    }\\n\\n    \/**\\n     * Modify to the last occurrence of a given day of the week\\n     * in the current quarter. If no dayOfWeek is provided, modify to the\\n     * last day of the current quarter.  Use the supplied constants\\n     * to indicate the desired dayOfWeek, ex. static::MONDAY.\\n     *\\n     * @param int|null $dayOfWeek day of the week default null\\n     *\\n     * @return static\\n     *\/\\n    public function lastOfQuarter($dayOfWeek = null)\\n    {\\n        return $this->setDate($this->year, $this->quarter * static::MONTHS_PER_QUARTER, 1)->lastOfMonth($dayOfWeek);\\n    }\\n\\n    \/**\\n     * Modify to the given occurrence of a given day of the week\\n     * in the current quarter. If the calculated occurrence is outside the scope\\n     * of the current quarter, then return false and no modifications are made.\\n     * Use the supplied constants to indicate the desired dayOfWeek, ex. static::MONDAY.\\n     *\\n     * @param int $nth\\n     * @param int $dayOfWeek\\n     *\\n     * @return mixed\\n     *\/\\n    public function nthOfQuarter($nth, $dayOfWeek)\\n    {\\n        $date = $this->avoidMutation()->day(1)->month($this->quarter * static::MONTHS_PER_QUARTER);\\n        $lastMonth = $date->month;\\n        $year = $date->year;\\n        $date = $date->firstOfQuarter()->modify('+'.$nth.' '.static::$days[$dayOfWeek]);\\n\\n        return ($lastMonth < $date->month || $year !== $date->year) ? false : $this->modify((string) $date);\\n    }\\n\\n    \/**\\n     * Modify to the first occurrence of a given day of the week\\n     * in the current year. If no dayOfWeek is provided, modify to the\\n     * first day of the current year.  Use the supplied constants\\n     * to indicate the desired dayOfWeek, ex. static::MONDAY.\\n     *\\n     * @param int|null $dayOfWeek day of the week default null\\n     *\\n     * @return static\\n     *\/\\n    public function firstOfYear($dayOfWeek = null)\\n    {\\n        return $this->month(1)->firstOfMonth($dayOfWeek);\\n    }\\n\\n    \/**\\n     * Modify to the last occurrence of a given day of the week\\n     * in the current year. If no dayOfWeek is provided, modify to the\\n     * last day of the current year.  Use the supplied constants\\n     * to indicate the desired dayOfWeek, ex. static::MONDAY.\\n     *\\n     * @param int|null $dayOfWeek day of the week default null\\n     *\\n     * @return static\\n     *\/\\n    public function lastOfYear($dayOfWeek = null)\\n    {\\n        return $this->month(static::MONTHS_PER_YEAR)->lastOfMonth($dayOfWeek);\\n    }\\n\\n    \/**\\n     * Modify to the given occurrence of a given day of the week\\n     * in the current year. If the calculated occurrence is outside the scope\\n     * of the current year, then return false and no modifications are made.\\n     * Use the supplied constants to indicate the desired dayOfWeek, ex. static::MONDAY.\\n     *\\n     * @param int $nth\\n     * @param int $dayOfWeek\\n     *\\n     * @return mixed\\n     *\/\\n    public function nthOfYear($nth, $dayOfWeek)\\n    {\\n        $date = $this->avoidMutation()->firstOfYear()->modify('+'.$nth.' '.static::$days[$dayOfWeek]);\\n\\n        return $this->year === $date->year ? $this->modify((string) $date) : false;\\n    }\\n\\n    \/**\\n     * Modify the current instance to the average of a given instance (default now) and the current instance\\n     * (second-precision).\\n     *\\n     * @param \\\\Carbon\\\\Carbon|\\\\DateTimeInterface|null $date\\n     *\\n     * @return static\\n     *\/\\n    public function average($date = null)\\n    {\\n        return $this->addRealMicroseconds((int) ($this->diffInMicroseconds($this->resolveCarbon($date), false) \/ 2));\\n    }\\n\\n    \/**\\n     * Get the closest date from the instance (second-precision).\\n     *\\n     * @param \\\\Carbon\\\\Carbon|\\\\DateTimeInterface|mixed $date1\\n     * @param \\\\Carbon\\\\Carbon|\\\\DateTimeInterface|mixed $date2\\n     *\\n     * @return static\\n     *\/\\n    public function closest($date1, $date2)\\n    {\\n        return $this->diffInMicroseconds($date1, true) < $this->diffInMicroseconds($date2, true) ? $date1 : $date2;\\n    }\\n\\n    \/**\\n     * Get the farthest date from the instance (second-precision).\\n     *\\n     * @param \\\\Carbon\\\\Carbon|\\\\DateTimeInterface|mixed $date1\\n     * @param \\\\Carbon\\\\Carbon|\\\\DateTimeInterface|mixed $date2\\n     *\\n     * @return static\\n     *\/\\n    public function farthest($date1, $date2)\\n    {\\n        return $this->diffInMicroseconds($date1, true) > $this->diffInMicroseconds($date2, true) ? $date1 : $date2;\\n    }\\n\\n    \/**\\n     * Get the minimum instance between a given instance (default now) and the current instance.\\n     *\\n     * @param \\\\Carbon\\\\Carbon|\\\\DateTimeInterface|mixed $date\\n     *\\n     * @return static\\n     *\/\\n    public function min($date = null)\\n    {\\n        $date = $this->resolveCarbon($date);\\n\\n        return $this->lt($date) ? $this : $date;\\n    }\\n\\n    \/**\\n     * Get the minimum instance between a given instance (default now) and the current instance.\\n     *\\n     * @param \\\\Carbon\\\\Carbon|\\\\DateTimeInterface|mixed $date\\n     *\\n     * @see min()\\n     *\\n     * @return static\\n     *\/\\n    public function minimum($date = null)\\n    {\\n        return $this->min($date);\\n    }\\n\\n    \/**\\n     * Get the maximum instance between a given instance (default now) and the current instance.\\n     *\\n     * @param \\\\Carbon\\\\Carbon|\\\\DateTimeInterface|mixed $date\\n     *\\n     * @return static\\n     *\/\\n    public function max($date = null)\\n    {\\n        $date = $this->resolveCarbon($date);\\n\\n        return $this->gt($date) ? $this : $date;\\n    }\\n\\n    \/**\\n     * Get the maximum instance between a given instance (default now) and the current instance.\\n     *\\n     * @param \\\\Carbon\\\\Carbon|\\\\DateTimeInterface|mixed $date\\n     *\\n     * @see max()\\n     *\\n     * @return static\\n     *\/\\n    public function maximum($date = null)\\n    {\\n        return $this->max($date);\\n    }\\n\\n    \/**\\n     * Calls \\\\DateTime::modify if mutable or \\\\DateTimeImmutable::modify else.\\n     *\\n     * @see https:\/\/php.net\/manual\/en\/datetime.modify.php\\n     *\\n     * @return static\\n     *\/\\n    #[ReturnTypeWillChange]\\n    public function modify($modify)\\n    {\\n        return parent::modify((string) $modify)\\n            ?: throw new InvalidFormatException('Could not modify with: '.var_export($modify, true));\\n    }\\n\\n    \/**\\n     * Similar to native modify() method of DateTime but can handle more grammars.\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::now()->change('next 2pm');\\n     * ```\\n     *\\n     * @link https:\/\/php.net\/manual\/en\/datetime.modify.php\\n     *\\n     * @param string $modifier\\n     *\\n     * @return static\\n     *\/\\n    public function change($modifier)\\n    {\\n        return $this->modify(preg_replace_callback('\/^(next|previous|last)\\\\s+(\\\\d{1,2}(h|am|pm|:\\\\d{1,2}(:\\\\d{1,2})?))$\/i', function ($match) {\\n            $match[2] = str_replace('h', ':00', $match[2]);\\n            $test = $this->avoidMutation()->modify($match[2]);\\n            $method = $match[1] === 'next' ? 'lt' : 'gt';\\n            $match[1] = $test->$method($this) ? $match[1].' day' : 'today';\\n\\n            return $match[1].' '.$match[2];\\n        }, strtr(trim($modifier), [\\n            ' at ' => ' ',\\n            'just now' => 'now',\\n            'after tomorrow' => 'tomorrow +1 day',\\n            'before yesterday' => 'yesterday -1 day',\\n        ])));\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Traits\/Options.php\",\"ext\":\"php\",\"size\":6064,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon\\\\Traits;\\n\\nuse Carbon\\\\CarbonInterface;\\nuse DateTimeInterface;\\nuse Throwable;\\n\\n\/**\\n * Trait Options.\\n *\\n * Embed base methods to change settings of Carbon classes.\\n *\\n * Depends on the following methods:\\n *\\n * @method static shiftTimezone($timezone) Set the timezone\\n *\/\\ntrait Options\\n{\\n    use StaticOptions;\\n    use Localization;\\n\\n    \/**\\n     * Indicates if months should be calculated with overflow.\\n     * Specific setting.\\n     *\/\\n    protected ?bool $localMonthsOverflow = null;\\n\\n    \/**\\n     * Indicates if years should be calculated with overflow.\\n     * Specific setting.\\n     *\/\\n    protected ?bool $localYearsOverflow = null;\\n\\n    \/**\\n     * Indicates if the strict mode is in use.\\n     * Specific setting.\\n     *\/\\n    protected ?bool $localStrictModeEnabled = null;\\n\\n    \/**\\n     * Options for diffForHumans and forHumans methods.\\n     *\/\\n    protected ?int $localHumanDiffOptions = null;\\n\\n    \/**\\n     * Format to use on string cast.\\n     *\\n     * @var string|callable|null\\n     *\/\\n    protected $localToStringFormat = null;\\n\\n    \/**\\n     * Format to use on JSON serialization.\\n     *\\n     * @var string|callable|null\\n     *\/\\n    protected $localSerializer = null;\\n\\n    \/**\\n     * Instance-specific macros.\\n     *\/\\n    protected ?array $localMacros = null;\\n\\n    \/**\\n     * Instance-specific generic macros.\\n     *\/\\n    protected ?array $localGenericMacros = null;\\n\\n    \/**\\n     * Function to call instead of format.\\n     *\\n     * @var string|callable|null\\n     *\/\\n    protected $localFormatFunction = null;\\n\\n    \/**\\n     * Set specific options.\\n     *  - strictMode: true|false|null\\n     *  - monthOverflow: true|false|null\\n     *  - yearOverflow: true|false|null\\n     *  - humanDiffOptions: int|null\\n     *  - toStringFormat: string|Closure|null\\n     *  - toJsonFormat: string|Closure|null\\n     *  - locale: string|null\\n     *  - timezone: \\\\DateTimeZone|string|int|null\\n     *  - macros: array|null\\n     *  - genericMacros: array|null\\n     *\\n     * @param array $settings\\n     *\\n     * @return $this|static\\n     *\/\\n    public function settings(array $settings): static\\n    {\\n        $this->localStrictModeEnabled = $settings['strictMode'] ?? null;\\n        $this->localMonthsOverflow = $settings['monthOverflow'] ?? null;\\n        $this->localYearsOverflow = $settings['yearOverflow'] ?? null;\\n        $this->localHumanDiffOptions = $settings['humanDiffOptions'] ?? null;\\n        $this->localToStringFormat = $settings['toStringFormat'] ?? null;\\n        $this->localSerializer = $settings['toJsonFormat'] ?? null;\\n        $this->localMacros = $settings['macros'] ?? null;\\n        $this->localGenericMacros = $settings['genericMacros'] ?? null;\\n        $this->localFormatFunction = $settings['formatFunction'] ?? null;\\n\\n        if (isset($settings['locale'])) {\\n            $locales = $settings['locale'];\\n\\n            if (!\\\\is_array($locales)) {\\n                $locales = [$locales];\\n            }\\n\\n            $this->locale(...$locales);\\n        } elseif (isset($settings['translator']) && property_exists($this, 'localTranslator')) {\\n            $this->localTranslator = $settings['translator'];\\n        }\\n\\n        if (isset($settings['innerTimezone'])) {\\n            return $this->setTimezone($settings['innerTimezone']);\\n        }\\n\\n        if (isset($settings['timezone'])) {\\n            return $this->shiftTimezone($settings['timezone']);\\n        }\\n\\n        return $this;\\n    }\\n\\n    \/**\\n     * Returns current local settings.\\n     *\/\\n    public function getSettings(): array\\n    {\\n        $settings = [];\\n        $map = [\\n            'localStrictModeEnabled' => 'strictMode',\\n            'localMonthsOverflow' => 'monthOverflow',\\n            'localYearsOverflow' => 'yearOverflow',\\n            'localHumanDiffOptions' => 'humanDiffOptions',\\n            'localToStringFormat' => 'toStringFormat',\\n            'localSerializer' => 'toJsonFormat',\\n            'localMacros' => 'macros',\\n            'localGenericMacros' => 'genericMacros',\\n            'locale' => 'locale',\\n            'tzName' => 'timezone',\\n            'localFormatFunction' => 'formatFunction',\\n        ];\\n\\n        foreach ($map as $property => $key) {\\n            $value = $this->$property ?? null;\\n\\n            if ($value !== null && ($key !== 'locale' || $value !== 'en' || $this->localTranslator)) {\\n                $settings[$key] = $value;\\n            }\\n        }\\n\\n        return $settings;\\n    }\\n\\n    \/**\\n     * Show truthy properties on var_dump().\\n     *\/\\n    public function __debugInfo(): array\\n    {\\n        $infos = array_filter(get_object_vars($this), static function ($var) {\\n            return $var;\\n        });\\n\\n        foreach (['dumpProperties', 'constructedObjectId', 'constructed', 'originalInput'] as $property) {\\n            if (isset($infos[$property])) {\\n                unset($infos[$property]);\\n            }\\n        }\\n\\n        $this->addExtraDebugInfos($infos);\\n\\n        foreach ([\\\"\\\\0*\\\\0\\\", ''] as $prefix) {\\n            $key = $prefix.'carbonRecurrences';\\n\\n            if (\\\\array_key_exists($key, $infos)) {\\n                $infos['recurrences'] = $infos[$key];\\n                unset($infos[$key]);\\n            }\\n        }\\n\\n        return $infos;\\n    }\\n\\n    protected function isLocalStrictModeEnabled(): bool\\n    {\\n        return $this->localStrictModeEnabled\\n            ?? $this->transmitFactory(static fn () => static::isStrictModeEnabled());\\n    }\\n\\n    protected function addExtraDebugInfos(array &$infos): void\\n    {\\n        if ($this instanceof DateTimeInterface) {\\n            try {\\n                $infos['date'] ??= $this->format(CarbonInterface::MOCK_DATETIME_FORMAT);\\n                $infos['timezone'] ??= $this->tzName ?? $this->timezoneSetting ?? $this->timezone ?? null;\\n            } catch (Throwable) {\\n                \/\/ noop\\n            }\\n        }\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Traits\/StaticLocalization.php\",\"ext\":\"php\",\"size\":2387,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon\\\\Traits;\\n\\nuse Carbon\\\\FactoryImmutable;\\nuse Symfony\\\\Contracts\\\\Translation\\\\TranslatorInterface;\\n\\n\/**\\n * Static config for localization.\\n *\/\\ntrait StaticLocalization\\n{\\n    \/**\\n     * @deprecated To avoid conflict between different third-party libraries, static setters should not be used.\\n     *             You should rather use the ->settings() method.\\n     * @see settings\\n     *\/\\n    public static function setHumanDiffOptions(int $humanDiffOptions): void\\n    {\\n        FactoryImmutable::getDefaultInstance()->setHumanDiffOptions($humanDiffOptions);\\n    }\\n\\n    \/**\\n     * @deprecated To avoid conflict between different third-party libraries, static setters should not be used.\\n     *             You should rather use the ->settings() method.\\n     * @see settings\\n     *\/\\n    public static function enableHumanDiffOption(int $humanDiffOption): void\\n    {\\n        FactoryImmutable::getDefaultInstance()->enableHumanDiffOption($humanDiffOption);\\n    }\\n\\n    \/**\\n     * @deprecated To avoid conflict between different third-party libraries, static setters should not be used.\\n     *             You should rather use the ->settings() method.\\n     * @see settings\\n     *\/\\n    public static function disableHumanDiffOption(int $humanDiffOption): void\\n    {\\n        FactoryImmutable::getDefaultInstance()->disableHumanDiffOption($humanDiffOption);\\n    }\\n\\n    \/**\\n     * Return default humanDiff() options (merged flags as integer).\\n     *\/\\n    public static function getHumanDiffOptions(): int\\n    {\\n        return FactoryImmutable::getInstance()->getHumanDiffOptions();\\n    }\\n\\n    \/**\\n     * Set the default translator instance to use.\\n     *\\n     * @param TranslatorInterface $translator\\n     *\\n     * @return void\\n     *\/\\n    public static function setTranslator(TranslatorInterface $translator): void\\n    {\\n        FactoryImmutable::getDefaultInstance()->setTranslator($translator);\\n    }\\n\\n    \/**\\n     * Initialize the default translator instance if necessary.\\n     *\/\\n    public static function getTranslator(): TranslatorInterface\\n    {\\n        return FactoryImmutable::getInstance()->getTranslator();\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Traits\/Converter.php\",\"ext\":\"php\",\"size\":14461,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon\\\\Traits;\\n\\nuse Carbon\\\\Carbon;\\nuse Carbon\\\\CarbonImmutable;\\nuse Carbon\\\\CarbonInterface;\\nuse Carbon\\\\CarbonInterval;\\nuse Carbon\\\\CarbonPeriod;\\nuse Carbon\\\\CarbonPeriodImmutable;\\nuse Carbon\\\\Exceptions\\\\UnitException;\\nuse Closure;\\nuse DateTime;\\nuse DateTimeImmutable;\\nuse DateTimeInterface;\\n\\n\/**\\n * Trait Converter.\\n *\\n * Change date into different string formats and types and\\n * handle the string cast.\\n *\\n * Depends on the following methods:\\n *\\n * @method static copy()\\n *\/\\ntrait Converter\\n{\\n    use ToStringFormat;\\n\\n    \/**\\n     * Returns the formatted date string on success or FALSE on failure.\\n     *\\n     * @see https:\/\/php.net\/manual\/en\/datetime.format.php\\n     *\/\\n    public function format(string $format): string\\n    {\\n        $function = $this->localFormatFunction\\n            ?? $this->getFactory()->getSettings()['formatFunction']\\n            ?? static::$formatFunction;\\n\\n        if (!$function) {\\n            return $this->rawFormat($format);\\n        }\\n\\n        if (\\\\is_string($function) && method_exists($this, $function)) {\\n            $function = [$this, $function];\\n        }\\n\\n        return $function(...\\\\func_get_args());\\n    }\\n\\n    \/**\\n     * @see https:\/\/php.net\/manual\/en\/datetime.format.php\\n     *\/\\n    public function rawFormat(string $format): string\\n    {\\n        return parent::format($format);\\n    }\\n\\n    \/**\\n     * Format the instance as a string using the set format\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::now(); \/\/ Carbon instances can be cast to string\\n     * ```\\n     *\/\\n    public function __toString(): string\\n    {\\n        $format = $this->localToStringFormat\\n            ?? $this->getFactory()->getSettings()['toStringFormat']\\n            ?? null;\\n\\n        return $format instanceof Closure\\n            ? $format($this)\\n            : $this->rawFormat($format ?: (\\n                \\\\defined('static::DEFAULT_TO_STRING_FORMAT')\\n                    ? static::DEFAULT_TO_STRING_FORMAT\\n                    : CarbonInterface::DEFAULT_TO_STRING_FORMAT\\n            ));\\n    }\\n\\n    \/**\\n     * Format the instance as date\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::now()->toDateString();\\n     * ```\\n     *\/\\n    public function toDateString(): string\\n    {\\n        return $this->rawFormat('Y-m-d');\\n    }\\n\\n    \/**\\n     * Format the instance as a readable date\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::now()->toFormattedDateString();\\n     * ```\\n     *\/\\n    public function toFormattedDateString(): string\\n    {\\n        return $this->rawFormat('M j, Y');\\n    }\\n\\n    \/**\\n     * Format the instance with the day, and a readable date\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::now()->toFormattedDayDateString();\\n     * ```\\n     *\/\\n    public function toFormattedDayDateString(): string\\n    {\\n        return $this->rawFormat('D, M j, Y');\\n    }\\n\\n    \/**\\n     * Format the instance as time\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::now()->toTimeString();\\n     * ```\\n     *\/\\n    public function toTimeString(string $unitPrecision = 'second'): string\\n    {\\n        return $this->rawFormat(static::getTimeFormatByPrecision($unitPrecision));\\n    }\\n\\n    \/**\\n     * Format the instance as date and time\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::now()->toDateTimeString();\\n     * ```\\n     *\/\\n    public function toDateTimeString(string $unitPrecision = 'second'): string\\n    {\\n        return $this->rawFormat('Y-m-d '.static::getTimeFormatByPrecision($unitPrecision));\\n    }\\n\\n    \/**\\n     * Return a format from H:i to H:i:s.u according to given unit precision.\\n     *\\n     * @param string $unitPrecision \\\"minute\\\", \\\"second\\\", \\\"millisecond\\\" or \\\"microsecond\\\"\\n     *\/\\n    public static function getTimeFormatByPrecision(string $unitPrecision): string\\n    {\\n        return match (static::singularUnit($unitPrecision)) {\\n            'minute' => 'H:i',\\n            'second' => 'H:i:s',\\n            'm', 'millisecond' => 'H:i:s.v',\\n            '\u00b5', 'microsecond' => 'H:i:s.u',\\n            default => throw new UnitException('Precision unit expected among: minute, second, millisecond and microsecond.'),\\n        };\\n    }\\n\\n    \/**\\n     * Format the instance as date and time T-separated with no timezone\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::now()->toDateTimeLocalString();\\n     * echo \\\"\\\\n\\\";\\n     * echo Carbon::now()->toDateTimeLocalString('minute'); \/\/ You can specify precision among: minute, second, millisecond and microsecond\\n     * ```\\n     *\/\\n    public function toDateTimeLocalString(string $unitPrecision = 'second'): string\\n    {\\n        return $this->rawFormat('Y-m-d\\\\T'.static::getTimeFormatByPrecision($unitPrecision));\\n    }\\n\\n    \/**\\n     * Format the instance with day, date and time\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::now()->toDayDateTimeString();\\n     * ```\\n     *\/\\n    public function toDayDateTimeString(): string\\n    {\\n        return $this->rawFormat('D, M j, Y g:i A');\\n    }\\n\\n    \/**\\n     * Format the instance as ATOM\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::now()->toAtomString();\\n     * ```\\n     *\/\\n    public function toAtomString(): string\\n    {\\n        return $this->rawFormat(DateTime::ATOM);\\n    }\\n\\n    \/**\\n     * Format the instance as COOKIE\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::now()->toCookieString();\\n     * ```\\n     *\/\\n    public function toCookieString(): string\\n    {\\n        return $this->rawFormat(DateTimeInterface::COOKIE);\\n    }\\n\\n    \/**\\n     * Format the instance as ISO8601\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::now()->toIso8601String();\\n     * ```\\n     *\/\\n    public function toIso8601String(): string\\n    {\\n        return $this->toAtomString();\\n    }\\n\\n    \/**\\n     * Format the instance as RFC822\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::now()->toRfc822String();\\n     * ```\\n     *\/\\n    public function toRfc822String(): string\\n    {\\n        return $this->rawFormat(DateTimeInterface::RFC822);\\n    }\\n\\n    \/**\\n     * Convert the instance to UTC and return as Zulu ISO8601\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::now()->toIso8601ZuluString();\\n     * ```\\n     *\/\\n    public function toIso8601ZuluString(string $unitPrecision = 'second'): string\\n    {\\n        return $this->avoidMutation()\\n            ->utc()\\n            ->rawFormat('Y-m-d\\\\T'.static::getTimeFormatByPrecision($unitPrecision).'\\\\Z');\\n    }\\n\\n    \/**\\n     * Format the instance as RFC850\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::now()->toRfc850String();\\n     * ```\\n     *\/\\n    public function toRfc850String(): string\\n    {\\n        return $this->rawFormat(DateTimeInterface::RFC850);\\n    }\\n\\n    \/**\\n     * Format the instance as RFC1036\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::now()->toRfc1036String();\\n     * ```\\n     *\/\\n    public function toRfc1036String(): string\\n    {\\n        return $this->rawFormat(DateTimeInterface::RFC1036);\\n    }\\n\\n    \/**\\n     * Format the instance as RFC1123\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::now()->toRfc1123String();\\n     * ```\\n     *\/\\n    public function toRfc1123String(): string\\n    {\\n        return $this->rawFormat(DateTimeInterface::RFC1123);\\n    }\\n\\n    \/**\\n     * Format the instance as RFC2822\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::now()->toRfc2822String();\\n     * ```\\n     *\/\\n    public function toRfc2822String(): string\\n    {\\n        return $this->rawFormat(DateTimeInterface::RFC2822);\\n    }\\n\\n    \/**\\n     * Format the instance as RFC3339.\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::now()->toRfc3339String() . \\\"\\\\n\\\";\\n     * echo Carbon::now()->toRfc3339String(true) . \\\"\\\\n\\\";\\n     * ```\\n     *\/\\n    public function toRfc3339String(bool $extended = false): string\\n    {\\n        return $this->rawFormat($extended ? DateTimeInterface::RFC3339_EXTENDED : DateTimeInterface::RFC3339);\\n    }\\n\\n    \/**\\n     * Format the instance as RSS\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::now()->toRssString();\\n     * ```\\n     *\/\\n    public function toRssString(): string\\n    {\\n        return $this->rawFormat(DateTimeInterface::RSS);\\n    }\\n\\n    \/**\\n     * Format the instance as W3C\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::now()->toW3cString();\\n     * ```\\n     *\/\\n    public function toW3cString(): string\\n    {\\n        return $this->rawFormat(DateTimeInterface::W3C);\\n    }\\n\\n    \/**\\n     * Format the instance as RFC7231\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::now()->toRfc7231String();\\n     * ```\\n     *\/\\n    public function toRfc7231String(): string\\n    {\\n        return $this->avoidMutation()\\n            ->setTimezone('GMT')\\n            ->rawFormat(\\\\defined('static::RFC7231_FORMAT') ? static::RFC7231_FORMAT : CarbonInterface::RFC7231_FORMAT);\\n    }\\n\\n    \/**\\n     * Get default array representation.\\n     *\\n     * @example\\n     * ```\\n     * var_dump(Carbon::now()->toArray());\\n     * ```\\n     *\/\\n    public function toArray(): array\\n    {\\n        return [\\n            'year' => $this->year,\\n            'month' => $this->month,\\n            'day' => $this->day,\\n            'dayOfWeek' => $this->dayOfWeek,\\n            'dayOfYear' => $this->dayOfYear,\\n            'hour' => $this->hour,\\n            'minute' => $this->minute,\\n            'second' => $this->second,\\n            'micro' => $this->micro,\\n            'timestamp' => $this->timestamp,\\n            'formatted' => $this->rawFormat(\\\\defined('static::DEFAULT_TO_STRING_FORMAT') ? static::DEFAULT_TO_STRING_FORMAT : CarbonInterface::DEFAULT_TO_STRING_FORMAT),\\n            'timezone' => $this->timezone,\\n        ];\\n    }\\n\\n    \/**\\n     * Get default object representation.\\n     *\\n     * @example\\n     * ```\\n     * var_dump(Carbon::now()->toObject());\\n     * ```\\n     *\/\\n    public function toObject(): object\\n    {\\n        return (object) $this->toArray();\\n    }\\n\\n    \/**\\n     * Returns english human-readable complete date string.\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::now()->toString();\\n     * ```\\n     *\/\\n    public function toString(): string\\n    {\\n        return $this->avoidMutation()->locale('en')->isoFormat('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');\\n    }\\n\\n    \/**\\n     * Return the ISO-8601 string (ex: 1977-04-22T06:00:00Z, if $keepOffset truthy, offset will be kept:\\n     * 1977-04-22T01:00:00-05:00).\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::now('America\/Toronto')->toISOString() . \\\"\\\\n\\\";\\n     * echo Carbon::now('America\/Toronto')->toISOString(true) . \\\"\\\\n\\\";\\n     * ```\\n     *\\n     * @param bool $keepOffset Pass true to keep the date offset. Else forced to UTC.\\n     *\/\\n    public function toISOString(bool $keepOffset = false): ?string\\n    {\\n        if (!$this->isValid()) {\\n            return null;\\n        }\\n\\n        $yearFormat = $this->year < 0 || $this->year > 9999 ? 'YYYYYY' : 'YYYY';\\n        $timezoneFormat = $keepOffset ? 'Z' : '[Z]';\\n        $date = $keepOffset ? $this : $this->avoidMutation()->utc();\\n\\n        return $date->isoFormat(\\\"$yearFormat-MM-DD[T]HH:mm:ss.SSSSSS$timezoneFormat\\\");\\n    }\\n\\n    \/**\\n     * Return the ISO-8601 string (ex: 1977-04-22T06:00:00Z) with UTC timezone.\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::now('America\/Toronto')->toJSON();\\n     * ```\\n     *\/\\n    public function toJSON(): ?string\\n    {\\n        return $this->toISOString();\\n    }\\n\\n    \/**\\n     * Return native DateTime PHP object matching the current instance.\\n     *\\n     * @example\\n     * ```\\n     * var_dump(Carbon::now()->toDateTime());\\n     * ```\\n     *\/\\n    public function toDateTime(): DateTime\\n    {\\n        return DateTime::createFromFormat('U.u', $this->rawFormat('U.u'))\\n            ->setTimezone($this->getTimezone());\\n    }\\n\\n    \/**\\n     * Return native toDateTimeImmutable PHP object matching the current instance.\\n     *\\n     * @example\\n     * ```\\n     * var_dump(Carbon::now()->toDateTimeImmutable());\\n     * ```\\n     *\/\\n    public function toDateTimeImmutable(): DateTimeImmutable\\n    {\\n        return DateTimeImmutable::createFromFormat('U.u', $this->rawFormat('U.u'))\\n            ->setTimezone($this->getTimezone());\\n    }\\n\\n    \/**\\n     * @alias toDateTime\\n     *\\n     * Return native DateTime PHP object matching the current instance.\\n     *\\n     * @example\\n     * ```\\n     * var_dump(Carbon::now()->toDate());\\n     * ```\\n     *\/\\n    public function toDate(): DateTime\\n    {\\n        return $this->toDateTime();\\n    }\\n\\n    \/**\\n     * Create a iterable CarbonPeriod object from current date to a given end date (and optional interval).\\n     *\\n     * @param \\\\DateTimeInterface|Carbon|CarbonImmutable|int|null $end      period end date or recurrences count if int\\n     * @param int|\\\\DateInterval|string|null                      $interval period default interval or number of the given $unit\\n     * @param string|null                                        $unit     if specified, $interval must be an integer\\n     *\/\\n    public function toPeriod($end = null, $interval = null, $unit = null): CarbonPeriod\\n    {\\n        if ($unit) {\\n            $interval = CarbonInterval::make(\\\"$interval \\\".static::pluralUnit($unit));\\n        }\\n\\n        $isDefaultInterval = !$interval;\\n        $interval ??= CarbonInterval::day();\\n        $class = $this->isMutable() ? CarbonPeriod::class : CarbonPeriodImmutable::class;\\n\\n        if (\\\\is_int($end) || (\\\\is_string($end) && ctype_digit($end))) {\\n            $end = (int) $end;\\n        }\\n\\n        $end ??= 1;\\n\\n        if (!\\\\is_int($end)) {\\n            $end = $this->resolveCarbon($end);\\n        }\\n\\n        return new $class(\\n            raw: [$this, CarbonInterval::make($interval), $end],\\n            dateClass: static::class,\\n            isDefaultInterval: $isDefaultInterval,\\n        );\\n    }\\n\\n    \/**\\n     * Create a iterable CarbonPeriod object from current date to a given end date (and optional interval).\\n     *\\n     * @param \\\\DateTimeInterface|Carbon|CarbonImmutable|null $end      period end date\\n     * @param int|\\\\DateInterval|string|null                  $interval period default interval or number of the given $unit\\n     * @param string|null                                    $unit     if specified, $interval must be an integer\\n     *\/\\n    public function range($end = null, $interval = null, $unit = null): CarbonPeriod\\n    {\\n        return $this->toPeriod($end, $interval, $unit);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Traits\/IntervalRounding.php\",\"ext\":\"php\",\"size\":1689,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon\\\\Traits;\\n\\nuse Carbon\\\\CarbonInterval;\\nuse Carbon\\\\Exceptions\\\\InvalidIntervalException;\\nuse DateInterval;\\n\\n\/**\\n * Trait to call rounding methods to interval or the interval of a period.\\n *\/\\ntrait IntervalRounding\\n{\\n    protected function callRoundMethod(string $method, array $parameters): ?static\\n    {\\n        $action = substr($method, 0, 4);\\n\\n        if ($action !== 'ceil') {\\n            $action = substr($method, 0, 5);\\n        }\\n\\n        if (\\\\in_array($action, ['round', 'floor', 'ceil'])) {\\n            return $this->{$action.'Unit'}(substr($method, \\\\strlen($action)), ...$parameters);\\n        }\\n\\n        return null;\\n    }\\n\\n    protected function roundWith(DateInterval|string|float|int $precision, callable|string $function): ?static\\n    {\\n        $unit = 'second';\\n\\n        if ($precision instanceof DateInterval) {\\n            $precision = CarbonInterval::instance($precision)->forHumans(['locale' => 'en']);\\n        }\\n\\n        if (\\\\is_string($precision) && preg_match('\/^\\\\s*(?<precision>\\\\d+)?\\\\s*(?<unit>\\\\w+)(?<other>\\\\W.*)?$\/', $precision, $match)) {\\n            if (trim($match['other'] ?? '') !== '') {\\n                throw new InvalidIntervalException('Rounding is only possible with single unit intervals.');\\n            }\\n\\n            $precision = (int) ($match['precision'] ?: 1);\\n            $unit = $match['unit'];\\n        }\\n\\n        return $this->roundUnit($unit, $precision, $function);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Traits\/Difference.php\",\"ext\":\"php\",\"size\":43657,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon\\\\Traits;\\n\\nuse Carbon\\\\Carbon;\\nuse Carbon\\\\CarbonImmutable;\\nuse Carbon\\\\CarbonInterface;\\nuse Carbon\\\\CarbonInterval;\\nuse Carbon\\\\CarbonPeriod;\\nuse Carbon\\\\Exceptions\\\\UnknownUnitException;\\nuse Carbon\\\\Unit;\\nuse Closure;\\nuse DateInterval;\\nuse DateTimeInterface;\\n\\n\/**\\n * Trait Difference.\\n *\\n * Depends on the following methods:\\n *\\n * @method bool lessThan($date)\\n * @method static copy()\\n * @method static resolveCarbon($date = null)\\n *\/\\ntrait Difference\\n{\\n    \/**\\n     * Get the difference as a DateInterval instance.\\n     * Return relative interval (negative if $absolute flag is not set to true and the given date is before\\n     * current one).\\n     *\\n     * @param \\\\Carbon\\\\CarbonInterface|\\\\DateTimeInterface|string|null $date\\n     * @param bool                                                   $absolute Get the absolute of the difference\\n     *\\n     * @return DateInterval\\n     *\/\\n    public function diffAsDateInterval($date = null, bool $absolute = false): DateInterval\\n    {\\n        $other = $this->resolveCarbon($date);\\n\\n        \/\/ Work-around for https:\/\/bugs.php.net\/bug.php?id=81458\\n        \/\/ It was initially introduced for https:\/\/bugs.php.net\/bug.php?id=80998\\n        \/\/ The very specific case of 80998 was fixed in PHP 8.1beta3, but it introduced 81458\\n        \/\/ So we still need to keep this for now\\n        if ($other->tz !== $this->tz) {\\n            $other = $other->avoidMutation()->setTimezone($this->tz);\\n        }\\n\\n        return parent::diff($other, $absolute);\\n    }\\n\\n    \/**\\n     * Get the difference as a CarbonInterval instance.\\n     * Return relative interval (negative if $absolute flag is not set to true and the given date is before\\n     * current one).\\n     *\\n     * @param \\\\Carbon\\\\CarbonInterface|\\\\DateTimeInterface|string|null $date\\n     * @param bool                                                   $absolute Get the absolute of the difference\\n     *\\n     * @return CarbonInterval\\n     *\/\\n    public function diffAsCarbonInterval($date = null, bool $absolute = false, array $skip = []): CarbonInterval\\n    {\\n        return CarbonInterval::diff($this, $this->resolveCarbon($date), $absolute, $skip)\\n            ->setLocalTranslator($this->getLocalTranslator());\\n    }\\n\\n    \/**\\n     * @alias diffAsCarbonInterval\\n     *\\n     * Get the difference as a DateInterval instance.\\n     * Return relative interval (negative if $absolute flag is not set to true and the given date is before\\n     * current one).\\n     *\\n     * @param \\\\Carbon\\\\CarbonInterface|\\\\DateTimeInterface|string|null $date\\n     * @param bool                                                   $absolute Get the absolute of the difference\\n     *\\n     * @return CarbonInterval\\n     *\/\\n    public function diff($date = null, bool $absolute = false, array $skip = []): CarbonInterval\\n    {\\n        return $this->diffAsCarbonInterval($date, $absolute, $skip);\\n    }\\n\\n    \/**\\n     * @param Unit|string                                            $unit     microsecond, millisecond, second, minute,\\n     *                                                                         hour, day, week, month, quarter, year,\\n     *                                                                         century, millennium\\n     * @param \\\\Carbon\\\\CarbonInterface|\\\\DateTimeInterface|string|null $date\\n     * @param bool                                                   $absolute Get the absolute of the difference\\n     * @param bool                                                   $utc      Always convert dates to UTC before comparing (if not set, it will do it only if timezones are different)\\n     *\\n     * @return float\\n     *\/\\n    public function diffInUnit(Unit|string $unit, $date = null, bool $absolute = false, bool $utc = false): float\\n    {\\n        $unit = static::pluralUnit($unit instanceof Unit ? $unit->value : rtrim($unit, 'z'));\\n        $method = 'diffIn'.$unit;\\n\\n        if (!method_exists($this, $method)) {\\n            throw new UnknownUnitException($unit);\\n        }\\n\\n        return $this->$method($date, $absolute, $utc);\\n    }\\n\\n    \/**\\n     * Get the difference in years\\n     *\\n     * @param \\\\Carbon\\\\CarbonInterface|\\\\DateTimeInterface|string|null $date\\n     * @param bool                                                   $absolute Get the absolute of the difference\\n     * @param bool                                                   $utc      Always convert dates to UTC before comparing (if not set, it will do it only if timezones are different)\\n     *\\n     * @return float\\n     *\/\\n    public function diffInYears($date = null, bool $absolute = false, bool $utc = false): float\\n    {\\n        $start = $this;\\n        $end = $this->resolveCarbon($date);\\n\\n        if ($utc) {\\n            $start = $start->avoidMutation()->utc();\\n            $end = $end->avoidMutation()->utc();\\n        }\\n\\n        $ascending = ($start <= $end);\\n        $sign = $absolute || $ascending ? 1 : -1;\\n\\n        if (!$ascending) {\\n            [$start, $end] = [$end, $start];\\n        }\\n\\n        $yearsDiff = (int) $start->diff($end, $absolute)->format('%r%y');\\n        \/** @var Carbon|CarbonImmutable $floorEnd *\/\\n        $floorEnd = $start->avoidMutation()->addYears($yearsDiff);\\n\\n        if ($floorEnd >= $end) {\\n            return $sign * $yearsDiff;\\n        }\\n\\n        \/** @var Carbon|CarbonImmutable $ceilEnd *\/\\n        $ceilEnd = $start->avoidMutation()->addYears($yearsDiff + 1);\\n\\n        $daysToFloor = $floorEnd->diffInDays($end);\\n        $daysToCeil = $end->diffInDays($ceilEnd);\\n\\n        return $sign * ($yearsDiff + $daysToFloor \/ ($daysToCeil + $daysToFloor));\\n    }\\n\\n    \/**\\n     * Get the difference in quarters.\\n     *\\n     * @param \\\\Carbon\\\\CarbonInterface|\\\\DateTimeInterface|string|null $date\\n     * @param bool                                                   $absolute Get the absolute of the difference\\n     * @param bool                                                   $utc      Always convert dates to UTC before comparing (if not set, it will do it only if timezones are different)\\n     *\\n     * @return float\\n     *\/\\n    public function diffInQuarters($date = null, bool $absolute = false, bool $utc = false): float\\n    {\\n        return $this->diffInMonths($date, $absolute, $utc) \/ static::MONTHS_PER_QUARTER;\\n    }\\n\\n    \/**\\n     * Get the difference in months.\\n     *\\n     * @param \\\\Carbon\\\\CarbonInterface|\\\\DateTimeInterface|string|null $date\\n     * @param bool                                                   $absolute Get the absolute of the difference\\n     * @param bool                                                   $utc      Always convert dates to UTC before comparing (if not set, it will do it only if timezones are different)\\n     *\\n     * @return float\\n     *\/\\n    public function diffInMonths($date = null, bool $absolute = false, bool $utc = false): float\\n    {\\n        $start = $this;\\n        $end = $this->resolveCarbon($date);\\n\\n        \/\/ Compare using UTC\\n        if ($utc || ($end->timezoneName !== $start->timezoneName)) {\\n            $start = $start->avoidMutation()->utc();\\n            $end = $end->avoidMutation()->utc();\\n        }\\n\\n        [$yearStart, $monthStart, $dayStart] = explode('-', $start->format('Y-m-dHisu'));\\n        [$yearEnd, $monthEnd, $dayEnd] = explode('-', $end->format('Y-m-dHisu'));\\n\\n        $monthsDiff = (((int) $yearEnd) - ((int) $yearStart)) * static::MONTHS_PER_YEAR +\\n            ((int) $monthEnd) - ((int) $monthStart);\\n\\n        if ($monthsDiff > 0) {\\n            $monthsDiff -= ($dayStart > $dayEnd ? 1 : 0);\\n        } elseif ($monthsDiff < 0) {\\n            $monthsDiff += ($dayStart < $dayEnd ? 1 : 0);\\n        }\\n\\n        $ascending = ($start <= $end);\\n        $sign = $absolute || $ascending ? 1 : -1;\\n        $monthsDiff = abs($monthsDiff);\\n\\n        if (!$ascending) {\\n            [$start, $end] = [$end, $start];\\n        }\\n\\n        \/** @var Carbon|CarbonImmutable $floorEnd *\/\\n        $floorEnd = $start->avoidMutation()->addMonths($monthsDiff);\\n\\n        if ($floorEnd >= $end) {\\n            return $sign * $monthsDiff;\\n        }\\n\\n        \/** @var Carbon|CarbonImmutable $ceilEnd *\/\\n        $ceilEnd = $start->avoidMutation()->addMonths($monthsDiff + 1);\\n\\n        $daysToFloor = $floorEnd->diffInDays($end);\\n        $daysToCeil = $end->diffInDays($ceilEnd);\\n\\n        return $sign * ($monthsDiff + $daysToFloor \/ ($daysToCeil + $daysToFloor));\\n    }\\n\\n    \/**\\n     * Get the difference in weeks.\\n     *\\n     * @param \\\\Carbon\\\\CarbonInterface|\\\\DateTimeInterface|string|null $date\\n     * @param bool                                                   $absolute Get the absolute of the difference\\n     * @param bool                                                   $utc      Always convert dates to UTC before comparing (if not set, it will do it only if timezones are different)\\n     *\\n     * @return float\\n     *\/\\n    public function diffInWeeks($date = null, bool $absolute = false, bool $utc = false): float\\n    {\\n        return $this->diffInDays($date, $absolute, $utc) \/ static::DAYS_PER_WEEK;\\n    }\\n\\n    \/**\\n     * Get the difference in days.\\n     *\\n     * @param \\\\Carbon\\\\CarbonInterface|\\\\DateTimeInterface|string|null $date\\n     * @param bool                                                   $absolute Get the absolute of the difference\\n     * @param bool                                                   $utc      Always convert dates to UTC before comparing (if not set, it will do it only if timezones are different)\\n     *\\n     * @return float\\n     *\/\\n    public function diffInDays($date = null, bool $absolute = false, bool $utc = false): float\\n    {\\n        $date = $this->resolveCarbon($date);\\n        $current = $this;\\n\\n        \/\/ Compare using UTC\\n        if ($utc || ($date->timezoneName !== $current->timezoneName)) {\\n            $date = $date->avoidMutation()->utc();\\n            $current = $current->avoidMutation()->utc();\\n        }\\n\\n        $negative = ($date < $current);\\n        [$start, $end] = $negative ? [$date, $current] : [$current, $date];\\n        $interval = $start->diffAsDateInterval($end);\\n        $daysA = $this->getIntervalDayDiff($interval);\\n        $floorEnd = $start->avoidMutation()->addDays($daysA);\\n        $daysB = $daysA + ($floorEnd <= $end ? 1 : -1);\\n        $ceilEnd = $start->avoidMutation()->addDays($daysB);\\n        $microsecondsBetween = $floorEnd->diffInMicroseconds($ceilEnd);\\n        $microsecondsToEnd = $floorEnd->diffInMicroseconds($end);\\n\\n        return ($negative && !$absolute ? -1 : 1)\\n            * ($daysA * ($microsecondsBetween - $microsecondsToEnd) + $daysB * $microsecondsToEnd)\\n            \/ $microsecondsBetween;\\n    }\\n\\n    \/**\\n     * Get the difference in days using a filter closure.\\n     *\\n     * @param Closure                                                $callback\\n     * @param \\\\Carbon\\\\CarbonInterface|\\\\DateTimeInterface|string|null $date\\n     * @param bool                                                   $absolute Get the absolute of the difference\\n     *\\n     * @return int\\n     *\/\\n    public function diffInDaysFiltered(Closure $callback, $date = null, bool $absolute = false): int\\n    {\\n        return $this->diffFiltered(CarbonInterval::day(), $callback, $date, $absolute);\\n    }\\n\\n    \/**\\n     * Get the difference in hours using a filter closure.\\n     *\\n     * @param Closure                                                $callback\\n     * @param \\\\Carbon\\\\CarbonInterface|\\\\DateTimeInterface|string|null $date\\n     * @param bool                                                   $absolute Get the absolute of the difference\\n     *\\n     * @return int\\n     *\/\\n    public function diffInHoursFiltered(Closure $callback, $date = null, bool $absolute = false): int\\n    {\\n        return $this->diffFiltered(CarbonInterval::hour(), $callback, $date, $absolute);\\n    }\\n\\n    \/**\\n     * Get the difference by the given interval using a filter closure.\\n     *\\n     * @param CarbonInterval                                         $ci       An interval to traverse by\\n     * @param Closure                                                $callback\\n     * @param \\\\Carbon\\\\CarbonInterface|\\\\DateTimeInterface|string|null $date\\n     * @param bool                                                   $absolute Get the absolute of the difference\\n     *\\n     * @return int\\n     *\/\\n    public function diffFiltered(CarbonInterval $ci, Closure $callback, $date = null, bool $absolute = false): int\\n    {\\n        $start = $this;\\n        $end = $this->resolveCarbon($date);\\n        $inverse = false;\\n\\n        if ($end < $start) {\\n            $start = $end;\\n            $end = $this;\\n            $inverse = true;\\n        }\\n\\n        $options = CarbonPeriod::EXCLUDE_END_DATE | ($this->isMutable() ? 0 : CarbonPeriod::IMMUTABLE);\\n        $diff = $ci->toPeriod($start, $end, $options)->filter($callback)->count();\\n\\n        return $inverse && !$absolute ? -$diff : $diff;\\n    }\\n\\n    \/**\\n     * Get the difference in weekdays.\\n     *\\n     * @param \\\\Carbon\\\\CarbonInterface|\\\\DateTimeInterface|string|null $date\\n     * @param bool                                                   $absolute Get the absolute of the difference\\n     *\\n     * @return int\\n     *\/\\n    public function diffInWeekdays($date = null, bool $absolute = false): int\\n    {\\n        return $this->diffInDaysFiltered(\\n            static fn (CarbonInterface $date) => $date->isWeekday(),\\n            $this->resolveCarbon($date)->avoidMutation()->modify($this->format('H:i:s.u')),\\n            $absolute,\\n        );\\n    }\\n\\n    \/**\\n     * Get the difference in weekend days using a filter.\\n     *\\n     * @param \\\\Carbon\\\\CarbonInterface|\\\\DateTimeInterface|string|null $date\\n     * @param bool                                                   $absolute Get the absolute of the difference\\n     *\\n     * @return int\\n     *\/\\n    public function diffInWeekendDays($date = null, bool $absolute = false): int\\n    {\\n        return $this->diffInDaysFiltered(\\n            static fn (CarbonInterface $date) => $date->isWeekend(),\\n            $this->resolveCarbon($date)->avoidMutation()->modify($this->format('H:i:s.u')),\\n            $absolute,\\n        );\\n    }\\n\\n    \/**\\n     * Get the difference in hours.\\n     *\\n     * @param \\\\Carbon\\\\CarbonInterface|\\\\DateTimeInterface|string|null $date\\n     * @param bool                                                   $absolute Get the absolute of the difference\\n     *\\n     * @return float\\n     *\/\\n    public function diffInHours($date = null, bool $absolute = false): float\\n    {\\n        return $this->diffInMinutes($date, $absolute) \/ static::MINUTES_PER_HOUR;\\n    }\\n\\n    \/**\\n     * Get the difference in minutes.\\n     *\\n     * @param \\\\Carbon\\\\CarbonInterface|\\\\DateTimeInterface|string|null $date\\n     * @param bool                                                   $absolute Get the absolute of the difference\\n     *\\n     * @return float\\n     *\/\\n    public function diffInMinutes($date = null, bool $absolute = false): float\\n    {\\n        return $this->diffInSeconds($date, $absolute) \/ static::SECONDS_PER_MINUTE;\\n    }\\n\\n    \/**\\n     * Get the difference in seconds.\\n     *\\n     * @param \\\\Carbon\\\\CarbonInterface|\\\\DateTimeInterface|string|null $date\\n     * @param bool                                                   $absolute Get the absolute of the difference\\n     *\\n     * @return float\\n     *\/\\n    public function diffInSeconds($date = null, bool $absolute = false): float\\n    {\\n        return $this->diffInMilliseconds($date, $absolute) \/ static::MILLISECONDS_PER_SECOND;\\n    }\\n\\n    \/**\\n     * Get the difference in microseconds.\\n     *\\n     * @param \\\\Carbon\\\\CarbonInterface|\\\\DateTimeInterface|string|null $date\\n     * @param bool                                                   $absolute Get the absolute of the difference\\n     *\\n     * @return float\\n     *\/\\n    public function diffInMicroseconds($date = null, bool $absolute = false): float\\n    {\\n        \/** @var CarbonInterface $date *\/\\n        $date = $this->resolveCarbon($date);\\n        $value = ($date->timestamp - $this->timestamp) * static::MICROSECONDS_PER_SECOND +\\n            $date->micro - $this->micro;\\n\\n        return $absolute ? abs($value) : $value;\\n    }\\n\\n    \/**\\n     * Get the difference in milliseconds.\\n     *\\n     * @param \\\\Carbon\\\\CarbonInterface|\\\\DateTimeInterface|string|null $date\\n     * @param bool                                                   $absolute Get the absolute of the difference\\n     *\\n     * @return float\\n     *\/\\n    public function diffInMilliseconds($date = null, bool $absolute = false): float\\n    {\\n        return $this->diffInMicroseconds($date, $absolute) \/ static::MICROSECONDS_PER_MILLISECOND;\\n    }\\n\\n    \/**\\n     * The number of seconds since midnight.\\n     *\\n     * @return float\\n     *\/\\n    public function secondsSinceMidnight(): float\\n    {\\n        return $this->diffInSeconds($this->copy()->startOfDay(), true);\\n    }\\n\\n    \/**\\n     * The number of seconds until 23:59:59.\\n     *\\n     * @return float\\n     *\/\\n    public function secondsUntilEndOfDay(): float\\n    {\\n        return $this->diffInSeconds($this->copy()->endOfDay(), true);\\n    }\\n\\n    \/**\\n     * Get the difference in a human readable format in the current locale from current instance to an other\\n     * instance given (or now if null given).\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::tomorrow()->diffForHumans() . \\\"\\\\n\\\";\\n     * echo Carbon::tomorrow()->diffForHumans(['parts' => 2]) . \\\"\\\\n\\\";\\n     * echo Carbon::tomorrow()->diffForHumans(['parts' => 3, 'join' => true]) . \\\"\\\\n\\\";\\n     * echo Carbon::tomorrow()->diffForHumans(Carbon::yesterday()) . \\\"\\\\n\\\";\\n     * echo Carbon::tomorrow()->diffForHumans(Carbon::yesterday(), ['short' => true]) . \\\"\\\\n\\\";\\n     * ```\\n     *\\n     * @param Carbon|DateTimeInterface|string|array|null $other   if array passed, will be used as parameters array, see $syntax below;\\n     *                                                            if null passed, now will be used as comparison reference;\\n     *                                                            if any other type, it will be converted to date and used as reference.\\n     * @param int|array                                  $syntax  if array passed, parameters will be extracted from it, the array may contains:\\n     *                                                            \u29bf 'syntax' entry (see below)\\n     *                                                            \u29bf 'short' entry (see below)\\n     *                                                            \u29bf 'parts' entry (see below)\\n     *                                                            \u29bf 'options' entry (see below)\\n     *                                                            \u29bf 'skip' entry, list of units to skip (array of strings or a single string,\\n     *                                                            ` it can be the unit name (singular or plural) or its shortcut\\n     *                                                            ` (y, m, w, d, h, min, s, ms, \u00b5s).\\n     *                                                            \u29bf 'aUnit' entry, prefer \\\"an hour\\\" over \\\"1 hour\\\" if true\\n     *                                                            \u29bf 'altNumbers' entry, use alternative numbers if available\\n     *                                                            ` (from the current language if true is passed, from the given language(s)\\n     *                                                            ` if array or string is passed)\\n     *                                                            \u29bf 'join' entry determines how to join multiple parts of the string\\n     *                                                            `  - if $join is a string, it's used as a joiner glue\\n     *                                                            `  - if $join is a callable\/closure, it get the list of string and should return a string\\n     *                                                            `  - if $join is an array, the first item will be the default glue, and the second item\\n     *                                                            `    will be used instead of the glue for the last item\\n     *                                                            `  - if $join is true, it will be guessed from the locale ('list' translation file entry)\\n     *                                                            `  - if $join is missing, a space will be used as glue\\n     *                                                            \u29bf 'other' entry (see above)\\n     *                                                            \u29bf 'minimumUnit' entry determines the smallest unit of time to display can be long or\\n     *                                                            `  short form of the units, e.g. 'hour' or 'h' (default value: s)\\n     *                                                            \u29bf 'locale' language in which the diff should be output (has no effect if 'translator' key is set)\\n     *                                                            \u29bf 'translator' a custom translator to use to translator the output.\\n     *                                                            if int passed, it adds modifiers:\\n     *                                                            Possible values:\\n     *                                                            - CarbonInterface::DIFF_ABSOLUTE          no modifiers\\n     *                                                            - CarbonInterface::DIFF_RELATIVE_TO_NOW   add ago\/from now modifier\\n     *                                                            - CarbonInterface::DIFF_RELATIVE_TO_OTHER add before\/after modifier\\n     *                                                            Default value: CarbonInterface::DIFF_ABSOLUTE\\n     * @param bool                                       $short   displays short format of time units\\n     * @param int                                        $parts   maximum number of parts to display (default value: 1: single unit)\\n     * @param int                                        $options human diff options\\n     *\/\\n    public function diffForHumans($other = null, $syntax = null, $short = false, $parts = 1, $options = null): string\\n    {\\n        \/* @var CarbonInterface $this *\/\\n        if (\\\\is_array($other)) {\\n            $other['syntax'] = \\\\array_key_exists('syntax', $other) ? $other['syntax'] : $syntax;\\n            $syntax = $other;\\n            $other = $syntax['other'] ?? null;\\n        }\\n\\n        $intSyntax = &$syntax;\\n\\n        if (\\\\is_array($syntax)) {\\n            $syntax['syntax'] = $syntax['syntax'] ?? null;\\n            $intSyntax = &$syntax['syntax'];\\n        }\\n\\n        $intSyntax = (int) ($intSyntax ?? static::DIFF_RELATIVE_AUTO);\\n        $intSyntax = $intSyntax === static::DIFF_RELATIVE_AUTO && $other === null ? static::DIFF_RELATIVE_TO_NOW : $intSyntax;\\n\\n        $parts = min(7, max(1, (int) $parts));\\n        $skip = \\\\is_array($syntax) ? ($syntax['skip'] ?? []) : [];\\n        $options ??= $this->localHumanDiffOptions ?? $this->transmitFactory(\\n            static fn () => static::getHumanDiffOptions(),\\n        );\\n\\n        return $this->diff($other, skip: (array) $skip)->forHumans($syntax, (bool) $short, $parts, $options);\\n    }\\n\\n    \/**\\n     * @alias diffForHumans\\n     *\\n     * Get the difference in a human readable format in the current locale from current instance to an other\\n     * instance given (or now if null given).\\n     *\\n     * @param Carbon|\\\\DateTimeInterface|string|array|null $other   if array passed, will be used as parameters array, see $syntax below;\\n     *                                                             if null passed, now will be used as comparison reference;\\n     *                                                             if any other type, it will be converted to date and used as reference.\\n     * @param int|array                                   $syntax  if array passed, parameters will be extracted from it, the array may contains:\\n     *                                                             - 'syntax' entry (see below)\\n     *                                                             - 'short' entry (see below)\\n     *                                                             - 'parts' entry (see below)\\n     *                                                             - 'options' entry (see below)\\n     *                                                             - 'join' entry determines how to join multiple parts of the string\\n     *                                                             `  - if $join is a string, it's used as a joiner glue\\n     *                                                             `  - if $join is a callable\/closure, it get the list of string and should return a string\\n     *                                                             `  - if $join is an array, the first item will be the default glue, and the second item\\n     *                                                             `    will be used instead of the glue for the last item\\n     *                                                             `  - if $join is true, it will be guessed from the locale ('list' translation file entry)\\n     *                                                             `  - if $join is missing, a space will be used as glue\\n     *                                                             - 'other' entry (see above)\\n     *                                                             if int passed, it add modifiers:\\n     *                                                             Possible values:\\n     *                                                             - CarbonInterface::DIFF_ABSOLUTE          no modifiers\\n     *                                                             - CarbonInterface::DIFF_RELATIVE_TO_NOW   add ago\/from now modifier\\n     *                                                             - CarbonInterface::DIFF_RELATIVE_TO_OTHER add before\/after modifier\\n     *                                                             Default value: CarbonInterface::DIFF_ABSOLUTE\\n     * @param bool                                        $short   displays short format of time units\\n     * @param int                                         $parts   maximum number of parts to display (default value: 1: single unit)\\n     * @param int                                         $options human diff options\\n     *\\n     * @return string\\n     *\/\\n    public function from($other = null, $syntax = null, $short = false, $parts = 1, $options = null)\\n    {\\n        return $this->diffForHumans($other, $syntax, $short, $parts, $options);\\n    }\\n\\n    \/**\\n     * @alias diffForHumans\\n     *\\n     * Get the difference in a human readable format in the current locale from current instance to an other\\n     * instance given (or now if null given).\\n     *\/\\n    public function since($other = null, $syntax = null, $short = false, $parts = 1, $options = null)\\n    {\\n        return $this->diffForHumans($other, $syntax, $short, $parts, $options);\\n    }\\n\\n    \/**\\n     * Get the difference in a human readable format in the current locale from an other\\n     * instance given (or now if null given) to current instance.\\n     *\\n     * When comparing a value in the past to default now:\\n     * 1 hour from now\\n     * 5 months from now\\n     *\\n     * When comparing a value in the future to default now:\\n     * 1 hour ago\\n     * 5 months ago\\n     *\\n     * When comparing a value in the past to another value:\\n     * 1 hour after\\n     * 5 months after\\n     *\\n     * When comparing a value in the future to another value:\\n     * 1 hour before\\n     * 5 months before\\n     *\\n     * @param Carbon|\\\\DateTimeInterface|string|array|null $other   if array passed, will be used as parameters array, see $syntax below;\\n     *                                                             if null passed, now will be used as comparison reference;\\n     *                                                             if any other type, it will be converted to date and used as reference.\\n     * @param int|array                                   $syntax  if array passed, parameters will be extracted from it, the array may contains:\\n     *                                                             - 'syntax' entry (see below)\\n     *                                                             - 'short' entry (see below)\\n     *                                                             - 'parts' entry (see below)\\n     *                                                             - 'options' entry (see below)\\n     *                                                             - 'join' entry determines how to join multiple parts of the string\\n     *                                                             `  - if $join is a string, it's used as a joiner glue\\n     *                                                             `  - if $join is a callable\/closure, it get the list of string and should return a string\\n     *                                                             `  - if $join is an array, the first item will be the default glue, and the second item\\n     *                                                             `    will be used instead of the glue for the last item\\n     *                                                             `  - if $join is true, it will be guessed from the locale ('list' translation file entry)\\n     *                                                             `  - if $join is missing, a space will be used as glue\\n     *                                                             - 'other' entry (see above)\\n     *                                                             if int passed, it add modifiers:\\n     *                                                             Possible values:\\n     *                                                             - CarbonInterface::DIFF_ABSOLUTE          no modifiers\\n     *                                                             - CarbonInterface::DIFF_RELATIVE_TO_NOW   add ago\/from now modifier\\n     *                                                             - CarbonInterface::DIFF_RELATIVE_TO_OTHER add before\/after modifier\\n     *                                                             Default value: CarbonInterface::DIFF_ABSOLUTE\\n     * @param bool                                        $short   displays short format of time units\\n     * @param int                                         $parts   maximum number of parts to display (default value: 1: single unit)\\n     * @param int                                         $options human diff options\\n     *\\n     * @return string\\n     *\/\\n    public function to($other = null, $syntax = null, $short = false, $parts = 1, $options = null)\\n    {\\n        if (!$syntax && !$other) {\\n            $syntax = CarbonInterface::DIFF_RELATIVE_TO_NOW;\\n        }\\n\\n        return $this->resolveCarbon($other)->diffForHumans($this, $syntax, $short, $parts, $options);\\n    }\\n\\n    \/**\\n     * @alias to\\n     *\\n     * Get the difference in a human readable format in the current locale from an other\\n     * instance given (or now if null given) to current instance.\\n     *\\n     * @param Carbon|\\\\DateTimeInterface|string|array|null $other   if array passed, will be used as parameters array, see $syntax below;\\n     *                                                             if null passed, now will be used as comparison reference;\\n     *                                                             if any other type, it will be converted to date and used as reference.\\n     * @param int|array                                   $syntax  if array passed, parameters will be extracted from it, the array may contains:\\n     *                                                             - 'syntax' entry (see below)\\n     *                                                             - 'short' entry (see below)\\n     *                                                             - 'parts' entry (see below)\\n     *                                                             - 'options' entry (see below)\\n     *                                                             - 'join' entry determines how to join multiple parts of the string\\n     *                                                             `  - if $join is a string, it's used as a joiner glue\\n     *                                                             `  - if $join is a callable\/closure, it get the list of string and should return a string\\n     *                                                             `  - if $join is an array, the first item will be the default glue, and the second item\\n     *                                                             `    will be used instead of the glue for the last item\\n     *                                                             `  - if $join is true, it will be guessed from the locale ('list' translation file entry)\\n     *                                                             `  - if $join is missing, a space will be used as glue\\n     *                                                             - 'other' entry (see above)\\n     *                                                             if int passed, it add modifiers:\\n     *                                                             Possible values:\\n     *                                                             - CarbonInterface::DIFF_ABSOLUTE          no modifiers\\n     *                                                             - CarbonInterface::DIFF_RELATIVE_TO_NOW   add ago\/from now modifier\\n     *                                                             - CarbonInterface::DIFF_RELATIVE_TO_OTHER add before\/after modifier\\n     *                                                             Default value: CarbonInterface::DIFF_ABSOLUTE\\n     * @param bool                                        $short   displays short format of time units\\n     * @param int                                         $parts   maximum number of parts to display (default value: 1: single unit)\\n     * @param int                                         $options human diff options\\n     *\\n     * @return string\\n     *\/\\n    public function until($other = null, $syntax = null, $short = false, $parts = 1, $options = null)\\n    {\\n        return $this->to($other, $syntax, $short, $parts, $options);\\n    }\\n\\n    \/**\\n     * Get the difference in a human readable format in the current locale from current\\n     * instance to now.\\n     *\\n     * @param int|array $syntax  if array passed, parameters will be extracted from it, the array may contains:\\n     *                           - 'syntax' entry (see below)\\n     *                           - 'short' entry (see below)\\n     *                           - 'parts' entry (see below)\\n     *                           - 'options' entry (see below)\\n     *                           - 'join' entry determines how to join multiple parts of the string\\n     *                           `  - if $join is a string, it's used as a joiner glue\\n     *                           `  - if $join is a callable\/closure, it get the list of string and should return a string\\n     *                           `  - if $join is an array, the first item will be the default glue, and the second item\\n     *                           `    will be used instead of the glue for the last item\\n     *                           `  - if $join is true, it will be guessed from the locale ('list' translation file entry)\\n     *                           `  - if $join is missing, a space will be used as glue\\n     *                           if int passed, it add modifiers:\\n     *                           Possible values:\\n     *                           - CarbonInterface::DIFF_ABSOLUTE          no modifiers\\n     *                           - CarbonInterface::DIFF_RELATIVE_TO_NOW   add ago\/from now modifier\\n     *                           - CarbonInterface::DIFF_RELATIVE_TO_OTHER add before\/after modifier\\n     *                           Default value: CarbonInterface::DIFF_ABSOLUTE\\n     * @param bool      $short   displays short format of time units\\n     * @param int       $parts   maximum number of parts to display (default value: 1: single unit)\\n     * @param int       $options human diff options\\n     *\\n     * @return string\\n     *\/\\n    public function fromNow($syntax = null, $short = false, $parts = 1, $options = null)\\n    {\\n        $other = null;\\n\\n        if ($syntax instanceof DateTimeInterface) {\\n            [$other, $syntax, $short, $parts, $options] = array_pad(\\\\func_get_args(), 5, null);\\n        }\\n\\n        return $this->from($other, $syntax, $short, $parts, $options);\\n    }\\n\\n    \/**\\n     * Get the difference in a human readable format in the current locale from an other\\n     * instance given to now\\n     *\\n     * @param int|array $syntax  if array passed, parameters will be extracted from it, the array may contains:\\n     *                           - 'syntax' entry (see below)\\n     *                           - 'short' entry (see below)\\n     *                           - 'parts' entry (see below)\\n     *                           - 'options' entry (see below)\\n     *                           - 'join' entry determines how to join multiple parts of the string\\n     *                           `  - if $join is a string, it's used as a joiner glue\\n     *                           `  - if $join is a callable\/closure, it get the list of string and should return a string\\n     *                           `  - if $join is an array, the first item will be the default glue, and the second item\\n     *                           `    will be used instead of the glue for the last item\\n     *                           `  - if $join is true, it will be guessed from the locale ('list' translation file entry)\\n     *                           `  - if $join is missing, a space will be used as glue\\n     *                           if int passed, it add modifiers:\\n     *                           Possible values:\\n     *                           - CarbonInterface::DIFF_ABSOLUTE          no modifiers\\n     *                           - CarbonInterface::DIFF_RELATIVE_TO_NOW   add ago\/from now modifier\\n     *                           - CarbonInterface::DIFF_RELATIVE_TO_OTHER add before\/after modifier\\n     *                           Default value: CarbonInterface::DIFF_ABSOLUTE\\n     * @param bool      $short   displays short format of time units\\n     * @param int       $parts   maximum number of parts to display (default value: 1: single part)\\n     * @param int       $options human diff options\\n     *\\n     * @return string\\n     *\/\\n    public function toNow($syntax = null, $short = false, $parts = 1, $options = null)\\n    {\\n        return $this->to(null, $syntax, $short, $parts, $options);\\n    }\\n\\n    \/**\\n     * Get the difference in a human readable format in the current locale from an other\\n     * instance given to now\\n     *\\n     * @param int|array $syntax  if array passed, parameters will be extracted from it, the array may contains:\\n     *                           - 'syntax' entry (see below)\\n     *                           - 'short' entry (see below)\\n     *                           - 'parts' entry (see below)\\n     *                           - 'options' entry (see below)\\n     *                           - 'join' entry determines how to join multiple parts of the string\\n     *                           `  - if $join is a string, it's used as a joiner glue\\n     *                           `  - if $join is a callable\/closure, it get the list of string and should return a string\\n     *                           `  - if $join is an array, the first item will be the default glue, and the second item\\n     *                           `    will be used instead of the glue for the last item\\n     *                           `  - if $join is true, it will be guessed from the locale ('list' translation file entry)\\n     *                           `  - if $join is missing, a space will be used as glue\\n     *                           if int passed, it add modifiers:\\n     *                           Possible values:\\n     *                           - CarbonInterface::DIFF_ABSOLUTE          no modifiers\\n     *                           - CarbonInterface::DIFF_RELATIVE_TO_NOW   add ago\/from now modifier\\n     *                           - CarbonInterface::DIFF_RELATIVE_TO_OTHER add before\/after modifier\\n     *                           Default value: CarbonInterface::DIFF_ABSOLUTE\\n     * @param bool      $short   displays short format of time units\\n     * @param int       $parts   maximum number of parts to display (default value: 1: single part)\\n     * @param int       $options human diff options\\n     *\\n     * @return string\\n     *\/\\n    public function ago($syntax = null, $short = false, $parts = 1, $options = null)\\n    {\\n        $other = null;\\n\\n        if ($syntax instanceof DateTimeInterface) {\\n            [$other, $syntax, $short, $parts, $options] = array_pad(\\\\func_get_args(), 5, null);\\n        }\\n\\n        return $this->from($other, $syntax, $short, $parts, $options);\\n    }\\n\\n    \/**\\n     * Get the difference in a human-readable format in the current locale from current instance to another\\n     * instance given (or now if null given).\\n     *\\n     * @return string\\n     *\/\\n    public function timespan($other = null, $timezone = null): string\\n    {\\n        if (\\\\is_string($other)) {\\n            $other = $this->transmitFactory(static fn () => static::parse($other, $timezone));\\n        }\\n\\n        return $this->diffForHumans($other, [\\n            'join' => ', ',\\n            'syntax' => CarbonInterface::DIFF_ABSOLUTE,\\n            'parts' => INF,\\n        ]);\\n    }\\n\\n    \/**\\n     * Returns either day of week + time (e.g. \\\"Last Friday at 3:30 PM\\\") if reference time is within 7 days,\\n     * or a calendar date (e.g. \\\"10\/29\/2017\\\") otherwise.\\n     *\\n     * Language, date and time formats will change according to the current locale.\\n     *\\n     * @param Carbon|\\\\DateTimeInterface|string|null $referenceTime\\n     * @param array                                 $formats\\n     *\\n     * @return string\\n     *\/\\n    public function calendar($referenceTime = null, array $formats = [])\\n    {\\n        \/** @var CarbonInterface $current *\/\\n        $current = $this->avoidMutation()->startOfDay();\\n        \/** @var CarbonInterface $other *\/\\n        $other = $this->resolveCarbon($referenceTime)->avoidMutation()->setTimezone($this->getTimezone())->startOfDay();\\n        $diff = $other->diffInDays($current, false);\\n        $format = $diff <= -static::DAYS_PER_WEEK ? 'sameElse' : (\\n            $diff < -1 ? 'lastWeek' : (\\n                $diff < 0 ? 'lastDay' : (\\n                    $diff < 1 ? 'sameDay' : (\\n                        $diff < 2 ? 'nextDay' : (\\n                            $diff < static::DAYS_PER_WEEK ? 'nextWeek' : 'sameElse'\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n        $format = array_merge($this->getCalendarFormats(), $formats)[$format];\\n        if ($format instanceof Closure) {\\n            $format = $format($current, $other) ?? '';\\n        }\\n\\n        return $this->isoFormat((string) $format);\\n    }\\n\\n    private function getIntervalDayDiff(DateInterval $interval): int\\n    {\\n        return (int) $interval->format('%r%a');\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Traits\/Macro.php\",\"ext\":\"php\",\"size\":2771,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon\\\\Traits;\\n\\nuse Carbon\\\\FactoryImmutable;\\n\\n\/**\\n * Trait Macros.\\n *\\n * Allows users to register macros within the Carbon class.\\n *\/\\ntrait Macro\\n{\\n    use Mixin;\\n\\n    \/**\\n     * Register a custom macro.\\n     *\\n     * Pass null macro to remove it.\\n     *\\n     * @example\\n     * ```\\n     * $userSettings = [\\n     *   'locale' => 'pt',\\n     *   'timezone' => 'America\/Sao_Paulo',\\n     * ];\\n     * Carbon::macro('userFormat', function () use ($userSettings) {\\n     *   return $this->copy()->locale($userSettings['locale'])->tz($userSettings['timezone'])->calendar();\\n     * });\\n     * echo Carbon::yesterday()->hours(11)->userFormat();\\n     * ```\\n     *\\n     * @param-closure-this static $macro\\n     *\/\\n    public static function macro(string $name, ?callable $macro): void\\n    {\\n        FactoryImmutable::getDefaultInstance()->macro($name, $macro);\\n    }\\n\\n    \/**\\n     * Remove all macros and generic macros.\\n     *\/\\n    public static function resetMacros(): void\\n    {\\n        FactoryImmutable::getDefaultInstance()->resetMacros();\\n    }\\n\\n    \/**\\n     * Register a custom macro.\\n     *\\n     * @param callable $macro\\n     * @param int      $priority marco with higher priority is tried first\\n     *\\n     * @return void\\n     *\/\\n    public static function genericMacro(callable $macro, int $priority = 0): void\\n    {\\n        FactoryImmutable::getDefaultInstance()->genericMacro($macro, $priority);\\n    }\\n\\n    \/**\\n     * Checks if macro is registered globally.\\n     *\\n     * @param string $name\\n     *\\n     * @return bool\\n     *\/\\n    public static function hasMacro(string $name): bool\\n    {\\n        return FactoryImmutable::getInstance()->hasMacro($name);\\n    }\\n\\n    \/**\\n     * Get the raw callable macro registered globally for a given name.\\n     *\/\\n    public static function getMacro(string $name): ?callable\\n    {\\n        return FactoryImmutable::getInstance()->getMacro($name);\\n    }\\n\\n    \/**\\n     * Checks if macro is registered globally or locally.\\n     *\/\\n    public function hasLocalMacro(string $name): bool\\n    {\\n        return ($this->localMacros && isset($this->localMacros[$name])) || $this->transmitFactory(\\n            static fn () => static::hasMacro($name),\\n        );\\n    }\\n\\n    \/**\\n     * Get the raw callable macro registered globally or locally for a given name.\\n     *\/\\n    public function getLocalMacro(string $name): ?callable\\n    {\\n        return ($this->localMacros ?? [])[$name] ?? $this->transmitFactory(\\n            static fn () => static::getMacro($name),\\n        );\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Traits\/Date.php\",\"ext\":\"php\",\"size\":233637,\"mtime\":1756373565},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Traits\/MagicParameter.php\",\"ext\":\"php\",\"size\":747,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon\\\\Traits;\\n\\n\/**\\n * Trait MagicParameter.\\n *\\n * Allows to retrieve parameter in magic calls by index or name.\\n *\/\\ntrait MagicParameter\\n{\\n    private function getMagicParameter(array $parameters, int $index, string $key, $default)\\n    {\\n        if (\\\\array_key_exists($index, $parameters)) {\\n            return $parameters[$index];\\n        }\\n\\n        if (\\\\array_key_exists($key, $parameters)) {\\n            return $parameters[$key];\\n        }\\n\\n        return $default;\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Traits\/Mixin.php\",\"ext\":\"php\",\"size\":6331,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon\\\\Traits;\\n\\nuse Carbon\\\\CarbonInterface;\\nuse Carbon\\\\CarbonInterval;\\nuse Carbon\\\\CarbonPeriod;\\nuse Closure;\\nuse Generator;\\nuse ReflectionClass;\\nuse ReflectionException;\\nuse ReflectionMethod;\\nuse Throwable;\\n\\n\/**\\n * Trait Mixin.\\n *\\n * Allows mixing in entire classes with multiple macros.\\n *\/\\ntrait Mixin\\n{\\n    \/**\\n     * Stack of macro instance contexts.\\n     *\/\\n    protected static array $macroContextStack = [];\\n\\n    \/**\\n     * Mix another object into the class.\\n     *\\n     * @example\\n     * ```\\n     * Carbon::mixin(new class {\\n     *   public function addMoon() {\\n     *     return function () {\\n     *       return $this->addDays(30);\\n     *     };\\n     *   }\\n     *   public function subMoon() {\\n     *     return function () {\\n     *       return $this->subDays(30);\\n     *     };\\n     *   }\\n     * });\\n     * $fullMoon = Carbon::create('2018-12-22');\\n     * $nextFullMoon = $fullMoon->addMoon();\\n     * $blackMoon = Carbon::create('2019-01-06');\\n     * $previousBlackMoon = $blackMoon->subMoon();\\n     * echo \\\"$nextFullMoon\\\\n\\\";\\n     * echo \\\"$previousBlackMoon\\\\n\\\";\\n     * ```\\n     *\\n     * @throws ReflectionException\\n     *\/\\n    public static function mixin(object|string $mixin): void\\n    {\\n        \\\\is_string($mixin) && trait_exists($mixin)\\n            ? self::loadMixinTrait($mixin)\\n            : self::loadMixinClass($mixin);\\n    }\\n\\n    \/**\\n     * @throws ReflectionException\\n     *\/\\n    private static function loadMixinClass(object|string $mixin): void\\n    {\\n        $methods = (new ReflectionClass($mixin))->getMethods(\\n            ReflectionMethod::IS_PUBLIC | ReflectionMethod::IS_PROTECTED,\\n        );\\n\\n        foreach ($methods as $method) {\\n            if ($method->isConstructor() || $method->isDestructor()) {\\n                continue;\\n            }\\n\\n            $macro = $method->invoke($mixin);\\n\\n            if (\\\\is_callable($macro)) {\\n                static::macro($method->name, $macro);\\n            }\\n        }\\n    }\\n\\n    private static function loadMixinTrait(string $trait): void\\n    {\\n        $context = eval(self::getAnonymousClassCodeForTrait($trait));\\n        $className = \\\\get_class($context);\\n        $baseClass = static::class;\\n\\n        foreach (self::getMixableMethods($context) as $name) {\\n            $closureBase = Closure::fromCallable([$context, $name]);\\n\\n            static::macro($name, function (...$parameters) use ($closureBase, $className, $baseClass) {\\n                $downContext = isset($this) ? ($this) : new $baseClass();\\n                $context = isset($this) ? $this->cast($className) : new $className();\\n\\n                try {\\n                    \/\/ @ is required to handle error if not converted into exceptions\\n                    $closure = @$closureBase->bindTo($context);\\n                } catch (Throwable) { \/\/ @codeCoverageIgnore\\n                    $closure = $closureBase; \/\/ @codeCoverageIgnore\\n                }\\n\\n                \/\/ in case of errors not converted into exceptions\\n                $closure = $closure ?: $closureBase;\\n\\n                $result = $closure(...$parameters);\\n\\n                if (!($result instanceof $className)) {\\n                    return $result;\\n                }\\n\\n                if ($downContext instanceof CarbonInterface && $result instanceof CarbonInterface) {\\n                    if ($context !== $result) {\\n                        $downContext = $downContext->copy();\\n                    }\\n\\n                    return $downContext\\n                        ->setTimezone($result->getTimezone())\\n                        ->modify($result->format('Y-m-d H:i:s.u'))\\n                        ->settings($result->getSettings());\\n                }\\n\\n                if ($downContext instanceof CarbonInterval && $result instanceof CarbonInterval) {\\n                    if ($context !== $result) {\\n                        $downContext = $downContext->copy();\\n                    }\\n\\n                    $downContext->copyProperties($result);\\n                    self::copyStep($downContext, $result);\\n                    self::copyNegativeUnits($downContext, $result);\\n\\n                    return $downContext->settings($result->getSettings());\\n                }\\n\\n                if ($downContext instanceof CarbonPeriod && $result instanceof CarbonPeriod) {\\n                    if ($context !== $result) {\\n                        $downContext = $downContext->copy();\\n                    }\\n\\n                    return $downContext\\n                        ->setDates($result->getStartDate(), $result->getEndDate())\\n                        ->setRecurrences($result->getRecurrences())\\n                        ->setOptions($result->getOptions())\\n                        ->settings($result->getSettings());\\n                }\\n\\n                return $result;\\n            });\\n        }\\n    }\\n\\n    private static function getAnonymousClassCodeForTrait(string $trait): string\\n    {\\n        return 'return new class() extends '.static::class.' {use '.$trait.';};';\\n    }\\n\\n    private static function getMixableMethods(self $context): Generator\\n    {\\n        foreach (get_class_methods($context) as $name) {\\n            if (method_exists(static::class, $name)) {\\n                continue;\\n            }\\n\\n            yield $name;\\n        }\\n    }\\n\\n    \/**\\n     * Stack a Carbon context from inside calls of self::this() and execute a given action.\\n     *\/\\n    protected static function bindMacroContext(?self $context, callable $callable): mixed\\n    {\\n        static::$macroContextStack[] = $context;\\n\\n        try {\\n            return $callable();\\n        } finally {\\n            array_pop(static::$macroContextStack);\\n        }\\n    }\\n\\n    \/**\\n     * Return the current context from inside a macro callee or a null if static.\\n     *\/\\n    protected static function context(): ?static\\n    {\\n        return end(static::$macroContextStack) ?: null;\\n    }\\n\\n    \/**\\n     * Return the current context from inside a macro callee or a new one if static.\\n     *\/\\n    protected static function this(): static\\n    {\\n        return end(static::$macroContextStack) ?: new static();\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Traits\/Boundaries.php\",\"ext\":\"php\",\"size\":12438,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon\\\\Traits;\\n\\nuse Carbon\\\\Exceptions\\\\UnknownUnitException;\\nuse Carbon\\\\Unit;\\nuse Carbon\\\\WeekDay;\\n\\n\/**\\n * Trait Boundaries.\\n *\\n * startOf, endOf and derived method for each unit.\\n *\\n * Depends on the following properties:\\n *\\n * @property int $year\\n * @property int $month\\n * @property int $daysInMonth\\n * @property int $quarter\\n *\\n * Depends on the following methods:\\n *\\n * @method $this setTime(int $hour, int $minute, int $second = 0, int $microseconds = 0)\\n * @method $this setDate(int $year, int $month, int $day)\\n * @method $this addMonths(int $value = 1)\\n *\/\\ntrait Boundaries\\n{\\n    \/**\\n     * Resets the time to 00:00:00 start of day\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::parse('2018-07-25 12:45:16')->startOfDay();\\n     * ```\\n     *\\n     * @return static\\n     *\/\\n    public function startOfDay()\\n    {\\n        return $this->setTime(0, 0, 0, 0);\\n    }\\n\\n    \/**\\n     * Resets the time to 23:59:59.999999 end of day\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::parse('2018-07-25 12:45:16')->endOfDay();\\n     * ```\\n     *\\n     * @return static\\n     *\/\\n    public function endOfDay()\\n    {\\n        return $this->setTime(static::HOURS_PER_DAY - 1, static::MINUTES_PER_HOUR - 1, static::SECONDS_PER_MINUTE - 1, static::MICROSECONDS_PER_SECOND - 1);\\n    }\\n\\n    \/**\\n     * Resets the date to the first day of the month and the time to 00:00:00\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::parse('2018-07-25 12:45:16')->startOfMonth();\\n     * ```\\n     *\\n     * @return static\\n     *\/\\n    public function startOfMonth()\\n    {\\n        return $this->setDate($this->year, $this->month, 1)->startOfDay();\\n    }\\n\\n    \/**\\n     * Resets the date to end of the month and time to 23:59:59.999999\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::parse('2018-07-25 12:45:16')->endOfMonth();\\n     * ```\\n     *\\n     * @return static\\n     *\/\\n    public function endOfMonth()\\n    {\\n        return $this->setDate($this->year, $this->month, $this->daysInMonth)->endOfDay();\\n    }\\n\\n    \/**\\n     * Resets the date to the first day of the quarter and the time to 00:00:00\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::parse('2018-07-25 12:45:16')->startOfQuarter();\\n     * ```\\n     *\\n     * @return static\\n     *\/\\n    public function startOfQuarter()\\n    {\\n        $month = ($this->quarter - 1) * static::MONTHS_PER_QUARTER + 1;\\n\\n        return $this->setDate($this->year, $month, 1)->startOfDay();\\n    }\\n\\n    \/**\\n     * Resets the date to end of the quarter and time to 23:59:59.999999\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::parse('2018-07-25 12:45:16')->endOfQuarter();\\n     * ```\\n     *\\n     * @return static\\n     *\/\\n    public function endOfQuarter()\\n    {\\n        return $this->startOfQuarter()->addMonths(static::MONTHS_PER_QUARTER - 1)->endOfMonth();\\n    }\\n\\n    \/**\\n     * Resets the date to the first day of the year and the time to 00:00:00\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::parse('2018-07-25 12:45:16')->startOfYear();\\n     * ```\\n     *\\n     * @return static\\n     *\/\\n    public function startOfYear()\\n    {\\n        return $this->setDate($this->year, 1, 1)->startOfDay();\\n    }\\n\\n    \/**\\n     * Resets the date to end of the year and time to 23:59:59.999999\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::parse('2018-07-25 12:45:16')->endOfYear();\\n     * ```\\n     *\\n     * @return static\\n     *\/\\n    public function endOfYear()\\n    {\\n        return $this->setDate($this->year, 12, 31)->endOfDay();\\n    }\\n\\n    \/**\\n     * Resets the date to the first day of the decade and the time to 00:00:00\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::parse('2018-07-25 12:45:16')->startOfDecade();\\n     * ```\\n     *\\n     * @return static\\n     *\/\\n    public function startOfDecade()\\n    {\\n        $year = $this->year - $this->year % static::YEARS_PER_DECADE;\\n\\n        return $this->setDate($year, 1, 1)->startOfDay();\\n    }\\n\\n    \/**\\n     * Resets the date to end of the decade and time to 23:59:59.999999\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::parse('2018-07-25 12:45:16')->endOfDecade();\\n     * ```\\n     *\\n     * @return static\\n     *\/\\n    public function endOfDecade()\\n    {\\n        $year = $this->year - $this->year % static::YEARS_PER_DECADE + static::YEARS_PER_DECADE - 1;\\n\\n        return $this->setDate($year, 12, 31)->endOfDay();\\n    }\\n\\n    \/**\\n     * Resets the date to the first day of the century and the time to 00:00:00\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::parse('2018-07-25 12:45:16')->startOfCentury();\\n     * ```\\n     *\\n     * @return static\\n     *\/\\n    public function startOfCentury()\\n    {\\n        $year = $this->year - ($this->year - 1) % static::YEARS_PER_CENTURY;\\n\\n        return $this->setDate($year, 1, 1)->startOfDay();\\n    }\\n\\n    \/**\\n     * Resets the date to end of the century and time to 23:59:59.999999\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::parse('2018-07-25 12:45:16')->endOfCentury();\\n     * ```\\n     *\\n     * @return static\\n     *\/\\n    public function endOfCentury()\\n    {\\n        $year = $this->year - 1 - ($this->year - 1) % static::YEARS_PER_CENTURY + static::YEARS_PER_CENTURY;\\n\\n        return $this->setDate($year, 12, 31)->endOfDay();\\n    }\\n\\n    \/**\\n     * Resets the date to the first day of the millennium and the time to 00:00:00\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::parse('2018-07-25 12:45:16')->startOfMillennium();\\n     * ```\\n     *\\n     * @return static\\n     *\/\\n    public function startOfMillennium()\\n    {\\n        $year = $this->year - ($this->year - 1) % static::YEARS_PER_MILLENNIUM;\\n\\n        return $this->setDate($year, 1, 1)->startOfDay();\\n    }\\n\\n    \/**\\n     * Resets the date to end of the millennium and time to 23:59:59.999999\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::parse('2018-07-25 12:45:16')->endOfMillennium();\\n     * ```\\n     *\\n     * @return static\\n     *\/\\n    public function endOfMillennium()\\n    {\\n        $year = $this->year - 1 - ($this->year - 1) % static::YEARS_PER_MILLENNIUM + static::YEARS_PER_MILLENNIUM;\\n\\n        return $this->setDate($year, 12, 31)->endOfDay();\\n    }\\n\\n    \/**\\n     * Resets the date to the first day of week (defined in $weekStartsAt) and the time to 00:00:00\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::parse('2018-07-25 12:45:16')->startOfWeek() . \\\"\\\\n\\\";\\n     * echo Carbon::parse('2018-07-25 12:45:16')->locale('ar')->startOfWeek() . \\\"\\\\n\\\";\\n     * echo Carbon::parse('2018-07-25 12:45:16')->startOfWeek(Carbon::SUNDAY) . \\\"\\\\n\\\";\\n     * ```\\n     *\\n     * @param WeekDay|int|null $weekStartsAt optional start allow you to specify the day of week to use to start the week\\n     *\\n     * @return static\\n     *\/\\n    public function startOfWeek(WeekDay|int|null $weekStartsAt = null): static\\n    {\\n        return $this\\n            ->subDays(\\n                (static::DAYS_PER_WEEK + $this->dayOfWeek - (WeekDay::int($weekStartsAt) ?? $this->firstWeekDay)) %\\n                static::DAYS_PER_WEEK,\\n            )\\n            ->startOfDay();\\n    }\\n\\n    \/**\\n     * Resets the date to end of week (defined in $weekEndsAt) and time to 23:59:59.999999\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::parse('2018-07-25 12:45:16')->endOfWeek() . \\\"\\\\n\\\";\\n     * echo Carbon::parse('2018-07-25 12:45:16')->locale('ar')->endOfWeek() . \\\"\\\\n\\\";\\n     * echo Carbon::parse('2018-07-25 12:45:16')->endOfWeek(Carbon::SATURDAY) . \\\"\\\\n\\\";\\n     * ```\\n     *\\n     * @param WeekDay|int|null $weekEndsAt optional end allow you to specify the day of week to use to end the week\\n     *\\n     * @return static\\n     *\/\\n    public function endOfWeek(WeekDay|int|null $weekEndsAt = null): static\\n    {\\n        return $this\\n            ->addDays(\\n                (static::DAYS_PER_WEEK - $this->dayOfWeek + (WeekDay::int($weekEndsAt) ?? $this->lastWeekDay)) %\\n                static::DAYS_PER_WEEK,\\n            )\\n            ->endOfDay();\\n    }\\n\\n    \/**\\n     * Modify to start of current hour, minutes and seconds become 0\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::parse('2018-07-25 12:45:16')->startOfHour();\\n     * ```\\n     *\/\\n    public function startOfHour(): static\\n    {\\n        return $this->setTime($this->hour, 0, 0, 0);\\n    }\\n\\n    \/**\\n     * Modify to end of current hour, minutes and seconds become 59\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::parse('2018-07-25 12:45:16')->endOfHour();\\n     * ```\\n     *\/\\n    public function endOfHour(): static\\n    {\\n        return $this->setTime($this->hour, static::MINUTES_PER_HOUR - 1, static::SECONDS_PER_MINUTE - 1, static::MICROSECONDS_PER_SECOND - 1);\\n    }\\n\\n    \/**\\n     * Modify to start of current minute, seconds become 0\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::parse('2018-07-25 12:45:16')->startOfMinute();\\n     * ```\\n     *\/\\n    public function startOfMinute(): static\\n    {\\n        return $this->setTime($this->hour, $this->minute, 0, 0);\\n    }\\n\\n    \/**\\n     * Modify to end of current minute, seconds become 59\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::parse('2018-07-25 12:45:16')->endOfMinute();\\n     * ```\\n     *\/\\n    public function endOfMinute(): static\\n    {\\n        return $this->setTime($this->hour, $this->minute, static::SECONDS_PER_MINUTE - 1, static::MICROSECONDS_PER_SECOND - 1);\\n    }\\n\\n    \/**\\n     * Modify to start of current second, microseconds become 0\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::parse('2018-07-25 12:45:16.334455')\\n     *   ->startOfSecond()\\n     *   ->format('H:i:s.u');\\n     * ```\\n     *\/\\n    public function startOfSecond(): static\\n    {\\n        return $this->setTime($this->hour, $this->minute, $this->second, 0);\\n    }\\n\\n    \/**\\n     * Modify to end of current second, microseconds become 999999\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::parse('2018-07-25 12:45:16.334455')\\n     *   ->endOfSecond()\\n     *   ->format('H:i:s.u');\\n     * ```\\n     *\/\\n    public function endOfSecond(): static\\n    {\\n        return $this->setTime($this->hour, $this->minute, $this->second, static::MICROSECONDS_PER_SECOND - 1);\\n    }\\n\\n    \/**\\n     * Modify to start of current millisecond, microseconds such as 12345 become 123000\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::parse('2018-07-25 12:45:16.334455')\\n     *   ->startOfSecond()\\n     *   ->format('H:i:s.u');\\n     * ```\\n     *\/\\n    public function startOfMillisecond(): static\\n    {\\n        $millisecond = (int) floor($this->micro \/ 1000);\\n\\n        return $this->setTime($this->hour, $this->minute, $this->second, $millisecond * 1000);\\n    }\\n\\n    \/**\\n     * Modify to end of current millisecond, microseconds such as 12345 become 123999\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::parse('2018-07-25 12:45:16.334455')\\n     *   ->endOfSecond()\\n     *   ->format('H:i:s.u');\\n     * ```\\n     *\/\\n    public function endOfMillisecond(): static\\n    {\\n        $millisecond = (int) floor($this->micro \/ 1000);\\n\\n        return $this->setTime($this->hour, $this->minute, $this->second, $millisecond * 1000 + 999);\\n    }\\n\\n    \/**\\n     * Modify to start of current given unit.\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::parse('2018-07-25 12:45:16.334455')\\n     *   ->startOf(Unit::Month)\\n     *   ->endOf(Unit::Week, Carbon::FRIDAY);\\n     * ```\\n     *\/\\n    public function startOf(Unit|string $unit, mixed ...$params): static\\n    {\\n        $ucfUnit = ucfirst($unit instanceof Unit ? $unit->value : static::singularUnit($unit));\\n        $method = \\\"startOf$ucfUnit\\\";\\n        if (!method_exists($this, $method)) {\\n            throw new UnknownUnitException($unit);\\n        }\\n\\n        return $this->$method(...$params);\\n    }\\n\\n    \/**\\n     * Modify to end of current given unit.\\n     *\\n     * @example\\n     * ```\\n     * echo Carbon::parse('2018-07-25 12:45:16.334455')\\n     *   ->startOf(Unit::Month)\\n     *   ->endOf(Unit::Week, Carbon::FRIDAY);\\n     * ```\\n     *\/\\n    public function endOf(Unit|string $unit, mixed ...$params): static\\n    {\\n        $ucfUnit = ucfirst($unit instanceof Unit ? $unit->value : static::singularUnit($unit));\\n        $method = \\\"endOf$ucfUnit\\\";\\n        if (!method_exists($this, $method)) {\\n            throw new UnknownUnitException($unit);\\n        }\\n\\n        return $this->$method(...$params);\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Factory.php\",\"ext\":\"php\",\"size\":45591,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon;\\n\\nuse Closure;\\nuse DateTimeImmutable;\\nuse DateTimeInterface;\\nuse DateTimeZone;\\nuse InvalidArgumentException;\\nuse ReflectionMethod;\\nuse RuntimeException;\\nuse Symfony\\\\Contracts\\\\Translation\\\\TranslatorInterface;\\nuse Throwable;\\n\\n\/**\\n * A factory to generate Carbon instances with common settings.\\n *\\n * <autodoc generated by `composer phpdoc`>\\n *\\n * @method bool                canBeCreatedFromFormat(?string $date, string $format)                                                                                Checks if the (date)time string is in a given format and valid to create a\\n *                                                                                                                                                                  new instance.\\n * @method ?Carbon             create($year = 0, $month = 1, $day = 1, $hour = 0, $minute = 0, $second = 0, $timezone = null)                                       Create a new Carbon instance from a specific date and time.\\n *                                                                                                                                                                  If any of $year, $month or $day are set to null their now() values will\\n *                                                                                                                                                                  be used.\\n *                                                                                                                                                                  If $hour is null it will be set to its now() value and the default\\n *                                                                                                                                                                  values for $minute and $second will be their now() values.\\n *                                                                                                                                                                  If $hour is not null then the default values for $minute and $second\\n *                                                                                                                                                                  will be 0.\\n * @method Carbon              createFromDate($year = null, $month = null, $day = null, $timezone = null)                                                           Create a Carbon instance from just a date. The time portion is set to now.\\n * @method ?Carbon             createFromFormat($format, $time, $timezone = null)                                                                                   Create a Carbon instance from a specific format.\\n * @method ?Carbon             createFromIsoFormat(string $format, string $time, $timezone = null, ?string $locale = 'en', ?TranslatorInterface $translator = null) Create a Carbon instance from a specific ISO format (same replacements as ->isoFormat()).\\n * @method ?Carbon             createFromLocaleFormat(string $format, string $locale, string $time, $timezone = null)                                               Create a Carbon instance from a specific format and a string in a given language.\\n * @method ?Carbon             createFromLocaleIsoFormat(string $format, string $locale, string $time, $timezone = null)                                            Create a Carbon instance from a specific ISO format and a string in a given language.\\n * @method Carbon              createFromTime($hour = 0, $minute = 0, $second = 0, $timezone = null)                                                                Create a Carbon instance from just a time. The date portion is set to today.\\n * @method Carbon              createFromTimeString(string $time, DateTimeZone|string|int|null $timezone = null)                                                    Create a Carbon instance from a time string. The date portion is set to today.\\n * @method Carbon              createFromTimestamp(string|int|float $timestamp, DateTimeZone|string|int|null $timezone = null)                                      Create a Carbon instance from a timestamp and set the timezone (UTC by default).\\n *                                                                                                                                                                  Timestamp input can be given as int, float or a string containing one or more numbers.\\n * @method Carbon              createFromTimestampMs(string|int|float $timestamp, DateTimeZone|string|int|null $timezone = null)                                    Create a Carbon instance from a timestamp in milliseconds.\\n *                                                                                                                                                                  Timestamp input can be given as int, float or a string containing one or more numbers.\\n * @method Carbon              createFromTimestampMsUTC($timestamp)                                                                                                 Create a Carbon instance from a timestamp in milliseconds.\\n *                                                                                                                                                                  Timestamp input can be given as int, float or a string containing one or more numbers.\\n * @method Carbon              createFromTimestampUTC(string|int|float $timestamp)                                                                                  Create a Carbon instance from a timestamp keeping the timezone to UTC.\\n *                                                                                                                                                                  Timestamp input can be given as int, float or a string containing one or more numbers.\\n * @method Carbon              createMidnightDate($year = null, $month = null, $day = null, $timezone = null)                                                       Create a Carbon instance from just a date. The time portion is set to midnight.\\n * @method ?Carbon             createSafe($year = null, $month = null, $day = null, $hour = null, $minute = null, $second = null, $timezone = null)                 Create a new safe Carbon instance from a specific date and time.\\n *                                                                                                                                                                  If any of $year, $month or $day are set to null their now() values will\\n *                                                                                                                                                                  be used.\\n *                                                                                                                                                                  If $hour is null it will be set to its now() value and the default\\n *                                                                                                                                                                  values for $minute and $second will be their now() values.\\n *                                                                                                                                                                  If $hour is not null then the default values for $minute and $second\\n *                                                                                                                                                                  will be 0.\\n *                                                                                                                                                                  If one of the set values is not valid, an InvalidDateException\\n *                                                                                                                                                                  will be thrown.\\n * @method Carbon              createStrict(?int $year = 0, ?int $month = 1, ?int $day = 1, ?int $hour = 0, ?int $minute = 0, ?int $second = 0, $timezone = null)   Create a new Carbon instance from a specific date and time using strict validation.\\n * @method mixed               executeWithLocale(string $locale, callable $func)                                                                                    Set the current locale to the given, execute the passed function, reset the locale to previous one,\\n *                                                                                                                                                                  then return the result of the closure (or null if the closure was void).\\n * @method Carbon              fromSerialized($value)                                                                                                               Create an instance from a serialized string.\\n * @method array               getAvailableLocales()                                                                                                                Returns the list of internally available locales and already loaded custom locales.\\n *                                                                                                                                                                  (It will ignore custom translator dynamic loading.)\\n * @method Language[]          getAvailableLocalesInfo()                                                                                                            Returns list of Language object for each available locale. This object allow you to get the ISO name, native\\n *                                                                                                                                                                  name, region and variant of the locale.\\n * @method array               getDays()                                                                                                                            Get the days of the week.\\n * @method ?string             getFallbackLocale()                                                                                                                  Get the fallback locale.\\n * @method array               getFormatsToIsoReplacements()                                                                                                        List of replacements from date() format to isoFormat().\\n * @method array               getIsoUnits()                                                                                                                        Returns list of locale units for ISO formatting.\\n * @method array|false         getLastErrors()                                                                                                                      {@inheritdoc}\\n * @method string              getLocale()                                                                                                                          Get the current translator locale.\\n * @method int                 getMidDayAt()                                                                                                                        get midday\/noon hour\\n * @method string              getTimeFormatByPrecision(string $unitPrecision)                                                                                      Return a format from H:i to H:i:s.u according to given unit precision.\\n * @method string|Closure|null getTranslationMessageWith($translator, string $key, ?string $locale = null, ?string $default = null)                                 Returns raw translation message for a given key.\\n * @method int                 getWeekEndsAt(?string $locale = null)                                                                                                Get the last day of week.\\n * @method int                 getWeekStartsAt(?string $locale = null)                                                                                              Get the first day of week.\\n * @method bool                hasRelativeKeywords(?string $time)                                                                                                   Determine if a time string will produce a relative date.\\n * @method Carbon              instance(DateTimeInterface $date)                                                                                                    Create a Carbon instance from a DateTime one.\\n * @method bool                isImmutable()                                                                                                                        Returns true if the current class\/instance is immutable.\\n * @method bool                isModifiableUnit($unit)                                                                                                              Returns true if a property can be changed via setter.\\n * @method bool                isMutable()                                                                                                                          Returns true if the current class\/instance is mutable.\\n * @method bool                localeHasDiffOneDayWords(string $locale)                                                                                             Returns true if the given locale is internally supported and has words for 1-day diff (just now, yesterday, tomorrow).\\n *                                                                                                                                                                  Support is considered enabled if the 3 words are translated in the given locale.\\n * @method bool                localeHasDiffSyntax(string $locale)                                                                                                  Returns true if the given locale is internally supported and has diff syntax support (ago, from now, before, after).\\n *                                                                                                                                                                  Support is considered enabled if the 4 sentences are translated in the given locale.\\n * @method bool                localeHasDiffTwoDayWords(string $locale)                                                                                             Returns true if the given locale is internally supported and has words for 2-days diff (before yesterday, after tomorrow).\\n *                                                                                                                                                                  Support is considered enabled if the 2 words are translated in the given locale.\\n * @method bool                localeHasPeriodSyntax($locale)                                                                                                       Returns true if the given locale is internally supported and has period syntax support (X times, every X, from X, to X).\\n *                                                                                                                                                                  Support is considered enabled if the 4 sentences are translated in the given locale.\\n * @method bool                localeHasShortUnits(string $locale)                                                                                                  Returns true if the given locale is internally supported and has short-units support.\\n *                                                                                                                                                                  Support is considered enabled if either year, day or hour has a short variant translated.\\n * @method ?Carbon             make($var, DateTimeZone|string|null $timezone = null)                                                                                Make a Carbon instance from given variable if possible.\\n *                                                                                                                                                                  Always return a new instance. Parse only strings and only these likely to be dates (skip intervals\\n *                                                                                                                                                                  and recurrences). Throw an exception for invalid format, but otherwise return null.\\n * @method void                mixin(object|string $mixin)                                                                                                          Mix another object into the class.\\n * @method Carbon              now(DateTimeZone|string|int|null $timezone = null)                                                                                   Get a Carbon instance for the current date and time.\\n * @method Carbon              parse(DateTimeInterface|WeekDay|Month|string|int|float|null $time, DateTimeZone|string|int|null $timezone = null)                    Create a carbon instance from a string.\\n *                                                                                                                                                                  This is an alias for the constructor that allows better fluent syntax\\n *                                                                                                                                                                  as it allows you to do Carbon::parse('Monday next week')->fn() rather\\n *                                                                                                                                                                  than (new Carbon('Monday next week'))->fn().\\n * @method Carbon              parseFromLocale(string $time, ?string $locale = null, DateTimeZone|string|int|null $timezone = null)                                 Create a carbon instance from a localized string (in French, Japanese, Arabic, etc.).\\n * @method string              pluralUnit(string $unit)                                                                                                             Returns standardized plural of a given singular\/plural unit name (in English).\\n * @method ?Carbon             rawCreateFromFormat(string $format, string $time, $timezone = null)                                                                  Create a Carbon instance from a specific format.\\n * @method Carbon              rawParse(DateTimeInterface|WeekDay|Month|string|int|float|null $time, DateTimeZone|string|int|null $timezone = null)                 Create a carbon instance from a string.\\n *                                                                                                                                                                  This is an alias for the constructor that allows better fluent syntax\\n *                                                                                                                                                                  as it allows you to do Carbon::parse('Monday next week')->fn() rather\\n *                                                                                                                                                                  than (new Carbon('Monday next week'))->fn().\\n * @method void                setFallbackLocale(string $locale)                                                                                                    Set the fallback locale.\\n * @method void                setLocale(string $locale)                                                                                                            Set the current translator locale and indicate if the source locale file exists.\\n *                                                                                                                                                                  Pass 'auto' as locale to use the closest language to the current LC_TIME locale.\\n * @method void                setMidDayAt($hour)                                                                                                                   @deprecated To avoid conflict between different third-party libraries, static setters should not be used.\\n *                                                                                                                                                                              You should rather consider mid-day is always 12pm, then if you need to test if it's an other\\n *                                                                                                                                                                              hour, test it explicitly:\\n *                                                                                                                                                                                  $date->format('G') == 13\\n *                                                                                                                                                                              or to set explicitly to a given hour:\\n *                                                                                                                                                                                  $date->setTime(13, 0, 0, 0)\\n *                                                                                                                                                                  Set midday\/noon hour\\n * @method string              singularUnit(string $unit)                                                                                                           Returns standardized singular of a given singular\/plural unit name (in English).\\n * @method void                sleep(int|float $seconds)\\n * @method Carbon              today(DateTimeZone|string|int|null $timezone = null)                                                                                 Create a Carbon instance for today.\\n * @method Carbon              tomorrow(DateTimeZone|string|int|null $timezone = null)                                                                              Create a Carbon instance for tomorrow.\\n * @method string              translateTimeString(string $timeString, ?string $from = null, ?string $to = null, int $mode = CarbonInterface::TRANSLATE_ALL)        Translate a time string from a locale to an other.\\n * @method string              translateWith(TranslatorInterface $translator, string $key, array $parameters = [], $number = null)                                  Translate using translation string or callback available.\\n * @method Carbon              yesterday(DateTimeZone|string|int|null $timezone = null)                                                                             Create a Carbon instance for yesterday.\\n *\\n * <\/autodoc>\\n *\/\\nclass Factory\\n{\\n    protected string $className = Carbon::class;\\n\\n    protected array $settings = [];\\n\\n    \/**\\n     * A test Carbon instance to be returned when now instances are created.\\n     *\/\\n    protected Closure|CarbonInterface|null $testNow = null;\\n\\n    \/**\\n     * The timezone to restore to when clearing the time mock.\\n     *\/\\n    protected ?string $testDefaultTimezone = null;\\n\\n    \/**\\n     * Is true when test-now is generated by a closure and timezone should be taken on the fly from it.\\n     *\/\\n    protected bool $useTimezoneFromTestNow = false;\\n\\n    \/**\\n     * Default translator.\\n     *\/\\n    protected TranslatorInterface $translator;\\n\\n    \/**\\n     * Days of weekend.\\n     *\/\\n    protected array $weekendDays = [\\n        CarbonInterface::SATURDAY,\\n        CarbonInterface::SUNDAY,\\n    ];\\n\\n    \/**\\n     * Format regex patterns.\\n     *\\n     * @var array<string, string>\\n     *\/\\n    protected array $regexFormats = [\\n        'd' => '(3[01]|[12][0-9]|0[1-9])',\\n        'D' => '(Sun|Mon|Tue|Wed|Thu|Fri|Sat)',\\n        'j' => '([123][0-9]|[1-9])',\\n        'l' => '([a-zA-Z]{2,})',\\n        'N' => '([1-7])',\\n        'S' => '(st|nd|rd|th)',\\n        'w' => '([0-6])',\\n        'z' => '(36[0-5]|3[0-5][0-9]|[12][0-9]{2}|[1-9]?[0-9])',\\n        'W' => '(5[012]|[1-4][0-9]|0?[1-9])',\\n        'F' => '([a-zA-Z]{2,})',\\n        'm' => '(1[012]|0[1-9])',\\n        'M' => '([a-zA-Z]{3})',\\n        'n' => '(1[012]|[1-9])',\\n        't' => '(2[89]|3[01])',\\n        'L' => '(0|1)',\\n        'o' => '([1-9][0-9]{0,4})',\\n        'Y' => '([1-9]?[0-9]{4})',\\n        'y' => '([0-9]{2})',\\n        'a' => '(am|pm)',\\n        'A' => '(AM|PM)',\\n        'B' => '([0-9]{3})',\\n        'g' => '(1[012]|[1-9])',\\n        'G' => '(2[0-3]|1?[0-9])',\\n        'h' => '(1[012]|0[1-9])',\\n        'H' => '(2[0-3]|[01][0-9])',\\n        'i' => '([0-5][0-9])',\\n        's' => '([0-5][0-9])',\\n        'u' => '([0-9]{1,6})',\\n        'v' => '([0-9]{1,3})',\\n        'e' => '([a-zA-Z]{1,5})|([a-zA-Z]*\\\\\\\\\/[a-zA-Z]*)',\\n        'I' => '(0|1)',\\n        'O' => '([+-](1[0123]|0[0-9])[0134][05])',\\n        'P' => '([+-](1[0123]|0[0-9]):[0134][05])',\\n        'p' => '(Z|[+-](1[0123]|0[0-9]):[0134][05])',\\n        'T' => '([a-zA-Z]{1,5})',\\n        'Z' => '(-?[1-5]?[0-9]{1,4})',\\n        'U' => '([0-9]*)',\\n\\n        \/\/ The formats below are combinations of the above formats.\\n        'c' => '(([1-9]?[0-9]{4})-(1[012]|0[1-9])-(3[01]|[12][0-9]|0[1-9])T(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])[+-](1[012]|0[0-9]):([0134][05]))', \/\/ Y-m-dTH:i:sP\\n        'r' => '(([a-zA-Z]{3}), ([123][0-9]|0[1-9]) ([a-zA-Z]{3}) ([1-9]?[0-9]{4}) (2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9]) [+-](1[012]|0[0-9])([0134][05]))', \/\/ D, d M Y H:i:s O\\n    ];\\n\\n    \/**\\n     * Format modifiers (such as available in createFromFormat) regex patterns.\\n     *\\n     * @var array\\n     *\/\\n    protected array $regexFormatModifiers = [\\n        '*' => '.+',\\n        ' ' => '[   ]',\\n        '#' => '[;:\\\\\\\\\/.,()-]',\\n        '?' => '([^a]|[a])',\\n        '!' => '',\\n        '|' => '',\\n        '+' => '',\\n    ];\\n\\n    public function __construct(array $settings = [], ?string $className = null)\\n    {\\n        if ($className) {\\n            $this->className = $className;\\n        }\\n\\n        $this->settings = $settings;\\n    }\\n\\n    public function getClassName(): string\\n    {\\n        return $this->className;\\n    }\\n\\n    public function setClassName(string $className): self\\n    {\\n        $this->className = $className;\\n\\n        return $this;\\n    }\\n\\n    public function className(?string $className = null): self|string\\n    {\\n        return $className === null ? $this->getClassName() : $this->setClassName($className);\\n    }\\n\\n    public function getSettings(): array\\n    {\\n        return $this->settings;\\n    }\\n\\n    public function setSettings(array $settings): self\\n    {\\n        $this->settings = $settings;\\n\\n        return $this;\\n    }\\n\\n    public function settings(?array $settings = null): self|array\\n    {\\n        return $settings === null ? $this->getSettings() : $this->setSettings($settings);\\n    }\\n\\n    public function mergeSettings(array $settings): self\\n    {\\n        $this->settings = array_merge($this->settings, $settings);\\n\\n        return $this;\\n    }\\n\\n    public function setHumanDiffOptions(int $humanDiffOptions): void\\n    {\\n        $this->mergeSettings([\\n            'humanDiffOptions' => $humanDiffOptions,\\n        ]);\\n    }\\n\\n    public function enableHumanDiffOption($humanDiffOption): void\\n    {\\n        $this->setHumanDiffOptions($this->getHumanDiffOptions() | $humanDiffOption);\\n    }\\n\\n    public function disableHumanDiffOption(int $humanDiffOption): void\\n    {\\n        $this->setHumanDiffOptions($this->getHumanDiffOptions() & ~$humanDiffOption);\\n    }\\n\\n    public function getHumanDiffOptions(): int\\n    {\\n        return (int) ($this->getSettings()['humanDiffOptions'] ?? 0);\\n    }\\n\\n    \/**\\n     * Register a custom macro.\\n     *\\n     * Pass null macro to remove it.\\n     *\\n     * @example\\n     * ```\\n     * $userSettings = [\\n     *   'locale' => 'pt',\\n     *   'timezone' => 'America\/Sao_Paulo',\\n     * ];\\n     * $factory->macro('userFormat', function () use ($userSettings) {\\n     *   return $this->copy()->locale($userSettings['locale'])->tz($userSettings['timezone'])->calendar();\\n     * });\\n     * echo $factory->yesterday()->hours(11)->userFormat();\\n     * ```\\n     *\\n     * @param-closure-this  static  $macro\\n     *\/\\n    public function macro(string $name, ?callable $macro): void\\n    {\\n        $macros = $this->getSettings()['macros'] ?? [];\\n        $macros[$name] = $macro;\\n\\n        $this->mergeSettings([\\n            'macros' => $macros,\\n        ]);\\n    }\\n\\n    \/**\\n     * Remove all macros and generic macros.\\n     *\/\\n    public function resetMacros(): void\\n    {\\n        $this->mergeSettings([\\n            'macros' => null,\\n            'genericMacros' => null,\\n        ]);\\n    }\\n\\n    \/**\\n     * Register a custom macro.\\n     *\\n     * @param callable $macro\\n     * @param int      $priority marco with higher priority is tried first\\n     *\\n     * @return void\\n     *\/\\n    public function genericMacro(callable $macro, int $priority = 0): void\\n    {\\n        $genericMacros = $this->getSettings()['genericMacros'] ?? [];\\n\\n        if (!isset($genericMacros[$priority])) {\\n            $genericMacros[$priority] = [];\\n            krsort($genericMacros, SORT_NUMERIC);\\n        }\\n\\n        $genericMacros[$priority][] = $macro;\\n\\n        $this->mergeSettings([\\n            'genericMacros' => $genericMacros,\\n        ]);\\n    }\\n\\n    \/**\\n     * Checks if macro is registered globally.\\n     *\/\\n    public function hasMacro(string $name): bool\\n    {\\n        return isset($this->getSettings()['macros'][$name]);\\n    }\\n\\n    \/**\\n     * Get the raw callable macro registered globally for a given name.\\n     *\/\\n    public function getMacro(string $name): ?callable\\n    {\\n        return $this->getSettings()['macros'][$name] ?? null;\\n    }\\n\\n    \/**\\n     * Set the default translator instance to use.\\n     *\/\\n    public function setTranslator(TranslatorInterface $translator): void\\n    {\\n        $this->translator = $translator;\\n    }\\n\\n    \/**\\n     * Initialize the default translator instance if necessary.\\n     *\/\\n    public function getTranslator(): TranslatorInterface\\n    {\\n        return $this->translator ??= Translator::get();\\n    }\\n\\n    \/**\\n     * Reset the format used to the default when type juggling a Carbon instance to a string\\n     *\\n     * @return void\\n     *\/\\n    public function resetToStringFormat(): void\\n    {\\n        $this->setToStringFormat(null);\\n    }\\n\\n    \/**\\n     * Set the default format used when type juggling a Carbon instance to a string.\\n     *\/\\n    public function setToStringFormat(string|Closure|null $format): void\\n    {\\n        $this->mergeSettings([\\n            'toStringFormat' => $format,\\n        ]);\\n    }\\n\\n    \/**\\n     * JSON serialize all Carbon instances using the given callback.\\n     *\/\\n    public function serializeUsing(string|callable|null $format): void\\n    {\\n        $this->mergeSettings([\\n            'toJsonFormat' => $format,\\n        ]);\\n    }\\n\\n    \/**\\n     * Enable the strict mode (or disable with passing false).\\n     *\/\\n    public function useStrictMode(bool $strictModeEnabled = true): void\\n    {\\n        $this->mergeSettings([\\n            'strictMode' => $strictModeEnabled,\\n        ]);\\n    }\\n\\n    \/**\\n     * Returns true if the strict mode is globally in use, false else.\\n     * (It can be overridden in specific instances.)\\n     *\/\\n    public function isStrictModeEnabled(): bool\\n    {\\n        return $this->getSettings()['strictMode'] ?? true;\\n    }\\n\\n    \/**\\n     * Indicates if months should be calculated with overflow.\\n     *\/\\n    public function useMonthsOverflow(bool $monthsOverflow = true): void\\n    {\\n        $this->mergeSettings([\\n            'monthOverflow' => $monthsOverflow,\\n        ]);\\n    }\\n\\n    \/**\\n     * Reset the month overflow behavior.\\n     *\/\\n    public function resetMonthsOverflow(): void\\n    {\\n        $this->useMonthsOverflow();\\n    }\\n\\n    \/**\\n     * Get the month overflow global behavior (can be overridden in specific instances).\\n     *\/\\n    public function shouldOverflowMonths(): bool\\n    {\\n        return $this->getSettings()['monthOverflow'] ?? true;\\n    }\\n\\n    \/**\\n     * Indicates if years should be calculated with overflow.\\n     *\/\\n    public function useYearsOverflow(bool $yearsOverflow = true): void\\n    {\\n        $this->mergeSettings([\\n            'yearOverflow' => $yearsOverflow,\\n        ]);\\n    }\\n\\n    \/**\\n     * Reset the month overflow behavior.\\n     *\/\\n    public function resetYearsOverflow(): void\\n    {\\n        $this->useYearsOverflow();\\n    }\\n\\n    \/**\\n     * Get the month overflow global behavior (can be overridden in specific instances).\\n     *\/\\n    public function shouldOverflowYears(): bool\\n    {\\n        return $this->getSettings()['yearOverflow'] ?? true;\\n    }\\n\\n    \/**\\n     * Get weekend days\\n     *\\n     * @return array\\n     *\/\\n    public function getWeekendDays(): array\\n    {\\n        return $this->weekendDays;\\n    }\\n\\n    \/**\\n     * Set weekend days\\n     *\/\\n    public function setWeekendDays(array $days): void\\n    {\\n        $this->weekendDays = $days;\\n    }\\n\\n    \/**\\n     * Checks if the (date)time string is in a given format.\\n     *\\n     * @example\\n     * ```\\n     * Carbon::hasFormat('11:12:45', 'h:i:s'); \/\/ true\\n     * Carbon::hasFormat('13:12:45', 'h:i:s'); \/\/ false\\n     * ```\\n     *\/\\n    public function hasFormat(string $date, string $format): bool\\n    {\\n        \/\/ createFromFormat() is known to handle edge cases silently.\\n        \/\/ E.g. \\\"1975-5-1\\\" (Y-n-j) will still be parsed correctly when \\\"Y-m-d\\\" is supplied as the format.\\n        \/\/ To ensure we're really testing against our desired format, perform an additional regex validation.\\n\\n        return $this->matchFormatPattern($date, preg_quote($format, '\/'), $this->regexFormats);\\n    }\\n\\n    \/**\\n     * Checks if the (date)time string is in a given format.\\n     *\\n     * @example\\n     * ```\\n     * Carbon::hasFormatWithModifiers('31\/08\/2015', 'd#m#Y'); \/\/ true\\n     * Carbon::hasFormatWithModifiers('31\/08\/2015', 'm#d#Y'); \/\/ false\\n     * ```\\n     *\/\\n    public function hasFormatWithModifiers(string $date, string $format): bool\\n    {\\n        return $this->matchFormatPattern($date, $format, array_merge($this->regexFormats, $this->regexFormatModifiers));\\n    }\\n\\n    \/**\\n     * Set a Carbon instance (real or mock) to be returned when a \\\"now\\\"\\n     * instance is created.  The provided instance will be returned\\n     * specifically under the following conditions:\\n     *   - A call to the static now() method, ex. Carbon::now()\\n     *   - When a null (or blank string) is passed to the constructor or parse(), ex. new Carbon(null)\\n     *   - When the string \\\"now\\\" is passed to the constructor or parse(), ex. new Carbon('now')\\n     *   - When a string containing the desired time is passed to Carbon::parse().\\n     *\\n     * Note the timezone parameter was left out of the examples above and\\n     * has no affect as the mock value will be returned regardless of its value.\\n     *\\n     * Only the moment is mocked with setTestNow(), the timezone will still be the one passed\\n     * as parameter of date_default_timezone_get() as a fallback (see setTestNowAndTimezone()).\\n     *\\n     * To clear the test instance call this method using the default\\n     * parameter of null.\\n     *\\n     * \/!\\\\ Use this method for unit tests only.\\n     *\\n     * @param DateTimeInterface|Closure|static|string|false|null $testNow real or mock Carbon instance\\n     *\/\\n    public function setTestNow(mixed $testNow = null): void\\n    {\\n        $this->useTimezoneFromTestNow = false;\\n        $this->testNow = $testNow instanceof self || $testNow instanceof Closure\\n            ? $testNow\\n            : $this->make($testNow);\\n    }\\n\\n    \/**\\n     * Set a Carbon instance (real or mock) to be returned when a \\\"now\\\"\\n     * instance is created.  The provided instance will be returned\\n     * specifically under the following conditions:\\n     *   - A call to the static now() method, ex. Carbon::now()\\n     *   - When a null (or blank string) is passed to the constructor or parse(), ex. new Carbon(null)\\n     *   - When the string \\\"now\\\" is passed to the constructor or parse(), ex. new Carbon('now')\\n     *   - When a string containing the desired time is passed to Carbon::parse().\\n     *\\n     * It will also align default timezone (e.g. call date_default_timezone_set()) with\\n     * the second argument or if null, with the timezone of the given date object.\\n     *\\n     * To clear the test instance call this method using the default\\n     * parameter of null.\\n     *\\n     * \/!\\\\ Use this method for unit tests only.\\n     *\\n     * @param DateTimeInterface|Closure|static|string|false|null $testNow real or mock Carbon instance\\n     *\/\\n    public function setTestNowAndTimezone(mixed $testNow = null, $timezone = null): void\\n    {\\n        if ($testNow) {\\n            $this->testDefaultTimezone ??= date_default_timezone_get();\\n        }\\n\\n        $useDateInstanceTimezone = $testNow instanceof DateTimeInterface;\\n\\n        if ($useDateInstanceTimezone) {\\n            $this->setDefaultTimezone($testNow->getTimezone()->getName(), $testNow);\\n        }\\n\\n        $this->setTestNow($testNow);\\n        $this->useTimezoneFromTestNow = ($timezone === null && $testNow instanceof Closure);\\n\\n        if (!$useDateInstanceTimezone) {\\n            $now = $this->getMockedTestNow(\\\\func_num_args() === 1 ? null : $timezone);\\n            $this->setDefaultTimezone($now?->tzName ?? $this->testDefaultTimezone ?? 'UTC', $now);\\n        }\\n\\n        if (!$testNow) {\\n            $this->testDefaultTimezone = null;\\n        }\\n    }\\n\\n    \/**\\n     * Temporarily sets a static date to be used within the callback.\\n     * Using setTestNow to set the date, executing the callback, then\\n     * clearing the test instance.\\n     *\\n     * \/!\\\\ Use this method for unit tests only.\\n     *\\n     * @template T\\n     *\\n     * @param DateTimeInterface|Closure|static|string|false|null $testNow  real or mock Carbon instance\\n     * @param Closure(): T                                       $callback\\n     *\\n     * @return T\\n     *\/\\n    public function withTestNow(mixed $testNow, callable $callback): mixed\\n    {\\n        $this->setTestNow($testNow);\\n\\n        try {\\n            $result = $callback();\\n        } finally {\\n            $this->setTestNow();\\n        }\\n\\n        return $result;\\n    }\\n\\n    \/**\\n     * Get the Carbon instance (real or mock) to be returned when a \\\"now\\\"\\n     * instance is created.\\n     *\\n     * @return Closure|CarbonInterface|null the current instance used for testing\\n     *\/\\n    public function getTestNow(): Closure|CarbonInterface|null\\n    {\\n        if ($this->testNow === null) {\\n            $factory = FactoryImmutable::getDefaultInstance();\\n\\n            if ($factory !== $this) {\\n                return $factory->getTestNow();\\n            }\\n        }\\n\\n        return $this->testNow;\\n    }\\n\\n    public function handleTestNowClosure(\\n        Closure|CarbonInterface|null $testNow,\\n        DateTimeZone|string|int|null $timezone = null,\\n    ): ?CarbonInterface {\\n        if ($testNow instanceof Closure) {\\n            $callback = Callback::fromClosure($testNow);\\n            $realNow = new DateTimeImmutable('now');\\n            $testNow = $testNow($callback->prepareParameter($this->parse(\\n                $realNow->format('Y-m-d H:i:s.u'),\\n                $timezone ?? $realNow->getTimezone(),\\n            )));\\n\\n            if ($testNow !== null && !($testNow instanceof DateTimeInterface)) {\\n                $function = $callback->getReflectionFunction();\\n                $type = \\\\is_object($testNow) ? $testNow::class : \\\\gettype($testNow);\\n\\n                throw new RuntimeException(\\n                    'The test closure defined in '.$function->getFileName().\\n                    ' at line '.$function->getStartLine().' returned '.$type.\\n                    '; expected '.CarbonInterface::class.'|null',\\n                );\\n            }\\n\\n            if (!($testNow instanceof CarbonInterface)) {\\n                $timezone ??= $this->useTimezoneFromTestNow ? $testNow->getTimezone() : null;\\n                $testNow = $this->__call('instance', [$testNow, $timezone]);\\n            }\\n        }\\n\\n        return $testNow;\\n    }\\n\\n    \/**\\n     * Determine if there is a valid test instance set. A valid test instance\\n     * is anything that is not null.\\n     *\\n     * @return bool true if there is a test instance, otherwise false\\n     *\/\\n    public function hasTestNow(): bool\\n    {\\n        return $this->getTestNow() !== null;\\n    }\\n\\n    public function withTimeZone(DateTimeZone|string|int|null $timezone): static\\n    {\\n        $factory = clone $this;\\n        $factory->settings['timezone'] = $timezone;\\n\\n        return $factory;\\n    }\\n\\n    public function __call(string $name, array $arguments): mixed\\n    {\\n        $method = new ReflectionMethod($this->className, $name);\\n        $settings = $this->settings;\\n\\n        if ($settings && isset($settings['timezone'])) {\\n            $timezoneParameters = array_filter($method->getParameters(), function ($parameter) {\\n                return \\\\in_array($parameter->getName(), ['tz', 'timezone'], true);\\n            });\\n            $timezoneSetting = $settings['timezone'];\\n\\n            if (isset($arguments[0]) && \\\\in_array($name, ['instance', 'make', 'create', 'parse'], true)) {\\n                if ($arguments[0] instanceof DateTimeInterface) {\\n                    $settings['innerTimezone'] = $settings['timezone'];\\n                } elseif (\\\\is_string($arguments[0]) && date_parse($arguments[0])['is_localtime']) {\\n                    unset($settings['timezone'], $settings['innerTimezone']);\\n                }\\n            }\\n\\n            if (\\\\count($timezoneParameters)) {\\n                $index = key($timezoneParameters);\\n\\n                if (!isset($arguments[$index])) {\\n                    array_splice($arguments, key($timezoneParameters), 0, [$timezoneSetting]);\\n                }\\n\\n                unset($settings['timezone']);\\n            }\\n        }\\n\\n        $clock = FactoryImmutable::getCurrentClock();\\n        FactoryImmutable::setCurrentClock($this);\\n\\n        try {\\n            $result = $this->className::$name(...$arguments);\\n        } finally {\\n            FactoryImmutable::setCurrentClock($clock);\\n        }\\n\\n        if (isset($this->translator)) {\\n            $settings['translator'] = $this->translator;\\n        }\\n\\n        return $result instanceof CarbonInterface && !empty($settings)\\n            ? $result->settings($settings)\\n            : $result;\\n    }\\n\\n    \/**\\n     * Get the mocked date passed in setTestNow() and if it's a Closure, execute it.\\n     *\/\\n    protected function getMockedTestNow(DateTimeZone|string|int|null $timezone): ?CarbonInterface\\n    {\\n        $testNow = $this->handleTestNowClosure($this->getTestNow());\\n\\n        if ($testNow instanceof CarbonInterface) {\\n            $testNow = $testNow->avoidMutation();\\n\\n            if ($timezone !== null) {\\n                return $testNow->setTimezone($timezone);\\n            }\\n        }\\n\\n        return $testNow;\\n    }\\n\\n    \/**\\n     * Checks if the (date)time string is in a given format with\\n     * given list of pattern replacements.\\n     *\\n     * @example\\n     * ```\\n     * Carbon::hasFormat('11:12:45', 'h:i:s'); \/\/ true\\n     * Carbon::hasFormat('13:12:45', 'h:i:s'); \/\/ false\\n     * ```\\n     *\\n     * @param string $date\\n     * @param string $format\\n     * @param array  $replacements\\n     *\\n     * @return bool\\n     *\/\\n    private function matchFormatPattern(string $date, string $format, array $replacements): bool\\n    {\\n        \/\/ Preg quote, but remove escaped backslashes since we'll deal with escaped characters in the format string.\\n        $regex = str_replace('\\\\\\\\\\\\\\\\', '\\\\\\\\', $format);\\n        \/\/ Replace not-escaped letters\\n        $regex = preg_replace_callback(\\n            '\/(?<!\\\\\\\\\\\\\\\\)((?:\\\\\\\\\\\\\\\\{2})*)(['.implode('', array_keys($replacements)).'])\/',\\n            static fn ($match) => $match[1].strtr($match[2], $replacements),\\n            $regex,\\n        );\\n        \/\/ Replace escaped letters by the letter itself\\n        $regex = preg_replace('\/(?<!\\\\\\\\\\\\\\\\)((?:\\\\\\\\\\\\\\\\{2})*)\\\\\\\\\\\\\\\\(\\\\w)\/', '$1$2', $regex);\\n        \/\/ Escape not escaped slashes\\n        $regex = preg_replace('#(?<!\\\\\\\\\\\\\\\\)((?:\\\\\\\\\\\\\\\\{2})*)\/#', '$1\\\\\\\\\/', $regex);\\n\\n        return (bool) @preg_match('\/^'.$regex.'$\/', $date);\\n    }\\n\\n    private function setDefaultTimezone(string $timezone, ?DateTimeInterface $date = null): void\\n    {\\n        $previous = null;\\n        $success = false;\\n\\n        try {\\n            $success = date_default_timezone_set($timezone);\\n        } catch (Throwable $exception) {\\n            $previous = $exception;\\n        }\\n\\n        if (!$success) {\\n            $suggestion = @CarbonTimeZone::create($timezone)->toRegionName($date);\\n\\n            throw new InvalidArgumentException(\\n                \\\"Timezone ID '$timezone' is invalid\\\".\\n                ($suggestion && $suggestion !== $timezone ? \\\", did you mean '$suggestion'?\\\" : '.').\\\"\\\\n\\\".\\n                \\\"It must be one of the IDs from DateTimeZone::listIdentifiers(),\\\\n\\\".\\n                'For the record, hours\/minutes offset are relevant only for a particular moment, '.\\n                'but not as a default timezone.',\\n                0,\\n                $previous\\n            );\\n        }\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Callback.php\",\"ext\":\"php\",\"size\":3119,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon;\\n\\nuse Closure;\\nuse DateInterval;\\nuse DatePeriod;\\nuse DateTime;\\nuse DateTimeInterface;\\nuse DateTimeZone;\\nuse ReflectionFunction;\\nuse ReflectionNamedType;\\nuse ReflectionType;\\n\\nfinal class Callback\\n{\\n    private ?ReflectionFunction $function;\\n\\n    private function __construct(private readonly Closure $closure)\\n    {\\n    }\\n\\n    public static function fromClosure(Closure $closure): self\\n    {\\n        return new self($closure);\\n    }\\n\\n    public static function parameter(mixed $closure, mixed $value, string|int $index = 0): mixed\\n    {\\n        if ($closure instanceof Closure) {\\n            return self::fromClosure($closure)->prepareParameter($value, $index);\\n        }\\n\\n        return $value;\\n    }\\n\\n    public function getReflectionFunction(): ReflectionFunction\\n    {\\n        return $this->function ??= new ReflectionFunction($this->closure);\\n    }\\n\\n    public function prepareParameter(mixed $value, string|int $index = 0): mixed\\n    {\\n        $type = $this->getParameterType($index);\\n\\n        if (!($type instanceof ReflectionNamedType)) {\\n            return $value;\\n        }\\n\\n        $name = $type->getName();\\n\\n        if ($name === CarbonInterface::class) {\\n            $name = $value instanceof DateTime ? Carbon::class : CarbonImmutable::class;\\n        }\\n\\n        if (!class_exists($name) || is_a($value, $name)) {\\n            return $value;\\n        }\\n\\n        $class = $this->getPromotedClass($value);\\n\\n        if ($class && is_a($name, $class, true)) {\\n            return $name::instance($value);\\n        }\\n\\n        return $value;\\n    }\\n\\n    public function call(mixed ...$arguments): mixed\\n    {\\n        foreach ($arguments as $index => &$value) {\\n            if ($this->getPromotedClass($value)) {\\n                $value = $this->prepareParameter($value, $index);\\n            }\\n        }\\n\\n        return ($this->closure)(...$arguments);\\n    }\\n\\n    private function getParameterType(string|int $index): ?ReflectionType\\n    {\\n        $parameters = $this->getReflectionFunction()->getParameters();\\n\\n        if (\\\\is_int($index)) {\\n            return ($parameters[$index] ?? null)?->getType();\\n        }\\n\\n        foreach ($parameters as $parameter) {\\n            if ($parameter->getName() === $index) {\\n                return $parameter->getType();\\n            }\\n        }\\n\\n        return null;\\n    }\\n\\n    \/** @return class-string|null *\/\\n    private function getPromotedClass(mixed $value): ?string\\n    {\\n        if ($value instanceof DateTimeInterface) {\\n            return CarbonInterface::class;\\n        }\\n\\n        if ($value instanceof DateInterval) {\\n            return CarbonInterval::class;\\n        }\\n\\n        if ($value instanceof DatePeriod) {\\n            return CarbonPeriod::class;\\n        }\\n\\n        if ($value instanceof DateTimeZone) {\\n            return CarbonTimeZone::class;\\n        }\\n\\n        return null;\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Carbon.php\",\"ext\":\"php\",\"size\":160416,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon;\\n\\nuse Carbon\\\\Traits\\\\Date;\\nuse DateTime;\\nuse DateTimeInterface;\\n\\n\/**\\n * A simple API extension for DateTime.\\n *\\n * <autodoc generated by `composer phpdoc`>\\n *\\n * @property      string           $localeDayOfWeek                                                                   the day of week in current locale\\n * @property      string           $shortLocaleDayOfWeek                                                              the abbreviated day of week in current locale\\n * @property      string           $localeMonth                                                                       the month in current locale\\n * @property      string           $shortLocaleMonth                                                                  the abbreviated month in current locale\\n * @property      int              $year\\n * @property      int              $yearIso\\n * @property      int              $month\\n * @property      int              $day\\n * @property      int              $hour\\n * @property      int              $minute\\n * @property      int              $second\\n * @property      int              $micro\\n * @property      int              $microsecond\\n * @property      int              $dayOfWeekIso                                                                      1 (for Monday) through 7 (for Sunday)\\n * @property      int|float|string $timestamp                                                                         seconds since the Unix Epoch\\n * @property      string           $englishDayOfWeek                                                                  the day of week in English\\n * @property      string           $shortEnglishDayOfWeek                                                             the abbreviated day of week in English\\n * @property      string           $englishMonth                                                                      the month in English\\n * @property      string           $shortEnglishMonth                                                                 the abbreviated month in English\\n * @property      int              $milliseconds\\n * @property      int              $millisecond\\n * @property      int              $milli\\n * @property      int              $week                                                                              1 through 53\\n * @property      int              $isoWeek                                                                           1 through 53\\n * @property      int              $weekYear                                                                          year according to week format\\n * @property      int              $isoWeekYear                                                                       year according to ISO week format\\n * @property      int              $age                                                                               does a diffInYears() with default parameters\\n * @property      int              $offset                                                                            the timezone offset in seconds from UTC\\n * @property      int              $offsetMinutes                                                                     the timezone offset in minutes from UTC\\n * @property      int              $offsetHours                                                                       the timezone offset in hours from UTC\\n * @property      CarbonTimeZone   $timezone                                                                          the current timezone\\n * @property      CarbonTimeZone   $tz                                                                                alias of $timezone\\n * @property      int              $centuryOfMillennium                                                               The value of the century starting from the beginning of the current millennium\\n * @property      int              $dayOfCentury                                                                      The value of the day starting from the beginning of the current century\\n * @property      int              $dayOfDecade                                                                       The value of the day starting from the beginning of the current decade\\n * @property      int              $dayOfMillennium                                                                   The value of the day starting from the beginning of the current millennium\\n * @property      int              $dayOfMonth                                                                        The value of the day starting from the beginning of the current month\\n * @property      int              $dayOfQuarter                                                                      The value of the day starting from the beginning of the current quarter\\n * @property      int              $dayOfWeek                                                                         0 (for Sunday) through 6 (for Saturday)\\n * @property      int              $dayOfYear                                                                         1 through 366\\n * @property      int              $decadeOfCentury                                                                   The value of the decade starting from the beginning of the current century\\n * @property      int              $decadeOfMillennium                                                                The value of the decade starting from the beginning of the current millennium\\n * @property      int              $hourOfCentury                                                                     The value of the hour starting from the beginning of the current century\\n * @property      int              $hourOfDay                                                                         The value of the hour starting from the beginning of the current day\\n * @property      int              $hourOfDecade                                                                      The value of the hour starting from the beginning of the current decade\\n * @property      int              $hourOfMillennium                                                                  The value of the hour starting from the beginning of the current millennium\\n * @property      int              $hourOfMonth                                                                       The value of the hour starting from the beginning of the current month\\n * @property      int              $hourOfQuarter                                                                     The value of the hour starting from the beginning of the current quarter\\n * @property      int              $hourOfWeek                                                                        The value of the hour starting from the beginning of the current week\\n * @property      int              $hourOfYear                                                                        The value of the hour starting from the beginning of the current year\\n * @property      int              $microsecondOfCentury                                                              The value of the microsecond starting from the beginning of the current century\\n * @property      int              $microsecondOfDay                                                                  The value of the microsecond starting from the beginning of the current day\\n * @property      int              $microsecondOfDecade                                                               The value of the microsecond starting from the beginning of the current decade\\n * @property      int              $microsecondOfHour                                                                 The value of the microsecond starting from the beginning of the current hour\\n * @property      int              $microsecondOfMillennium                                                           The value of the microsecond starting from the beginning of the current millennium\\n * @property      int              $microsecondOfMillisecond                                                          The value of the microsecond starting from the beginning of the current millisecond\\n * @property      int              $microsecondOfMinute                                                               The value of the microsecond starting from the beginning of the current minute\\n * @property      int              $microsecondOfMonth                                                                The value of the microsecond starting from the beginning of the current month\\n * @property      int              $microsecondOfQuarter                                                              The value of the microsecond starting from the beginning of the current quarter\\n * @property      int              $microsecondOfSecond                                                               The value of the microsecond starting from the beginning of the current second\\n * @property      int              $microsecondOfWeek                                                                 The value of the microsecond starting from the beginning of the current week\\n * @property      int              $microsecondOfYear                                                                 The value of the microsecond starting from the beginning of the current year\\n * @property      int              $millisecondOfCentury                                                              The value of the millisecond starting from the beginning of the current century\\n * @property      int              $millisecondOfDay                                                                  The value of the millisecond starting from the beginning of the current day\\n * @property      int              $millisecondOfDecade                                                               The value of the millisecond starting from the beginning of the current decade\\n * @property      int              $millisecondOfHour                                                                 The value of the millisecond starting from the beginning of the current hour\\n * @property      int              $millisecondOfMillennium                                                           The value of the millisecond starting from the beginning of the current millennium\\n * @property      int              $millisecondOfMinute                                                               The value of the millisecond starting from the beginning of the current minute\\n * @property      int              $millisecondOfMonth                                                                The value of the millisecond starting from the beginning of the current month\\n * @property      int              $millisecondOfQuarter                                                              The value of the millisecond starting from the beginning of the current quarter\\n * @property      int              $millisecondOfSecond                                                               The value of the millisecond starting from the beginning of the current second\\n * @property      int              $millisecondOfWeek                                                                 The value of the millisecond starting from the beginning of the current week\\n * @property      int              $millisecondOfYear                                                                 The value of the millisecond starting from the beginning of the current year\\n * @property      int              $minuteOfCentury                                                                   The value of the minute starting from the beginning of the current century\\n * @property      int              $minuteOfDay                                                                       The value of the minute starting from the beginning of the current day\\n * @property      int              $minuteOfDecade                                                                    The value of the minute starting from the beginning of the current decade\\n * @property      int              $minuteOfHour                                                                      The value of the minute starting from the beginning of the current hour\\n * @property      int              $minuteOfMillennium                                                                The value of the minute starting from the beginning of the current millennium\\n * @property      int              $minuteOfMonth                                                                     The value of the minute starting from the beginning of the current month\\n * @property      int              $minuteOfQuarter                                                                   The value of the minute starting from the beginning of the current quarter\\n * @property      int              $minuteOfWeek                                                                      The value of the minute starting from the beginning of the current week\\n * @property      int              $minuteOfYear                                                                      The value of the minute starting from the beginning of the current year\\n * @property      int              $monthOfCentury                                                                    The value of the month starting from the beginning of the current century\\n * @property      int              $monthOfDecade                                                                     The value of the month starting from the beginning of the current decade\\n * @property      int              $monthOfMillennium                                                                 The value of the month starting from the beginning of the current millennium\\n * @property      int              $monthOfQuarter                                                                    The value of the month starting from the beginning of the current quarter\\n * @property      int              $monthOfYear                                                                       The value of the month starting from the beginning of the current year\\n * @property      int              $quarterOfCentury                                                                  The value of the quarter starting from the beginning of the current century\\n * @property      int              $quarterOfDecade                                                                   The value of the quarter starting from the beginning of the current decade\\n * @property      int              $quarterOfMillennium                                                               The value of the quarter starting from the beginning of the current millennium\\n * @property      int              $quarterOfYear                                                                     The value of the quarter starting from the beginning of the current year\\n * @property      int              $secondOfCentury                                                                   The value of the second starting from the beginning of the current century\\n * @property      int              $secondOfDay                                                                       The value of the second starting from the beginning of the current day\\n * @property      int              $secondOfDecade                                                                    The value of the second starting from the beginning of the current decade\\n * @property      int              $secondOfHour                                                                      The value of the second starting from the beginning of the current hour\\n * @property      int              $secondOfMillennium                                                                The value of the second starting from the beginning of the current millennium\\n * @property      int              $secondOfMinute                                                                    The value of the second starting from the beginning of the current minute\\n * @property      int              $secondOfMonth                                                                     The value of the second starting from the beginning of the current month\\n * @property      int              $secondOfQuarter                                                                   The value of the second starting from the beginning of the current quarter\\n * @property      int              $secondOfWeek                                                                      The value of the second starting from the beginning of the current week\\n * @property      int              $secondOfYear                                                                      The value of the second starting from the beginning of the current year\\n * @property      int              $weekOfCentury                                                                     The value of the week starting from the beginning of the current century\\n * @property      int              $weekOfDecade                                                                      The value of the week starting from the beginning of the current decade\\n * @property      int              $weekOfMillennium                                                                  The value of the week starting from the beginning of the current millennium\\n * @property      int              $weekOfMonth                                                                       1 through 5\\n * @property      int              $weekOfQuarter                                                                     The value of the week starting from the beginning of the current quarter\\n * @property      int              $weekOfYear                                                                        ISO-8601 week number of year, weeks starting on Monday\\n * @property      int              $yearOfCentury                                                                     The value of the year starting from the beginning of the current century\\n * @property      int              $yearOfDecade                                                                      The value of the year starting from the beginning of the current decade\\n * @property      int              $yearOfMillennium                                                                  The value of the year starting from the beginning of the current millennium\\n * @property-read string           $latinMeridiem                                                                     \\\"am\\\"\/\\\"pm\\\" (Ante meridiem or Post meridiem latin lowercase mark)\\n * @property-read string           $latinUpperMeridiem                                                                \\\"AM\\\"\/\\\"PM\\\" (Ante meridiem or Post meridiem latin uppercase mark)\\n * @property-read string           $timezoneAbbreviatedName                                                           the current timezone abbreviated name\\n * @property-read string           $tzAbbrName                                                                        alias of $timezoneAbbreviatedName\\n * @property-read string           $dayName                                                                           long name of weekday translated according to Carbon locale, in english if no translation available for current language\\n * @property-read string           $shortDayName                                                                      short name of weekday translated according to Carbon locale, in english if no translation available for current language\\n * @property-read string           $minDayName                                                                        very short name of weekday translated according to Carbon locale, in english if no translation available for current language\\n * @property-read string           $monthName                                                                         long name of month translated according to Carbon locale, in english if no translation available for current language\\n * @property-read string           $shortMonthName                                                                    short name of month translated according to Carbon locale, in english if no translation available for current language\\n * @property-read string           $meridiem                                                                          lowercase meridiem mark translated according to Carbon locale, in latin if no translation available for current language\\n * @property-read string           $upperMeridiem                                                                     uppercase meridiem mark translated according to Carbon locale, in latin if no translation available for current language\\n * @property-read int              $noZeroHour                                                                        current hour from 1 to 24\\n * @property-read int              $isoWeeksInYear                                                                    51 through 53\\n * @property-read int              $weekNumberInMonth                                                                 1 through 5\\n * @property-read int              $firstWeekDay                                                                      0 through 6\\n * @property-read int              $lastWeekDay                                                                       0 through 6\\n * @property-read int              $quarter                                                                           the quarter of this instance, 1 - 4\\n * @property-read int              $decade                                                                            the decade of this instance\\n * @property-read int              $century                                                                           the century of this instance\\n * @property-read int              $millennium                                                                        the millennium of this instance\\n * @property-read bool             $dst                                                                               daylight savings time indicator, true if DST, false otherwise\\n * @property-read bool             $local                                                                             checks if the timezone is local, true if local, false otherwise\\n * @property-read bool             $utc                                                                               checks if the timezone is UTC, true if UTC, false otherwise\\n * @property-read string           $timezoneName                                                                      the current timezone name\\n * @property-read string           $tzName                                                                            alias of $timezoneName\\n * @property-read string           $locale                                                                            locale of the current instance\\n * @property-read int              $centuriesInMillennium                                                             The number of centuries contained in the current millennium\\n * @property-read int              $daysInCentury                                                                     The number of days contained in the current century\\n * @property-read int              $daysInDecade                                                                      The number of days contained in the current decade\\n * @property-read int              $daysInMillennium                                                                  The number of days contained in the current millennium\\n * @property-read int              $daysInMonth                                                                       number of days in the given month\\n * @property-read int              $daysInQuarter                                                                     The number of days contained in the current quarter\\n * @property-read int              $daysInWeek                                                                        The number of days contained in the current week\\n * @property-read int              $daysInYear                                                                        365 or 366\\n * @property-read int              $decadesInCentury                                                                  The number of decades contained in the current century\\n * @property-read int              $decadesInMillennium                                                               The number of decades contained in the current millennium\\n * @property-read int              $hoursInCentury                                                                    The number of hours contained in the current century\\n * @property-read int              $hoursInDay                                                                        The number of hours contained in the current day\\n * @property-read int              $hoursInDecade                                                                     The number of hours contained in the current decade\\n * @property-read int              $hoursInMillennium                                                                 The number of hours contained in the current millennium\\n * @property-read int              $hoursInMonth                                                                      The number of hours contained in the current month\\n * @property-read int              $hoursInQuarter                                                                    The number of hours contained in the current quarter\\n * @property-read int              $hoursInWeek                                                                       The number of hours contained in the current week\\n * @property-read int              $hoursInYear                                                                       The number of hours contained in the current year\\n * @property-read int              $microsecondsInCentury                                                             The number of microseconds contained in the current century\\n * @property-read int              $microsecondsInDay                                                                 The number of microseconds contained in the current day\\n * @property-read int              $microsecondsInDecade                                                              The number of microseconds contained in the current decade\\n * @property-read int              $microsecondsInHour                                                                The number of microseconds contained in the current hour\\n * @property-read int              $microsecondsInMillennium                                                          The number of microseconds contained in the current millennium\\n * @property-read int              $microsecondsInMillisecond                                                         The number of microseconds contained in the current millisecond\\n * @property-read int              $microsecondsInMinute                                                              The number of microseconds contained in the current minute\\n * @property-read int              $microsecondsInMonth                                                               The number of microseconds contained in the current month\\n * @property-read int              $microsecondsInQuarter                                                             The number of microseconds contained in the current quarter\\n * @property-read int              $microsecondsInSecond                                                              The number of microseconds contained in the current second\\n * @property-read int              $microsecondsInWeek                                                                The number of microseconds contained in the current week\\n * @property-read int              $microsecondsInYear                                                                The number of microseconds contained in the current year\\n * @property-read int              $millisecondsInCentury                                                             The number of milliseconds contained in the current century\\n * @property-read int              $millisecondsInDay                                                                 The number of milliseconds contained in the current day\\n * @property-read int              $millisecondsInDecade                                                              The number of milliseconds contained in the current decade\\n * @property-read int              $millisecondsInHour                                                                The number of milliseconds contained in the current hour\\n * @property-read int              $millisecondsInMillennium                                                          The number of milliseconds contained in the current millennium\\n * @property-read int              $millisecondsInMinute                                                              The number of milliseconds contained in the current minute\\n * @property-read int              $millisecondsInMonth                                                               The number of milliseconds contained in the current month\\n * @property-read int              $millisecondsInQuarter                                                             The number of milliseconds contained in the current quarter\\n * @property-read int              $millisecondsInSecond                                                              The number of milliseconds contained in the current second\\n * @property-read int              $millisecondsInWeek                                                                The number of milliseconds contained in the current week\\n * @property-read int              $millisecondsInYear                                                                The number of milliseconds contained in the current year\\n * @property-read int              $minutesInCentury                                                                  The number of minutes contained in the current century\\n * @property-read int              $minutesInDay                                                                      The number of minutes contained in the current day\\n * @property-read int              $minutesInDecade                                                                   The number of minutes contained in the current decade\\n * @property-read int              $minutesInHour                                                                     The number of minutes contained in the current hour\\n * @property-read int              $minutesInMillennium                                                               The number of minutes contained in the current millennium\\n * @property-read int              $minutesInMonth                                                                    The number of minutes contained in the current month\\n * @property-read int              $minutesInQuarter                                                                  The number of minutes contained in the current quarter\\n * @property-read int              $minutesInWeek                                                                     The number of minutes contained in the current week\\n * @property-read int              $minutesInYear                                                                     The number of minutes contained in the current year\\n * @property-read int              $monthsInCentury                                                                   The number of months contained in the current century\\n * @property-read int              $monthsInDecade                                                                    The number of months contained in the current decade\\n * @property-read int              $monthsInMillennium                                                                The number of months contained in the current millennium\\n * @property-read int              $monthsInQuarter                                                                   The number of months contained in the current quarter\\n * @property-read int              $monthsInYear                                                                      The number of months contained in the current year\\n * @property-read int              $quartersInCentury                                                                 The number of quarters contained in the current century\\n * @property-read int              $quartersInDecade                                                                  The number of quarters contained in the current decade\\n * @property-read int              $quartersInMillennium                                                              The number of quarters contained in the current millennium\\n * @property-read int              $quartersInYear                                                                    The number of quarters contained in the current year\\n * @property-read int              $secondsInCentury                                                                  The number of seconds contained in the current century\\n * @property-read int              $secondsInDay                                                                      The number of seconds contained in the current day\\n * @property-read int              $secondsInDecade                                                                   The number of seconds contained in the current decade\\n * @property-read int              $secondsInHour                                                                     The number of seconds contained in the current hour\\n * @property-read int              $secondsInMillennium                                                               The number of seconds contained in the current millennium\\n * @property-read int              $secondsInMinute                                                                   The number of seconds contained in the current minute\\n * @property-read int              $secondsInMonth                                                                    The number of seconds contained in the current month\\n * @property-read int              $secondsInQuarter                                                                  The number of seconds contained in the current quarter\\n * @property-read int              $secondsInWeek                                                                     The number of seconds contained in the current week\\n * @property-read int              $secondsInYear                                                                     The number of seconds contained in the current year\\n * @property-read int              $weeksInCentury                                                                    The number of weeks contained in the current century\\n * @property-read int              $weeksInDecade                                                                     The number of weeks contained in the current decade\\n * @property-read int              $weeksInMillennium                                                                 The number of weeks contained in the current millennium\\n * @property-read int              $weeksInMonth                                                                      The number of weeks contained in the current month\\n * @property-read int              $weeksInQuarter                                                                    The number of weeks contained in the current quarter\\n * @property-read int              $weeksInYear                                                                       51 through 53\\n * @property-read int              $yearsInCentury                                                                    The number of years contained in the current century\\n * @property-read int              $yearsInDecade                                                                     The number of years contained in the current decade\\n * @property-read int              $yearsInMillennium                                                                 The number of years contained in the current millennium\\n *\\n * @method        bool             isUtc()                                                                            Check if the current instance has UTC timezone. (Both isUtc and isUTC cases are valid.)\\n * @method        bool             isLocal()                                                                          Check if the current instance has non-UTC timezone.\\n * @method        bool             isValid()                                                                          Check if the current instance is a valid date.\\n * @method        bool             isDST()                                                                            Check if the current instance is in a daylight saving time.\\n * @method        bool             isSunday()                                                                         Checks if the instance day is sunday.\\n * @method        bool             isMonday()                                                                         Checks if the instance day is monday.\\n * @method        bool             isTuesday()                                                                        Checks if the instance day is tuesday.\\n * @method        bool             isWednesday()                                                                      Checks if the instance day is wednesday.\\n * @method        bool             isThursday()                                                                       Checks if the instance day is thursday.\\n * @method        bool             isFriday()                                                                         Checks if the instance day is friday.\\n * @method        bool             isSaturday()                                                                       Checks if the instance day is saturday.\\n * @method        bool             isSameYear(DateTimeInterface|string $date)                                         Checks if the given date is in the same year as the instance. If null passed, compare to now (with the same timezone).\\n * @method        bool             isCurrentYear()                                                                    Checks if the instance is in the same year as the current moment.\\n * @method        bool             isNextYear()                                                                       Checks if the instance is in the same year as the current moment next year.\\n * @method        bool             isLastYear()                                                                       Checks if the instance is in the same year as the current moment last year.\\n * @method        bool             isCurrentMonth()                                                                   Checks if the instance is in the same month as the current moment.\\n * @method        bool             isNextMonth()                                                                      Checks if the instance is in the same month as the current moment next month.\\n * @method        bool             isLastMonth()                                                                      Checks if the instance is in the same month as the current moment last month.\\n * @method        bool             isSameWeek(DateTimeInterface|string $date)                                         Checks if the given date is in the same week as the instance. If null passed, compare to now (with the same timezone).\\n * @method        bool             isCurrentWeek()                                                                    Checks if the instance is in the same week as the current moment.\\n * @method        bool             isNextWeek()                                                                       Checks if the instance is in the same week as the current moment next week.\\n * @method        bool             isLastWeek()                                                                       Checks if the instance is in the same week as the current moment last week.\\n * @method        bool             isSameDay(DateTimeInterface|string $date)                                          Checks if the given date is in the same day as the instance. If null passed, compare to now (with the same timezone).\\n * @method        bool             isCurrentDay()                                                                     Checks if the instance is in the same day as the current moment.\\n * @method        bool             isNextDay()                                                                        Checks if the instance is in the same day as the current moment next day.\\n * @method        bool             isLastDay()                                                                        Checks if the instance is in the same day as the current moment last day.\\n * @method        bool             isSameHour(DateTimeInterface|string $date)                                         Checks if the given date is in the same hour as the instance. If null passed, compare to now (with the same timezone).\\n * @method        bool             isCurrentHour()                                                                    Checks if the instance is in the same hour as the current moment.\\n * @method        bool             isNextHour()                                                                       Checks if the instance is in the same hour as the current moment next hour.\\n * @method        bool             isLastHour()                                                                       Checks if the instance is in the same hour as the current moment last hour.\\n * @method        bool             isSameMinute(DateTimeInterface|string $date)                                       Checks if the given date is in the same minute as the instance. If null passed, compare to now (with the same timezone).\\n * @method        bool             isCurrentMinute()                                                                  Checks if the instance is in the same minute as the current moment.\\n * @method        bool             isNextMinute()                                                                     Checks if the instance is in the same minute as the current moment next minute.\\n * @method        bool             isLastMinute()                                                                     Checks if the instance is in the same minute as the current moment last minute.\\n * @method        bool             isSameSecond(DateTimeInterface|string $date)                                       Checks if the given date is in the same second as the instance. If null passed, compare to now (with the same timezone).\\n * @method        bool             isCurrentSecond()                                                                  Checks if the instance is in the same second as the current moment.\\n * @method        bool             isNextSecond()                                                                     Checks if the instance is in the same second as the current moment next second.\\n * @method        bool             isLastSecond()                                                                     Checks if the instance is in the same second as the current moment last second.\\n * @method        bool             isSameMilli(DateTimeInterface|string $date)                                        Checks if the given date is in the same millisecond as the instance. If null passed, compare to now (with the same timezone).\\n * @method        bool             isCurrentMilli()                                                                   Checks if the instance is in the same millisecond as the current moment.\\n * @method        bool             isNextMilli()                                                                      Checks if the instance is in the same millisecond as the current moment next millisecond.\\n * @method        bool             isLastMilli()                                                                      Checks if the instance is in the same millisecond as the current moment last millisecond.\\n * @method        bool             isSameMillisecond(DateTimeInterface|string $date)                                  Checks if the given date is in the same millisecond as the instance. If null passed, compare to now (with the same timezone).\\n * @method        bool             isCurrentMillisecond()                                                             Checks if the instance is in the same millisecond as the current moment.\\n * @method        bool             isNextMillisecond()                                                                Checks if the instance is in the same millisecond as the current moment next millisecond.\\n * @method        bool             isLastMillisecond()                                                                Checks if the instance is in the same millisecond as the current moment last millisecond.\\n * @method        bool             isSameMicro(DateTimeInterface|string $date)                                        Checks if the given date is in the same microsecond as the instance. If null passed, compare to now (with the same timezone).\\n * @method        bool             isCurrentMicro()                                                                   Checks if the instance is in the same microsecond as the current moment.\\n * @method        bool             isNextMicro()                                                                      Checks if the instance is in the same microsecond as the current moment next microsecond.\\n * @method        bool             isLastMicro()                                                                      Checks if the instance is in the same microsecond as the current moment last microsecond.\\n * @method        bool             isSameMicrosecond(DateTimeInterface|string $date)                                  Checks if the given date is in the same microsecond as the instance. If null passed, compare to now (with the same timezone).\\n * @method        bool             isCurrentMicrosecond()                                                             Checks if the instance is in the same microsecond as the current moment.\\n * @method        bool             isNextMicrosecond()                                                                Checks if the instance is in the same microsecond as the current moment next microsecond.\\n * @method        bool             isLastMicrosecond()                                                                Checks if the instance is in the same microsecond as the current moment last microsecond.\\n * @method        bool             isSameDecade(DateTimeInterface|string $date)                                       Checks if the given date is in the same decade as the instance. If null passed, compare to now (with the same timezone).\\n * @method        bool             isCurrentDecade()                                                                  Checks if the instance is in the same decade as the current moment.\\n * @method        bool             isNextDecade()                                                                     Checks if the instance is in the same decade as the current moment next decade.\\n * @method        bool             isLastDecade()                                                                     Checks if the instance is in the same decade as the current moment last decade.\\n * @method        bool             isSameCentury(DateTimeInterface|string $date)                                      Checks if the given date is in the same century as the instance. If null passed, compare to now (with the same timezone).\\n * @method        bool             isCurrentCentury()                                                                 Checks if the instance is in the same century as the current moment.\\n * @method        bool             isNextCentury()                                                                    Checks if the instance is in the same century as the current moment next century.\\n * @method        bool             isLastCentury()                                                                    Checks if the instance is in the same century as the current moment last century.\\n * @method        bool             isSameMillennium(DateTimeInterface|string $date)                                   Checks if the given date is in the same millennium as the instance. If null passed, compare to now (with the same timezone).\\n * @method        bool             isCurrentMillennium()                                                              Checks if the instance is in the same millennium as the current moment.\\n * @method        bool             isNextMillennium()                                                                 Checks if the instance is in the same millennium as the current moment next millennium.\\n * @method        bool             isLastMillennium()                                                                 Checks if the instance is in the same millennium as the current moment last millennium.\\n * @method        bool             isCurrentQuarter()                                                                 Checks if the instance is in the same quarter as the current moment.\\n * @method        bool             isNextQuarter()                                                                    Checks if the instance is in the same quarter as the current moment next quarter.\\n * @method        bool             isLastQuarter()                                                                    Checks if the instance is in the same quarter as the current moment last quarter.\\n * @method        $this            years(int $value)                                                                  Set current instance year to the given value.\\n * @method        $this            year(int $value)                                                                   Set current instance year to the given value.\\n * @method        $this            setYears(int $value)                                                               Set current instance year to the given value.\\n * @method        $this            setYear(int $value)                                                                Set current instance year to the given value.\\n * @method        $this            months(Month|int $value)                                                           Set current instance month to the given value.\\n * @method        $this            month(Month|int $value)                                                            Set current instance month to the given value.\\n * @method        $this            setMonths(Month|int $value)                                                        Set current instance month to the given value.\\n * @method        $this            setMonth(Month|int $value)                                                         Set current instance month to the given value.\\n * @method        $this            days(int $value)                                                                   Set current instance day to the given value.\\n * @method        $this            day(int $value)                                                                    Set current instance day to the given value.\\n * @method        $this            setDays(int $value)                                                                Set current instance day to the given value.\\n * @method        $this            setDay(int $value)                                                                 Set current instance day to the given value.\\n * @method        $this            hours(int $value)                                                                  Set current instance hour to the given value.\\n * @method        $this            hour(int $value)                                                                   Set current instance hour to the given value.\\n * @method        $this            setHours(int $value)                                                               Set current instance hour to the given value.\\n * @method        $this            setHour(int $value)                                                                Set current instance hour to the given value.\\n * @method        $this            minutes(int $value)                                                                Set current instance minute to the given value.\\n * @method        $this            minute(int $value)                                                                 Set current instance minute to the given value.\\n * @method        $this            setMinutes(int $value)                                                             Set current instance minute to the given value.\\n * @method        $this            setMinute(int $value)                                                              Set current instance minute to the given value.\\n * @method        $this            seconds(int $value)                                                                Set current instance second to the given value.\\n * @method        $this            second(int $value)                                                                 Set current instance second to the given value.\\n * @method        $this            setSeconds(int $value)                                                             Set current instance second to the given value.\\n * @method        $this            setSecond(int $value)                                                              Set current instance second to the given value.\\n * @method        $this            millis(int $value)                                                                 Set current instance millisecond to the given value.\\n * @method        $this            milli(int $value)                                                                  Set current instance millisecond to the given value.\\n * @method        $this            setMillis(int $value)                                                              Set current instance millisecond to the given value.\\n * @method        $this            setMilli(int $value)                                                               Set current instance millisecond to the given value.\\n * @method        $this            milliseconds(int $value)                                                           Set current instance millisecond to the given value.\\n * @method        $this            millisecond(int $value)                                                            Set current instance millisecond to the given value.\\n * @method        $this            setMilliseconds(int $value)                                                        Set current instance millisecond to the given value.\\n * @method        $this            setMillisecond(int $value)                                                         Set current instance millisecond to the given value.\\n * @method        $this            micros(int $value)                                                                 Set current instance microsecond to the given value.\\n * @method        $this            micro(int $value)                                                                  Set current instance microsecond to the given value.\\n * @method        $this            setMicros(int $value)                                                              Set current instance microsecond to the given value.\\n * @method        $this            setMicro(int $value)                                                               Set current instance microsecond to the given value.\\n * @method        $this            microseconds(int $value)                                                           Set current instance microsecond to the given value.\\n * @method        $this            microsecond(int $value)                                                            Set current instance microsecond to the given value.\\n * @method        $this            setMicroseconds(int $value)                                                        Set current instance microsecond to the given value.\\n * @method        $this            setMicrosecond(int $value)                                                         Set current instance microsecond to the given value.\\n * @method        $this            addYears(int|float $value = 1)                                                     Add years (the $value count passed in) to the instance (using date interval).\\n * @method        $this            addYear()                                                                          Add one year to the instance (using date interval).\\n * @method        $this            subYears(int|float $value = 1)                                                     Sub years (the $value count passed in) to the instance (using date interval).\\n * @method        $this            subYear()                                                                          Sub one year to the instance (using date interval).\\n * @method        $this            addYearsWithOverflow(int|float $value = 1)                                         Add years (the $value count passed in) to the instance (using date interval) with overflow explicitly allowed.\\n * @method        $this            addYearWithOverflow()                                                              Add one year to the instance (using date interval) with overflow explicitly allowed.\\n * @method        $this            subYearsWithOverflow(int|float $value = 1)                                         Sub years (the $value count passed in) to the instance (using date interval) with overflow explicitly allowed.\\n * @method        $this            subYearWithOverflow()                                                              Sub one year to the instance (using date interval) with overflow explicitly allowed.\\n * @method        $this            addYearsWithoutOverflow(int|float $value = 1)                                      Add years (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addYearWithoutOverflow()                                                           Add one year to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subYearsWithoutOverflow(int|float $value = 1)                                      Sub years (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subYearWithoutOverflow()                                                           Sub one year to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addYearsWithNoOverflow(int|float $value = 1)                                       Add years (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addYearWithNoOverflow()                                                            Add one year to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subYearsWithNoOverflow(int|float $value = 1)                                       Sub years (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subYearWithNoOverflow()                                                            Sub one year to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addYearsNoOverflow(int|float $value = 1)                                           Add years (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addYearNoOverflow()                                                                Add one year to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subYearsNoOverflow(int|float $value = 1)                                           Sub years (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subYearNoOverflow()                                                                Sub one year to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addMonths(int|float $value = 1)                                                    Add months (the $value count passed in) to the instance (using date interval).\\n * @method        $this            addMonth()                                                                         Add one month to the instance (using date interval).\\n * @method        $this            subMonths(int|float $value = 1)                                                    Sub months (the $value count passed in) to the instance (using date interval).\\n * @method        $this            subMonth()                                                                         Sub one month to the instance (using date interval).\\n * @method        $this            addMonthsWithOverflow(int|float $value = 1)                                        Add months (the $value count passed in) to the instance (using date interval) with overflow explicitly allowed.\\n * @method        $this            addMonthWithOverflow()                                                             Add one month to the instance (using date interval) with overflow explicitly allowed.\\n * @method        $this            subMonthsWithOverflow(int|float $value = 1)                                        Sub months (the $value count passed in) to the instance (using date interval) with overflow explicitly allowed.\\n * @method        $this            subMonthWithOverflow()                                                             Sub one month to the instance (using date interval) with overflow explicitly allowed.\\n * @method        $this            addMonthsWithoutOverflow(int|float $value = 1)                                     Add months (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addMonthWithoutOverflow()                                                          Add one month to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subMonthsWithoutOverflow(int|float $value = 1)                                     Sub months (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subMonthWithoutOverflow()                                                          Sub one month to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addMonthsWithNoOverflow(int|float $value = 1)                                      Add months (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addMonthWithNoOverflow()                                                           Add one month to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subMonthsWithNoOverflow(int|float $value = 1)                                      Sub months (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subMonthWithNoOverflow()                                                           Sub one month to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addMonthsNoOverflow(int|float $value = 1)                                          Add months (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addMonthNoOverflow()                                                               Add one month to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subMonthsNoOverflow(int|float $value = 1)                                          Sub months (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subMonthNoOverflow()                                                               Sub one month to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addDays(int|float $value = 1)                                                      Add days (the $value count passed in) to the instance (using date interval).\\n * @method        $this            addDay()                                                                           Add one day to the instance (using date interval).\\n * @method        $this            subDays(int|float $value = 1)                                                      Sub days (the $value count passed in) to the instance (using date interval).\\n * @method        $this            subDay()                                                                           Sub one day to the instance (using date interval).\\n * @method        $this            addHours(int|float $value = 1)                                                     Add hours (the $value count passed in) to the instance (using date interval).\\n * @method        $this            addHour()                                                                          Add one hour to the instance (using date interval).\\n * @method        $this            subHours(int|float $value = 1)                                                     Sub hours (the $value count passed in) to the instance (using date interval).\\n * @method        $this            subHour()                                                                          Sub one hour to the instance (using date interval).\\n * @method        $this            addMinutes(int|float $value = 1)                                                   Add minutes (the $value count passed in) to the instance (using date interval).\\n * @method        $this            addMinute()                                                                        Add one minute to the instance (using date interval).\\n * @method        $this            subMinutes(int|float $value = 1)                                                   Sub minutes (the $value count passed in) to the instance (using date interval).\\n * @method        $this            subMinute()                                                                        Sub one minute to the instance (using date interval).\\n * @method        $this            addSeconds(int|float $value = 1)                                                   Add seconds (the $value count passed in) to the instance (using date interval).\\n * @method        $this            addSecond()                                                                        Add one second to the instance (using date interval).\\n * @method        $this            subSeconds(int|float $value = 1)                                                   Sub seconds (the $value count passed in) to the instance (using date interval).\\n * @method        $this            subSecond()                                                                        Sub one second to the instance (using date interval).\\n * @method        $this            addMillis(int|float $value = 1)                                                    Add milliseconds (the $value count passed in) to the instance (using date interval).\\n * @method        $this            addMilli()                                                                         Add one millisecond to the instance (using date interval).\\n * @method        $this            subMillis(int|float $value = 1)                                                    Sub milliseconds (the $value count passed in) to the instance (using date interval).\\n * @method        $this            subMilli()                                                                         Sub one millisecond to the instance (using date interval).\\n * @method        $this            addMilliseconds(int|float $value = 1)                                              Add milliseconds (the $value count passed in) to the instance (using date interval).\\n * @method        $this            addMillisecond()                                                                   Add one millisecond to the instance (using date interval).\\n * @method        $this            subMilliseconds(int|float $value = 1)                                              Sub milliseconds (the $value count passed in) to the instance (using date interval).\\n * @method        $this            subMillisecond()                                                                   Sub one millisecond to the instance (using date interval).\\n * @method        $this            addMicros(int|float $value = 1)                                                    Add microseconds (the $value count passed in) to the instance (using date interval).\\n * @method        $this            addMicro()                                                                         Add one microsecond to the instance (using date interval).\\n * @method        $this            subMicros(int|float $value = 1)                                                    Sub microseconds (the $value count passed in) to the instance (using date interval).\\n * @method        $this            subMicro()                                                                         Sub one microsecond to the instance (using date interval).\\n * @method        $this            addMicroseconds(int|float $value = 1)                                              Add microseconds (the $value count passed in) to the instance (using date interval).\\n * @method        $this            addMicrosecond()                                                                   Add one microsecond to the instance (using date interval).\\n * @method        $this            subMicroseconds(int|float $value = 1)                                              Sub microseconds (the $value count passed in) to the instance (using date interval).\\n * @method        $this            subMicrosecond()                                                                   Sub one microsecond to the instance (using date interval).\\n * @method        $this            addMillennia(int|float $value = 1)                                                 Add millennia (the $value count passed in) to the instance (using date interval).\\n * @method        $this            addMillennium()                                                                    Add one millennium to the instance (using date interval).\\n * @method        $this            subMillennia(int|float $value = 1)                                                 Sub millennia (the $value count passed in) to the instance (using date interval).\\n * @method        $this            subMillennium()                                                                    Sub one millennium to the instance (using date interval).\\n * @method        $this            addMillenniaWithOverflow(int|float $value = 1)                                     Add millennia (the $value count passed in) to the instance (using date interval) with overflow explicitly allowed.\\n * @method        $this            addMillenniumWithOverflow()                                                        Add one millennium to the instance (using date interval) with overflow explicitly allowed.\\n * @method        $this            subMillenniaWithOverflow(int|float $value = 1)                                     Sub millennia (the $value count passed in) to the instance (using date interval) with overflow explicitly allowed.\\n * @method        $this            subMillenniumWithOverflow()                                                        Sub one millennium to the instance (using date interval) with overflow explicitly allowed.\\n * @method        $this            addMillenniaWithoutOverflow(int|float $value = 1)                                  Add millennia (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addMillenniumWithoutOverflow()                                                     Add one millennium to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subMillenniaWithoutOverflow(int|float $value = 1)                                  Sub millennia (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subMillenniumWithoutOverflow()                                                     Sub one millennium to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addMillenniaWithNoOverflow(int|float $value = 1)                                   Add millennia (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addMillenniumWithNoOverflow()                                                      Add one millennium to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subMillenniaWithNoOverflow(int|float $value = 1)                                   Sub millennia (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subMillenniumWithNoOverflow()                                                      Sub one millennium to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addMillenniaNoOverflow(int|float $value = 1)                                       Add millennia (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addMillenniumNoOverflow()                                                          Add one millennium to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subMillenniaNoOverflow(int|float $value = 1)                                       Sub millennia (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subMillenniumNoOverflow()                                                          Sub one millennium to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addCenturies(int|float $value = 1)                                                 Add centuries (the $value count passed in) to the instance (using date interval).\\n * @method        $this            addCentury()                                                                       Add one century to the instance (using date interval).\\n * @method        $this            subCenturies(int|float $value = 1)                                                 Sub centuries (the $value count passed in) to the instance (using date interval).\\n * @method        $this            subCentury()                                                                       Sub one century to the instance (using date interval).\\n * @method        $this            addCenturiesWithOverflow(int|float $value = 1)                                     Add centuries (the $value count passed in) to the instance (using date interval) with overflow explicitly allowed.\\n * @method        $this            addCenturyWithOverflow()                                                           Add one century to the instance (using date interval) with overflow explicitly allowed.\\n * @method        $this            subCenturiesWithOverflow(int|float $value = 1)                                     Sub centuries (the $value count passed in) to the instance (using date interval) with overflow explicitly allowed.\\n * @method        $this            subCenturyWithOverflow()                                                           Sub one century to the instance (using date interval) with overflow explicitly allowed.\\n * @method        $this            addCenturiesWithoutOverflow(int|float $value = 1)                                  Add centuries (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addCenturyWithoutOverflow()                                                        Add one century to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subCenturiesWithoutOverflow(int|float $value = 1)                                  Sub centuries (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subCenturyWithoutOverflow()                                                        Sub one century to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addCenturiesWithNoOverflow(int|float $value = 1)                                   Add centuries (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addCenturyWithNoOverflow()                                                         Add one century to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subCenturiesWithNoOverflow(int|float $value = 1)                                   Sub centuries (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subCenturyWithNoOverflow()                                                         Sub one century to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addCenturiesNoOverflow(int|float $value = 1)                                       Add centuries (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addCenturyNoOverflow()                                                             Add one century to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subCenturiesNoOverflow(int|float $value = 1)                                       Sub centuries (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subCenturyNoOverflow()                                                             Sub one century to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addDecades(int|float $value = 1)                                                   Add decades (the $value count passed in) to the instance (using date interval).\\n * @method        $this            addDecade()                                                                        Add one decade to the instance (using date interval).\\n * @method        $this            subDecades(int|float $value = 1)                                                   Sub decades (the $value count passed in) to the instance (using date interval).\\n * @method        $this            subDecade()                                                                        Sub one decade to the instance (using date interval).\\n * @method        $this            addDecadesWithOverflow(int|float $value = 1)                                       Add decades (the $value count passed in) to the instance (using date interval) with overflow explicitly allowed.\\n * @method        $this            addDecadeWithOverflow()                                                            Add one decade to the instance (using date interval) with overflow explicitly allowed.\\n * @method        $this            subDecadesWithOverflow(int|float $value = 1)                                       Sub decades (the $value count passed in) to the instance (using date interval) with overflow explicitly allowed.\\n * @method        $this            subDecadeWithOverflow()                                                            Sub one decade to the instance (using date interval) with overflow explicitly allowed.\\n * @method        $this            addDecadesWithoutOverflow(int|float $value = 1)                                    Add decades (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addDecadeWithoutOverflow()                                                         Add one decade to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subDecadesWithoutOverflow(int|float $value = 1)                                    Sub decades (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subDecadeWithoutOverflow()                                                         Sub one decade to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addDecadesWithNoOverflow(int|float $value = 1)                                     Add decades (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addDecadeWithNoOverflow()                                                          Add one decade to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subDecadesWithNoOverflow(int|float $value = 1)                                     Sub decades (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subDecadeWithNoOverflow()                                                          Sub one decade to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addDecadesNoOverflow(int|float $value = 1)                                         Add decades (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addDecadeNoOverflow()                                                              Add one decade to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subDecadesNoOverflow(int|float $value = 1)                                         Sub decades (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subDecadeNoOverflow()                                                              Sub one decade to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addQuarters(int|float $value = 1)                                                  Add quarters (the $value count passed in) to the instance (using date interval).\\n * @method        $this            addQuarter()                                                                       Add one quarter to the instance (using date interval).\\n * @method        $this            subQuarters(int|float $value = 1)                                                  Sub quarters (the $value count passed in) to the instance (using date interval).\\n * @method        $this            subQuarter()                                                                       Sub one quarter to the instance (using date interval).\\n * @method        $this            addQuartersWithOverflow(int|float $value = 1)                                      Add quarters (the $value count passed in) to the instance (using date interval) with overflow explicitly allowed.\\n * @method        $this            addQuarterWithOverflow()                                                           Add one quarter to the instance (using date interval) with overflow explicitly allowed.\\n * @method        $this            subQuartersWithOverflow(int|float $value = 1)                                      Sub quarters (the $value count passed in) to the instance (using date interval) with overflow explicitly allowed.\\n * @method        $this            subQuarterWithOverflow()                                                           Sub one quarter to the instance (using date interval) with overflow explicitly allowed.\\n * @method        $this            addQuartersWithoutOverflow(int|float $value = 1)                                   Add quarters (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addQuarterWithoutOverflow()                                                        Add one quarter to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subQuartersWithoutOverflow(int|float $value = 1)                                   Sub quarters (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subQuarterWithoutOverflow()                                                        Sub one quarter to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addQuartersWithNoOverflow(int|float $value = 1)                                    Add quarters (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addQuarterWithNoOverflow()                                                         Add one quarter to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subQuartersWithNoOverflow(int|float $value = 1)                                    Sub quarters (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subQuarterWithNoOverflow()                                                         Sub one quarter to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addQuartersNoOverflow(int|float $value = 1)                                        Add quarters (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addQuarterNoOverflow()                                                             Add one quarter to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subQuartersNoOverflow(int|float $value = 1)                                        Sub quarters (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            subQuarterNoOverflow()                                                             Sub one quarter to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        $this            addWeeks(int|float $value = 1)                                                     Add weeks (the $value count passed in) to the instance (using date interval).\\n * @method        $this            addWeek()                                                                          Add one week to the instance (using date interval).\\n * @method        $this            subWeeks(int|float $value = 1)                                                     Sub weeks (the $value count passed in) to the instance (using date interval).\\n * @method        $this            subWeek()                                                                          Sub one week to the instance (using date interval).\\n * @method        $this            addWeekdays(int|float $value = 1)                                                  Add weekdays (the $value count passed in) to the instance (using date interval).\\n * @method        $this            addWeekday()                                                                       Add one weekday to the instance (using date interval).\\n * @method        $this            subWeekdays(int|float $value = 1)                                                  Sub weekdays (the $value count passed in) to the instance (using date interval).\\n * @method        $this            subWeekday()                                                                       Sub one weekday to the instance (using date interval).\\n * @method        $this            addUTCMicros(int|float $value = 1)                                                 Add microseconds (the $value count passed in) to the instance (using timestamp).\\n * @method        $this            addUTCMicro()                                                                      Add one microsecond to the instance (using timestamp).\\n * @method        $this            subUTCMicros(int|float $value = 1)                                                 Sub microseconds (the $value count passed in) to the instance (using timestamp).\\n * @method        $this            subUTCMicro()                                                                      Sub one microsecond to the instance (using timestamp).\\n * @method        CarbonPeriod     microsUntil($endDate = null, int|float $factor = 1)                                Return an iterable period from current date to given end (string, DateTime or Carbon instance) for each microsecond or every X microseconds if a factor is given.\\n * @method        float            diffInUTCMicros(DateTimeInterface|string|null $date, bool $absolute = false)       Convert current and given date in UTC timezone and return a floating number of microseconds.\\n * @method        $this            addUTCMicroseconds(int|float $value = 1)                                           Add microseconds (the $value count passed in) to the instance (using timestamp).\\n * @method        $this            addUTCMicrosecond()                                                                Add one microsecond to the instance (using timestamp).\\n * @method        $this            subUTCMicroseconds(int|float $value = 1)                                           Sub microseconds (the $value count passed in) to the instance (using timestamp).\\n * @method        $this            subUTCMicrosecond()                                                                Sub one microsecond to the instance (using timestamp).\\n * @method        CarbonPeriod     microsecondsUntil($endDate = null, int|float $factor = 1)                          Return an iterable period from current date to given end (string, DateTime or Carbon instance) for each microsecond or every X microseconds if a factor is given.\\n * @method        float            diffInUTCMicroseconds(DateTimeInterface|string|null $date, bool $absolute = false) Convert current and given date in UTC timezone and return a floating number of microseconds.\\n * @method        $this            addUTCMillis(int|float $value = 1)                                                 Add milliseconds (the $value count passed in) to the instance (using timestamp).\\n * @method        $this            addUTCMilli()                                                                      Add one millisecond to the instance (using timestamp).\\n * @method        $this            subUTCMillis(int|float $value = 1)                                                 Sub milliseconds (the $value count passed in) to the instance (using timestamp).\\n * @method        $this            subUTCMilli()                                                                      Sub one millisecond to the instance (using timestamp).\\n * @method        CarbonPeriod     millisUntil($endDate = null, int|float $factor = 1)                                Return an iterable period from current date to given end (string, DateTime or Carbon instance) for each millisecond or every X milliseconds if a factor is given.\\n * @method        float            diffInUTCMillis(DateTimeInterface|string|null $date, bool $absolute = false)       Convert current and given date in UTC timezone and return a floating number of milliseconds.\\n * @method        $this            addUTCMilliseconds(int|float $value = 1)                                           Add milliseconds (the $value count passed in) to the instance (using timestamp).\\n * @method        $this            addUTCMillisecond()                                                                Add one millisecond to the instance (using timestamp).\\n * @method        $this            subUTCMilliseconds(int|float $value = 1)                                           Sub milliseconds (the $value count passed in) to the instance (using timestamp).\\n * @method        $this            subUTCMillisecond()                                                                Sub one millisecond to the instance (using timestamp).\\n * @method        CarbonPeriod     millisecondsUntil($endDate = null, int|float $factor = 1)                          Return an iterable period from current date to given end (string, DateTime or Carbon instance) for each millisecond or every X milliseconds if a factor is given.\\n * @method        float            diffInUTCMilliseconds(DateTimeInterface|string|null $date, bool $absolute = false) Convert current and given date in UTC timezone and return a floating number of milliseconds.\\n * @method        $this            addUTCSeconds(int|float $value = 1)                                                Add seconds (the $value count passed in) to the instance (using timestamp).\\n * @method        $this            addUTCSecond()                                                                     Add one second to the instance (using timestamp).\\n * @method        $this            subUTCSeconds(int|float $value = 1)                                                Sub seconds (the $value count passed in) to the instance (using timestamp).\\n * @method        $this            subUTCSecond()                                                                     Sub one second to the instance (using timestamp).\\n * @method        CarbonPeriod     secondsUntil($endDate = null, int|float $factor = 1)                               Return an iterable period from current date to given end (string, DateTime or Carbon instance) for each second or every X seconds if a factor is given.\\n * @method        float            diffInUTCSeconds(DateTimeInterface|string|null $date, bool $absolute = false)      Convert current and given date in UTC timezone and return a floating number of seconds.\\n * @method        $this            addUTCMinutes(int|float $value = 1)                                                Add minutes (the $value count passed in) to the instance (using timestamp).\\n * @method        $this            addUTCMinute()                                                                     Add one minute to the instance (using timestamp).\\n * @method        $this            subUTCMinutes(int|float $value = 1)                                                Sub minutes (the $value count passed in) to the instance (using timestamp).\\n * @method        $this            subUTCMinute()                                                                     Sub one minute to the instance (using timestamp).\\n * @method        CarbonPeriod     minutesUntil($endDate = null, int|float $factor = 1)                               Return an iterable period from current date to given end (string, DateTime or Carbon instance) for each minute or every X minutes if a factor is given.\\n * @method        float            diffInUTCMinutes(DateTimeInterface|string|null $date, bool $absolute = false)      Convert current and given date in UTC timezone and return a floating number of minutes.\\n * @method        $this            addUTCHours(int|float $value = 1)                                                  Add hours (the $value count passed in) to the instance (using timestamp).\\n * @method        $this            addUTCHour()                                                                       Add one hour to the instance (using timestamp).\\n * @method        $this            subUTCHours(int|float $value = 1)                                                  Sub hours (the $value count passed in) to the instance (using timestamp).\\n * @method        $this            subUTCHour()                                                                       Sub one hour to the instance (using timestamp).\\n * @method        CarbonPeriod     hoursUntil($endDate = null, int|float $factor = 1)                                 Return an iterable period from current date to given end (string, DateTime or Carbon instance) for each hour or every X hours if a factor is given.\\n * @method        float            diffInUTCHours(DateTimeInterface|string|null $date, bool $absolute = false)        Convert current and given date in UTC timezone and return a floating number of hours.\\n * @method        $this            addUTCDays(int|float $value = 1)                                                   Add days (the $value count passed in) to the instance (using timestamp).\\n * @method        $this            addUTCDay()                                                                        Add one day to the instance (using timestamp).\\n * @method        $this            subUTCDays(int|float $value = 1)                                                   Sub days (the $value count passed in) to the instance (using timestamp).\\n * @method        $this            subUTCDay()                                                                        Sub one day to the instance (using timestamp).\\n * @method        CarbonPeriod     daysUntil($endDate = null, int|float $factor = 1)                                  Return an iterable period from current date to given end (string, DateTime or Carbon instance) for each day or every X days if a factor is given.\\n * @method        float            diffInUTCDays(DateTimeInterface|string|null $date, bool $absolute = false)         Convert current and given date in UTC timezone and return a floating number of days.\\n * @method        $this            addUTCWeeks(int|float $value = 1)                                                  Add weeks (the $value count passed in) to the instance (using timestamp).\\n * @method        $this            addUTCWeek()                                                                       Add one week to the instance (using timestamp).\\n * @method        $this            subUTCWeeks(int|float $value = 1)                                                  Sub weeks (the $value count passed in) to the instance (using timestamp).\\n * @method        $this            subUTCWeek()                                                                       Sub one week to the instance (using timestamp).\\n * @method        CarbonPeriod     weeksUntil($endDate = null, int|float $factor = 1)                                 Return an iterable period from current date to given end (string, DateTime or Carbon instance) for each week or every X weeks if a factor is given.\\n * @method        float            diffInUTCWeeks(DateTimeInterface|string|null $date, bool $absolute = false)        Convert current and given date in UTC timezone and return a floating number of weeks.\\n * @method        $this            addUTCMonths(int|float $value = 1)                                                 Add months (the $value count passed in) to the instance (using timestamp).\\n * @method        $this            addUTCMonth()                                                                      Add one month to the instance (using timestamp).\\n * @method        $this            subUTCMonths(int|float $value = 1)                                                 Sub months (the $value count passed in) to the instance (using timestamp).\\n * @method        $this            subUTCMonth()                                                                      Sub one month to the instance (using timestamp).\\n * @method        CarbonPeriod     monthsUntil($endDate = null, int|float $factor = 1)                                Return an iterable period from current date to given end (string, DateTime or Carbon instance) for each month or every X months if a factor is given.\\n * @method        float            diffInUTCMonths(DateTimeInterface|string|null $date, bool $absolute = false)       Convert current and given date in UTC timezone and return a floating number of months.\\n * @method        $this            addUTCQuarters(int|float $value = 1)                                               Add quarters (the $value count passed in) to the instance (using timestamp).\\n * @method        $this            addUTCQuarter()                                                                    Add one quarter to the instance (using timestamp).\\n * @method        $this            subUTCQuarters(int|float $value = 1)                                               Sub quarters (the $value count passed in) to the instance (using timestamp).\\n * @method        $this            subUTCQuarter()                                                                    Sub one quarter to the instance (using timestamp).\\n * @method        CarbonPeriod     quartersUntil($endDate = null, int|float $factor = 1)                              Return an iterable period from current date to given end (string, DateTime or Carbon instance) for each quarter or every X quarters if a factor is given.\\n * @method        float            diffInUTCQuarters(DateTimeInterface|string|null $date, bool $absolute = false)     Convert current and given date in UTC timezone and return a floating number of quarters.\\n * @method        $this            addUTCYears(int|float $value = 1)                                                  Add years (the $value count passed in) to the instance (using timestamp).\\n * @method        $this            addUTCYear()                                                                       Add one year to the instance (using timestamp).\\n * @method        $this            subUTCYears(int|float $value = 1)                                                  Sub years (the $value count passed in) to the instance (using timestamp).\\n * @method        $this            subUTCYear()                                                                       Sub one year to the instance (using timestamp).\\n * @method        CarbonPeriod     yearsUntil($endDate = null, int|float $factor = 1)                                 Return an iterable period from current date to given end (string, DateTime or Carbon instance) for each year or every X years if a factor is given.\\n * @method        float            diffInUTCYears(DateTimeInterface|string|null $date, bool $absolute = false)        Convert current and given date in UTC timezone and return a floating number of years.\\n * @method        $this            addUTCDecades(int|float $value = 1)                                                Add decades (the $value count passed in) to the instance (using timestamp).\\n * @method        $this            addUTCDecade()                                                                     Add one decade to the instance (using timestamp).\\n * @method        $this            subUTCDecades(int|float $value = 1)                                                Sub decades (the $value count passed in) to the instance (using timestamp).\\n * @method        $this            subUTCDecade()                                                                     Sub one decade to the instance (using timestamp).\\n * @method        CarbonPeriod     decadesUntil($endDate = null, int|float $factor = 1)                               Return an iterable period from current date to given end (string, DateTime or Carbon instance) for each decade or every X decades if a factor is given.\\n * @method        float            diffInUTCDecades(DateTimeInterface|string|null $date, bool $absolute = false)      Convert current and given date in UTC timezone and return a floating number of decades.\\n * @method        $this            addUTCCenturies(int|float $value = 1)                                              Add centuries (the $value count passed in) to the instance (using timestamp).\\n * @method        $this            addUTCCentury()                                                                    Add one century to the instance (using timestamp).\\n * @method        $this            subUTCCenturies(int|float $value = 1)                                              Sub centuries (the $value count passed in) to the instance (using timestamp).\\n * @method        $this            subUTCCentury()                                                                    Sub one century to the instance (using timestamp).\\n * @method        CarbonPeriod     centuriesUntil($endDate = null, int|float $factor = 1)                             Return an iterable period from current date to given end (string, DateTime or Carbon instance) for each century or every X centuries if a factor is given.\\n * @method        float            diffInUTCCenturies(DateTimeInterface|string|null $date, bool $absolute = false)    Convert current and given date in UTC timezone and return a floating number of centuries.\\n * @method        $this            addUTCMillennia(int|float $value = 1)                                              Add millennia (the $value count passed in) to the instance (using timestamp).\\n * @method        $this            addUTCMillennium()                                                                 Add one millennium to the instance (using timestamp).\\n * @method        $this            subUTCMillennia(int|float $value = 1)                                              Sub millennia (the $value count passed in) to the instance (using timestamp).\\n * @method        $this            subUTCMillennium()                                                                 Sub one millennium to the instance (using timestamp).\\n * @method        CarbonPeriod     millenniaUntil($endDate = null, int|float $factor = 1)                             Return an iterable period from current date to given end (string, DateTime or Carbon instance) for each millennium or every X millennia if a factor is given.\\n * @method        float            diffInUTCMillennia(DateTimeInterface|string|null $date, bool $absolute = false)    Convert current and given date in UTC timezone and return a floating number of millennia.\\n * @method        $this            roundYear(float $precision = 1, string $function = \\\"round\\\")                        Round the current instance year with given precision using the given function.\\n * @method        $this            roundYears(float $precision = 1, string $function = \\\"round\\\")                       Round the current instance year with given precision using the given function.\\n * @method        $this            floorYear(float $precision = 1)                                                    Truncate the current instance year with given precision.\\n * @method        $this            floorYears(float $precision = 1)                                                   Truncate the current instance year with given precision.\\n * @method        $this            ceilYear(float $precision = 1)                                                     Ceil the current instance year with given precision.\\n * @method        $this            ceilYears(float $precision = 1)                                                    Ceil the current instance year with given precision.\\n * @method        $this            roundMonth(float $precision = 1, string $function = \\\"round\\\")                       Round the current instance month with given precision using the given function.\\n * @method        $this            roundMonths(float $precision = 1, string $function = \\\"round\\\")                      Round the current instance month with given precision using the given function.\\n * @method        $this            floorMonth(float $precision = 1)                                                   Truncate the current instance month with given precision.\\n * @method        $this            floorMonths(float $precision = 1)                                                  Truncate the current instance month with given precision.\\n * @method        $this            ceilMonth(float $precision = 1)                                                    Ceil the current instance month with given precision.\\n * @method        $this            ceilMonths(float $precision = 1)                                                   Ceil the current instance month with given precision.\\n * @method        $this            roundDay(float $precision = 1, string $function = \\\"round\\\")                         Round the current instance day with given precision using the given function.\\n * @method        $this            roundDays(float $precision = 1, string $function = \\\"round\\\")                        Round the current instance day with given precision using the given function.\\n * @method        $this            floorDay(float $precision = 1)                                                     Truncate the current instance day with given precision.\\n * @method        $this            floorDays(float $precision = 1)                                                    Truncate the current instance day with given precision.\\n * @method        $this            ceilDay(float $precision = 1)                                                      Ceil the current instance day with given precision.\\n * @method        $this            ceilDays(float $precision = 1)                                                     Ceil the current instance day with given precision.\\n * @method        $this            roundHour(float $precision = 1, string $function = \\\"round\\\")                        Round the current instance hour with given precision using the given function.\\n * @method        $this            roundHours(float $precision = 1, string $function = \\\"round\\\")                       Round the current instance hour with given precision using the given function.\\n * @method        $this            floorHour(float $precision = 1)                                                    Truncate the current instance hour with given precision.\\n * @method        $this            floorHours(float $precision = 1)                                                   Truncate the current instance hour with given precision.\\n * @method        $this            ceilHour(float $precision = 1)                                                     Ceil the current instance hour with given precision.\\n * @method        $this            ceilHours(float $precision = 1)                                                    Ceil the current instance hour with given precision.\\n * @method        $this            roundMinute(float $precision = 1, string $function = \\\"round\\\")                      Round the current instance minute with given precision using the given function.\\n * @method        $this            roundMinutes(float $precision = 1, string $function = \\\"round\\\")                     Round the current instance minute with given precision using the given function.\\n * @method        $this            floorMinute(float $precision = 1)                                                  Truncate the current instance minute with given precision.\\n * @method        $this            floorMinutes(float $precision = 1)                                                 Truncate the current instance minute with given precision.\\n * @method        $this            ceilMinute(float $precision = 1)                                                   Ceil the current instance minute with given precision.\\n * @method        $this            ceilMinutes(float $precision = 1)                                                  Ceil the current instance minute with given precision.\\n * @method        $this            roundSecond(float $precision = 1, string $function = \\\"round\\\")                      Round the current instance second with given precision using the given function.\\n * @method        $this            roundSeconds(float $precision = 1, string $function = \\\"round\\\")                     Round the current instance second with given precision using the given function.\\n * @method        $this            floorSecond(float $precision = 1)                                                  Truncate the current instance second with given precision.\\n * @method        $this            floorSeconds(float $precision = 1)                                                 Truncate the current instance second with given precision.\\n * @method        $this            ceilSecond(float $precision = 1)                                                   Ceil the current instance second with given precision.\\n * @method        $this            ceilSeconds(float $precision = 1)                                                  Ceil the current instance second with given precision.\\n * @method        $this            roundMillennium(float $precision = 1, string $function = \\\"round\\\")                  Round the current instance millennium with given precision using the given function.\\n * @method        $this            roundMillennia(float $precision = 1, string $function = \\\"round\\\")                   Round the current instance millennium with given precision using the given function.\\n * @method        $this            floorMillennium(float $precision = 1)                                              Truncate the current instance millennium with given precision.\\n * @method        $this            floorMillennia(float $precision = 1)                                               Truncate the current instance millennium with given precision.\\n * @method        $this            ceilMillennium(float $precision = 1)                                               Ceil the current instance millennium with given precision.\\n * @method        $this            ceilMillennia(float $precision = 1)                                                Ceil the current instance millennium with given precision.\\n * @method        $this            roundCentury(float $precision = 1, string $function = \\\"round\\\")                     Round the current instance century with given precision using the given function.\\n * @method        $this            roundCenturies(float $precision = 1, string $function = \\\"round\\\")                   Round the current instance century with given precision using the given function.\\n * @method        $this            floorCentury(float $precision = 1)                                                 Truncate the current instance century with given precision.\\n * @method        $this            floorCenturies(float $precision = 1)                                               Truncate the current instance century with given precision.\\n * @method        $this            ceilCentury(float $precision = 1)                                                  Ceil the current instance century with given precision.\\n * @method        $this            ceilCenturies(float $precision = 1)                                                Ceil the current instance century with given precision.\\n * @method        $this            roundDecade(float $precision = 1, string $function = \\\"round\\\")                      Round the current instance decade with given precision using the given function.\\n * @method        $this            roundDecades(float $precision = 1, string $function = \\\"round\\\")                     Round the current instance decade with given precision using the given function.\\n * @method        $this            floorDecade(float $precision = 1)                                                  Truncate the current instance decade with given precision.\\n * @method        $this            floorDecades(float $precision = 1)                                                 Truncate the current instance decade with given precision.\\n * @method        $this            ceilDecade(float $precision = 1)                                                   Ceil the current instance decade with given precision.\\n * @method        $this            ceilDecades(float $precision = 1)                                                  Ceil the current instance decade with given precision.\\n * @method        $this            roundQuarter(float $precision = 1, string $function = \\\"round\\\")                     Round the current instance quarter with given precision using the given function.\\n * @method        $this            roundQuarters(float $precision = 1, string $function = \\\"round\\\")                    Round the current instance quarter with given precision using the given function.\\n * @method        $this            floorQuarter(float $precision = 1)                                                 Truncate the current instance quarter with given precision.\\n * @method        $this            floorQuarters(float $precision = 1)                                                Truncate the current instance quarter with given precision.\\n * @method        $this            ceilQuarter(float $precision = 1)                                                  Ceil the current instance quarter with given precision.\\n * @method        $this            ceilQuarters(float $precision = 1)                                                 Ceil the current instance quarter with given precision.\\n * @method        $this            roundMillisecond(float $precision = 1, string $function = \\\"round\\\")                 Round the current instance millisecond with given precision using the given function.\\n * @method        $this            roundMilliseconds(float $precision = 1, string $function = \\\"round\\\")                Round the current instance millisecond with given precision using the given function.\\n * @method        $this            floorMillisecond(float $precision = 1)                                             Truncate the current instance millisecond with given precision.\\n * @method        $this            floorMilliseconds(float $precision = 1)                                            Truncate the current instance millisecond with given precision.\\n * @method        $this            ceilMillisecond(float $precision = 1)                                              Ceil the current instance millisecond with given precision.\\n * @method        $this            ceilMilliseconds(float $precision = 1)                                             Ceil the current instance millisecond with given precision.\\n * @method        $this            roundMicrosecond(float $precision = 1, string $function = \\\"round\\\")                 Round the current instance microsecond with given precision using the given function.\\n * @method        $this            roundMicroseconds(float $precision = 1, string $function = \\\"round\\\")                Round the current instance microsecond with given precision using the given function.\\n * @method        $this            floorMicrosecond(float $precision = 1)                                             Truncate the current instance microsecond with given precision.\\n * @method        $this            floorMicroseconds(float $precision = 1)                                            Truncate the current instance microsecond with given precision.\\n * @method        $this            ceilMicrosecond(float $precision = 1)                                              Ceil the current instance microsecond with given precision.\\n * @method        $this            ceilMicroseconds(float $precision = 1)                                             Ceil the current instance microsecond with given precision.\\n * @method        string           shortAbsoluteDiffForHumans(DateTimeInterface $other = null, int $parts = 1)        Get the difference (short format, 'Absolute' mode) in a human readable format in the current locale. ($other and $parts parameters can be swapped.)\\n * @method        string           longAbsoluteDiffForHumans(DateTimeInterface $other = null, int $parts = 1)         Get the difference (long format, 'Absolute' mode) in a human readable format in the current locale. ($other and $parts parameters can be swapped.)\\n * @method        string           shortRelativeDiffForHumans(DateTimeInterface $other = null, int $parts = 1)        Get the difference (short format, 'Relative' mode) in a human readable format in the current locale. ($other and $parts parameters can be swapped.)\\n * @method        string           longRelativeDiffForHumans(DateTimeInterface $other = null, int $parts = 1)         Get the difference (long format, 'Relative' mode) in a human readable format in the current locale. ($other and $parts parameters can be swapped.)\\n * @method        string           shortRelativeToNowDiffForHumans(DateTimeInterface $other = null, int $parts = 1)   Get the difference (short format, 'RelativeToNow' mode) in a human readable format in the current locale. ($other and $parts parameters can be swapped.)\\n * @method        string           longRelativeToNowDiffForHumans(DateTimeInterface $other = null, int $parts = 1)    Get the difference (long format, 'RelativeToNow' mode) in a human readable format in the current locale. ($other and $parts parameters can be swapped.)\\n * @method        string           shortRelativeToOtherDiffForHumans(DateTimeInterface $other = null, int $parts = 1) Get the difference (short format, 'RelativeToOther' mode) in a human readable format in the current locale. ($other and $parts parameters can be swapped.)\\n * @method        string           longRelativeToOtherDiffForHumans(DateTimeInterface $other = null, int $parts = 1)  Get the difference (long format, 'RelativeToOther' mode) in a human readable format in the current locale. ($other and $parts parameters can be swapped.)\\n * @method        int              centuriesInMillennium()                                                            Return the number of centuries contained in the current millennium\\n * @method        int|static       centuryOfMillennium(?int $century = null)                                          Return the value of the century starting from the beginning of the current millennium when called with no parameters, change the current century when called with an integer value\\n * @method        int|static       dayOfCentury(?int $day = null)                                                     Return the value of the day starting from the beginning of the current century when called with no parameters, change the current day when called with an integer value\\n * @method        int|static       dayOfDecade(?int $day = null)                                                      Return the value of the day starting from the beginning of the current decade when called with no parameters, change the current day when called with an integer value\\n * @method        int|static       dayOfMillennium(?int $day = null)                                                  Return the value of the day starting from the beginning of the current millennium when called with no parameters, change the current day when called with an integer value\\n * @method        int|static       dayOfMonth(?int $day = null)                                                       Return the value of the day starting from the beginning of the current month when called with no parameters, change the current day when called with an integer value\\n * @method        int|static       dayOfQuarter(?int $day = null)                                                     Return the value of the day starting from the beginning of the current quarter when called with no parameters, change the current day when called with an integer value\\n * @method        int|static       dayOfWeek(?int $day = null)                                                        Return the value of the day starting from the beginning of the current week when called with no parameters, change the current day when called with an integer value\\n * @method        int              daysInCentury()                                                                    Return the number of days contained in the current century\\n * @method        int              daysInDecade()                                                                     Return the number of days contained in the current decade\\n * @method        int              daysInMillennium()                                                                 Return the number of days contained in the current millennium\\n * @method        int              daysInMonth()                                                                      Return the number of days contained in the current month\\n * @method        int              daysInQuarter()                                                                    Return the number of days contained in the current quarter\\n * @method        int              daysInWeek()                                                                       Return the number of days contained in the current week\\n * @method        int              daysInYear()                                                                       Return the number of days contained in the current year\\n * @method        int|static       decadeOfCentury(?int $decade = null)                                               Return the value of the decade starting from the beginning of the current century when called with no parameters, change the current decade when called with an integer value\\n * @method        int|static       decadeOfMillennium(?int $decade = null)                                            Return the value of the decade starting from the beginning of the current millennium when called with no parameters, change the current decade when called with an integer value\\n * @method        int              decadesInCentury()                                                                 Return the number of decades contained in the current century\\n * @method        int              decadesInMillennium()                                                              Return the number of decades contained in the current millennium\\n * @method        int|static       hourOfCentury(?int $hour = null)                                                   Return the value of the hour starting from the beginning of the current century when called with no parameters, change the current hour when called with an integer value\\n * @method        int|static       hourOfDay(?int $hour = null)                                                       Return the value of the hour starting from the beginning of the current day when called with no parameters, change the current hour when called with an integer value\\n * @method        int|static       hourOfDecade(?int $hour = null)                                                    Return the value of the hour starting from the beginning of the current decade when called with no parameters, change the current hour when called with an integer value\\n * @method        int|static       hourOfMillennium(?int $hour = null)                                                Return the value of the hour starting from the beginning of the current millennium when called with no parameters, change the current hour when called with an integer value\\n * @method        int|static       hourOfMonth(?int $hour = null)                                                     Return the value of the hour starting from the beginning of the current month when called with no parameters, change the current hour when called with an integer value\\n * @method        int|static       hourOfQuarter(?int $hour = null)                                                   Return the value of the hour starting from the beginning of the current quarter when called with no parameters, change the current hour when called with an integer value\\n * @method        int|static       hourOfWeek(?int $hour = null)                                                      Return the value of the hour starting from the beginning of the current week when called with no parameters, change the current hour when called with an integer value\\n * @method        int|static       hourOfYear(?int $hour = null)                                                      Return the value of the hour starting from the beginning of the current year when called with no parameters, change the current hour when called with an integer value\\n * @method        int              hoursInCentury()                                                                   Return the number of hours contained in the current century\\n * @method        int              hoursInDay()                                                                       Return the number of hours contained in the current day\\n * @method        int              hoursInDecade()                                                                    Return the number of hours contained in the current decade\\n * @method        int              hoursInMillennium()                                                                Return the number of hours contained in the current millennium\\n * @method        int              hoursInMonth()                                                                     Return the number of hours contained in the current month\\n * @method        int              hoursInQuarter()                                                                   Return the number of hours contained in the current quarter\\n * @method        int              hoursInWeek()                                                                      Return the number of hours contained in the current week\\n * @method        int              hoursInYear()                                                                      Return the number of hours contained in the current year\\n * @method        int|static       microsecondOfCentury(?int $microsecond = null)                                     Return the value of the microsecond starting from the beginning of the current century when called with no parameters, change the current microsecond when called with an integer value\\n * @method        int|static       microsecondOfDay(?int $microsecond = null)                                         Return the value of the microsecond starting from the beginning of the current day when called with no parameters, change the current microsecond when called with an integer value\\n * @method        int|static       microsecondOfDecade(?int $microsecond = null)                                      Return the value of the microsecond starting from the beginning of the current decade when called with no parameters, change the current microsecond when called with an integer value\\n * @method        int|static       microsecondOfHour(?int $microsecond = null)                                        Return the value of the microsecond starting from the beginning of the current hour when called with no parameters, change the current microsecond when called with an integer value\\n * @method        int|static       microsecondOfMillennium(?int $microsecond = null)                                  Return the value of the microsecond starting from the beginning of the current millennium when called with no parameters, change the current microsecond when called with an integer value\\n * @method        int|static       microsecondOfMillisecond(?int $microsecond = null)                                 Return the value of the microsecond starting from the beginning of the current millisecond when called with no parameters, change the current microsecond when called with an integer value\\n * @method        int|static       microsecondOfMinute(?int $microsecond = null)                                      Return the value of the microsecond starting from the beginning of the current minute when called with no parameters, change the current microsecond when called with an integer value\\n * @method        int|static       microsecondOfMonth(?int $microsecond = null)                                       Return the value of the microsecond starting from the beginning of the current month when called with no parameters, change the current microsecond when called with an integer value\\n * @method        int|static       microsecondOfQuarter(?int $microsecond = null)                                     Return the value of the microsecond starting from the beginning of the current quarter when called with no parameters, change the current microsecond when called with an integer value\\n * @method        int|static       microsecondOfSecond(?int $microsecond = null)                                      Return the value of the microsecond starting from the beginning of the current second when called with no parameters, change the current microsecond when called with an integer value\\n * @method        int|static       microsecondOfWeek(?int $microsecond = null)                                        Return the value of the microsecond starting from the beginning of the current week when called with no parameters, change the current microsecond when called with an integer value\\n * @method        int|static       microsecondOfYear(?int $microsecond = null)                                        Return the value of the microsecond starting from the beginning of the current year when called with no parameters, change the current microsecond when called with an integer value\\n * @method        int              microsecondsInCentury()                                                            Return the number of microseconds contained in the current century\\n * @method        int              microsecondsInDay()                                                                Return the number of microseconds contained in the current day\\n * @method        int              microsecondsInDecade()                                                             Return the number of microseconds contained in the current decade\\n * @method        int              microsecondsInHour()                                                               Return the number of microseconds contained in the current hour\\n * @method        int              microsecondsInMillennium()                                                         Return the number of microseconds contained in the current millennium\\n * @method        int              microsecondsInMillisecond()                                                        Return the number of microseconds contained in the current millisecond\\n * @method        int              microsecondsInMinute()                                                             Return the number of microseconds contained in the current minute\\n * @method        int              microsecondsInMonth()                                                              Return the number of microseconds contained in the current month\\n * @method        int              microsecondsInQuarter()                                                            Return the number of microseconds contained in the current quarter\\n * @method        int              microsecondsInSecond()                                                             Return the number of microseconds contained in the current second\\n * @method        int              microsecondsInWeek()                                                               Return the number of microseconds contained in the current week\\n * @method        int              microsecondsInYear()                                                               Return the number of microseconds contained in the current year\\n * @method        int|static       millisecondOfCentury(?int $millisecond = null)                                     Return the value of the millisecond starting from the beginning of the current century when called with no parameters, change the current millisecond when called with an integer value\\n * @method        int|static       millisecondOfDay(?int $millisecond = null)                                         Return the value of the millisecond starting from the beginning of the current day when called with no parameters, change the current millisecond when called with an integer value\\n * @method        int|static       millisecondOfDecade(?int $millisecond = null)                                      Return the value of the millisecond starting from the beginning of the current decade when called with no parameters, change the current millisecond when called with an integer value\\n * @method        int|static       millisecondOfHour(?int $millisecond = null)                                        Return the value of the millisecond starting from the beginning of the current hour when called with no parameters, change the current millisecond when called with an integer value\\n * @method        int|static       millisecondOfMillennium(?int $millisecond = null)                                  Return the value of the millisecond starting from the beginning of the current millennium when called with no parameters, change the current millisecond when called with an integer value\\n * @method        int|static       millisecondOfMinute(?int $millisecond = null)                                      Return the value of the millisecond starting from the beginning of the current minute when called with no parameters, change the current millisecond when called with an integer value\\n * @method        int|static       millisecondOfMonth(?int $millisecond = null)                                       Return the value of the millisecond starting from the beginning of the current month when called with no parameters, change the current millisecond when called with an integer value\\n * @method        int|static       millisecondOfQuarter(?int $millisecond = null)                                     Return the value of the millisecond starting from the beginning of the current quarter when called with no parameters, change the current millisecond when called with an integer value\\n * @method        int|static       millisecondOfSecond(?int $millisecond = null)                                      Return the value of the millisecond starting from the beginning of the current second when called with no parameters, change the current millisecond when called with an integer value\\n * @method        int|static       millisecondOfWeek(?int $millisecond = null)                                        Return the value of the millisecond starting from the beginning of the current week when called with no parameters, change the current millisecond when called with an integer value\\n * @method        int|static       millisecondOfYear(?int $millisecond = null)                                        Return the value of the millisecond starting from the beginning of the current year when called with no parameters, change the current millisecond when called with an integer value\\n * @method        int              millisecondsInCentury()                                                            Return the number of milliseconds contained in the current century\\n * @method        int              millisecondsInDay()                                                                Return the number of milliseconds contained in the current day\\n * @method        int              millisecondsInDecade()                                                             Return the number of milliseconds contained in the current decade\\n * @method        int              millisecondsInHour()                                                               Return the number of milliseconds contained in the current hour\\n * @method        int              millisecondsInMillennium()                                                         Return the number of milliseconds contained in the current millennium\\n * @method        int              millisecondsInMinute()                                                             Return the number of milliseconds contained in the current minute\\n * @method        int              millisecondsInMonth()                                                              Return the number of milliseconds contained in the current month\\n * @method        int              millisecondsInQuarter()                                                            Return the number of milliseconds contained in the current quarter\\n * @method        int              millisecondsInSecond()                                                             Return the number of milliseconds contained in the current second\\n * @method        int              millisecondsInWeek()                                                               Return the number of milliseconds contained in the current week\\n * @method        int              millisecondsInYear()                                                               Return the number of milliseconds contained in the current year\\n * @method        int|static       minuteOfCentury(?int $minute = null)                                               Return the value of the minute starting from the beginning of the current century when called with no parameters, change the current minute when called with an integer value\\n * @method        int|static       minuteOfDay(?int $minute = null)                                                   Return the value of the minute starting from the beginning of the current day when called with no parameters, change the current minute when called with an integer value\\n * @method        int|static       minuteOfDecade(?int $minute = null)                                                Return the value of the minute starting from the beginning of the current decade when called with no parameters, change the current minute when called with an integer value\\n * @method        int|static       minuteOfHour(?int $minute = null)                                                  Return the value of the minute starting from the beginning of the current hour when called with no parameters, change the current minute when called with an integer value\\n * @method        int|static       minuteOfMillennium(?int $minute = null)                                            Return the value of the minute starting from the beginning of the current millennium when called with no parameters, change the current minute when called with an integer value\\n * @method        int|static       minuteOfMonth(?int $minute = null)                                                 Return the value of the minute starting from the beginning of the current month when called with no parameters, change the current minute when called with an integer value\\n * @method        int|static       minuteOfQuarter(?int $minute = null)                                               Return the value of the minute starting from the beginning of the current quarter when called with no parameters, change the current minute when called with an integer value\\n * @method        int|static       minuteOfWeek(?int $minute = null)                                                  Return the value of the minute starting from the beginning of the current week when called with no parameters, change the current minute when called with an integer value\\n * @method        int|static       minuteOfYear(?int $minute = null)                                                  Return the value of the minute starting from the beginning of the current year when called with no parameters, change the current minute when called with an integer value\\n * @method        int              minutesInCentury()                                                                 Return the number of minutes contained in the current century\\n * @method        int              minutesInDay()                                                                     Return the number of minutes contained in the current day\\n * @method        int              minutesInDecade()                                                                  Return the number of minutes contained in the current decade\\n * @method        int              minutesInHour()                                                                    Return the number of minutes contained in the current hour\\n * @method        int              minutesInMillennium()                                                              Return the number of minutes contained in the current millennium\\n * @method        int              minutesInMonth()                                                                   Return the number of minutes contained in the current month\\n * @method        int              minutesInQuarter()                                                                 Return the number of minutes contained in the current quarter\\n * @method        int              minutesInWeek()                                                                    Return the number of minutes contained in the current week\\n * @method        int              minutesInYear()                                                                    Return the number of minutes contained in the current year\\n * @method        int|static       monthOfCentury(?int $month = null)                                                 Return the value of the month starting from the beginning of the current century when called with no parameters, change the current month when called with an integer value\\n * @method        int|static       monthOfDecade(?int $month = null)                                                  Return the value of the month starting from the beginning of the current decade when called with no parameters, change the current month when called with an integer value\\n * @method        int|static       monthOfMillennium(?int $month = null)                                              Return the value of the month starting from the beginning of the current millennium when called with no parameters, change the current month when called with an integer value\\n * @method        int|static       monthOfQuarter(?int $month = null)                                                 Return the value of the month starting from the beginning of the current quarter when called with no parameters, change the current month when called with an integer value\\n * @method        int|static       monthOfYear(?int $month = null)                                                    Return the value of the month starting from the beginning of the current year when called with no parameters, change the current month when called with an integer value\\n * @method        int              monthsInCentury()                                                                  Return the number of months contained in the current century\\n * @method        int              monthsInDecade()                                                                   Return the number of months contained in the current decade\\n * @method        int              monthsInMillennium()                                                               Return the number of months contained in the current millennium\\n * @method        int              monthsInQuarter()                                                                  Return the number of months contained in the current quarter\\n * @method        int              monthsInYear()                                                                     Return the number of months contained in the current year\\n * @method        int|static       quarterOfCentury(?int $quarter = null)                                             Return the value of the quarter starting from the beginning of the current century when called with no parameters, change the current quarter when called with an integer value\\n * @method        int|static       quarterOfDecade(?int $quarter = null)                                              Return the value of the quarter starting from the beginning of the current decade when called with no parameters, change the current quarter when called with an integer value\\n * @method        int|static       quarterOfMillennium(?int $quarter = null)                                          Return the value of the quarter starting from the beginning of the current millennium when called with no parameters, change the current quarter when called with an integer value\\n * @method        int|static       quarterOfYear(?int $quarter = null)                                                Return the value of the quarter starting from the beginning of the current year when called with no parameters, change the current quarter when called with an integer value\\n * @method        int              quartersInCentury()                                                                Return the number of quarters contained in the current century\\n * @method        int              quartersInDecade()                                                                 Return the number of quarters contained in the current decade\\n * @method        int              quartersInMillennium()                                                             Return the number of quarters contained in the current millennium\\n * @method        int              quartersInYear()                                                                   Return the number of quarters contained in the current year\\n * @method        int|static       secondOfCentury(?int $second = null)                                               Return the value of the second starting from the beginning of the current century when called with no parameters, change the current second when called with an integer value\\n * @method        int|static       secondOfDay(?int $second = null)                                                   Return the value of the second starting from the beginning of the current day when called with no parameters, change the current second when called with an integer value\\n * @method        int|static       secondOfDecade(?int $second = null)                                                Return the value of the second starting from the beginning of the current decade when called with no parameters, change the current second when called with an integer value\\n * @method        int|static       secondOfHour(?int $second = null)                                                  Return the value of the second starting from the beginning of the current hour when called with no parameters, change the current second when called with an integer value\\n * @method        int|static       secondOfMillennium(?int $second = null)                                            Return the value of the second starting from the beginning of the current millennium when called with no parameters, change the current second when called with an integer value\\n * @method        int|static       secondOfMinute(?int $second = null)                                                Return the value of the second starting from the beginning of the current minute when called with no parameters, change the current second when called with an integer value\\n * @method        int|static       secondOfMonth(?int $second = null)                                                 Return the value of the second starting from the beginning of the current month when called with no parameters, change the current second when called with an integer value\\n * @method        int|static       secondOfQuarter(?int $second = null)                                               Return the value of the second starting from the beginning of the current quarter when called with no parameters, change the current second when called with an integer value\\n * @method        int|static       secondOfWeek(?int $second = null)                                                  Return the value of the second starting from the beginning of the current week when called with no parameters, change the current second when called with an integer value\\n * @method        int|static       secondOfYear(?int $second = null)                                                  Return the value of the second starting from the beginning of the current year when called with no parameters, change the current second when called with an integer value\\n * @method        int              secondsInCentury()                                                                 Return the number of seconds contained in the current century\\n * @method        int              secondsInDay()                                                                     Return the number of seconds contained in the current day\\n * @method        int              secondsInDecade()                                                                  Return the number of seconds contained in the current decade\\n * @method        int              secondsInHour()                                                                    Return the number of seconds contained in the current hour\\n * @method        int              secondsInMillennium()                                                              Return the number of seconds contained in the current millennium\\n * @method        int              secondsInMinute()                                                                  Return the number of seconds contained in the current minute\\n * @method        int              secondsInMonth()                                                                   Return the number of seconds contained in the current month\\n * @method        int              secondsInQuarter()                                                                 Return the number of seconds contained in the current quarter\\n * @method        int              secondsInWeek()                                                                    Return the number of seconds contained in the current week\\n * @method        int              secondsInYear()                                                                    Return the number of seconds contained in the current year\\n * @method        int|static       weekOfCentury(?int $week = null)                                                   Return the value of the week starting from the beginning of the current century when called with no parameters, change the current week when called with an integer value\\n * @method        int|static       weekOfDecade(?int $week = null)                                                    Return the value of the week starting from the beginning of the current decade when called with no parameters, change the current week when called with an integer value\\n * @method        int|static       weekOfMillennium(?int $week = null)                                                Return the value of the week starting from the beginning of the current millennium when called with no parameters, change the current week when called with an integer value\\n * @method        int|static       weekOfMonth(?int $week = null)                                                     Return the value of the week starting from the beginning of the current month when called with no parameters, change the current week when called with an integer value\\n * @method        int|static       weekOfQuarter(?int $week = null)                                                   Return the value of the week starting from the beginning of the current quarter when called with no parameters, change the current week when called with an integer value\\n * @method        int|static       weekOfYear(?int $week = null)                                                      Return the value of the week starting from the beginning of the current year when called with no parameters, change the current week when called with an integer value\\n * @method        int              weeksInCentury()                                                                   Return the number of weeks contained in the current century\\n * @method        int              weeksInDecade()                                                                    Return the number of weeks contained in the current decade\\n * @method        int              weeksInMillennium()                                                                Return the number of weeks contained in the current millennium\\n * @method        int              weeksInMonth()                                                                     Return the number of weeks contained in the current month\\n * @method        int              weeksInQuarter()                                                                   Return the number of weeks contained in the current quarter\\n * @method        int|static       yearOfCentury(?int $year = null)                                                   Return the value of the year starting from the beginning of the current century when called with no parameters, change the current year when called with an integer value\\n * @method        int|static       yearOfDecade(?int $year = null)                                                    Return the value of the year starting from the beginning of the current decade when called with no parameters, change the current year when called with an integer value\\n * @method        int|static       yearOfMillennium(?int $year = null)                                                Return the value of the year starting from the beginning of the current millennium when called with no parameters, change the current year when called with an integer value\\n * @method        int              yearsInCentury()                                                                   Return the number of years contained in the current century\\n * @method        int              yearsInDecade()                                                                    Return the number of years contained in the current decade\\n * @method        int              yearsInMillennium()                                                                Return the number of years contained in the current millennium\\n *\\n * <\/autodoc>\\n *\/\\nclass Carbon extends DateTime implements CarbonInterface\\n{\\n    use Date;\\n\\n    \/**\\n     * Returns true if the current class\/instance is mutable.\\n     *\/\\n    public static function isMutable(): bool\\n    {\\n        return true;\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Laravel\/ServiceProvider.php\",\"ext\":\"php\",\"size\":4720,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon\\\\Laravel;\\n\\nuse Carbon\\\\Carbon;\\nuse Carbon\\\\CarbonImmutable;\\nuse Carbon\\\\CarbonInterval;\\nuse Carbon\\\\CarbonPeriod;\\nuse Illuminate\\\\Contracts\\\\Events\\\\Dispatcher as DispatcherContract;\\nuse Illuminate\\\\Events\\\\Dispatcher;\\nuse Illuminate\\\\Events\\\\EventDispatcher;\\nuse Illuminate\\\\Support\\\\Carbon as IlluminateCarbon;\\nuse Illuminate\\\\Support\\\\Facades\\\\Date;\\nuse Throwable;\\n\\nclass ServiceProvider extends \\\\Illuminate\\\\Support\\\\ServiceProvider\\n{\\n    \/** @var callable|null *\/\\n    protected $appGetter = null;\\n\\n    \/** @var callable|null *\/\\n    protected $localeGetter = null;\\n\\n    \/** @var callable|null *\/\\n    protected $fallbackLocaleGetter = null;\\n\\n    public function setAppGetter(?callable $appGetter): void\\n    {\\n        $this->appGetter = $appGetter;\\n    }\\n\\n    public function setLocaleGetter(?callable $localeGetter): void\\n    {\\n        $this->localeGetter = $localeGetter;\\n    }\\n\\n    public function setFallbackLocaleGetter(?callable $fallbackLocaleGetter): void\\n    {\\n        $this->fallbackLocaleGetter = $fallbackLocaleGetter;\\n    }\\n\\n    public function boot()\\n    {\\n        $this->updateLocale();\\n        $this->updateFallbackLocale();\\n\\n        if (!$this->app->bound('events')) {\\n            return;\\n        }\\n\\n        $service = $this;\\n        $events = $this->app['events'];\\n\\n        if ($this->isEventDispatcher($events)) {\\n            $events->listen(class_exists('Illuminate\\\\Foundation\\\\Events\\\\LocaleUpdated') ? 'Illuminate\\\\Foundation\\\\Events\\\\LocaleUpdated' : 'locale.changed', function () use ($service) {\\n                $service->updateLocale();\\n            });\\n        }\\n    }\\n\\n    public function updateLocale()\\n    {\\n        $locale = $this->getLocale();\\n\\n        if ($locale === null) {\\n            return;\\n        }\\n\\n        Carbon::setLocale($locale);\\n        CarbonImmutable::setLocale($locale);\\n        CarbonPeriod::setLocale($locale);\\n        CarbonInterval::setLocale($locale);\\n\\n        if (class_exists(IlluminateCarbon::class)) {\\n            IlluminateCarbon::setLocale($locale);\\n        }\\n\\n        if (class_exists(Date::class)) {\\n            try {\\n                $root = Date::getFacadeRoot();\\n                $root->setLocale($locale);\\n            } catch (Throwable) {\\n                \/\/ Non Carbon class in use in Date facade\\n            }\\n        }\\n    }\\n\\n    public function updateFallbackLocale()\\n    {\\n        $locale = $this->getFallbackLocale();\\n\\n        if ($locale === null) {\\n            return;\\n        }\\n\\n        Carbon::setFallbackLocale($locale);\\n        CarbonImmutable::setFallbackLocale($locale);\\n        CarbonPeriod::setFallbackLocale($locale);\\n        CarbonInterval::setFallbackLocale($locale);\\n\\n        if (class_exists(IlluminateCarbon::class) && method_exists(IlluminateCarbon::class, 'setFallbackLocale')) {\\n            IlluminateCarbon::setFallbackLocale($locale);\\n        }\\n\\n        if (class_exists(Date::class)) {\\n            try {\\n                $root = Date::getFacadeRoot();\\n                $root->setFallbackLocale($locale);\\n            } catch (Throwable) { \/\/ @codeCoverageIgnore\\n                \/\/ Non Carbon class in use in Date facade\\n            }\\n        }\\n    }\\n\\n    public function register()\\n    {\\n        \/\/ Needed for Laravel < 5.3 compatibility\\n    }\\n\\n    protected function getLocale()\\n    {\\n        if ($this->localeGetter) {\\n            return ($this->localeGetter)();\\n        }\\n\\n        $app = $this->getApp();\\n        $app = $app && method_exists($app, 'getLocale')\\n            ? $app\\n            : $this->getGlobalApp('translator');\\n\\n        return $app ? $app->getLocale() : null;\\n    }\\n\\n    protected function getFallbackLocale()\\n    {\\n        if ($this->fallbackLocaleGetter) {\\n            return ($this->fallbackLocaleGetter)();\\n        }\\n\\n        $app = $this->getApp();\\n\\n        return $app && method_exists($app, 'getFallbackLocale')\\n            ? $app->getFallbackLocale()\\n            : $this->getGlobalApp('translator')?->getFallback();\\n    }\\n\\n    protected function getApp()\\n    {\\n        if ($this->appGetter) {\\n            return ($this->appGetter)();\\n        }\\n\\n        return $this->app ?? $this->getGlobalApp();\\n    }\\n\\n    protected function getGlobalApp(...$args)\\n    {\\n        return \\\\function_exists('app') ? \\\\app(...$args) : null;\\n    }\\n\\n    protected function isEventDispatcher($instance)\\n    {\\n        return $instance instanceof EventDispatcher\\n            || $instance instanceof Dispatcher\\n            || $instance instanceof DispatcherContract;\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/WrapperClock.php\",\"ext\":\"php\",\"size\":5210,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon;\\n\\nuse DateTime;\\nuse DateTimeImmutable;\\nuse DateTimeInterface;\\nuse DateTimeZone;\\nuse Psr\\\\Clock\\\\ClockInterface as PsrClockInterface;\\nuse RuntimeException;\\nuse Symfony\\\\Component\\\\Clock\\\\ClockInterface;\\n\\nfinal class WrapperClock implements ClockInterface\\n{\\n    public function __construct(\\n        private PsrClockInterface|Factory|DateTimeInterface $currentClock,\\n    ) {\\n    }\\n\\n    public function unwrap(): PsrClockInterface|Factory|DateTimeInterface\\n    {\\n        return $this->currentClock;\\n    }\\n\\n    public function getFactory(): Factory\\n    {\\n        if ($this->currentClock instanceof Factory) {\\n            return $this->currentClock;\\n        }\\n\\n        if ($this->currentClock instanceof DateTime) {\\n            $factory = new Factory();\\n            $factory->setTestNowAndTimezone($this->currentClock);\\n\\n            return $factory;\\n        }\\n\\n        if ($this->currentClock instanceof DateTimeImmutable) {\\n            $factory = new FactoryImmutable();\\n            $factory->setTestNowAndTimezone($this->currentClock);\\n\\n            return $factory;\\n        }\\n\\n        $factory = new FactoryImmutable();\\n        $factory->setTestNowAndTimezone(fn () => $this->currentClock->now());\\n\\n        return $factory;\\n    }\\n\\n    private function nowRaw(): DateTimeInterface\\n    {\\n        if ($this->currentClock instanceof DateTimeInterface) {\\n            return $this->currentClock;\\n        }\\n\\n        if ($this->currentClock instanceof Factory) {\\n            return $this->currentClock->__call('now', []);\\n        }\\n\\n        return $this->currentClock->now();\\n    }\\n\\n    public function now(): DateTimeImmutable\\n    {\\n        $now = $this->nowRaw();\\n\\n        return $now instanceof DateTimeImmutable\\n            ? $now\\n            : new CarbonImmutable($now);\\n    }\\n\\n    \/**\\n     * @template T of CarbonInterface\\n     *\\n     * @param class-string<T> $class\\n     *\\n     * @return T\\n     *\/\\n    public function nowAs(string $class, DateTimeZone|string|int|null $timezone = null): CarbonInterface\\n    {\\n        $now = $this->nowRaw();\\n        $date = $now instanceof $class ? $now : $class::instance($now);\\n\\n        return $timezone === null ? $date : $date->setTimezone($timezone);\\n    }\\n\\n    public function nowAsCarbon(DateTimeZone|string|int|null $timezone = null): CarbonInterface\\n    {\\n        $now = $this->nowRaw();\\n\\n        return $now instanceof CarbonInterface\\n            ? ($timezone === null ? $now : $now->setTimezone($timezone))\\n            : $this->dateAsCarbon($now, $timezone);\\n    }\\n\\n    private function dateAsCarbon(DateTimeInterface $date, DateTimeZone|string|int|null $timezone): CarbonInterface\\n    {\\n        return $date instanceof DateTimeImmutable\\n            ? new CarbonImmutable($date, $timezone)\\n            : new Carbon($date, $timezone);\\n    }\\n\\n    public function sleep(float|int $seconds): void\\n    {\\n        if ($seconds === 0 || $seconds === 0.0) {\\n            return;\\n        }\\n\\n        if ($seconds < 0) {\\n            throw new RuntimeException('Expected positive number of seconds, '.$seconds.' given');\\n        }\\n\\n        if ($this->currentClock instanceof DateTimeInterface) {\\n            $this->currentClock = $this->addSeconds($this->currentClock, $seconds);\\n\\n            return;\\n        }\\n\\n        if ($this->currentClock instanceof ClockInterface) {\\n            $this->currentClock->sleep($seconds);\\n\\n            return;\\n        }\\n\\n        $this->currentClock = $this->addSeconds($this->currentClock->now(), $seconds);\\n    }\\n\\n    public function withTimeZone(DateTimeZone|string $timezone): static\\n    {\\n        if ($this->currentClock instanceof ClockInterface) {\\n            return new self($this->currentClock->withTimeZone($timezone));\\n        }\\n\\n        $now = $this->currentClock instanceof DateTimeInterface\\n            ? $this->currentClock\\n            : $this->currentClock->now();\\n\\n        if (!($now instanceof DateTimeImmutable)) {\\n            $now = clone $now;\\n        }\\n\\n        if (\\\\is_string($timezone)) {\\n            $timezone = new DateTimeZone($timezone);\\n        }\\n\\n        return new self($now->setTimezone($timezone));\\n    }\\n\\n    private function addSeconds(DateTimeInterface $date, float|int $seconds): DateTimeInterface\\n    {\\n        $secondsPerHour = CarbonInterface::SECONDS_PER_MINUTE * CarbonInterface::MINUTES_PER_HOUR;\\n        $hours = number_format(\\n            floor($seconds \/ $secondsPerHour),\\n            thousands_separator: '',\\n        );\\n        $microseconds = number_format(\\n            ($seconds - $hours * $secondsPerHour) * CarbonInterface::MICROSECONDS_PER_SECOND,\\n            thousands_separator: '',\\n        );\\n\\n        if (!($date instanceof DateTimeImmutable)) {\\n            $date = clone $date;\\n        }\\n\\n        if ($hours !== '0') {\\n            $date = $date->modify(\\\"$hours hours\\\");\\n        }\\n\\n        if ($microseconds !== '0') {\\n            $date = $date->modify(\\\"$microseconds microseconds\\\");\\n        }\\n\\n        return $date;\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/PHPStan\/MacroExtension.php\",\"ext\":\"php\",\"size\":4173,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon\\\\PHPStan;\\n\\nuse Carbon\\\\CarbonInterface;\\nuse Carbon\\\\FactoryImmutable;\\nuse Closure;\\nuse InvalidArgumentException;\\nuse PHPStan\\\\Reflection\\\\ClassReflection;\\nuse PHPStan\\\\Reflection\\\\MethodReflection;\\nuse PHPStan\\\\Reflection\\\\MethodsClassReflectionExtension;\\nuse PHPStan\\\\Reflection\\\\ReflectionProvider;\\nuse PHPStan\\\\Type\\\\ClosureTypeFactory;\\nuse ReflectionFunction;\\nuse ReflectionMethod;\\nuse stdClass;\\nuse Throwable;\\n\\n\/**\\n * Class MacroExtension.\\n *\\n * @codeCoverageIgnore Pure PHPStan wrapper.\\n *\/\\nfinal class MacroExtension implements MethodsClassReflectionExtension\\n{\\n    \/**\\n     * @var ReflectionProvider\\n     *\/\\n    protected $reflectionProvider;\\n\\n    \/**\\n     * @var ClosureTypeFactory\\n     *\/\\n    protected $closureTypeFactory;\\n\\n    \/**\\n     * Extension constructor.\\n     *\\n     * @param ReflectionProvider $reflectionProvider\\n     * @param ClosureTypeFactory $closureTypeFactory\\n     *\/\\n    public function __construct(\\n        ReflectionProvider $reflectionProvider,\\n        ClosureTypeFactory $closureTypeFactory\\n    ) {\\n        $this->reflectionProvider = $reflectionProvider;\\n        $this->closureTypeFactory = $closureTypeFactory;\\n    }\\n\\n    \/**\\n     * {@inheritdoc}\\n     *\/\\n    public function hasMethod(ClassReflection $classReflection, string $methodName): bool\\n    {\\n        if (\\n            $classReflection->getName() !== CarbonInterface::class &&\\n            !$classReflection->isSubclassOf(CarbonInterface::class)\\n        ) {\\n            return false;\\n        }\\n\\n        $className = $classReflection->getName();\\n\\n        return \\\\is_callable([$className, 'hasMacro']) &&\\n            $className::hasMacro($methodName);\\n    }\\n\\n    \/**\\n     * {@inheritdoc}\\n     *\/\\n    public function getMethod(ClassReflection $classReflection, string $methodName): MethodReflection\\n    {\\n        $macros = FactoryImmutable::getDefaultInstance()->getSettings()['macros'] ?? [];\\n        $macro = $macros[$methodName] ?? throw new InvalidArgumentException(\\\"Macro '$methodName' not found\\\");\\n        $static = false;\\n        $final = false;\\n        $deprecated = false;\\n        $docComment = null;\\n\\n        if (\\\\is_array($macro) && \\\\count($macro) === 2 && \\\\is_string($macro[1])) {\\n            \\\\assert($macro[1] !== '');\\n\\n            $reflection = new ReflectionMethod($macro[0], $macro[1]);\\n            $closure = \\\\is_object($macro[0]) ? $reflection->getClosure($macro[0]) : $reflection->getClosure();\\n\\n            $static = $reflection->isStatic();\\n            $final = $reflection->isFinal();\\n            $deprecated = $reflection->isDeprecated();\\n            $docComment = $reflection->getDocComment() ?: null;\\n        } elseif (\\\\is_string($macro)) {\\n            $reflection = new ReflectionFunction($macro);\\n            $closure = $reflection->getClosure();\\n            $deprecated = $reflection->isDeprecated();\\n            $docComment = $reflection->getDocComment() ?: null;\\n        } elseif ($macro instanceof Closure) {\\n            $closure = $macro;\\n\\n            try {\\n                $boundClosure = Closure::bind($closure, new stdClass());\\n                $static = (!$boundClosure || (new ReflectionFunction($boundClosure))->getClosureThis() === null);\\n            } catch (Throwable) {\\n                $static = true;\\n            }\\n\\n            $reflection = new ReflectionFunction($macro);\\n            $deprecated = $reflection->isDeprecated();\\n            $docComment = $reflection->getDocComment() ?: null;\\n        }\\n\\n        if (!isset($closure)) {\\n            throw new InvalidArgumentException('Could not create reflection from the spec given'); \/\/ @codeCoverageIgnore\\n        }\\n\\n        $closureType = $this->closureTypeFactory->fromClosureObject($closure);\\n\\n        return new MacroMethodReflection(\\n            $classReflection,\\n            $methodName,\\n            $closureType,\\n            $static,\\n            $final,\\n            $deprecated,\\n            $docComment,\\n        );\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/PHPStan\/MacroMethodReflection.php\",\"ext\":\"php\",\"size\":2773,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon\\\\PHPStan;\\n\\nuse PHPStan\\\\Reflection\\\\ClassReflection;\\nuse PHPStan\\\\Reflection\\\\MethodReflection;\\nuse PHPStan\\\\Reflection\\\\ParametersAcceptor;\\nuse PHPStan\\\\TrinaryLogic;\\nuse PHPStan\\\\Type\\\\Type;\\n\\nuse function preg_match;\\n\\nclass MacroMethodReflection implements MethodReflection\\n{\\n    private ClassReflection $declaringClass;\\n    private string $methodName;\\n    private ParametersAcceptor $macroClosureType;\\n    private bool $static;\\n    private bool $final;\\n    private bool $deprecated;\\n    private ?string $docComment;\\n\\n    public function __construct(\\n        ClassReflection $declaringClass,\\n        string $methodName,\\n        ParametersAcceptor $macroClosureType,\\n        bool $static,\\n        bool $final,\\n        bool $deprecated,\\n        ?string $docComment\\n    ) {\\n        $this->declaringClass = $declaringClass;\\n        $this->methodName = $methodName;\\n        $this->macroClosureType = $macroClosureType;\\n        $this->static = $static;\\n        $this->final = $final;\\n        $this->deprecated = $deprecated;\\n        $this->docComment = $docComment;\\n    }\\n\\n    public function getDeclaringClass(): ClassReflection\\n    {\\n        return $this->declaringClass;\\n    }\\n\\n    public function isStatic(): bool\\n    {\\n        return $this->static;\\n    }\\n\\n    public function isPrivate(): bool\\n    {\\n        return false;\\n    }\\n\\n    public function isPublic(): bool\\n    {\\n        return true;\\n    }\\n\\n    public function getDocComment(): ?string\\n    {\\n        return $this->docComment;\\n    }\\n\\n    public function getName(): string\\n    {\\n        return $this->methodName;\\n    }\\n\\n    public function getPrototype(): \\\\PHPStan\\\\Reflection\\\\ClassMemberReflection\\n    {\\n        return $this;\\n    }\\n\\n    public function getVariants(): array\\n    {\\n        return [$this->macroClosureType];\\n    }\\n\\n    public function isDeprecated(): TrinaryLogic\\n    {\\n        return TrinaryLogic::createFromBoolean(\\n            $this->deprecated ||\\n            preg_match('\/@deprecated\/i', $this->getDocComment() ?: '')\\n        );\\n    }\\n\\n    public function getDeprecatedDescription(): ?string\\n    {\\n        return null;\\n    }\\n\\n    public function isFinal(): TrinaryLogic\\n    {\\n        return TrinaryLogic::createFromBoolean($this->final);\\n    }\\n\\n    public function isInternal(): TrinaryLogic\\n    {\\n        return TrinaryLogic::createNo();\\n    }\\n\\n    public function getThrowType(): ?Type\\n    {\\n        return null;\\n    }\\n\\n    public function hasSideEffects(): TrinaryLogic\\n    {\\n        return TrinaryLogic::createMaybe();\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/CarbonInterval.php\",\"ext\":\"php\",\"size\":126237,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon;\\n\\nuse Carbon\\\\Exceptions\\\\BadFluentConstructorException;\\nuse Carbon\\\\Exceptions\\\\BadFluentSetterException;\\nuse Carbon\\\\Exceptions\\\\InvalidCastException;\\nuse Carbon\\\\Exceptions\\\\InvalidFormatException;\\nuse Carbon\\\\Exceptions\\\\InvalidIntervalException;\\nuse Carbon\\\\Exceptions\\\\OutOfRangeException;\\nuse Carbon\\\\Exceptions\\\\ParseErrorException;\\nuse Carbon\\\\Exceptions\\\\UnitNotConfiguredException;\\nuse Carbon\\\\Exceptions\\\\UnknownGetterException;\\nuse Carbon\\\\Exceptions\\\\UnknownSetterException;\\nuse Carbon\\\\Exceptions\\\\UnknownUnitException;\\nuse Carbon\\\\Traits\\\\IntervalRounding;\\nuse Carbon\\\\Traits\\\\IntervalStep;\\nuse Carbon\\\\Traits\\\\LocalFactory;\\nuse Carbon\\\\Traits\\\\MagicParameter;\\nuse Carbon\\\\Traits\\\\Mixin;\\nuse Carbon\\\\Traits\\\\Options;\\nuse Carbon\\\\Traits\\\\ToStringFormat;\\nuse Closure;\\nuse DateInterval;\\nuse DateTime;\\nuse DateTimeInterface;\\nuse DateTimeZone;\\nuse Exception;\\nuse InvalidArgumentException;\\nuse ReflectionException;\\nuse ReturnTypeWillChange;\\nuse RuntimeException;\\nuse Symfony\\\\Contracts\\\\Translation\\\\TranslatorInterface;\\nuse Throwable;\\n\\n\/**\\n * A simple API extension for DateInterval.\\n * The implementation provides helpers to handle weeks but only days are saved.\\n * Weeks are calculated based on the total days of the current instance.\\n *\\n * @property int $years Year component of the current interval. (For P2Y6M, the value will be 2)\\n * @property int $months Month component of the current interval. (For P1Y6M10D, the value will be 6)\\n * @property int $weeks Week component of the current interval calculated from the days. (For P1Y6M17D, the value will be 2)\\n * @property int $dayz Day component of the current interval (weeks * 7 + days). (For P6M17DT20H, the value will be 17)\\n * @property int $hours Hour component of the current interval. (For P7DT20H5M, the value will be 20)\\n * @property int $minutes Minute component of the current interval. (For PT20H5M30S, the value will be 5)\\n * @property int $seconds Second component of the current interval. (CarbonInterval::minutes(2)->seconds(34)->microseconds(567_890)->seconds = 34)\\n * @property int $milliseconds Milliseconds component of the current interval. (CarbonInterval::seconds(34)->microseconds(567_890)->milliseconds = 567)\\n * @property int $microseconds Microseconds component of the current interval. (CarbonInterval::seconds(34)->microseconds(567_890)->microseconds = 567_890)\\n * @property int $microExcludeMilli Remaining microseconds without the milliseconds.\\n * @property int $dayzExcludeWeeks Total days remaining in the final week of the current instance (days % 7).\\n * @property int $daysExcludeWeeks alias of dayzExcludeWeeks\\n * @property-read float $totalYears Number of years equivalent to the interval. (For P1Y6M, the value will be 1.5)\\n * @property-read float $totalMonths Number of months equivalent to the interval. (For P1Y6M10D, the value will be ~12.357)\\n * @property-read float $totalWeeks Number of weeks equivalent to the interval. (For P6M17DT20H, the value will be ~26.548)\\n * @property-read float $totalDays Number of days equivalent to the interval. (For P17DT20H, the value will be ~17.833)\\n * @property-read float $totalDayz Alias for totalDays.\\n * @property-read float $totalHours Number of hours equivalent to the interval. (For P1DT20H5M, the value will be ~44.083)\\n * @property-read float $totalMinutes Number of minutes equivalent to the interval. (For PT20H5M30S, the value will be 1205.5)\\n * @property-read float $totalSeconds Number of seconds equivalent to the interval. (CarbonInterval::minutes(2)->seconds(34)->microseconds(567_890)->totalSeconds = 154.567_890)\\n * @property-read float $totalMilliseconds Number of milliseconds equivalent to the interval. (CarbonInterval::seconds(34)->microseconds(567_890)->totalMilliseconds = 34567.890)\\n * @property-read float $totalMicroseconds Number of microseconds equivalent to the interval. (CarbonInterval::seconds(34)->microseconds(567_890)->totalMicroseconds = 34567890)\\n * @property-read string $locale locale of the current instance\\n *\\n * @method static CarbonInterval years($years = 1) Create instance specifying a number of years or modify the number of years if called on an instance.\\n * @method static CarbonInterval year($years = 1) Alias for years()\\n * @method static CarbonInterval months($months = 1) Create instance specifying a number of months or modify the number of months if called on an instance.\\n * @method static CarbonInterval month($months = 1) Alias for months()\\n * @method static CarbonInterval weeks($weeks = 1) Create instance specifying a number of weeks or modify the number of weeks if called on an instance.\\n * @method static CarbonInterval week($weeks = 1) Alias for weeks()\\n * @method static CarbonInterval days($days = 1) Create instance specifying a number of days or modify the number of days if called on an instance.\\n * @method static CarbonInterval dayz($days = 1) Alias for days()\\n * @method static CarbonInterval daysExcludeWeeks($days = 1) Create instance specifying a number of days or modify the number of days (keeping the current number of weeks) if called on an instance.\\n * @method static CarbonInterval dayzExcludeWeeks($days = 1) Alias for daysExcludeWeeks()\\n * @method static CarbonInterval day($days = 1) Alias for days()\\n * @method static CarbonInterval hours($hours = 1) Create instance specifying a number of hours or modify the number of hours if called on an instance.\\n * @method static CarbonInterval hour($hours = 1) Alias for hours()\\n * @method static CarbonInterval minutes($minutes = 1) Create instance specifying a number of minutes or modify the number of minutes if called on an instance.\\n * @method static CarbonInterval minute($minutes = 1) Alias for minutes()\\n * @method static CarbonInterval seconds($seconds = 1) Create instance specifying a number of seconds or modify the number of seconds if called on an instance.\\n * @method static CarbonInterval second($seconds = 1) Alias for seconds()\\n * @method static CarbonInterval milliseconds($milliseconds = 1) Create instance specifying a number of milliseconds or modify the number of milliseconds if called on an instance.\\n * @method static CarbonInterval millisecond($milliseconds = 1) Alias for milliseconds()\\n * @method static CarbonInterval microseconds($microseconds = 1) Create instance specifying a number of microseconds or modify the number of microseconds if called on an instance.\\n * @method static CarbonInterval microsecond($microseconds = 1) Alias for microseconds()\\n * @method $this addYears(int $years) Add given number of years to the current interval\\n * @method $this subYears(int $years) Subtract given number of years to the current interval\\n * @method $this addMonths(int $months) Add given number of months to the current interval\\n * @method $this subMonths(int $months) Subtract given number of months to the current interval\\n * @method $this addWeeks(int|float $weeks) Add given number of weeks to the current interval\\n * @method $this subWeeks(int|float $weeks) Subtract given number of weeks to the current interval\\n * @method $this addDays(int|float $days) Add given number of days to the current interval\\n * @method $this subDays(int|float $days) Subtract given number of days to the current interval\\n * @method $this addHours(int|float $hours) Add given number of hours to the current interval\\n * @method $this subHours(int|float $hours) Subtract given number of hours to the current interval\\n * @method $this addMinutes(int|float $minutes) Add given number of minutes to the current interval\\n * @method $this subMinutes(int|float $minutes) Subtract given number of minutes to the current interval\\n * @method $this addSeconds(int|float $seconds) Add given number of seconds to the current interval\\n * @method $this subSeconds(int|float $seconds) Subtract given number of seconds to the current interval\\n * @method $this addMilliseconds(int|float $milliseconds) Add given number of milliseconds to the current interval\\n * @method $this subMilliseconds(int|float $milliseconds) Subtract given number of milliseconds to the current interval\\n * @method $this addMicroseconds(int|float $microseconds) Add given number of microseconds to the current interval\\n * @method $this subMicroseconds(int|float $microseconds) Subtract given number of microseconds to the current interval\\n * @method $this roundYear(int|float $precision = 1, string $function = \\\"round\\\") Round the current instance year with given precision using the given function.\\n * @method $this roundYears(int|float $precision = 1, string $function = \\\"round\\\") Round the current instance year with given precision using the given function.\\n * @method $this floorYear(int|float $precision = 1) Truncate the current instance year with given precision.\\n * @method $this floorYears(int|float $precision = 1) Truncate the current instance year with given precision.\\n * @method $this ceilYear(int|float $precision = 1) Ceil the current instance year with given precision.\\n * @method $this ceilYears(int|float $precision = 1) Ceil the current instance year with given precision.\\n * @method $this roundMonth(int|float $precision = 1, string $function = \\\"round\\\") Round the current instance month with given precision using the given function.\\n * @method $this roundMonths(int|float $precision = 1, string $function = \\\"round\\\") Round the current instance month with given precision using the given function.\\n * @method $this floorMonth(int|float $precision = 1) Truncate the current instance month with given precision.\\n * @method $this floorMonths(int|float $precision = 1) Truncate the current instance month with given precision.\\n * @method $this ceilMonth(int|float $precision = 1) Ceil the current instance month with given precision.\\n * @method $this ceilMonths(int|float $precision = 1) Ceil the current instance month with given precision.\\n * @method $this roundWeek(int|float $precision = 1, string $function = \\\"round\\\") Round the current instance day with given precision using the given function.\\n * @method $this roundWeeks(int|float $precision = 1, string $function = \\\"round\\\") Round the current instance day with given precision using the given function.\\n * @method $this floorWeek(int|float $precision = 1) Truncate the current instance day with given precision.\\n * @method $this floorWeeks(int|float $precision = 1) Truncate the current instance day with given precision.\\n * @method $this ceilWeek(int|float $precision = 1) Ceil the current instance day with given precision.\\n * @method $this ceilWeeks(int|float $precision = 1) Ceil the current instance day with given precision.\\n * @method $this roundDay(int|float $precision = 1, string $function = \\\"round\\\") Round the current instance day with given precision using the given function.\\n * @method $this roundDays(int|float $precision = 1, string $function = \\\"round\\\") Round the current instance day with given precision using the given function.\\n * @method $this floorDay(int|float $precision = 1) Truncate the current instance day with given precision.\\n * @method $this floorDays(int|float $precision = 1) Truncate the current instance day with given precision.\\n * @method $this ceilDay(int|float $precision = 1) Ceil the current instance day with given precision.\\n * @method $this ceilDays(int|float $precision = 1) Ceil the current instance day with given precision.\\n * @method $this roundHour(int|float $precision = 1, string $function = \\\"round\\\") Round the current instance hour with given precision using the given function.\\n * @method $this roundHours(int|float $precision = 1, string $function = \\\"round\\\") Round the current instance hour with given precision using the given function.\\n * @method $this floorHour(int|float $precision = 1) Truncate the current instance hour with given precision.\\n * @method $this floorHours(int|float $precision = 1) Truncate the current instance hour with given precision.\\n * @method $this ceilHour(int|float $precision = 1) Ceil the current instance hour with given precision.\\n * @method $this ceilHours(int|float $precision = 1) Ceil the current instance hour with given precision.\\n * @method $this roundMinute(int|float $precision = 1, string $function = \\\"round\\\") Round the current instance minute with given precision using the given function.\\n * @method $this roundMinutes(int|float $precision = 1, string $function = \\\"round\\\") Round the current instance minute with given precision using the given function.\\n * @method $this floorMinute(int|float $precision = 1) Truncate the current instance minute with given precision.\\n * @method $this floorMinutes(int|float $precision = 1) Truncate the current instance minute with given precision.\\n * @method $this ceilMinute(int|float $precision = 1) Ceil the current instance minute with given precision.\\n * @method $this ceilMinutes(int|float $precision = 1) Ceil the current instance minute with given precision.\\n * @method $this roundSecond(int|float $precision = 1, string $function = \\\"round\\\") Round the current instance second with given precision using the given function.\\n * @method $this roundSeconds(int|float $precision = 1, string $function = \\\"round\\\") Round the current instance second with given precision using the given function.\\n * @method $this floorSecond(int|float $precision = 1) Truncate the current instance second with given precision.\\n * @method $this floorSeconds(int|float $precision = 1) Truncate the current instance second with given precision.\\n * @method $this ceilSecond(int|float $precision = 1) Ceil the current instance second with given precision.\\n * @method $this ceilSeconds(int|float $precision = 1) Ceil the current instance second with given precision.\\n * @method $this roundMillennium(int|float $precision = 1, string $function = \\\"round\\\") Round the current instance millennium with given precision using the given function.\\n * @method $this roundMillennia(int|float $precision = 1, string $function = \\\"round\\\") Round the current instance millennium with given precision using the given function.\\n * @method $this floorMillennium(int|float $precision = 1) Truncate the current instance millennium with given precision.\\n * @method $this floorMillennia(int|float $precision = 1) Truncate the current instance millennium with given precision.\\n * @method $this ceilMillennium(int|float $precision = 1) Ceil the current instance millennium with given precision.\\n * @method $this ceilMillennia(int|float $precision = 1) Ceil the current instance millennium with given precision.\\n * @method $this roundCentury(int|float $precision = 1, string $function = \\\"round\\\") Round the current instance century with given precision using the given function.\\n * @method $this roundCenturies(int|float $precision = 1, string $function = \\\"round\\\") Round the current instance century with given precision using the given function.\\n * @method $this floorCentury(int|float $precision = 1) Truncate the current instance century with given precision.\\n * @method $this floorCenturies(int|float $precision = 1) Truncate the current instance century with given precision.\\n * @method $this ceilCentury(int|float $precision = 1) Ceil the current instance century with given precision.\\n * @method $this ceilCenturies(int|float $precision = 1) Ceil the current instance century with given precision.\\n * @method $this roundDecade(int|float $precision = 1, string $function = \\\"round\\\") Round the current instance decade with given precision using the given function.\\n * @method $this roundDecades(int|float $precision = 1, string $function = \\\"round\\\") Round the current instance decade with given precision using the given function.\\n * @method $this floorDecade(int|float $precision = 1) Truncate the current instance decade with given precision.\\n * @method $this floorDecades(int|float $precision = 1) Truncate the current instance decade with given precision.\\n * @method $this ceilDecade(int|float $precision = 1) Ceil the current instance decade with given precision.\\n * @method $this ceilDecades(int|float $precision = 1) Ceil the current instance decade with given precision.\\n * @method $this roundQuarter(int|float $precision = 1, string $function = \\\"round\\\") Round the current instance quarter with given precision using the given function.\\n * @method $this roundQuarters(int|float $precision = 1, string $function = \\\"round\\\") Round the current instance quarter with given precision using the given function.\\n * @method $this floorQuarter(int|float $precision = 1) Truncate the current instance quarter with given precision.\\n * @method $this floorQuarters(int|float $precision = 1) Truncate the current instance quarter with given precision.\\n * @method $this ceilQuarter(int|float $precision = 1) Ceil the current instance quarter with given precision.\\n * @method $this ceilQuarters(int|float $precision = 1) Ceil the current instance quarter with given precision.\\n * @method $this roundMillisecond(int|float $precision = 1, string $function = \\\"round\\\") Round the current instance millisecond with given precision using the given function.\\n * @method $this roundMilliseconds(int|float $precision = 1, string $function = \\\"round\\\") Round the current instance millisecond with given precision using the given function.\\n * @method $this floorMillisecond(int|float $precision = 1) Truncate the current instance millisecond with given precision.\\n * @method $this floorMilliseconds(int|float $precision = 1) Truncate the current instance millisecond with given precision.\\n * @method $this ceilMillisecond(int|float $precision = 1) Ceil the current instance millisecond with given precision.\\n * @method $this ceilMilliseconds(int|float $precision = 1) Ceil the current instance millisecond with given precision.\\n * @method $this roundMicrosecond(int|float $precision = 1, string $function = \\\"round\\\") Round the current instance microsecond with given precision using the given function.\\n * @method $this roundMicroseconds(int|float $precision = 1, string $function = \\\"round\\\") Round the current instance microsecond with given precision using the given function.\\n * @method $this floorMicrosecond(int|float $precision = 1) Truncate the current instance microsecond with given precision.\\n * @method $this floorMicroseconds(int|float $precision = 1) Truncate the current instance microsecond with given precision.\\n * @method $this ceilMicrosecond(int|float $precision = 1) Ceil the current instance microsecond with given precision.\\n * @method $this ceilMicroseconds(int|float $precision = 1) Ceil the current instance microsecond with given precision.\\n *\/\\nclass CarbonInterval extends DateInterval implements CarbonConverterInterface\\n{\\n    use LocalFactory;\\n    use IntervalRounding;\\n    use IntervalStep;\\n    use MagicParameter;\\n    use Mixin {\\n        Mixin::mixin as baseMixin;\\n    }\\n    use Options;\\n    use ToStringFormat;\\n\\n    \/**\\n     * Unlimited parts for forHumans() method.\\n     *\\n     * INF constant can be used instead.\\n     *\/\\n    public const NO_LIMIT = -1;\\n\\n    public const POSITIVE = 1;\\n    public const NEGATIVE = -1;\\n\\n    \/**\\n     * Interval spec period designators\\n     *\/\\n    public const PERIOD_PREFIX = 'P';\\n    public const PERIOD_YEARS = 'Y';\\n    public const PERIOD_MONTHS = 'M';\\n    public const PERIOD_DAYS = 'D';\\n    public const PERIOD_TIME_PREFIX = 'T';\\n    public const PERIOD_HOURS = 'H';\\n    public const PERIOD_MINUTES = 'M';\\n    public const PERIOD_SECONDS = 'S';\\n\\n    public const SPECIAL_TRANSLATIONS = [\\n        1 => [\\n            'option' => CarbonInterface::ONE_DAY_WORDS,\\n            'future' => 'diff_tomorrow',\\n            'past' => 'diff_yesterday',\\n        ],\\n        2 => [\\n            'option' => CarbonInterface::TWO_DAY_WORDS,\\n            'future' => 'diff_after_tomorrow',\\n            'past' => 'diff_before_yesterday',\\n        ],\\n    ];\\n\\n    protected static ?array $cascadeFactors = null;\\n\\n    protected static array $formats = [\\n        'y' => 'y',\\n        'Y' => 'y',\\n        'o' => 'y',\\n        'm' => 'm',\\n        'n' => 'm',\\n        'W' => 'weeks',\\n        'd' => 'd',\\n        'j' => 'd',\\n        'z' => 'd',\\n        'h' => 'h',\\n        'g' => 'h',\\n        'H' => 'h',\\n        'G' => 'h',\\n        'i' => 'i',\\n        's' => 's',\\n        'u' => 'micro',\\n        'v' => 'milli',\\n    ];\\n\\n    private static ?array $flipCascadeFactors = null;\\n\\n    private static bool $floatSettersEnabled = false;\\n\\n    \/**\\n     * The registered macros.\\n     *\/\\n    protected static array $macros = [];\\n\\n    \/**\\n     * Timezone handler for settings() method.\\n     *\/\\n    protected DateTimeZone|string|int|null $timezoneSetting = null;\\n\\n    \/**\\n     * The input used to create the interval.\\n     *\/\\n    protected mixed $originalInput = null;\\n\\n    \/**\\n     * Start date if interval was created from a difference between 2 dates.\\n     *\/\\n    protected ?CarbonInterface $startDate = null;\\n\\n    \/**\\n     * End date if interval was created from a difference between 2 dates.\\n     *\/\\n    protected ?CarbonInterface $endDate = null;\\n\\n    \/**\\n     * End date if interval was created from a difference between 2 dates.\\n     *\/\\n    protected ?DateInterval $rawInterval = null;\\n\\n    \/**\\n     * Flag if the interval was made from a diff with absolute flag on.\\n     *\/\\n    protected bool $absolute = false;\\n\\n    protected ?array $initialValues = null;\\n\\n    \/**\\n     * Set the instance's timezone from a string or object.\\n     *\/\\n    public function setTimezone(DateTimeZone|string|int $timezone): static\\n    {\\n        $this->timezoneSetting = $timezone;\\n        $this->checkStartAndEnd();\\n\\n        if ($this->startDate) {\\n            $this->startDate = $this->startDate\\n                ->avoidMutation()\\n                ->setTimezone($timezone);\\n            $this->rawInterval = null;\\n        }\\n\\n        if ($this->endDate) {\\n            $this->endDate = $this->endDate\\n                ->avoidMutation()\\n                ->setTimezone($timezone);\\n            $this->rawInterval = null;\\n        }\\n\\n        return $this;\\n    }\\n\\n    \/**\\n     * Set the instance's timezone from a string or object and add\/subtract the offset difference.\\n     *\/\\n    public function shiftTimezone(DateTimeZone|string|int $timezone): static\\n    {\\n        $this->timezoneSetting = $timezone;\\n        $this->checkStartAndEnd();\\n\\n        if ($this->startDate) {\\n            $this->startDate = $this->startDate\\n                ->avoidMutation()\\n                ->shiftTimezone($timezone);\\n            $this->rawInterval = null;\\n        }\\n\\n        if ($this->endDate) {\\n            $this->endDate = $this->endDate\\n                ->avoidMutation()\\n                ->shiftTimezone($timezone);\\n            $this->rawInterval = null;\\n        }\\n\\n        return $this;\\n    }\\n\\n    \/**\\n     * Mapping of units and factors for cascading.\\n     *\\n     * Should only be modified by changing the factors or referenced constants.\\n     *\/\\n    public static function getCascadeFactors(): array\\n    {\\n        return static::$cascadeFactors ?: static::getDefaultCascadeFactors();\\n    }\\n\\n    protected static function getDefaultCascadeFactors(): array\\n    {\\n        return [\\n            'milliseconds' => [CarbonInterface::MICROSECONDS_PER_MILLISECOND, 'microseconds'],\\n            'seconds' => [CarbonInterface::MILLISECONDS_PER_SECOND, 'milliseconds'],\\n            'minutes' => [CarbonInterface::SECONDS_PER_MINUTE, 'seconds'],\\n            'hours' => [CarbonInterface::MINUTES_PER_HOUR, 'minutes'],\\n            'dayz' => [CarbonInterface::HOURS_PER_DAY, 'hours'],\\n            'weeks' => [CarbonInterface::DAYS_PER_WEEK, 'dayz'],\\n            'months' => [CarbonInterface::WEEKS_PER_MONTH, 'weeks'],\\n            'years' => [CarbonInterface::MONTHS_PER_YEAR, 'months'],\\n        ];\\n    }\\n\\n    \/**\\n     * Set default cascading factors for ->cascade() method.\\n     *\\n     * @param array $cascadeFactors\\n     *\/\\n    public static function setCascadeFactors(array $cascadeFactors)\\n    {\\n        self::$flipCascadeFactors = null;\\n        static::$cascadeFactors = $cascadeFactors;\\n    }\\n\\n    \/**\\n     * This option allow you to opt-in for the Carbon 3 behavior where float\\n     * values will no longer be cast to integer (so truncated).\\n     *\\n     * \u26a0\ufe0f This settings will be applied globally, which mean your whole application\\n     * code including the third-party dependencies that also may use Carbon will\\n     * adopt the new behavior.\\n     *\/\\n    public static function enableFloatSetters(bool $floatSettersEnabled = true): void\\n    {\\n        self::$floatSettersEnabled = $floatSettersEnabled;\\n    }\\n\\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ CONSTRUCTORS \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\\n\\n    \/**\\n     * Create a new CarbonInterval instance.\\n     *\\n     * @param Closure|DateInterval|string|int|null $years\\n     * @param int|float|null                       $months\\n     * @param int|float|null                       $weeks\\n     * @param int|float|null                       $days\\n     * @param int|float|null                       $hours\\n     * @param int|float|null                       $minutes\\n     * @param int|float|null                       $seconds\\n     * @param int|float|null                       $microseconds\\n     *\\n     * @throws Exception when the interval_spec (passed as $years) cannot be parsed as an interval.\\n     *\/\\n    public function __construct($years = null, $months = null, $weeks = null, $days = null, $hours = null, $minutes = null, $seconds = null, $microseconds = null)\\n    {\\n        $this->originalInput = \\\\func_num_args() === 1 ? $years : \\\\func_get_args();\\n\\n        if ($years instanceof Closure) {\\n            $this->step = $years;\\n            $years = null;\\n        }\\n\\n        if ($years instanceof DateInterval) {\\n            parent::__construct(static::getDateIntervalSpec($years));\\n            $this->f = $years->f;\\n            self::copyNegativeUnits($years, $this);\\n\\n            return;\\n        }\\n\\n        $spec = $years;\\n        $isStringSpec = (\\\\is_string($spec) && !preg_match('\/^[\\\\d.]\/', $spec));\\n\\n        if (!$isStringSpec || (float) $years) {\\n            $spec = static::PERIOD_PREFIX;\\n\\n            $spec .= $years > 0 ? $years.static::PERIOD_YEARS : '';\\n            $spec .= $months > 0 ? $months.static::PERIOD_MONTHS : '';\\n\\n            $specDays = 0;\\n            $specDays += $weeks > 0 ? $weeks * static::getDaysPerWeek() : 0;\\n            $specDays += $days > 0 ? $days : 0;\\n\\n            $spec .= $specDays > 0 ? $specDays.static::PERIOD_DAYS : '';\\n\\n            if ($hours > 0 || $minutes > 0 || $seconds > 0) {\\n                $spec .= static::PERIOD_TIME_PREFIX;\\n                $spec .= $hours > 0 ? $hours.static::PERIOD_HOURS : '';\\n                $spec .= $minutes > 0 ? $minutes.static::PERIOD_MINUTES : '';\\n                $spec .= $seconds > 0 ? $seconds.static::PERIOD_SECONDS : '';\\n            }\\n\\n            if ($spec === static::PERIOD_PREFIX) {\\n                \/\/ Allow the zero interval.\\n                $spec .= '0'.static::PERIOD_YEARS;\\n            }\\n        }\\n\\n        try {\\n            parent::__construct($spec);\\n        } catch (Throwable $exception) {\\n            try {\\n                parent::__construct('PT0S');\\n\\n                if ($isStringSpec) {\\n                    if (!preg_match('\/^P\\n                        (?:(?<year>[+-]?\\\\d*(?:\\\\.\\\\d+)?)Y)?\\n                        (?:(?<month>[+-]?\\\\d*(?:\\\\.\\\\d+)?)M)?\\n                        (?:(?<week>[+-]?\\\\d*(?:\\\\.\\\\d+)?)W)?\\n                        (?:(?<day>[+-]?\\\\d*(?:\\\\.\\\\d+)?)D)?\\n                        (?:T\\n                            (?:(?<hour>[+-]?\\\\d*(?:\\\\.\\\\d+)?)H)?\\n                            (?:(?<minute>[+-]?\\\\d*(?:\\\\.\\\\d+)?)M)?\\n                            (?:(?<second>[+-]?\\\\d*(?:\\\\.\\\\d+)?)S)?\\n                        )?\\n                    $\/x', $spec, $match)) {\\n                        throw new InvalidArgumentException(\\\"Invalid duration: $spec\\\");\\n                    }\\n\\n                    $years = (float) ($match['year'] ?? 0);\\n                    $this->assertSafeForInteger('year', $years);\\n                    $months = (float) ($match['month'] ?? 0);\\n                    $this->assertSafeForInteger('month', $months);\\n                    $weeks = (float) ($match['week'] ?? 0);\\n                    $this->assertSafeForInteger('week', $weeks);\\n                    $days = (float) ($match['day'] ?? 0);\\n                    $this->assertSafeForInteger('day', $days);\\n                    $hours = (float) ($match['hour'] ?? 0);\\n                    $this->assertSafeForInteger('hour', $hours);\\n                    $minutes = (float) ($match['minute'] ?? 0);\\n                    $this->assertSafeForInteger('minute', $minutes);\\n                    $seconds = (float) ($match['second'] ?? 0);\\n                    $this->assertSafeForInteger('second', $seconds);\\n                    $microseconds = (int) str_pad(\\n                        substr(explode('.', $match['second'] ?? '0.0')[1] ?? '0', 0, 6),\\n                        6,\\n                        '0',\\n                    );\\n                }\\n\\n                $totalDays = (($weeks * static::getDaysPerWeek()) + $days);\\n                $this->assertSafeForInteger('days total (including weeks)', $totalDays);\\n\\n                $this->y = (int) $years;\\n                $this->m = (int) $months;\\n                $this->d = (int) $totalDays;\\n                $this->h = (int) $hours;\\n                $this->i = (int) $minutes;\\n                $this->s = (int) $seconds;\\n                $secondFloatPart = (float) ($microseconds \/ CarbonInterface::MICROSECONDS_PER_SECOND);\\n                $this->f = $secondFloatPart;\\n                $intervalMicroseconds = (int) ($this->f * CarbonInterface::MICROSECONDS_PER_SECOND);\\n                $intervalSeconds = $seconds - $secondFloatPart;\\n\\n                if (\\n                    ((float) $this->y) !== $years ||\\n                    ((float) $this->m) !== $months ||\\n                    ((float) $this->d) !== $totalDays ||\\n                    ((float) $this->h) !== $hours ||\\n                    ((float) $this->i) !== $minutes ||\\n                    ((float) $this->s) !== $intervalSeconds ||\\n                    $intervalMicroseconds !== ((int) $microseconds)\\n                ) {\\n                    $this->add(static::fromString(\\n                        ($years - $this->y).' years '.\\n                        ($months - $this->m).' months '.\\n                        ($totalDays - $this->d).' days '.\\n                        ($hours - $this->h).' hours '.\\n                        ($minutes - $this->i).' minutes '.\\n                        number_format($intervalSeconds - $this->s, 6, '.', '').' seconds '.\\n                        ($microseconds - $intervalMicroseconds).' microseconds ',\\n                    ));\\n                }\\n            } catch (Throwable $secondException) {\\n                throw $secondException instanceof OutOfRangeException ? $secondException : $exception;\\n            }\\n        }\\n\\n        if ($microseconds !== null) {\\n            $this->f = $microseconds \/ CarbonInterface::MICROSECONDS_PER_SECOND;\\n        }\\n\\n        foreach (['years', 'months', 'weeks', 'days', 'hours', 'minutes', 'seconds'] as $unit) {\\n            if ($$unit < 0) {\\n                $this->set($unit, $$unit);\\n            }\\n        }\\n    }\\n\\n    \/**\\n     * Returns the factor for a given source-to-target couple.\\n     *\\n     * @param string $source\\n     * @param string $target\\n     *\\n     * @return int|float|null\\n     *\/\\n    public static function getFactor($source, $target)\\n    {\\n        $source = self::standardizeUnit($source);\\n        $target = self::standardizeUnit($target);\\n        $factors = self::getFlipCascadeFactors();\\n\\n        if (isset($factors[$source])) {\\n            [$to, $factor] = $factors[$source];\\n\\n            if ($to === $target) {\\n                return $factor;\\n            }\\n\\n            return $factor * static::getFactor($to, $target);\\n        }\\n\\n        return null;\\n    }\\n\\n    \/**\\n     * Returns the factor for a given source-to-target couple if set,\\n     * else try to find the appropriate constant as the factor, such as Carbon::DAYS_PER_WEEK.\\n     *\\n     * @param string $source\\n     * @param string $target\\n     *\\n     * @return int|float|null\\n     *\/\\n    public static function getFactorWithDefault($source, $target)\\n    {\\n        $factor = self::getFactor($source, $target);\\n\\n        if ($factor) {\\n            return $factor;\\n        }\\n\\n        static $defaults = [\\n            'month' => ['year' => Carbon::MONTHS_PER_YEAR],\\n            'week' => ['month' => Carbon::WEEKS_PER_MONTH],\\n            'day' => ['week' => Carbon::DAYS_PER_WEEK],\\n            'hour' => ['day' => Carbon::HOURS_PER_DAY],\\n            'minute' => ['hour' => Carbon::MINUTES_PER_HOUR],\\n            'second' => ['minute' => Carbon::SECONDS_PER_MINUTE],\\n            'millisecond' => ['second' => Carbon::MILLISECONDS_PER_SECOND],\\n            'microsecond' => ['millisecond' => Carbon::MICROSECONDS_PER_MILLISECOND],\\n        ];\\n\\n        return $defaults[$source][$target] ?? null;\\n    }\\n\\n    \/**\\n     * Returns current config for days per week.\\n     *\\n     * @return int|float\\n     *\/\\n    public static function getDaysPerWeek()\\n    {\\n        return static::getFactor('dayz', 'weeks') ?: Carbon::DAYS_PER_WEEK;\\n    }\\n\\n    \/**\\n     * Returns current config for hours per day.\\n     *\\n     * @return int|float\\n     *\/\\n    public static function getHoursPerDay()\\n    {\\n        return static::getFactor('hours', 'dayz') ?: Carbon::HOURS_PER_DAY;\\n    }\\n\\n    \/**\\n     * Returns current config for minutes per hour.\\n     *\\n     * @return int|float\\n     *\/\\n    public static function getMinutesPerHour()\\n    {\\n        return static::getFactor('minutes', 'hours') ?: Carbon::MINUTES_PER_HOUR;\\n    }\\n\\n    \/**\\n     * Returns current config for seconds per minute.\\n     *\\n     * @return int|float\\n     *\/\\n    public static function getSecondsPerMinute()\\n    {\\n        return static::getFactor('seconds', 'minutes') ?: Carbon::SECONDS_PER_MINUTE;\\n    }\\n\\n    \/**\\n     * Returns current config for microseconds per second.\\n     *\\n     * @return int|float\\n     *\/\\n    public static function getMillisecondsPerSecond()\\n    {\\n        return static::getFactor('milliseconds', 'seconds') ?: Carbon::MILLISECONDS_PER_SECOND;\\n    }\\n\\n    \/**\\n     * Returns current config for microseconds per second.\\n     *\\n     * @return int|float\\n     *\/\\n    public static function getMicrosecondsPerMillisecond()\\n    {\\n        return static::getFactor('microseconds', 'milliseconds') ?: Carbon::MICROSECONDS_PER_MILLISECOND;\\n    }\\n\\n    \/**\\n     * Create a new CarbonInterval instance from specific values.\\n     * This is an alias for the constructor that allows better fluent\\n     * syntax as it allows you to do CarbonInterval::create(1)->fn() rather than\\n     * (new CarbonInterval(1))->fn().\\n     *\\n     * @param int $years\\n     * @param int $months\\n     * @param int $weeks\\n     * @param int $days\\n     * @param int $hours\\n     * @param int $minutes\\n     * @param int $seconds\\n     * @param int $microseconds\\n     *\\n     * @throws Exception when the interval_spec (passed as $years) cannot be parsed as an interval.\\n     *\\n     * @return static\\n     *\/\\n    public static function create($years = null, $months = null, $weeks = null, $days = null, $hours = null, $minutes = null, $seconds = null, $microseconds = null)\\n    {\\n        return new static($years, $months, $weeks, $days, $hours, $minutes, $seconds, $microseconds);\\n    }\\n\\n    \/**\\n     * Parse a string into a new CarbonInterval object according to the specified format.\\n     *\\n     * @example\\n     * ```\\n     * echo Carboninterval::createFromFormat('H:i', '1:30');\\n     * ```\\n     *\\n     * @param string      $format   Format of the $interval input string\\n     * @param string|null $interval Input string to convert into an interval\\n     *\\n     * @throws \\\\Carbon\\\\Exceptions\\\\ParseErrorException when the $interval cannot be parsed as an interval.\\n     *\\n     * @return static\\n     *\/\\n    public static function createFromFormat(string $format, ?string $interval): static\\n    {\\n        $instance = new static(0);\\n        $length = mb_strlen($format);\\n\\n        if (preg_match('\/s([,.])([uv])$\/', $format, $match)) {\\n            $interval = explode($match[1], $interval);\\n            $index = \\\\count($interval) - 1;\\n            $interval[$index] = str_pad($interval[$index], $match[2] === 'v' ? 3 : 6, '0');\\n            $interval = implode($match[1], $interval);\\n        }\\n\\n        $interval ??= '';\\n\\n        for ($index = 0; $index < $length; $index++) {\\n            $expected = mb_substr($format, $index, 1);\\n            $nextCharacter = mb_substr($interval, 0, 1);\\n            $unit = static::$formats[$expected] ?? null;\\n\\n            if ($unit) {\\n                if (!preg_match('\/^-?\\\\d+\/', $interval, $match)) {\\n                    throw new ParseErrorException('number', $nextCharacter);\\n                }\\n\\n                $interval = mb_substr($interval, mb_strlen($match[0]));\\n                self::incrementUnit($instance, $unit, (int) ($match[0]));\\n\\n                continue;\\n            }\\n\\n            if ($nextCharacter !== $expected) {\\n                throw new ParseErrorException(\\n                    \\\"'$expected'\\\",\\n                    $nextCharacter,\\n                    'Allowed substitutes for interval formats are '.implode(', ', array_keys(static::$formats)).\\\"\\\\n\\\".\\n                    'See https:\/\/php.net\/manual\/en\/function.date.php for their meaning',\\n                );\\n            }\\n\\n            $interval = mb_substr($interval, 1);\\n        }\\n\\n        if ($interval !== '') {\\n            throw new ParseErrorException(\\n                'end of string',\\n                $interval,\\n            );\\n        }\\n\\n        return $instance;\\n    }\\n\\n    \/**\\n     * Return the original source used to create the current interval.\\n     *\\n     * @return array|int|string|DateInterval|mixed|null\\n     *\/\\n    public function original()\\n    {\\n        return $this->originalInput;\\n    }\\n\\n    \/**\\n     * Return the start date if interval was created from a difference between 2 dates.\\n     *\\n     * @return CarbonInterface|null\\n     *\/\\n    public function start(): ?CarbonInterface\\n    {\\n        $this->checkStartAndEnd();\\n\\n        return $this->startDate;\\n    }\\n\\n    \/**\\n     * Return the end date if interval was created from a difference between 2 dates.\\n     *\\n     * @return CarbonInterface|null\\n     *\/\\n    public function end(): ?CarbonInterface\\n    {\\n        $this->checkStartAndEnd();\\n\\n        return $this->endDate;\\n    }\\n\\n    \/**\\n     * Get rid of the original input, start date and end date that may be kept in memory.\\n     *\\n     * @return $this\\n     *\/\\n    public function optimize(): static\\n    {\\n        $this->originalInput = null;\\n        $this->startDate = null;\\n        $this->endDate = null;\\n        $this->rawInterval = null;\\n        $this->absolute = false;\\n\\n        return $this;\\n    }\\n\\n    \/**\\n     * Get a copy of the instance.\\n     *\\n     * @return static\\n     *\/\\n    public function copy(): static\\n    {\\n        $date = new static(0);\\n        $date->copyProperties($this);\\n        $date->step = $this->step;\\n\\n        return $date;\\n    }\\n\\n    \/**\\n     * Get a copy of the instance.\\n     *\\n     * @return static\\n     *\/\\n    public function clone(): static\\n    {\\n        return $this->copy();\\n    }\\n\\n    \/**\\n     * Provide static helpers to create instances.  Allows CarbonInterval::years(3).\\n     *\\n     * Note: This is done using the magic method to allow static and instance methods to\\n     *       have the same names.\\n     *\\n     * @param string $method     magic method name called\\n     * @param array  $parameters parameters list\\n     *\\n     * @return static|mixed|null\\n     *\/\\n    public static function __callStatic(string $method, array $parameters)\\n    {\\n        try {\\n            $interval = new static(0);\\n            $localStrictModeEnabled = $interval->localStrictModeEnabled;\\n            $interval->localStrictModeEnabled = true;\\n\\n            $result = static::hasMacro($method)\\n                ? static::bindMacroContext(null, function () use (&$method, &$parameters, &$interval) {\\n                    return $interval->callMacro($method, $parameters);\\n                })\\n                : $interval->$method(...$parameters);\\n\\n            $interval->localStrictModeEnabled = $localStrictModeEnabled;\\n\\n            return $result;\\n        } catch (BadFluentSetterException $exception) {\\n            if (Carbon::isStrictModeEnabled()) {\\n                throw new BadFluentConstructorException($method, 0, $exception);\\n            }\\n\\n            return null;\\n        }\\n    }\\n\\n    \/**\\n     * Evaluate the PHP generated by var_export() and recreate the exported CarbonInterval instance.\\n     *\\n     * @param array $dump data as exported by var_export()\\n     *\\n     * @return static\\n     *\/\\n    #[ReturnTypeWillChange]\\n    public static function __set_state($dump)\\n    {\\n        \/** @noinspection PhpVoidFunctionResultUsedInspection *\/\\n        \/** @var DateInterval $dateInterval *\/\\n        $dateInterval = parent::__set_state($dump);\\n\\n        return static::instance($dateInterval);\\n    }\\n\\n    \/**\\n     * Return the current context from inside a macro callee or a new one if static.\\n     *\\n     * @return static\\n     *\/\\n    protected static function this(): static\\n    {\\n        return end(static::$macroContextStack) ?: new static(0);\\n    }\\n\\n    \/**\\n     * Creates a CarbonInterval from string.\\n     *\\n     * Format:\\n     *\\n     * Suffix | Unit    | Example | DateInterval expression\\n     * -------|---------|---------|------------------------\\n     * y      | years   |   1y    | P1Y\\n     * mo     | months  |   3mo   | P3M\\n     * w      | weeks   |   2w    | P2W\\n     * d      | days    |  28d    | P28D\\n     * h      | hours   |   4h    | PT4H\\n     * m      | minutes |  12m    | PT12M\\n     * s      | seconds |  59s    | PT59S\\n     *\\n     * e. g. `1w 3d 4h 32m 23s` is converted to 10 days 4 hours 32 minutes and 23 seconds.\\n     *\\n     * Special cases:\\n     *  - An empty string will return a zero interval\\n     *  - Fractions are allowed for weeks, days, hours and minutes and will be converted\\n     *    and rounded to the next smaller value (caution: 0.5w = 4d)\\n     *\\n     * @param string $intervalDefinition\\n     *\\n     * @throws InvalidIntervalException\\n     *\\n     * @return static\\n     *\/\\n    public static function fromString(string $intervalDefinition): static\\n    {\\n        if (empty($intervalDefinition)) {\\n            return self::withOriginal(new static(0), $intervalDefinition);\\n        }\\n\\n        $years = 0;\\n        $months = 0;\\n        $weeks = 0;\\n        $days = 0;\\n        $hours = 0;\\n        $minutes = 0;\\n        $seconds = 0;\\n        $milliseconds = 0;\\n        $microseconds = 0;\\n\\n        $pattern = '\/(-?\\\\d+(?:\\\\.\\\\d+)?)\\\\h*([^\\\\d\\\\h]*)\/i';\\n        preg_match_all($pattern, $intervalDefinition, $parts, PREG_SET_ORDER);\\n\\n        while ([$part, $value, $unit] = array_shift($parts)) {\\n            $intValue = (int) $value;\\n            $fraction = (float) $value - $intValue;\\n\\n            \/\/ Fix calculation precision\\n            switch (round($fraction, 6)) {\\n                case 1:\\n                    $fraction = 0;\\n                    $intValue++;\\n\\n                    break;\\n                case 0:\\n                    $fraction = 0;\\n\\n                    break;\\n            }\\n\\n            switch ($unit === '\u00b5s' ? '\u00b5s' : strtolower($unit)) {\\n                case 'millennia':\\n                case 'millennium':\\n                    $years += $intValue * CarbonInterface::YEARS_PER_MILLENNIUM;\\n\\n                    break;\\n\\n                case 'century':\\n                case 'centuries':\\n                    $years += $intValue * CarbonInterface::YEARS_PER_CENTURY;\\n\\n                    break;\\n\\n                case 'decade':\\n                case 'decades':\\n                    $years += $intValue * CarbonInterface::YEARS_PER_DECADE;\\n\\n                    break;\\n\\n                case 'year':\\n                case 'years':\\n                case 'y':\\n                case 'yr':\\n                case 'yrs':\\n                    $years += $intValue;\\n\\n                    break;\\n\\n                case 'quarter':\\n                case 'quarters':\\n                    $months += $intValue * CarbonInterface::MONTHS_PER_QUARTER;\\n\\n                    break;\\n\\n                case 'month':\\n                case 'months':\\n                case 'mo':\\n                case 'mos':\\n                    $months += $intValue;\\n\\n                    break;\\n\\n                case 'week':\\n                case 'weeks':\\n                case 'w':\\n                    $weeks += $intValue;\\n\\n                    if ($fraction) {\\n                        $parts[] = [null, $fraction * static::getDaysPerWeek(), 'd'];\\n                    }\\n\\n                    break;\\n\\n                case 'day':\\n                case 'days':\\n                case 'd':\\n                    $days += $intValue;\\n\\n                    if ($fraction) {\\n                        $parts[] = [null, $fraction * static::getHoursPerDay(), 'h'];\\n                    }\\n\\n                    break;\\n\\n                case 'hour':\\n                case 'hours':\\n                case 'h':\\n                    $hours += $intValue;\\n\\n                    if ($fraction) {\\n                        $parts[] = [null, $fraction * static::getMinutesPerHour(), 'm'];\\n                    }\\n\\n                    break;\\n\\n                case 'minute':\\n                case 'minutes':\\n                case 'm':\\n                    $minutes += $intValue;\\n\\n                    if ($fraction) {\\n                        $parts[] = [null, $fraction * static::getSecondsPerMinute(), 's'];\\n                    }\\n\\n                    break;\\n\\n                case 'second':\\n                case 'seconds':\\n                case 's':\\n                    $seconds += $intValue;\\n\\n                    if ($fraction) {\\n                        $parts[] = [null, $fraction * static::getMillisecondsPerSecond(), 'ms'];\\n                    }\\n\\n                    break;\\n\\n                case 'millisecond':\\n                case 'milliseconds':\\n                case 'milli':\\n                case 'ms':\\n                    $milliseconds += $intValue;\\n\\n                    if ($fraction) {\\n                        $microseconds += round($fraction * static::getMicrosecondsPerMillisecond());\\n                    }\\n\\n                    break;\\n\\n                case 'microsecond':\\n                case 'microseconds':\\n                case 'micro':\\n                case '\u00b5s':\\n                    $microseconds += $intValue;\\n\\n                    break;\\n\\n                default:\\n                    throw new InvalidIntervalException(\\n                        \\\"Invalid part $part in definition $intervalDefinition\\\",\\n                    );\\n            }\\n        }\\n\\n        return self::withOriginal(\\n            new static($years, $months, $weeks, $days, $hours, $minutes, $seconds, $milliseconds * Carbon::MICROSECONDS_PER_MILLISECOND + $microseconds),\\n            $intervalDefinition,\\n        );\\n    }\\n\\n    \/**\\n     * Creates a CarbonInterval from string using a different locale.\\n     *\\n     * @param string      $interval interval string in the given language (may also contain English).\\n     * @param string|null $locale   if locale is null or not specified, current global locale will be used instead.\\n     *\\n     * @return static\\n     *\/\\n    public static function parseFromLocale(string $interval, ?string $locale = null): static\\n    {\\n        return static::fromString(Carbon::translateTimeString($interval, $locale ?: static::getLocale(), CarbonInterface::DEFAULT_LOCALE));\\n    }\\n\\n    \/**\\n     * Create an interval from the difference between 2 dates.\\n     *\\n     * @param \\\\Carbon\\\\Carbon|\\\\DateTimeInterface|mixed $start\\n     * @param \\\\Carbon\\\\Carbon|\\\\DateTimeInterface|mixed $end\\n     *\\n     * @return static\\n     *\/\\n    public static function diff($start, $end = null, bool $absolute = false, array $skip = []): static\\n    {\\n        $start = $start instanceof CarbonInterface ? $start : Carbon::make($start);\\n        $end = $end instanceof CarbonInterface ? $end : Carbon::make($end);\\n        $rawInterval = $start->diffAsDateInterval($end, $absolute);\\n        $interval = static::instance($rawInterval, $skip);\\n\\n        $interval->absolute = $absolute;\\n        $interval->rawInterval = $rawInterval;\\n        $interval->startDate = $start;\\n        $interval->endDate = $end;\\n        $interval->initialValues = $interval->getInnerValues();\\n\\n        return $interval;\\n    }\\n\\n    \/**\\n     * Invert the interval if it's inverted.\\n     *\\n     * @param bool $absolute do nothing if set to false\\n     *\\n     * @return $this\\n     *\/\\n    public function abs(bool $absolute = false): static\\n    {\\n        if ($absolute && $this->invert) {\\n            $this->invert();\\n        }\\n\\n        return $this;\\n    }\\n\\n    \/**\\n     * @alias abs\\n     *\\n     * Invert the interval if it's inverted.\\n     *\\n     * @param bool $absolute do nothing if set to false\\n     *\\n     * @return $this\\n     *\/\\n    public function absolute(bool $absolute = true): static\\n    {\\n        return $this->abs($absolute);\\n    }\\n\\n    \/**\\n     * Cast the current instance into the given class.\\n     *\\n     * @template T of DateInterval\\n     *\\n     * @psalm-param class-string<T> $className The $className::instance() method will be called to cast the current object.\\n     *\\n     * @return T\\n     *\/\\n    public function cast(string $className): mixed\\n    {\\n        return self::castIntervalToClass($this, $className);\\n    }\\n\\n    \/**\\n     * Create a CarbonInterval instance from a DateInterval one.  Can not instance\\n     * DateInterval objects created from DateTime::diff() as you can't externally\\n     * set the $days field.\\n     *\\n     * @param DateInterval $interval\\n     * @param bool         $skipCopy set to true to return the passed object\\n     *                               (without copying it) if it's already of the\\n     *                               current class\\n     *\\n     * @return static\\n     *\/\\n    public static function instance(DateInterval $interval, array $skip = [], bool $skipCopy = false): static\\n    {\\n        if ($skipCopy && $interval instanceof static) {\\n            return $interval;\\n        }\\n\\n        return self::castIntervalToClass($interval, static::class, $skip);\\n    }\\n\\n    \/**\\n     * Make a CarbonInterval instance from given variable if possible.\\n     *\\n     * Always return a new instance. Parse only strings and only these likely to be intervals (skip dates\\n     * and recurrences). Throw an exception for invalid format, but otherwise return null.\\n     *\\n     * @param mixed|int|DateInterval|string|Closure|Unit|null $interval interval or number of the given $unit\\n     * @param Unit|string|null                                $unit     if specified, $interval must be an integer\\n     * @param bool                                            $skipCopy set to true to return the passed object\\n     *                                                                  (without copying it) if it's already of the\\n     *                                                                  current class\\n     *\\n     * @return static|null\\n     *\/\\n    public static function make($interval, $unit = null, bool $skipCopy = false): ?self\\n    {\\n        if ($interval instanceof Unit) {\\n            $interval = $interval->interval();\\n        }\\n\\n        if ($unit instanceof Unit) {\\n            $unit = $unit->value;\\n        }\\n\\n        if ($unit) {\\n            $interval = \\\"$interval $unit\\\";\\n        }\\n\\n        if ($interval instanceof DateInterval) {\\n            return static::instance($interval, [], $skipCopy);\\n        }\\n\\n        if ($interval instanceof Closure) {\\n            return self::withOriginal(new static($interval), $interval);\\n        }\\n\\n        if (!\\\\is_string($interval)) {\\n            return null;\\n        }\\n\\n        return static::makeFromString($interval);\\n    }\\n\\n    protected static function makeFromString(string $interval): ?self\\n    {\\n        $interval = preg_replace('\/\\\\s+\/', ' ', trim($interval));\\n\\n        if (preg_match('\/^P[T\\\\d]\/', $interval)) {\\n            return new static($interval);\\n        }\\n\\n        if (preg_match('\/^(?:\\\\h*-?\\\\d+(?:\\\\.\\\\d+)?\\\\h*[a-z]+)+$\/i', $interval)) {\\n            return static::fromString($interval);\\n        }\\n\\n        $intervalInstance = static::createFromDateString($interval);\\n\\n        return $intervalInstance->isEmpty() ? null : $intervalInstance;\\n    }\\n\\n    protected function resolveInterval($interval): ?self\\n    {\\n        if (!($interval instanceof self)) {\\n            return self::make($interval);\\n        }\\n\\n        return $interval;\\n    }\\n\\n    \/**\\n     * Sets up a DateInterval from the relative parts of the string.\\n     *\\n     * @param string $datetime\\n     *\\n     * @return static\\n     *\\n     * @link https:\/\/php.net\/manual\/en\/dateinterval.createfromdatestring.php\\n     *\/\\n    public static function createFromDateString(string $datetime): static\\n    {\\n        $string = strtr($datetime, [\\n            ',' => ' ',\\n            ' and ' => ' ',\\n        ]);\\n        $previousException = null;\\n\\n        try {\\n            $interval = parent::createFromDateString($string);\\n        } catch (Throwable $exception) {\\n            $interval = null;\\n            $previousException = $exception;\\n        }\\n\\n        $interval ?: throw new InvalidFormatException(\\n            'Could not create interval from: '.var_export($datetime, true),\\n            previous: $previousException,\\n        );\\n\\n        if (!($interval instanceof static)) {\\n            $interval = static::instance($interval);\\n        }\\n\\n        return self::withOriginal($interval, $datetime);\\n    }\\n\\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ GETTERS AND SETTERS \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\\n\\n    \/**\\n     * Get a part of the CarbonInterval object.\\n     *\/\\n    public function get(Unit|string $name): int|float|string|null\\n    {\\n        $name = Unit::toName($name);\\n\\n        if (str_starts_with($name, 'total')) {\\n            return $this->total(substr($name, 5));\\n        }\\n\\n        $resolvedUnit = Carbon::singularUnit(rtrim($name, 'z'));\\n\\n        return match ($resolvedUnit) {\\n            'tzname', 'tz_name' => match (true) {\\n                ($this->timezoneSetting === null) => null,\\n                \\\\is_string($this->timezoneSetting) => $this->timezoneSetting,\\n                ($this->timezoneSetting instanceof DateTimeZone) => $this->timezoneSetting->getName(),\\n                default => CarbonTimeZone::instance($this->timezoneSetting)->getName(),\\n            },\\n            'year' => $this->y,\\n            'month' => $this->m,\\n            'day' => $this->d,\\n            'hour' => $this->h,\\n            'minute' => $this->i,\\n            'second' => $this->s,\\n            'milli', 'millisecond' => (int) (round($this->f * Carbon::MICROSECONDS_PER_SECOND) \/\\n                Carbon::MICROSECONDS_PER_MILLISECOND),\\n            'micro', 'microsecond' => (int) round($this->f * Carbon::MICROSECONDS_PER_SECOND),\\n            'microexcludemilli' => (int) round($this->f * Carbon::MICROSECONDS_PER_SECOND) %\\n                Carbon::MICROSECONDS_PER_MILLISECOND,\\n            'week' => (int) ($this->d \/ (int) static::getDaysPerWeek()),\\n            'daysexcludeweek', 'dayzexcludeweek' => $this->d % (int) static::getDaysPerWeek(),\\n            'locale' => $this->getTranslatorLocale(),\\n            default => throw new UnknownGetterException($name, previous: new UnknownGetterException($resolvedUnit)),\\n        };\\n    }\\n\\n    \/**\\n     * Get a part of the CarbonInterval object.\\n     *\/\\n    public function __get(string $name): int|float|string|null\\n    {\\n        return $this->get($name);\\n    }\\n\\n    \/**\\n     * Set a part of the CarbonInterval object.\\n     *\\n     * @param Unit|string|array $name\\n     * @param int               $value\\n     *\\n     * @throws UnknownSetterException\\n     *\\n     * @return $this\\n     *\/\\n    public function set($name, $value = null): static\\n    {\\n        $properties = \\\\is_array($name) ? $name : [$name => $value];\\n\\n        foreach ($properties as $key => $value) {\\n            switch (Carbon::singularUnit($key instanceof Unit ? $key->value : rtrim((string) $key, 'z'))) {\\n                case 'year':\\n                    $this->checkIntegerValue($key, $value);\\n                    $this->y = $value;\\n                    $this->handleDecimalPart('year', $value, $this->y);\\n\\n                    break;\\n\\n                case 'month':\\n                    $this->checkIntegerValue($key, $value);\\n                    $this->m = $value;\\n                    $this->handleDecimalPart('month', $value, $this->m);\\n\\n                    break;\\n\\n                case 'week':\\n                    $this->checkIntegerValue($key, $value);\\n                    $days = $value * (int) static::getDaysPerWeek();\\n                    $this->assertSafeForInteger('days total (including weeks)', $days);\\n                    $this->d = $days;\\n                    $this->handleDecimalPart('day', $days, $this->d);\\n\\n                    break;\\n\\n                case 'day':\\n                    if ($value === false) {\\n                        break;\\n                    }\\n\\n                    $this->checkIntegerValue($key, $value);\\n                    $this->d = $value;\\n                    $this->handleDecimalPart('day', $value, $this->d);\\n\\n                    break;\\n\\n                case 'daysexcludeweek':\\n                case 'dayzexcludeweek':\\n                    $this->checkIntegerValue($key, $value);\\n                    $days = $this->weeks * (int) static::getDaysPerWeek() + $value;\\n                    $this->assertSafeForInteger('days total (including weeks)', $days);\\n                    $this->d = $days;\\n                    $this->handleDecimalPart('day', $days, $this->d);\\n\\n                    break;\\n\\n                case 'hour':\\n                    $this->checkIntegerValue($key, $value);\\n                    $this->h = $value;\\n                    $this->handleDecimalPart('hour', $value, $this->h);\\n\\n                    break;\\n\\n                case 'minute':\\n                    $this->checkIntegerValue($key, $value);\\n                    $this->i = $value;\\n                    $this->handleDecimalPart('minute', $value, $this->i);\\n\\n                    break;\\n\\n                case 'second':\\n                    $this->checkIntegerValue($key, $value);\\n                    $this->s = $value;\\n                    $this->handleDecimalPart('second', $value, $this->s);\\n\\n                    break;\\n\\n                case 'milli':\\n                case 'millisecond':\\n                    $this->microseconds = $value * Carbon::MICROSECONDS_PER_MILLISECOND + $this->microseconds % Carbon::MICROSECONDS_PER_MILLISECOND;\\n\\n                    break;\\n\\n                case 'micro':\\n                case 'microsecond':\\n                    $this->f = $value \/ Carbon::MICROSECONDS_PER_SECOND;\\n\\n                    break;\\n\\n                default:\\n                    if (str_starts_with($key, ' * ')) {\\n                        return $this->setSetting(substr($key, 3), $value);\\n                    }\\n\\n                    if ($this->localStrictModeEnabled ?? Carbon::isStrictModeEnabled()) {\\n                        throw new UnknownSetterException($key);\\n                    }\\n\\n                    $this->$key = $value;\\n            }\\n        }\\n\\n        return $this;\\n    }\\n\\n    \/**\\n     * Set a part of the CarbonInterval object.\\n     *\\n     * @param string $name\\n     * @param int    $value\\n     *\\n     * @throws UnknownSetterException\\n     *\/\\n    public function __set(string $name, $value)\\n    {\\n        $this->set($name, $value);\\n    }\\n\\n    \/**\\n     * Allow setting of weeks and days to be cumulative.\\n     *\\n     * @param int $weeks Number of weeks to set\\n     * @param int $days  Number of days to set\\n     *\\n     * @return static\\n     *\/\\n    public function weeksAndDays(int $weeks, int $days): static\\n    {\\n        $this->dayz = ($weeks * static::getDaysPerWeek()) + $days;\\n\\n        return $this;\\n    }\\n\\n    \/**\\n     * Returns true if the interval is empty for each unit.\\n     *\\n     * @return bool\\n     *\/\\n    public function isEmpty(): bool\\n    {\\n        return $this->years === 0 &&\\n            $this->months === 0 &&\\n            $this->dayz === 0 &&\\n            !$this->days &&\\n            $this->hours === 0 &&\\n            $this->minutes === 0 &&\\n            $this->seconds === 0 &&\\n            $this->microseconds === 0;\\n    }\\n\\n    \/**\\n     * Register a custom macro.\\n     *\\n     * Pass null macro to remove it.\\n     *\\n     * @example\\n     * ```\\n     * CarbonInterval::macro('twice', function () {\\n     *   return $this->times(2);\\n     * });\\n     * echo CarbonInterval::hours(2)->twice();\\n     * ```\\n     *\\n     * @param-closure-this static $macro\\n     *\/\\n    public static function macro(string $name, ?callable $macro): void\\n    {\\n        static::$macros[$name] = $macro;\\n    }\\n\\n    \/**\\n     * Register macros from a mixin object.\\n     *\\n     * @example\\n     * ```\\n     * CarbonInterval::mixin(new class {\\n     *   public function daysToHours() {\\n     *     return function () {\\n     *       $this->hours += $this->days;\\n     *       $this->days = 0;\\n     *\\n     *       return $this;\\n     *     };\\n     *   }\\n     *   public function hoursToDays() {\\n     *     return function () {\\n     *       $this->days += $this->hours;\\n     *       $this->hours = 0;\\n     *\\n     *       return $this;\\n     *     };\\n     *   }\\n     * });\\n     * echo CarbonInterval::hours(5)->hoursToDays() . \\\"\\\\n\\\";\\n     * echo CarbonInterval::days(5)->daysToHours() . \\\"\\\\n\\\";\\n     * ```\\n     *\\n     * @param object|string $mixin\\n     *\\n     * @throws ReflectionException\\n     *\\n     * @return void\\n     *\/\\n    public static function mixin($mixin): void\\n    {\\n        static::baseMixin($mixin);\\n    }\\n\\n    \/**\\n     * Check if macro is registered.\\n     *\\n     * @param string $name\\n     *\\n     * @return bool\\n     *\/\\n    public static function hasMacro(string $name): bool\\n    {\\n        return isset(static::$macros[$name]);\\n    }\\n\\n    \/**\\n     * Call given macro.\\n     *\\n     * @param string $name\\n     * @param array  $parameters\\n     *\\n     * @return mixed\\n     *\/\\n    protected function callMacro(string $name, array $parameters)\\n    {\\n        $macro = static::$macros[$name];\\n\\n        if ($macro instanceof Closure) {\\n            $boundMacro = @$macro->bindTo($this, static::class) ?: @$macro->bindTo(null, static::class);\\n\\n            return ($boundMacro ?: $macro)(...$parameters);\\n        }\\n\\n        return $macro(...$parameters);\\n    }\\n\\n    \/**\\n     * Allow fluent calls on the setters... CarbonInterval::years(3)->months(5)->day().\\n     *\\n     * Note: This is done using the magic method to allow static and instance methods to\\n     *       have the same names.\\n     *\\n     * @param string $method     magic method name called\\n     * @param array  $parameters parameters list\\n     *\\n     * @throws BadFluentSetterException|Throwable\\n     *\\n     * @return static|int|float|string\\n     *\/\\n    public function __call(string $method, array $parameters)\\n    {\\n        if (static::hasMacro($method)) {\\n            return static::bindMacroContext($this, function () use (&$method, &$parameters) {\\n                return $this->callMacro($method, $parameters);\\n            });\\n        }\\n\\n        $roundedValue = $this->callRoundMethod($method, $parameters);\\n\\n        if ($roundedValue !== null) {\\n            return $roundedValue;\\n        }\\n\\n        if (preg_match('\/^(?<method>add|sub)(?<unit>[A-Z].*)$\/', $method, $match)) {\\n            $value = $this->getMagicParameter($parameters, 0, Carbon::pluralUnit($match['unit']), 0);\\n\\n            return $this->{$match['method']}($value, $match['unit']);\\n        }\\n\\n        $value = $this->getMagicParameter($parameters, 0, Carbon::pluralUnit($method), 1);\\n\\n        try {\\n            $this->set($method, $value);\\n        } catch (UnknownSetterException $exception) {\\n            if ($this->localStrictModeEnabled ?? Carbon::isStrictModeEnabled()) {\\n                throw new BadFluentSetterException($method, 0, $exception);\\n            }\\n        }\\n\\n        return $this;\\n    }\\n\\n    protected function getForHumansInitialVariables($syntax, $short): array\\n    {\\n        if (\\\\is_array($syntax)) {\\n            return $syntax;\\n        }\\n\\n        if (\\\\is_int($short)) {\\n            return [\\n                'parts' => $short,\\n                'short' => false,\\n            ];\\n        }\\n\\n        if (\\\\is_bool($syntax)) {\\n            return [\\n                'short' => $syntax,\\n                'syntax' => CarbonInterface::DIFF_ABSOLUTE,\\n            ];\\n        }\\n\\n        return [];\\n    }\\n\\n    \/**\\n     * @param mixed $syntax\\n     * @param mixed $short\\n     * @param mixed $parts\\n     * @param mixed $options\\n     *\\n     * @return array\\n     *\/\\n    protected function getForHumansParameters($syntax = null, $short = false, $parts = self::NO_LIMIT, $options = null): array\\n    {\\n        $optionalSpace = ' ';\\n        $default = $this->getTranslationMessage('list.0') ?? $this->getTranslationMessage('list') ?? ' ';\\n        \/** @var bool|string $join *\/\\n        $join = $default === '' ? '' : ' ';\\n        \/** @var bool|array|string $altNumbers *\/\\n        $altNumbers = false;\\n        $aUnit = false;\\n        $minimumUnit = 's';\\n        $skip = [];\\n        extract($this->getForHumansInitialVariables($syntax, $short));\\n        $skip = array_map(\\n            static fn ($unit) => $unit instanceof Unit ? $unit->value : $unit,\\n            (array) $skip,\\n        );\\n        $skip = array_map(\\n            'strtolower',\\n            array_filter($skip, static fn ($unit) => \\\\is_string($unit) && $unit !== ''),\\n        );\\n\\n        $syntax ??= CarbonInterface::DIFF_ABSOLUTE;\\n\\n        if ($parts === self::NO_LIMIT) {\\n            $parts = INF;\\n        }\\n\\n        $options ??= static::getHumanDiffOptions();\\n\\n        if ($join === false) {\\n            $join = ' ';\\n        } elseif ($join === true) {\\n            $join = [\\n                $default,\\n                $this->getTranslationMessage('list.1') ?? $default,\\n            ];\\n        }\\n\\n        if ($altNumbers && $altNumbers !== true) {\\n            $language = new Language($this->locale);\\n            $altNumbers = \\\\in_array($language->getCode(), (array) $altNumbers, true);\\n        }\\n\\n        if (\\\\is_array($join)) {\\n            [$default, $last] = $join;\\n\\n            if ($default !== ' ') {\\n                $optionalSpace = '';\\n            }\\n\\n            $join = function ($list) use ($default, $last) {\\n                if (\\\\count($list) < 2) {\\n                    return implode('', $list);\\n                }\\n\\n                $end = array_pop($list);\\n\\n                return implode($default, $list).$last.$end;\\n            };\\n        }\\n\\n        if (\\\\is_string($join)) {\\n            if ($join !== ' ') {\\n                $optionalSpace = '';\\n            }\\n\\n            $glue = $join;\\n            $join = static fn ($list) => implode($glue, $list);\\n        }\\n\\n        $interpolations = [\\n            ':optional-space' => $optionalSpace,\\n        ];\\n\\n        $translator ??= isset($locale) ? Translator::get($locale) : null;\\n\\n        return [$syntax, $short, $parts, $options, $join, $aUnit, $altNumbers, $interpolations, $minimumUnit, $skip, $translator];\\n    }\\n\\n    protected static function getRoundingMethodFromOptions(int $options): ?string\\n    {\\n        if ($options & CarbonInterface::ROUND) {\\n            return 'round';\\n        }\\n\\n        if ($options & CarbonInterface::CEIL) {\\n            return 'ceil';\\n        }\\n\\n        if ($options & CarbonInterface::FLOOR) {\\n            return 'floor';\\n        }\\n\\n        return null;\\n    }\\n\\n    \/**\\n     * Returns interval values as an array where key are the unit names and values the counts.\\n     *\\n     * @return int[]\\n     *\/\\n    public function toArray(): array\\n    {\\n        return [\\n            'years' => $this->years,\\n            'months' => $this->months,\\n            'weeks' => $this->weeks,\\n            'days' => $this->daysExcludeWeeks,\\n            'hours' => $this->hours,\\n            'minutes' => $this->minutes,\\n            'seconds' => $this->seconds,\\n            'microseconds' => $this->microseconds,\\n        ];\\n    }\\n\\n    \/**\\n     * Returns interval non-zero values as an array where key are the unit names and values the counts.\\n     *\\n     * @return int[]\\n     *\/\\n    public function getNonZeroValues(): array\\n    {\\n        return array_filter($this->toArray(), 'intval');\\n    }\\n\\n    \/**\\n     * Returns interval values as an array where key are the unit names and values the counts\\n     * from the biggest non-zero one the the smallest non-zero one.\\n     *\\n     * @return int[]\\n     *\/\\n    public function getValuesSequence(): array\\n    {\\n        $nonZeroValues = $this->getNonZeroValues();\\n\\n        if ($nonZeroValues === []) {\\n            return [];\\n        }\\n\\n        $keys = array_keys($nonZeroValues);\\n        $firstKey = $keys[0];\\n        $lastKey = $keys[\\\\count($keys) - 1];\\n        $values = [];\\n        $record = false;\\n\\n        foreach ($this->toArray() as $unit => $count) {\\n            if ($unit === $firstKey) {\\n                $record = true;\\n            }\\n\\n            if ($record) {\\n                $values[$unit] = $count;\\n            }\\n\\n            if ($unit === $lastKey) {\\n                $record = false;\\n            }\\n        }\\n\\n        return $values;\\n    }\\n\\n    \/**\\n     * Get the current interval in a human readable format in the current locale.\\n     *\\n     * @example\\n     * ```\\n     * echo CarbonInterval::fromString('4d 3h 40m')->forHumans() . \\\"\\\\n\\\";\\n     * echo CarbonInterval::fromString('4d 3h 40m')->forHumans(['parts' => 2]) . \\\"\\\\n\\\";\\n     * echo CarbonInterval::fromString('4d 3h 40m')->forHumans(['parts' => 3, 'join' => true]) . \\\"\\\\n\\\";\\n     * echo CarbonInterval::fromString('4d 3h 40m')->forHumans(['short' => true]) . \\\"\\\\n\\\";\\n     * echo CarbonInterval::fromString('1d 24h')->forHumans(['join' => ' or ']) . \\\"\\\\n\\\";\\n     * echo CarbonInterval::fromString('1d 24h')->forHumans(['minimumUnit' => 'hour']) . \\\"\\\\n\\\";\\n     * ```\\n     *\\n     * @param int|array $syntax  if array passed, parameters will be extracted from it, the array may contain:\\n     *                           \u29bf 'syntax' entry (see below)\\n     *                           \u29bf 'short' entry (see below)\\n     *                           \u29bf 'parts' entry (see below)\\n     *                           \u29bf 'options' entry (see below)\\n     *                           \u29bf 'skip' entry, list of units to skip (array of strings or a single string,\\n     *                           ` it can be the unit name (singular or plural) or its shortcut\\n     *                           ` (y, m, w, d, h, min, s, ms, \u00b5s).\\n     *                           \u29bf 'aUnit' entry, prefer \\\"an hour\\\" over \\\"1 hour\\\" if true\\n     *                           \u29bf 'altNumbers' entry, use alternative numbers if available\\n     *                           ` (from the current language if true is passed, from the given language(s)\\n     *                           ` if array or string is passed)\\n     *                           \u29bf 'join' entry determines how to join multiple parts of the string\\n     *                           `  - if $join is a string, it's used as a joiner glue\\n     *                           `  - if $join is a callable\/closure, it get the list of string and should return a string\\n     *                           `  - if $join is an array, the first item will be the default glue, and the second item\\n     *                           `    will be used instead of the glue for the last item\\n     *                           `  - if $join is true, it will be guessed from the locale ('list' translation file entry)\\n     *                           `  - if $join is missing, a space will be used as glue\\n     *                           \u29bf 'minimumUnit' entry determines the smallest unit of time to display can be long or\\n     *                           `  short form of the units, e.g. 'hour' or 'h' (default value: s)\\n     *                           \u29bf 'locale' language in which the diff should be output (has no effect if 'translator' key is set)\\n     *                           \u29bf 'translator' a custom translator to use to translator the output.\\n     *                           if int passed, it adds modifiers:\\n     *                           Possible values:\\n     *                           - CarbonInterface::DIFF_ABSOLUTE          no modifiers\\n     *                           - CarbonInterface::DIFF_RELATIVE_TO_NOW   add ago\/from now modifier\\n     *                           - CarbonInterface::DIFF_RELATIVE_TO_OTHER add before\/after modifier\\n     *                           Default value: CarbonInterface::DIFF_ABSOLUTE\\n     * @param bool      $short   displays short format of time units\\n     * @param int       $parts   maximum number of parts to display (default value: -1: no limits)\\n     * @param int       $options human diff options\\n     *\\n     * @throws Exception\\n     *\\n     * @return string\\n     *\/\\n    public function forHumans($syntax = null, $short = false, $parts = self::NO_LIMIT, $options = null): string\\n    {\\n        \/* @var TranslatorInterface|null $translator *\/\\n        [$syntax, $short, $parts, $options, $join, $aUnit, $altNumbers, $interpolations, $minimumUnit, $skip, $translator] = $this\\n            ->getForHumansParameters($syntax, $short, $parts, $options);\\n\\n        $interval = [];\\n\\n        $syntax = (int) ($syntax ?? CarbonInterface::DIFF_ABSOLUTE);\\n        $absolute = $syntax === CarbonInterface::DIFF_ABSOLUTE;\\n        $relativeToNow = $syntax === CarbonInterface::DIFF_RELATIVE_TO_NOW;\\n        $count = 1;\\n        $unit = $short ? 's' : 'second';\\n        $isFuture = $this->invert === 1;\\n        $transId = $relativeToNow ? ($isFuture ? 'from_now' : 'ago') : ($isFuture ? 'after' : 'before');\\n        $declensionMode = null;\\n\\n        $translator ??= $this->getLocalTranslator();\\n\\n        $handleDeclensions = function ($unit, $count, $index = 0, $parts = 1) use ($interpolations, $transId, $translator, $altNumbers, $absolute, &$declensionMode) {\\n            if (!$absolute) {\\n                $declensionMode = $declensionMode ?? $this->translate($transId.'_mode');\\n\\n                if ($this->needsDeclension($declensionMode, $index, $parts)) {\\n                    \/\/ Some languages have special pluralization for past and future tense.\\n                    $key = $unit.'_'.$transId;\\n                    $result = $this->translate($key, $interpolations, $count, $translator, $altNumbers);\\n\\n                    if ($result !== $key) {\\n                        return $result;\\n                    }\\n                }\\n            }\\n\\n            $result = $this->translate($unit, $interpolations, $count, $translator, $altNumbers);\\n\\n            if ($result !== $unit) {\\n                return $result;\\n            }\\n\\n            return null;\\n        };\\n\\n        $intervalValues = $this;\\n        $method = static::getRoundingMethodFromOptions($options);\\n\\n        if ($method) {\\n            $previousCount = INF;\\n\\n            while (\\n                \\\\count($intervalValues->getNonZeroValues()) > $parts &&\\n                ($count = \\\\count($keys = array_keys($intervalValues->getValuesSequence()))) > 1\\n            ) {\\n                $index = min($count, $previousCount - 1) - 2;\\n\\n                if ($index < 0) {\\n                    break;\\n                }\\n\\n                $intervalValues = $this->copy()->roundUnit(\\n                    $keys[$index],\\n                    1,\\n                    $method,\\n                );\\n                $previousCount = $count;\\n            }\\n        }\\n\\n        $diffIntervalArray = [\\n            ['value' => $intervalValues->years,             'unit' => 'year',        'unitShort' => 'y'],\\n            ['value' => $intervalValues->months,            'unit' => 'month',       'unitShort' => 'm'],\\n            ['value' => $intervalValues->weeks,             'unit' => 'week',        'unitShort' => 'w'],\\n            ['value' => $intervalValues->daysExcludeWeeks,  'unit' => 'day',         'unitShort' => 'd'],\\n            ['value' => $intervalValues->hours,             'unit' => 'hour',        'unitShort' => 'h'],\\n            ['value' => $intervalValues->minutes,           'unit' => 'minute',      'unitShort' => 'min'],\\n            ['value' => $intervalValues->seconds,           'unit' => 'second',      'unitShort' => 's'],\\n            ['value' => $intervalValues->milliseconds,      'unit' => 'millisecond', 'unitShort' => 'ms'],\\n            ['value' => $intervalValues->microExcludeMilli, 'unit' => 'microsecond', 'unitShort' => '\u00b5s'],\\n        ];\\n\\n        if (!empty($skip)) {\\n            foreach ($diffIntervalArray as $index => &$unitData) {\\n                $nextIndex = $index + 1;\\n\\n                if ($unitData['value'] &&\\n                    isset($diffIntervalArray[$nextIndex]) &&\\n                    \\\\count(array_intersect([$unitData['unit'], $unitData['unit'].'s', $unitData['unitShort']], $skip))\\n                ) {\\n                    $diffIntervalArray[$nextIndex]['value'] += $unitData['value'] *\\n                        self::getFactorWithDefault($diffIntervalArray[$nextIndex]['unit'], $unitData['unit']);\\n                    $unitData['value'] = 0;\\n                }\\n            }\\n        }\\n\\n        $transChoice = function ($short, $unitData, $index, $parts) use ($absolute, $handleDeclensions, $translator, $aUnit, $altNumbers, $interpolations) {\\n            $count = $unitData['value'];\\n\\n            if ($short) {\\n                $result = $handleDeclensions($unitData['unitShort'], $count, $index, $parts);\\n\\n                if ($result !== null) {\\n                    return $result;\\n                }\\n            } elseif ($aUnit) {\\n                $result = $handleDeclensions('a_'.$unitData['unit'], $count, $index, $parts);\\n\\n                if ($result !== null) {\\n                    return $result;\\n                }\\n            }\\n\\n            if (!$absolute) {\\n                return $handleDeclensions($unitData['unit'], $count, $index, $parts);\\n            }\\n\\n            return $this->translate($unitData['unit'], $interpolations, $count, $translator, $altNumbers);\\n        };\\n\\n        $fallbackUnit = ['second', 's'];\\n\\n        foreach ($diffIntervalArray as $diffIntervalData) {\\n            if ($diffIntervalData['value'] > 0) {\\n                $unit = $short ? $diffIntervalData['unitShort'] : $diffIntervalData['unit'];\\n                $count = $diffIntervalData['value'];\\n                $interval[] = [$short, $diffIntervalData];\\n            } elseif ($options & CarbonInterface::SEQUENTIAL_PARTS_ONLY && \\\\count($interval) > 0) {\\n                break;\\n            }\\n\\n            \/\/ break the loop after we get the required number of parts in array\\n            if (\\\\count($interval) >= $parts) {\\n                break;\\n            }\\n\\n            \/\/ break the loop after we have reached the minimum unit\\n            if (\\\\in_array($minimumUnit, [$diffIntervalData['unit'], $diffIntervalData['unitShort']], true)) {\\n                $fallbackUnit = [$diffIntervalData['unit'], $diffIntervalData['unitShort']];\\n\\n                break;\\n            }\\n        }\\n\\n        $actualParts = \\\\count($interval);\\n\\n        foreach ($interval as $index => &$item) {\\n            $item = $transChoice($item[0], $item[1], $index, $actualParts);\\n        }\\n\\n        if (\\\\count($interval) === 0) {\\n            if ($relativeToNow && $options & CarbonInterface::JUST_NOW) {\\n                $key = 'diff_now';\\n                $translation = $this->translate($key, $interpolations, null, $translator);\\n\\n                if ($translation !== $key) {\\n                    return $translation;\\n                }\\n            }\\n\\n            $count = $options & CarbonInterface::NO_ZERO_DIFF ? 1 : 0;\\n            $unit = $fallbackUnit[$short ? 1 : 0];\\n            $interval[] = $this->translate($unit, $interpolations, $count, $translator, $altNumbers);\\n        }\\n\\n        \/\/ join the interval parts by a space\\n        $time = $join($interval);\\n\\n        unset($diffIntervalArray, $interval);\\n\\n        if ($absolute) {\\n            return $time;\\n        }\\n\\n        $isFuture = $this->invert === 1;\\n\\n        $transId = $relativeToNow ? ($isFuture ? 'from_now' : 'ago') : ($isFuture ? 'after' : 'before');\\n\\n        if ($parts === 1) {\\n            if ($relativeToNow && $unit === 'day') {\\n                $specialTranslations = static::SPECIAL_TRANSLATIONS[$count] ?? null;\\n\\n                if ($specialTranslations && $options & $specialTranslations['option']) {\\n                    $key = $specialTranslations[$isFuture ? 'future' : 'past'];\\n                    $translation = $this->translate($key, $interpolations, null, $translator);\\n\\n                    if ($translation !== $key) {\\n                        return $translation;\\n                    }\\n                }\\n            }\\n\\n            $aTime = $aUnit ? $handleDeclensions('a_'.$unit, $count) : null;\\n\\n            $time = $aTime ?: $handleDeclensions($unit, $count) ?: $time;\\n        }\\n\\n        $time = [':time' => $time];\\n\\n        return $this->translate($transId, array_merge($time, $interpolations, $time), null, $translator);\\n    }\\n\\n    public function format(string $format): string\\n    {\\n        $output = parent::format($format);\\n\\n        if (!str_contains($format, '%a') || !isset($this->startDate, $this->endDate)) {\\n            return $output;\\n        }\\n\\n        $this->rawInterval ??= $this->startDate->diffAsDateInterval($this->endDate);\\n\\n        return str_replace('(unknown)', $this->rawInterval->format('%a'), $output);\\n    }\\n\\n    \/**\\n     * Format the instance as a string using the forHumans() function.\\n     *\\n     * @throws Exception\\n     *\\n     * @return string\\n     *\/\\n    public function __toString(): string\\n    {\\n        $format = $this->localToStringFormat\\n            ?? $this->getFactory()->getSettings()['toStringFormat']\\n            ?? null;\\n\\n        if (!$format) {\\n            return $this->forHumans();\\n        }\\n\\n        if ($format instanceof Closure) {\\n            return $format($this);\\n        }\\n\\n        return $this->format($format);\\n    }\\n\\n    \/**\\n     * Return native DateInterval PHP object matching the current instance.\\n     *\\n     * @example\\n     * ```\\n     * var_dump(CarbonInterval::hours(2)->toDateInterval());\\n     * ```\\n     *\\n     * @return DateInterval\\n     *\/\\n    public function toDateInterval(): DateInterval\\n    {\\n        return self::castIntervalToClass($this, DateInterval::class);\\n    }\\n\\n    \/**\\n     * Convert the interval to a CarbonPeriod.\\n     *\\n     * @param DateTimeInterface|string|int ...$params Start date, [end date or recurrences] and optional settings.\\n     *\\n     * @return CarbonPeriod\\n     *\/\\n    public function toPeriod(...$params): CarbonPeriod\\n    {\\n        if ($this->timezoneSetting) {\\n            $timeZone = \\\\is_string($this->timezoneSetting)\\n                ? new DateTimeZone($this->timezoneSetting)\\n                : $this->timezoneSetting;\\n\\n            if ($timeZone instanceof DateTimeZone) {\\n                array_unshift($params, $timeZone);\\n            }\\n        }\\n\\n        $class = ($params[0] ?? null) instanceof DateTime ? CarbonPeriod::class : CarbonPeriodImmutable::class;\\n\\n        return $class::create($this, ...$params);\\n    }\\n\\n    \/**\\n     * Decompose the current interval into\\n     *\\n     * @param mixed|int|DateInterval|string|Closure|Unit|null $interval interval or number of the given $unit\\n     * @param Unit|string|null                                $unit     if specified, $interval must be an integer\\n     *\\n     * @return CarbonPeriod\\n     *\/\\n    public function stepBy($interval, Unit|string|null $unit = null): CarbonPeriod\\n    {\\n        $this->checkStartAndEnd();\\n        $start = $this->startDate ?? CarbonImmutable::make('now');\\n        $end = $this->endDate ?? $start->copy()->add($this);\\n\\n        try {\\n            $step = static::make($interval, $unit);\\n        } catch (InvalidFormatException $exception) {\\n            if ($unit || (\\\\is_string($interval) ? preg_match('\/(\\\\s|\\\\d)\/', $interval) : !($interval instanceof Unit))) {\\n                throw $exception;\\n            }\\n\\n            $step = static::make(1, $interval);\\n        }\\n\\n        $class = $start instanceof DateTime ? CarbonPeriod::class : CarbonPeriodImmutable::class;\\n\\n        return $class::create($step, $start, $end);\\n    }\\n\\n    \/**\\n     * Invert the interval.\\n     *\\n     * @param bool|int $inverted if a parameter is passed, the passed value cast as 1 or 0 is used\\n     *                           as the new value of the ->invert property.\\n     *\\n     * @return $this\\n     *\/\\n    public function invert($inverted = null): static\\n    {\\n        $this->invert = (\\\\func_num_args() === 0 ? !$this->invert : $inverted) ? 1 : 0;\\n\\n        return $this;\\n    }\\n\\n    protected function solveNegativeInterval(): static\\n    {\\n        if (!$this->isEmpty() && $this->years <= 0 && $this->months <= 0 && $this->dayz <= 0 && $this->hours <= 0 && $this->minutes <= 0 && $this->seconds <= 0 && $this->microseconds <= 0) {\\n            $this->years *= self::NEGATIVE;\\n            $this->months *= self::NEGATIVE;\\n            $this->dayz *= self::NEGATIVE;\\n            $this->hours *= self::NEGATIVE;\\n            $this->minutes *= self::NEGATIVE;\\n            $this->seconds *= self::NEGATIVE;\\n            $this->microseconds *= self::NEGATIVE;\\n            $this->invert();\\n        }\\n\\n        return $this;\\n    }\\n\\n    \/**\\n     * Add the passed interval to the current instance.\\n     *\\n     * @param string|DateInterval $unit\\n     * @param int|float           $value\\n     *\\n     * @return $this\\n     *\/\\n    public function add($unit, $value = 1): static\\n    {\\n        if (is_numeric($unit)) {\\n            [$value, $unit] = [$unit, $value];\\n        }\\n\\n        if (\\\\is_string($unit) && !preg_match('\/^\\\\s*-?\\\\d\/', $unit)) {\\n            $unit = \\\"$value $unit\\\";\\n            $value = 1;\\n        }\\n\\n        $interval = static::make($unit);\\n\\n        if (!$interval) {\\n            throw new InvalidIntervalException('This type of data cannot be added\/subtracted.');\\n        }\\n\\n        if ($value !== 1) {\\n            $interval->times($value);\\n        }\\n\\n        $sign = ($this->invert === 1) !== ($interval->invert === 1) ? self::NEGATIVE : self::POSITIVE;\\n        $this->years += $interval->y * $sign;\\n        $this->months += $interval->m * $sign;\\n        $this->dayz += ($interval->days === false ? $interval->d : $interval->days) * $sign;\\n        $this->hours += $interval->h * $sign;\\n        $this->minutes += $interval->i * $sign;\\n        $this->seconds += $interval->s * $sign;\\n        $this->microseconds += $interval->microseconds * $sign;\\n\\n        $this->solveNegativeInterval();\\n\\n        return $this;\\n    }\\n\\n    \/**\\n     * Subtract the passed interval to the current instance.\\n     *\\n     * @param string|DateInterval $unit\\n     * @param int|float           $value\\n     *\\n     * @return $this\\n     *\/\\n    public function sub($unit, $value = 1): static\\n    {\\n        if (is_numeric($unit)) {\\n            [$value, $unit] = [$unit, $value];\\n        }\\n\\n        return $this->add($unit, -(float) $value);\\n    }\\n\\n    \/**\\n     * Subtract the passed interval to the current instance.\\n     *\\n     * @param string|DateInterval $unit\\n     * @param int|float           $value\\n     *\\n     * @return $this\\n     *\/\\n    public function subtract($unit, $value = 1): static\\n    {\\n        return $this->sub($unit, $value);\\n    }\\n\\n    \/**\\n     * Add given parameters to the current interval.\\n     *\\n     * @param int       $years\\n     * @param int       $months\\n     * @param int|float $weeks\\n     * @param int|float $days\\n     * @param int|float $hours\\n     * @param int|float $minutes\\n     * @param int|float $seconds\\n     * @param int|float $microseconds\\n     *\\n     * @return $this\\n     *\/\\n    public function plus(\\n        $years = 0,\\n        $months = 0,\\n        $weeks = 0,\\n        $days = 0,\\n        $hours = 0,\\n        $minutes = 0,\\n        $seconds = 0,\\n        $microseconds = 0\\n    ): static {\\n        return $this->add(\\\"\\n            $years years $months months $weeks weeks $days days\\n            $hours hours $minutes minutes $seconds seconds $microseconds microseconds\\n        \\\");\\n    }\\n\\n    \/**\\n     * Add given parameters to the current interval.\\n     *\\n     * @param int       $years\\n     * @param int       $months\\n     * @param int|float $weeks\\n     * @param int|float $days\\n     * @param int|float $hours\\n     * @param int|float $minutes\\n     * @param int|float $seconds\\n     * @param int|float $microseconds\\n     *\\n     * @return $this\\n     *\/\\n    public function minus(\\n        $years = 0,\\n        $months = 0,\\n        $weeks = 0,\\n        $days = 0,\\n        $hours = 0,\\n        $minutes = 0,\\n        $seconds = 0,\\n        $microseconds = 0\\n    ): static {\\n        return $this->sub(\\\"\\n            $years years $months months $weeks weeks $days days\\n            $hours hours $minutes minutes $seconds seconds $microseconds microseconds\\n        \\\");\\n    }\\n\\n    \/**\\n     * Multiply current instance given number of times. times() is naive, it multiplies each unit\\n     * (so day can be greater than 31, hour can be greater than 23, etc.) and the result is rounded\\n     * separately for each unit.\\n     *\\n     * Use times() when you want a fast and approximated calculation that does not cascade units.\\n     *\\n     * For a precise and cascaded calculation,\\n     *\\n     * @see multiply()\\n     *\\n     * @param float|int $factor\\n     *\\n     * @return $this\\n     *\/\\n    public function times($factor): static\\n    {\\n        if ($factor < 0) {\\n            $this->invert = $this->invert ? 0 : 1;\\n            $factor = -$factor;\\n        }\\n\\n        $this->years = (int) round($this->years * $factor);\\n        $this->months = (int) round($this->months * $factor);\\n        $this->dayz = (int) round($this->dayz * $factor);\\n        $this->hours = (int) round($this->hours * $factor);\\n        $this->minutes = (int) round($this->minutes * $factor);\\n        $this->seconds = (int) round($this->seconds * $factor);\\n        $this->microseconds = (int) round($this->microseconds * $factor);\\n\\n        return $this;\\n    }\\n\\n    \/**\\n     * Divide current instance by a given divider. shares() is naive, it divides each unit separately\\n     * and the result is rounded for each unit. So 5 hours and 20 minutes shared by 3 becomes 2 hours\\n     * and 7 minutes.\\n     *\\n     * Use shares() when you want a fast and approximated calculation that does not cascade units.\\n     *\\n     * For a precise and cascaded calculation,\\n     *\\n     * @see divide()\\n     *\\n     * @param float|int $divider\\n     *\\n     * @return $this\\n     *\/\\n    public function shares($divider): static\\n    {\\n        return $this->times(1 \/ $divider);\\n    }\\n\\n    protected function copyProperties(self $interval, $ignoreSign = false): static\\n    {\\n        $this->years = $interval->years;\\n        $this->months = $interval->months;\\n        $this->dayz = $interval->dayz;\\n        $this->hours = $interval->hours;\\n        $this->minutes = $interval->minutes;\\n        $this->seconds = $interval->seconds;\\n        $this->microseconds = $interval->microseconds;\\n\\n        if (!$ignoreSign) {\\n            $this->invert = $interval->invert;\\n        }\\n\\n        return $this;\\n    }\\n\\n    \/**\\n     * Multiply and cascade current instance by a given factor.\\n     *\\n     * @param float|int $factor\\n     *\\n     * @return $this\\n     *\/\\n    public function multiply($factor): static\\n    {\\n        if ($factor < 0) {\\n            $this->invert = $this->invert ? 0 : 1;\\n            $factor = -$factor;\\n        }\\n\\n        $yearPart = (int) floor($this->years * $factor); \/\/ Split calculation to prevent imprecision\\n\\n        if ($yearPart) {\\n            $this->years -= $yearPart \/ $factor;\\n        }\\n\\n        return $this->copyProperties(\\n            static::create($yearPart)\\n                ->microseconds(abs($this->totalMicroseconds) * $factor)\\n                ->cascade(),\\n            true,\\n        );\\n    }\\n\\n    \/**\\n     * Divide and cascade current instance by a given divider.\\n     *\\n     * @param float|int $divider\\n     *\\n     * @return $this\\n     *\/\\n    public function divide($divider): static\\n    {\\n        return $this->multiply(1 \/ $divider);\\n    }\\n\\n    \/**\\n     * Get the interval_spec string of a date interval.\\n     *\\n     * @param DateInterval $interval\\n     *\\n     * @return string\\n     *\/\\n    public static function getDateIntervalSpec(DateInterval $interval, bool $microseconds = false, array $skip = []): string\\n    {\\n        $date = array_filter([\\n            static::PERIOD_YEARS => abs($interval->y),\\n            static::PERIOD_MONTHS => abs($interval->m),\\n            static::PERIOD_DAYS => abs($interval->d),\\n        ]);\\n\\n        $skip = array_map([Unit::class, 'toNameIfUnit'], $skip);\\n\\n        if (\\n            $interval->days >= CarbonInterface::DAYS_PER_WEEK * CarbonInterface::WEEKS_PER_MONTH &&\\n            (!isset($date[static::PERIOD_YEARS]) || \\\\count(array_intersect(['y', 'year', 'years'], $skip))) &&\\n            (!isset($date[static::PERIOD_MONTHS]) || \\\\count(array_intersect(['m', 'month', 'months'], $skip)))\\n        ) {\\n            $date = [\\n                static::PERIOD_DAYS => abs($interval->days),\\n            ];\\n        }\\n\\n        $seconds = abs($interval->s);\\n        if ($microseconds && $interval->f > 0) {\\n            $seconds = \\\\sprintf('%d.%06d', $seconds, abs($interval->f) * 1000000);\\n        }\\n\\n        $time = array_filter([\\n            static::PERIOD_HOURS => abs($interval->h),\\n            static::PERIOD_MINUTES => abs($interval->i),\\n            static::PERIOD_SECONDS => $seconds,\\n        ]);\\n\\n        $specString = static::PERIOD_PREFIX;\\n\\n        foreach ($date as $key => $value) {\\n            $specString .= $value.$key;\\n        }\\n\\n        if (\\\\count($time) > 0) {\\n            $specString .= static::PERIOD_TIME_PREFIX;\\n            foreach ($time as $key => $value) {\\n                $specString .= $value.$key;\\n            }\\n        }\\n\\n        return $specString === static::PERIOD_PREFIX ? 'PT0S' : $specString;\\n    }\\n\\n    \/**\\n     * Get the interval_spec string.\\n     *\\n     * @return string\\n     *\/\\n    public function spec(bool $microseconds = false): string\\n    {\\n        return static::getDateIntervalSpec($this, $microseconds);\\n    }\\n\\n    \/**\\n     * Comparing 2 date intervals.\\n     *\\n     * @param DateInterval $first\\n     * @param DateInterval $second\\n     *\\n     * @return int 0, 1 or -1\\n     *\/\\n    public static function compareDateIntervals(DateInterval $first, DateInterval $second): int\\n    {\\n        $current = Carbon::now();\\n        $passed = $current->avoidMutation()->add($second);\\n        $current->add($first);\\n\\n        return $current <=> $passed;\\n    }\\n\\n    \/**\\n     * Comparing with passed interval.\\n     *\\n     * @param DateInterval $interval\\n     *\\n     * @return int 0, 1 or -1\\n     *\/\\n    public function compare(DateInterval $interval): int\\n    {\\n        return static::compareDateIntervals($this, $interval);\\n    }\\n\\n    \/**\\n     * Convert overflowed values into bigger units.\\n     *\\n     * @return $this\\n     *\/\\n    public function cascade(): static\\n    {\\n        return $this->doCascade(false);\\n    }\\n\\n    public function hasNegativeValues(): bool\\n    {\\n        foreach ($this->toArray() as $value) {\\n            if ($value < 0) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    public function hasPositiveValues(): bool\\n    {\\n        foreach ($this->toArray() as $value) {\\n            if ($value > 0) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    \/**\\n     * Get amount of given unit equivalent to the interval.\\n     *\\n     * @param string $unit\\n     *\\n     * @throws UnknownUnitException|UnitNotConfiguredException\\n     *\\n     * @return float\\n     *\/\\n    public function total(string $unit): float\\n    {\\n        $realUnit = $unit = strtolower($unit);\\n\\n        if (\\\\in_array($unit, ['days', 'weeks'])) {\\n            $realUnit = 'dayz';\\n        } elseif (!\\\\in_array($unit, ['microseconds', 'milliseconds', 'seconds', 'minutes', 'hours', 'dayz', 'months', 'years'])) {\\n            throw new UnknownUnitException($unit);\\n        }\\n\\n        $this->checkStartAndEnd();\\n\\n        if ($this->startDate && $this->endDate) {\\n            $diff = $this->startDate->diffInUnit($unit, $this->endDate);\\n\\n            return $this->absolute ? abs($diff) : $diff;\\n        }\\n\\n        $result = 0;\\n        $cumulativeFactor = 0;\\n        $unitFound = false;\\n        $factors = self::getFlipCascadeFactors();\\n        $daysPerWeek = (int) static::getDaysPerWeek();\\n\\n        $values = [\\n            'years' => $this->years,\\n            'months' => $this->months,\\n            'weeks' => (int) ($this->d \/ $daysPerWeek),\\n            'dayz' => fmod($this->d, $daysPerWeek),\\n            'hours' => $this->hours,\\n            'minutes' => $this->minutes,\\n            'seconds' => $this->seconds,\\n            'milliseconds' => (int) ($this->microseconds \/ Carbon::MICROSECONDS_PER_MILLISECOND),\\n            'microseconds' => $this->microseconds % Carbon::MICROSECONDS_PER_MILLISECOND,\\n        ];\\n\\n        if (isset($factors['dayz']) && $factors['dayz'][0] !== 'weeks') {\\n            $values['dayz'] += $values['weeks'] * $daysPerWeek;\\n            $values['weeks'] = 0;\\n        }\\n\\n        foreach ($factors as $source => [$target, $factor]) {\\n            if ($source === $realUnit) {\\n                $unitFound = true;\\n                $value = $values[$source];\\n                $result += $value;\\n                $cumulativeFactor = 1;\\n            }\\n\\n            if ($factor === false) {\\n                if ($unitFound) {\\n                    break;\\n                }\\n\\n                $result = 0;\\n                $cumulativeFactor = 0;\\n\\n                continue;\\n            }\\n\\n            if ($target === $realUnit) {\\n                $unitFound = true;\\n            }\\n\\n            if ($cumulativeFactor) {\\n                $cumulativeFactor *= $factor;\\n                $result += $values[$target] * $cumulativeFactor;\\n\\n                continue;\\n            }\\n\\n            $value = $values[$source];\\n\\n            $result = ($result + $value) \/ $factor;\\n        }\\n\\n        if (isset($target) && !$cumulativeFactor) {\\n            $result += $values[$target];\\n        }\\n\\n        if (!$unitFound) {\\n            throw new UnitNotConfiguredException($unit);\\n        }\\n\\n        if ($this->invert) {\\n            $result *= self::NEGATIVE;\\n        }\\n\\n        if ($unit === 'weeks') {\\n            $result \/= $daysPerWeek;\\n        }\\n\\n        \/\/ Cast as int numbers with no decimal part\\n        return fmod($result, 1) === 0.0 ? (int) $result : $result;\\n    }\\n\\n    \/**\\n     * Determines if the instance is equal to another\\n     *\\n     * @param CarbonInterval|DateInterval|mixed $interval\\n     *\\n     * @see equalTo()\\n     *\\n     * @return bool\\n     *\/\\n    public function eq($interval): bool\\n    {\\n        return $this->equalTo($interval);\\n    }\\n\\n    \/**\\n     * Determines if the instance is equal to another\\n     *\\n     * @param CarbonInterval|DateInterval|mixed $interval\\n     *\\n     * @return bool\\n     *\/\\n    public function equalTo($interval): bool\\n    {\\n        $interval = $this->resolveInterval($interval);\\n\\n        if ($interval === null) {\\n            return false;\\n        }\\n\\n        $step = $this->getStep();\\n\\n        if ($step) {\\n            return $step === $interval->getStep();\\n        }\\n\\n        if ($this->isEmpty()) {\\n            return $interval->isEmpty();\\n        }\\n\\n        $cascadedInterval = $this->copy()->cascade();\\n        $comparedInterval = $interval->copy()->cascade();\\n\\n        return $cascadedInterval->invert === $comparedInterval->invert &&\\n            $cascadedInterval->getNonZeroValues() === $comparedInterval->getNonZeroValues();\\n    }\\n\\n    \/**\\n     * Determines if the instance is not equal to another\\n     *\\n     * @param CarbonInterval|DateInterval|mixed $interval\\n     *\\n     * @see notEqualTo()\\n     *\\n     * @return bool\\n     *\/\\n    public function ne($interval): bool\\n    {\\n        return $this->notEqualTo($interval);\\n    }\\n\\n    \/**\\n     * Determines if the instance is not equal to another\\n     *\\n     * @param CarbonInterval|DateInterval|mixed $interval\\n     *\\n     * @return bool\\n     *\/\\n    public function notEqualTo($interval): bool\\n    {\\n        return !$this->eq($interval);\\n    }\\n\\n    \/**\\n     * Determines if the instance is greater (longer) than another\\n     *\\n     * @param CarbonInterval|DateInterval|mixed $interval\\n     *\\n     * @see greaterThan()\\n     *\\n     * @return bool\\n     *\/\\n    public function gt($interval): bool\\n    {\\n        return $this->greaterThan($interval);\\n    }\\n\\n    \/**\\n     * Determines if the instance is greater (longer) than another\\n     *\\n     * @param CarbonInterval|DateInterval|mixed $interval\\n     *\\n     * @return bool\\n     *\/\\n    public function greaterThan($interval): bool\\n    {\\n        $interval = $this->resolveInterval($interval);\\n\\n        return $interval === null || $this->totalMicroseconds > $interval->totalMicroseconds;\\n    }\\n\\n    \/**\\n     * Determines if the instance is greater (longer) than or equal to another\\n     *\\n     * @param CarbonInterval|DateInterval|mixed $interval\\n     *\\n     * @see greaterThanOrEqualTo()\\n     *\\n     * @return bool\\n     *\/\\n    public function gte($interval): bool\\n    {\\n        return $this->greaterThanOrEqualTo($interval);\\n    }\\n\\n    \/**\\n     * Determines if the instance is greater (longer) than or equal to another\\n     *\\n     * @param CarbonInterval|DateInterval|mixed $interval\\n     *\\n     * @return bool\\n     *\/\\n    public function greaterThanOrEqualTo($interval): bool\\n    {\\n        return $this->greaterThan($interval) || $this->equalTo($interval);\\n    }\\n\\n    \/**\\n     * Determines if the instance is less (shorter) than another\\n     *\\n     * @param CarbonInterval|DateInterval|mixed $interval\\n     *\\n     * @see lessThan()\\n     *\\n     * @return bool\\n     *\/\\n    public function lt($interval): bool\\n    {\\n        return $this->lessThan($interval);\\n    }\\n\\n    \/**\\n     * Determines if the instance is less (shorter) than another\\n     *\\n     * @param CarbonInterval|DateInterval|mixed $interval\\n     *\\n     * @return bool\\n     *\/\\n    public function lessThan($interval): bool\\n    {\\n        $interval = $this->resolveInterval($interval);\\n\\n        return $interval !== null && $this->totalMicroseconds < $interval->totalMicroseconds;\\n    }\\n\\n    \/**\\n     * Determines if the instance is less (shorter) than or equal to another\\n     *\\n     * @param CarbonInterval|DateInterval|mixed $interval\\n     *\\n     * @see lessThanOrEqualTo()\\n     *\\n     * @return bool\\n     *\/\\n    public function lte($interval): bool\\n    {\\n        return $this->lessThanOrEqualTo($interval);\\n    }\\n\\n    \/**\\n     * Determines if the instance is less (shorter) than or equal to another\\n     *\\n     * @param CarbonInterval|DateInterval|mixed $interval\\n     *\\n     * @return bool\\n     *\/\\n    public function lessThanOrEqualTo($interval): bool\\n    {\\n        return $this->lessThan($interval) || $this->equalTo($interval);\\n    }\\n\\n    \/**\\n     * Determines if the instance is between two others.\\n     *\\n     * The third argument allow you to specify if bounds are included or not (true by default)\\n     * but for when you including\/excluding bounds may produce different results in your application,\\n     * we recommend to use the explicit methods ->betweenIncluded() or ->betweenExcluded() instead.\\n     *\\n     * @example\\n     * ```\\n     * CarbonInterval::hours(48)->between(CarbonInterval::day(), CarbonInterval::days(3)); \/\/ true\\n     * CarbonInterval::hours(48)->between(CarbonInterval::day(), CarbonInterval::hours(36)); \/\/ false\\n     * CarbonInterval::hours(48)->between(CarbonInterval::day(), CarbonInterval::days(2)); \/\/ true\\n     * CarbonInterval::hours(48)->between(CarbonInterval::day(), CarbonInterval::days(2), false); \/\/ false\\n     * ```\\n     *\\n     * @param CarbonInterval|DateInterval|mixed $interval1\\n     * @param CarbonInterval|DateInterval|mixed $interval2\\n     * @param bool                              $equal     Indicates if an equal to comparison should be done\\n     *\\n     * @return bool\\n     *\/\\n    public function between($interval1, $interval2, bool $equal = true): bool\\n    {\\n        return $equal\\n            ? $this->greaterThanOrEqualTo($interval1) && $this->lessThanOrEqualTo($interval2)\\n            : $this->greaterThan($interval1) && $this->lessThan($interval2);\\n    }\\n\\n    \/**\\n     * Determines if the instance is between two others, bounds excluded.\\n     *\\n     * @example\\n     * ```\\n     * CarbonInterval::hours(48)->betweenExcluded(CarbonInterval::day(), CarbonInterval::days(3)); \/\/ true\\n     * CarbonInterval::hours(48)->betweenExcluded(CarbonInterval::day(), CarbonInterval::hours(36)); \/\/ false\\n     * CarbonInterval::hours(48)->betweenExcluded(CarbonInterval::day(), CarbonInterval::days(2)); \/\/ true\\n     * ```\\n     *\\n     * @param CarbonInterval|DateInterval|mixed $interval1\\n     * @param CarbonInterval|DateInterval|mixed $interval2\\n     *\\n     * @return bool\\n     *\/\\n    public function betweenIncluded($interval1, $interval2): bool\\n    {\\n        return $this->between($interval1, $interval2, true);\\n    }\\n\\n    \/**\\n     * Determines if the instance is between two others, bounds excluded.\\n     *\\n     * @example\\n     * ```\\n     * CarbonInterval::hours(48)->betweenExcluded(CarbonInterval::day(), CarbonInterval::days(3)); \/\/ true\\n     * CarbonInterval::hours(48)->betweenExcluded(CarbonInterval::day(), CarbonInterval::hours(36)); \/\/ false\\n     * CarbonInterval::hours(48)->betweenExcluded(CarbonInterval::day(), CarbonInterval::days(2)); \/\/ false\\n     * ```\\n     *\\n     * @param CarbonInterval|DateInterval|mixed $interval1\\n     * @param CarbonInterval|DateInterval|mixed $interval2\\n     *\\n     * @return bool\\n     *\/\\n    public function betweenExcluded($interval1, $interval2): bool\\n    {\\n        return $this->between($interval1, $interval2, false);\\n    }\\n\\n    \/**\\n     * Determines if the instance is between two others\\n     *\\n     * @example\\n     * ```\\n     * CarbonInterval::hours(48)->isBetween(CarbonInterval::day(), CarbonInterval::days(3)); \/\/ true\\n     * CarbonInterval::hours(48)->isBetween(CarbonInterval::day(), CarbonInterval::hours(36)); \/\/ false\\n     * CarbonInterval::hours(48)->isBetween(CarbonInterval::day(), CarbonInterval::days(2)); \/\/ true\\n     * CarbonInterval::hours(48)->isBetween(CarbonInterval::day(), CarbonInterval::days(2), false); \/\/ false\\n     * ```\\n     *\\n     * @param CarbonInterval|DateInterval|mixed $interval1\\n     * @param CarbonInterval|DateInterval|mixed $interval2\\n     * @param bool                              $equal     Indicates if an equal to comparison should be done\\n     *\\n     * @return bool\\n     *\/\\n    public function isBetween($interval1, $interval2, bool $equal = true): bool\\n    {\\n        return $this->between($interval1, $interval2, $equal);\\n    }\\n\\n    \/**\\n     * Round the current instance at the given unit with given precision if specified and the given function.\\n     *\\n     * @throws Exception\\n     *\/\\n    public function roundUnit(string $unit, DateInterval|string|int|float $precision = 1, string $function = 'round'): static\\n    {\\n        if (static::getCascadeFactors() !== static::getDefaultCascadeFactors()) {\\n            $value = $function($this->total($unit) \/ $precision) * $precision;\\n            $inverted = $value < 0;\\n\\n            return $this->copyProperties(self::fromString(\\n                number_format(abs($value), 12, '.', '').' '.$unit\\n            )->invert($inverted)->cascade());\\n        }\\n\\n        $base = CarbonImmutable::parse('2000-01-01 00:00:00', 'UTC')\\n            ->roundUnit($unit, $precision, $function);\\n        $next = $base->add($this);\\n        $inverted = $next < $base;\\n\\n        if ($inverted) {\\n            $next = $base->sub($this);\\n        }\\n\\n        $this->copyProperties(\\n            $next\\n                ->roundUnit($unit, $precision, $function)\\n                ->diff($base),\\n        );\\n\\n        return $this->invert($inverted);\\n    }\\n\\n    \/**\\n     * Truncate the current instance at the given unit with given precision if specified.\\n     *\\n     * @param string                             $unit\\n     * @param float|int|string|DateInterval|null $precision\\n     *\\n     * @throws Exception\\n     *\\n     * @return $this\\n     *\/\\n    public function floorUnit(string $unit, $precision = 1): static\\n    {\\n        return $this->roundUnit($unit, $precision, 'floor');\\n    }\\n\\n    \/**\\n     * Ceil the current instance at the given unit with given precision if specified.\\n     *\\n     * @param string                             $unit\\n     * @param float|int|string|DateInterval|null $precision\\n     *\\n     * @throws Exception\\n     *\\n     * @return $this\\n     *\/\\n    public function ceilUnit(string $unit, $precision = 1): static\\n    {\\n        return $this->roundUnit($unit, $precision, 'ceil');\\n    }\\n\\n    \/**\\n     * Round the current instance second with given precision if specified.\\n     *\\n     * @param float|int|string|DateInterval|null $precision\\n     * @param string                             $function\\n     *\\n     * @throws Exception\\n     *\\n     * @return $this\\n     *\/\\n    public function round($precision = 1, string $function = 'round'): static\\n    {\\n        return $this->roundWith($precision, $function);\\n    }\\n\\n    \/**\\n     * Round the current instance second with given precision if specified.\\n     *\\n     * @throws Exception\\n     *\\n     * @return $this\\n     *\/\\n    public function floor(DateInterval|string|float|int $precision = 1): static\\n    {\\n        return $this->round($precision, 'floor');\\n    }\\n\\n    \/**\\n     * Ceil the current instance second with given precision if specified.\\n     *\\n     * @throws Exception\\n     *\\n     * @return $this\\n     *\/\\n    public function ceil(DateInterval|string|float|int $precision = 1): static\\n    {\\n        return $this->round($precision, 'ceil');\\n    }\\n\\n    public function __unserialize(array $data): void\\n    {\\n        $properties = array_combine(\\n            array_map(\\n                static fn (mixed $key) => \\\\is_string($key)\\n                    ? str_replace('tzName', 'timezoneSetting', $key)\\n                    : $key,\\n                array_keys($data),\\n            ),\\n            $data,\\n        );\\n\\n        if (method_exists(parent::class, '__unserialize')) {\\n            \/\/ PHP >= 8.2\\n            parent::__unserialize($properties);\\n\\n            return;\\n        }\\n\\n        \/\/ PHP <= 8.1\\n        \/\/ @codeCoverageIgnoreStart\\n        $properties = array_combine(\\n            array_map(\\n                static fn (string $property) => preg_replace('\/^\\\\0.+\\\\0\/', '', $property),\\n                array_keys($data),\\n            ),\\n            $data,\\n        );\\n        $localStrictMode = $this->localStrictModeEnabled;\\n        $this->localStrictModeEnabled = false;\\n        $days = $properties['days'] ?? false;\\n        $this->days = $days === false ? false : (int) $days;\\n        $this->y = (int) ($properties['y'] ?? 0);\\n        $this->m = (int) ($properties['m'] ?? 0);\\n        $this->d = (int) ($properties['d'] ?? 0);\\n        $this->h = (int) ($properties['h'] ?? 0);\\n        $this->i = (int) ($properties['i'] ?? 0);\\n        $this->s = (int) ($properties['s'] ?? 0);\\n        $this->f = (float) ($properties['f'] ?? 0.0);\\n        \/\/ @phpstan-ignore-next-line\\n        $this->weekday = (int) ($properties['weekday'] ?? 0);\\n        \/\/ @phpstan-ignore-next-line\\n        $this->weekday_behavior = (int) ($properties['weekday_behavior'] ?? 0);\\n        \/\/ @phpstan-ignore-next-line\\n        $this->first_last_day_of = (int) ($properties['first_last_day_of'] ?? 0);\\n        $this->invert = (int) ($properties['invert'] ?? 0);\\n        \/\/ @phpstan-ignore-next-line\\n        $this->special_type = (int) ($properties['special_type'] ?? 0);\\n        \/\/ @phpstan-ignore-next-line\\n        $this->special_amount = (int) ($properties['special_amount'] ?? 0);\\n        \/\/ @phpstan-ignore-next-line\\n        $this->have_weekday_relative = (int) ($properties['have_weekday_relative'] ?? 0);\\n        \/\/ @phpstan-ignore-next-line\\n        $this->have_special_relative = (int) ($properties['have_special_relative'] ?? 0);\\n        parent::__construct(self::getDateIntervalSpec($this));\\n\\n        foreach ($properties as $property => $value) {\\n            if ($property === 'localStrictModeEnabled') {\\n                continue;\\n            }\\n\\n            $this->$property = $value;\\n        }\\n\\n        $this->localStrictModeEnabled = $properties['localStrictModeEnabled'] ?? $localStrictMode;\\n        \/\/ @codeCoverageIgnoreEnd\\n    }\\n\\n    \/**\\n     * @template T\\n     *\\n     * @param T     $interval\\n     * @param mixed $original\\n     *\\n     * @return T\\n     *\/\\n    private static function withOriginal(mixed $interval, mixed $original): mixed\\n    {\\n        if ($interval instanceof self) {\\n            $interval->originalInput = $original;\\n        }\\n\\n        return $interval;\\n    }\\n\\n    private static function standardizeUnit(string $unit): string\\n    {\\n        $unit = rtrim($unit, 'sz').'s';\\n\\n        return $unit === 'days' ? 'dayz' : $unit;\\n    }\\n\\n    private static function getFlipCascadeFactors(): array\\n    {\\n        if (!self::$flipCascadeFactors) {\\n            self::$flipCascadeFactors = [];\\n\\n            foreach (self::getCascadeFactors() as $to => [$factor, $from]) {\\n                self::$flipCascadeFactors[self::standardizeUnit($from)] = [self::standardizeUnit($to), $factor];\\n            }\\n        }\\n\\n        return self::$flipCascadeFactors;\\n    }\\n\\n    \/**\\n     * @template T of DateInterval\\n     *\\n     * @param DateInterval $interval\\n     *\\n     * @psalm-param class-string<T> $className\\n     *\\n     * @return T\\n     *\/\\n    private static function castIntervalToClass(DateInterval $interval, string $className, array $skip = []): object\\n    {\\n        $mainClass = DateInterval::class;\\n\\n        if (!is_a($className, $mainClass, true)) {\\n            throw new InvalidCastException(\\\"$className is not a sub-class of $mainClass.\\\");\\n        }\\n\\n        $microseconds = $interval->f;\\n        $instance = self::buildInstance($interval, $className, $skip);\\n\\n        if ($instance instanceof self) {\\n            $instance->originalInput = $interval;\\n        }\\n\\n        if ($microseconds) {\\n            $instance->f = $microseconds;\\n        }\\n\\n        if ($interval instanceof self && is_a($className, self::class, true)) {\\n            self::copyStep($interval, $instance);\\n        }\\n\\n        self::copyNegativeUnits($interval, $instance);\\n\\n        return self::withOriginal($instance, $interval);\\n    }\\n\\n    \/**\\n     * @template T of DateInterval\\n     *\\n     * @param DateInterval $interval\\n     *\\n     * @psalm-param class-string<T> $className\\n     *\\n     * @return T\\n     *\/\\n    private static function buildInstance(\\n        DateInterval $interval,\\n        string $className,\\n        array $skip = [],\\n    ): object {\\n        $serialization = self::buildSerializationString($interval, $className, $skip);\\n\\n        return match ($serialization) {\\n            null => new $className(static::getDateIntervalSpec($interval, false, $skip)),\\n            default => unserialize($serialization),\\n        };\\n    }\\n\\n    \/**\\n     * As demonstrated by rlanvin (https:\/\/github.com\/rlanvin) in\\n     * https:\/\/github.com\/briannesbitt\/Carbon\/issues\/3018#issuecomment-2888538438\\n     *\\n     * Modifying the output of serialize() to change the class name and unserializing\\n     * the tweaked string allows creating new interval instances where the ->days\\n     * property can be set. It's not possible neither with `new` nto with `__set_state`.\\n     *\\n     * It has a non-negligible performance cost, so we'll use this method only if\\n     * $interval->days !== false.\\n     *\/\\n    private static function buildSerializationString(\\n        DateInterval $interval,\\n        string $className,\\n        array $skip = [],\\n    ): ?string {\\n        if ($interval->days === false || PHP_VERSION_ID < 8_02_00 || $skip !== []) {\\n            return null;\\n        }\\n\\n        \/\/ De-enhance CarbonInterval objects to be serializable back to DateInterval\\n        if ($interval instanceof self && !is_a($className, self::class, true)) {\\n            $interval = clone $interval;\\n            unset($interval->timezoneSetting);\\n            unset($interval->originalInput);\\n            unset($interval->startDate);\\n            unset($interval->endDate);\\n            unset($interval->rawInterval);\\n            unset($interval->absolute);\\n            unset($interval->initialValues);\\n            unset($interval->clock);\\n            unset($interval->step);\\n            unset($interval->localMonthsOverflow);\\n            unset($interval->localYearsOverflow);\\n            unset($interval->localStrictModeEnabled);\\n            unset($interval->localHumanDiffOptions);\\n            unset($interval->localToStringFormat);\\n            unset($interval->localSerializer);\\n            unset($interval->localMacros);\\n            unset($interval->localGenericMacros);\\n            unset($interval->localFormatFunction);\\n            unset($interval->localTranslator);\\n        }\\n\\n        $serialization = serialize($interval);\\n        $inputClass = $interval::class;\\n        $expectedStart = 'O:'.\\\\strlen($inputClass).':\\\"'.$inputClass.'\\\":';\\n\\n        if (!str_starts_with($serialization, $expectedStart)) {\\n            return null; \/\/ @codeCoverageIgnore\\n        }\\n\\n        return 'O:'.\\\\strlen($className).':\\\"'.$className.'\\\":'.substr($serialization, \\\\strlen($expectedStart));\\n    }\\n\\n    private static function copyStep(self $from, self $to): void\\n    {\\n        $to->setStep($from->getStep());\\n    }\\n\\n    private static function copyNegativeUnits(DateInterval $from, DateInterval $to): void\\n    {\\n        $to->invert = $from->invert;\\n\\n        foreach (['y', 'm', 'd', 'h', 'i', 's'] as $unit) {\\n            if ($from->$unit < 0) {\\n                self::setIntervalUnit($to, $unit, $to->$unit * self::NEGATIVE);\\n            }\\n        }\\n    }\\n\\n    private function invertCascade(array $values): static\\n    {\\n        return $this->set(array_map(function ($value) {\\n            return -$value;\\n        }, $values))->doCascade(true)->invert();\\n    }\\n\\n    private function doCascade(bool $deep): static\\n    {\\n        $originalData = $this->toArray();\\n        $originalData['milliseconds'] = (int) ($originalData['microseconds'] \/ static::getMicrosecondsPerMillisecond());\\n        $originalData['microseconds'] = $originalData['microseconds'] % static::getMicrosecondsPerMillisecond();\\n        $originalData['weeks'] = (int) ($this->d \/ static::getDaysPerWeek());\\n        $originalData['daysExcludeWeeks'] = fmod($this->d, static::getDaysPerWeek());\\n        unset($originalData['days']);\\n        $newData = $originalData;\\n        $previous = [];\\n\\n        foreach (self::getFlipCascadeFactors() as $source => [$target, $factor]) {\\n            foreach (['source', 'target'] as $key) {\\n                if ($$key === 'dayz') {\\n                    $$key = 'daysExcludeWeeks';\\n                }\\n            }\\n\\n            $value = $newData[$source];\\n            $modulo = fmod($factor + fmod($value, $factor), $factor);\\n            $newData[$source] = $modulo;\\n            $newData[$target] += ($value - $modulo) \/ $factor;\\n\\n            $decimalPart = fmod($newData[$source], 1);\\n\\n            if ($decimalPart !== 0.0) {\\n                $unit = $source;\\n\\n                foreach ($previous as [$subUnit, $subFactor]) {\\n                    $newData[$unit] -= $decimalPart;\\n                    $newData[$subUnit] += $decimalPart * $subFactor;\\n                    $decimalPart = fmod($newData[$subUnit], 1);\\n\\n                    if ($decimalPart === 0.0) {\\n                        break;\\n                    }\\n\\n                    $unit = $subUnit;\\n                }\\n            }\\n\\n            array_unshift($previous, [$source, $factor]);\\n        }\\n\\n        $positive = null;\\n\\n        if (!$deep) {\\n            foreach ($newData as $value) {\\n                if ($value) {\\n                    if ($positive === null) {\\n                        $positive = ($value > 0);\\n\\n                        continue;\\n                    }\\n\\n                    if (($value > 0) !== $positive) {\\n                        return $this->invertCascade($originalData)\\n                            ->solveNegativeInterval();\\n                    }\\n                }\\n            }\\n        }\\n\\n        return $this->set($newData)\\n            ->solveNegativeInterval();\\n    }\\n\\n    private function needsDeclension(string $mode, int $index, int $parts): bool\\n    {\\n        return match ($mode) {\\n            'last' => $index === $parts - 1,\\n            default => true,\\n        };\\n    }\\n\\n    private function checkIntegerValue(string $name, mixed $value): void\\n    {\\n        if (\\\\is_int($value)) {\\n            return;\\n        }\\n\\n        $this->assertSafeForInteger($name, $value);\\n\\n        if (\\\\is_float($value) && (((float) (int) $value) === $value)) {\\n            return;\\n        }\\n\\n        if (!self::$floatSettersEnabled) {\\n            $type = \\\\gettype($value);\\n            @trigger_error(\\n                \\\"Since 2.70.0, it's deprecated to pass $type value for $name.\\\\n\\\".\\n                \\\"It's truncated when stored as an integer interval unit.\\\\n\\\".\\n                \\\"From 3.0.0, decimal part will no longer be truncated and will be cascaded to smaller units.\\\\n\\\".\\n                \\\"- To maintain the current behavior, use explicit cast: $name((int) \\\\$value)\\\\n\\\".\\n                \\\"- To adopt the new behavior globally, call CarbonInterval::enableFloatSetters()\\\\n\\\",\\n                \\\\E_USER_DEPRECATED,\\n            );\\n        }\\n    }\\n\\n    \/**\\n     * Throw an exception if precision loss when storing the given value as an integer would be >= 1.0.\\n     *\/\\n    private function assertSafeForInteger(string $name, mixed $value): void\\n    {\\n        if ($value && !\\\\is_int($value) && ($value >= 0x7fffffffffffffff || $value <= -0x7fffffffffffffff)) {\\n            throw new OutOfRangeException($name, -0x7fffffffffffffff, 0x7fffffffffffffff, $value);\\n        }\\n    }\\n\\n    private function handleDecimalPart(string $unit, mixed $value, mixed $integerValue): void\\n    {\\n        if (self::$floatSettersEnabled) {\\n            $floatValue = (float) $value;\\n            $base = (float) $integerValue;\\n\\n            if ($floatValue === $base) {\\n                return;\\n            }\\n\\n            $units = [\\n                'y' => 'year',\\n                'm' => 'month',\\n                'd' => 'day',\\n                'h' => 'hour',\\n                'i' => 'minute',\\n                's' => 'second',\\n            ];\\n            $upper = true;\\n\\n            foreach ($units as $property => $name) {\\n                if ($name === $unit) {\\n                    $upper = false;\\n\\n                    continue;\\n                }\\n\\n                if (!$upper && $this->$property !== 0) {\\n                    throw new RuntimeException(\\n                        \\\"You cannot set $unit to a float value as $name would be overridden, \\\".\\n                        'set it first to 0 explicitly if you really want to erase its value'\\n                    );\\n                }\\n            }\\n\\n            $this->add($unit, $floatValue - $base);\\n        }\\n    }\\n\\n    private function getInnerValues(): array\\n    {\\n        return [$this->y, $this->m, $this->d, $this->h, $this->i, $this->s, $this->f, $this->invert, $this->days];\\n    }\\n\\n    private function checkStartAndEnd(): void\\n    {\\n        if (\\n            $this->initialValues !== null\\n            && ($this->startDate !== null || $this->endDate !== null)\\n            && $this->initialValues !== $this->getInnerValues()\\n        ) {\\n            $this->absolute = false;\\n            $this->startDate = null;\\n            $this->endDate = null;\\n            $this->rawInterval = null;\\n        }\\n    }\\n\\n    \/** @return $this *\/\\n    private function setSetting(string $setting, mixed $value): self\\n    {\\n        switch ($setting) {\\n            case 'timezoneSetting':\\n                return $value === null ? $this : $this->setTimezone($value);\\n\\n            case 'step':\\n                $this->setStep($value);\\n\\n                return $this;\\n\\n            case 'localMonthsOverflow':\\n                return $value === null ? $this : $this->settings(['monthOverflow' => $value]);\\n\\n            case 'localYearsOverflow':\\n                return $value === null ? $this : $this->settings(['yearOverflow' => $value]);\\n\\n            case 'localStrictModeEnabled':\\n            case 'localHumanDiffOptions':\\n            case 'localToStringFormat':\\n            case 'localSerializer':\\n            case 'localMacros':\\n            case 'localGenericMacros':\\n            case 'localFormatFunction':\\n            case 'localTranslator':\\n                $this->$setting = $value;\\n\\n                return $this;\\n\\n            default:\\n                \/\/ Drop unknown settings\\n                return $this;\\n        }\\n    }\\n\\n    private static function incrementUnit(DateInterval $instance, string $unit, int $value): void\\n    {\\n        if ($value === 0) {\\n            return;\\n        }\\n\\n        \/\/ @codeCoverageIgnoreStart\\n        if (PHP_VERSION_ID !== 8_03_20) {\\n            $instance->$unit += $value;\\n\\n            return;\\n        }\\n\\n        \/\/ Cannot use +=, nor set to a negative value directly as it segfaults in PHP 8.3.20\\n        self::setIntervalUnit($instance, $unit, ($instance->$unit ?? 0) + $value);\\n        \/\/ @codeCoverageIgnoreEnd\\n    }\\n\\n    \/** @codeCoverageIgnore *\/\\n    private static function setIntervalUnit(DateInterval $instance, string $unit, mixed $value): void\\n    {\\n        switch ($unit) {\\n            case 'y':\\n                $instance->y = $value;\\n\\n                break;\\n\\n            case 'm':\\n                $instance->m = $value;\\n\\n                break;\\n\\n            case 'd':\\n                $instance->d = $value;\\n\\n                break;\\n\\n            case 'h':\\n                $instance->h = $value;\\n\\n                break;\\n\\n            case 'i':\\n                $instance->i = $value;\\n\\n                break;\\n\\n            case 's':\\n                $instance->s = $value;\\n\\n                break;\\n\\n            default:\\n                $instance->$unit = $value;\\n        }\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/CarbonImmutable.php\",\"ext\":\"php\",\"size\":161482,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon;\\n\\nuse Carbon\\\\Traits\\\\Date;\\nuse DateTimeImmutable;\\nuse DateTimeInterface;\\n\\n\/**\\n * A simple API extension for DateTimeImmutable.\\n *\\n * <autodoc generated by `composer phpdoc`>\\n *\\n * @property      string           $localeDayOfWeek                                                                   the day of week in current locale\\n * @property      string           $shortLocaleDayOfWeek                                                              the abbreviated day of week in current locale\\n * @property      string           $localeMonth                                                                       the month in current locale\\n * @property      string           $shortLocaleMonth                                                                  the abbreviated month in current locale\\n * @property      int              $year\\n * @property      int              $yearIso\\n * @property      int              $month\\n * @property      int              $day\\n * @property      int              $hour\\n * @property      int              $minute\\n * @property      int              $second\\n * @property      int              $micro\\n * @property      int              $microsecond\\n * @property      int              $dayOfWeekIso                                                                      1 (for Monday) through 7 (for Sunday)\\n * @property      int|float|string $timestamp                                                                         seconds since the Unix Epoch\\n * @property      string           $englishDayOfWeek                                                                  the day of week in English\\n * @property      string           $shortEnglishDayOfWeek                                                             the abbreviated day of week in English\\n * @property      string           $englishMonth                                                                      the month in English\\n * @property      string           $shortEnglishMonth                                                                 the abbreviated month in English\\n * @property      int              $milliseconds\\n * @property      int              $millisecond\\n * @property      int              $milli\\n * @property      int              $week                                                                              1 through 53\\n * @property      int              $isoWeek                                                                           1 through 53\\n * @property      int              $weekYear                                                                          year according to week format\\n * @property      int              $isoWeekYear                                                                       year according to ISO week format\\n * @property      int              $age                                                                               does a diffInYears() with default parameters\\n * @property      int              $offset                                                                            the timezone offset in seconds from UTC\\n * @property      int              $offsetMinutes                                                                     the timezone offset in minutes from UTC\\n * @property      int              $offsetHours                                                                       the timezone offset in hours from UTC\\n * @property      CarbonTimeZone   $timezone                                                                          the current timezone\\n * @property      CarbonTimeZone   $tz                                                                                alias of $timezone\\n * @property      int              $centuryOfMillennium                                                               The value of the century starting from the beginning of the current millennium\\n * @property      int              $dayOfCentury                                                                      The value of the day starting from the beginning of the current century\\n * @property      int              $dayOfDecade                                                                       The value of the day starting from the beginning of the current decade\\n * @property      int              $dayOfMillennium                                                                   The value of the day starting from the beginning of the current millennium\\n * @property      int              $dayOfMonth                                                                        The value of the day starting from the beginning of the current month\\n * @property      int              $dayOfQuarter                                                                      The value of the day starting from the beginning of the current quarter\\n * @property      int              $dayOfWeek                                                                         0 (for Sunday) through 6 (for Saturday)\\n * @property      int              $dayOfYear                                                                         1 through 366\\n * @property      int              $decadeOfCentury                                                                   The value of the decade starting from the beginning of the current century\\n * @property      int              $decadeOfMillennium                                                                The value of the decade starting from the beginning of the current millennium\\n * @property      int              $hourOfCentury                                                                     The value of the hour starting from the beginning of the current century\\n * @property      int              $hourOfDay                                                                         The value of the hour starting from the beginning of the current day\\n * @property      int              $hourOfDecade                                                                      The value of the hour starting from the beginning of the current decade\\n * @property      int              $hourOfMillennium                                                                  The value of the hour starting from the beginning of the current millennium\\n * @property      int              $hourOfMonth                                                                       The value of the hour starting from the beginning of the current month\\n * @property      int              $hourOfQuarter                                                                     The value of the hour starting from the beginning of the current quarter\\n * @property      int              $hourOfWeek                                                                        The value of the hour starting from the beginning of the current week\\n * @property      int              $hourOfYear                                                                        The value of the hour starting from the beginning of the current year\\n * @property      int              $microsecondOfCentury                                                              The value of the microsecond starting from the beginning of the current century\\n * @property      int              $microsecondOfDay                                                                  The value of the microsecond starting from the beginning of the current day\\n * @property      int              $microsecondOfDecade                                                               The value of the microsecond starting from the beginning of the current decade\\n * @property      int              $microsecondOfHour                                                                 The value of the microsecond starting from the beginning of the current hour\\n * @property      int              $microsecondOfMillennium                                                           The value of the microsecond starting from the beginning of the current millennium\\n * @property      int              $microsecondOfMillisecond                                                          The value of the microsecond starting from the beginning of the current millisecond\\n * @property      int              $microsecondOfMinute                                                               The value of the microsecond starting from the beginning of the current minute\\n * @property      int              $microsecondOfMonth                                                                The value of the microsecond starting from the beginning of the current month\\n * @property      int              $microsecondOfQuarter                                                              The value of the microsecond starting from the beginning of the current quarter\\n * @property      int              $microsecondOfSecond                                                               The value of the microsecond starting from the beginning of the current second\\n * @property      int              $microsecondOfWeek                                                                 The value of the microsecond starting from the beginning of the current week\\n * @property      int              $microsecondOfYear                                                                 The value of the microsecond starting from the beginning of the current year\\n * @property      int              $millisecondOfCentury                                                              The value of the millisecond starting from the beginning of the current century\\n * @property      int              $millisecondOfDay                                                                  The value of the millisecond starting from the beginning of the current day\\n * @property      int              $millisecondOfDecade                                                               The value of the millisecond starting from the beginning of the current decade\\n * @property      int              $millisecondOfHour                                                                 The value of the millisecond starting from the beginning of the current hour\\n * @property      int              $millisecondOfMillennium                                                           The value of the millisecond starting from the beginning of the current millennium\\n * @property      int              $millisecondOfMinute                                                               The value of the millisecond starting from the beginning of the current minute\\n * @property      int              $millisecondOfMonth                                                                The value of the millisecond starting from the beginning of the current month\\n * @property      int              $millisecondOfQuarter                                                              The value of the millisecond starting from the beginning of the current quarter\\n * @property      int              $millisecondOfSecond                                                               The value of the millisecond starting from the beginning of the current second\\n * @property      int              $millisecondOfWeek                                                                 The value of the millisecond starting from the beginning of the current week\\n * @property      int              $millisecondOfYear                                                                 The value of the millisecond starting from the beginning of the current year\\n * @property      int              $minuteOfCentury                                                                   The value of the minute starting from the beginning of the current century\\n * @property      int              $minuteOfDay                                                                       The value of the minute starting from the beginning of the current day\\n * @property      int              $minuteOfDecade                                                                    The value of the minute starting from the beginning of the current decade\\n * @property      int              $minuteOfHour                                                                      The value of the minute starting from the beginning of the current hour\\n * @property      int              $minuteOfMillennium                                                                The value of the minute starting from the beginning of the current millennium\\n * @property      int              $minuteOfMonth                                                                     The value of the minute starting from the beginning of the current month\\n * @property      int              $minuteOfQuarter                                                                   The value of the minute starting from the beginning of the current quarter\\n * @property      int              $minuteOfWeek                                                                      The value of the minute starting from the beginning of the current week\\n * @property      int              $minuteOfYear                                                                      The value of the minute starting from the beginning of the current year\\n * @property      int              $monthOfCentury                                                                    The value of the month starting from the beginning of the current century\\n * @property      int              $monthOfDecade                                                                     The value of the month starting from the beginning of the current decade\\n * @property      int              $monthOfMillennium                                                                 The value of the month starting from the beginning of the current millennium\\n * @property      int              $monthOfQuarter                                                                    The value of the month starting from the beginning of the current quarter\\n * @property      int              $monthOfYear                                                                       The value of the month starting from the beginning of the current year\\n * @property      int              $quarterOfCentury                                                                  The value of the quarter starting from the beginning of the current century\\n * @property      int              $quarterOfDecade                                                                   The value of the quarter starting from the beginning of the current decade\\n * @property      int              $quarterOfMillennium                                                               The value of the quarter starting from the beginning of the current millennium\\n * @property      int              $quarterOfYear                                                                     The value of the quarter starting from the beginning of the current year\\n * @property      int              $secondOfCentury                                                                   The value of the second starting from the beginning of the current century\\n * @property      int              $secondOfDay                                                                       The value of the second starting from the beginning of the current day\\n * @property      int              $secondOfDecade                                                                    The value of the second starting from the beginning of the current decade\\n * @property      int              $secondOfHour                                                                      The value of the second starting from the beginning of the current hour\\n * @property      int              $secondOfMillennium                                                                The value of the second starting from the beginning of the current millennium\\n * @property      int              $secondOfMinute                                                                    The value of the second starting from the beginning of the current minute\\n * @property      int              $secondOfMonth                                                                     The value of the second starting from the beginning of the current month\\n * @property      int              $secondOfQuarter                                                                   The value of the second starting from the beginning of the current quarter\\n * @property      int              $secondOfWeek                                                                      The value of the second starting from the beginning of the current week\\n * @property      int              $secondOfYear                                                                      The value of the second starting from the beginning of the current year\\n * @property      int              $weekOfCentury                                                                     The value of the week starting from the beginning of the current century\\n * @property      int              $weekOfDecade                                                                      The value of the week starting from the beginning of the current decade\\n * @property      int              $weekOfMillennium                                                                  The value of the week starting from the beginning of the current millennium\\n * @property      int              $weekOfMonth                                                                       1 through 5\\n * @property      int              $weekOfQuarter                                                                     The value of the week starting from the beginning of the current quarter\\n * @property      int              $weekOfYear                                                                        ISO-8601 week number of year, weeks starting on Monday\\n * @property      int              $yearOfCentury                                                                     The value of the year starting from the beginning of the current century\\n * @property      int              $yearOfDecade                                                                      The value of the year starting from the beginning of the current decade\\n * @property      int              $yearOfMillennium                                                                  The value of the year starting from the beginning of the current millennium\\n * @property-read string           $latinMeridiem                                                                     \\\"am\\\"\/\\\"pm\\\" (Ante meridiem or Post meridiem latin lowercase mark)\\n * @property-read string           $latinUpperMeridiem                                                                \\\"AM\\\"\/\\\"PM\\\" (Ante meridiem or Post meridiem latin uppercase mark)\\n * @property-read string           $timezoneAbbreviatedName                                                           the current timezone abbreviated name\\n * @property-read string           $tzAbbrName                                                                        alias of $timezoneAbbreviatedName\\n * @property-read string           $dayName                                                                           long name of weekday translated according to Carbon locale, in english if no translation available for current language\\n * @property-read string           $shortDayName                                                                      short name of weekday translated according to Carbon locale, in english if no translation available for current language\\n * @property-read string           $minDayName                                                                        very short name of weekday translated according to Carbon locale, in english if no translation available for current language\\n * @property-read string           $monthName                                                                         long name of month translated according to Carbon locale, in english if no translation available for current language\\n * @property-read string           $shortMonthName                                                                    short name of month translated according to Carbon locale, in english if no translation available for current language\\n * @property-read string           $meridiem                                                                          lowercase meridiem mark translated according to Carbon locale, in latin if no translation available for current language\\n * @property-read string           $upperMeridiem                                                                     uppercase meridiem mark translated according to Carbon locale, in latin if no translation available for current language\\n * @property-read int              $noZeroHour                                                                        current hour from 1 to 24\\n * @property-read int              $isoWeeksInYear                                                                    51 through 53\\n * @property-read int              $weekNumberInMonth                                                                 1 through 5\\n * @property-read int              $firstWeekDay                                                                      0 through 6\\n * @property-read int              $lastWeekDay                                                                       0 through 6\\n * @property-read int              $quarter                                                                           the quarter of this instance, 1 - 4\\n * @property-read int              $decade                                                                            the decade of this instance\\n * @property-read int              $century                                                                           the century of this instance\\n * @property-read int              $millennium                                                                        the millennium of this instance\\n * @property-read bool             $dst                                                                               daylight savings time indicator, true if DST, false otherwise\\n * @property-read bool             $local                                                                             checks if the timezone is local, true if local, false otherwise\\n * @property-read bool             $utc                                                                               checks if the timezone is UTC, true if UTC, false otherwise\\n * @property-read string           $timezoneName                                                                      the current timezone name\\n * @property-read string           $tzName                                                                            alias of $timezoneName\\n * @property-read string           $locale                                                                            locale of the current instance\\n * @property-read int              $centuriesInMillennium                                                             The number of centuries contained in the current millennium\\n * @property-read int              $daysInCentury                                                                     The number of days contained in the current century\\n * @property-read int              $daysInDecade                                                                      The number of days contained in the current decade\\n * @property-read int              $daysInMillennium                                                                  The number of days contained in the current millennium\\n * @property-read int              $daysInMonth                                                                       number of days in the given month\\n * @property-read int              $daysInQuarter                                                                     The number of days contained in the current quarter\\n * @property-read int              $daysInWeek                                                                        The number of days contained in the current week\\n * @property-read int              $daysInYear                                                                        365 or 366\\n * @property-read int              $decadesInCentury                                                                  The number of decades contained in the current century\\n * @property-read int              $decadesInMillennium                                                               The number of decades contained in the current millennium\\n * @property-read int              $hoursInCentury                                                                    The number of hours contained in the current century\\n * @property-read int              $hoursInDay                                                                        The number of hours contained in the current day\\n * @property-read int              $hoursInDecade                                                                     The number of hours contained in the current decade\\n * @property-read int              $hoursInMillennium                                                                 The number of hours contained in the current millennium\\n * @property-read int              $hoursInMonth                                                                      The number of hours contained in the current month\\n * @property-read int              $hoursInQuarter                                                                    The number of hours contained in the current quarter\\n * @property-read int              $hoursInWeek                                                                       The number of hours contained in the current week\\n * @property-read int              $hoursInYear                                                                       The number of hours contained in the current year\\n * @property-read int              $microsecondsInCentury                                                             The number of microseconds contained in the current century\\n * @property-read int              $microsecondsInDay                                                                 The number of microseconds contained in the current day\\n * @property-read int              $microsecondsInDecade                                                              The number of microseconds contained in the current decade\\n * @property-read int              $microsecondsInHour                                                                The number of microseconds contained in the current hour\\n * @property-read int              $microsecondsInMillennium                                                          The number of microseconds contained in the current millennium\\n * @property-read int              $microsecondsInMillisecond                                                         The number of microseconds contained in the current millisecond\\n * @property-read int              $microsecondsInMinute                                                              The number of microseconds contained in the current minute\\n * @property-read int              $microsecondsInMonth                                                               The number of microseconds contained in the current month\\n * @property-read int              $microsecondsInQuarter                                                             The number of microseconds contained in the current quarter\\n * @property-read int              $microsecondsInSecond                                                              The number of microseconds contained in the current second\\n * @property-read int              $microsecondsInWeek                                                                The number of microseconds contained in the current week\\n * @property-read int              $microsecondsInYear                                                                The number of microseconds contained in the current year\\n * @property-read int              $millisecondsInCentury                                                             The number of milliseconds contained in the current century\\n * @property-read int              $millisecondsInDay                                                                 The number of milliseconds contained in the current day\\n * @property-read int              $millisecondsInDecade                                                              The number of milliseconds contained in the current decade\\n * @property-read int              $millisecondsInHour                                                                The number of milliseconds contained in the current hour\\n * @property-read int              $millisecondsInMillennium                                                          The number of milliseconds contained in the current millennium\\n * @property-read int              $millisecondsInMinute                                                              The number of milliseconds contained in the current minute\\n * @property-read int              $millisecondsInMonth                                                               The number of milliseconds contained in the current month\\n * @property-read int              $millisecondsInQuarter                                                             The number of milliseconds contained in the current quarter\\n * @property-read int              $millisecondsInSecond                                                              The number of milliseconds contained in the current second\\n * @property-read int              $millisecondsInWeek                                                                The number of milliseconds contained in the current week\\n * @property-read int              $millisecondsInYear                                                                The number of milliseconds contained in the current year\\n * @property-read int              $minutesInCentury                                                                  The number of minutes contained in the current century\\n * @property-read int              $minutesInDay                                                                      The number of minutes contained in the current day\\n * @property-read int              $minutesInDecade                                                                   The number of minutes contained in the current decade\\n * @property-read int              $minutesInHour                                                                     The number of minutes contained in the current hour\\n * @property-read int              $minutesInMillennium                                                               The number of minutes contained in the current millennium\\n * @property-read int              $minutesInMonth                                                                    The number of minutes contained in the current month\\n * @property-read int              $minutesInQuarter                                                                  The number of minutes contained in the current quarter\\n * @property-read int              $minutesInWeek                                                                     The number of minutes contained in the current week\\n * @property-read int              $minutesInYear                                                                     The number of minutes contained in the current year\\n * @property-read int              $monthsInCentury                                                                   The number of months contained in the current century\\n * @property-read int              $monthsInDecade                                                                    The number of months contained in the current decade\\n * @property-read int              $monthsInMillennium                                                                The number of months contained in the current millennium\\n * @property-read int              $monthsInQuarter                                                                   The number of months contained in the current quarter\\n * @property-read int              $monthsInYear                                                                      The number of months contained in the current year\\n * @property-read int              $quartersInCentury                                                                 The number of quarters contained in the current century\\n * @property-read int              $quartersInDecade                                                                  The number of quarters contained in the current decade\\n * @property-read int              $quartersInMillennium                                                              The number of quarters contained in the current millennium\\n * @property-read int              $quartersInYear                                                                    The number of quarters contained in the current year\\n * @property-read int              $secondsInCentury                                                                  The number of seconds contained in the current century\\n * @property-read int              $secondsInDay                                                                      The number of seconds contained in the current day\\n * @property-read int              $secondsInDecade                                                                   The number of seconds contained in the current decade\\n * @property-read int              $secondsInHour                                                                     The number of seconds contained in the current hour\\n * @property-read int              $secondsInMillennium                                                               The number of seconds contained in the current millennium\\n * @property-read int              $secondsInMinute                                                                   The number of seconds contained in the current minute\\n * @property-read int              $secondsInMonth                                                                    The number of seconds contained in the current month\\n * @property-read int              $secondsInQuarter                                                                  The number of seconds contained in the current quarter\\n * @property-read int              $secondsInWeek                                                                     The number of seconds contained in the current week\\n * @property-read int              $secondsInYear                                                                     The number of seconds contained in the current year\\n * @property-read int              $weeksInCentury                                                                    The number of weeks contained in the current century\\n * @property-read int              $weeksInDecade                                                                     The number of weeks contained in the current decade\\n * @property-read int              $weeksInMillennium                                                                 The number of weeks contained in the current millennium\\n * @property-read int              $weeksInMonth                                                                      The number of weeks contained in the current month\\n * @property-read int              $weeksInQuarter                                                                    The number of weeks contained in the current quarter\\n * @property-read int              $weeksInYear                                                                       51 through 53\\n * @property-read int              $yearsInCentury                                                                    The number of years contained in the current century\\n * @property-read int              $yearsInDecade                                                                     The number of years contained in the current decade\\n * @property-read int              $yearsInMillennium                                                                 The number of years contained in the current millennium\\n *\\n * @method        bool             isUtc()                                                                            Check if the current instance has UTC timezone. (Both isUtc and isUTC cases are valid.)\\n * @method        bool             isLocal()                                                                          Check if the current instance has non-UTC timezone.\\n * @method        bool             isValid()                                                                          Check if the current instance is a valid date.\\n * @method        bool             isDST()                                                                            Check if the current instance is in a daylight saving time.\\n * @method        bool             isSunday()                                                                         Checks if the instance day is sunday.\\n * @method        bool             isMonday()                                                                         Checks if the instance day is monday.\\n * @method        bool             isTuesday()                                                                        Checks if the instance day is tuesday.\\n * @method        bool             isWednesday()                                                                      Checks if the instance day is wednesday.\\n * @method        bool             isThursday()                                                                       Checks if the instance day is thursday.\\n * @method        bool             isFriday()                                                                         Checks if the instance day is friday.\\n * @method        bool             isSaturday()                                                                       Checks if the instance day is saturday.\\n * @method        bool             isSameYear(DateTimeInterface|string $date)                                         Checks if the given date is in the same year as the instance. If null passed, compare to now (with the same timezone).\\n * @method        bool             isCurrentYear()                                                                    Checks if the instance is in the same year as the current moment.\\n * @method        bool             isNextYear()                                                                       Checks if the instance is in the same year as the current moment next year.\\n * @method        bool             isLastYear()                                                                       Checks if the instance is in the same year as the current moment last year.\\n * @method        bool             isCurrentMonth()                                                                   Checks if the instance is in the same month as the current moment.\\n * @method        bool             isNextMonth()                                                                      Checks if the instance is in the same month as the current moment next month.\\n * @method        bool             isLastMonth()                                                                      Checks if the instance is in the same month as the current moment last month.\\n * @method        bool             isSameWeek(DateTimeInterface|string $date)                                         Checks if the given date is in the same week as the instance. If null passed, compare to now (with the same timezone).\\n * @method        bool             isCurrentWeek()                                                                    Checks if the instance is in the same week as the current moment.\\n * @method        bool             isNextWeek()                                                                       Checks if the instance is in the same week as the current moment next week.\\n * @method        bool             isLastWeek()                                                                       Checks if the instance is in the same week as the current moment last week.\\n * @method        bool             isSameDay(DateTimeInterface|string $date)                                          Checks if the given date is in the same day as the instance. If null passed, compare to now (with the same timezone).\\n * @method        bool             isCurrentDay()                                                                     Checks if the instance is in the same day as the current moment.\\n * @method        bool             isNextDay()                                                                        Checks if the instance is in the same day as the current moment next day.\\n * @method        bool             isLastDay()                                                                        Checks if the instance is in the same day as the current moment last day.\\n * @method        bool             isSameHour(DateTimeInterface|string $date)                                         Checks if the given date is in the same hour as the instance. If null passed, compare to now (with the same timezone).\\n * @method        bool             isCurrentHour()                                                                    Checks if the instance is in the same hour as the current moment.\\n * @method        bool             isNextHour()                                                                       Checks if the instance is in the same hour as the current moment next hour.\\n * @method        bool             isLastHour()                                                                       Checks if the instance is in the same hour as the current moment last hour.\\n * @method        bool             isSameMinute(DateTimeInterface|string $date)                                       Checks if the given date is in the same minute as the instance. If null passed, compare to now (with the same timezone).\\n * @method        bool             isCurrentMinute()                                                                  Checks if the instance is in the same minute as the current moment.\\n * @method        bool             isNextMinute()                                                                     Checks if the instance is in the same minute as the current moment next minute.\\n * @method        bool             isLastMinute()                                                                     Checks if the instance is in the same minute as the current moment last minute.\\n * @method        bool             isSameSecond(DateTimeInterface|string $date)                                       Checks if the given date is in the same second as the instance. If null passed, compare to now (with the same timezone).\\n * @method        bool             isCurrentSecond()                                                                  Checks if the instance is in the same second as the current moment.\\n * @method        bool             isNextSecond()                                                                     Checks if the instance is in the same second as the current moment next second.\\n * @method        bool             isLastSecond()                                                                     Checks if the instance is in the same second as the current moment last second.\\n * @method        bool             isSameMilli(DateTimeInterface|string $date)                                        Checks if the given date is in the same millisecond as the instance. If null passed, compare to now (with the same timezone).\\n * @method        bool             isCurrentMilli()                                                                   Checks if the instance is in the same millisecond as the current moment.\\n * @method        bool             isNextMilli()                                                                      Checks if the instance is in the same millisecond as the current moment next millisecond.\\n * @method        bool             isLastMilli()                                                                      Checks if the instance is in the same millisecond as the current moment last millisecond.\\n * @method        bool             isSameMillisecond(DateTimeInterface|string $date)                                  Checks if the given date is in the same millisecond as the instance. If null passed, compare to now (with the same timezone).\\n * @method        bool             isCurrentMillisecond()                                                             Checks if the instance is in the same millisecond as the current moment.\\n * @method        bool             isNextMillisecond()                                                                Checks if the instance is in the same millisecond as the current moment next millisecond.\\n * @method        bool             isLastMillisecond()                                                                Checks if the instance is in the same millisecond as the current moment last millisecond.\\n * @method        bool             isSameMicro(DateTimeInterface|string $date)                                        Checks if the given date is in the same microsecond as the instance. If null passed, compare to now (with the same timezone).\\n * @method        bool             isCurrentMicro()                                                                   Checks if the instance is in the same microsecond as the current moment.\\n * @method        bool             isNextMicro()                                                                      Checks if the instance is in the same microsecond as the current moment next microsecond.\\n * @method        bool             isLastMicro()                                                                      Checks if the instance is in the same microsecond as the current moment last microsecond.\\n * @method        bool             isSameMicrosecond(DateTimeInterface|string $date)                                  Checks if the given date is in the same microsecond as the instance. If null passed, compare to now (with the same timezone).\\n * @method        bool             isCurrentMicrosecond()                                                             Checks if the instance is in the same microsecond as the current moment.\\n * @method        bool             isNextMicrosecond()                                                                Checks if the instance is in the same microsecond as the current moment next microsecond.\\n * @method        bool             isLastMicrosecond()                                                                Checks if the instance is in the same microsecond as the current moment last microsecond.\\n * @method        bool             isSameDecade(DateTimeInterface|string $date)                                       Checks if the given date is in the same decade as the instance. If null passed, compare to now (with the same timezone).\\n * @method        bool             isCurrentDecade()                                                                  Checks if the instance is in the same decade as the current moment.\\n * @method        bool             isNextDecade()                                                                     Checks if the instance is in the same decade as the current moment next decade.\\n * @method        bool             isLastDecade()                                                                     Checks if the instance is in the same decade as the current moment last decade.\\n * @method        bool             isSameCentury(DateTimeInterface|string $date)                                      Checks if the given date is in the same century as the instance. If null passed, compare to now (with the same timezone).\\n * @method        bool             isCurrentCentury()                                                                 Checks if the instance is in the same century as the current moment.\\n * @method        bool             isNextCentury()                                                                    Checks if the instance is in the same century as the current moment next century.\\n * @method        bool             isLastCentury()                                                                    Checks if the instance is in the same century as the current moment last century.\\n * @method        bool             isSameMillennium(DateTimeInterface|string $date)                                   Checks if the given date is in the same millennium as the instance. If null passed, compare to now (with the same timezone).\\n * @method        bool             isCurrentMillennium()                                                              Checks if the instance is in the same millennium as the current moment.\\n * @method        bool             isNextMillennium()                                                                 Checks if the instance is in the same millennium as the current moment next millennium.\\n * @method        bool             isLastMillennium()                                                                 Checks if the instance is in the same millennium as the current moment last millennium.\\n * @method        bool             isCurrentQuarter()                                                                 Checks if the instance is in the same quarter as the current moment.\\n * @method        bool             isNextQuarter()                                                                    Checks if the instance is in the same quarter as the current moment next quarter.\\n * @method        bool             isLastQuarter()                                                                    Checks if the instance is in the same quarter as the current moment last quarter.\\n * @method        CarbonImmutable  years(int $value)                                                                  Set current instance year to the given value.\\n * @method        CarbonImmutable  year(int $value)                                                                   Set current instance year to the given value.\\n * @method        CarbonImmutable  setYears(int $value)                                                               Set current instance year to the given value.\\n * @method        CarbonImmutable  setYear(int $value)                                                                Set current instance year to the given value.\\n * @method        CarbonImmutable  months(Month|int $value)                                                           Set current instance month to the given value.\\n * @method        CarbonImmutable  month(Month|int $value)                                                            Set current instance month to the given value.\\n * @method        CarbonImmutable  setMonths(Month|int $value)                                                        Set current instance month to the given value.\\n * @method        CarbonImmutable  setMonth(Month|int $value)                                                         Set current instance month to the given value.\\n * @method        CarbonImmutable  days(int $value)                                                                   Set current instance day to the given value.\\n * @method        CarbonImmutable  day(int $value)                                                                    Set current instance day to the given value.\\n * @method        CarbonImmutable  setDays(int $value)                                                                Set current instance day to the given value.\\n * @method        CarbonImmutable  setDay(int $value)                                                                 Set current instance day to the given value.\\n * @method        CarbonImmutable  hours(int $value)                                                                  Set current instance hour to the given value.\\n * @method        CarbonImmutable  hour(int $value)                                                                   Set current instance hour to the given value.\\n * @method        CarbonImmutable  setHours(int $value)                                                               Set current instance hour to the given value.\\n * @method        CarbonImmutable  setHour(int $value)                                                                Set current instance hour to the given value.\\n * @method        CarbonImmutable  minutes(int $value)                                                                Set current instance minute to the given value.\\n * @method        CarbonImmutable  minute(int $value)                                                                 Set current instance minute to the given value.\\n * @method        CarbonImmutable  setMinutes(int $value)                                                             Set current instance minute to the given value.\\n * @method        CarbonImmutable  setMinute(int $value)                                                              Set current instance minute to the given value.\\n * @method        CarbonImmutable  seconds(int $value)                                                                Set current instance second to the given value.\\n * @method        CarbonImmutable  second(int $value)                                                                 Set current instance second to the given value.\\n * @method        CarbonImmutable  setSeconds(int $value)                                                             Set current instance second to the given value.\\n * @method        CarbonImmutable  setSecond(int $value)                                                              Set current instance second to the given value.\\n * @method        CarbonImmutable  millis(int $value)                                                                 Set current instance millisecond to the given value.\\n * @method        CarbonImmutable  milli(int $value)                                                                  Set current instance millisecond to the given value.\\n * @method        CarbonImmutable  setMillis(int $value)                                                              Set current instance millisecond to the given value.\\n * @method        CarbonImmutable  setMilli(int $value)                                                               Set current instance millisecond to the given value.\\n * @method        CarbonImmutable  milliseconds(int $value)                                                           Set current instance millisecond to the given value.\\n * @method        CarbonImmutable  millisecond(int $value)                                                            Set current instance millisecond to the given value.\\n * @method        CarbonImmutable  setMilliseconds(int $value)                                                        Set current instance millisecond to the given value.\\n * @method        CarbonImmutable  setMillisecond(int $value)                                                         Set current instance millisecond to the given value.\\n * @method        CarbonImmutable  micros(int $value)                                                                 Set current instance microsecond to the given value.\\n * @method        CarbonImmutable  micro(int $value)                                                                  Set current instance microsecond to the given value.\\n * @method        CarbonImmutable  setMicros(int $value)                                                              Set current instance microsecond to the given value.\\n * @method        CarbonImmutable  setMicro(int $value)                                                               Set current instance microsecond to the given value.\\n * @method        CarbonImmutable  microseconds(int $value)                                                           Set current instance microsecond to the given value.\\n * @method        CarbonImmutable  microsecond(int $value)                                                            Set current instance microsecond to the given value.\\n * @method        CarbonImmutable  setMicroseconds(int $value)                                                        Set current instance microsecond to the given value.\\n * @method        CarbonImmutable  setMicrosecond(int $value)                                                         Set current instance microsecond to the given value.\\n * @method        CarbonImmutable  addYears(int|float $value = 1)                                                     Add years (the $value count passed in) to the instance (using date interval).\\n * @method        CarbonImmutable  addYear()                                                                          Add one year to the instance (using date interval).\\n * @method        CarbonImmutable  subYears(int|float $value = 1)                                                     Sub years (the $value count passed in) to the instance (using date interval).\\n * @method        CarbonImmutable  subYear()                                                                          Sub one year to the instance (using date interval).\\n * @method        CarbonImmutable  addYearsWithOverflow(int|float $value = 1)                                         Add years (the $value count passed in) to the instance (using date interval) with overflow explicitly allowed.\\n * @method        CarbonImmutable  addYearWithOverflow()                                                              Add one year to the instance (using date interval) with overflow explicitly allowed.\\n * @method        CarbonImmutable  subYearsWithOverflow(int|float $value = 1)                                         Sub years (the $value count passed in) to the instance (using date interval) with overflow explicitly allowed.\\n * @method        CarbonImmutable  subYearWithOverflow()                                                              Sub one year to the instance (using date interval) with overflow explicitly allowed.\\n * @method        CarbonImmutable  addYearsWithoutOverflow(int|float $value = 1)                                      Add years (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addYearWithoutOverflow()                                                           Add one year to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subYearsWithoutOverflow(int|float $value = 1)                                      Sub years (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subYearWithoutOverflow()                                                           Sub one year to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addYearsWithNoOverflow(int|float $value = 1)                                       Add years (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addYearWithNoOverflow()                                                            Add one year to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subYearsWithNoOverflow(int|float $value = 1)                                       Sub years (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subYearWithNoOverflow()                                                            Sub one year to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addYearsNoOverflow(int|float $value = 1)                                           Add years (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addYearNoOverflow()                                                                Add one year to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subYearsNoOverflow(int|float $value = 1)                                           Sub years (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subYearNoOverflow()                                                                Sub one year to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addMonths(int|float $value = 1)                                                    Add months (the $value count passed in) to the instance (using date interval).\\n * @method        CarbonImmutable  addMonth()                                                                         Add one month to the instance (using date interval).\\n * @method        CarbonImmutable  subMonths(int|float $value = 1)                                                    Sub months (the $value count passed in) to the instance (using date interval).\\n * @method        CarbonImmutable  subMonth()                                                                         Sub one month to the instance (using date interval).\\n * @method        CarbonImmutable  addMonthsWithOverflow(int|float $value = 1)                                        Add months (the $value count passed in) to the instance (using date interval) with overflow explicitly allowed.\\n * @method        CarbonImmutable  addMonthWithOverflow()                                                             Add one month to the instance (using date interval) with overflow explicitly allowed.\\n * @method        CarbonImmutable  subMonthsWithOverflow(int|float $value = 1)                                        Sub months (the $value count passed in) to the instance (using date interval) with overflow explicitly allowed.\\n * @method        CarbonImmutable  subMonthWithOverflow()                                                             Sub one month to the instance (using date interval) with overflow explicitly allowed.\\n * @method        CarbonImmutable  addMonthsWithoutOverflow(int|float $value = 1)                                     Add months (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addMonthWithoutOverflow()                                                          Add one month to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subMonthsWithoutOverflow(int|float $value = 1)                                     Sub months (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subMonthWithoutOverflow()                                                          Sub one month to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addMonthsWithNoOverflow(int|float $value = 1)                                      Add months (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addMonthWithNoOverflow()                                                           Add one month to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subMonthsWithNoOverflow(int|float $value = 1)                                      Sub months (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subMonthWithNoOverflow()                                                           Sub one month to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addMonthsNoOverflow(int|float $value = 1)                                          Add months (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addMonthNoOverflow()                                                               Add one month to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subMonthsNoOverflow(int|float $value = 1)                                          Sub months (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subMonthNoOverflow()                                                               Sub one month to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addDays(int|float $value = 1)                                                      Add days (the $value count passed in) to the instance (using date interval).\\n * @method        CarbonImmutable  addDay()                                                                           Add one day to the instance (using date interval).\\n * @method        CarbonImmutable  subDays(int|float $value = 1)                                                      Sub days (the $value count passed in) to the instance (using date interval).\\n * @method        CarbonImmutable  subDay()                                                                           Sub one day to the instance (using date interval).\\n * @method        CarbonImmutable  addHours(int|float $value = 1)                                                     Add hours (the $value count passed in) to the instance (using date interval).\\n * @method        CarbonImmutable  addHour()                                                                          Add one hour to the instance (using date interval).\\n * @method        CarbonImmutable  subHours(int|float $value = 1)                                                     Sub hours (the $value count passed in) to the instance (using date interval).\\n * @method        CarbonImmutable  subHour()                                                                          Sub one hour to the instance (using date interval).\\n * @method        CarbonImmutable  addMinutes(int|float $value = 1)                                                   Add minutes (the $value count passed in) to the instance (using date interval).\\n * @method        CarbonImmutable  addMinute()                                                                        Add one minute to the instance (using date interval).\\n * @method        CarbonImmutable  subMinutes(int|float $value = 1)                                                   Sub minutes (the $value count passed in) to the instance (using date interval).\\n * @method        CarbonImmutable  subMinute()                                                                        Sub one minute to the instance (using date interval).\\n * @method        CarbonImmutable  addSeconds(int|float $value = 1)                                                   Add seconds (the $value count passed in) to the instance (using date interval).\\n * @method        CarbonImmutable  addSecond()                                                                        Add one second to the instance (using date interval).\\n * @method        CarbonImmutable  subSeconds(int|float $value = 1)                                                   Sub seconds (the $value count passed in) to the instance (using date interval).\\n * @method        CarbonImmutable  subSecond()                                                                        Sub one second to the instance (using date interval).\\n * @method        CarbonImmutable  addMillis(int|float $value = 1)                                                    Add milliseconds (the $value count passed in) to the instance (using date interval).\\n * @method        CarbonImmutable  addMilli()                                                                         Add one millisecond to the instance (using date interval).\\n * @method        CarbonImmutable  subMillis(int|float $value = 1)                                                    Sub milliseconds (the $value count passed in) to the instance (using date interval).\\n * @method        CarbonImmutable  subMilli()                                                                         Sub one millisecond to the instance (using date interval).\\n * @method        CarbonImmutable  addMilliseconds(int|float $value = 1)                                              Add milliseconds (the $value count passed in) to the instance (using date interval).\\n * @method        CarbonImmutable  addMillisecond()                                                                   Add one millisecond to the instance (using date interval).\\n * @method        CarbonImmutable  subMilliseconds(int|float $value = 1)                                              Sub milliseconds (the $value count passed in) to the instance (using date interval).\\n * @method        CarbonImmutable  subMillisecond()                                                                   Sub one millisecond to the instance (using date interval).\\n * @method        CarbonImmutable  addMicros(int|float $value = 1)                                                    Add microseconds (the $value count passed in) to the instance (using date interval).\\n * @method        CarbonImmutable  addMicro()                                                                         Add one microsecond to the instance (using date interval).\\n * @method        CarbonImmutable  subMicros(int|float $value = 1)                                                    Sub microseconds (the $value count passed in) to the instance (using date interval).\\n * @method        CarbonImmutable  subMicro()                                                                         Sub one microsecond to the instance (using date interval).\\n * @method        CarbonImmutable  addMicroseconds(int|float $value = 1)                                              Add microseconds (the $value count passed in) to the instance (using date interval).\\n * @method        CarbonImmutable  addMicrosecond()                                                                   Add one microsecond to the instance (using date interval).\\n * @method        CarbonImmutable  subMicroseconds(int|float $value = 1)                                              Sub microseconds (the $value count passed in) to the instance (using date interval).\\n * @method        CarbonImmutable  subMicrosecond()                                                                   Sub one microsecond to the instance (using date interval).\\n * @method        CarbonImmutable  addMillennia(int|float $value = 1)                                                 Add millennia (the $value count passed in) to the instance (using date interval).\\n * @method        CarbonImmutable  addMillennium()                                                                    Add one millennium to the instance (using date interval).\\n * @method        CarbonImmutable  subMillennia(int|float $value = 1)                                                 Sub millennia (the $value count passed in) to the instance (using date interval).\\n * @method        CarbonImmutable  subMillennium()                                                                    Sub one millennium to the instance (using date interval).\\n * @method        CarbonImmutable  addMillenniaWithOverflow(int|float $value = 1)                                     Add millennia (the $value count passed in) to the instance (using date interval) with overflow explicitly allowed.\\n * @method        CarbonImmutable  addMillenniumWithOverflow()                                                        Add one millennium to the instance (using date interval) with overflow explicitly allowed.\\n * @method        CarbonImmutable  subMillenniaWithOverflow(int|float $value = 1)                                     Sub millennia (the $value count passed in) to the instance (using date interval) with overflow explicitly allowed.\\n * @method        CarbonImmutable  subMillenniumWithOverflow()                                                        Sub one millennium to the instance (using date interval) with overflow explicitly allowed.\\n * @method        CarbonImmutable  addMillenniaWithoutOverflow(int|float $value = 1)                                  Add millennia (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addMillenniumWithoutOverflow()                                                     Add one millennium to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subMillenniaWithoutOverflow(int|float $value = 1)                                  Sub millennia (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subMillenniumWithoutOverflow()                                                     Sub one millennium to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addMillenniaWithNoOverflow(int|float $value = 1)                                   Add millennia (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addMillenniumWithNoOverflow()                                                      Add one millennium to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subMillenniaWithNoOverflow(int|float $value = 1)                                   Sub millennia (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subMillenniumWithNoOverflow()                                                      Sub one millennium to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addMillenniaNoOverflow(int|float $value = 1)                                       Add millennia (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addMillenniumNoOverflow()                                                          Add one millennium to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subMillenniaNoOverflow(int|float $value = 1)                                       Sub millennia (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subMillenniumNoOverflow()                                                          Sub one millennium to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addCenturies(int|float $value = 1)                                                 Add centuries (the $value count passed in) to the instance (using date interval).\\n * @method        CarbonImmutable  addCentury()                                                                       Add one century to the instance (using date interval).\\n * @method        CarbonImmutable  subCenturies(int|float $value = 1)                                                 Sub centuries (the $value count passed in) to the instance (using date interval).\\n * @method        CarbonImmutable  subCentury()                                                                       Sub one century to the instance (using date interval).\\n * @method        CarbonImmutable  addCenturiesWithOverflow(int|float $value = 1)                                     Add centuries (the $value count passed in) to the instance (using date interval) with overflow explicitly allowed.\\n * @method        CarbonImmutable  addCenturyWithOverflow()                                                           Add one century to the instance (using date interval) with overflow explicitly allowed.\\n * @method        CarbonImmutable  subCenturiesWithOverflow(int|float $value = 1)                                     Sub centuries (the $value count passed in) to the instance (using date interval) with overflow explicitly allowed.\\n * @method        CarbonImmutable  subCenturyWithOverflow()                                                           Sub one century to the instance (using date interval) with overflow explicitly allowed.\\n * @method        CarbonImmutable  addCenturiesWithoutOverflow(int|float $value = 1)                                  Add centuries (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addCenturyWithoutOverflow()                                                        Add one century to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subCenturiesWithoutOverflow(int|float $value = 1)                                  Sub centuries (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subCenturyWithoutOverflow()                                                        Sub one century to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addCenturiesWithNoOverflow(int|float $value = 1)                                   Add centuries (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addCenturyWithNoOverflow()                                                         Add one century to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subCenturiesWithNoOverflow(int|float $value = 1)                                   Sub centuries (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subCenturyWithNoOverflow()                                                         Sub one century to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addCenturiesNoOverflow(int|float $value = 1)                                       Add centuries (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addCenturyNoOverflow()                                                             Add one century to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subCenturiesNoOverflow(int|float $value = 1)                                       Sub centuries (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subCenturyNoOverflow()                                                             Sub one century to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addDecades(int|float $value = 1)                                                   Add decades (the $value count passed in) to the instance (using date interval).\\n * @method        CarbonImmutable  addDecade()                                                                        Add one decade to the instance (using date interval).\\n * @method        CarbonImmutable  subDecades(int|float $value = 1)                                                   Sub decades (the $value count passed in) to the instance (using date interval).\\n * @method        CarbonImmutable  subDecade()                                                                        Sub one decade to the instance (using date interval).\\n * @method        CarbonImmutable  addDecadesWithOverflow(int|float $value = 1)                                       Add decades (the $value count passed in) to the instance (using date interval) with overflow explicitly allowed.\\n * @method        CarbonImmutable  addDecadeWithOverflow()                                                            Add one decade to the instance (using date interval) with overflow explicitly allowed.\\n * @method        CarbonImmutable  subDecadesWithOverflow(int|float $value = 1)                                       Sub decades (the $value count passed in) to the instance (using date interval) with overflow explicitly allowed.\\n * @method        CarbonImmutable  subDecadeWithOverflow()                                                            Sub one decade to the instance (using date interval) with overflow explicitly allowed.\\n * @method        CarbonImmutable  addDecadesWithoutOverflow(int|float $value = 1)                                    Add decades (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addDecadeWithoutOverflow()                                                         Add one decade to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subDecadesWithoutOverflow(int|float $value = 1)                                    Sub decades (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subDecadeWithoutOverflow()                                                         Sub one decade to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addDecadesWithNoOverflow(int|float $value = 1)                                     Add decades (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addDecadeWithNoOverflow()                                                          Add one decade to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subDecadesWithNoOverflow(int|float $value = 1)                                     Sub decades (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subDecadeWithNoOverflow()                                                          Sub one decade to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addDecadesNoOverflow(int|float $value = 1)                                         Add decades (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addDecadeNoOverflow()                                                              Add one decade to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subDecadesNoOverflow(int|float $value = 1)                                         Sub decades (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subDecadeNoOverflow()                                                              Sub one decade to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addQuarters(int|float $value = 1)                                                  Add quarters (the $value count passed in) to the instance (using date interval).\\n * @method        CarbonImmutable  addQuarter()                                                                       Add one quarter to the instance (using date interval).\\n * @method        CarbonImmutable  subQuarters(int|float $value = 1)                                                  Sub quarters (the $value count passed in) to the instance (using date interval).\\n * @method        CarbonImmutable  subQuarter()                                                                       Sub one quarter to the instance (using date interval).\\n * @method        CarbonImmutable  addQuartersWithOverflow(int|float $value = 1)                                      Add quarters (the $value count passed in) to the instance (using date interval) with overflow explicitly allowed.\\n * @method        CarbonImmutable  addQuarterWithOverflow()                                                           Add one quarter to the instance (using date interval) with overflow explicitly allowed.\\n * @method        CarbonImmutable  subQuartersWithOverflow(int|float $value = 1)                                      Sub quarters (the $value count passed in) to the instance (using date interval) with overflow explicitly allowed.\\n * @method        CarbonImmutable  subQuarterWithOverflow()                                                           Sub one quarter to the instance (using date interval) with overflow explicitly allowed.\\n * @method        CarbonImmutable  addQuartersWithoutOverflow(int|float $value = 1)                                   Add quarters (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addQuarterWithoutOverflow()                                                        Add one quarter to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subQuartersWithoutOverflow(int|float $value = 1)                                   Sub quarters (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subQuarterWithoutOverflow()                                                        Sub one quarter to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addQuartersWithNoOverflow(int|float $value = 1)                                    Add quarters (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addQuarterWithNoOverflow()                                                         Add one quarter to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subQuartersWithNoOverflow(int|float $value = 1)                                    Sub quarters (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subQuarterWithNoOverflow()                                                         Sub one quarter to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addQuartersNoOverflow(int|float $value = 1)                                        Add quarters (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addQuarterNoOverflow()                                                             Add one quarter to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subQuartersNoOverflow(int|float $value = 1)                                        Sub quarters (the $value count passed in) to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  subQuarterNoOverflow()                                                             Sub one quarter to the instance (using date interval) with overflow explicitly forbidden.\\n * @method        CarbonImmutable  addWeeks(int|float $value = 1)                                                     Add weeks (the $value count passed in) to the instance (using date interval).\\n * @method        CarbonImmutable  addWeek()                                                                          Add one week to the instance (using date interval).\\n * @method        CarbonImmutable  subWeeks(int|float $value = 1)                                                     Sub weeks (the $value count passed in) to the instance (using date interval).\\n * @method        CarbonImmutable  subWeek()                                                                          Sub one week to the instance (using date interval).\\n * @method        CarbonImmutable  addWeekdays(int|float $value = 1)                                                  Add weekdays (the $value count passed in) to the instance (using date interval).\\n * @method        CarbonImmutable  addWeekday()                                                                       Add one weekday to the instance (using date interval).\\n * @method        CarbonImmutable  subWeekdays(int|float $value = 1)                                                  Sub weekdays (the $value count passed in) to the instance (using date interval).\\n * @method        CarbonImmutable  subWeekday()                                                                       Sub one weekday to the instance (using date interval).\\n * @method        CarbonImmutable  addUTCMicros(int|float $value = 1)                                                 Add microseconds (the $value count passed in) to the instance (using timestamp).\\n * @method        CarbonImmutable  addUTCMicro()                                                                      Add one microsecond to the instance (using timestamp).\\n * @method        CarbonImmutable  subUTCMicros(int|float $value = 1)                                                 Sub microseconds (the $value count passed in) to the instance (using timestamp).\\n * @method        CarbonImmutable  subUTCMicro()                                                                      Sub one microsecond to the instance (using timestamp).\\n * @method        CarbonPeriod     microsUntil($endDate = null, int|float $factor = 1)                                Return an iterable period from current date to given end (string, DateTime or Carbon instance) for each microsecond or every X microseconds if a factor is given.\\n * @method        float            diffInUTCMicros(DateTimeInterface|string|null $date, bool $absolute = false)       Convert current and given date in UTC timezone and return a floating number of microseconds.\\n * @method        CarbonImmutable  addUTCMicroseconds(int|float $value = 1)                                           Add microseconds (the $value count passed in) to the instance (using timestamp).\\n * @method        CarbonImmutable  addUTCMicrosecond()                                                                Add one microsecond to the instance (using timestamp).\\n * @method        CarbonImmutable  subUTCMicroseconds(int|float $value = 1)                                           Sub microseconds (the $value count passed in) to the instance (using timestamp).\\n * @method        CarbonImmutable  subUTCMicrosecond()                                                                Sub one microsecond to the instance (using timestamp).\\n * @method        CarbonPeriod     microsecondsUntil($endDate = null, int|float $factor = 1)                          Return an iterable period from current date to given end (string, DateTime or Carbon instance) for each microsecond or every X microseconds if a factor is given.\\n * @method        float            diffInUTCMicroseconds(DateTimeInterface|string|null $date, bool $absolute = false) Convert current and given date in UTC timezone and return a floating number of microseconds.\\n * @method        CarbonImmutable  addUTCMillis(int|float $value = 1)                                                 Add milliseconds (the $value count passed in) to the instance (using timestamp).\\n * @method        CarbonImmutable  addUTCMilli()                                                                      Add one millisecond to the instance (using timestamp).\\n * @method        CarbonImmutable  subUTCMillis(int|float $value = 1)                                                 Sub milliseconds (the $value count passed in) to the instance (using timestamp).\\n * @method        CarbonImmutable  subUTCMilli()                                                                      Sub one millisecond to the instance (using timestamp).\\n * @method        CarbonPeriod     millisUntil($endDate = null, int|float $factor = 1)                                Return an iterable period from current date to given end (string, DateTime or Carbon instance) for each millisecond or every X milliseconds if a factor is given.\\n * @method        float            diffInUTCMillis(DateTimeInterface|string|null $date, bool $absolute = false)       Convert current and given date in UTC timezone and return a floating number of milliseconds.\\n * @method        CarbonImmutable  addUTCMilliseconds(int|float $value = 1)                                           Add milliseconds (the $value count passed in) to the instance (using timestamp).\\n * @method        CarbonImmutable  addUTCMillisecond()                                                                Add one millisecond to the instance (using timestamp).\\n * @method        CarbonImmutable  subUTCMilliseconds(int|float $value = 1)                                           Sub milliseconds (the $value count passed in) to the instance (using timestamp).\\n * @method        CarbonImmutable  subUTCMillisecond()                                                                Sub one millisecond to the instance (using timestamp).\\n * @method        CarbonPeriod     millisecondsUntil($endDate = null, int|float $factor = 1)                          Return an iterable period from current date to given end (string, DateTime or Carbon instance) for each millisecond or every X milliseconds if a factor is given.\\n * @method        float            diffInUTCMilliseconds(DateTimeInterface|string|null $date, bool $absolute = false) Convert current and given date in UTC timezone and return a floating number of milliseconds.\\n * @method        CarbonImmutable  addUTCSeconds(int|float $value = 1)                                                Add seconds (the $value count passed in) to the instance (using timestamp).\\n * @method        CarbonImmutable  addUTCSecond()                                                                     Add one second to the instance (using timestamp).\\n * @method        CarbonImmutable  subUTCSeconds(int|float $value = 1)                                                Sub seconds (the $value count passed in) to the instance (using timestamp).\\n * @method        CarbonImmutable  subUTCSecond()                                                                     Sub one second to the instance (using timestamp).\\n * @method        CarbonPeriod     secondsUntil($endDate = null, int|float $factor = 1)                               Return an iterable period from current date to given end (string, DateTime or Carbon instance) for each second or every X seconds if a factor is given.\\n * @method        float            diffInUTCSeconds(DateTimeInterface|string|null $date, bool $absolute = false)      Convert current and given date in UTC timezone and return a floating number of seconds.\\n * @method        CarbonImmutable  addUTCMinutes(int|float $value = 1)                                                Add minutes (the $value count passed in) to the instance (using timestamp).\\n * @method        CarbonImmutable  addUTCMinute()                                                                     Add one minute to the instance (using timestamp).\\n * @method        CarbonImmutable  subUTCMinutes(int|float $value = 1)                                                Sub minutes (the $value count passed in) to the instance (using timestamp).\\n * @method        CarbonImmutable  subUTCMinute()                                                                     Sub one minute to the instance (using timestamp).\\n * @method        CarbonPeriod     minutesUntil($endDate = null, int|float $factor = 1)                               Return an iterable period from current date to given end (string, DateTime or Carbon instance) for each minute or every X minutes if a factor is given.\\n * @method        float            diffInUTCMinutes(DateTimeInterface|string|null $date, bool $absolute = false)      Convert current and given date in UTC timezone and return a floating number of minutes.\\n * @method        CarbonImmutable  addUTCHours(int|float $value = 1)                                                  Add hours (the $value count passed in) to the instance (using timestamp).\\n * @method        CarbonImmutable  addUTCHour()                                                                       Add one hour to the instance (using timestamp).\\n * @method        CarbonImmutable  subUTCHours(int|float $value = 1)                                                  Sub hours (the $value count passed in) to the instance (using timestamp).\\n * @method        CarbonImmutable  subUTCHour()                                                                       Sub one hour to the instance (using timestamp).\\n * @method        CarbonPeriod     hoursUntil($endDate = null, int|float $factor = 1)                                 Return an iterable period from current date to given end (string, DateTime or Carbon instance) for each hour or every X hours if a factor is given.\\n * @method        float            diffInUTCHours(DateTimeInterface|string|null $date, bool $absolute = false)        Convert current and given date in UTC timezone and return a floating number of hours.\\n * @method        CarbonImmutable  addUTCDays(int|float $value = 1)                                                   Add days (the $value count passed in) to the instance (using timestamp).\\n * @method        CarbonImmutable  addUTCDay()                                                                        Add one day to the instance (using timestamp).\\n * @method        CarbonImmutable  subUTCDays(int|float $value = 1)                                                   Sub days (the $value count passed in) to the instance (using timestamp).\\n * @method        CarbonImmutable  subUTCDay()                                                                        Sub one day to the instance (using timestamp).\\n * @method        CarbonPeriod     daysUntil($endDate = null, int|float $factor = 1)                                  Return an iterable period from current date to given end (string, DateTime or Carbon instance) for each day or every X days if a factor is given.\\n * @method        float            diffInUTCDays(DateTimeInterface|string|null $date, bool $absolute = false)         Convert current and given date in UTC timezone and return a floating number of days.\\n * @method        CarbonImmutable  addUTCWeeks(int|float $value = 1)                                                  Add weeks (the $value count passed in) to the instance (using timestamp).\\n * @method        CarbonImmutable  addUTCWeek()                                                                       Add one week to the instance (using timestamp).\\n * @method        CarbonImmutable  subUTCWeeks(int|float $value = 1)                                                  Sub weeks (the $value count passed in) to the instance (using timestamp).\\n * @method        CarbonImmutable  subUTCWeek()                                                                       Sub one week to the instance (using timestamp).\\n * @method        CarbonPeriod     weeksUntil($endDate = null, int|float $factor = 1)                                 Return an iterable period from current date to given end (string, DateTime or Carbon instance) for each week or every X weeks if a factor is given.\\n * @method        float            diffInUTCWeeks(DateTimeInterface|string|null $date, bool $absolute = false)        Convert current and given date in UTC timezone and return a floating number of weeks.\\n * @method        CarbonImmutable  addUTCMonths(int|float $value = 1)                                                 Add months (the $value count passed in) to the instance (using timestamp).\\n * @method        CarbonImmutable  addUTCMonth()                                                                      Add one month to the instance (using timestamp).\\n * @method        CarbonImmutable  subUTCMonths(int|float $value = 1)                                                 Sub months (the $value count passed in) to the instance (using timestamp).\\n * @method        CarbonImmutable  subUTCMonth()                                                                      Sub one month to the instance (using timestamp).\\n * @method        CarbonPeriod     monthsUntil($endDate = null, int|float $factor = 1)                                Return an iterable period from current date to given end (string, DateTime or Carbon instance) for each month or every X months if a factor is given.\\n * @method        float            diffInUTCMonths(DateTimeInterface|string|null $date, bool $absolute = false)       Convert current and given date in UTC timezone and return a floating number of months.\\n * @method        CarbonImmutable  addUTCQuarters(int|float $value = 1)                                               Add quarters (the $value count passed in) to the instance (using timestamp).\\n * @method        CarbonImmutable  addUTCQuarter()                                                                    Add one quarter to the instance (using timestamp).\\n * @method        CarbonImmutable  subUTCQuarters(int|float $value = 1)                                               Sub quarters (the $value count passed in) to the instance (using timestamp).\\n * @method        CarbonImmutable  subUTCQuarter()                                                                    Sub one quarter to the instance (using timestamp).\\n * @method        CarbonPeriod     quartersUntil($endDate = null, int|float $factor = 1)                              Return an iterable period from current date to given end (string, DateTime or Carbon instance) for each quarter or every X quarters if a factor is given.\\n * @method        float            diffInUTCQuarters(DateTimeInterface|string|null $date, bool $absolute = false)     Convert current and given date in UTC timezone and return a floating number of quarters.\\n * @method        CarbonImmutable  addUTCYears(int|float $value = 1)                                                  Add years (the $value count passed in) to the instance (using timestamp).\\n * @method        CarbonImmutable  addUTCYear()                                                                       Add one year to the instance (using timestamp).\\n * @method        CarbonImmutable  subUTCYears(int|float $value = 1)                                                  Sub years (the $value count passed in) to the instance (using timestamp).\\n * @method        CarbonImmutable  subUTCYear()                                                                       Sub one year to the instance (using timestamp).\\n * @method        CarbonPeriod     yearsUntil($endDate = null, int|float $factor = 1)                                 Return an iterable period from current date to given end (string, DateTime or Carbon instance) for each year or every X years if a factor is given.\\n * @method        float            diffInUTCYears(DateTimeInterface|string|null $date, bool $absolute = false)        Convert current and given date in UTC timezone and return a floating number of years.\\n * @method        CarbonImmutable  addUTCDecades(int|float $value = 1)                                                Add decades (the $value count passed in) to the instance (using timestamp).\\n * @method        CarbonImmutable  addUTCDecade()                                                                     Add one decade to the instance (using timestamp).\\n * @method        CarbonImmutable  subUTCDecades(int|float $value = 1)                                                Sub decades (the $value count passed in) to the instance (using timestamp).\\n * @method        CarbonImmutable  subUTCDecade()                                                                     Sub one decade to the instance (using timestamp).\\n * @method        CarbonPeriod     decadesUntil($endDate = null, int|float $factor = 1)                               Return an iterable period from current date to given end (string, DateTime or Carbon instance) for each decade or every X decades if a factor is given.\\n * @method        float            diffInUTCDecades(DateTimeInterface|string|null $date, bool $absolute = false)      Convert current and given date in UTC timezone and return a floating number of decades.\\n * @method        CarbonImmutable  addUTCCenturies(int|float $value = 1)                                              Add centuries (the $value count passed in) to the instance (using timestamp).\\n * @method        CarbonImmutable  addUTCCentury()                                                                    Add one century to the instance (using timestamp).\\n * @method        CarbonImmutable  subUTCCenturies(int|float $value = 1)                                              Sub centuries (the $value count passed in) to the instance (using timestamp).\\n * @method        CarbonImmutable  subUTCCentury()                                                                    Sub one century to the instance (using timestamp).\\n * @method        CarbonPeriod     centuriesUntil($endDate = null, int|float $factor = 1)                             Return an iterable period from current date to given end (string, DateTime or Carbon instance) for each century or every X centuries if a factor is given.\\n * @method        float            diffInUTCCenturies(DateTimeInterface|string|null $date, bool $absolute = false)    Convert current and given date in UTC timezone and return a floating number of centuries.\\n * @method        CarbonImmutable  addUTCMillennia(int|float $value = 1)                                              Add millennia (the $value count passed in) to the instance (using timestamp).\\n * @method        CarbonImmutable  addUTCMillennium()                                                                 Add one millennium to the instance (using timestamp).\\n * @method        CarbonImmutable  subUTCMillennia(int|float $value = 1)                                              Sub millennia (the $value count passed in) to the instance (using timestamp).\\n * @method        CarbonImmutable  subUTCMillennium()                                                                 Sub one millennium to the instance (using timestamp).\\n * @method        CarbonPeriod     millenniaUntil($endDate = null, int|float $factor = 1)                             Return an iterable period from current date to given end (string, DateTime or Carbon instance) for each millennium or every X millennia if a factor is given.\\n * @method        float            diffInUTCMillennia(DateTimeInterface|string|null $date, bool $absolute = false)    Convert current and given date in UTC timezone and return a floating number of millennia.\\n * @method        CarbonImmutable  roundYear(float $precision = 1, string $function = \\\"round\\\")                        Round the current instance year with given precision using the given function.\\n * @method        CarbonImmutable  roundYears(float $precision = 1, string $function = \\\"round\\\")                       Round the current instance year with given precision using the given function.\\n * @method        CarbonImmutable  floorYear(float $precision = 1)                                                    Truncate the current instance year with given precision.\\n * @method        CarbonImmutable  floorYears(float $precision = 1)                                                   Truncate the current instance year with given precision.\\n * @method        CarbonImmutable  ceilYear(float $precision = 1)                                                     Ceil the current instance year with given precision.\\n * @method        CarbonImmutable  ceilYears(float $precision = 1)                                                    Ceil the current instance year with given precision.\\n * @method        CarbonImmutable  roundMonth(float $precision = 1, string $function = \\\"round\\\")                       Round the current instance month with given precision using the given function.\\n * @method        CarbonImmutable  roundMonths(float $precision = 1, string $function = \\\"round\\\")                      Round the current instance month with given precision using the given function.\\n * @method        CarbonImmutable  floorMonth(float $precision = 1)                                                   Truncate the current instance month with given precision.\\n * @method        CarbonImmutable  floorMonths(float $precision = 1)                                                  Truncate the current instance month with given precision.\\n * @method        CarbonImmutable  ceilMonth(float $precision = 1)                                                    Ceil the current instance month with given precision.\\n * @method        CarbonImmutable  ceilMonths(float $precision = 1)                                                   Ceil the current instance month with given precision.\\n * @method        CarbonImmutable  roundDay(float $precision = 1, string $function = \\\"round\\\")                         Round the current instance day with given precision using the given function.\\n * @method        CarbonImmutable  roundDays(float $precision = 1, string $function = \\\"round\\\")                        Round the current instance day with given precision using the given function.\\n * @method        CarbonImmutable  floorDay(float $precision = 1)                                                     Truncate the current instance day with given precision.\\n * @method        CarbonImmutable  floorDays(float $precision = 1)                                                    Truncate the current instance day with given precision.\\n * @method        CarbonImmutable  ceilDay(float $precision = 1)                                                      Ceil the current instance day with given precision.\\n * @method        CarbonImmutable  ceilDays(float $precision = 1)                                                     Ceil the current instance day with given precision.\\n * @method        CarbonImmutable  roundHour(float $precision = 1, string $function = \\\"round\\\")                        Round the current instance hour with given precision using the given function.\\n * @method        CarbonImmutable  roundHours(float $precision = 1, string $function = \\\"round\\\")                       Round the current instance hour with given precision using the given function.\\n * @method        CarbonImmutable  floorHour(float $precision = 1)                                                    Truncate the current instance hour with given precision.\\n * @method        CarbonImmutable  floorHours(float $precision = 1)                                                   Truncate the current instance hour with given precision.\\n * @method        CarbonImmutable  ceilHour(float $precision = 1)                                                     Ceil the current instance hour with given precision.\\n * @method        CarbonImmutable  ceilHours(float $precision = 1)                                                    Ceil the current instance hour with given precision.\\n * @method        CarbonImmutable  roundMinute(float $precision = 1, string $function = \\\"round\\\")                      Round the current instance minute with given precision using the given function.\\n * @method        CarbonImmutable  roundMinutes(float $precision = 1, string $function = \\\"round\\\")                     Round the current instance minute with given precision using the given function.\\n * @method        CarbonImmutable  floorMinute(float $precision = 1)                                                  Truncate the current instance minute with given precision.\\n * @method        CarbonImmutable  floorMinutes(float $precision = 1)                                                 Truncate the current instance minute with given precision.\\n * @method        CarbonImmutable  ceilMinute(float $precision = 1)                                                   Ceil the current instance minute with given precision.\\n * @method        CarbonImmutable  ceilMinutes(float $precision = 1)                                                  Ceil the current instance minute with given precision.\\n * @method        CarbonImmutable  roundSecond(float $precision = 1, string $function = \\\"round\\\")                      Round the current instance second with given precision using the given function.\\n * @method        CarbonImmutable  roundSeconds(float $precision = 1, string $function = \\\"round\\\")                     Round the current instance second with given precision using the given function.\\n * @method        CarbonImmutable  floorSecond(float $precision = 1)                                                  Truncate the current instance second with given precision.\\n * @method        CarbonImmutable  floorSeconds(float $precision = 1)                                                 Truncate the current instance second with given precision.\\n * @method        CarbonImmutable  ceilSecond(float $precision = 1)                                                   Ceil the current instance second with given precision.\\n * @method        CarbonImmutable  ceilSeconds(float $precision = 1)                                                  Ceil the current instance second with given precision.\\n * @method        CarbonImmutable  roundMillennium(float $precision = 1, string $function = \\\"round\\\")                  Round the current instance millennium with given precision using the given function.\\n * @method        CarbonImmutable  roundMillennia(float $precision = 1, string $function = \\\"round\\\")                   Round the current instance millennium with given precision using the given function.\\n * @method        CarbonImmutable  floorMillennium(float $precision = 1)                                              Truncate the current instance millennium with given precision.\\n * @method        CarbonImmutable  floorMillennia(float $precision = 1)                                               Truncate the current instance millennium with given precision.\\n * @method        CarbonImmutable  ceilMillennium(float $precision = 1)                                               Ceil the current instance millennium with given precision.\\n * @method        CarbonImmutable  ceilMillennia(float $precision = 1)                                                Ceil the current instance millennium with given precision.\\n * @method        CarbonImmutable  roundCentury(float $precision = 1, string $function = \\\"round\\\")                     Round the current instance century with given precision using the given function.\\n * @method        CarbonImmutable  roundCenturies(float $precision = 1, string $function = \\\"round\\\")                   Round the current instance century with given precision using the given function.\\n * @method        CarbonImmutable  floorCentury(float $precision = 1)                                                 Truncate the current instance century with given precision.\\n * @method        CarbonImmutable  floorCenturies(float $precision = 1)                                               Truncate the current instance century with given precision.\\n * @method        CarbonImmutable  ceilCentury(float $precision = 1)                                                  Ceil the current instance century with given precision.\\n * @method        CarbonImmutable  ceilCenturies(float $precision = 1)                                                Ceil the current instance century with given precision.\\n * @method        CarbonImmutable  roundDecade(float $precision = 1, string $function = \\\"round\\\")                      Round the current instance decade with given precision using the given function.\\n * @method        CarbonImmutable  roundDecades(float $precision = 1, string $function = \\\"round\\\")                     Round the current instance decade with given precision using the given function.\\n * @method        CarbonImmutable  floorDecade(float $precision = 1)                                                  Truncate the current instance decade with given precision.\\n * @method        CarbonImmutable  floorDecades(float $precision = 1)                                                 Truncate the current instance decade with given precision.\\n * @method        CarbonImmutable  ceilDecade(float $precision = 1)                                                   Ceil the current instance decade with given precision.\\n * @method        CarbonImmutable  ceilDecades(float $precision = 1)                                                  Ceil the current instance decade with given precision.\\n * @method        CarbonImmutable  roundQuarter(float $precision = 1, string $function = \\\"round\\\")                     Round the current instance quarter with given precision using the given function.\\n * @method        CarbonImmutable  roundQuarters(float $precision = 1, string $function = \\\"round\\\")                    Round the current instance quarter with given precision using the given function.\\n * @method        CarbonImmutable  floorQuarter(float $precision = 1)                                                 Truncate the current instance quarter with given precision.\\n * @method        CarbonImmutable  floorQuarters(float $precision = 1)                                                Truncate the current instance quarter with given precision.\\n * @method        CarbonImmutable  ceilQuarter(float $precision = 1)                                                  Ceil the current instance quarter with given precision.\\n * @method        CarbonImmutable  ceilQuarters(float $precision = 1)                                                 Ceil the current instance quarter with given precision.\\n * @method        CarbonImmutable  roundMillisecond(float $precision = 1, string $function = \\\"round\\\")                 Round the current instance millisecond with given precision using the given function.\\n * @method        CarbonImmutable  roundMilliseconds(float $precision = 1, string $function = \\\"round\\\")                Round the current instance millisecond with given precision using the given function.\\n * @method        CarbonImmutable  floorMillisecond(float $precision = 1)                                             Truncate the current instance millisecond with given precision.\\n * @method        CarbonImmutable  floorMilliseconds(float $precision = 1)                                            Truncate the current instance millisecond with given precision.\\n * @method        CarbonImmutable  ceilMillisecond(float $precision = 1)                                              Ceil the current instance millisecond with given precision.\\n * @method        CarbonImmutable  ceilMilliseconds(float $precision = 1)                                             Ceil the current instance millisecond with given precision.\\n * @method        CarbonImmutable  roundMicrosecond(float $precision = 1, string $function = \\\"round\\\")                 Round the current instance microsecond with given precision using the given function.\\n * @method        CarbonImmutable  roundMicroseconds(float $precision = 1, string $function = \\\"round\\\")                Round the current instance microsecond with given precision using the given function.\\n * @method        CarbonImmutable  floorMicrosecond(float $precision = 1)                                             Truncate the current instance microsecond with given precision.\\n * @method        CarbonImmutable  floorMicroseconds(float $precision = 1)                                            Truncate the current instance microsecond with given precision.\\n * @method        CarbonImmutable  ceilMicrosecond(float $precision = 1)                                              Ceil the current instance microsecond with given precision.\\n * @method        CarbonImmutable  ceilMicroseconds(float $precision = 1)                                             Ceil the current instance microsecond with given precision.\\n * @method        string           shortAbsoluteDiffForHumans(DateTimeInterface $other = null, int $parts = 1)        Get the difference (short format, 'Absolute' mode) in a human readable format in the current locale. ($other and $parts parameters can be swapped.)\\n * @method        string           longAbsoluteDiffForHumans(DateTimeInterface $other = null, int $parts = 1)         Get the difference (long format, 'Absolute' mode) in a human readable format in the current locale. ($other and $parts parameters can be swapped.)\\n * @method        string           shortRelativeDiffForHumans(DateTimeInterface $other = null, int $parts = 1)        Get the difference (short format, 'Relative' mode) in a human readable format in the current locale. ($other and $parts parameters can be swapped.)\\n * @method        string           longRelativeDiffForHumans(DateTimeInterface $other = null, int $parts = 1)         Get the difference (long format, 'Relative' mode) in a human readable format in the current locale. ($other and $parts parameters can be swapped.)\\n * @method        string           shortRelativeToNowDiffForHumans(DateTimeInterface $other = null, int $parts = 1)   Get the difference (short format, 'RelativeToNow' mode) in a human readable format in the current locale. ($other and $parts parameters can be swapped.)\\n * @method        string           longRelativeToNowDiffForHumans(DateTimeInterface $other = null, int $parts = 1)    Get the difference (long format, 'RelativeToNow' mode) in a human readable format in the current locale. ($other and $parts parameters can be swapped.)\\n * @method        string           shortRelativeToOtherDiffForHumans(DateTimeInterface $other = null, int $parts = 1) Get the difference (short format, 'RelativeToOther' mode) in a human readable format in the current locale. ($other and $parts parameters can be swapped.)\\n * @method        string           longRelativeToOtherDiffForHumans(DateTimeInterface $other = null, int $parts = 1)  Get the difference (long format, 'RelativeToOther' mode) in a human readable format in the current locale. ($other and $parts parameters can be swapped.)\\n * @method        int              centuriesInMillennium()                                                            Return the number of centuries contained in the current millennium\\n * @method        int|static       centuryOfMillennium(?int $century = null)                                          Return the value of the century starting from the beginning of the current millennium when called with no parameters, change the current century when called with an integer value\\n * @method        int|static       dayOfCentury(?int $day = null)                                                     Return the value of the day starting from the beginning of the current century when called with no parameters, change the current day when called with an integer value\\n * @method        int|static       dayOfDecade(?int $day = null)                                                      Return the value of the day starting from the beginning of the current decade when called with no parameters, change the current day when called with an integer value\\n * @method        int|static       dayOfMillennium(?int $day = null)                                                  Return the value of the day starting from the beginning of the current millennium when called with no parameters, change the current day when called with an integer value\\n * @method        int|static       dayOfMonth(?int $day = null)                                                       Return the value of the day starting from the beginning of the current month when called with no parameters, change the current day when called with an integer value\\n * @method        int|static       dayOfQuarter(?int $day = null)                                                     Return the value of the day starting from the beginning of the current quarter when called with no parameters, change the current day when called with an integer value\\n * @method        int|static       dayOfWeek(?int $day = null)                                                        Return the value of the day starting from the beginning of the current week when called with no parameters, change the current day when called with an integer value\\n * @method        int              daysInCentury()                                                                    Return the number of days contained in the current century\\n * @method        int              daysInDecade()                                                                     Return the number of days contained in the current decade\\n * @method        int              daysInMillennium()                                                                 Return the number of days contained in the current millennium\\n * @method        int              daysInMonth()                                                                      Return the number of days contained in the current month\\n * @method        int              daysInQuarter()                                                                    Return the number of days contained in the current quarter\\n * @method        int              daysInWeek()                                                                       Return the number of days contained in the current week\\n * @method        int              daysInYear()                                                                       Return the number of days contained in the current year\\n * @method        int|static       decadeOfCentury(?int $decade = null)                                               Return the value of the decade starting from the beginning of the current century when called with no parameters, change the current decade when called with an integer value\\n * @method        int|static       decadeOfMillennium(?int $decade = null)                                            Return the value of the decade starting from the beginning of the current millennium when called with no parameters, change the current decade when called with an integer value\\n * @method        int              decadesInCentury()                                                                 Return the number of decades contained in the current century\\n * @method        int              decadesInMillennium()                                                              Return the number of decades contained in the current millennium\\n * @method        int|static       hourOfCentury(?int $hour = null)                                                   Return the value of the hour starting from the beginning of the current century when called with no parameters, change the current hour when called with an integer value\\n * @method        int|static       hourOfDay(?int $hour = null)                                                       Return the value of the hour starting from the beginning of the current day when called with no parameters, change the current hour when called with an integer value\\n * @method        int|static       hourOfDecade(?int $hour = null)                                                    Return the value of the hour starting from the beginning of the current decade when called with no parameters, change the current hour when called with an integer value\\n * @method        int|static       hourOfMillennium(?int $hour = null)                                                Return the value of the hour starting from the beginning of the current millennium when called with no parameters, change the current hour when called with an integer value\\n * @method        int|static       hourOfMonth(?int $hour = null)                                                     Return the value of the hour starting from the beginning of the current month when called with no parameters, change the current hour when called with an integer value\\n * @method        int|static       hourOfQuarter(?int $hour = null)                                                   Return the value of the hour starting from the beginning of the current quarter when called with no parameters, change the current hour when called with an integer value\\n * @method        int|static       hourOfWeek(?int $hour = null)                                                      Return the value of the hour starting from the beginning of the current week when called with no parameters, change the current hour when called with an integer value\\n * @method        int|static       hourOfYear(?int $hour = null)                                                      Return the value of the hour starting from the beginning of the current year when called with no parameters, change the current hour when called with an integer value\\n * @method        int              hoursInCentury()                                                                   Return the number of hours contained in the current century\\n * @method        int              hoursInDay()                                                                       Return the number of hours contained in the current day\\n * @method        int              hoursInDecade()                                                                    Return the number of hours contained in the current decade\\n * @method        int              hoursInMillennium()                                                                Return the number of hours contained in the current millennium\\n * @method        int              hoursInMonth()                                                                     Return the number of hours contained in the current month\\n * @method        int              hoursInQuarter()                                                                   Return the number of hours contained in the current quarter\\n * @method        int              hoursInWeek()                                                                      Return the number of hours contained in the current week\\n * @method        int              hoursInYear()                                                                      Return the number of hours contained in the current year\\n * @method        int|static       microsecondOfCentury(?int $microsecond = null)                                     Return the value of the microsecond starting from the beginning of the current century when called with no parameters, change the current microsecond when called with an integer value\\n * @method        int|static       microsecondOfDay(?int $microsecond = null)                                         Return the value of the microsecond starting from the beginning of the current day when called with no parameters, change the current microsecond when called with an integer value\\n * @method        int|static       microsecondOfDecade(?int $microsecond = null)                                      Return the value of the microsecond starting from the beginning of the current decade when called with no parameters, change the current microsecond when called with an integer value\\n * @method        int|static       microsecondOfHour(?int $microsecond = null)                                        Return the value of the microsecond starting from the beginning of the current hour when called with no parameters, change the current microsecond when called with an integer value\\n * @method        int|static       microsecondOfMillennium(?int $microsecond = null)                                  Return the value of the microsecond starting from the beginning of the current millennium when called with no parameters, change the current microsecond when called with an integer value\\n * @method        int|static       microsecondOfMillisecond(?int $microsecond = null)                                 Return the value of the microsecond starting from the beginning of the current millisecond when called with no parameters, change the current microsecond when called with an integer value\\n * @method        int|static       microsecondOfMinute(?int $microsecond = null)                                      Return the value of the microsecond starting from the beginning of the current minute when called with no parameters, change the current microsecond when called with an integer value\\n * @method        int|static       microsecondOfMonth(?int $microsecond = null)                                       Return the value of the microsecond starting from the beginning of the current month when called with no parameters, change the current microsecond when called with an integer value\\n * @method        int|static       microsecondOfQuarter(?int $microsecond = null)                                     Return the value of the microsecond starting from the beginning of the current quarter when called with no parameters, change the current microsecond when called with an integer value\\n * @method        int|static       microsecondOfSecond(?int $microsecond = null)                                      Return the value of the microsecond starting from the beginning of the current second when called with no parameters, change the current microsecond when called with an integer value\\n * @method        int|static       microsecondOfWeek(?int $microsecond = null)                                        Return the value of the microsecond starting from the beginning of the current week when called with no parameters, change the current microsecond when called with an integer value\\n * @method        int|static       microsecondOfYear(?int $microsecond = null)                                        Return the value of the microsecond starting from the beginning of the current year when called with no parameters, change the current microsecond when called with an integer value\\n * @method        int              microsecondsInCentury()                                                            Return the number of microseconds contained in the current century\\n * @method        int              microsecondsInDay()                                                                Return the number of microseconds contained in the current day\\n * @method        int              microsecondsInDecade()                                                             Return the number of microseconds contained in the current decade\\n * @method        int              microsecondsInHour()                                                               Return the number of microseconds contained in the current hour\\n * @method        int              microsecondsInMillennium()                                                         Return the number of microseconds contained in the current millennium\\n * @method        int              microsecondsInMillisecond()                                                        Return the number of microseconds contained in the current millisecond\\n * @method        int              microsecondsInMinute()                                                             Return the number of microseconds contained in the current minute\\n * @method        int              microsecondsInMonth()                                                              Return the number of microseconds contained in the current month\\n * @method        int              microsecondsInQuarter()                                                            Return the number of microseconds contained in the current quarter\\n * @method        int              microsecondsInSecond()                                                             Return the number of microseconds contained in the current second\\n * @method        int              microsecondsInWeek()                                                               Return the number of microseconds contained in the current week\\n * @method        int              microsecondsInYear()                                                               Return the number of microseconds contained in the current year\\n * @method        int|static       millisecondOfCentury(?int $millisecond = null)                                     Return the value of the millisecond starting from the beginning of the current century when called with no parameters, change the current millisecond when called with an integer value\\n * @method        int|static       millisecondOfDay(?int $millisecond = null)                                         Return the value of the millisecond starting from the beginning of the current day when called with no parameters, change the current millisecond when called with an integer value\\n * @method        int|static       millisecondOfDecade(?int $millisecond = null)                                      Return the value of the millisecond starting from the beginning of the current decade when called with no parameters, change the current millisecond when called with an integer value\\n * @method        int|static       millisecondOfHour(?int $millisecond = null)                                        Return the value of the millisecond starting from the beginning of the current hour when called with no parameters, change the current millisecond when called with an integer value\\n * @method        int|static       millisecondOfMillennium(?int $millisecond = null)                                  Return the value of the millisecond starting from the beginning of the current millennium when called with no parameters, change the current millisecond when called with an integer value\\n * @method        int|static       millisecondOfMinute(?int $millisecond = null)                                      Return the value of the millisecond starting from the beginning of the current minute when called with no parameters, change the current millisecond when called with an integer value\\n * @method        int|static       millisecondOfMonth(?int $millisecond = null)                                       Return the value of the millisecond starting from the beginning of the current month when called with no parameters, change the current millisecond when called with an integer value\\n * @method        int|static       millisecondOfQuarter(?int $millisecond = null)                                     Return the value of the millisecond starting from the beginning of the current quarter when called with no parameters, change the current millisecond when called with an integer value\\n * @method        int|static       millisecondOfSecond(?int $millisecond = null)                                      Return the value of the millisecond starting from the beginning of the current second when called with no parameters, change the current millisecond when called with an integer value\\n * @method        int|static       millisecondOfWeek(?int $millisecond = null)                                        Return the value of the millisecond starting from the beginning of the current week when called with no parameters, change the current millisecond when called with an integer value\\n * @method        int|static       millisecondOfYear(?int $millisecond = null)                                        Return the value of the millisecond starting from the beginning of the current year when called with no parameters, change the current millisecond when called with an integer value\\n * @method        int              millisecondsInCentury()                                                            Return the number of milliseconds contained in the current century\\n * @method        int              millisecondsInDay()                                                                Return the number of milliseconds contained in the current day\\n * @method        int              millisecondsInDecade()                                                             Return the number of milliseconds contained in the current decade\\n * @method        int              millisecondsInHour()                                                               Return the number of milliseconds contained in the current hour\\n * @method        int              millisecondsInMillennium()                                                         Return the number of milliseconds contained in the current millennium\\n * @method        int              millisecondsInMinute()                                                             Return the number of milliseconds contained in the current minute\\n * @method        int              millisecondsInMonth()                                                              Return the number of milliseconds contained in the current month\\n * @method        int              millisecondsInQuarter()                                                            Return the number of milliseconds contained in the current quarter\\n * @method        int              millisecondsInSecond()                                                             Return the number of milliseconds contained in the current second\\n * @method        int              millisecondsInWeek()                                                               Return the number of milliseconds contained in the current week\\n * @method        int              millisecondsInYear()                                                               Return the number of milliseconds contained in the current year\\n * @method        int|static       minuteOfCentury(?int $minute = null)                                               Return the value of the minute starting from the beginning of the current century when called with no parameters, change the current minute when called with an integer value\\n * @method        int|static       minuteOfDay(?int $minute = null)                                                   Return the value of the minute starting from the beginning of the current day when called with no parameters, change the current minute when called with an integer value\\n * @method        int|static       minuteOfDecade(?int $minute = null)                                                Return the value of the minute starting from the beginning of the current decade when called with no parameters, change the current minute when called with an integer value\\n * @method        int|static       minuteOfHour(?int $minute = null)                                                  Return the value of the minute starting from the beginning of the current hour when called with no parameters, change the current minute when called with an integer value\\n * @method        int|static       minuteOfMillennium(?int $minute = null)                                            Return the value of the minute starting from the beginning of the current millennium when called with no parameters, change the current minute when called with an integer value\\n * @method        int|static       minuteOfMonth(?int $minute = null)                                                 Return the value of the minute starting from the beginning of the current month when called with no parameters, change the current minute when called with an integer value\\n * @method        int|static       minuteOfQuarter(?int $minute = null)                                               Return the value of the minute starting from the beginning of the current quarter when called with no parameters, change the current minute when called with an integer value\\n * @method        int|static       minuteOfWeek(?int $minute = null)                                                  Return the value of the minute starting from the beginning of the current week when called with no parameters, change the current minute when called with an integer value\\n * @method        int|static       minuteOfYear(?int $minute = null)                                                  Return the value of the minute starting from the beginning of the current year when called with no parameters, change the current minute when called with an integer value\\n * @method        int              minutesInCentury()                                                                 Return the number of minutes contained in the current century\\n * @method        int              minutesInDay()                                                                     Return the number of minutes contained in the current day\\n * @method        int              minutesInDecade()                                                                  Return the number of minutes contained in the current decade\\n * @method        int              minutesInHour()                                                                    Return the number of minutes contained in the current hour\\n * @method        int              minutesInMillennium()                                                              Return the number of minutes contained in the current millennium\\n * @method        int              minutesInMonth()                                                                   Return the number of minutes contained in the current month\\n * @method        int              minutesInQuarter()                                                                 Return the number of minutes contained in the current quarter\\n * @method        int              minutesInWeek()                                                                    Return the number of minutes contained in the current week\\n * @method        int              minutesInYear()                                                                    Return the number of minutes contained in the current year\\n * @method        int|static       monthOfCentury(?int $month = null)                                                 Return the value of the month starting from the beginning of the current century when called with no parameters, change the current month when called with an integer value\\n * @method        int|static       monthOfDecade(?int $month = null)                                                  Return the value of the month starting from the beginning of the current decade when called with no parameters, change the current month when called with an integer value\\n * @method        int|static       monthOfMillennium(?int $month = null)                                              Return the value of the month starting from the beginning of the current millennium when called with no parameters, change the current month when called with an integer value\\n * @method        int|static       monthOfQuarter(?int $month = null)                                                 Return the value of the month starting from the beginning of the current quarter when called with no parameters, change the current month when called with an integer value\\n * @method        int|static       monthOfYear(?int $month = null)                                                    Return the value of the month starting from the beginning of the current year when called with no parameters, change the current month when called with an integer value\\n * @method        int              monthsInCentury()                                                                  Return the number of months contained in the current century\\n * @method        int              monthsInDecade()                                                                   Return the number of months contained in the current decade\\n * @method        int              monthsInMillennium()                                                               Return the number of months contained in the current millennium\\n * @method        int              monthsInQuarter()                                                                  Return the number of months contained in the current quarter\\n * @method        int              monthsInYear()                                                                     Return the number of months contained in the current year\\n * @method        int|static       quarterOfCentury(?int $quarter = null)                                             Return the value of the quarter starting from the beginning of the current century when called with no parameters, change the current quarter when called with an integer value\\n * @method        int|static       quarterOfDecade(?int $quarter = null)                                              Return the value of the quarter starting from the beginning of the current decade when called with no parameters, change the current quarter when called with an integer value\\n * @method        int|static       quarterOfMillennium(?int $quarter = null)                                          Return the value of the quarter starting from the beginning of the current millennium when called with no parameters, change the current quarter when called with an integer value\\n * @method        int|static       quarterOfYear(?int $quarter = null)                                                Return the value of the quarter starting from the beginning of the current year when called with no parameters, change the current quarter when called with an integer value\\n * @method        int              quartersInCentury()                                                                Return the number of quarters contained in the current century\\n * @method        int              quartersInDecade()                                                                 Return the number of quarters contained in the current decade\\n * @method        int              quartersInMillennium()                                                             Return the number of quarters contained in the current millennium\\n * @method        int              quartersInYear()                                                                   Return the number of quarters contained in the current year\\n * @method        int|static       secondOfCentury(?int $second = null)                                               Return the value of the second starting from the beginning of the current century when called with no parameters, change the current second when called with an integer value\\n * @method        int|static       secondOfDay(?int $second = null)                                                   Return the value of the second starting from the beginning of the current day when called with no parameters, change the current second when called with an integer value\\n * @method        int|static       secondOfDecade(?int $second = null)                                                Return the value of the second starting from the beginning of the current decade when called with no parameters, change the current second when called with an integer value\\n * @method        int|static       secondOfHour(?int $second = null)                                                  Return the value of the second starting from the beginning of the current hour when called with no parameters, change the current second when called with an integer value\\n * @method        int|static       secondOfMillennium(?int $second = null)                                            Return the value of the second starting from the beginning of the current millennium when called with no parameters, change the current second when called with an integer value\\n * @method        int|static       secondOfMinute(?int $second = null)                                                Return the value of the second starting from the beginning of the current minute when called with no parameters, change the current second when called with an integer value\\n * @method        int|static       secondOfMonth(?int $second = null)                                                 Return the value of the second starting from the beginning of the current month when called with no parameters, change the current second when called with an integer value\\n * @method        int|static       secondOfQuarter(?int $second = null)                                               Return the value of the second starting from the beginning of the current quarter when called with no parameters, change the current second when called with an integer value\\n * @method        int|static       secondOfWeek(?int $second = null)                                                  Return the value of the second starting from the beginning of the current week when called with no parameters, change the current second when called with an integer value\\n * @method        int|static       secondOfYear(?int $second = null)                                                  Return the value of the second starting from the beginning of the current year when called with no parameters, change the current second when called with an integer value\\n * @method        int              secondsInCentury()                                                                 Return the number of seconds contained in the current century\\n * @method        int              secondsInDay()                                                                     Return the number of seconds contained in the current day\\n * @method        int              secondsInDecade()                                                                  Return the number of seconds contained in the current decade\\n * @method        int              secondsInHour()                                                                    Return the number of seconds contained in the current hour\\n * @method        int              secondsInMillennium()                                                              Return the number of seconds contained in the current millennium\\n * @method        int              secondsInMinute()                                                                  Return the number of seconds contained in the current minute\\n * @method        int              secondsInMonth()                                                                   Return the number of seconds contained in the current month\\n * @method        int              secondsInQuarter()                                                                 Return the number of seconds contained in the current quarter\\n * @method        int              secondsInWeek()                                                                    Return the number of seconds contained in the current week\\n * @method        int              secondsInYear()                                                                    Return the number of seconds contained in the current year\\n * @method        int|static       weekOfCentury(?int $week = null)                                                   Return the value of the week starting from the beginning of the current century when called with no parameters, change the current week when called with an integer value\\n * @method        int|static       weekOfDecade(?int $week = null)                                                    Return the value of the week starting from the beginning of the current decade when called with no parameters, change the current week when called with an integer value\\n * @method        int|static       weekOfMillennium(?int $week = null)                                                Return the value of the week starting from the beginning of the current millennium when called with no parameters, change the current week when called with an integer value\\n * @method        int|static       weekOfMonth(?int $week = null)                                                     Return the value of the week starting from the beginning of the current month when called with no parameters, change the current week when called with an integer value\\n * @method        int|static       weekOfQuarter(?int $week = null)                                                   Return the value of the week starting from the beginning of the current quarter when called with no parameters, change the current week when called with an integer value\\n * @method        int|static       weekOfYear(?int $week = null)                                                      Return the value of the week starting from the beginning of the current year when called with no parameters, change the current week when called with an integer value\\n * @method        int              weeksInCentury()                                                                   Return the number of weeks contained in the current century\\n * @method        int              weeksInDecade()                                                                    Return the number of weeks contained in the current decade\\n * @method        int              weeksInMillennium()                                                                Return the number of weeks contained in the current millennium\\n * @method        int              weeksInMonth()                                                                     Return the number of weeks contained in the current month\\n * @method        int              weeksInQuarter()                                                                   Return the number of weeks contained in the current quarter\\n * @method        int|static       yearOfCentury(?int $year = null)                                                   Return the value of the year starting from the beginning of the current century when called with no parameters, change the current year when called with an integer value\\n * @method        int|static       yearOfDecade(?int $year = null)                                                    Return the value of the year starting from the beginning of the current decade when called with no parameters, change the current year when called with an integer value\\n * @method        int|static       yearOfMillennium(?int $year = null)                                                Return the value of the year starting from the beginning of the current millennium when called with no parameters, change the current year when called with an integer value\\n * @method        int              yearsInCentury()                                                                   Return the number of years contained in the current century\\n * @method        int              yearsInDecade()                                                                    Return the number of years contained in the current decade\\n * @method        int              yearsInMillennium()                                                                Return the number of years contained in the current millennium\\n *\\n * <\/autodoc>\\n *\/\\nclass CarbonImmutable extends DateTimeImmutable implements CarbonInterface\\n{\\n    use Date {\\n        __clone as dateTraitClone;\\n    }\\n\\n    public function __clone(): void\\n    {\\n        $this->dateTraitClone();\\n        $this->endOfTime = false;\\n        $this->startOfTime = false;\\n    }\\n\\n    \/**\\n     * Create a very old date representing start of time.\\n     *\\n     * @return static\\n     *\/\\n    public static function startOfTime(): static\\n    {\\n        $date = static::parse('0001-01-01')->years(self::getStartOfTimeYear());\\n        $date->startOfTime = true;\\n\\n        return $date;\\n    }\\n\\n    \/**\\n     * Create a very far date representing end of time.\\n     *\\n     * @return static\\n     *\/\\n    public static function endOfTime(): static\\n    {\\n        $date = static::parse('9999-12-31 23:59:59.999999')->years(self::getEndOfTimeYear());\\n        $date->endOfTime = true;\\n\\n        return $date;\\n    }\\n\\n    \/**\\n     * @codeCoverageIgnore\\n     *\/\\n    private static function getEndOfTimeYear(): int\\n    {\\n        return 1118290769066902787; \/\/ PHP_INT_MAX no longer work since PHP 8.1\\n    }\\n\\n    \/**\\n     * @codeCoverageIgnore\\n     *\/\\n    private static function getStartOfTimeYear(): int\\n    {\\n        return -1118290769066898816; \/\/ PHP_INT_MIN no longer work since PHP 8.1\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/CarbonPeriodImmutable.php\",\"ext\":\"php\",\"size\":856,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon;\\n\\nclass CarbonPeriodImmutable extends CarbonPeriod\\n{\\n    \/**\\n     * Default date class of iteration items.\\n     *\\n     * @var string\\n     *\/\\n    protected const DEFAULT_DATE_CLASS = CarbonImmutable::class;\\n\\n    \/**\\n     * Date class of iteration items.\\n     *\/\\n    protected string $dateClass = CarbonImmutable::class;\\n\\n    \/**\\n     * Prepare the instance to be set (self if mutable to be mutated,\\n     * copy if immutable to generate a new instance).\\n     *\/\\n    protected function copyIfImmutable(): static\\n    {\\n        return $this->constructed ? clone $this : $this;\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/TranslatorImmutable.php\",\"ext\":\"php\",\"size\":2405,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon;\\n\\nuse Carbon\\\\Exceptions\\\\ImmutableException;\\nuse Symfony\\\\Component\\\\Config\\\\ConfigCacheFactoryInterface;\\nuse Symfony\\\\Component\\\\Translation\\\\Formatter\\\\MessageFormatterInterface;\\n\\nclass TranslatorImmutable extends Translator\\n{\\n    private bool $constructed = false;\\n\\n    public function __construct($locale, ?MessageFormatterInterface $formatter = null, $cacheDir = null, $debug = false)\\n    {\\n        parent::__construct($locale, $formatter, $cacheDir, $debug);\\n        $this->constructed = true;\\n    }\\n\\n    \/**\\n     * @codeCoverageIgnore\\n     *\/\\n    public function setDirectories(array $directories): static\\n    {\\n        $this->disallowMutation(__METHOD__);\\n\\n        return parent::setDirectories($directories);\\n    }\\n\\n    public function setLocale($locale): void\\n    {\\n        $this->disallowMutation(__METHOD__);\\n\\n        parent::setLocale($locale);\\n    }\\n\\n    \/**\\n     * @codeCoverageIgnore\\n     *\/\\n    public function setMessages(string $locale, array $messages): static\\n    {\\n        $this->disallowMutation(__METHOD__);\\n\\n        return parent::setMessages($locale, $messages);\\n    }\\n\\n    \/**\\n     * @codeCoverageIgnore\\n     *\/\\n    public function setTranslations(array $messages): static\\n    {\\n        $this->disallowMutation(__METHOD__);\\n\\n        return parent::setTranslations($messages);\\n    }\\n\\n    \/**\\n     * @codeCoverageIgnore\\n     *\/\\n    public function setConfigCacheFactory(ConfigCacheFactoryInterface $configCacheFactory): void\\n    {\\n        $this->disallowMutation(__METHOD__);\\n\\n        parent::setConfigCacheFactory($configCacheFactory);\\n    }\\n\\n    public function resetMessages(?string $locale = null): bool\\n    {\\n        $this->disallowMutation(__METHOD__);\\n\\n        return parent::resetMessages($locale);\\n    }\\n\\n    \/**\\n     * @codeCoverageIgnore\\n     *\/\\n    public function setFallbackLocales(array $locales): void\\n    {\\n        $this->disallowMutation(__METHOD__);\\n\\n        parent::setFallbackLocales($locales);\\n    }\\n\\n    private function disallowMutation($method)\\n    {\\n        if ($this->constructed) {\\n            throw new ImmutableException($method.' not allowed on '.static::class);\\n        }\\n    }\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/CarbonConverterInterface.php\",\"ext\":\"php\",\"size\":443,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\ndeclare(strict_types=1);\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nnamespace Carbon;\\n\\nuse DateTimeInterface;\\n\\ninterface CarbonConverterInterface\\n{\\n    public function convertDate(DateTimeInterface $dateTime, bool $negated = false): CarbonInterface;\\n}\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/CarbonInterface.php\",\"ext\":\"php\",\"size\":314722,\"mtime\":1756373565},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Lang\/en_CH.php\",\"ext\":\"php\",\"size\":519,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nreturn array_replace_recursive(require __DIR__.'\/en.php', [\\n    'formats' => [\\n        'LT' => 'HH:mm',\\n        'LTS' => 'HH:mm:ss',\\n        'L' => 'DD.MM.YYYY',\\n        'LL' => 'D MMMM YYYY',\\n        'LLL' => 'D MMMM YYYY HH:mm',\\n        'LLLL' => 'dddd D MMMM YYYY HH:mm',\\n    ],\\n]);\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Lang\/tr_TR.php\",\"ext\":\"php\",\"size\":267,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nreturn require __DIR__.'\/tr.php';\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Lang\/en_CM.php\",\"ext\":\"php\",\"size\":267,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nreturn require __DIR__.'\/en.php';\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Lang\/en_IE.php\",\"ext\":\"php\",\"size\":682,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\n\/*\\n * Authors:\\n * - Martin McWhorter\\n * - Fran\u00e7ois B\\n * - Chris Cartlidge\\n * - JD Isaacks\\n *\/\\nreturn array_replace_recursive(require __DIR__.'\/en.php', [\\n    'from_now' => 'in :time',\\n    'formats' => [\\n        'LT' => 'HH:mm',\\n        'LTS' => 'HH:mm:ss',\\n        'L' => 'DD-MM-YYYY',\\n        'LL' => 'D MMMM YYYY',\\n        'LLL' => 'D MMMM YYYY HH:mm',\\n        'LLLL' => 'dddd D MMMM YYYY HH:mm',\\n    ],\\n    'day_of_first_week_of_year' => 4,\\n]);\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Lang\/the_NP.php\",\"ext\":\"php\",\"size\":1537,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\n\/*\\n * Authors:\\n * - Chitwanix OS Development    info@chitwanix.com\\n *\/\\nreturn array_replace_recursive(require __DIR__.'\/en.php', [\\n    'formats' => [\\n        'L' => 'dddd DD MMM YYYY',\\n    ],\\n    'months' => ['\u091c\u0928\u0935\u0930\u0940', '\u092b\u093c\u0930\u0935\u0930\u0940', '\u092e\u093e\u0930\u094d\u091a', '\u0905\u092a\u094d\u0930\u0947\u0932', '\u092e\u0908', '\u091c\u0942\u0928', '\u091c\u0941\u0932\u093e\u0908', '\u0905\u0917\u0938\u094d\u0924', '\u0938\u093f\u0924\u092e\u094d\u092c\u0930', '\u0905\u0915\u094d\u091f\u0942\u092c\u0930', '\u0928\u0935\u092e\u094d\u092c\u0930', '\u0926\u093f\u0938\u092e\u094d\u092c\u0930'],\\n    'months_short' => ['\u091c\u0928\u0935\u0930\u0940', '\u092b\u093c\u0930\u0935\u0930\u0940', '\u092e\u093e\u0930\u094d\u091a', '\u0905\u092a\u094d\u0930\u0947\u0932', '\u092e\u0908', '\u091c\u0942\u0928', '\u091c\u0941\u0932\u093e\u0908', '\u0905\u0917\u0938\u094d\u0924', '\u0938\u093f\u0924\u092e\u094d\u092c\u0930', '\u0905\u0915\u094d\u091f\u0942\u092c\u0930', '\u0928\u0935\u092e\u094d\u092c\u0930', '\u0926\u093f\u0938\u092e\u094d\u092c\u0930'],\\n    'weekdays' => ['\u0906\u0907\u0924\u092c\u093e\u0930', '\u0938\u094b\u092e\u092c\u093e\u0930', '\u092e\u0902\u0917\u0932\u092c\u093e\u0930', '\u092c\u0941\u0927\u092c\u093e\u0930', '\u092c\u093f\u0939\u093f\u092c\u093e\u0930', '\u0936\u0941\u0915\u094d\u0930\u092c\u093e\u0930', '\u0936\u0928\u093f\u092c\u093e\u0930'],\\n    'weekdays_short' => ['\u0906\u0907\u0924', '\u0938\u094b\u092e', '\u092e\u0902\u0917\u0932', '\u092c\u0941\u0927', '\u092c\u093f\u0939\u093f', '\u0936\u0941\u0915\u094d\u0930', '\u0936\u0928\u093f'],\\n    'weekdays_min' => ['\u0906\u0907\u0924', '\u0938\u094b\u092e', '\u092e\u0902\u0917\u0932', '\u092c\u0941\u0927', '\u092c\u093f\u0939\u093f', '\u0936\u0941\u0915\u094d\u0930', '\u0936\u0928\u093f'],\\n    'first_day_of_week' => 0,\\n    'day_of_first_week_of_year' => 1,\\n    'meridiem' => ['\u092a\u0942\u0930\u094d\u0935\u093e\u0939\u094d\u0928', '\u0905\u092a\u0930\u093e\u0939\u094d\u0928'],\\n]);\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Lang\/sc.php\",\"ext\":\"php\",\"size\":334,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\n\/*\\n * Unknown default region, use the first alphabetically.\\n *\/\\nreturn require __DIR__.'\/sc_IT.php';\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Lang\/vun.php\",\"ext\":\"php\",\"size\":1091,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nreturn array_replace_recursive(require __DIR__.'\/en.php', [\\n    'meridiem' => ['utuko', 'kyiukonyi'],\\n    'weekdays' => ['Jumapilyi', 'Jumatatuu', 'Jumanne', 'Jumatanu', 'Alhamisi', 'Ijumaa', 'Jumamosi'],\\n    'weekdays_short' => ['Jpi', 'Jtt', 'Jnn', 'Jtn', 'Alh', 'Iju', 'Jmo'],\\n    'weekdays_min' => ['Jpi', 'Jtt', 'Jnn', 'Jtn', 'Alh', 'Iju', 'Jmo'],\\n    'months' => ['Januari', 'Februari', 'Machi', 'Aprilyi', 'Mei', 'Junyi', 'Julyai', 'Agusti', 'Septemba', 'Oktoba', 'Novemba', 'Desemba'],\\n    'months_short' => ['Jan', 'Feb', 'Mac', 'Apr', 'Mei', 'Jun', 'Jul', 'Ago', 'Sep', 'Okt', 'Nov', 'Des'],\\n    'first_day_of_week' => 1,\\n    'formats' => [\\n        'LT' => 'HH:mm',\\n        'LTS' => 'HH:mm:ss',\\n        'L' => 'DD\/MM\/YYYY',\\n        'LL' => 'D MMM YYYY',\\n        'LLL' => 'D MMMM YYYY HH:mm',\\n        'LLLL' => 'dddd, D MMMM YYYY HH:mm',\\n    ],\\n]);\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Lang\/en_LR.php\",\"ext\":\"php\",\"size\":267,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nreturn require __DIR__.'\/en.php';\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Lang\/nl_BQ.php\",\"ext\":\"php\",\"size\":267,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nreturn require __DIR__.'\/nl.php';\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Lang\/en_NG.php\",\"ext\":\"php\",\"size\":388,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nreturn array_replace_recursive(require __DIR__.'\/en.php', [\\n    'formats' => [\\n        'L' => 'DD\/MM\/YY',\\n    ],\\n    'day_of_first_week_of_year' => 1,\\n]);\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Lang\/shi_Latn.php\",\"ext\":\"php\",\"size\":1270,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nreturn array_replace_recursive(require __DIR__.'\/shi.php', [\\n    'meridiem' => ['tifawt', 'tadgg\u02b7at'],\\n    'weekdays' => ['asamas', 'aynas', 'asinas', 'ak\u1e5bas', 'akwas', 'asimwas', 'asi\u1e0dyas'],\\n    'weekdays_short' => ['asa', 'ayn', 'asi', 'ak\u1e5b', 'akw', 'asim', 'asi\u1e0d'],\\n    'weekdays_min' => ['asa', 'ayn', 'asi', 'ak\u1e5b', 'akw', 'asim', 'asi\u1e0d'],\\n    'months' => ['innayr', 'b\u1e5bay\u1e5b', 'ma\u1e5b\u1e63', 'ibrir', 'mayyu', 'yunyu', 'yulyuz', '\u0263uct', 'cutanbir', 'ktubr', 'nuwanbir', 'dujanbir'],\\n    'months_short' => ['inn', 'b\u1e5ba', 'ma\u1e5b', 'ibr', 'may', 'yun', 'yul', '\u0263uc', 'cut', 'ktu', 'nuw', 'duj'],\\n    'first_day_of_week' => 6,\\n    'weekend' => [5, 6],\\n    'formats' => [\\n        'LT' => 'HH:mm',\\n        'LTS' => 'HH:mm:ss',\\n        'L' => 'D\/M\/YYYY',\\n        'LL' => 'D MMM, YYYY',\\n        'LLL' => 'D MMMM YYYY HH:mm',\\n        'LLLL' => 'dddd D MMMM YYYY HH:mm',\\n    ],\\n\\n    'minute' => ':count agur', \/\/ less reliable\\n    'min' => ':count agur', \/\/ less reliable\\n    'a_minute' => ':count agur', \/\/ less reliable\\n]);\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Lang\/lkt.php\",\"ext\":\"php\",\"size\":1276,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nreturn array_replace_recursive(require __DIR__.'\/en.php', [\\n    'first_day_of_week' => 0,\\n\\n    'month' => ':count ha\u014bw\u00ed', \/\/ less reliable\\n    'm' => ':count ha\u014bw\u00ed', \/\/ less reliable\\n    'a_month' => ':count ha\u014bw\u00ed', \/\/ less reliable\\n\\n    'week' => ':count \u0161ak\u00f3wi\u014b', \/\/ less reliable\\n    'w' => ':count \u0161ak\u00f3wi\u014b', \/\/ less reliable\\n    'a_week' => ':count \u0161ak\u00f3wi\u014b', \/\/ less reliable\\n\\n    'hour' => ':count maza \u0161ka\u014b\u0161ka\u014b', \/\/ less reliable\\n    'h' => ':count maza \u0161ka\u014b\u0161ka\u014b', \/\/ less reliable\\n    'a_hour' => ':count maza \u0161ka\u014b\u0161ka\u014b', \/\/ less reliable\\n\\n    'minute' => ':count \u010d\u00edk\u02bcala', \/\/ less reliable\\n    'min' => ':count \u010d\u00edk\u02bcala', \/\/ less reliable\\n    'a_minute' => ':count \u010d\u00edk\u02bcala', \/\/ less reliable\\n\\n    'year' => ':count wan\u00edyetu',\\n    'y' => ':count wan\u00edyetu',\\n    'a_year' => ':count wan\u00edyetu',\\n\\n    'day' => ':count a\u014bp\u00e9tu',\\n    'd' => ':count a\u014bp\u00e9tu',\\n    'a_day' => ':count a\u014bp\u00e9tu',\\n\\n    'second' => ':count icinu\u014bpa',\\n    's' => ':count icinu\u014bpa',\\n    'a_second' => ':count icinu\u014bpa',\\n]);\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Lang\/wa.php\",\"ext\":\"php\",\"size\":334,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\n\/*\\n * Unknown default region, use the first alphabetically.\\n *\/\\nreturn require __DIR__.'\/wa_BE.php';\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Lang\/lu.php\",\"ext\":\"php\",\"size\":1110,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nreturn array_replace_recursive(require __DIR__.'\/en.php', [\\n    'meridiem' => ['Dinda', 'Dilolo'],\\n    'weekdays' => ['Lumingu', 'Nkodya', 'Nd\u00e0ay\u00e0', 'Ndang\u00f9', 'Nj\u00f2wa', 'Ng\u00f2vya', 'Lubingu'],\\n    'weekdays_short' => ['Lum', 'Nko', 'Ndy', 'Ndg', 'Njw', 'Ngv', 'Lub'],\\n    'weekdays_min' => ['Lum', 'Nko', 'Ndy', 'Ndg', 'Njw', 'Ngv', 'Lub'],\\n    'months' => ['Ciongo', 'L\u00f9ishi', 'Lus\u00f2lo', 'M\u00f9uy\u00e0', 'Lum\u00f9ng\u00f9l\u00f9', 'Lufuimi', 'Kab\u00e0l\u00e0sh\u00ecp\u00f9', 'L\u00f9sh\u00eck\u00e0', 'Lutongolo', 'Lung\u00f9di', 'Kasw\u00e8k\u00e8s\u00e8', 'Cisw\u00e0'],\\n    'months_short' => ['Cio', 'Lui', 'Lus', 'Muu', 'Lum', 'Luf', 'Kab', 'Lush', 'Lut', 'Lun', 'Kas', 'Cis'],\\n    'first_day_of_week' => 1,\\n    'formats' => [\\n        'LT' => 'HH:mm',\\n        'LTS' => 'HH:mm:ss',\\n        'L' => 'D\/M\/YYYY',\\n        'LL' => 'D MMM YYYY',\\n        'LLL' => 'D MMMM YYYY HH:mm',\\n        'LLLL' => 'dddd D MMMM YYYY HH:mm',\\n    ],\\n]);\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Lang\/fr_BI.php\",\"ext\":\"php\",\"size\":267,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\nreturn require __DIR__.'\/fr.php';\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Lang\/sr_RS.php\",\"ext\":\"php\",\"size\":355,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\n\/*\\n * Authors:\\n * - sr_YU, sr_CS locale Danilo Segan bug-glibc-locales@gnu.org\\n *\/\\nreturn require __DIR__.'\/sr_Cyrl.php';\\n\"},{\"base\":\"plugins\",\"rel\":\"hostinger-ai-assistant\/vendor\/nesbot\/carbon\/src\/Carbon\/Lang\/sat_IN.php\",\"ext\":\"php\",\"size\":2533,\"mtime\":1756373565,\"type\":\"text\",\"content\":\"<?php\\n\\n\/**\\n * This file is part of the Carbon package.\\n *\\n * (c) Brian Nesbitt <brian@nesbot.com>\\n *\\n * For the full copyright and license information, please view the LICENSE\\n * file that was distributed with this source code.\\n *\/\\n\\n\/*\\n * Authors:\\n * - Red Hat Pune    libc-alpha@sourceware.org\\n *\/\\nreturn array_replace_recursive(require __DIR__.'\/en.php', [\\n    'formats' => [\\n        'L' => 'D\/M\/YY',\\n    ],\\n    'months' => ['\u091c\u0928\u0935\u0930\u0940', '\u092b\u0930\u0935\u0930\u0940', '\u092e\u093e\u0930\u094d\u091a', '\u0905\u092a\u094d\u0930\u0947\u0932', '\u092e\u0908', '\u091c\u0941\u0928', '\u091c\u0941\u0932\u093e\u0908', '\u0905\u0917\u0938\u094d\u0924', '\u0938\u093f\u0924\u092e\u094d\u092c\u0930', '\u0905\u0916\u0925\u092c\u0930', '\u0928\u0935\u092e\u094d\u092c\u0930', '\u0926\u093f\u0938\u092e\u094d\u092c\u0930'],\\n    'months_short' => ['\u091c\u0928\u0935\u0930\u0940', '\u092b\u0930\u0935\u0930\u0940', '\u092e\u093e\u0930\u094d\u091a', '\u0905\u092a\u094d\u0930\u0947\u0932', '\u092e\u0908', '\u091c\u0941\u0928', '\u091c\u0941\u0932\u093e\u0908', '\u0905\u0917\u0938\u094d\u0924', '\u0938\u093f\u0924\u092e\u094d\u092c\u0930', '\u0905\u0916\u0925\u092c\u0930', '\u0928\u0935\u092e\u094d\u092c\u0930', '\u0926\u093f\u0938\u092e\u094d\u092c\u0930'],\\n    'weekdays' => ['\u0938\u093f\u0902\u0917\u0947\u092e\u093e\u0901\u0939\u093e\u0901', '\u0913\u0924\u0947\u092e\u093e\u0901\u0939\u093e\u0901', '\u092c\u093e\u0932\u0947\u092e\u093e\u0901\u0939\u093e\u0901', '\u0938\u093e\u0917\u0941\u0928\u092e\u093e\u0901\u0939\u093e\u0901', '\u0938\u093e\u0930\u0926\u0940\u092e\u093e\u0901\u0939\u093e\u0901', '\u091c\u093e\u0930\u0941\u092e\u092e\u093e\u0901\u0939\u093e\u0901', '\u091e\u0941\u0939\u0941\u092e\u092e\u093e\u0901\u0939\u093e\u0901'],\\n    'weekdays_short' => ['\u0938\u093f\u0902\u0917\u0947', '\u0913\u0924\u0947', '\u092c\u093e\u0932\u0947', '\u0938\u093e\u0917\u0941\u0928', '\u0938\u093e\u0930\u0926\u0940', '\u091c\u093e\u0930\u0941\u092e', '\u091e\u0941\u0939\u0941\u092e'],\\n    'weekdays_min' => ['\u0938\u093f\u0902\u0917\u0947', '\u0913\u0924\u0947', '\u092c\u093e\u0932\u0947', '\u0938\u093e\u0917\u0941\u0928', '\u0938\u093e\u0930\u0926\u0940', '\u091c\u093e\u0930\u0941\u092e', '\u091e\u0941\u0939\u0941\u092e'],\\n    'first_day_of_week' => 0,\\n    'day_of_first_week_of_year' => 1,\\n\\n    'month' => ':count \u0144ind\u1ea1 cando', \/\/ less reliable\\n    'm' => ':count \u0144ind\u1ea1 cando', \/\/ less reliable\\n    'a_month' => ':count \u0144ind\u1ea1 cando', \/\/ less reliable\\n\\n    'week' => ':count m\u00e3h\u00e3', \/\/ less reliable\\n    'w' => ':count m\u00e3h\u00e3', \/\/ less reliable\\n    'a_week' => ':count m\u00e3h\u00e3', \/\/ less reliable\\n\\n    'hour' => ':count \u1c65\u1c73\u1c71\u1c5a', \/\/ less reliable\\n    'h' => ':count \u1c65\u1c73\u1c71\u1c5a', \/\/ less reliable\\n    'a_hour' => ':count \u1c65\u1c73\u1c71\u1c5a', \/\/ less reliable\\n\\n    'minute' => ':count \u1c6f\u1c64\u1c5e\u1c6a\u1c69', \/\/ less reliable\\n    'min' => ':count \u1c6f\u1c64\u1c5e\u1c6a\u1c69', \/\/ less reliable\\n    'a_minute' => ':count \u1c6f\u1c64\u1c5e\u1c6a\u1c69', \/\/ less reliable\\n\\n    'second' => ':count ar', \/\/ less reliable\\n    's' => ':count ar', \/\/ less reliable\\n    'a_second' => ':count ar', \/\/ less reliable\\n\\n    'year' => ':count ne\u0332s',\\n    'y' => ':count ne\u0332s',\\n    'a_year' => ':count ne\u0332s',\\n\\n    'day' => ':count \u1c6b\u1c64\u1c71',\\n    'd' => ':count \u1c6b\u1c64\u1c71',\\n    'a_day' => ':count \u1c6b\u1c64\u1c71',\\n]);\\n\"}]"