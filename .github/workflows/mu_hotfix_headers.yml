name: mu_fix_trail_scan

on:
  workflow_dispatch: {}

permissions:
  contents: read

concurrency:
  group: mu-fix-trail
  cancel-in-progress: true

jobs:
  fix-and-scan:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - name: Fix TRAIL (pure POSIX) + rescan
        uses: appleboy/ssh-action@v1.0.3
        with:
          host:     ${{ secrets.DEPLOY_HOST }}
          port:     ${{ secrets.DEPLOY_PORT }}
          username: ${{ secrets.DEPLOY_USER }}
          password: ${{ secrets.DEPLOY_PASS }}
          command_timeout: 15m
          script: |
            set -eu

            ROOT="${HOME}/domains/weektoppick.com/public_html"
            test -f "${ROOT}/wp-config.php" || { echo "::error::Brak wp-config.php w ${ROOT}"; exit 1; }
            cd "${ROOT}"
            echo "[INFO] WP_ROOT=${ROOT}"

            TARGETS="wp-content/mu-plugins wp-content/themes"

            echo "== A) Wykryj pliki z TRAIL (tekst po '?>' na końcu) =="
            TRAIL_LIST="$(mktemp)"
            # Skany bez /proc i bez perl: wypiszemy pliki, w których po '?>' NIE jest czysty EOF
            # Heurystyka: jeżeli plik zawiera '?>' i ostatnia linia NIE kończy się dokładnie na '?>'
            # to potencjalnie ma śmieci po zamykającym tagu.
            while IFS= read -r f; do
              # pomiń bardzo duże binarne rzeczy – ale my i tak bierzemy *.php
              if grep -q "?>" "$f"; then
                # ostatnie 200 bajtów wystarczą, żeby ocenić ogon
                TAILHEX="$(tail -c 200 "$f" | od -An -tx1 || true)"
                # jeśli w ogonie jest sekwencja '3f 3e' (?>), a po niej cokolwiek nie-białego → uznamy za TRAIL
                # prościej: sprawdźmy literalnie: jeśli plik kończy się '?>' + (SP/TAB/CR/LF) → OK,
                # jeśli ma '?>' a nie kończy się bezpośrednio na '?>' → oznacz jako TRAIL
                if awk 'END{ if (NR==0) exit 1; last=$0; } END{ if (match(last,/\?>[[:space:]]*$/)) exit 1; else exit 0 }' "$f"; then
                  echo "$f" >> "$TRAIL_LIST"
                fi
              fi
            done < <(find $TARGETS -type f -name '*.php' 2>/dev/null)

            echo "-- TRAIL kandydaci --"
            if [ -s "$TRAIL_LIST" ]; then
              nl -ba "$TRAIL_LIST"
            else
              echo "(brak)"
            fi

            echo "== B) Napraw TRAIL (usuń końcowe '?>' + whitespace) =="
            if [ -s "$TRAIL_LIST" ]; then
              while IFS= read -r f; do
                cp "$f" "$f.wtp.bak" || true
                # Zbuduj nową wersję bez końcowego '?>' i białych znaków po nim:
                awk '{
                      buf = buf $0 ORS
                    }
                    END{
                      # usuń trailing whitespace na końcu
                      sub(/[[:space:]]+$/,"",buf)
                      # usuń końcowe "?>" + ewentualny whitespace
                      sub(/\?>[[:space:]]*$/,"",buf)
                      printf "%s", buf
                    }' "$f" > "$f.wtp.tmp" && mv "$f.wtp.tmp" "$f"
                echo "fixed: $f"
              done < "$TRAIL_LIST"
            else
              echo "Nic do naprawy (TRAIL)"
            fi

            echo "== C) Rescan (BOM / HEAD / TRAIL / ECHO_TOP) =="
            echo "-- 1) BOM na początku (EF BB BF) --"
            FOUND=0
            while IFS= read -r f; do
              if head -c 3 "$f" | od -An -tx1 | grep -qi "ef bb bf"; then
                echo "BOM: $f"; FOUND=1
              fi
            done < <(find $TARGETS -type f -name '*.php' 2>/dev/null)
            [ "${FOUND:-0}" -eq 0 ] && echo "(none)"

            echo "-- 2) Pliki nie zaczynające się od '<?php' (informacyjnie) --"
            FOUND=0
            while IFS= read -r f; do
              H="$(head -c 5 "$f" | tr -d '\r\n')"
              if [ "$H" != "<?php" ]; then
                echo "HEAD: $f  (starts with: $(head -c 16 "$f" | od -An -tx1 || true))"
                FOUND=1
              fi
            done < <(find $TARGETS -type f -name '*.php' 2>/dev/null)
            [ "${FOUND:-0}" -eq 0 ] && echo "(none)"

            echo "-- 3) TRAIL po naprawie --"
            FOUND=0
            while IFS= read -r f; do
              if grep -q "?>" "$f"; then
                if awk 'END{ if (NR==0) exit 1; last=$0; } END{ if (match(last,/\?>[[:space:]]*$/)) exit 1; else exit 0 }' "$f"; then
                  echo "TRAIL: $f"; FOUND=1
                fi
              fi
            done < <(find $TARGETS -type f -name '*.php' 2>/dev/null)
            [ "${FOUND:-0}" -eq 0 ] && echo "(none)"

            echo "-- 4) echo/print/var_dump/printf w TOP 40 liniach --"
            FOUND=0
            while IFS= read -r f; do
              if head -n 40 "$f" | grep -qE '^[[:space:]]*(echo|print|var_dump|printf)\b'; then
                echo "ECHO_TOP: $f"; FOUND=1
              fi
            done < <(find $TARGETS -type f -name '*.php' 2>/dev/null)
            [ "${FOUND:-0}" -eq 0 ] && echo "(none)"

            echo "== D) Podgląd functions.php (początek) =="
            THEME_FN="wp-content/themes/wtp-core-theme/functions.php"
            command -v xxd >/dev/null && xxd -g 1 -l 16 "${THEME_FN}" || head -c 32 "${THEME_FN}" | od -An -tx1
            echo "-- first 60 lines --"
            nl -ba "${THEME_FN}" | sed -n '1,60p' || true

            echo "== DONE =="
