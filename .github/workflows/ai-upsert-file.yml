name: AI Upsert File

on:
  workflow_dispatch:
    inputs:
      path:
        description: 'Target path in repo (np. mu-plugins/00-mu-safe-loader.php)'
        required: false
        default: 'sandbox/ai-upsert-test.txt'
        type: string
      message:
        description: 'Commit message'
        required: false
        default: 'chore(upsert): test commit from UI'
        type: string
      content_plain:
        description: 'File content (PLAIN). Jeśli podasz – workflow sam zakoduje do Base64'
        required: false
        default: 'Hello from AI Upsert (default).'
        type: string
      content_b64:
        description: 'File content (Base64). Zostaw puste, jeśli używasz content_plain'
        required: false
        type: string
      branch:
        description: 'Target branch'
        required: false
        default: 'main'
        type: string
  repository_dispatch:
    types: [ai-upsert-file]

permissions:
  contents: write

concurrency:
  group: ai-upsert-file
  cancel-in-progress: true

jobs:
  upsert:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Upsert file via GitHub API (UI or repository_dispatch)
        uses: actions/github-script@v7
        with:
          script: |
            const ev = context.eventName;

            // pobierz inputs (UI) lub client_payload (repo dispatch)
            const getStr = (name, def='') => (core.getInput(name, { required: false }) || def).trim();
            let path, message, branch, content_b64, content_plain;

            if (ev === 'repository_dispatch') {
              const p = context.payload?.client_payload || {};
              path         = (p.path || 'sandbox/ai-upsert-test.txt').trim();
              message      = (p.message || 'chore(upsert): test commit from dispatch').trim();
              branch       = (p.branch || 'main').trim();
              content_b64  = (p.content_b64 || '').trim();
              content_plain= (p.content_plain || 'Hello from AI Upsert (dispatch default).').trim();
            } else {
              path         = getStr('path','sandbox/ai-upsert-test.txt');
              message      = getStr('message','chore(upsert): test commit from UI');
              branch       = getStr('branch','main');
              content_b64  = getStr('content_b64','');
              content_plain= getStr('content_plain','Hello from AI Upsert (default).');
            }

            core.info(`event=${ev}`);
            core.info(`path="${path}", branch="${branch}"`);
            core.info(`has_plain=${!!content_plain}, has_b64=${!!content_b64}`);

            // jeśli brak b64, zakoduj plain
            if (!content_b64) {
              content_b64 = Buffer.from(content_plain, 'utf8').toString('base64');
            }

            const { owner, repo } = context.repo;

            // odczytaj aktualny sha (jeśli plik istnieje)
            let sha;
            try {
              const { data } = await github.request('GET /repos/{owner}/{repo}/contents/{path}', {
                owner, repo, path, ref: branch,
              });
              sha = data?.sha;
              core.info(`Existing file sha=${sha || ''}`);
            } catch (e) {
              if (e.status === 404) {
                core.info('File does not exist yet (creating new).');
              } else {
                core.setFailed(`getContent failed: ${e.message}`);
                return;
              }
            }

            // PUT create/update
            try {
              const res = await github.request('PUT /repos/{owner}/{repo}/contents/{path}', {
                owner, repo, path, message, branch, content: content_b64, sha
              });
              core.info(`OK: ${res.status}, commit: ${res.data.commit?.sha}`);
              await core.summary
                .addHeading('AI Upsert File')
                .addList([
                  `path: ${path}`,
                  `branch: ${branch}`,
                  `commit: ${res.data.commit?.sha || ''}`
                ])
                .write();
            } catch (e) {
              core.setFailed(`PUT failed: ${e.message}`);
            }
