name: AI Upsert File

on:
  workflow_dispatch:
    inputs:
      path:
        description: 'Target path in repo (np. mu-plugins/00-mu-safe-loader.php)'
        required: true
        type: string
      message:
        description: 'Commit message'
        required: true
        type: string
      content_plain:
        description: 'File content (PLAIN). Jeśli podasz – workflow sam zakoduje do Base64'
        required: false
        type: string
      content_b64:
        description: 'File content (Base64). Zostaw puste, jeśli używasz content_plain'
        required: false
        type: string
      branch:
        description: 'Target branch'
        required: false
        default: 'main'
        type: string
  repository_dispatch:
    types: [ai-upsert-file]

permissions:
  contents: write

concurrency:
  group: ai-upsert-file
  cancel-in-progress: true

jobs:
  upsert:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Upsert file via GitHub API (UI or repository_dispatch)
        uses: actions/github-script@v7
        with:
          script: |
            // 1) Zbierz wejście z UI (workflow_dispatch) lub z client_payload (repository_dispatch)
            const ev = context.eventName;

            function getStrInput(name, req=false) {
              const v = core.getInput(name, { required: false }) || '';
              if (req && !v) throw new Error(`Missing required input: ${name}`);
              return v;
            }

            let path = '';
            let message = '';
            let branch = '';
            let content_b64 = '';
            let content_plain = '';

            if (ev === 'repository_dispatch') {
              const p = context.payload?.client_payload || {};
              path         = (p.path || '').trim();
              message      = (p.message || '').trim();
              branch       = (p.branch || 'main').trim();
              content_b64  = (p.content_b64 || '').trim();
              content_plain= (p.content_plain || '').trim();
            } else {
              path         = (getStrInput('path') || '').trim();
              message      = (getStrInput('message') || '').trim();
              branch       = (getStrInput('branch') || 'main').trim();
              content_b64  = (getStrInput('content_b64') || '').trim();
              content_plain= (getStrInput('content_plain') || '').trim();
            }

            core.info(`event=${ev}`);
            core.info(`path.len=${path.length}, branch=${branch}`);
            core.info(`has_plain=${!!content_plain}, has_b64=${!!content_b64}`);

            if (!path)  core.setFailed('Input "path" is required and was empty.');
            if (!message) core.setFailed('Input "message" is required and was empty.');
            if (!path || !message) return;

            // 2) Jeśli nie ma b64 a jest plain – zakoduj
            if (!content_b64) {
              if (!content_plain) {
                core.setFailed('Provide either content_plain or content_b64.');
                return;
              }
              content_b64 = Buffer.from(content_plain, 'utf8').toString('base64');
            }

            const { owner, repo } = context.repo;

            // 3) Pobierz SHA jeśli plik istnieje
            let sha;
            try {
              const { data } = await github.request('GET /repos/{owner}/{repo}/contents/{path}', {
                owner, repo, path, ref: branch,
              });
              sha = data?.sha;
              core.info(`Current file exists, sha=${sha || ''}`);
            } catch (e) {
              if (e.status === 404) {
                core.info('File does not exist yet (creating new).');
              } else {
                core.setFailed(`getContent failed: ${e.message}`);
                return;
              }
            }

            // 4) PUT (create/update)
            try {
              const res = await github.request('PUT /repos/{owner}/{repo}/contents/{path}', {
                owner, repo, path, message, branch, content: content_b64, sha
              });
              core.info(`OK: ${res.status}, commit: ${res.data.commit?.sha}`);
              await core.summary
                .addHeading('AI Upsert File')
                .addList([
                  `path: ${path}`,
                  `branch: ${branch}`,
                  `commit: ${res.data.commit?.sha || ''}`
                ])
                .write();
            } catch (e) {
              core.setFailed(`PUT failed: ${e.message}`);
            }
