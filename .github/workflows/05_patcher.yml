name: 05_patcher

on:
  repository_dispatch:
    types: [ai-patcher]
  workflow_dispatch: {}   # ręcznie na próbę

permissions:
  contents: read

concurrency:
  group: patcher
  cancel-in-progress: true

jobs:
  patch:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    env:
      GH_PAT: ${{ secrets.WTP_GITHUB_PAT }}
      OPENAI_API_KEY: ${{ secrets.WTP_OPENAI_API_KEY }}
      OWNER: ${{ github.repository_owner }}
      REPO:  ${{ github.event.repository.name }}
    steps:
      - uses: actions/checkout@v4

      - name: Gather context (payload → /tmp/input.json)
        run: |
          set -euo pipefail
          # 1) Raw payload z repository_dispatch (może być puste)
          printf '%s' '${{ toJson(github.event.client_payload) }}' > /tmp/incoming.json

          # 2) next.json (opcjonalnie, ale preferowane)
          NX=".wtp/next.json"
          if [ -f "$NX" ]; then
            jq -c . "$NX" > /tmp/next.json
          else
            echo "{}" > /tmp/next.json
          fi

          # 3) ostatni snapshot (opcjonalny)
          SNAP=".wtp/state/ro/public/latest/snapshot.json"
          if [ -f "$SNAP" ]; then
            jq -c . "$SNAP" > /tmp/snapshot.json
          else
            echo "{}" > /tmp/snapshot.json
          fi

          # 4) scal: incoming nadpisuje next.json (jeśli przekazano pola), snapshot do kontekstu
          jq -n \
            --slurpfile a /tmp/next.json \
            --slurpfile b /tmp/incoming.json \
            --slurpfile s /tmp/snapshot.json '
              def norm(x):
                {
                  path:        (x.path // ""),
                  message:     (x.message // ""),
                  branch:      (x.branch // "main"),
                  content_b64: (x.content_b64 // ""),
                  content_plain:(x.content_plain // ""),
                  raw_url:     (x.raw_url // ""),
                  verify:      (x.verify // {}),
                  auto:        (x.auto // {})
                };
              (norm($a[0]) + norm($b[0])) as $m
              | {meta:$m, snapshot:$s[0]}
            ' > /tmp/input.json

          echo "---- INPUT (meta) ----"
          jq .meta /tmp/input.json
          echo "---- SNAP present ----"
          jq 'keys|length' /tmp/input.json >/dev/null

      - name: Build AI prompt (/tmp/prompt.md)
        run: |
          set -euo pipefail
          cat > /tmp/prompt.md <<'PROMPT'
You are an autonomous repo patcher for a WordPress project (MU-plugins + theme).
Goal: produce ONE JSON object with a patch to upsert a file in the repository.

### Required OUTPUT (JSON only, no text around):
{
  "path": "relative/path/in/repo",
  "message": "commit message",
  "branch": "main",
  "content_plain": "FILE CONTENT (use \\n for newlines)"
}

Rules:
- Output **only** valid JSON (no markdown, no prose).
- Prefer `content_plain` (no base64). No trailing spaces at line ends.
- Keep code minimal and safe. If not sure, create a harmless test file.
- If `meta.path` is present, respect it. Otherwise propose a sensible path.
- If theme patch: path under `themes/wtp-core-theme/…`
- If MU patch: path under `mu-plugins/…`
- Keep commit message short and descriptive.

### Context
PROMPT
          echo '```json'              >> /tmp/prompt.md
          jq . /tmp/input.json        >> /tmp/prompt.md
          echo '```'                  >> /tmp/prompt.md
          echo "Prompt bytes: $(wc -c </tmp/prompt.md)"

      - name: Call OpenAI → /tmp/ai.json
        run: |
          set -euo pipefail
          test -n "${OPENAI_API_KEY}" || { echo "::error::Missing secret WTP_OPENAI_API_KEY"; exit 1; }

          # minimal chat.completions call; model możesz zmienić na swój
          curl -sS https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer ${OPENAI_API_KEY}" \
            -H "Content-Type: application/json" \
            -d @- > /tmp/ai_raw.json <<'REQ'
          {
            "model": "gpt-4o-mini",
            "temperature": 0.2,
            "messages": [
              {"role":"system","content":"You are a careful DevOps/WordPress patch planner. Respond with JSON only."},
              {"role":"user","content": null}
            ],
            "response_format": {"type":"json_object"}
          }
REQ
          # wstrzyknij prompt (musimy podmienić null → treść z pliku)
          python3 - <<'PY'
import json,sys
raw=open("/tmp/ai_raw.json","rb").
