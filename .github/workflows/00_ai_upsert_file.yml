name: 00_ai_upsert_file

on:
  workflow_dispatch:
    inputs:
      path:
        description: 'Ścieżka w repo (np. themes/wtp-core-theme/_agent-proof.txt)'
        required: false
        type: string
      message:
        description: 'Commit message'
        required: false
        type: string
      content_plain:
        description: 'Treść pliku (PLAIN) — użyj jednego z: content_plain lub content_b64'
        required: false
        type: string
      content_b64:
        description: 'Treść pliku (Base64) — użyj jednego z: content_plain lub content_b64'
        required: false
        type: string
      sha256:
        description: 'Opcjonalny SHA-256 zdekodowanej treści'
        required: false
        type: string
      branch:
        description: 'Docelowy branch'
        required: false
        default: 'main'
        type: string
  repository_dispatch:
    types: [ai-upsert-file]

permissions:
  contents: write

concurrency:
  group: ai-upsert-file
  cancel-in-progress: true

jobs:
  upsert:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v4

      - name: Resolve inputs (UI / repo-dispatch / fallback to .wtp/agent/next.json)
        id: inp
        run: |
          set -euo pipefail
          to_json() { jq -c .; }

          EV="${{ github.event_name }}"
          PATH_INP="${{ github.event.inputs.path }}"
          MSG_INP="${{ github.event.inputs.message }}"
          PLA_INP="${{ github.event.inputs.content_plain }}"
          B64_INP="${{ github.event.inputs.content_b64 }}"
          SHA_INP="${{ github.event.inputs.sha256 }}"
          BR_INP="${{ github.event.inputs.branch }}"

          if [ "$EV" = "repository_dispatch" ]; then
            echo "repository_dispatch payload" >&2
            printf '%s' '${{ toJson(github.event.client_payload) }}' > /tmp/payload.json
          elif [ -n "${PATH_INP}${MSG_INP}${PLA_INP}${B64_INP}${SHA_INP}" ]; then
            echo "workflow_dispatch with inputs" >&2
            jq -n --arg path "$PATH_INP" --arg message "$MSG_INP" \
                  --arg cp "$PLA_INP" --arg cb "$B64_INP" \
                  --arg sha "$SHA_INP" --arg br "$BR_INP" \
                  '{path:$path,message:$message,content_plain:$cp,content_b64:$cb,sha256:$sha,branch:$br}' \
              > /tmp/payload.json
          else
            echo "fallback: reading .wtp/agent/next.json" >&2
            test -f .wtp/agent/next.json || { echo "::error::.wtp/agent/next.json not found and no inputs given"; exit 1; }
            jq -c . .wtp/agent/next.json > /tmp/payload.json
          fi

          cat /tmp/payload.json | to_json

      - name: Upsert file
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.WTP_GITHUB_PAT || github.token }}
          script: |
            const crypto = require('crypto');
            const p = require('fs').readFileSync('/tmp/payload.json','utf8');
            const cfg = JSON.parse(p);

            const path = (cfg.path||'').trim();
            const message = (cfg.message||'').trim();
            const branch = (cfg.branch||'main').trim();
            let content_b64 = (cfg.content_b64||'').trim();
            const content_plain = (cfg.content_plain||'').trim();
            const sha256 = (cfg.sha256||'').trim().toLowerCase();

            if (!path)    core.setFailed('path required');
            if (!message) core.setFailed('message required');
            if (!path || !message) process.exit(1);
            if (path.startsWith('/')) { core.setFailed('path must be repo-relative (no leading /)'); process.exit(1); }

            const both = content_plain && content_b64;
            const none = !content_plain && !content_b64;
            if (both || none) { core.setFailed('Provide exactly one: content_plain OR content_b64'); process.exit(1); }

            let buf;
            if (content_b64) {
              try { buf = Buffer.from(content_b64,'base64'); if (buf.toString('base64')!==content_b64) throw 0; }
              catch { core.setFailed('content_b64 not valid base64'); process.exit(1); }
            } else {
              buf = Buffer.from(content_plain,'utf8');
              content_b64 = buf.toString('base64');
            }

            if (sha256) {
              const calc = crypto.createHash('sha256').update(buf).digest('hex');
              if (calc !== sha256) { core.setFailed('SHA-256 mismatch'); process.exit(1); }
            }

            const {owner, repo} = context.repo;

            // Read existing file sha (optional)
            let sha;
            try {
              const r = await github.request('GET /repos/{owner}/{repo}/contents/{path}', {owner,repo,path,ref:branch});
              sha = r.data.sha;
            } catch(e){ if (e.status !== 404) { core.setFailed('GET contents failed: '+e.message); process.exit(1); } }

            // PUT
            const r2 = await github.request('PUT /repos/{owner}/{repo}/contents/{path}', {
              owner, repo, path, message, branch, content: content_b64, sha
            });
            const commitSha = r2.data?.commit?.sha || '';
            core.info('Committed '+commitSha);
            await core.summary.addHeading('AI Upsert File')
              .addTable([[{data:'Field',header:true},{data:'Value',header:true}],
                         ['path',path],['branch',branch],['commit',commitSha]])
              .write();
