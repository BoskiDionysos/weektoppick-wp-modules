name: 00_AI_upsert_file

on:
  schedule:
    - cron: "*/10 * * * *"   # co 10 minut
  workflow_dispatch: {}
  repository_dispatch:
    types: [agent-orchestrate]

permissions:
  contents: write   # commit plików
  actions: write    # dispatch innych workflowów

concurrency:
  group: agent-orchestrator
  cancel-in-progress: true

jobs:
  orchestrate:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Orchestrate next.json
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.WTP_GITHUB_PAT || github.token }}
          script: |
            const crypto = require('crypto');
            const core   = require('@actions/core');

            const { owner, repo } = context.repo;
            const branch = 'main';
            const NEXT_PATH = '.wtp/agent/next.json';
            const HISTORY_DIR = '.wtp/agent/history';

            async function getFile(path) {
              try {
                const { data } = await github.request('GET /repos/{owner}/{repo}/contents/{path}', {
                  owner, repo, path, ref: branch,
                });
                return data;
              } catch (e) {
                if (e.status === 404) return null;
                throw e;
              }
            }

            async function putFile(path, content_b64, message, sha) {
              const { data } = await github.request('PUT /repos/{owner}/{repo}/contents/{path}', {
                owner, repo, path, message, branch, content: content_b64, sha
              });
              return data;
            }

            async function deleteFile(path, message, sha) {
              await github.request('DELETE /repos/{owner}/{repo}/contents/{path}', {
                owner, repo, path, message, branch, sha
              });
            }

            // 1) Pobierz plan .wtp/agent/next.json
            const nextFile = await getFile(NEXT_PATH);
            if (!nextFile) {
              core.notice('Brak .wtp/agent/next.json → nic do zrobienia.');
              return;
            }
            const nextJson = JSON.parse(Buffer.from(nextFile.content, 'base64').toString('utf8'));

            // Oczekiwane pola
            let { path, message, content_plain, content_b64, sha256, dispatch, touch_paths } = nextJson;
            path = (path || '').trim();
            message = (message || '').trim();
            dispatch = Boolean(dispatch);
            touch_paths = Array.isArray(touch_paths) ? touch_paths : [];

            if (!path || !message || (!content_plain && !content_b64) || (content_plain && content_b64)) {
              core.setFailed('next.json ma niepełne/konfliktowe pola (wymagane: path, message, dokładnie jedno z content_plain/content_b64).');
              return;
            }

            let buf;
            if (content_b64) {
              try {
                buf = Buffer.from(content_b64, 'base64');
                if (buf.toString('base64') !== content_b64) throw new Error('base64 re-encode mismatch');
              } catch {
                core.setFailed('content_b64 w next.json nie jest prawidłowym Base64.');
                return;
              }
            } else {
              buf = Buffer.from(content_plain, 'utf8');
              content_b64 = buf.toString('base64');
            }

            if (sha256) {
              const calc = crypto.createHash('sha256').update(buf).digest('hex');
              if (calc.toLowerCase() !== String(sha256).toLowerCase()) {
                core.setFailed(`SHA-256 mismatch treści (expected ${sha256}, got ${calc}).`);
                return;
              }
            }

            // 2) Sprawdź, czy docelowy plik istnieje (SHA do update)
            let existingSha;
            const existing = await getFile(path);
            if (existing) existingSha = existing.sha;

            // 3) Commit docelowego pliku
            const putRes = await putFile(path, content_b64, message, existingSha);
            const commitSha = putRes?.commit?.sha || '(unknown)';
            core.info(`Committed ${path} @ ${commitSha}`);

            // 4) Zarchiwizuj next.json do history i usuń bieżący
            // utwórz katalog history (jeśli trzeba) – zrobimy to małym „touch” pliku .keep
            const keepPath = `${HISTORY_DIR}/.keep`;
            try {
              const keepFile = await getFile(keepPath);
              if (!keepFile) {
                await putFile(keepPath, Buffer.from('').toString('base64'), 'chore(agent): ensure history dir', undefined);
              }
            } catch (e) {
              core.warning(`Nie udało się utworzyć ${HISTORY_DIR}/.keep: ${e.message}`);
            }

            const stamp = new Date().toISOString().replace(/[:]/g,'').replace(/\..+$/,'');
            const archivedName = `${HISTORY_DIR}/next-${stamp}-${context.runId}.json`;
            await putFile(archivedName, nextFile.content, 'chore(agent): archive consumed next.json', undefined);
            await deleteFile(NEXT_PATH, 'chore(agent): consume next.json', nextFile.sha);

            // 5) (Opcjonalnie) dotknij dodatkowych ścieżek, by wymusić 01_deploy przez "paths"
            // Uwaga: jeśli commit dotyka themes/plugins/mu-plugins/wp-content/** to i tak odpali się 01.
            for (const extraPath of touch_paths) {
              const p = String(extraPath || '').trim();
              if (!p) continue;
              const content = Buffer.from(`// touch by orchestrator ${new Date().toISOString()}\n`).toString('base64');
              let extraSha;
              const ex = await getFile(p);
              if (ex) extraSha = ex.sha;
              await putFile(p, content, `chore(agent): touch ${p} to trigger pipelines`, extraSha);
              core.info(`Touched ${p}`);
            }

            // 6) (Opcjonalnie) explicite odpal 01→02→03
            if (dispatch) {
              const tokenKind = process.env['WTP_GITHUB_PAT'] ? 'WTP_GITHUB_PAT' : 'GITHUB_TOKEN';
              core.info(`Dispatching 01→02→03 via ${tokenKind}...`);
              const workflows = [
                '01_deploy.yml',
                '02_wpcli.yml',
                '03_snapshot.yml',
              ];
              for (const wf of workflows) {
                try {
                  await github.request('POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches', {
                    owner, repo, workflow_id: wf, ref: branch,
                    inputs: {}
                  });
                  core.info(`Dispatched ${wf}`);
                } catch (e) {
                  core.warning(`Dispatch ${wf} failed: ${e.message} (może wystarczy sam push)`);
                }
              }
            }

            await core.summary
              .addHeading('00 Orchestrator – executed')
              .addTable([
                [{data:'Field',header:true},{data:'Value',header:true}],
                ['plan', NEXT_PATH],
                ['committed', path],
                ['commit', commitSha],
                ['dispatch_01_02_03', String(dispatch)],
              ])
              .write();
