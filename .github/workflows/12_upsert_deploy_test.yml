name: 12_upsert_deploy_test
on:
  workflow_dispatch:
    inputs:
      target_path:
        description: "Ścieżka w repo i na serwerze (np. wp-content/themes/wtp-core-theme/functions.php)"
        required: true
        type: string
      commit_message:
        description: "Commit message"
        required: true
        type: string
      content_plain:
        description: "Nowa treść pliku (PLAIN)"
        required: true
        type: string

permissions:
  contents: write

concurrency:
  group: upsert-deploy-test
  cancel-in-progress: true

jobs:
  upsert_deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    env:
      HOST:   ${{ secrets.DEPLOY_HOST }}
      PORT:   ${{ secrets.DEPLOY_PORT }}
      USER:   ${{ secrets.DEPLOY_USER }}
      PASS:   ${{ secrets.DEPLOY_PASS }}
      TARGET: ${{ secrets.DEPLOY_TARGET }}
      RUN_ID: ${{ github.run_id }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Write file content into repo (safe JSON→file)
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const filePath = `${{ toJson(inputs.target_path) }}`;
            const contentJson = ${{ toJson(inputs.content_plain) }}; // JSON string, zachowuje newlines
            const content = JSON.parse(contentJson);
            fs.mkdirSync(path.dirname(filePath), { recursive: true });
            fs.writeFileSync(filePath, content, { encoding: 'utf8' });

      - name: Commit + push (rebase-safe)
        run: |
          set -euo pipefail
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add "${{ inputs.target_path }}"
          if git diff --staged --quiet; then
            echo "::notice::No repo changes for ${{ inputs.target_path }}"
          else
            git commit -m "${{ inputs.commit_message }}"
            BRANCH="${GITHUB_REF_NAME:-main}"
            git fetch origin "$BRANCH"
            git pull --rebase origin "$BRANCH" || { git rebase --continue || true; }
            git push origin "HEAD:$BRANCH"
          fi

      - name: Setup tools (sshpass)
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y sshpass

      - name: Prepare backup on server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host:     ${{ env.HOST }}
          username: ${{ env.USER }}
          password: ${{ env.PASS }}
          port:     ${{ env.PORT }}
          request_pty: true
          envs: TARGET,RUN_ID
          script: |
            set -euo pipefail
            TARGET="${TARGET:-/home/${USER}/domains/weektoppick.com/public_html}"
            FILE_REL="${{ inputs.target_path }}"
            FILE_ABS="${TARGET}/${FILE_REL}"
            OUT="${TARGET}/.wtp/state/ci_logs/auto_upsert_${RUN_ID}"
            mkdir -p "${OUT}" "$(dirname "${FILE_ABS}")"
            if [ -f "${FILE_ABS}" ]; then
              cp -a "${FILE_ABS}" "${FILE_ABS}.bak.${RUN_ID}"
              echo "${FILE_ABS}.bak.${RUN_ID}" > "${OUT}/backup_path.txt"
            fi

      - name: Upload file to server (scp)
        run: |
          set -euo pipefail
          SVRTGT="${TARGET:-/home/${USER}/domains/weektoppick.com/public_html}"
          DEST="${SVRTGT}/${{ inputs.target_path }}"
          sshpass -p "${PASS}" scp -P "${PORT}" -o StrictHostKeyChecking=no \
            "${{ inputs.target_path }}" \
            "${USER}@${HOST}:${DEST}"

      - name: Lint, purge cache, curl test, auto-rollback if broken
        uses: appleboy/ssh-action@v1.0.3
        with:
          host:     ${{ env.HOST }}
          username: ${{ env.USER }}
          password: ${{ env.PASS }}
          port:     ${{ env.PORT }}
          request_pty: true
          envs: TARGET,RUN_ID
          script: |
            set -euo pipefail
            TARGET="${TARGET:-/home/${USER}/domains/weektoppick.com/public_html}"
            FILE_REL="${{ inputs.target_path }}"
            FILE_ABS="${TARGET}/${FILE_REL}"
            OUT="${TARGET}/.wtp/state/ci_logs/auto_upsert_${RUN_ID}"
            mkdir -p "${OUT}"

            # Lint (jeśli PHP)
            case "$FILE_ABS" in
              *.php) php -l "${FILE_ABS}" > "${OUT}/php_lint_after.txt" 2>&1 || true ;;
            esac

            # Purge LS cache (jeśli plugin aktywny)
            if command -v wp >/dev/null 2>&1; then
              wp plugin is-active litespeed-cache && wp litespeed-purge all || true
            fi

            # Health-check frontu
            HOMEURL="$(php -r 'include "wp-config.php"; include "wp-load.php"; echo get_option("home");' 2>/dev/null || true)"
            HOMEURL="${HOMEURL:-https://weektoppick.com}"
            STATUS=$(curl -ks -o /dev/null -w "%{http_code}" "$HOMEURL" || echo 000)
            BODY="$(curl -ks "$HOMEURL" || true)"
            echo "$STATUS" > "${OUT}/http_status_after.txt"
            printf "%s" "$BODY" > "${OUT}/home_after.html"
            echo "$(printf "%s" "$BODY" | wc -c)" > "${OUT}/home_after_size.txt"

            SIZE=$(cat "${OUT}/home_after_size.txt" || echo 0)
            if [ "$STATUS" != "200" ] || [ "${SIZE:-0}" -lt 600 ]; then
              echo "[WARN] unhealthy after upsert (status=$STATUS size=$SIZE) -> rollback" | tee "${OUT}/action.txt"
              if [ -f "${FILE_ABS}.bak.${RUN_ID}" ]; then
                cp -a "${FILE_ABS}.bak.${RUN_ID}" "${FILE_ABS}"
                echo "rolled_back" >> "${OUT}/action.txt"
                # drugi curl po rollbacku
                STATUS2=$(curl -ks -o /dev/null -w "%{http_code}" "$HOMEURL" || echo 000)
                echo "$STATUS2" > "${OUT}/http_status_after_rollback.txt"
              else
                echo "no_backup_to_restore" >> "${OUT}/action.txt"
              fi
            else
              echo "[OK] healthy after upsert (status=$STATUS size=$SIZE)" | tee "${OUT}/action.txt"
            fi

            # Logi błędów (ostatnie 200 linii)
            for LOG in error_log logs/error_log wp-content/debug.log; do
              [ -f "$LOG" ] && tail -n 200 "$LOG" > "${OUT}/$(echo "$LOG" | tr '/' '_')"
            done

            # Metadane
            echo "${FILE_REL}" > "${OUT}/target_path.txt"

      - name: Pull & publish report (RO + latest/auto-upsert)
        if: always()
        run: |
          set -euo pipefail
          mkdir -p "_ci_logs/${RUN_ID}/auto_upsert"
          SVRTGT="${TARGET:-/home/${USER}/domains/weektoppick.com/public_html}"
          sshpass -p "${PASS}" scp -P "${PORT}" -o StrictHostKeyChecking=no -r \
            "${USER}@${HOST}:${SVRTGT}/.wtp/state/ci_logs/auto_upsert_${RUN_ID}" \
            "_ci_logs/${RUN_ID}/auto_upsert/" || true

          RO_DIR=".wtp/state/ro/public/${RUN_ID}/auto-upsert"
          RO_LATEST=".wtp/state/ro/public/latest/auto-upsert"
          mkdir -p "${RO_DIR}" "${RO_LATEST}"
          cp -a "_ci_logs/${RUN_ID}/auto_upsert/." "${RO_DIR}/" || true
          rm -rf "${RO_LATEST}"; mkdir -p "${RO_LATEST}"
          cp -a "${RO_DIR}/." "${RO_LATEST}/" || true

          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add -A
          if git diff --staged --quiet; then
            echo "::notice::Nothing to commit."; exit 0
          fi
          git commit -m "auto-upsert report ${RUN_ID}"
          BRANCH="${GITHUB_REF_NAME:-main}"
          git fetch origin "$BRANCH"
          git pull --rebase origin "$BRANCH" || { git rebase --continue || true; }
          git push origin "HEAD:$BRANCH"
