name: 03_repo_audit_full (read-only, complete)

on:
  workflow_dispatch: {}
  workflow_run:
    workflows: ["03_repo_snapshot"]
    types: [completed]

permissions:
  contents: write

concurrency:
  group: repo-audit-full
  cancel-in-progress: true

jobs:
  audit:
    runs-on: ubuntu-latest
    timeout-minutes: 20

    env:
      RUN_ID: ${{ github.run_id }}

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Install deps
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          pip install pyyaml

      - name: Build extended repo audit (indexes, hooks, symbols, metas)
        run: |
          set -euo pipefail
          OUT_DIR="_out/repo_audit/${RUN_ID}"
          mkdir -p "$OUT_DIR"

          # 1) Pełne listy plików
          git ls-files -co --exclude-standard > "${OUT_DIR}/filelist.txt"
          ls -laR > "${OUT_DIR}/tree.txt"

          # 2) Indeks workflowów
          python - << 'PY'
          import os, glob, json, yaml, pathlib
          RUN_ID = os.environ["RUN_ID"]
          OUT = pathlib.Path(f"_out/repo_audit/{RUN_ID}")
          OUT.mkdir(parents=True, exist_ok=True)
          items=[]
          for p in sorted(glob.glob(".github/workflows/*.yml")):
              try:
                  with open(p,"r",encoding="utf-8") as f:
                      y = yaml.safe_load(f) or {}
              except Exception as e:
                  y = {"_parse_error": str(e)}
              items.append({
                  "file": pathlib.Path(p).name,
                  "name": y.get("name", pathlib.Path(p).name),
                  "on": y.get("on"),
                  "jobs": list((y.get("jobs") or {}).keys())
              })
          (OUT/"workflows.json").write_text(json.dumps(items, ensure_ascii=False, indent=2), encoding="utf-8")
          md = ["# Workflows index","","(auto)"]
          for w in items:
              md.append(f"## {w['name']} ({w['file']})")
              md.append(f"- Triggers: `{w['on']}`")
              md.append(f"- Jobs: {', '.join(w['jobs']) if w['jobs'] else '-'}")
              md.append("")
          (OUT/"workflows.md").write_text("\n".join(md)+"\n", encoding="utf-8")
          PY

          # 3) Hooks / symbols / includes
          python - << 'PY'
          import os, re, json, pathlib
          RUN_ID = os.environ["RUN_ID"]
          OUT = pathlib.Path(f"_out/repo_audit/{RUN_ID}")
          OUT.mkdir(parents=True, exist_ok=True)

          hooks = []
          symbols = {"functions":[], "classes":[]}
          includes = []

          php_like = re.compile(r'.*\.(php|inc)$', re.I)
          re_add_action = re.compile(r'add_action\s*\(\s*[\'"]([^\'"]+)[\'"]\s*,\s*([^\)]+)\)', re.I)
          re_add_filter = re.compile(r'add_filter\s*\(\s*[\'"]([^\'"]+)[\'"]\s*,\s*([^\)]+)\)', re.I)
          re_fn = re.compile(r'function\s+([a-zA-Z0-9_]+)\s*\(', re.I)
          re_class = re.compile(r'class\s+([a-zA-Z0-9_]+)\s', re.I)
          re_inc = re.compile(r'^\s*(require|require_once|include|include_once)\s*\(?\s*[\'"]([^\'"]+)[\'"]', re.I)

          for root,dirs,files in os.walk("."):
              for fn in files:
                  p = os.path.join(root,fn)
                  if not php_like.match(p):
                      continue
                  try:
                      txt = open(p, "r", encoding="utf-8", errors="ignore").read()
                  except:
                      continue
                  for m in re_add_action.finditer(txt):
                      hooks.append({"type":"action","hook":m.group(1),"cb":m.group(2).strip(),"file":p})
                  for m in re_add_filter.finditer(txt):
                      hooks.append({"type":"filter","hook":m.group(1),"cb":m.group(2).strip(),"file":p})
                  for m in re_fn.finditer(txt):
                      symbols["functions"].append({"name":m.group(1),"file":p})
                  for m in re_class.finditer(txt):
                      symbols["classes"].append({"name":m.group(1),"file":p})
                  for line in txt.splitlines():
                      mi = re_inc.search(line)
                      if mi:
                          includes.append({"file":p,"stmt":mi.group(1),"target":mi.group(2)})

          (OUT/"hooks.json").write_text(json.dumps(hooks, ensure_ascii=False, indent=2), encoding="utf-8")
          (OUT/"symbol_index.json").write_text(json.dumps(symbols, ensure_ascii=False, indent=2), encoding="utf-8")
          (OUT/"includes_index.json").write_text(json.dumps(includes, ensure_ascii=False, indent=2), encoding="utf-8")
          PY

          # 4) Metadane pluginów + MU
          python - << 'PY'
          import os, json, pathlib, re
          RUN_ID = os.environ["RUN_ID"]
          OUT = pathlib.Path(f"_out/repo_audit/{RUN_ID}")
          OUT.mkdir(parents=True, exist_ok=True)

          def scan_plugins(root):
              rootp = pathlib.Path(root)
              out=[]
              if not rootp.exists(): return out
              for p in sorted(rootp.glob("*")):
                  if p.is_dir():
                      slug=p.name
                      headers={}
                      for mf in list(p.glob("*.php"))[:10]:
                          try:
                              txt=mf.read_text(encoding="utf-8", errors="ignore")
                              m=re.search(r"Plugin\s*Name\s*:\s*(.+)", txt)
                              if m: headers["PluginName"]=m.group(1).strip()
                              m=re.search(r"Version\s*:\s*([0-9A-Za-z\.\-\_]+)", txt)
                              if m: headers["Version"]=m.group(1).strip()
                              m=re.search(r"Description\s*:\s*(.+)", txt)
                              if m: headers["Description"]=m.group(1).strip()
                          except: pass
                      out.append({"slug":slug,"headers":headers})
              return out

          mu = scan_plugins("wp-content/mu-plugins")
          norm = scan_plugins("wp-content/plugins")

          (OUT/"mu_meta.json").write_text(json.dumps(mu, ensure_ascii=False, indent=2), encoding="utf-8")
          (OUT/"plugin_meta.json").write_text(json.dumps(norm, ensure_ascii=False, indent=2), encoding="utf-8")
          PY

          # 5) REPO_AUDIT.md + agregat
          python - << 'PY'
          import os, json, pathlib
          RUN_ID = os.environ["RUN_ID"]
          OUT = pathlib.Path(f"_out/repo_audit/{RUN_ID}")
          OUT.mkdir(parents=True, exist_ok=True)

          L=[]
          L.append("# REPO AUDIT (extended)")
          L.append("")
          L.append("- generated: `filelist.txt`, `tree.txt`, `workflows.*`, `hooks.json`, `symbol_index.json`, `includes_index.json`, `plugin_meta.json`, `mu_meta.json`")
          (OUT/"REPO_AUDIT.md").write_text("\n".join(L)+"\n", encoding="utf-8")

          agg = {
            "run_id": RUN_ID,
            "files_index": "filelist.txt",
            "tree": "tree.txt",
            "workflows": "workflows.json",
            "hooks": "hooks.json",
            "symbols": "symbol_index.json",
            "includes": "includes_index.json",
            "mu_meta": "mu_meta.json",
            "plugin_meta": "plugin_meta.json"
          }
          (OUT/"repo-audit.json").write_text(json.dumps(agg, ensure_ascii=False, indent=2), encoding="utf-8")
          PY

      - name: Publish to .wtp/state (RUN-ID and latest)
        run: |
          set -euo pipefail
          RUN_DIR=".wtp/state/ro/public/${RUN_ID}"
          LATEST=".wtp/state/ro/public/latest"
          SRC="_out/repo_audit/${RUN_ID}"

          mkdir -p "${RUN_DIR}/repo" "${LATEST}/repo"

          # RUN-ID
          cp -f "${SRC}/filelist.txt"            "${RUN_DIR}/filelist.txt"
          cp -f "${SRC}/tree.txt"                "${RUN_DIR}/tree.txt"
          cp -f "${SRC}/workflows.json"          "${RUN_DIR}/workflows.json"
          cp -f "${SRC}/workflows.md"            "${RUN_DIR}/workflows.md"
          cp -f "${SRC}/hooks.json"              "${RUN_DIR}/repo/hooks.json"
          cp -f "${SRC}/symbol_index.json"       "${RUN_DIR}/repo/symbol_index.json"
          cp -f "${SRC}/includes_index.json"     "${RUN_DIR}/repo/includes_index.json"
          cp -f "${SRC}/plugin_meta.json"        "${RUN_DIR}/repo/plugin_meta.json"
          cp -f "${SRC}/mu_meta.json"            "${RUN_DIR}/repo/mu_meta.json"
          cp -f "${SRC}/repo-audit.json"         "${RUN_DIR}/repo/repo-audit.json"
          cp -f "${SRC}/REPO_AUDIT.md"           "${RUN_DIR}/repo/REPO_AUDIT.md"

          # LATEST
          cp -f "${RUN_DIR}/filelist.txt"        "${LATEST}/filelist.txt"
          cp -f "${RUN_DIR}/tree.txt"            "${LATEST}/tree.txt"
          cp -f "${RUN_DIR}/workflows.json"      "${LATEST}/workflows.json"
          cp -f "${RUN_DIR}/workflows.md"        "${LATEST}/workflows.md"
          cp -f "${RUN_DIR}/repo/hooks.json"     "${LATEST}/repo/hooks.json"
          cp -f "${RUN_DIR}/repo/symbol_index.json"  "${LATEST}/repo/symbol_index.json"
          cp -f "${RUN_DIR}/repo/includes_index.json" "${LATEST}/repo/includes_index.json"
          cp -f "${RUN_DIR}/repo/plugin_meta.json"    "${LATEST}/repo/plugin_meta.json"
          cp -f "${RUN_DIR}/repo/mu_meta.json"        "${LATEST}/repo/mu_meta.json"
          cp -f "${RUN_DIR}/repo/repo-audit.json"     "${LATEST}/repo/repo-audit.json"
          cp -f "${RUN_DIR}/repo/REPO_AUDIT.md"       "${LATEST}/repo/REPO_AUDIT.md"

          # Jeśli snapshot/architektura brakują w latest — spróbuj dociągnąć z najnowszego RUN-u snapshotu
          for f in REPO_ARCHITECTURE.md repo-snapshot.json; do
            if [ ! -f "${LATEST}/repo/${f}" ]; then
              CAND=$(ls -1dt .wtp/state/ro/public/*/repo 2>/dev/null | head -n1 || true)
              if [ -n "${CAND:-}" ] && [ -f "${CAND}/${f}" ]; then
                cp -f "${CAND}/${f}" "${LATEST}/repo/${f}" || true
              fi
            fi
          done

          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add -A
          if git diff --staged --quiet; then
            echo "::notice::Nothing to commit."
          else
            git commit -m "repo audit (extended) ${RUN_ID}"
            BRANCH="${GITHUB_REF_NAME:-main}"
            git branch --show-current >/dev/null 2>&1 || git checkout -B "$BRANCH"
            for i in 1 2 3; do
              git fetch origin "$BRANCH"
              git pull --rebase origin "$BRANCH" || { git rebase --continue || true; }
              if git push origin "HEAD:$BRANCH"; then
                echo "Notice: Pushed (attempt $i)"; exit 0
              fi
              sleep 2
            done
            echo "::error::Push failed after 3 attempts"; exit 1
          fi
